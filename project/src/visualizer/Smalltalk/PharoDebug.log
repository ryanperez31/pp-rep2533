THERE_BE_DRAGONS_HERE
Could not resolve: BaselineOfJSON [BaselineOfJSON] in /Users/ryanperez/Documents/Pharo/images/Visualizer/pharo-local/package-cache https://github.com/SvenVC/NeoJSON.git[master]
23 October 2023 11:00:48.528986 pm

VM: Mac OS - arm64 - 1000 - CoInterpreter VMMaker-tonel.1 uuid: 902dd483-c0c4-0d00-86f2-0f880df24b96 Oct 23 2023
StackToRegisterMappingCogit VMMaker-tonel.1 uuid: 902dd483-c0c4-0d00-86f2-0f880df24b96 Oct 23 2023
v10.0.8 - Commit: b323c5fb - Date: 2023-10-20 16:02:07 -0400

Image: Pharo11.0.0 [Build information: Pharo-11.0.0+build.710.sha.ea28d8552cac85a7ce1e9c34ab1e7bd45f7b9910 (64 Bit)]

MetacelloFetchingMCSpecLoader(MetacelloCommonMCSpecLoader)>>retryingResolvePackageSpecReferences:gofer:
	Receiver: a MetacelloFetchingMCSpecLoader(explicit load : BaselineOfJSON)
	Arguments and temporary variables: 
		packageSpec: 	spec 
	name: 'BaselineOfJSON';
	repository: 'github://SvenVC/N[..]
		gofer: 	a MetacelloGofer
		references: 	#()
		retryCount: 	3
		repositoryError: 	nil
	Receiver's instance variables: 
		spec: 	spec 
	name: 'BaselineOfJSON';
	repository: 'github://SvenVC/NeoJSON/[..]
		operator: 	nil
		loaderPolicy: 	a MetacelloLoaderPolicy
		disablePackageCache: 	false


[ 
      | references nearestReference cachedReference externalReference mcVersion loadedVersionInfos |
      cachedReference := nil.
      packageSpec
        searchCacheRepositoryForPackage: [ 
          "check to see if mcz file is already in cacheRepository"
          cachedReference := self
            resolvePackageSpec: packageSpec
            cachedGofer: self loaderPolicy cacheGofer.
          (cachedReference ~~ nil and: [ packageSpec getFile ~~ nil ])
            ifTrue: [ 
              cachedReference name = packageSpec file
                ifTrue: [ 
                  "exact match between packageSpec file and cache"
                  ^ self
                    scheduleFetchFor: packageSpec
                    cachedReference: cachedReference ] ] ].
      references := self
        retryingResolvePackageSpecReferences: packageSpec
        gofer: gofer.	"look up mcz file"
      nearestReference := references last asMetacelloCachingResolvedReference.
      (cachedReference ~~ nil
        and: [ cachedReference name = nearestReference name ])
        ifTrue: [ 
          "latest reference in repository matches cachedReference ... "
          ^ self
            scheduleFetchFor: packageSpec
            nearestReference: nearestReference ].
      (self ignoreImage not
        and: [ (loadedVersionInfos := self ancestorsFor: packageSpec) ~~ nil ])
        ifTrue: [ 
          "If the mcz is already loaded into the image, no need to copy"
          loadedVersionInfos
            do: [ :info | 
              info name = nearestReference name
                ifTrue: [ 
                  | spc |
                  spc := packageSpec copy.
                  spc file: info name.
                  (MetacelloIgnorePackageLoaded signal: spc)
                    ifFalse: [ ^ self ] ] ] ].
      externalReference := (references
        select: [ :ref | ref name = nearestReference name ]) first
        asMetacelloCachingResolvedReference.
      self repositoryMap
        at: externalReference name
        put: externalReference repository.
      (self
        resolveDependencies: externalReference
        nearest: nearestReference
        into: (OrderedCollection with: nearestReference))
        do: [ :reference | 
          | pSpec l |
          mcVersion := reference version.
          (l := (GoferVersionReference name: reference name)
            resolveAllWith: self loaderPolicy cacheGofer) isEmpty
            ifTrue: [ 
              self cacheRepository storeVersion: mcVersion.
              reference == nearestReference
                ifTrue: [ pSpec := packageSpec ]
                ifFalse: [ 
                  pSpec := packageSpec project packageSpec.
                  pSpec name: mcVersion package name ].
              self loadData
                addVersion: mcVersion
                versionInfo: mcVersion info
                resolvedReference: reference
                packageSpec: pSpec ] ].
      self scheduleFetchFor: packageSpec externalReference: externalReference ] in MetacelloFetchingMCSpecLoader>>linearLoadPackageSpec:gofer:
	Receiver: a MetacelloFetchingMCSpecLoader(explicit load : BaselineOfJSON)
	Arguments and temporary variables: 
		packageSpec: 	spec 
	name: 'BaselineOfJSON';
	repository: 'github://SvenVC/N[..]
		gofer: 	a MetacelloGofer
		cachedReference: 	nil
		mcVersion: 	nil
		references: 	nil
		nearestReference: 	nil
		externalReference: 	nil
		loadedVersionInfos: 	nil
	Receiver's instance variables: 
		spec: 	spec 
	name: 'BaselineOfJSON';
	repository: 'github://SvenVC/NeoJSON/[..]
		operator: 	nil
		loaderPolicy: 	a MetacelloLoaderPolicy
		disablePackageCache: 	false


[:bar |
            bar value: 1.
            aBlock value.
            bar value: 2 ] in IceMetacelloPharoPlatform(MetacelloPharoCommonPlatform)>>do:displaying:
	Receiver: an IceMetacelloPharoPlatform
	Arguments and temporary variables: 
		aBlock: 	[ 
      | references nearestReference cachedReference externalRefe[..]
		aString: 	'Fetching BaselineOfJSON'
		bar: 	a Job
	Receiver's instance variables: 
		bypassProgressBars: 	false
		bypassGoferLoadUpdateCategories: 	false


FullBlockClosure(BlockClosure)>>cull:
	Receiver: [:bar |
            bar value: 1.
            aBlock value.
            bar value: 2 ]
	Arguments and temporary variables: 
		anArg: 	a Job
	Receiver's instance variables: 
		outerContext: 	IceMetacelloPharoPlatform(MetacelloPharoCommonPlatform)>>do:d[..]
		compiledBlock: 	a CompiledBlock: [:bar |
            bar value: 1.
         [..]
		numArgs: 	1
		receiver: 	an IceMetacelloPharoPlatform


[ ^ block cull: self ] in [ self prepareForRunning.
	  CurrentJob value: self during: [ ^ block cull: self ] ] in Job>>run
	Receiver: a Job
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		block: 	[:bar |
            bar value: 1.
            aBlock value.
        [..]
		currentValue: 	1
		min: 	0
		max: 	2
		title: 	'Fetching BaselineOfJSON'
		children: 	an OrderedCollection()
		isRunning: 	true
		parent: 	nil
		process: 	a Process in nil
		owner: 	a MorphicUIManager


[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in CurrentJob(DynamicVariable)>>value:during:
	Receiver: a CurrentJob
	Arguments and temporary variables: 
		anObject: 	a Job
		aBlock: 	[ ^ block cull: self ]
		activeProcess: 	a Process in nil
		oldValue: 	nil
	Receiver's instance variables: 
		index: 	2


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ]
	Arguments and temporary variables: 
		aBlock: 	[
			activeProcess
				psValueAt: index
				put: oldValue ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	CurrentJob(DynamicVariable)>>value:during:
		compiledBlock: 	a CompiledBlock: [ activeProcess
			psValueAt: index
			put:[..]
		numArgs: 	0
		receiver: 	a CurrentJob


CurrentJob(DynamicVariable)>>value:during:
	Receiver: a CurrentJob
	Arguments and temporary variables: 
		anObject: 	a Job
		aBlock: 	[ ^ block cull: self ]
		activeProcess: 	a Process in nil
		oldValue: 	nil
	Receiver's instance variables: 
		index: 	2


CurrentJob class(DynamicVariable class)>>value:during:
	Receiver: CurrentJob
	Arguments and temporary variables: 
		anObject: 	a Job
		aBlock: 	[ ^ block cull: self ]
	Receiver's instance variables: 
		superclass: 	DynamicVariable
		methodDict: 	a MethodDictionary()
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		commentSourcePointer: 	nil
		subclasses: 	nil
		name: 	#CurrentJob
		classPool: 	nil
		sharedPools: 	nil
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Jobs-Base'
		soleInstance: 	a CurrentJob


[ self prepareForRunning.
	  CurrentJob value: self during: [ ^ block cull: self ] ] in Job>>run
	Receiver: a Job
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		block: 	[:bar |
            bar value: 1.
            aBlock value.
        [..]
		currentValue: 	1
		min: 	0
		max: 	2
		title: 	'Fetching BaselineOfJSON'
		children: 	an OrderedCollection()
		isRunning: 	true
		parent: 	nil
		process: 	a Process in nil
		owner: 	a MorphicUIManager


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ self prepareForRunning.
	  CurrentJob value: self during: [ ^ block cull: self ] ]
	Arguments and temporary variables: 
		aBlock: 	[ self cleanupAfterRunning ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	Job>>run
		compiledBlock: 	a CompiledBlock: [ self prepareForRunning.
	  CurrentJob val[..]
		numArgs: 	0
		receiver: 	a Job


Job>>run
	Receiver: a Job
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		block: 	[:bar |
            bar value: 1.
            aBlock value.
        [..]
		currentValue: 	1
		min: 	0
		max: 	2
		title: 	'Fetching BaselineOfJSON'
		children: 	an OrderedCollection()
		isRunning: 	true
		parent: 	nil
		process: 	a Process in nil
		owner: 	a MorphicUIManager


MorphicUIManager(UIManager)>>displayProgress:from:to:during:
	Receiver: a MorphicUIManager
	Arguments and temporary variables: 
		titleString: 	'Fetching BaselineOfJSON'
		minVal: 	0
		maxVal: 	2
		workBlock: 	[:bar |
            bar value: 1.
            aBlock value.
    [..]
	Receiver's instance variables: 
		activeTranscript: 	nil


ByteString(String)>>displayProgressFrom:to:during:
	Receiver: 'Fetching BaselineOfJSON'
	Arguments and temporary variables: 
		minVal: 	0
		maxVal: 	2
		workBlock: 	[:bar |
            bar value: 1.
            aBlock value.
    [..]
	Receiver's instance variables: 
'Fetching BaselineOfJSON'

IceMetacelloPharoPlatform(MetacelloPharoCommonPlatform)>>do:displaying:
	Receiver: an IceMetacelloPharoPlatform
	Arguments and temporary variables: 
		aBlock: 	[ 
      | references nearestReference cachedReference externalRefe[..]
		aString: 	'Fetching BaselineOfJSON'
	Receiver's instance variables: 
		bypassProgressBars: 	false
		bypassGoferLoadUpdateCategories: 	false


MetacelloFetchingMCSpecLoader>>linearLoadPackageSpec:gofer:
	Receiver: a MetacelloFetchingMCSpecLoader(explicit load : BaselineOfJSON)
	Arguments and temporary variables: 
		packageSpec: 	spec 
	name: 'BaselineOfJSON';
	repository: 'github://SvenVC/N[..]
		gofer: 	a MetacelloGofer
	Receiver's instance variables: 
		spec: 	spec 
	name: 'BaselineOfJSON';
	repository: 'github://SvenVC/NeoJSON/[..]
		operator: 	nil
		loaderPolicy: 	a MetacelloLoaderPolicy
		disablePackageCache: 	false


MetacelloPackageSpec>>loadUsing:gofer:
	Receiver: spec 
	name: 'BaselineOfJSON';
	repository: 'github://SvenVC/NeoJSON/repository'.
	Arguments and temporary variables: 
		aLoader: 	a MetacelloFetchingMCSpecLoader(explicit load : BaselineOfJSON)
		gofer: 	a MetacelloGofer
	Receiver's instance variables: 
		project: 	<<error during printing>>

[:pkg | pkg loadUsing: self gofer: gofer ] in MetacelloFetchingMCSpecLoader(MetacelloCommonMCSpecLoader)>>linearLoadPackageSpecs:repositories:
	Receiver: a MetacelloFetchingMCSpecLoader(explicit load : BaselineOfJSON)
	Arguments and temporary variables: 
		packageSpecs: 	an Array(spec 
	name: 'BaselineOfJSON';
	repository: 'github:[..]
		repositories: 	an OrderedCollection(an IceMetacelloRepositoryAdapter)
		gofer: 	a MetacelloGofer
		pkg: 	spec 
	name: 'BaselineOfJSON';
	repository: 'github://SvenVC/NeoJSON/r[..]
	Receiver's instance variables: 
		spec: 	spec 
	name: 'BaselineOfJSON';
	repository: 'github://SvenVC/NeoJSON/[..]
		operator: 	nil
		loaderPolicy: 	a MetacelloLoaderPolicy
		disablePackageCache: 	false


Array(SequenceableCollection)>>do:
	Receiver: an Array(spec 
	name: 'BaselineOfJSON';
	repository: 'github://SvenVC/NeoJSON/reposito[..]
	Arguments and temporary variables: 
		aBlock: 	[:pkg | pkg loadUsing: self gofer: gofer ]
		index: 	1
	Receiver's instance variables: 
an Array(spec 
	name: 'BaselineOfJSON';
	repository: 'github://SvenVC/NeoJSON/reposito[..]

MetacelloFetchingMCSpecLoader(MetacelloCommonMCSpecLoader)>>linearLoadPackageSpecs:repositories:
	Receiver: a MetacelloFetchingMCSpecLoader(explicit load : BaselineOfJSON)
	Arguments and temporary variables: 
		packageSpecs: 	an Array(spec 
	name: 'BaselineOfJSON';
	repository: 'github:[..]
		repositories: 	an OrderedCollection(an IceMetacelloRepositoryAdapter)
		gofer: 	a MetacelloGofer
	Receiver's instance variables: 
		spec: 	spec 
	name: 'BaselineOfJSON';
	repository: 'github://SvenVC/NeoJSON/[..]
		operator: 	nil
		loaderPolicy: 	a MetacelloLoaderPolicy
		disablePackageCache: 	false


[ super linearLoadPackageSpecs: packageSpecs repositories: repositories ] in MetacelloFetchingMCSpecLoader>>explicitLoadPackageSpecs:repositories:
	Receiver: a MetacelloFetchingMCSpecLoader(explicit load : BaselineOfJSON)
	Arguments and temporary variables: 
		packageSpecs: 	an Array(spec 
	name: 'BaselineOfJSON';
	repository: 'github:[..]
		repositories: 	an OrderedCollection(an IceMetacelloRepositoryAdapter)
		directive: 	nil
	Receiver's instance variables: 
		spec: 	spec 
	name: 'BaselineOfJSON';
	repository: 'github://SvenVC/NeoJSON/[..]
		operator: 	nil
		loaderPolicy: 	a MetacelloLoaderPolicy
		disablePackageCache: 	false


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ super linearLoadPackageSpecs: packageSpecs repositories: repositories ]
	Arguments and temporary variables: 
		aBlock: 	[ loadDirective := oldRoot ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	MetacelloFetchingMCSpecLoader>>explicitLoadPackageSpecs:repos[..]
		compiledBlock: 	a CompiledBlock: [ super linearLoadPackageSpecs: packageSpec[..]
		numArgs: 	0
		receiver: 	a MetacelloFetchingMCSpecLoader(explicit load : BaselineOfJSON)


MetacelloLoaderPolicy>>pushLoadDirective:during:
	Receiver: a MetacelloLoaderPolicy
	Arguments and temporary variables: 
		aLoaderDirective: 	explicit load : BaselineOfJSON
		aBlock: 	[ super linearLoadPackageSpecs: packageSpecs repositories: reposito[..]
		oldRoot: 	linear load : 
	explicit load : BaselineOfJSON
	Receiver's instance variables: 
		overrideRepositories: 	nil
		repositoryMap: 	a Dictionary()
		ensuredMap: 	a Dictionary()
		cacheRepository: 	a MCDictionaryRepository(cache)
		cacheGofer: 	a Gofer
		ignoreImage: 	false
		loadData: 	nil
		loadDirective: 	explicit load : BaselineOfJSON
		silently: 	nil


MetacelloLoaderPolicy>>pushExplicitLoadDirectivesDuring:for:
	Receiver: a MetacelloLoaderPolicy
	Arguments and temporary variables: 
		aBlock: 	[ super linearLoadPackageSpecs: packageSpecs repositories: reposito[..]
		aLoader: 	a MetacelloFetchingMCSpecLoader(explicit load : BaselineOfJSON)
		directive: 	explicit load : BaselineOfJSON
	Receiver's instance variables: 
		overrideRepositories: 	nil
		repositoryMap: 	a Dictionary()
		ensuredMap: 	a Dictionary()
		cacheRepository: 	a MCDictionaryRepository(cache)
		cacheGofer: 	a Gofer
		ignoreImage: 	false
		loadData: 	nil
		loadDirective: 	explicit load : BaselineOfJSON
		silently: 	nil


MetacelloFetchingMCSpecLoader>>explicitLoadPackageSpecs:repositories:
	Receiver: a MetacelloFetchingMCSpecLoader(explicit load : BaselineOfJSON)
	Arguments and temporary variables: 
		packageSpecs: 	an Array(spec 
	name: 'BaselineOfJSON';
	repository: 'github:[..]
		repositories: 	an OrderedCollection(an IceMetacelloRepositoryAdapter)
		directive: 	nil
	Receiver's instance variables: 
		spec: 	spec 
	name: 'BaselineOfJSON';
	repository: 'github://SvenVC/NeoJSON/[..]
		operator: 	nil
		loaderPolicy: 	a MetacelloLoaderPolicy
		disablePackageCache: 	false


MetacelloPackageSpec>>explicitLoadUsing:
	Receiver: spec 
	name: 'BaselineOfJSON';
	repository: 'github://SvenVC/NeoJSON/repository'.
	Arguments and temporary variables: 
		mcLoader: 	a MetacelloLoadingMCSpecLoader
		wc: 	nil
		fetchingSpecLoader: 	a MetacelloFetchingMCSpecLoader(explicit load : Baselin[..]
	Receiver's instance variables: 
		project: 	<<error during printing>>

MetacelloPackageSpec>>load
	Receiver: spec 
	name: 'BaselineOfJSON';
	repository: 'github://SvenVC/NeoJSON/repository'.
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		project: 	<<error during printing>>

[ spec projectPackage load ] in MetacelloScriptEngine>>getBaselineUnconditionalLoad:
	Receiver: a MetacelloScriptEngine
	Arguments and temporary variables: 
		unconditionalLoad: 	true
		spec: 	spec 
	name: 'JSON';
	repository: 'github://SvenVC/NeoJSON/repository'.
	Receiver's instance variables: 
		root: 	nil
		projectSpec: 	spec 
	name: 'JSON';
	repository: 'github://SvenVC/NeoJSON/rep[..]
		options: 	a Dictionary()


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [ spec projectPackage load ]
	Arguments and temporary variables: 
		exception: 	MetacelloIgnorePackageLoaded
		handlerAction: 	[ :ex | 
      "see https://github.com/dalehenrich/metacello[..]
	Receiver's instance variables: 
		outerContext: 	MetacelloScriptEngine>>getBaselineUnconditionalLoad:
		compiledBlock: 	a CompiledBlock: [ spec projectPackage load ]
		numArgs: 	0
		receiver: 	a MetacelloScriptEngine


MetacelloScriptEngine>>getBaselineUnconditionalLoad:
	Receiver: a MetacelloScriptEngine
	Arguments and temporary variables: 
		unconditionalLoad: 	true
		spec: 	spec 
	name: 'JSON';
	repository: 'github://SvenVC/NeoJSON/repository'.
	Receiver's instance variables: 
		root: 	nil
		projectSpec: 	spec 
	name: 'JSON';
	repository: 'github://SvenVC/NeoJSON/rep[..]
		options: 	a Dictionary()


MetacelloScriptEngine>>getBaselineProjectUnconditionalLoad:
	Receiver: a MetacelloScriptEngine
	Arguments and temporary variables: 
		unconditionalLoad: 	true
		project: 	nil
	Receiver's instance variables: 
		root: 	nil
		projectSpec: 	spec 
	name: 'JSON';
	repository: 'github://SvenVC/NeoJSON/rep[..]
		options: 	a Dictionary()


MetacelloMCBaselineProject>>projectForScriptEngine:unconditionalLoad:
	Receiver: <<error during printing>>
	Arguments and temporary variables: 
		aMetacelloScriptEngine: 	a MetacelloScriptEngine
		aBool: 	false
	Receiver's instance variables: 
		versionMap: 	nil
		symbolicVersionMap: 	nil
		errorMap: 	nil
		loader: 	nil
		loaderClass: 	MetacelloLoadingMCSpecLoader
		loadType: 	nil
		configuration: 	<<error during printing>>

MetacelloMCBaselineProject(MetacelloProject)>>projectForScriptEngine:
	Receiver: <<error during printing>>
	Arguments and temporary variables: 
		aMetacelloScriptEngine: 	a MetacelloScriptEngine
	Receiver's instance variables: 
		versionMap: 	nil
		symbolicVersionMap: 	nil
		errorMap: 	nil
		loader: 	nil
		loaderClass: 	MetacelloLoadingMCSpecLoader
		loadType: 	nil
		configuration: 	<<error during printing>>

MetacelloMCBaselineOfProjectSpec(MetacelloMCProjectSpec)>>versionForScriptEngine:
	Receiver: spec 
	name: 'JSON';
	repository: 'github://SvenVC/NeoJSON/repository'.
	Arguments and temporary variables: 
<<error during printing>>
	Receiver's instance variables: 
		project: 	<<error during printing>>

[ 
          | version loadedSpec |
          self setDefaultsAndValidateProjectSpec.
          [ loadedSpec := (self lookupProjectSpecFor: self projectSpec) copy ]
            on: MetacelloAllowProjectDowngrade , MetacelloAllowProjectUpgrade
            do: [ :ex | ex handleOnDownGrade: onDownGradeBlock onUpgrade: onUpgradeBlock ].
          version := loadedSpec versionForScriptEngine: self.
          self
            root:
              (required isEmpty
                ifTrue: [ version load ]
                ifFalse: [ version load: required ]) loadDirective.
          loadedSpec loads: required.
          MetacelloProjectRegistration
            registrationForProjectSpec: loadedSpec
            ifAbsent: [ :new | 
              new
                loadedInImage: true;
                registerProject ]
            ifPresent: [ :existing :new | 
              existing
                copyOnWrite: [ :existingCopy | 
                  existingCopy
                    loadedInImage: true;
                    merge: new ] ] ] in [ 
      self
        handleNotificationsForAction: [ 
          | version loadedSpec |
          self setDefaultsAndValidateProjectSpec.
          [ loadedSpec := (self lookupProjectSpecFor: self projectSpec) copy ]
            on: MetacelloAllowProjectDowngrade , MetacelloAllowProjectUpgrade
            do: [ :ex | ex handleOnDownGrade: onDownGradeBlock onUpgrade: onUpgradeBlock ].
          version := loadedSpec versionForScriptEngine: self.
          self
            root:
              (required isEmpty
                ifTrue: [ version load ]
                ifFalse: [ version load: required ]) loadDirective.
          loadedSpec loads: required.
          MetacelloProjectRegistration
            registrationForProjectSpec: loadedSpec
            ifAbsent: [ :new | 
              new
                loadedInImage: true;
                registerProject ]
            ifPresent: [ :existing :new | 
              existing
                copyOnWrite: [ :existingCopy | 
                  existingCopy
                    loadedInImage: true;
                    merge: new ] ] ] ] in MetacelloScriptEngine>>load:onProjectDownGrade:onProjectUpgrade:
	Receiver: a MetacelloScriptEngine
	Arguments and temporary variables: 
		required: 	#()
		onDownGradeBlock: 	[ :ex :existing :new | ex allowEvenIfLocked ]
		onUpgradeBlock: 	[ :ex :existing :new | ex allowEvenIfLocked ]
		loadedSpec: 	spec 
	name: 'JSON';
	repository: 'github://SvenVC/NeoJSON/repo[..]
		version: 	nil
	Receiver's instance variables: 
		root: 	nil
		projectSpec: 	spec 
	name: 'JSON';
	repository: 'github://SvenVC/NeoJSON/rep[..]
		options: 	a Dictionary()


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [ 
          | version loadedSpec |
          self setDefaultsAndValidateProjectSpec.
[..]
	Arguments and temporary variables: 
		exception: 	an ExceptionSet
		handlerAction: 	[ :ex | 
      "lookup and registration handlers need to be [..]
	Receiver's instance variables: 
		outerContext: 	[ 
      self
        handleNotificationsForAction: [ 
      [..]
		compiledBlock: 	a CompiledBlock: [ 
          | version loadedSpec |
       [..]
		numArgs: 	0
		receiver: 	a MetacelloScriptEngine


[ 
  actionBlock
    on:
      MetacelloLookupProjectSpec , MetacelloLookupProjectSpecForLoad
        , MetacelloProjectSpecLoadedNotification
        , MetacelloScriptEnsureProjectLoadedForDevelopment
        , MetacelloLookupBaselineSpecForEnsureLoad
    do: [ :ex | 
      "lookup and registration handlers need to be innermost set of handlers ...they may throw option notifications"
      ex handleResolutionFor: self ] ] in [ 
  [ 
  actionBlock
    on:
      MetacelloLookupProjectSpec , MetacelloLookupProjectSpecForLoad
        , MetacelloProjectSpecLoadedNotification
        , MetacelloScriptEnsureProjectLoadedForDevelopment
        , MetacelloLookupBaselineSpecForEnsureLoad
    do: [ :ex | 
      "lookup and registration handlers need to be innermost set of handlers ...they may throw option notifications"
      ex handleResolutionFor: self ] ]
    on:
      MetacelloAllowProjectDowngrade , MetacelloAllowProjectUpgrade
        , MetacelloAllowConflictingProjectUpgrade
    do: [ :ex | 
      "option handlers need to be outermost set of handlers ... last line of defense before users are involved"
      ex handleResolutionFor: self ] ] in [ 
  [ 
  [ 
  actionBlock
    on:
      MetacelloLookupProjectSpec , MetacelloLookupProjectSpecForLoad
        , MetacelloProjectSpecLoadedNotification
        , MetacelloScriptEnsureProjectLoadedForDevelopment
        , MetacelloLookupBaselineSpecForEnsureLoad
    do: [ :ex | 
      "lookup and registration handlers need to be innermost set of handlers ...they may throw option notifications"
      ex handleResolutionFor: self ] ]
    on:
      MetacelloAllowProjectDowngrade , MetacelloAllowProjectUpgrade
        , MetacelloAllowConflictingProjectUpgrade
    do: [ :ex | 
      "option handlers need to be outermost set of handlers ... last line of defense before users are involved"
      ex handleResolutionFor: self ] ]
    on: MetacelloAllowLockedProjectChange
    do: [ :ex | 
      "MetacelloAllowLockedProjectChange need to be outermost handler ... since it is signaled from second line of handlers"
      ex handleResolutionFor: self ] ] in MetacelloScriptEngine>>handleNotificationsForAction:
	Receiver: a MetacelloScriptEngine
	Arguments and temporary variables: 
		actionBlock: 	[ 
          | version loadedSpec |
          self setDefaults[..]
	Receiver's instance variables: 
		root: 	nil
		projectSpec: 	spec 
	name: 'JSON';
	repository: 'github://SvenVC/NeoJSON/rep[..]
		options: 	a Dictionary()


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [ 
  actionBlock
    on:
      MetacelloLookupProjectSpec , MetacelloLookupProjectSpec[..]
	Arguments and temporary variables: 
		exception: 	an ExceptionSet
		handlerAction: 	[ :ex | 
      "option handlers need to be outermost set of [..]
	Receiver's instance variables: 
		outerContext: 	[ 
  [ 
  actionBlock
    on:
      MetacelloLookupProjectSpe[..]
		compiledBlock: 	a CompiledBlock: [ 
  actionBlock
    on:
      MetacelloLoo[..]
		numArgs: 	0
		receiver: 	a MetacelloScriptEngine


[ 
  [ 
  actionBlock
    on:
      MetacelloLookupProjectSpec , MetacelloLookupProjectSpecForLoad
        , MetacelloProjectSpecLoadedNotification
        , MetacelloScriptEnsureProjectLoadedForDevelopment
        , MetacelloLookupBaselineSpecForEnsureLoad
    do: [ :ex | 
      "lookup and registration handlers need to be innermost set of handlers ...they may throw option notifications"
      ex handleResolutionFor: self ] ]
    on:
      MetacelloAllowProjectDowngrade , MetacelloAllowProjectUpgrade
        , MetacelloAllowConflictingProjectUpgrade
    do: [ :ex | 
      "option handlers need to be outermost set of handlers ... last line of defense before users are involved"
      ex handleResolutionFor: self ] ] in [ 
  [ 
  [ 
  actionBlock
    on:
      MetacelloLookupProjectSpec , MetacelloLookupProjectSpecForLoad
        , MetacelloProjectSpecLoadedNotification
        , MetacelloScriptEnsureProjectLoadedForDevelopment
        , MetacelloLookupBaselineSpecForEnsureLoad
    do: [ :ex | 
      "lookup and registration handlers need to be innermost set of handlers ...they may throw option notifications"
      ex handleResolutionFor: self ] ]
    on:
      MetacelloAllowProjectDowngrade , MetacelloAllowProjectUpgrade
        , MetacelloAllowConflictingProjectUpgrade
    do: [ :ex | 
      "option handlers need to be outermost set of handlers ... last line of defense before users are involved"
      ex handleResolutionFor: self ] ]
    on: MetacelloAllowLockedProjectChange
    do: [ :ex | 
      "MetacelloAllowLockedProjectChange need to be outermost handler ... since it is signaled from second line of handlers"
      ex handleResolutionFor: self ] ] in MetacelloScriptEngine>>handleNotificationsForAction:
	Receiver: a MetacelloScriptEngine
	Arguments and temporary variables: 
		actionBlock: 	[ 
          | version loadedSpec |
          self setDefaults[..]
	Receiver's instance variables: 
		root: 	nil
		projectSpec: 	spec 
	name: 'JSON';
	repository: 'github://SvenVC/NeoJSON/rep[..]
		options: 	a Dictionary()



--- The full stack ---
MetacelloFetchingMCSpecLoader(MetacelloCommonMCSpecLoader)>>retryingResolvePackageSpecReferences:gofer:
[ 
      | references nearestReference cachedReference externalReference mcVersion loadedVersionInfos |
      cachedReference := nil.
      packageSpec
        searchCacheRepositoryForPackage: [ 
          "check to see if mcz file is already in cacheRepository"
          cachedReference := self
            resolvePackageSpec: packageSpec
            cachedGofer: self loaderPolicy cacheGofer.
          (cachedReference ~~ nil and: [ packageSpec getFile ~~ nil ])
            ifTrue: [ 
              cachedReference name = packageSpec file
                ifTrue: [ 
                  "exact match between packageSpec file and cache"
                  ^ self
                    scheduleFetchFor: packageSpec
                    cachedReference: cachedReference ] ] ].
      references := self
        retryingResolvePackageSpecReferences: packageSpec
        gofer: gofer.	"look up mcz file"
      nearestReference := references last asMetacelloCachingResolvedReference.
      (cachedReference ~~ nil
        and: [ cachedReference name = nearestReference name ])
        ifTrue: [ 
          "latest reference in repository matches cachedReference ... "
          ^ self
            scheduleFetchFor: packageSpec
            nearestReference: nearestReference ].
      (self ignoreImage not
        and: [ (loadedVersionInfos := self ancestorsFor: packageSpec) ~~ nil ])
        ifTrue: [ 
          "If the mcz is already loaded into the image, no need to copy"
          loadedVersionInfos
            do: [ :info | 
              info name = nearestReference name
                ifTrue: [ 
                  | spc |
                  spc := packageSpec copy.
                  spc file: info name.
                  (MetacelloIgnorePackageLoaded signal: spc)
                    ifFalse: [ ^ self ] ] ] ].
      externalReference := (references
        select: [ :ref | ref name = nearestReference name ]) first
        asMetacelloCachingResolvedReference.
      self repositoryMap
        at: externalReference name
        put: externalReference repository.
      (self
        resolveDependencies: externalReference
        nearest: nearestReference
        into: (OrderedCollection with: nearestReference))
        do: [ :reference | 
          | pSpec l |
          mcVersion := reference version.
          (l := (GoferVersionReference name: reference name)
            resolveAllWith: self loaderPolicy cacheGofer) isEmpty
            ifTrue: [ 
              self cacheRepository storeVersion: mcVersion.
              reference == nearestReference
                ifTrue: [ pSpec := packageSpec ]
                ifFalse: [ 
                  pSpec := packageSpec project packageSpec.
                  pSpec name: mcVersion package name ].
              self loadData
                addVersion: mcVersion
                versionInfo: mcVersion info
                resolvedReference: reference
                packageSpec: pSpec ] ].
      self scheduleFetchFor: packageSpec externalReference: externalReference ] in MetacelloFetchingMCSpecLoader>>linearLoadPackageSpec:gofer:
[:bar |
            bar value: 1.
            aBlock value.
            bar value: 2 ] in IceMetacelloPharoPlatform(MetacelloPharoCommonPlatform)>>do:displaying:
FullBlockClosure(BlockClosure)>>cull:
[ ^ block cull: self ] in [ self prepareForRunning.
	  CurrentJob value: self during: [ ^ block cull: self ] ] in Job>>run
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in CurrentJob(DynamicVariable)>>value:during:
FullBlockClosure(BlockClosure)>>ensure:
CurrentJob(DynamicVariable)>>value:during:
CurrentJob class(DynamicVariable class)>>value:during:
[ self prepareForRunning.
	  CurrentJob value: self during: [ ^ block cull: self ] ] in Job>>run
FullBlockClosure(BlockClosure)>>ensure:
Job>>run
MorphicUIManager(UIManager)>>displayProgress:from:to:during:
ByteString(String)>>displayProgressFrom:to:during:
IceMetacelloPharoPlatform(MetacelloPharoCommonPlatform)>>do:displaying:
MetacelloFetchingMCSpecLoader>>linearLoadPackageSpec:gofer:
MetacelloPackageSpec>>loadUsing:gofer:
[:pkg | pkg loadUsing: self gofer: gofer ] in MetacelloFetchingMCSpecLoader(MetacelloCommonMCSpecLoader)>>linearLoadPackageSpecs:repositories:
Array(SequenceableCollection)>>do:
MetacelloFetchingMCSpecLoader(MetacelloCommonMCSpecLoader)>>linearLoadPackageSpecs:repositories:
[ super linearLoadPackageSpecs: packageSpecs repositories: repositories ] in MetacelloFetchingMCSpecLoader>>explicitLoadPackageSpecs:repositories:
FullBlockClosure(BlockClosure)>>ensure:
MetacelloLoaderPolicy>>pushLoadDirective:during:
MetacelloLoaderPolicy>>pushExplicitLoadDirectivesDuring:for:
MetacelloFetchingMCSpecLoader>>explicitLoadPackageSpecs:repositories:
MetacelloPackageSpec>>explicitLoadUsing:
MetacelloPackageSpec>>load
[ spec projectPackage load ] in MetacelloScriptEngine>>getBaselineUnconditionalLoad:
FullBlockClosure(BlockClosure)>>on:do:
MetacelloScriptEngine>>getBaselineUnconditionalLoad:
MetacelloScriptEngine>>getBaselineProjectUnconditionalLoad:
MetacelloMCBaselineProject>>projectForScriptEngine:unconditionalLoad:
MetacelloMCBaselineProject(MetacelloProject)>>projectForScriptEngine:
MetacelloMCBaselineOfProjectSpec(MetacelloMCProjectSpec)>>versionForScriptEngine:
[ 
          | version loadedSpec |
          self setDefaultsAndValidateProjectSpec.
          [ loadedSpec := (self lookupProjectSpecFor: self projectSpec) copy ]
            on: MetacelloAllowProjectDowngrade , MetacelloAllowProjectUpgrade
            do: [ :ex | ex handleOnDownGrade: onDownGradeBlock onUpgrade: onUpgradeBlock ].
          version := loadedSpec versionForScriptEngine: self.
          self
            root:
              (required isEmpty
                ifTrue: [ version load ]
                ifFalse: [ version load: required ]) loadDirective.
          loadedSpec loads: required.
          MetacelloProjectRegistration
            registrationForProjectSpec: loadedSpec
            ifAbsent: [ :new | 
              new
                loadedInImage: true;
                registerProject ]
            ifPresent: [ :existing :new | 
              existing
                copyOnWrite: [ :existingCopy | 
                  existingCopy
                    loadedInImage: true;
                    merge: new ] ] ] in [ 
      self
        handleNotificationsForAction: [ 
          | version loadedSpec |
          self setDefaultsAndValidateProjectSpec.
          [ loadedSpec := (self lookupProjectSpecFor: self projectSpec) copy ]
            on: MetacelloAllowProjectDowngrade , MetacelloAllowProjectUpgrade
            do: [ :ex | ex handleOnDownGrade: onDownGradeBlock onUpgrade: onUpgradeBlock ].
          version := loadedSpec versionForScriptEngine: self.
          self
            root:
              (required isEmpty
                ifTrue: [ version load ]
                ifFalse: [ version load: required ]) loadDirective.
          loadedSpec loads: required.
          MetacelloProjectRegistration
            registrationForProjectSpec: loadedSpec
            ifAbsent: [ :new | 
              new
                loadedInImage: true;
                registerProject ]
            ifPresent: [ :existing :new | 
              existing
                copyOnWrite: [ :existingCopy | 
                  existingCopy
                    loadedInImage: true;
                    merge: new ] ] ] ] in MetacelloScriptEngine>>load:onProjectDownGrade:onProjectUpgrade:
FullBlockClosure(BlockClosure)>>on:do:
[ 
  actionBlock
    on:
      MetacelloLookupProjectSpec , MetacelloLookupProjectSpecForLoad
        , MetacelloProjectSpecLoadedNotification
        , MetacelloScriptEnsureProjectLoadedForDevelopment
        , MetacelloLookupBaselineSpecForEnsureLoad
    do: [ :ex | 
      "lookup and registration handlers need to be innermost set of handlers ...they may throw option notifications"
      ex handleResolutionFor: self ] ] in [ 
  [ 
  actionBlock
    on:
      MetacelloLookupProjectSpec , MetacelloLookupProjectSpecForLoad
        , MetacelloProjectSpecLoadedNotification
        , MetacelloScriptEnsureProjectLoadedForDevelopment
        , MetacelloLookupBaselineSpecForEnsureLoad
    do: [ :ex | 
      "lookup and registration handlers need to be innermost set of handlers ...they may throw option notifications"
      ex handleResolutionFor: self ] ]
    on:
      MetacelloAllowProjectDowngrade , MetacelloAllowProjectUpgrade
        , MetacelloAllowConflictingProjectUpgrade
    do: [ :ex | 
      "option handlers need to be outermost set of handlers ... last line of defense before users are involved"
      ex handleResolutionFor: self ] ] in [ 
  [ 
  [ 
  actionBlock
    on:
      MetacelloLookupProjectSpec , MetacelloLookupProjectSpecForLoad
        , MetacelloProjectSpecLoadedNotification
        , MetacelloScriptEnsureProjectLoadedForDevelopment
        , MetacelloLookupBaselineSpecForEnsureLoad
    do: [ :ex | 
      "lookup and registration handlers need to be innermost set of handlers ...they may throw option notifications"
      ex handleResolutionFor: self ] ]
    on:
      MetacelloAllowProjectDowngrade , MetacelloAllowProjectUpgrade
        , MetacelloAllowConflictingProjectUpgrade
    do: [ :ex | 
      "option handlers need to be outermost set of handlers ... last line of defense before users are involved"
      ex handleResolutionFor: self ] ]
    on: MetacelloAllowLockedProjectChange
    do: [ :ex | 
      "MetacelloAllowLockedProjectChange need to be outermost handler ... since it is signaled from second line of handlers"
      ex handleResolutionFor: self ] ] in MetacelloScriptEngine>>handleNotificationsForAction:
FullBlockClosure(BlockClosure)>>on:do:
[ 
  [ 
  actionBlock
    on:
      MetacelloLookupProjectSpec , MetacelloLookupProjectSpecForLoad
        , MetacelloProjectSpecLoadedNotification
        , MetacelloScriptEnsureProjectLoadedForDevelopment
        , MetacelloLookupBaselineSpecForEnsureLoad
    do: [ :ex | 
      "lookup and registration handlers need to be innermost set of handlers ...they may throw option notifications"
      ex handleResolutionFor: self ] ]
    on:
      MetacelloAllowProjectDowngrade , MetacelloAllowProjectUpgrade
        , MetacelloAllowConflictingProjectUpgrade
    do: [ :ex | 
      "option handlers need to be outermost set of handlers ... last line of defense before users are involved"
      ex handleResolutionFor: self ] ] in [ 
  [ 
  [ 
  actionBlock
    on:
      MetacelloLookupProjectSpec , MetacelloLookupProjectSpecForLoad
        , MetacelloProjectSpecLoadedNotification
        , MetacelloScriptEnsureProjectLoadedForDevelopment
        , MetacelloLookupBaselineSpecForEnsureLoad
    do: [ :ex | 
      "lookup and registration handlers need to be innermost set of handlers ...they may throw option notifications"
      ex handleResolutionFor: self ] ]
    on:
      MetacelloAllowProjectDowngrade , MetacelloAllowProjectUpgrade
        , MetacelloAllowConflictingProjectUpgrade
    do: [ :ex | 
      "option handlers need to be outermost set of handlers ... last line of defense before users are involved"
      ex handleResolutionFor: self ] ]
    on: MetacelloAllowLockedProjectChange
    do: [ :ex | 
      "MetacelloAllowLockedProjectChange need to be outermost handler ... since it is signaled from second line of handlers"
      ex handleResolutionFor: self ] ] in MetacelloScriptEngine>>handleNotificationsForAction:
 - - - - - - - - - - - - - - -
			- - - - - - - - - - - - - - - - - -
FullBlockClosure(BlockClosure)>>on:do:
[ 
  [ 
  [ 
  actionBlock
    on:
      MetacelloLookupProjectSpec , MetacelloLookupProjectSpecForLoad
        , MetacelloProjectSpecLoadedNotification
        , MetacelloScriptEnsureProjectLoadedForDevelopment
        , MetacelloLookupBaselineSpecForEnsureLoad
    do: [ :ex | 
      "lookup and registration handlers need to be innermost set of handlers ...they may throw option notifications"
      ex handleResolutionFor: self ] ]
    on:
      MetacelloAllowProjectDowngrade , MetacelloAllowProjectUpgrade
        , MetacelloAllowConflictingProjectUpgrade
    do: [ :ex | 
      "option handlers need to be outermost set of handlers ... last line of defense before users are involved"
      ex handleResolutionFor: self ] ]
    on: MetacelloAllowLockedProjectChange
    do: [ :ex | 
      "MetacelloAllowLockedProjectChange need to be outermost handler ... since it is signaled from second line of handlers"
      ex handleResolutionFor: self ] ] in MetacelloScriptEngine>>handleNotificationsForAction:
FullBlockClosure(BlockClosure)>>on:do:
MetacelloScriptEngine>>handleNotificationsForAction:
[ 
      self
        handleNotificationsForAction: [ 
          | version loadedSpec |
          self setDefaultsAndValidateProjectSpec.
          [ loadedSpec := (self lookupProjectSpecFor: self projectSpec) copy ]
            on: MetacelloAllowProjectDowngrade , MetacelloAllowProjectUpgrade
            do: [ :ex | ex handleOnDownGrade: onDownGradeBlock onUpgrade: onUpgradeBlock ].
          version := loadedSpec versionForScriptEngine: self.
          self
            root:
              (required isEmpty
                ifTrue: [ version load ]
                ifFalse: [ version load: required ]) loadDirective.
          loadedSpec loads: required.
          MetacelloProjectRegistration
            registrationForProjectSpec: loadedSpec
            ifAbsent: [ :new | 
              new
                loadedInImage: true;
                registerProject ]
            ifPresent: [ :existing :new | 
              existing
                copyOnWrite: [ :existingCopy | 
                  existingCopy
                    loadedInImage: true;
                    merge: new ] ] ] ] in MetacelloScriptEngine>>load:onProjectDownGrade:onProjectUpgrade:
FullBlockClosure(BlockClosure)>>ensure:
MetacelloProjectRegistration class>>copyRegistryRestoreOnErrorWhile:
MetacelloScriptEngine>>load:onProjectDownGrade:onProjectUpgrade:
MetacelloScriptEngine>>load:
[ :projectSpec | 
      | engine |
      engine := MetacelloScriptEngine new
        options: self options copy;
        projectSpec: projectSpec;
        yourself.
      engine perform: actionArg key withArguments: actionArg value.
      engine root ifNotNil: [ :root | self roots add: root ] ] in MetacelloScriptApiExecutor(MetacelloScriptExecutor)>>execute:
[ :projectSpec | 
      projectSpec
        ifNotNil: [ projectSpecBlock value: (self applyArgsToProjectSpec: projectSpec copy) ] ] in MetacelloScriptApiExecutor>>executeString:do:
Array(SequenceableCollection)>>do:
MetacelloScriptApiExecutor>>executeString:do:
ByteString(String)>>execute:against:
MetacelloScriptApiExecutor(MetacelloScriptExecutor)>>execute:
[ 
		super execute: statements ] in MetacelloScriptApiExecutor>>execute:
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in IceMetacelloLoadSessionContext(DynamicVariable)>>value:during:
FullBlockClosure(BlockClosure)>>ensure:
IceMetacelloLoadSessionContext(DynamicVariable)>>value:during:
IceMetacelloLoadSessionContext class(DynamicVariable class)>>value:during:
IceMetacelloPharoPlatform>>withMetacelloLoadSessionDo:
MetacelloScriptApiExecutor>>execute:
Metacello>>execute:args:
Metacello>>load
UndefinedObject>>DoIt
OCReceiverDoItSemanticScope(OCDoItSemanticScope)>>evaluateDoIt:
OpalCompiler>>evaluate
[
		self announcer announce: (SpCodeWillBeEvaluatedAnnouncement newContent: aString).
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionModel doItReceiver.
		result := receiver class compiler
			source: aString;
			context: self interactionModel doItContext;
			receiver: self interactionModel doItReceiver;
			requestor: self interactionModel;
			environment: self environment;
			failBlock:  [ 
				self announcer announce: (SpCodeEvaluationFailedAnnouncement newContent: aString).
				^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		self announcer announce: (SpCodeEvaluationSucceedAnnouncement newContent: aString).
		result ] in SpCodePresenter>>evaluate:onCompileError:onError:
FullBlockClosure(BlockClosure)>>on:do:
SpCodePresenter>>evaluate:onCompileError:onError:
StPlaygroundPagePresenter>>doEvaluateAndGo
StPlaygroundPagePresenter>>doEvaluateAllAndGo
StPlaygroundDoItCommand>>execute
SpCommand(CmCommandDecorator)>>execute
[ specCommand execute ] in [ :specCommand | 
			aButtonClass new
				label: specCommand name;
				help: specCommand description;
				in: [ :button | 
					specCommand hasIcon
						ifTrue: [ button icon: specCommand icon ] ];
				action: [ specCommand execute ];
				yourself ] in SpCommand>>configureAsButtonOfClass:
FullBlockClosure(BlockClosure)>>cull:
SpMorphicToolbarButtonAdapter>>execute
SpToolbarButtonMorph(PluggableButtonMorph)>>performAction:
[:m |
		(m containsPoint: evt cursorPoint) ifTrue: [m enabled ifTrue: [ m performAction: evt ]]] in SpToolbarButtonMorph(PluggableButtonMorph)>>mouseUp:
Array(SequenceableCollection)>>do:
SpToolbarButtonMorph(PluggableButtonMorph)>>mouseUp:
SpToolbarButtonMorph(Morph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
SpToolbarButtonMorph(Morph)>>handleEvent:
SpToolbarButtonMorph(Morph)>>handleFocusEvent:
[
		result := focusHolder handleFocusEvent: transformedEvent.
	] in HandMorph>>sendFocusEvent:to:clear:
FullBlockClosure(BlockClosure)>>on:do:
WorldMorph>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil ]) ifTrue: [
			morphicWorld activeHand handleEvent: anEvent
		]
	] in OSWindowMorphicEventHandler>>dispatchMorphicEvent:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycleNow
WorldMorph>>doOneCycle
[
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMutex critical: [
			                     self extraWorldList ].
		extraWorldsToDraw do: [ :world | world doOneCycle ].

		(self currentWorld isNotNil and: [
			 (extraWorldsToDraw includes: self currentWorld) not ]) ifTrue: [
			self currentWorld doOneCycle ] ] in WorldMorph class>>doOneCycle
FullBlockClosure(BlockClosure)>>ensure:
WorldState class>>doDrawCycleWith:
WorldMorph class>>doOneCycle
MorphicRenderLoop>>doOneCycle
MorphicRenderLoop>>doOneCycleWhile:
[ MorphicRenderLoop new doOneCycleWhile: [ true ] ] in MorphicUIManager>>spawnNewProcess
[self value.
			"IMPORTANT: Do not step over next line of code. See method comments for details"
			Processor terminateRealActive] in FullBlockClosure(BlockClosure)>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
Could not resolve: BaselineOfJSON [BaselineOfJSON] in /Users/ryanperez/Documents/Pharo/images/Visualizer/pharo-local/package-cache https://github.com/SvenVC/NeoJSON.git[master]
23 October 2023 11:00:48.564991 pm

VM: Mac OS - arm64 - 1000 - CoInterpreter VMMaker-tonel.1 uuid: 902dd483-c0c4-0d00-86f2-0f880df24b96 Oct 23 2023
StackToRegisterMappingCogit VMMaker-tonel.1 uuid: 902dd483-c0c4-0d00-86f2-0f880df24b96 Oct 23 2023
v10.0.8 - Commit: b323c5fb - Date: 2023-10-20 16:02:07 -0400

Image: Pharo11.0.0 [Build information: Pharo-11.0.0+build.710.sha.ea28d8552cac85a7ce1e9c34ab1e7bd45f7b9910 (64 Bit)]

MetacelloFetchingMCSpecLoader(MetacelloCommonMCSpecLoader)>>retryingResolvePackageSpecReferences:gofer:
	Receiver: a MetacelloFetchingMCSpecLoader(explicit load : BaselineOfJSON)
	Arguments and temporary variables: 
		packageSpec: 	spec 
	name: 'BaselineOfJSON';
	repository: 'github://SvenVC/N[..]
		gofer: 	a MetacelloGofer
		references: 	#()
		retryCount: 	3
		repositoryError: 	nil
	Receiver's instance variables: 
		spec: 	spec 
	name: 'BaselineOfJSON';
	repository: 'github://SvenVC/NeoJSON/[..]
		operator: 	nil
		loaderPolicy: 	a MetacelloLoaderPolicy
		disablePackageCache: 	false


[ 
      | references nearestReference cachedReference externalReference mcVersion loadedVersionInfos |
      cachedReference := nil.
      packageSpec
        searchCacheRepositoryForPackage: [ 
          "check to see if mcz file is already in cacheRepository"
          cachedReference := self
            resolvePackageSpec: packageSpec
            cachedGofer: self loaderPolicy cacheGofer.
          (cachedReference ~~ nil and: [ packageSpec getFile ~~ nil ])
            ifTrue: [ 
              cachedReference name = packageSpec file
                ifTrue: [ 
                  "exact match between packageSpec file and cache"
                  ^ self
                    scheduleFetchFor: packageSpec
                    cachedReference: cachedReference ] ] ].
      references := self
        retryingResolvePackageSpecReferences: packageSpec
        gofer: gofer.	"look up mcz file"
      nearestReference := references last asMetacelloCachingResolvedReference.
      (cachedReference ~~ nil
        and: [ cachedReference name = nearestReference name ])
        ifTrue: [ 
          "latest reference in repository matches cachedReference ... "
          ^ self
            scheduleFetchFor: packageSpec
            nearestReference: nearestReference ].
      (self ignoreImage not
        and: [ (loadedVersionInfos := self ancestorsFor: packageSpec) ~~ nil ])
        ifTrue: [ 
          "If the mcz is already loaded into the image, no need to copy"
          loadedVersionInfos
            do: [ :info | 
              info name = nearestReference name
                ifTrue: [ 
                  | spc |
                  spc := packageSpec copy.
                  spc file: info name.
                  (MetacelloIgnorePackageLoaded signal: spc)
                    ifFalse: [ ^ self ] ] ] ].
      externalReference := (references
        select: [ :ref | ref name = nearestReference name ]) first
        asMetacelloCachingResolvedReference.
      self repositoryMap
        at: externalReference name
        put: externalReference repository.
      (self
        resolveDependencies: externalReference
        nearest: nearestReference
        into: (OrderedCollection with: nearestReference))
        do: [ :reference | 
          | pSpec l |
          mcVersion := reference version.
          (l := (GoferVersionReference name: reference name)
            resolveAllWith: self loaderPolicy cacheGofer) isEmpty
            ifTrue: [ 
              self cacheRepository storeVersion: mcVersion.
              reference == nearestReference
                ifTrue: [ pSpec := packageSpec ]
                ifFalse: [ 
                  pSpec := packageSpec project packageSpec.
                  pSpec name: mcVersion package name ].
              self loadData
                addVersion: mcVersion
                versionInfo: mcVersion info
                resolvedReference: reference
                packageSpec: pSpec ] ].
      self scheduleFetchFor: packageSpec externalReference: externalReference ] in MetacelloFetchingMCSpecLoader>>linearLoadPackageSpec:gofer:
	Receiver: a MetacelloFetchingMCSpecLoader(explicit load : BaselineOfJSON)
	Arguments and temporary variables: 
		packageSpec: 	spec 
	name: 'BaselineOfJSON';
	repository: 'github://SvenVC/N[..]
		gofer: 	a MetacelloGofer
		cachedReference: 	nil
		mcVersion: 	nil
		references: 	nil
		nearestReference: 	nil
		externalReference: 	nil
		loadedVersionInfos: 	nil
	Receiver's instance variables: 
		spec: 	spec 
	name: 'BaselineOfJSON';
	repository: 'github://SvenVC/NeoJSON/[..]
		operator: 	nil
		loaderPolicy: 	a MetacelloLoaderPolicy
		disablePackageCache: 	false


[:bar |
            bar value: 1.
            aBlock value.
            bar value: 2 ] in IceMetacelloPharoPlatform(MetacelloPharoCommonPlatform)>>do:displaying:
	Receiver: an IceMetacelloPharoPlatform
	Arguments and temporary variables: 
		aBlock: 	[ 
      | references nearestReference cachedReference externalRefe[..]
		aString: 	'Fetching BaselineOfJSON'
		bar: 	a Job
	Receiver's instance variables: 
		bypassProgressBars: 	false
		bypassGoferLoadUpdateCategories: 	false


FullBlockClosure(BlockClosure)>>cull:
	Receiver: [:bar |
            bar value: 1.
            aBlock value.
            bar value: 2 ]
	Arguments and temporary variables: 
		anArg: 	a Job
	Receiver's instance variables: 
		outerContext: 	IceMetacelloPharoPlatform(MetacelloPharoCommonPlatform)>>do:d[..]
		compiledBlock: 	a CompiledBlock: [:bar |
            bar value: 1.
         [..]
		numArgs: 	1
		receiver: 	an IceMetacelloPharoPlatform


[ ^ block cull: self ] in [ self prepareForRunning.
	  CurrentJob value: self during: [ ^ block cull: self ] ] in Job>>run
	Receiver: a Job
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		block: 	[:bar |
            bar value: 1.
            aBlock value.
        [..]
		currentValue: 	1
		min: 	0
		max: 	2
		title: 	'Fetching BaselineOfJSON'
		children: 	an OrderedCollection()
		isRunning: 	true
		parent: 	nil
		process: 	a Process in nil
		owner: 	a MorphicUIManager


[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in CurrentJob(DynamicVariable)>>value:during:
	Receiver: a CurrentJob
	Arguments and temporary variables: 
		anObject: 	a Job
		aBlock: 	[ ^ block cull: self ]
		activeProcess: 	a Process in nil
		oldValue: 	nil
	Receiver's instance variables: 
		index: 	2


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ]
	Arguments and temporary variables: 
		aBlock: 	[
			activeProcess
				psValueAt: index
				put: oldValue ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	CurrentJob(DynamicVariable)>>value:during:
		compiledBlock: 	a CompiledBlock: [ activeProcess
			psValueAt: index
			put:[..]
		numArgs: 	0
		receiver: 	a CurrentJob


CurrentJob(DynamicVariable)>>value:during:
	Receiver: a CurrentJob
	Arguments and temporary variables: 
		anObject: 	a Job
		aBlock: 	[ ^ block cull: self ]
		activeProcess: 	a Process in nil
		oldValue: 	nil
	Receiver's instance variables: 
		index: 	2


CurrentJob class(DynamicVariable class)>>value:during:
	Receiver: CurrentJob
	Arguments and temporary variables: 
		anObject: 	a Job
		aBlock: 	[ ^ block cull: self ]
	Receiver's instance variables: 
		superclass: 	DynamicVariable
		methodDict: 	a MethodDictionary()
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		commentSourcePointer: 	nil
		subclasses: 	nil
		name: 	#CurrentJob
		classPool: 	nil
		sharedPools: 	nil
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Jobs-Base'
		soleInstance: 	a CurrentJob


[ self prepareForRunning.
	  CurrentJob value: self during: [ ^ block cull: self ] ] in Job>>run
	Receiver: a Job
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		block: 	[:bar |
            bar value: 1.
            aBlock value.
        [..]
		currentValue: 	1
		min: 	0
		max: 	2
		title: 	'Fetching BaselineOfJSON'
		children: 	an OrderedCollection()
		isRunning: 	true
		parent: 	nil
		process: 	a Process in nil
		owner: 	a MorphicUIManager


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ self prepareForRunning.
	  CurrentJob value: self during: [ ^ block cull: self ] ]
	Arguments and temporary variables: 
		aBlock: 	[ self cleanupAfterRunning ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	Job>>run
		compiledBlock: 	a CompiledBlock: [ self prepareForRunning.
	  CurrentJob val[..]
		numArgs: 	0
		receiver: 	a Job


Job>>run
	Receiver: a Job
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		block: 	[:bar |
            bar value: 1.
            aBlock value.
        [..]
		currentValue: 	1
		min: 	0
		max: 	2
		title: 	'Fetching BaselineOfJSON'
		children: 	an OrderedCollection()
		isRunning: 	true
		parent: 	nil
		process: 	a Process in nil
		owner: 	a MorphicUIManager


MorphicUIManager(UIManager)>>displayProgress:from:to:during:
	Receiver: a MorphicUIManager
	Arguments and temporary variables: 
		titleString: 	'Fetching BaselineOfJSON'
		minVal: 	0
		maxVal: 	2
		workBlock: 	[:bar |
            bar value: 1.
            aBlock value.
    [..]
	Receiver's instance variables: 
		activeTranscript: 	nil


ByteString(String)>>displayProgressFrom:to:during:
	Receiver: 'Fetching BaselineOfJSON'
	Arguments and temporary variables: 
		minVal: 	0
		maxVal: 	2
		workBlock: 	[:bar |
            bar value: 1.
            aBlock value.
    [..]
	Receiver's instance variables: 
'Fetching BaselineOfJSON'

IceMetacelloPharoPlatform(MetacelloPharoCommonPlatform)>>do:displaying:
	Receiver: an IceMetacelloPharoPlatform
	Arguments and temporary variables: 
		aBlock: 	[ 
      | references nearestReference cachedReference externalRefe[..]
		aString: 	'Fetching BaselineOfJSON'
	Receiver's instance variables: 
		bypassProgressBars: 	false
		bypassGoferLoadUpdateCategories: 	false


MetacelloFetchingMCSpecLoader>>linearLoadPackageSpec:gofer:
	Receiver: a MetacelloFetchingMCSpecLoader(explicit load : BaselineOfJSON)
	Arguments and temporary variables: 
		packageSpec: 	spec 
	name: 'BaselineOfJSON';
	repository: 'github://SvenVC/N[..]
		gofer: 	a MetacelloGofer
	Receiver's instance variables: 
		spec: 	spec 
	name: 'BaselineOfJSON';
	repository: 'github://SvenVC/NeoJSON/[..]
		operator: 	nil
		loaderPolicy: 	a MetacelloLoaderPolicy
		disablePackageCache: 	false


MetacelloPackageSpec>>loadUsing:gofer:
	Receiver: spec 
	name: 'BaselineOfJSON';
	repository: 'github://SvenVC/NeoJSON/repository'.
	Arguments and temporary variables: 
		aLoader: 	a MetacelloFetchingMCSpecLoader(explicit load : BaselineOfJSON)
		gofer: 	a MetacelloGofer
	Receiver's instance variables: 
		project: 	<<error during printing>>

[:pkg | pkg loadUsing: self gofer: gofer ] in MetacelloFetchingMCSpecLoader(MetacelloCommonMCSpecLoader)>>linearLoadPackageSpecs:repositories:
	Receiver: a MetacelloFetchingMCSpecLoader(explicit load : BaselineOfJSON)
	Arguments and temporary variables: 
		packageSpecs: 	an Array(spec 
	name: 'BaselineOfJSON';
	repository: 'github:[..]
		repositories: 	an OrderedCollection(an IceMetacelloRepositoryAdapter)
		gofer: 	a MetacelloGofer
		pkg: 	spec 
	name: 'BaselineOfJSON';
	repository: 'github://SvenVC/NeoJSON/r[..]
	Receiver's instance variables: 
		spec: 	spec 
	name: 'BaselineOfJSON';
	repository: 'github://SvenVC/NeoJSON/[..]
		operator: 	nil
		loaderPolicy: 	a MetacelloLoaderPolicy
		disablePackageCache: 	false


Array(SequenceableCollection)>>do:
	Receiver: an Array(spec 
	name: 'BaselineOfJSON';
	repository: 'github://SvenVC/NeoJSON/reposito[..]
	Arguments and temporary variables: 
		aBlock: 	[:pkg | pkg loadUsing: self gofer: gofer ]
		index: 	1
	Receiver's instance variables: 
an Array(spec 
	name: 'BaselineOfJSON';
	repository: 'github://SvenVC/NeoJSON/reposito[..]

MetacelloFetchingMCSpecLoader(MetacelloCommonMCSpecLoader)>>linearLoadPackageSpecs:repositories:
	Receiver: a MetacelloFetchingMCSpecLoader(explicit load : BaselineOfJSON)
	Arguments and temporary variables: 
		packageSpecs: 	an Array(spec 
	name: 'BaselineOfJSON';
	repository: 'github:[..]
		repositories: 	an OrderedCollection(an IceMetacelloRepositoryAdapter)
		gofer: 	a MetacelloGofer
	Receiver's instance variables: 
		spec: 	spec 
	name: 'BaselineOfJSON';
	repository: 'github://SvenVC/NeoJSON/[..]
		operator: 	nil
		loaderPolicy: 	a MetacelloLoaderPolicy
		disablePackageCache: 	false


[ super linearLoadPackageSpecs: packageSpecs repositories: repositories ] in MetacelloFetchingMCSpecLoader>>explicitLoadPackageSpecs:repositories:
	Receiver: a MetacelloFetchingMCSpecLoader(explicit load : BaselineOfJSON)
	Arguments and temporary variables: 
		packageSpecs: 	an Array(spec 
	name: 'BaselineOfJSON';
	repository: 'github:[..]
		repositories: 	an OrderedCollection(an IceMetacelloRepositoryAdapter)
		directive: 	nil
	Receiver's instance variables: 
		spec: 	spec 
	name: 'BaselineOfJSON';
	repository: 'github://SvenVC/NeoJSON/[..]
		operator: 	nil
		loaderPolicy: 	a MetacelloLoaderPolicy
		disablePackageCache: 	false


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ super linearLoadPackageSpecs: packageSpecs repositories: repositories ]
	Arguments and temporary variables: 
		aBlock: 	[ loadDirective := oldRoot ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	MetacelloFetchingMCSpecLoader>>explicitLoadPackageSpecs:repos[..]
		compiledBlock: 	a CompiledBlock: [ super linearLoadPackageSpecs: packageSpec[..]
		numArgs: 	0
		receiver: 	a MetacelloFetchingMCSpecLoader(explicit load : BaselineOfJSON)


MetacelloLoaderPolicy>>pushLoadDirective:during:
	Receiver: a MetacelloLoaderPolicy
	Arguments and temporary variables: 
		aLoaderDirective: 	explicit load : BaselineOfJSON
		aBlock: 	[ super linearLoadPackageSpecs: packageSpecs repositories: reposito[..]
		oldRoot: 	linear load : 
	explicit load : BaselineOfJSON
	Receiver's instance variables: 
		overrideRepositories: 	nil
		repositoryMap: 	a Dictionary()
		ensuredMap: 	a Dictionary()
		cacheRepository: 	a MCDictionaryRepository(cache)
		cacheGofer: 	a Gofer
		ignoreImage: 	false
		loadData: 	nil
		loadDirective: 	explicit load : BaselineOfJSON
		silently: 	nil


MetacelloLoaderPolicy>>pushExplicitLoadDirectivesDuring:for:
	Receiver: a MetacelloLoaderPolicy
	Arguments and temporary variables: 
		aBlock: 	[ super linearLoadPackageSpecs: packageSpecs repositories: reposito[..]
		aLoader: 	a MetacelloFetchingMCSpecLoader(explicit load : BaselineOfJSON)
		directive: 	explicit load : BaselineOfJSON
	Receiver's instance variables: 
		overrideRepositories: 	nil
		repositoryMap: 	a Dictionary()
		ensuredMap: 	a Dictionary()
		cacheRepository: 	a MCDictionaryRepository(cache)
		cacheGofer: 	a Gofer
		ignoreImage: 	false
		loadData: 	nil
		loadDirective: 	explicit load : BaselineOfJSON
		silently: 	nil


MetacelloFetchingMCSpecLoader>>explicitLoadPackageSpecs:repositories:
	Receiver: a MetacelloFetchingMCSpecLoader(explicit load : BaselineOfJSON)
	Arguments and temporary variables: 
		packageSpecs: 	an Array(spec 
	name: 'BaselineOfJSON';
	repository: 'github:[..]
		repositories: 	an OrderedCollection(an IceMetacelloRepositoryAdapter)
		directive: 	nil
	Receiver's instance variables: 
		spec: 	spec 
	name: 'BaselineOfJSON';
	repository: 'github://SvenVC/NeoJSON/[..]
		operator: 	nil
		loaderPolicy: 	a MetacelloLoaderPolicy
		disablePackageCache: 	false


MetacelloPackageSpec>>explicitLoadUsing:
	Receiver: spec 
	name: 'BaselineOfJSON';
	repository: 'github://SvenVC/NeoJSON/repository'.
	Arguments and temporary variables: 
		mcLoader: 	a MetacelloLoadingMCSpecLoader
		wc: 	nil
		fetchingSpecLoader: 	a MetacelloFetchingMCSpecLoader(explicit load : Baselin[..]
	Receiver's instance variables: 
		project: 	<<error during printing>>

MetacelloPackageSpec>>load
	Receiver: spec 
	name: 'BaselineOfJSON';
	repository: 'github://SvenVC/NeoJSON/repository'.
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		project: 	<<error during printing>>

[ spec projectPackage load ] in MetacelloScriptEngine>>getBaselineUnconditionalLoad:
	Receiver: a MetacelloScriptEngine
	Arguments and temporary variables: 
		unconditionalLoad: 	true
		spec: 	spec 
	name: 'JSON';
	repository: 'github://SvenVC/NeoJSON/repository'.
	Receiver's instance variables: 
		root: 	nil
		projectSpec: 	spec 
	name: 'JSON';
	repository: 'github://SvenVC/NeoJSON/rep[..]
		options: 	a Dictionary()


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [ spec projectPackage load ]
	Arguments and temporary variables: 
		exception: 	MetacelloIgnorePackageLoaded
		handlerAction: 	[ :ex | 
      "see https://github.com/dalehenrich/metacello[..]
	Receiver's instance variables: 
		outerContext: 	MetacelloScriptEngine>>getBaselineUnconditionalLoad:
		compiledBlock: 	a CompiledBlock: [ spec projectPackage load ]
		numArgs: 	0
		receiver: 	a MetacelloScriptEngine


MetacelloScriptEngine>>getBaselineUnconditionalLoad:
	Receiver: a MetacelloScriptEngine
	Arguments and temporary variables: 
		unconditionalLoad: 	true
		spec: 	spec 
	name: 'JSON';
	repository: 'github://SvenVC/NeoJSON/repository'.
	Receiver's instance variables: 
		root: 	nil
		projectSpec: 	spec 
	name: 'JSON';
	repository: 'github://SvenVC/NeoJSON/rep[..]
		options: 	a Dictionary()


MetacelloScriptEngine>>getBaselineProjectUnconditionalLoad:
	Receiver: a MetacelloScriptEngine
	Arguments and temporary variables: 
		unconditionalLoad: 	true
		project: 	nil
	Receiver's instance variables: 
		root: 	nil
		projectSpec: 	spec 
	name: 'JSON';
	repository: 'github://SvenVC/NeoJSON/rep[..]
		options: 	a Dictionary()


MetacelloMCBaselineProject>>projectForScriptEngine:unconditionalLoad:
	Receiver: <<error during printing>>
	Arguments and temporary variables: 
		aMetacelloScriptEngine: 	a MetacelloScriptEngine
		aBool: 	false
	Receiver's instance variables: 
		versionMap: 	nil
		symbolicVersionMap: 	nil
		errorMap: 	nil
		loader: 	nil
		loaderClass: 	MetacelloLoadingMCSpecLoader
		loadType: 	nil
		configuration: 	<<error during printing>>

MetacelloMCBaselineProject(MetacelloProject)>>projectForScriptEngine:
	Receiver: <<error during printing>>
	Arguments and temporary variables: 
		aMetacelloScriptEngine: 	a MetacelloScriptEngine
	Receiver's instance variables: 
		versionMap: 	nil
		symbolicVersionMap: 	nil
		errorMap: 	nil
		loader: 	nil
		loaderClass: 	MetacelloLoadingMCSpecLoader
		loadType: 	nil
		configuration: 	<<error during printing>>

MetacelloMCBaselineOfProjectSpec(MetacelloMCProjectSpec)>>versionForScriptEngine:
	Receiver: spec 
	name: 'JSON';
	repository: 'github://SvenVC/NeoJSON/repository'.
	Arguments and temporary variables: 
<<error during printing>>
	Receiver's instance variables: 
		project: 	<<error during printing>>

[ 
          | version loadedSpec |
          self setDefaultsAndValidateProjectSpec.
          [ loadedSpec := (self lookupProjectSpecFor: self projectSpec) copy ]
            on: MetacelloAllowProjectDowngrade , MetacelloAllowProjectUpgrade
            do: [ :ex | ex handleOnDownGrade: onDownGradeBlock onUpgrade: onUpgradeBlock ].
          version := loadedSpec versionForScriptEngine: self.
          self
            root:
              (required isEmpty
                ifTrue: [ version load ]
                ifFalse: [ version load: required ]) loadDirective.
          loadedSpec loads: required.
          MetacelloProjectRegistration
            registrationForProjectSpec: loadedSpec
            ifAbsent: [ :new | 
              new
                loadedInImage: true;
                registerProject ]
            ifPresent: [ :existing :new | 
              existing
                copyOnWrite: [ :existingCopy | 
                  existingCopy
                    loadedInImage: true;
                    merge: new ] ] ] in [ 
      self
        handleNotificationsForAction: [ 
          | version loadedSpec |
          self setDefaultsAndValidateProjectSpec.
          [ loadedSpec := (self lookupProjectSpecFor: self projectSpec) copy ]
            on: MetacelloAllowProjectDowngrade , MetacelloAllowProjectUpgrade
            do: [ :ex | ex handleOnDownGrade: onDownGradeBlock onUpgrade: onUpgradeBlock ].
          version := loadedSpec versionForScriptEngine: self.
          self
            root:
              (required isEmpty
                ifTrue: [ version load ]
                ifFalse: [ version load: required ]) loadDirective.
          loadedSpec loads: required.
          MetacelloProjectRegistration
            registrationForProjectSpec: loadedSpec
            ifAbsent: [ :new | 
              new
                loadedInImage: true;
                registerProject ]
            ifPresent: [ :existing :new | 
              existing
                copyOnWrite: [ :existingCopy | 
                  existingCopy
                    loadedInImage: true;
                    merge: new ] ] ] ] in MetacelloScriptEngine>>load:onProjectDownGrade:onProjectUpgrade:
	Receiver: a MetacelloScriptEngine
	Arguments and temporary variables: 
		required: 	#()
		onDownGradeBlock: 	[ :ex :existing :new | ex allowEvenIfLocked ]
		onUpgradeBlock: 	[ :ex :existing :new | ex allowEvenIfLocked ]
		loadedSpec: 	spec 
	name: 'JSON';
	repository: 'github://SvenVC/NeoJSON/repo[..]
		version: 	nil
	Receiver's instance variables: 
		root: 	nil
		projectSpec: 	spec 
	name: 'JSON';
	repository: 'github://SvenVC/NeoJSON/rep[..]
		options: 	a Dictionary()


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [ 
          | version loadedSpec |
          self setDefaultsAndValidateProjectSpec.
[..]
	Arguments and temporary variables: 
		exception: 	an ExceptionSet
		handlerAction: 	[ :ex | 
      "lookup and registration handlers need to be [..]
	Receiver's instance variables: 
		outerContext: 	[ 
      self
        handleNotificationsForAction: [ 
      [..]
		compiledBlock: 	a CompiledBlock: [ 
          | version loadedSpec |
       [..]
		numArgs: 	0
		receiver: 	a MetacelloScriptEngine


[ 
  actionBlock
    on:
      MetacelloLookupProjectSpec , MetacelloLookupProjectSpecForLoad
        , MetacelloProjectSpecLoadedNotification
        , MetacelloScriptEnsureProjectLoadedForDevelopment
        , MetacelloLookupBaselineSpecForEnsureLoad
    do: [ :ex | 
      "lookup and registration handlers need to be innermost set of handlers ...they may throw option notifications"
      ex handleResolutionFor: self ] ] in [ 
  [ 
  actionBlock
    on:
      MetacelloLookupProjectSpec , MetacelloLookupProjectSpecForLoad
        , MetacelloProjectSpecLoadedNotification
        , MetacelloScriptEnsureProjectLoadedForDevelopment
        , MetacelloLookupBaselineSpecForEnsureLoad
    do: [ :ex | 
      "lookup and registration handlers need to be innermost set of handlers ...they may throw option notifications"
      ex handleResolutionFor: self ] ]
    on:
      MetacelloAllowProjectDowngrade , MetacelloAllowProjectUpgrade
        , MetacelloAllowConflictingProjectUpgrade
    do: [ :ex | 
      "option handlers need to be outermost set of handlers ... last line of defense before users are involved"
      ex handleResolutionFor: self ] ] in [ 
  [ 
  [ 
  actionBlock
    on:
      MetacelloLookupProjectSpec , MetacelloLookupProjectSpecForLoad
        , MetacelloProjectSpecLoadedNotification
        , MetacelloScriptEnsureProjectLoadedForDevelopment
        , MetacelloLookupBaselineSpecForEnsureLoad
    do: [ :ex | 
      "lookup and registration handlers need to be innermost set of handlers ...they may throw option notifications"
      ex handleResolutionFor: self ] ]
    on:
      MetacelloAllowProjectDowngrade , MetacelloAllowProjectUpgrade
        , MetacelloAllowConflictingProjectUpgrade
    do: [ :ex | 
      "option handlers need to be outermost set of handlers ... last line of defense before users are involved"
      ex handleResolutionFor: self ] ]
    on: MetacelloAllowLockedProjectChange
    do: [ :ex | 
      "MetacelloAllowLockedProjectChange need to be outermost handler ... since it is signaled from second line of handlers"
      ex handleResolutionFor: self ] ] in MetacelloScriptEngine>>handleNotificationsForAction:
	Receiver: a MetacelloScriptEngine
	Arguments and temporary variables: 
		actionBlock: 	[ 
          | version loadedSpec |
          self setDefaults[..]
	Receiver's instance variables: 
		root: 	nil
		projectSpec: 	spec 
	name: 'JSON';
	repository: 'github://SvenVC/NeoJSON/rep[..]
		options: 	a Dictionary()


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [ 
  actionBlock
    on:
      MetacelloLookupProjectSpec , MetacelloLookupProjectSpec[..]
	Arguments and temporary variables: 
		exception: 	an ExceptionSet
		handlerAction: 	[ :ex | 
      "option handlers need to be outermost set of [..]
	Receiver's instance variables: 
		outerContext: 	[ 
  [ 
  actionBlock
    on:
      MetacelloLookupProjectSpe[..]
		compiledBlock: 	a CompiledBlock: [ 
  actionBlock
    on:
      MetacelloLoo[..]
		numArgs: 	0
		receiver: 	a MetacelloScriptEngine


[ 
  [ 
  actionBlock
    on:
      MetacelloLookupProjectSpec , MetacelloLookupProjectSpecForLoad
        , MetacelloProjectSpecLoadedNotification
        , MetacelloScriptEnsureProjectLoadedForDevelopment
        , MetacelloLookupBaselineSpecForEnsureLoad
    do: [ :ex | 
      "lookup and registration handlers need to be innermost set of handlers ...they may throw option notifications"
      ex handleResolutionFor: self ] ]
    on:
      MetacelloAllowProjectDowngrade , MetacelloAllowProjectUpgrade
        , MetacelloAllowConflictingProjectUpgrade
    do: [ :ex | 
      "option handlers need to be outermost set of handlers ... last line of defense before users are involved"
      ex handleResolutionFor: self ] ] in [ 
  [ 
  [ 
  actionBlock
    on:
      MetacelloLookupProjectSpec , MetacelloLookupProjectSpecForLoad
        , MetacelloProjectSpecLoadedNotification
        , MetacelloScriptEnsureProjectLoadedForDevelopment
        , MetacelloLookupBaselineSpecForEnsureLoad
    do: [ :ex | 
      "lookup and registration handlers need to be innermost set of handlers ...they may throw option notifications"
      ex handleResolutionFor: self ] ]
    on:
      MetacelloAllowProjectDowngrade , MetacelloAllowProjectUpgrade
        , MetacelloAllowConflictingProjectUpgrade
    do: [ :ex | 
      "option handlers need to be outermost set of handlers ... last line of defense before users are involved"
      ex handleResolutionFor: self ] ]
    on: MetacelloAllowLockedProjectChange
    do: [ :ex | 
      "MetacelloAllowLockedProjectChange need to be outermost handler ... since it is signaled from second line of handlers"
      ex handleResolutionFor: self ] ] in MetacelloScriptEngine>>handleNotificationsForAction:
	Receiver: a MetacelloScriptEngine
	Arguments and temporary variables: 
		actionBlock: 	[ 
          | version loadedSpec |
          self setDefaults[..]
	Receiver's instance variables: 
		root: 	nil
		projectSpec: 	spec 
	name: 'JSON';
	repository: 'github://SvenVC/NeoJSON/rep[..]
		options: 	a Dictionary()



--- The full stack ---
MetacelloFetchingMCSpecLoader(MetacelloCommonMCSpecLoader)>>retryingResolvePackageSpecReferences:gofer:
[ 
      | references nearestReference cachedReference externalReference mcVersion loadedVersionInfos |
      cachedReference := nil.
      packageSpec
        searchCacheRepositoryForPackage: [ 
          "check to see if mcz file is already in cacheRepository"
          cachedReference := self
            resolvePackageSpec: packageSpec
            cachedGofer: self loaderPolicy cacheGofer.
          (cachedReference ~~ nil and: [ packageSpec getFile ~~ nil ])
            ifTrue: [ 
              cachedReference name = packageSpec file
                ifTrue: [ 
                  "exact match between packageSpec file and cache"
                  ^ self
                    scheduleFetchFor: packageSpec
                    cachedReference: cachedReference ] ] ].
      references := self
        retryingResolvePackageSpecReferences: packageSpec
        gofer: gofer.	"look up mcz file"
      nearestReference := references last asMetacelloCachingResolvedReference.
      (cachedReference ~~ nil
        and: [ cachedReference name = nearestReference name ])
        ifTrue: [ 
          "latest reference in repository matches cachedReference ... "
          ^ self
            scheduleFetchFor: packageSpec
            nearestReference: nearestReference ].
      (self ignoreImage not
        and: [ (loadedVersionInfos := self ancestorsFor: packageSpec) ~~ nil ])
        ifTrue: [ 
          "If the mcz is already loaded into the image, no need to copy"
          loadedVersionInfos
            do: [ :info | 
              info name = nearestReference name
                ifTrue: [ 
                  | spc |
                  spc := packageSpec copy.
                  spc file: info name.
                  (MetacelloIgnorePackageLoaded signal: spc)
                    ifFalse: [ ^ self ] ] ] ].
      externalReference := (references
        select: [ :ref | ref name = nearestReference name ]) first
        asMetacelloCachingResolvedReference.
      self repositoryMap
        at: externalReference name
        put: externalReference repository.
      (self
        resolveDependencies: externalReference
        nearest: nearestReference
        into: (OrderedCollection with: nearestReference))
        do: [ :reference | 
          | pSpec l |
          mcVersion := reference version.
          (l := (GoferVersionReference name: reference name)
            resolveAllWith: self loaderPolicy cacheGofer) isEmpty
            ifTrue: [ 
              self cacheRepository storeVersion: mcVersion.
              reference == nearestReference
                ifTrue: [ pSpec := packageSpec ]
                ifFalse: [ 
                  pSpec := packageSpec project packageSpec.
                  pSpec name: mcVersion package name ].
              self loadData
                addVersion: mcVersion
                versionInfo: mcVersion info
                resolvedReference: reference
                packageSpec: pSpec ] ].
      self scheduleFetchFor: packageSpec externalReference: externalReference ] in MetacelloFetchingMCSpecLoader>>linearLoadPackageSpec:gofer:
[:bar |
            bar value: 1.
            aBlock value.
            bar value: 2 ] in IceMetacelloPharoPlatform(MetacelloPharoCommonPlatform)>>do:displaying:
FullBlockClosure(BlockClosure)>>cull:
[ ^ block cull: self ] in [ self prepareForRunning.
	  CurrentJob value: self during: [ ^ block cull: self ] ] in Job>>run
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in CurrentJob(DynamicVariable)>>value:during:
FullBlockClosure(BlockClosure)>>ensure:
CurrentJob(DynamicVariable)>>value:during:
CurrentJob class(DynamicVariable class)>>value:during:
[ self prepareForRunning.
	  CurrentJob value: self during: [ ^ block cull: self ] ] in Job>>run
FullBlockClosure(BlockClosure)>>ensure:
Job>>run
MorphicUIManager(UIManager)>>displayProgress:from:to:during:
ByteString(String)>>displayProgressFrom:to:during:
IceMetacelloPharoPlatform(MetacelloPharoCommonPlatform)>>do:displaying:
MetacelloFetchingMCSpecLoader>>linearLoadPackageSpec:gofer:
MetacelloPackageSpec>>loadUsing:gofer:
[:pkg | pkg loadUsing: self gofer: gofer ] in MetacelloFetchingMCSpecLoader(MetacelloCommonMCSpecLoader)>>linearLoadPackageSpecs:repositories:
Array(SequenceableCollection)>>do:
MetacelloFetchingMCSpecLoader(MetacelloCommonMCSpecLoader)>>linearLoadPackageSpecs:repositories:
[ super linearLoadPackageSpecs: packageSpecs repositories: repositories ] in MetacelloFetchingMCSpecLoader>>explicitLoadPackageSpecs:repositories:
FullBlockClosure(BlockClosure)>>ensure:
MetacelloLoaderPolicy>>pushLoadDirective:during:
MetacelloLoaderPolicy>>pushExplicitLoadDirectivesDuring:for:
MetacelloFetchingMCSpecLoader>>explicitLoadPackageSpecs:repositories:
MetacelloPackageSpec>>explicitLoadUsing:
MetacelloPackageSpec>>load
[ spec projectPackage load ] in MetacelloScriptEngine>>getBaselineUnconditionalLoad:
FullBlockClosure(BlockClosure)>>on:do:
MetacelloScriptEngine>>getBaselineUnconditionalLoad:
MetacelloScriptEngine>>getBaselineProjectUnconditionalLoad:
MetacelloMCBaselineProject>>projectForScriptEngine:unconditionalLoad:
MetacelloMCBaselineProject(MetacelloProject)>>projectForScriptEngine:
MetacelloMCBaselineOfProjectSpec(MetacelloMCProjectSpec)>>versionForScriptEngine:
[ 
          | version loadedSpec |
          self setDefaultsAndValidateProjectSpec.
          [ loadedSpec := (self lookupProjectSpecFor: self projectSpec) copy ]
            on: MetacelloAllowProjectDowngrade , MetacelloAllowProjectUpgrade
            do: [ :ex | ex handleOnDownGrade: onDownGradeBlock onUpgrade: onUpgradeBlock ].
          version := loadedSpec versionForScriptEngine: self.
          self
            root:
              (required isEmpty
                ifTrue: [ version load ]
                ifFalse: [ version load: required ]) loadDirective.
          loadedSpec loads: required.
          MetacelloProjectRegistration
            registrationForProjectSpec: loadedSpec
            ifAbsent: [ :new | 
              new
                loadedInImage: true;
                registerProject ]
            ifPresent: [ :existing :new | 
              existing
                copyOnWrite: [ :existingCopy | 
                  existingCopy
                    loadedInImage: true;
                    merge: new ] ] ] in [ 
      self
        handleNotificationsForAction: [ 
          | version loadedSpec |
          self setDefaultsAndValidateProjectSpec.
          [ loadedSpec := (self lookupProjectSpecFor: self projectSpec) copy ]
            on: MetacelloAllowProjectDowngrade , MetacelloAllowProjectUpgrade
            do: [ :ex | ex handleOnDownGrade: onDownGradeBlock onUpgrade: onUpgradeBlock ].
          version := loadedSpec versionForScriptEngine: self.
          self
            root:
              (required isEmpty
                ifTrue: [ version load ]
                ifFalse: [ version load: required ]) loadDirective.
          loadedSpec loads: required.
          MetacelloProjectRegistration
            registrationForProjectSpec: loadedSpec
            ifAbsent: [ :new | 
              new
                loadedInImage: true;
                registerProject ]
            ifPresent: [ :existing :new | 
              existing
                copyOnWrite: [ :existingCopy | 
                  existingCopy
                    loadedInImage: true;
                    merge: new ] ] ] ] in MetacelloScriptEngine>>load:onProjectDownGrade:onProjectUpgrade:
FullBlockClosure(BlockClosure)>>on:do:
[ 
  actionBlock
    on:
      MetacelloLookupProjectSpec , MetacelloLookupProjectSpecForLoad
        , MetacelloProjectSpecLoadedNotification
        , MetacelloScriptEnsureProjectLoadedForDevelopment
        , MetacelloLookupBaselineSpecForEnsureLoad
    do: [ :ex | 
      "lookup and registration handlers need to be innermost set of handlers ...they may throw option notifications"
      ex handleResolutionFor: self ] ] in [ 
  [ 
  actionBlock
    on:
      MetacelloLookupProjectSpec , MetacelloLookupProjectSpecForLoad
        , MetacelloProjectSpecLoadedNotification
        , MetacelloScriptEnsureProjectLoadedForDevelopment
        , MetacelloLookupBaselineSpecForEnsureLoad
    do: [ :ex | 
      "lookup and registration handlers need to be innermost set of handlers ...they may throw option notifications"
      ex handleResolutionFor: self ] ]
    on:
      MetacelloAllowProjectDowngrade , MetacelloAllowProjectUpgrade
        , MetacelloAllowConflictingProjectUpgrade
    do: [ :ex | 
      "option handlers need to be outermost set of handlers ... last line of defense before users are involved"
      ex handleResolutionFor: self ] ] in [ 
  [ 
  [ 
  actionBlock
    on:
      MetacelloLookupProjectSpec , MetacelloLookupProjectSpecForLoad
        , MetacelloProjectSpecLoadedNotification
        , MetacelloScriptEnsureProjectLoadedForDevelopment
        , MetacelloLookupBaselineSpecForEnsureLoad
    do: [ :ex | 
      "lookup and registration handlers need to be innermost set of handlers ...they may throw option notifications"
      ex handleResolutionFor: self ] ]
    on:
      MetacelloAllowProjectDowngrade , MetacelloAllowProjectUpgrade
        , MetacelloAllowConflictingProjectUpgrade
    do: [ :ex | 
      "option handlers need to be outermost set of handlers ... last line of defense before users are involved"
      ex handleResolutionFor: self ] ]
    on: MetacelloAllowLockedProjectChange
    do: [ :ex | 
      "MetacelloAllowLockedProjectChange need to be outermost handler ... since it is signaled from second line of handlers"
      ex handleResolutionFor: self ] ] in MetacelloScriptEngine>>handleNotificationsForAction:
FullBlockClosure(BlockClosure)>>on:do:
[ 
  [ 
  actionBlock
    on:
      MetacelloLookupProjectSpec , MetacelloLookupProjectSpecForLoad
        , MetacelloProjectSpecLoadedNotification
        , MetacelloScriptEnsureProjectLoadedForDevelopment
        , MetacelloLookupBaselineSpecForEnsureLoad
    do: [ :ex | 
      "lookup and registration handlers need to be innermost set of handlers ...they may throw option notifications"
      ex handleResolutionFor: self ] ]
    on:
      MetacelloAllowProjectDowngrade , MetacelloAllowProjectUpgrade
        , MetacelloAllowConflictingProjectUpgrade
    do: [ :ex | 
      "option handlers need to be outermost set of handlers ... last line of defense before users are involved"
      ex handleResolutionFor: self ] ] in [ 
  [ 
  [ 
  actionBlock
    on:
      MetacelloLookupProjectSpec , MetacelloLookupProjectSpecForLoad
        , MetacelloProjectSpecLoadedNotification
        , MetacelloScriptEnsureProjectLoadedForDevelopment
        , MetacelloLookupBaselineSpecForEnsureLoad
    do: [ :ex | 
      "lookup and registration handlers need to be innermost set of handlers ...they may throw option notifications"
      ex handleResolutionFor: self ] ]
    on:
      MetacelloAllowProjectDowngrade , MetacelloAllowProjectUpgrade
        , MetacelloAllowConflictingProjectUpgrade
    do: [ :ex | 
      "option handlers need to be outermost set of handlers ... last line of defense before users are involved"
      ex handleResolutionFor: self ] ]
    on: MetacelloAllowLockedProjectChange
    do: [ :ex | 
      "MetacelloAllowLockedProjectChange need to be outermost handler ... since it is signaled from second line of handlers"
      ex handleResolutionFor: self ] ] in MetacelloScriptEngine>>handleNotificationsForAction:
 - - - - - - - - - - - - - - -
			- - - - - - - - - - - - - - - - - -
FullBlockClosure(BlockClosure)>>on:do:
[ 
  [ 
  [ 
  actionBlock
    on:
      MetacelloLookupProjectSpec , MetacelloLookupProjectSpecForLoad
        , MetacelloProjectSpecLoadedNotification
        , MetacelloScriptEnsureProjectLoadedForDevelopment
        , MetacelloLookupBaselineSpecForEnsureLoad
    do: [ :ex | 
      "lookup and registration handlers need to be innermost set of handlers ...they may throw option notifications"
      ex handleResolutionFor: self ] ]
    on:
      MetacelloAllowProjectDowngrade , MetacelloAllowProjectUpgrade
        , MetacelloAllowConflictingProjectUpgrade
    do: [ :ex | 
      "option handlers need to be outermost set of handlers ... last line of defense before users are involved"
      ex handleResolutionFor: self ] ]
    on: MetacelloAllowLockedProjectChange
    do: [ :ex | 
      "MetacelloAllowLockedProjectChange need to be outermost handler ... since it is signaled from second line of handlers"
      ex handleResolutionFor: self ] ] in MetacelloScriptEngine>>handleNotificationsForAction:
FullBlockClosure(BlockClosure)>>on:do:
MetacelloScriptEngine>>handleNotificationsForAction:
[ 
      self
        handleNotificationsForAction: [ 
          | version loadedSpec |
          self setDefaultsAndValidateProjectSpec.
          [ loadedSpec := (self lookupProjectSpecFor: self projectSpec) copy ]
            on: MetacelloAllowProjectDowngrade , MetacelloAllowProjectUpgrade
            do: [ :ex | ex handleOnDownGrade: onDownGradeBlock onUpgrade: onUpgradeBlock ].
          version := loadedSpec versionForScriptEngine: self.
          self
            root:
              (required isEmpty
                ifTrue: [ version load ]
                ifFalse: [ version load: required ]) loadDirective.
          loadedSpec loads: required.
          MetacelloProjectRegistration
            registrationForProjectSpec: loadedSpec
            ifAbsent: [ :new | 
              new
                loadedInImage: true;
                registerProject ]
            ifPresent: [ :existing :new | 
              existing
                copyOnWrite: [ :existingCopy | 
                  existingCopy
                    loadedInImage: true;
                    merge: new ] ] ] ] in MetacelloScriptEngine>>load:onProjectDownGrade:onProjectUpgrade:
FullBlockClosure(BlockClosure)>>ensure:
MetacelloProjectRegistration class>>copyRegistryRestoreOnErrorWhile:
MetacelloScriptEngine>>load:onProjectDownGrade:onProjectUpgrade:
MetacelloScriptEngine>>load:
[ :projectSpec | 
      | engine |
      engine := MetacelloScriptEngine new
        options: self options copy;
        projectSpec: projectSpec;
        yourself.
      engine perform: actionArg key withArguments: actionArg value.
      engine root ifNotNil: [ :root | self roots add: root ] ] in MetacelloScriptApiExecutor(MetacelloScriptExecutor)>>execute:
[ :projectSpec | 
      projectSpec
        ifNotNil: [ projectSpecBlock value: (self applyArgsToProjectSpec: projectSpec copy) ] ] in MetacelloScriptApiExecutor>>executeString:do:
Array(SequenceableCollection)>>do:
MetacelloScriptApiExecutor>>executeString:do:
ByteString(String)>>execute:against:
MetacelloScriptApiExecutor(MetacelloScriptExecutor)>>execute:
[ 
		super execute: statements ] in MetacelloScriptApiExecutor>>execute:
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in IceMetacelloLoadSessionContext(DynamicVariable)>>value:during:
FullBlockClosure(BlockClosure)>>ensure:
IceMetacelloLoadSessionContext(DynamicVariable)>>value:during:
IceMetacelloLoadSessionContext class(DynamicVariable class)>>value:during:
IceMetacelloPharoPlatform>>withMetacelloLoadSessionDo:
MetacelloScriptApiExecutor>>execute:
Metacello>>execute:args:
Metacello>>load
UndefinedObject>>DoIt
OCReceiverDoItSemanticScope(OCDoItSemanticScope)>>evaluateDoIt:
OpalCompiler>>evaluate
[
		self announcer announce: (SpCodeWillBeEvaluatedAnnouncement newContent: aString).
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionModel doItReceiver.
		result := receiver class compiler
			source: aString;
			context: self interactionModel doItContext;
			receiver: self interactionModel doItReceiver;
			requestor: self interactionModel;
			environment: self environment;
			failBlock:  [ 
				self announcer announce: (SpCodeEvaluationFailedAnnouncement newContent: aString).
				^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		self announcer announce: (SpCodeEvaluationSucceedAnnouncement newContent: aString).
		result ] in SpCodePresenter>>evaluate:onCompileError:onError:
FullBlockClosure(BlockClosure)>>on:do:
SpCodePresenter>>evaluate:onCompileError:onError:
StPlaygroundPagePresenter>>doEvaluateAndGo
StPlaygroundPagePresenter>>doEvaluateAllAndGo
StPlaygroundDoItCommand>>execute
SpCommand(CmCommandDecorator)>>execute
[ specCommand execute ] in [ :specCommand | 
			aButtonClass new
				label: specCommand name;
				help: specCommand description;
				in: [ :button | 
					specCommand hasIcon
						ifTrue: [ button icon: specCommand icon ] ];
				action: [ specCommand execute ];
				yourself ] in SpCommand>>configureAsButtonOfClass:
FullBlockClosure(BlockClosure)>>cull:
SpMorphicToolbarButtonAdapter>>execute
SpToolbarButtonMorph(PluggableButtonMorph)>>performAction:
[:m |
		(m containsPoint: evt cursorPoint) ifTrue: [m enabled ifTrue: [ m performAction: evt ]]] in SpToolbarButtonMorph(PluggableButtonMorph)>>mouseUp:
Array(SequenceableCollection)>>do:
SpToolbarButtonMorph(PluggableButtonMorph)>>mouseUp:
SpToolbarButtonMorph(Morph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
SpToolbarButtonMorph(Morph)>>handleEvent:
SpToolbarButtonMorph(Morph)>>handleFocusEvent:
[
		result := focusHolder handleFocusEvent: transformedEvent.
	] in HandMorph>>sendFocusEvent:to:clear:
FullBlockClosure(BlockClosure)>>on:do:
WorldMorph>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil ]) ifTrue: [
			morphicWorld activeHand handleEvent: anEvent
		]
	] in OSWindowMorphicEventHandler>>dispatchMorphicEvent:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycleNow
WorldMorph>>doOneCycle
[
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMutex critical: [
			                     self extraWorldList ].
		extraWorldsToDraw do: [ :world | world doOneCycle ].

		(self currentWorld isNotNil and: [
			 (extraWorldsToDraw includes: self currentWorld) not ]) ifTrue: [
			self currentWorld doOneCycle ] ] in WorldMorph class>>doOneCycle
FullBlockClosure(BlockClosure)>>ensure:
WorldState class>>doDrawCycleWith:
WorldMorph class>>doOneCycle
MorphicRenderLoop>>doOneCycle
MorphicRenderLoop>>doOneCycleWhile:
[ MorphicRenderLoop new doOneCycleWhile: [ true ] ] in MorphicUIManager>>spawnNewProcess
[self value.
			"IMPORTANT: Do not step over next line of code. See method comments for details"
			Processor terminateRealActive] in FullBlockClosure(BlockClosure)>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
Could not resolve: BaselineOfJSON [BaselineOfJSON] in /Users/ryanperez/Documents/Pharo/images/Visualizer/pharo-local/package-cache https://github.com/SvenVC/NeoJSON.git[master]
23 October 2023 11:03:38.317776 pm

VM: Mac OS - arm64 - 1000 - CoInterpreter VMMaker-tonel.1 uuid: 902dd483-c0c4-0d00-86f2-0f880df24b96 Oct 23 2023
StackToRegisterMappingCogit VMMaker-tonel.1 uuid: 902dd483-c0c4-0d00-86f2-0f880df24b96 Oct 23 2023
v10.0.8 - Commit: b323c5fb - Date: 2023-10-20 16:02:07 -0400

Image: Pharo11.0.0 [Build information: Pharo-11.0.0+build.710.sha.ea28d8552cac85a7ce1e9c34ab1e7bd45f7b9910 (64 Bit)]

MetacelloFetchingMCSpecLoader(MetacelloCommonMCSpecLoader)>>retryingResolvePackageSpecReferences:gofer:
	Receiver: a MetacelloFetchingMCSpecLoader(explicit load : BaselineOfJSON)
	Arguments and temporary variables: 
		packageSpec: 	spec 
	name: 'BaselineOfJSON';
	repository: 'github://svenvc/N[..]
		gofer: 	a MetacelloGofer
		references: 	#()
		retryCount: 	3
		repositoryError: 	nil
	Receiver's instance variables: 
		spec: 	spec 
	name: 'BaselineOfJSON';
	repository: 'github://svenvc/NeoJSON/[..]
		operator: 	nil
		loaderPolicy: 	a MetacelloLoaderPolicy
		disablePackageCache: 	false


[ 
      | references nearestReference cachedReference externalReference mcVersion loadedVersionInfos |
      cachedReference := nil.
      packageSpec
        searchCacheRepositoryForPackage: [ 
          "check to see if mcz file is already in cacheRepository"
          cachedReference := self
            resolvePackageSpec: packageSpec
            cachedGofer: self loaderPolicy cacheGofer.
          (cachedReference ~~ nil and: [ packageSpec getFile ~~ nil ])
            ifTrue: [ 
              cachedReference name = packageSpec file
                ifTrue: [ 
                  "exact match between packageSpec file and cache"
                  ^ self
                    scheduleFetchFor: packageSpec
                    cachedReference: cachedReference ] ] ].
      references := self
        retryingResolvePackageSpecReferences: packageSpec
        gofer: gofer.	"look up mcz file"
      nearestReference := references last asMetacelloCachingResolvedReference.
      (cachedReference ~~ nil
        and: [ cachedReference name = nearestReference name ])
        ifTrue: [ 
          "latest reference in repository matches cachedReference ... "
          ^ self
            scheduleFetchFor: packageSpec
            nearestReference: nearestReference ].
      (self ignoreImage not
        and: [ (loadedVersionInfos := self ancestorsFor: packageSpec) ~~ nil ])
        ifTrue: [ 
          "If the mcz is already loaded into the image, no need to copy"
          loadedVersionInfos
            do: [ :info | 
              info name = nearestReference name
                ifTrue: [ 
                  | spc |
                  spc := packageSpec copy.
                  spc file: info name.
                  (MetacelloIgnorePackageLoaded signal: spc)
                    ifFalse: [ ^ self ] ] ] ].
      externalReference := (references
        select: [ :ref | ref name = nearestReference name ]) first
        asMetacelloCachingResolvedReference.
      self repositoryMap
        at: externalReference name
        put: externalReference repository.
      (self
        resolveDependencies: externalReference
        nearest: nearestReference
        into: (OrderedCollection with: nearestReference))
        do: [ :reference | 
          | pSpec l |
          mcVersion := reference version.
          (l := (GoferVersionReference name: reference name)
            resolveAllWith: self loaderPolicy cacheGofer) isEmpty
            ifTrue: [ 
              self cacheRepository storeVersion: mcVersion.
              reference == nearestReference
                ifTrue: [ pSpec := packageSpec ]
                ifFalse: [ 
                  pSpec := packageSpec project packageSpec.
                  pSpec name: mcVersion package name ].
              self loadData
                addVersion: mcVersion
                versionInfo: mcVersion info
                resolvedReference: reference
                packageSpec: pSpec ] ].
      self scheduleFetchFor: packageSpec externalReference: externalReference ] in MetacelloFetchingMCSpecLoader>>linearLoadPackageSpec:gofer:
	Receiver: a MetacelloFetchingMCSpecLoader(explicit load : BaselineOfJSON)
	Arguments and temporary variables: 
		packageSpec: 	spec 
	name: 'BaselineOfJSON';
	repository: 'github://svenvc/N[..]
		gofer: 	a MetacelloGofer
		cachedReference: 	nil
		mcVersion: 	nil
		references: 	nil
		nearestReference: 	nil
		externalReference: 	nil
		loadedVersionInfos: 	nil
	Receiver's instance variables: 
		spec: 	spec 
	name: 'BaselineOfJSON';
	repository: 'github://svenvc/NeoJSON/[..]
		operator: 	nil
		loaderPolicy: 	a MetacelloLoaderPolicy
		disablePackageCache: 	false


[:bar |
            bar value: 1.
            aBlock value.
            bar value: 2 ] in IceMetacelloPharoPlatform(MetacelloPharoCommonPlatform)>>do:displaying:
	Receiver: an IceMetacelloPharoPlatform
	Arguments and temporary variables: 
		aBlock: 	[ 
      | references nearestReference cachedReference externalRefe[..]
		aString: 	'Fetching BaselineOfJSON'
		bar: 	a Job
	Receiver's instance variables: 
		bypassProgressBars: 	false
		bypassGoferLoadUpdateCategories: 	false


FullBlockClosure(BlockClosure)>>cull:
	Receiver: [:bar |
            bar value: 1.
            aBlock value.
            bar value: 2 ]
	Arguments and temporary variables: 
		anArg: 	a Job
	Receiver's instance variables: 
		outerContext: 	IceMetacelloPharoPlatform(MetacelloPharoCommonPlatform)>>do:d[..]
		compiledBlock: 	a CompiledBlock: [:bar |
            bar value: 1.
         [..]
		numArgs: 	1
		receiver: 	an IceMetacelloPharoPlatform


[ ^ block cull: self ] in [ self prepareForRunning.
	  CurrentJob value: self during: [ ^ block cull: self ] ] in Job>>run
	Receiver: a Job
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		block: 	[:bar |
            bar value: 1.
            aBlock value.
        [..]
		currentValue: 	1
		min: 	0
		max: 	2
		title: 	'Fetching BaselineOfJSON'
		children: 	an OrderedCollection()
		isRunning: 	true
		parent: 	nil
		process: 	a Process in nil
		owner: 	a MorphicUIManager


[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in CurrentJob(DynamicVariable)>>value:during:
	Receiver: a CurrentJob
	Arguments and temporary variables: 
		anObject: 	a Job
		aBlock: 	[ ^ block cull: self ]
		activeProcess: 	a Process in nil
		oldValue: 	nil
	Receiver's instance variables: 
		index: 	2


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ]
	Arguments and temporary variables: 
		aBlock: 	[
			activeProcess
				psValueAt: index
				put: oldValue ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	CurrentJob(DynamicVariable)>>value:during:
		compiledBlock: 	a CompiledBlock: [ activeProcess
			psValueAt: index
			put:[..]
		numArgs: 	0
		receiver: 	a CurrentJob


CurrentJob(DynamicVariable)>>value:during:
	Receiver: a CurrentJob
	Arguments and temporary variables: 
		anObject: 	a Job
		aBlock: 	[ ^ block cull: self ]
		activeProcess: 	a Process in nil
		oldValue: 	nil
	Receiver's instance variables: 
		index: 	2


CurrentJob class(DynamicVariable class)>>value:during:
	Receiver: CurrentJob
	Arguments and temporary variables: 
		anObject: 	a Job
		aBlock: 	[ ^ block cull: self ]
	Receiver's instance variables: 
		superclass: 	DynamicVariable
		methodDict: 	a MethodDictionary()
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		commentSourcePointer: 	nil
		subclasses: 	nil
		name: 	#CurrentJob
		classPool: 	nil
		sharedPools: 	nil
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Jobs-Base'
		soleInstance: 	a CurrentJob


[ self prepareForRunning.
	  CurrentJob value: self during: [ ^ block cull: self ] ] in Job>>run
	Receiver: a Job
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		block: 	[:bar |
            bar value: 1.
            aBlock value.
        [..]
		currentValue: 	1
		min: 	0
		max: 	2
		title: 	'Fetching BaselineOfJSON'
		children: 	an OrderedCollection()
		isRunning: 	true
		parent: 	nil
		process: 	a Process in nil
		owner: 	a MorphicUIManager


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ self prepareForRunning.
	  CurrentJob value: self during: [ ^ block cull: self ] ]
	Arguments and temporary variables: 
		aBlock: 	[ self cleanupAfterRunning ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	Job>>run
		compiledBlock: 	a CompiledBlock: [ self prepareForRunning.
	  CurrentJob val[..]
		numArgs: 	0
		receiver: 	a Job


Job>>run
	Receiver: a Job
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		block: 	[:bar |
            bar value: 1.
            aBlock value.
        [..]
		currentValue: 	1
		min: 	0
		max: 	2
		title: 	'Fetching BaselineOfJSON'
		children: 	an OrderedCollection()
		isRunning: 	true
		parent: 	nil
		process: 	a Process in nil
		owner: 	a MorphicUIManager


MorphicUIManager(UIManager)>>displayProgress:from:to:during:
	Receiver: a MorphicUIManager
	Arguments and temporary variables: 
		titleString: 	'Fetching BaselineOfJSON'
		minVal: 	0
		maxVal: 	2
		workBlock: 	[:bar |
            bar value: 1.
            aBlock value.
    [..]
	Receiver's instance variables: 
		activeTranscript: 	nil


ByteString(String)>>displayProgressFrom:to:during:
	Receiver: 'Fetching BaselineOfJSON'
	Arguments and temporary variables: 
		minVal: 	0
		maxVal: 	2
		workBlock: 	[:bar |
            bar value: 1.
            aBlock value.
    [..]
	Receiver's instance variables: 
'Fetching BaselineOfJSON'

IceMetacelloPharoPlatform(MetacelloPharoCommonPlatform)>>do:displaying:
	Receiver: an IceMetacelloPharoPlatform
	Arguments and temporary variables: 
		aBlock: 	[ 
      | references nearestReference cachedReference externalRefe[..]
		aString: 	'Fetching BaselineOfJSON'
	Receiver's instance variables: 
		bypassProgressBars: 	false
		bypassGoferLoadUpdateCategories: 	false


MetacelloFetchingMCSpecLoader>>linearLoadPackageSpec:gofer:
	Receiver: a MetacelloFetchingMCSpecLoader(explicit load : BaselineOfJSON)
	Arguments and temporary variables: 
		packageSpec: 	spec 
	name: 'BaselineOfJSON';
	repository: 'github://svenvc/N[..]
		gofer: 	a MetacelloGofer
	Receiver's instance variables: 
		spec: 	spec 
	name: 'BaselineOfJSON';
	repository: 'github://svenvc/NeoJSON/[..]
		operator: 	nil
		loaderPolicy: 	a MetacelloLoaderPolicy
		disablePackageCache: 	false


MetacelloPackageSpec>>loadUsing:gofer:
	Receiver: spec 
	name: 'BaselineOfJSON';
	repository: 'github://svenvc/NeoJSON/repository'.
	Arguments and temporary variables: 
		aLoader: 	a MetacelloFetchingMCSpecLoader(explicit load : BaselineOfJSON)
		gofer: 	a MetacelloGofer
	Receiver's instance variables: 
		project: 	<<error during printing>>

[:pkg | pkg loadUsing: self gofer: gofer ] in MetacelloFetchingMCSpecLoader(MetacelloCommonMCSpecLoader)>>linearLoadPackageSpecs:repositories:
	Receiver: a MetacelloFetchingMCSpecLoader(explicit load : BaselineOfJSON)
	Arguments and temporary variables: 
		packageSpecs: 	an Array(spec 
	name: 'BaselineOfJSON';
	repository: 'github:[..]
		repositories: 	an OrderedCollection(an IceMetacelloRepositoryAdapter)
		gofer: 	a MetacelloGofer
		pkg: 	spec 
	name: 'BaselineOfJSON';
	repository: 'github://svenvc/NeoJSON/r[..]
	Receiver's instance variables: 
		spec: 	spec 
	name: 'BaselineOfJSON';
	repository: 'github://svenvc/NeoJSON/[..]
		operator: 	nil
		loaderPolicy: 	a MetacelloLoaderPolicy
		disablePackageCache: 	false


Array(SequenceableCollection)>>do:
	Receiver: an Array(spec 
	name: 'BaselineOfJSON';
	repository: 'github://svenvc/NeoJSON/reposito[..]
	Arguments and temporary variables: 
		aBlock: 	[:pkg | pkg loadUsing: self gofer: gofer ]
		index: 	1
	Receiver's instance variables: 
an Array(spec 
	name: 'BaselineOfJSON';
	repository: 'github://svenvc/NeoJSON/reposito[..]

MetacelloFetchingMCSpecLoader(MetacelloCommonMCSpecLoader)>>linearLoadPackageSpecs:repositories:
	Receiver: a MetacelloFetchingMCSpecLoader(explicit load : BaselineOfJSON)
	Arguments and temporary variables: 
		packageSpecs: 	an Array(spec 
	name: 'BaselineOfJSON';
	repository: 'github:[..]
		repositories: 	an OrderedCollection(an IceMetacelloRepositoryAdapter)
		gofer: 	a MetacelloGofer
	Receiver's instance variables: 
		spec: 	spec 
	name: 'BaselineOfJSON';
	repository: 'github://svenvc/NeoJSON/[..]
		operator: 	nil
		loaderPolicy: 	a MetacelloLoaderPolicy
		disablePackageCache: 	false


[ super linearLoadPackageSpecs: packageSpecs repositories: repositories ] in MetacelloFetchingMCSpecLoader>>explicitLoadPackageSpecs:repositories:
	Receiver: a MetacelloFetchingMCSpecLoader(explicit load : BaselineOfJSON)
	Arguments and temporary variables: 
		packageSpecs: 	an Array(spec 
	name: 'BaselineOfJSON';
	repository: 'github:[..]
		repositories: 	an OrderedCollection(an IceMetacelloRepositoryAdapter)
		directive: 	nil
	Receiver's instance variables: 
		spec: 	spec 
	name: 'BaselineOfJSON';
	repository: 'github://svenvc/NeoJSON/[..]
		operator: 	nil
		loaderPolicy: 	a MetacelloLoaderPolicy
		disablePackageCache: 	false


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ super linearLoadPackageSpecs: packageSpecs repositories: repositories ]
	Arguments and temporary variables: 
		aBlock: 	[ loadDirective := oldRoot ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	MetacelloFetchingMCSpecLoader>>explicitLoadPackageSpecs:repos[..]
		compiledBlock: 	a CompiledBlock: [ super linearLoadPackageSpecs: packageSpec[..]
		numArgs: 	0
		receiver: 	a MetacelloFetchingMCSpecLoader(explicit load : BaselineOfJSON)


MetacelloLoaderPolicy>>pushLoadDirective:during:
	Receiver: a MetacelloLoaderPolicy
	Arguments and temporary variables: 
		aLoaderDirective: 	explicit load : BaselineOfJSON
		aBlock: 	[ super linearLoadPackageSpecs: packageSpecs repositories: reposito[..]
		oldRoot: 	linear load : 
	explicit load : BaselineOfJSON
	Receiver's instance variables: 
		overrideRepositories: 	nil
		repositoryMap: 	a Dictionary()
		ensuredMap: 	a Dictionary()
		cacheRepository: 	a MCDictionaryRepository(cache)
		cacheGofer: 	a Gofer
		ignoreImage: 	false
		loadData: 	nil
		loadDirective: 	explicit load : BaselineOfJSON
		silently: 	nil


MetacelloLoaderPolicy>>pushExplicitLoadDirectivesDuring:for:
	Receiver: a MetacelloLoaderPolicy
	Arguments and temporary variables: 
		aBlock: 	[ super linearLoadPackageSpecs: packageSpecs repositories: reposito[..]
		aLoader: 	a MetacelloFetchingMCSpecLoader(explicit load : BaselineOfJSON)
		directive: 	explicit load : BaselineOfJSON
	Receiver's instance variables: 
		overrideRepositories: 	nil
		repositoryMap: 	a Dictionary()
		ensuredMap: 	a Dictionary()
		cacheRepository: 	a MCDictionaryRepository(cache)
		cacheGofer: 	a Gofer
		ignoreImage: 	false
		loadData: 	nil
		loadDirective: 	explicit load : BaselineOfJSON
		silently: 	nil


MetacelloFetchingMCSpecLoader>>explicitLoadPackageSpecs:repositories:
	Receiver: a MetacelloFetchingMCSpecLoader(explicit load : BaselineOfJSON)
	Arguments and temporary variables: 
		packageSpecs: 	an Array(spec 
	name: 'BaselineOfJSON';
	repository: 'github:[..]
		repositories: 	an OrderedCollection(an IceMetacelloRepositoryAdapter)
		directive: 	nil
	Receiver's instance variables: 
		spec: 	spec 
	name: 'BaselineOfJSON';
	repository: 'github://svenvc/NeoJSON/[..]
		operator: 	nil
		loaderPolicy: 	a MetacelloLoaderPolicy
		disablePackageCache: 	false


MetacelloPackageSpec>>explicitLoadUsing:
	Receiver: spec 
	name: 'BaselineOfJSON';
	repository: 'github://svenvc/NeoJSON/repository'.
	Arguments and temporary variables: 
		mcLoader: 	a MetacelloLoadingMCSpecLoader
		wc: 	nil
		fetchingSpecLoader: 	a MetacelloFetchingMCSpecLoader(explicit load : Baselin[..]
	Receiver's instance variables: 
		project: 	<<error during printing>>

MetacelloPackageSpec>>load
	Receiver: spec 
	name: 'BaselineOfJSON';
	repository: 'github://svenvc/NeoJSON/repository'.
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		project: 	<<error during printing>>

[ spec projectPackage load ] in MetacelloScriptEngine>>getBaselineUnconditionalLoad:
	Receiver: a MetacelloScriptEngine
	Arguments and temporary variables: 
		unconditionalLoad: 	true
		spec: 	spec 
	name: 'JSON';
	repository: 'github://svenvc/NeoJSON/repository'.
	Receiver's instance variables: 
		root: 	nil
		projectSpec: 	spec 
	name: 'JSON';
	repository: 'github://svenvc/NeoJSON/rep[..]
		options: 	a Dictionary()


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [ spec projectPackage load ]
	Arguments and temporary variables: 
		exception: 	MetacelloIgnorePackageLoaded
		handlerAction: 	[ :ex | 
      "see https://github.com/dalehenrich/metacello[..]
	Receiver's instance variables: 
		outerContext: 	MetacelloScriptEngine>>getBaselineUnconditionalLoad:
		compiledBlock: 	a CompiledBlock: [ spec projectPackage load ]
		numArgs: 	0
		receiver: 	a MetacelloScriptEngine


MetacelloScriptEngine>>getBaselineUnconditionalLoad:
	Receiver: a MetacelloScriptEngine
	Arguments and temporary variables: 
		unconditionalLoad: 	true
		spec: 	spec 
	name: 'JSON';
	repository: 'github://svenvc/NeoJSON/repository'.
	Receiver's instance variables: 
		root: 	nil
		projectSpec: 	spec 
	name: 'JSON';
	repository: 'github://svenvc/NeoJSON/rep[..]
		options: 	a Dictionary()


MetacelloScriptEngine>>getBaselineProjectUnconditionalLoad:
	Receiver: a MetacelloScriptEngine
	Arguments and temporary variables: 
		unconditionalLoad: 	true
		project: 	nil
	Receiver's instance variables: 
		root: 	nil
		projectSpec: 	spec 
	name: 'JSON';
	repository: 'github://svenvc/NeoJSON/rep[..]
		options: 	a Dictionary()


MetacelloMCBaselineProject>>projectForScriptEngine:unconditionalLoad:
	Receiver: <<error during printing>>
	Arguments and temporary variables: 
		aMetacelloScriptEngine: 	a MetacelloScriptEngine
		aBool: 	false
	Receiver's instance variables: 
		versionMap: 	nil
		symbolicVersionMap: 	nil
		errorMap: 	nil
		loader: 	nil
		loaderClass: 	MetacelloLoadingMCSpecLoader
		loadType: 	nil
		configuration: 	<<error during printing>>

MetacelloMCBaselineProject(MetacelloProject)>>projectForScriptEngine:
	Receiver: <<error during printing>>
	Arguments and temporary variables: 
		aMetacelloScriptEngine: 	a MetacelloScriptEngine
	Receiver's instance variables: 
		versionMap: 	nil
		symbolicVersionMap: 	nil
		errorMap: 	nil
		loader: 	nil
		loaderClass: 	MetacelloLoadingMCSpecLoader
		loadType: 	nil
		configuration: 	<<error during printing>>

MetacelloMCBaselineOfProjectSpec(MetacelloMCProjectSpec)>>versionForScriptEngine:
	Receiver: spec 
	name: 'JSON';
	repository: 'github://svenvc/NeoJSON/repository'.
	Arguments and temporary variables: 
<<error during printing>>
	Receiver's instance variables: 
		project: 	<<error during printing>>

[ 
          | version loadedSpec |
          self setDefaultsAndValidateProjectSpec.
          [ loadedSpec := (self lookupProjectSpecFor: self projectSpec) copy ]
            on: MetacelloAllowProjectDowngrade , MetacelloAllowProjectUpgrade
            do: [ :ex | ex handleOnDownGrade: onDownGradeBlock onUpgrade: onUpgradeBlock ].
          version := loadedSpec versionForScriptEngine: self.
          self
            root:
              (required isEmpty
                ifTrue: [ version load ]
                ifFalse: [ version load: required ]) loadDirective.
          loadedSpec loads: required.
          MetacelloProjectRegistration
            registrationForProjectSpec: loadedSpec
            ifAbsent: [ :new | 
              new
                loadedInImage: true;
                registerProject ]
            ifPresent: [ :existing :new | 
              existing
                copyOnWrite: [ :existingCopy | 
                  existingCopy
                    loadedInImage: true;
                    merge: new ] ] ] in [ 
      self
        handleNotificationsForAction: [ 
          | version loadedSpec |
          self setDefaultsAndValidateProjectSpec.
          [ loadedSpec := (self lookupProjectSpecFor: self projectSpec) copy ]
            on: MetacelloAllowProjectDowngrade , MetacelloAllowProjectUpgrade
            do: [ :ex | ex handleOnDownGrade: onDownGradeBlock onUpgrade: onUpgradeBlock ].
          version := loadedSpec versionForScriptEngine: self.
          self
            root:
              (required isEmpty
                ifTrue: [ version load ]
                ifFalse: [ version load: required ]) loadDirective.
          loadedSpec loads: required.
          MetacelloProjectRegistration
            registrationForProjectSpec: loadedSpec
            ifAbsent: [ :new | 
              new
                loadedInImage: true;
                registerProject ]
            ifPresent: [ :existing :new | 
              existing
                copyOnWrite: [ :existingCopy | 
                  existingCopy
                    loadedInImage: true;
                    merge: new ] ] ] ] in MetacelloScriptEngine>>load:onProjectDownGrade:onProjectUpgrade:
	Receiver: a MetacelloScriptEngine
	Arguments and temporary variables: 
		required: 	#()
		onDownGradeBlock: 	[ :ex :existing :new | ex allowEvenIfLocked ]
		onUpgradeBlock: 	[ :ex :existing :new | ex allowEvenIfLocked ]
		loadedSpec: 	spec 
	name: 'JSON';
	repository: 'github://svenvc/NeoJSON/repo[..]
		version: 	nil
	Receiver's instance variables: 
		root: 	nil
		projectSpec: 	spec 
	name: 'JSON';
	repository: 'github://svenvc/NeoJSON/rep[..]
		options: 	a Dictionary()


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [ 
          | version loadedSpec |
          self setDefaultsAndValidateProjectSpec.
[..]
	Arguments and temporary variables: 
		exception: 	an ExceptionSet
		handlerAction: 	[ :ex | 
      "lookup and registration handlers need to be [..]
	Receiver's instance variables: 
		outerContext: 	[ 
      self
        handleNotificationsForAction: [ 
      [..]
		compiledBlock: 	a CompiledBlock: [ 
          | version loadedSpec |
       [..]
		numArgs: 	0
		receiver: 	a MetacelloScriptEngine


[ 
  actionBlock
    on:
      MetacelloLookupProjectSpec , MetacelloLookupProjectSpecForLoad
        , MetacelloProjectSpecLoadedNotification
        , MetacelloScriptEnsureProjectLoadedForDevelopment
        , MetacelloLookupBaselineSpecForEnsureLoad
    do: [ :ex | 
      "lookup and registration handlers need to be innermost set of handlers ...they may throw option notifications"
      ex handleResolutionFor: self ] ] in [ 
  [ 
  actionBlock
    on:
      MetacelloLookupProjectSpec , MetacelloLookupProjectSpecForLoad
        , MetacelloProjectSpecLoadedNotification
        , MetacelloScriptEnsureProjectLoadedForDevelopment
        , MetacelloLookupBaselineSpecForEnsureLoad
    do: [ :ex | 
      "lookup and registration handlers need to be innermost set of handlers ...they may throw option notifications"
      ex handleResolutionFor: self ] ]
    on:
      MetacelloAllowProjectDowngrade , MetacelloAllowProjectUpgrade
        , MetacelloAllowConflictingProjectUpgrade
    do: [ :ex | 
      "option handlers need to be outermost set of handlers ... last line of defense before users are involved"
      ex handleResolutionFor: self ] ] in [ 
  [ 
  [ 
  actionBlock
    on:
      MetacelloLookupProjectSpec , MetacelloLookupProjectSpecForLoad
        , MetacelloProjectSpecLoadedNotification
        , MetacelloScriptEnsureProjectLoadedForDevelopment
        , MetacelloLookupBaselineSpecForEnsureLoad
    do: [ :ex | 
      "lookup and registration handlers need to be innermost set of handlers ...they may throw option notifications"
      ex handleResolutionFor: self ] ]
    on:
      MetacelloAllowProjectDowngrade , MetacelloAllowProjectUpgrade
        , MetacelloAllowConflictingProjectUpgrade
    do: [ :ex | 
      "option handlers need to be outermost set of handlers ... last line of defense before users are involved"
      ex handleResolutionFor: self ] ]
    on: MetacelloAllowLockedProjectChange
    do: [ :ex | 
      "MetacelloAllowLockedProjectChange need to be outermost handler ... since it is signaled from second line of handlers"
      ex handleResolutionFor: self ] ] in MetacelloScriptEngine>>handleNotificationsForAction:
	Receiver: a MetacelloScriptEngine
	Arguments and temporary variables: 
		actionBlock: 	[ 
          | version loadedSpec |
          self setDefaults[..]
	Receiver's instance variables: 
		root: 	nil
		projectSpec: 	spec 
	name: 'JSON';
	repository: 'github://svenvc/NeoJSON/rep[..]
		options: 	a Dictionary()


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [ 
  actionBlock
    on:
      MetacelloLookupProjectSpec , MetacelloLookupProjectSpec[..]
	Arguments and temporary variables: 
		exception: 	an ExceptionSet
		handlerAction: 	[ :ex | 
      "option handlers need to be outermost set of [..]
	Receiver's instance variables: 
		outerContext: 	[ 
  [ 
  actionBlock
    on:
      MetacelloLookupProjectSpe[..]
		compiledBlock: 	a CompiledBlock: [ 
  actionBlock
    on:
      MetacelloLoo[..]
		numArgs: 	0
		receiver: 	a MetacelloScriptEngine


[ 
  [ 
  actionBlock
    on:
      MetacelloLookupProjectSpec , MetacelloLookupProjectSpecForLoad
        , MetacelloProjectSpecLoadedNotification
        , MetacelloScriptEnsureProjectLoadedForDevelopment
        , MetacelloLookupBaselineSpecForEnsureLoad
    do: [ :ex | 
      "lookup and registration handlers need to be innermost set of handlers ...they may throw option notifications"
      ex handleResolutionFor: self ] ]
    on:
      MetacelloAllowProjectDowngrade , MetacelloAllowProjectUpgrade
        , MetacelloAllowConflictingProjectUpgrade
    do: [ :ex | 
      "option handlers need to be outermost set of handlers ... last line of defense before users are involved"
      ex handleResolutionFor: self ] ] in [ 
  [ 
  [ 
  actionBlock
    on:
      MetacelloLookupProjectSpec , MetacelloLookupProjectSpecForLoad
        , MetacelloProjectSpecLoadedNotification
        , MetacelloScriptEnsureProjectLoadedForDevelopment
        , MetacelloLookupBaselineSpecForEnsureLoad
    do: [ :ex | 
      "lookup and registration handlers need to be innermost set of handlers ...they may throw option notifications"
      ex handleResolutionFor: self ] ]
    on:
      MetacelloAllowProjectDowngrade , MetacelloAllowProjectUpgrade
        , MetacelloAllowConflictingProjectUpgrade
    do: [ :ex | 
      "option handlers need to be outermost set of handlers ... last line of defense before users are involved"
      ex handleResolutionFor: self ] ]
    on: MetacelloAllowLockedProjectChange
    do: [ :ex | 
      "MetacelloAllowLockedProjectChange need to be outermost handler ... since it is signaled from second line of handlers"
      ex handleResolutionFor: self ] ] in MetacelloScriptEngine>>handleNotificationsForAction:
	Receiver: a MetacelloScriptEngine
	Arguments and temporary variables: 
		actionBlock: 	[ 
          | version loadedSpec |
          self setDefaults[..]
	Receiver's instance variables: 
		root: 	nil
		projectSpec: 	spec 
	name: 'JSON';
	repository: 'github://svenvc/NeoJSON/rep[..]
		options: 	a Dictionary()



--- The full stack ---
MetacelloFetchingMCSpecLoader(MetacelloCommonMCSpecLoader)>>retryingResolvePackageSpecReferences:gofer:
[ 
      | references nearestReference cachedReference externalReference mcVersion loadedVersionInfos |
      cachedReference := nil.
      packageSpec
        searchCacheRepositoryForPackage: [ 
          "check to see if mcz file is already in cacheRepository"
          cachedReference := self
            resolvePackageSpec: packageSpec
            cachedGofer: self loaderPolicy cacheGofer.
          (cachedReference ~~ nil and: [ packageSpec getFile ~~ nil ])
            ifTrue: [ 
              cachedReference name = packageSpec file
                ifTrue: [ 
                  "exact match between packageSpec file and cache"
                  ^ self
                    scheduleFetchFor: packageSpec
                    cachedReference: cachedReference ] ] ].
      references := self
        retryingResolvePackageSpecReferences: packageSpec
        gofer: gofer.	"look up mcz file"
      nearestReference := references last asMetacelloCachingResolvedReference.
      (cachedReference ~~ nil
        and: [ cachedReference name = nearestReference name ])
        ifTrue: [ 
          "latest reference in repository matches cachedReference ... "
          ^ self
            scheduleFetchFor: packageSpec
            nearestReference: nearestReference ].
      (self ignoreImage not
        and: [ (loadedVersionInfos := self ancestorsFor: packageSpec) ~~ nil ])
        ifTrue: [ 
          "If the mcz is already loaded into the image, no need to copy"
          loadedVersionInfos
            do: [ :info | 
              info name = nearestReference name
                ifTrue: [ 
                  | spc |
                  spc := packageSpec copy.
                  spc file: info name.
                  (MetacelloIgnorePackageLoaded signal: spc)
                    ifFalse: [ ^ self ] ] ] ].
      externalReference := (references
        select: [ :ref | ref name = nearestReference name ]) first
        asMetacelloCachingResolvedReference.
      self repositoryMap
        at: externalReference name
        put: externalReference repository.
      (self
        resolveDependencies: externalReference
        nearest: nearestReference
        into: (OrderedCollection with: nearestReference))
        do: [ :reference | 
          | pSpec l |
          mcVersion := reference version.
          (l := (GoferVersionReference name: reference name)
            resolveAllWith: self loaderPolicy cacheGofer) isEmpty
            ifTrue: [ 
              self cacheRepository storeVersion: mcVersion.
              reference == nearestReference
                ifTrue: [ pSpec := packageSpec ]
                ifFalse: [ 
                  pSpec := packageSpec project packageSpec.
                  pSpec name: mcVersion package name ].
              self loadData
                addVersion: mcVersion
                versionInfo: mcVersion info
                resolvedReference: reference
                packageSpec: pSpec ] ].
      self scheduleFetchFor: packageSpec externalReference: externalReference ] in MetacelloFetchingMCSpecLoader>>linearLoadPackageSpec:gofer:
[:bar |
            bar value: 1.
            aBlock value.
            bar value: 2 ] in IceMetacelloPharoPlatform(MetacelloPharoCommonPlatform)>>do:displaying:
FullBlockClosure(BlockClosure)>>cull:
[ ^ block cull: self ] in [ self prepareForRunning.
	  CurrentJob value: self during: [ ^ block cull: self ] ] in Job>>run
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in CurrentJob(DynamicVariable)>>value:during:
FullBlockClosure(BlockClosure)>>ensure:
CurrentJob(DynamicVariable)>>value:during:
CurrentJob class(DynamicVariable class)>>value:during:
[ self prepareForRunning.
	  CurrentJob value: self during: [ ^ block cull: self ] ] in Job>>run
FullBlockClosure(BlockClosure)>>ensure:
Job>>run
MorphicUIManager(UIManager)>>displayProgress:from:to:during:
ByteString(String)>>displayProgressFrom:to:during:
IceMetacelloPharoPlatform(MetacelloPharoCommonPlatform)>>do:displaying:
MetacelloFetchingMCSpecLoader>>linearLoadPackageSpec:gofer:
MetacelloPackageSpec>>loadUsing:gofer:
[:pkg | pkg loadUsing: self gofer: gofer ] in MetacelloFetchingMCSpecLoader(MetacelloCommonMCSpecLoader)>>linearLoadPackageSpecs:repositories:
Array(SequenceableCollection)>>do:
MetacelloFetchingMCSpecLoader(MetacelloCommonMCSpecLoader)>>linearLoadPackageSpecs:repositories:
[ super linearLoadPackageSpecs: packageSpecs repositories: repositories ] in MetacelloFetchingMCSpecLoader>>explicitLoadPackageSpecs:repositories:
FullBlockClosure(BlockClosure)>>ensure:
MetacelloLoaderPolicy>>pushLoadDirective:during:
MetacelloLoaderPolicy>>pushExplicitLoadDirectivesDuring:for:
MetacelloFetchingMCSpecLoader>>explicitLoadPackageSpecs:repositories:
MetacelloPackageSpec>>explicitLoadUsing:
MetacelloPackageSpec>>load
[ spec projectPackage load ] in MetacelloScriptEngine>>getBaselineUnconditionalLoad:
FullBlockClosure(BlockClosure)>>on:do:
MetacelloScriptEngine>>getBaselineUnconditionalLoad:
MetacelloScriptEngine>>getBaselineProjectUnconditionalLoad:
MetacelloMCBaselineProject>>projectForScriptEngine:unconditionalLoad:
MetacelloMCBaselineProject(MetacelloProject)>>projectForScriptEngine:
MetacelloMCBaselineOfProjectSpec(MetacelloMCProjectSpec)>>versionForScriptEngine:
[ 
          | version loadedSpec |
          self setDefaultsAndValidateProjectSpec.
          [ loadedSpec := (self lookupProjectSpecFor: self projectSpec) copy ]
            on: MetacelloAllowProjectDowngrade , MetacelloAllowProjectUpgrade
            do: [ :ex | ex handleOnDownGrade: onDownGradeBlock onUpgrade: onUpgradeBlock ].
          version := loadedSpec versionForScriptEngine: self.
          self
            root:
              (required isEmpty
                ifTrue: [ version load ]
                ifFalse: [ version load: required ]) loadDirective.
          loadedSpec loads: required.
          MetacelloProjectRegistration
            registrationForProjectSpec: loadedSpec
            ifAbsent: [ :new | 
              new
                loadedInImage: true;
                registerProject ]
            ifPresent: [ :existing :new | 
              existing
                copyOnWrite: [ :existingCopy | 
                  existingCopy
                    loadedInImage: true;
                    merge: new ] ] ] in [ 
      self
        handleNotificationsForAction: [ 
          | version loadedSpec |
          self setDefaultsAndValidateProjectSpec.
          [ loadedSpec := (self lookupProjectSpecFor: self projectSpec) copy ]
            on: MetacelloAllowProjectDowngrade , MetacelloAllowProjectUpgrade
            do: [ :ex | ex handleOnDownGrade: onDownGradeBlock onUpgrade: onUpgradeBlock ].
          version := loadedSpec versionForScriptEngine: self.
          self
            root:
              (required isEmpty
                ifTrue: [ version load ]
                ifFalse: [ version load: required ]) loadDirective.
          loadedSpec loads: required.
          MetacelloProjectRegistration
            registrationForProjectSpec: loadedSpec
            ifAbsent: [ :new | 
              new
                loadedInImage: true;
                registerProject ]
            ifPresent: [ :existing :new | 
              existing
                copyOnWrite: [ :existingCopy | 
                  existingCopy
                    loadedInImage: true;
                    merge: new ] ] ] ] in MetacelloScriptEngine>>load:onProjectDownGrade:onProjectUpgrade:
FullBlockClosure(BlockClosure)>>on:do:
[ 
  actionBlock
    on:
      MetacelloLookupProjectSpec , MetacelloLookupProjectSpecForLoad
        , MetacelloProjectSpecLoadedNotification
        , MetacelloScriptEnsureProjectLoadedForDevelopment
        , MetacelloLookupBaselineSpecForEnsureLoad
    do: [ :ex | 
      "lookup and registration handlers need to be innermost set of handlers ...they may throw option notifications"
      ex handleResolutionFor: self ] ] in [ 
  [ 
  actionBlock
    on:
      MetacelloLookupProjectSpec , MetacelloLookupProjectSpecForLoad
        , MetacelloProjectSpecLoadedNotification
        , MetacelloScriptEnsureProjectLoadedForDevelopment
        , MetacelloLookupBaselineSpecForEnsureLoad
    do: [ :ex | 
      "lookup and registration handlers need to be innermost set of handlers ...they may throw option notifications"
      ex handleResolutionFor: self ] ]
    on:
      MetacelloAllowProjectDowngrade , MetacelloAllowProjectUpgrade
        , MetacelloAllowConflictingProjectUpgrade
    do: [ :ex | 
      "option handlers need to be outermost set of handlers ... last line of defense before users are involved"
      ex handleResolutionFor: self ] ] in [ 
  [ 
  [ 
  actionBlock
    on:
      MetacelloLookupProjectSpec , MetacelloLookupProjectSpecForLoad
        , MetacelloProjectSpecLoadedNotification
        , MetacelloScriptEnsureProjectLoadedForDevelopment
        , MetacelloLookupBaselineSpecForEnsureLoad
    do: [ :ex | 
      "lookup and registration handlers need to be innermost set of handlers ...they may throw option notifications"
      ex handleResolutionFor: self ] ]
    on:
      MetacelloAllowProjectDowngrade , MetacelloAllowProjectUpgrade
        , MetacelloAllowConflictingProjectUpgrade
    do: [ :ex | 
      "option handlers need to be outermost set of handlers ... last line of defense before users are involved"
      ex handleResolutionFor: self ] ]
    on: MetacelloAllowLockedProjectChange
    do: [ :ex | 
      "MetacelloAllowLockedProjectChange need to be outermost handler ... since it is signaled from second line of handlers"
      ex handleResolutionFor: self ] ] in MetacelloScriptEngine>>handleNotificationsForAction:
FullBlockClosure(BlockClosure)>>on:do:
[ 
  [ 
  actionBlock
    on:
      MetacelloLookupProjectSpec , MetacelloLookupProjectSpecForLoad
        , MetacelloProjectSpecLoadedNotification
        , MetacelloScriptEnsureProjectLoadedForDevelopment
        , MetacelloLookupBaselineSpecForEnsureLoad
    do: [ :ex | 
      "lookup and registration handlers need to be innermost set of handlers ...they may throw option notifications"
      ex handleResolutionFor: self ] ]
    on:
      MetacelloAllowProjectDowngrade , MetacelloAllowProjectUpgrade
        , MetacelloAllowConflictingProjectUpgrade
    do: [ :ex | 
      "option handlers need to be outermost set of handlers ... last line of defense before users are involved"
      ex handleResolutionFor: self ] ] in [ 
  [ 
  [ 
  actionBlock
    on:
      MetacelloLookupProjectSpec , MetacelloLookupProjectSpecForLoad
        , MetacelloProjectSpecLoadedNotification
        , MetacelloScriptEnsureProjectLoadedForDevelopment
        , MetacelloLookupBaselineSpecForEnsureLoad
    do: [ :ex | 
      "lookup and registration handlers need to be innermost set of handlers ...they may throw option notifications"
      ex handleResolutionFor: self ] ]
    on:
      MetacelloAllowProjectDowngrade , MetacelloAllowProjectUpgrade
        , MetacelloAllowConflictingProjectUpgrade
    do: [ :ex | 
      "option handlers need to be outermost set of handlers ... last line of defense before users are involved"
      ex handleResolutionFor: self ] ]
    on: MetacelloAllowLockedProjectChange
    do: [ :ex | 
      "MetacelloAllowLockedProjectChange need to be outermost handler ... since it is signaled from second line of handlers"
      ex handleResolutionFor: self ] ] in MetacelloScriptEngine>>handleNotificationsForAction:
 - - - - - - - - - - - - - - -
			- - - - - - - - - - - - - - - - - -
FullBlockClosure(BlockClosure)>>on:do:
[ 
  [ 
  [ 
  actionBlock
    on:
      MetacelloLookupProjectSpec , MetacelloLookupProjectSpecForLoad
        , MetacelloProjectSpecLoadedNotification
        , MetacelloScriptEnsureProjectLoadedForDevelopment
        , MetacelloLookupBaselineSpecForEnsureLoad
    do: [ :ex | 
      "lookup and registration handlers need to be innermost set of handlers ...they may throw option notifications"
      ex handleResolutionFor: self ] ]
    on:
      MetacelloAllowProjectDowngrade , MetacelloAllowProjectUpgrade
        , MetacelloAllowConflictingProjectUpgrade
    do: [ :ex | 
      "option handlers need to be outermost set of handlers ... last line of defense before users are involved"
      ex handleResolutionFor: self ] ]
    on: MetacelloAllowLockedProjectChange
    do: [ :ex | 
      "MetacelloAllowLockedProjectChange need to be outermost handler ... since it is signaled from second line of handlers"
      ex handleResolutionFor: self ] ] in MetacelloScriptEngine>>handleNotificationsForAction:
FullBlockClosure(BlockClosure)>>on:do:
MetacelloScriptEngine>>handleNotificationsForAction:
[ 
      self
        handleNotificationsForAction: [ 
          | version loadedSpec |
          self setDefaultsAndValidateProjectSpec.
          [ loadedSpec := (self lookupProjectSpecFor: self projectSpec) copy ]
            on: MetacelloAllowProjectDowngrade , MetacelloAllowProjectUpgrade
            do: [ :ex | ex handleOnDownGrade: onDownGradeBlock onUpgrade: onUpgradeBlock ].
          version := loadedSpec versionForScriptEngine: self.
          self
            root:
              (required isEmpty
                ifTrue: [ version load ]
                ifFalse: [ version load: required ]) loadDirective.
          loadedSpec loads: required.
          MetacelloProjectRegistration
            registrationForProjectSpec: loadedSpec
            ifAbsent: [ :new | 
              new
                loadedInImage: true;
                registerProject ]
            ifPresent: [ :existing :new | 
              existing
                copyOnWrite: [ :existingCopy | 
                  existingCopy
                    loadedInImage: true;
                    merge: new ] ] ] ] in MetacelloScriptEngine>>load:onProjectDownGrade:onProjectUpgrade:
FullBlockClosure(BlockClosure)>>ensure:
MetacelloProjectRegistration class>>copyRegistryRestoreOnErrorWhile:
MetacelloScriptEngine>>load:onProjectDownGrade:onProjectUpgrade:
MetacelloScriptEngine>>load:
[ :projectSpec | 
      | engine |
      engine := MetacelloScriptEngine new
        options: self options copy;
        projectSpec: projectSpec;
        yourself.
      engine perform: actionArg key withArguments: actionArg value.
      engine root ifNotNil: [ :root | self roots add: root ] ] in MetacelloScriptApiExecutor(MetacelloScriptExecutor)>>execute:
[ :projectSpec | 
      projectSpec
        ifNotNil: [ projectSpecBlock value: (self applyArgsToProjectSpec: projectSpec copy) ] ] in MetacelloScriptApiExecutor>>executeString:do:
Array(SequenceableCollection)>>do:
MetacelloScriptApiExecutor>>executeString:do:
ByteString(String)>>execute:against:
MetacelloScriptApiExecutor(MetacelloScriptExecutor)>>execute:
[ 
		super execute: statements ] in MetacelloScriptApiExecutor>>execute:
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in IceMetacelloLoadSessionContext(DynamicVariable)>>value:during:
FullBlockClosure(BlockClosure)>>ensure:
IceMetacelloLoadSessionContext(DynamicVariable)>>value:during:
IceMetacelloLoadSessionContext class(DynamicVariable class)>>value:during:
IceMetacelloPharoPlatform>>withMetacelloLoadSessionDo:
MetacelloScriptApiExecutor>>execute:
Metacello>>execute:args:
Metacello>>load
UndefinedObject>>DoIt
OCReceiverDoItSemanticScope(OCDoItSemanticScope)>>evaluateDoIt:
OpalCompiler>>evaluate
[
		self announcer announce: (SpCodeWillBeEvaluatedAnnouncement newContent: aString).
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionModel doItReceiver.
		result := receiver class compiler
			source: aString;
			context: self interactionModel doItContext;
			receiver: self interactionModel doItReceiver;
			requestor: self interactionModel;
			environment: self environment;
			failBlock:  [ 
				self announcer announce: (SpCodeEvaluationFailedAnnouncement newContent: aString).
				^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		self announcer announce: (SpCodeEvaluationSucceedAnnouncement newContent: aString).
		result ] in SpCodePresenter>>evaluate:onCompileError:onError:
FullBlockClosure(BlockClosure)>>on:do:
SpCodePresenter>>evaluate:onCompileError:onError:
StPlaygroundPagePresenter>>doEvaluateAndGo
StPlaygroundPagePresenter>>doEvaluateAllAndGo
StPlaygroundDoItCommand>>execute
SpCommand(CmCommandDecorator)>>execute
[ specCommand execute ] in [ :specCommand | 
			aButtonClass new
				label: specCommand name;
				help: specCommand description;
				in: [ :button | 
					specCommand hasIcon
						ifTrue: [ button icon: specCommand icon ] ];
				action: [ specCommand execute ];
				yourself ] in SpCommand>>configureAsButtonOfClass:
FullBlockClosure(BlockClosure)>>cull:
SpMorphicToolbarButtonAdapter>>execute
SpToolbarButtonMorph(PluggableButtonMorph)>>performAction:
[:m |
		(m containsPoint: evt cursorPoint) ifTrue: [m enabled ifTrue: [ m performAction: evt ]]] in SpToolbarButtonMorph(PluggableButtonMorph)>>mouseUp:
Array(SequenceableCollection)>>do:
SpToolbarButtonMorph(PluggableButtonMorph)>>mouseUp:
SpToolbarButtonMorph(Morph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
SpToolbarButtonMorph(Morph)>>handleEvent:
SpToolbarButtonMorph(Morph)>>handleFocusEvent:
[
		result := focusHolder handleFocusEvent: transformedEvent.
	] in HandMorph>>sendFocusEvent:to:clear:
FullBlockClosure(BlockClosure)>>on:do:
WorldMorph>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil ]) ifTrue: [
			morphicWorld activeHand handleEvent: anEvent
		]
	] in OSWindowMorphicEventHandler>>dispatchMorphicEvent:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycleNow
WorldMorph>>doOneCycle
[
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMutex critical: [
			                     self extraWorldList ].
		extraWorldsToDraw do: [ :world | world doOneCycle ].

		(self currentWorld isNotNil and: [
			 (extraWorldsToDraw includes: self currentWorld) not ]) ifTrue: [
			self currentWorld doOneCycle ] ] in WorldMorph class>>doOneCycle
FullBlockClosure(BlockClosure)>>ensure:
WorldState class>>doDrawCycleWith:
WorldMorph class>>doOneCycle
MorphicRenderLoop>>doOneCycle
MorphicRenderLoop>>doOneCycleWhile:
[ MorphicRenderLoop new doOneCycleWhile: [ true ] ] in MorphicUIManager>>spawnNewProcess
[self value.
			"IMPORTANT: Do not step over next line of code. See method comments for details"
			Processor terminateRealActive] in FullBlockClosure(BlockClosure)>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
Could not resolve: BaselineOfJSON [BaselineOfJSON] in /Users/ryanperez/Documents/Pharo/images/Visualizer/pharo-local/package-cache https://github.com/SvenVC/NeoJSON.git[master]
23 October 2023 11:03:38.337448 pm

VM: Mac OS - arm64 - 1000 - CoInterpreter VMMaker-tonel.1 uuid: 902dd483-c0c4-0d00-86f2-0f880df24b96 Oct 23 2023
StackToRegisterMappingCogit VMMaker-tonel.1 uuid: 902dd483-c0c4-0d00-86f2-0f880df24b96 Oct 23 2023
v10.0.8 - Commit: b323c5fb - Date: 2023-10-20 16:02:07 -0400

Image: Pharo11.0.0 [Build information: Pharo-11.0.0+build.710.sha.ea28d8552cac85a7ce1e9c34ab1e7bd45f7b9910 (64 Bit)]

MetacelloFetchingMCSpecLoader(MetacelloCommonMCSpecLoader)>>retryingResolvePackageSpecReferences:gofer:
	Receiver: a MetacelloFetchingMCSpecLoader(explicit load : BaselineOfJSON)
	Arguments and temporary variables: 
		packageSpec: 	spec 
	name: 'BaselineOfJSON';
	repository: 'github://svenvc/N[..]
		gofer: 	a MetacelloGofer
		references: 	#()
		retryCount: 	3
		repositoryError: 	nil
	Receiver's instance variables: 
		spec: 	spec 
	name: 'BaselineOfJSON';
	repository: 'github://svenvc/NeoJSON/[..]
		operator: 	nil
		loaderPolicy: 	a MetacelloLoaderPolicy
		disablePackageCache: 	false


[ 
      | references nearestReference cachedReference externalReference mcVersion loadedVersionInfos |
      cachedReference := nil.
      packageSpec
        searchCacheRepositoryForPackage: [ 
          "check to see if mcz file is already in cacheRepository"
          cachedReference := self
            resolvePackageSpec: packageSpec
            cachedGofer: self loaderPolicy cacheGofer.
          (cachedReference ~~ nil and: [ packageSpec getFile ~~ nil ])
            ifTrue: [ 
              cachedReference name = packageSpec file
                ifTrue: [ 
                  "exact match between packageSpec file and cache"
                  ^ self
                    scheduleFetchFor: packageSpec
                    cachedReference: cachedReference ] ] ].
      references := self
        retryingResolvePackageSpecReferences: packageSpec
        gofer: gofer.	"look up mcz file"
      nearestReference := references last asMetacelloCachingResolvedReference.
      (cachedReference ~~ nil
        and: [ cachedReference name = nearestReference name ])
        ifTrue: [ 
          "latest reference in repository matches cachedReference ... "
          ^ self
            scheduleFetchFor: packageSpec
            nearestReference: nearestReference ].
      (self ignoreImage not
        and: [ (loadedVersionInfos := self ancestorsFor: packageSpec) ~~ nil ])
        ifTrue: [ 
          "If the mcz is already loaded into the image, no need to copy"
          loadedVersionInfos
            do: [ :info | 
              info name = nearestReference name
                ifTrue: [ 
                  | spc |
                  spc := packageSpec copy.
                  spc file: info name.
                  (MetacelloIgnorePackageLoaded signal: spc)
                    ifFalse: [ ^ self ] ] ] ].
      externalReference := (references
        select: [ :ref | ref name = nearestReference name ]) first
        asMetacelloCachingResolvedReference.
      self repositoryMap
        at: externalReference name
        put: externalReference repository.
      (self
        resolveDependencies: externalReference
        nearest: nearestReference
        into: (OrderedCollection with: nearestReference))
        do: [ :reference | 
          | pSpec l |
          mcVersion := reference version.
          (l := (GoferVersionReference name: reference name)
            resolveAllWith: self loaderPolicy cacheGofer) isEmpty
            ifTrue: [ 
              self cacheRepository storeVersion: mcVersion.
              reference == nearestReference
                ifTrue: [ pSpec := packageSpec ]
                ifFalse: [ 
                  pSpec := packageSpec project packageSpec.
                  pSpec name: mcVersion package name ].
              self loadData
                addVersion: mcVersion
                versionInfo: mcVersion info
                resolvedReference: reference
                packageSpec: pSpec ] ].
      self scheduleFetchFor: packageSpec externalReference: externalReference ] in MetacelloFetchingMCSpecLoader>>linearLoadPackageSpec:gofer:
	Receiver: a MetacelloFetchingMCSpecLoader(explicit load : BaselineOfJSON)
	Arguments and temporary variables: 
		packageSpec: 	spec 
	name: 'BaselineOfJSON';
	repository: 'github://svenvc/N[..]
		gofer: 	a MetacelloGofer
		cachedReference: 	nil
		mcVersion: 	nil
		references: 	nil
		nearestReference: 	nil
		externalReference: 	nil
		loadedVersionInfos: 	nil
	Receiver's instance variables: 
		spec: 	spec 
	name: 'BaselineOfJSON';
	repository: 'github://svenvc/NeoJSON/[..]
		operator: 	nil
		loaderPolicy: 	a MetacelloLoaderPolicy
		disablePackageCache: 	false


[:bar |
            bar value: 1.
            aBlock value.
            bar value: 2 ] in IceMetacelloPharoPlatform(MetacelloPharoCommonPlatform)>>do:displaying:
	Receiver: an IceMetacelloPharoPlatform
	Arguments and temporary variables: 
		aBlock: 	[ 
      | references nearestReference cachedReference externalRefe[..]
		aString: 	'Fetching BaselineOfJSON'
		bar: 	a Job
	Receiver's instance variables: 
		bypassProgressBars: 	false
		bypassGoferLoadUpdateCategories: 	false


FullBlockClosure(BlockClosure)>>cull:
	Receiver: [:bar |
            bar value: 1.
            aBlock value.
            bar value: 2 ]
	Arguments and temporary variables: 
		anArg: 	a Job
	Receiver's instance variables: 
		outerContext: 	IceMetacelloPharoPlatform(MetacelloPharoCommonPlatform)>>do:d[..]
		compiledBlock: 	a CompiledBlock: [:bar |
            bar value: 1.
         [..]
		numArgs: 	1
		receiver: 	an IceMetacelloPharoPlatform


[ ^ block cull: self ] in [ self prepareForRunning.
	  CurrentJob value: self during: [ ^ block cull: self ] ] in Job>>run
	Receiver: a Job
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		block: 	[:bar |
            bar value: 1.
            aBlock value.
        [..]
		currentValue: 	1
		min: 	0
		max: 	2
		title: 	'Fetching BaselineOfJSON'
		children: 	an OrderedCollection()
		isRunning: 	true
		parent: 	nil
		process: 	a Process in nil
		owner: 	a MorphicUIManager


[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in CurrentJob(DynamicVariable)>>value:during:
	Receiver: a CurrentJob
	Arguments and temporary variables: 
		anObject: 	a Job
		aBlock: 	[ ^ block cull: self ]
		activeProcess: 	a Process in nil
		oldValue: 	nil
	Receiver's instance variables: 
		index: 	2


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ]
	Arguments and temporary variables: 
		aBlock: 	[
			activeProcess
				psValueAt: index
				put: oldValue ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	CurrentJob(DynamicVariable)>>value:during:
		compiledBlock: 	a CompiledBlock: [ activeProcess
			psValueAt: index
			put:[..]
		numArgs: 	0
		receiver: 	a CurrentJob


CurrentJob(DynamicVariable)>>value:during:
	Receiver: a CurrentJob
	Arguments and temporary variables: 
		anObject: 	a Job
		aBlock: 	[ ^ block cull: self ]
		activeProcess: 	a Process in nil
		oldValue: 	nil
	Receiver's instance variables: 
		index: 	2


CurrentJob class(DynamicVariable class)>>value:during:
	Receiver: CurrentJob
	Arguments and temporary variables: 
		anObject: 	a Job
		aBlock: 	[ ^ block cull: self ]
	Receiver's instance variables: 
		superclass: 	DynamicVariable
		methodDict: 	a MethodDictionary()
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		commentSourcePointer: 	nil
		subclasses: 	nil
		name: 	#CurrentJob
		classPool: 	nil
		sharedPools: 	nil
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Jobs-Base'
		soleInstance: 	a CurrentJob


[ self prepareForRunning.
	  CurrentJob value: self during: [ ^ block cull: self ] ] in Job>>run
	Receiver: a Job
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		block: 	[:bar |
            bar value: 1.
            aBlock value.
        [..]
		currentValue: 	1
		min: 	0
		max: 	2
		title: 	'Fetching BaselineOfJSON'
		children: 	an OrderedCollection()
		isRunning: 	true
		parent: 	nil
		process: 	a Process in nil
		owner: 	a MorphicUIManager


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ self prepareForRunning.
	  CurrentJob value: self during: [ ^ block cull: self ] ]
	Arguments and temporary variables: 
		aBlock: 	[ self cleanupAfterRunning ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	Job>>run
		compiledBlock: 	a CompiledBlock: [ self prepareForRunning.
	  CurrentJob val[..]
		numArgs: 	0
		receiver: 	a Job


Job>>run
	Receiver: a Job
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		block: 	[:bar |
            bar value: 1.
            aBlock value.
        [..]
		currentValue: 	1
		min: 	0
		max: 	2
		title: 	'Fetching BaselineOfJSON'
		children: 	an OrderedCollection()
		isRunning: 	true
		parent: 	nil
		process: 	a Process in nil
		owner: 	a MorphicUIManager


MorphicUIManager(UIManager)>>displayProgress:from:to:during:
	Receiver: a MorphicUIManager
	Arguments and temporary variables: 
		titleString: 	'Fetching BaselineOfJSON'
		minVal: 	0
		maxVal: 	2
		workBlock: 	[:bar |
            bar value: 1.
            aBlock value.
    [..]
	Receiver's instance variables: 
		activeTranscript: 	nil


ByteString(String)>>displayProgressFrom:to:during:
	Receiver: 'Fetching BaselineOfJSON'
	Arguments and temporary variables: 
		minVal: 	0
		maxVal: 	2
		workBlock: 	[:bar |
            bar value: 1.
            aBlock value.
    [..]
	Receiver's instance variables: 
'Fetching BaselineOfJSON'

IceMetacelloPharoPlatform(MetacelloPharoCommonPlatform)>>do:displaying:
	Receiver: an IceMetacelloPharoPlatform
	Arguments and temporary variables: 
		aBlock: 	[ 
      | references nearestReference cachedReference externalRefe[..]
		aString: 	'Fetching BaselineOfJSON'
	Receiver's instance variables: 
		bypassProgressBars: 	false
		bypassGoferLoadUpdateCategories: 	false


MetacelloFetchingMCSpecLoader>>linearLoadPackageSpec:gofer:
	Receiver: a MetacelloFetchingMCSpecLoader(explicit load : BaselineOfJSON)
	Arguments and temporary variables: 
		packageSpec: 	spec 
	name: 'BaselineOfJSON';
	repository: 'github://svenvc/N[..]
		gofer: 	a MetacelloGofer
	Receiver's instance variables: 
		spec: 	spec 
	name: 'BaselineOfJSON';
	repository: 'github://svenvc/NeoJSON/[..]
		operator: 	nil
		loaderPolicy: 	a MetacelloLoaderPolicy
		disablePackageCache: 	false


MetacelloPackageSpec>>loadUsing:gofer:
	Receiver: spec 
	name: 'BaselineOfJSON';
	repository: 'github://svenvc/NeoJSON/repository'.
	Arguments and temporary variables: 
		aLoader: 	a MetacelloFetchingMCSpecLoader(explicit load : BaselineOfJSON)
		gofer: 	a MetacelloGofer
	Receiver's instance variables: 
		project: 	<<error during printing>>

[:pkg | pkg loadUsing: self gofer: gofer ] in MetacelloFetchingMCSpecLoader(MetacelloCommonMCSpecLoader)>>linearLoadPackageSpecs:repositories:
	Receiver: a MetacelloFetchingMCSpecLoader(explicit load : BaselineOfJSON)
	Arguments and temporary variables: 
		packageSpecs: 	an Array(spec 
	name: 'BaselineOfJSON';
	repository: 'github:[..]
		repositories: 	an OrderedCollection(an IceMetacelloRepositoryAdapter)
		gofer: 	a MetacelloGofer
		pkg: 	spec 
	name: 'BaselineOfJSON';
	repository: 'github://svenvc/NeoJSON/r[..]
	Receiver's instance variables: 
		spec: 	spec 
	name: 'BaselineOfJSON';
	repository: 'github://svenvc/NeoJSON/[..]
		operator: 	nil
		loaderPolicy: 	a MetacelloLoaderPolicy
		disablePackageCache: 	false


Array(SequenceableCollection)>>do:
	Receiver: an Array(spec 
	name: 'BaselineOfJSON';
	repository: 'github://svenvc/NeoJSON/reposito[..]
	Arguments and temporary variables: 
		aBlock: 	[:pkg | pkg loadUsing: self gofer: gofer ]
		index: 	1
	Receiver's instance variables: 
an Array(spec 
	name: 'BaselineOfJSON';
	repository: 'github://svenvc/NeoJSON/reposito[..]

MetacelloFetchingMCSpecLoader(MetacelloCommonMCSpecLoader)>>linearLoadPackageSpecs:repositories:
	Receiver: a MetacelloFetchingMCSpecLoader(explicit load : BaselineOfJSON)
	Arguments and temporary variables: 
		packageSpecs: 	an Array(spec 
	name: 'BaselineOfJSON';
	repository: 'github:[..]
		repositories: 	an OrderedCollection(an IceMetacelloRepositoryAdapter)
		gofer: 	a MetacelloGofer
	Receiver's instance variables: 
		spec: 	spec 
	name: 'BaselineOfJSON';
	repository: 'github://svenvc/NeoJSON/[..]
		operator: 	nil
		loaderPolicy: 	a MetacelloLoaderPolicy
		disablePackageCache: 	false


[ super linearLoadPackageSpecs: packageSpecs repositories: repositories ] in MetacelloFetchingMCSpecLoader>>explicitLoadPackageSpecs:repositories:
	Receiver: a MetacelloFetchingMCSpecLoader(explicit load : BaselineOfJSON)
	Arguments and temporary variables: 
		packageSpecs: 	an Array(spec 
	name: 'BaselineOfJSON';
	repository: 'github:[..]
		repositories: 	an OrderedCollection(an IceMetacelloRepositoryAdapter)
		directive: 	nil
	Receiver's instance variables: 
		spec: 	spec 
	name: 'BaselineOfJSON';
	repository: 'github://svenvc/NeoJSON/[..]
		operator: 	nil
		loaderPolicy: 	a MetacelloLoaderPolicy
		disablePackageCache: 	false


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ super linearLoadPackageSpecs: packageSpecs repositories: repositories ]
	Arguments and temporary variables: 
		aBlock: 	[ loadDirective := oldRoot ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	MetacelloFetchingMCSpecLoader>>explicitLoadPackageSpecs:repos[..]
		compiledBlock: 	a CompiledBlock: [ super linearLoadPackageSpecs: packageSpec[..]
		numArgs: 	0
		receiver: 	a MetacelloFetchingMCSpecLoader(explicit load : BaselineOfJSON)


MetacelloLoaderPolicy>>pushLoadDirective:during:
	Receiver: a MetacelloLoaderPolicy
	Arguments and temporary variables: 
		aLoaderDirective: 	explicit load : BaselineOfJSON
		aBlock: 	[ super linearLoadPackageSpecs: packageSpecs repositories: reposito[..]
		oldRoot: 	linear load : 
	explicit load : BaselineOfJSON
	Receiver's instance variables: 
		overrideRepositories: 	nil
		repositoryMap: 	a Dictionary()
		ensuredMap: 	a Dictionary()
		cacheRepository: 	a MCDictionaryRepository(cache)
		cacheGofer: 	a Gofer
		ignoreImage: 	false
		loadData: 	nil
		loadDirective: 	explicit load : BaselineOfJSON
		silently: 	nil


MetacelloLoaderPolicy>>pushExplicitLoadDirectivesDuring:for:
	Receiver: a MetacelloLoaderPolicy
	Arguments and temporary variables: 
		aBlock: 	[ super linearLoadPackageSpecs: packageSpecs repositories: reposito[..]
		aLoader: 	a MetacelloFetchingMCSpecLoader(explicit load : BaselineOfJSON)
		directive: 	explicit load : BaselineOfJSON
	Receiver's instance variables: 
		overrideRepositories: 	nil
		repositoryMap: 	a Dictionary()
		ensuredMap: 	a Dictionary()
		cacheRepository: 	a MCDictionaryRepository(cache)
		cacheGofer: 	a Gofer
		ignoreImage: 	false
		loadData: 	nil
		loadDirective: 	explicit load : BaselineOfJSON
		silently: 	nil


MetacelloFetchingMCSpecLoader>>explicitLoadPackageSpecs:repositories:
	Receiver: a MetacelloFetchingMCSpecLoader(explicit load : BaselineOfJSON)
	Arguments and temporary variables: 
		packageSpecs: 	an Array(spec 
	name: 'BaselineOfJSON';
	repository: 'github:[..]
		repositories: 	an OrderedCollection(an IceMetacelloRepositoryAdapter)
		directive: 	nil
	Receiver's instance variables: 
		spec: 	spec 
	name: 'BaselineOfJSON';
	repository: 'github://svenvc/NeoJSON/[..]
		operator: 	nil
		loaderPolicy: 	a MetacelloLoaderPolicy
		disablePackageCache: 	false


MetacelloPackageSpec>>explicitLoadUsing:
	Receiver: spec 
	name: 'BaselineOfJSON';
	repository: 'github://svenvc/NeoJSON/repository'.
	Arguments and temporary variables: 
		mcLoader: 	a MetacelloLoadingMCSpecLoader
		wc: 	nil
		fetchingSpecLoader: 	a MetacelloFetchingMCSpecLoader(explicit load : Baselin[..]
	Receiver's instance variables: 
		project: 	<<error during printing>>

MetacelloPackageSpec>>load
	Receiver: spec 
	name: 'BaselineOfJSON';
	repository: 'github://svenvc/NeoJSON/repository'.
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		project: 	<<error during printing>>

[ spec projectPackage load ] in MetacelloScriptEngine>>getBaselineUnconditionalLoad:
	Receiver: a MetacelloScriptEngine
	Arguments and temporary variables: 
		unconditionalLoad: 	true
		spec: 	spec 
	name: 'JSON';
	repository: 'github://svenvc/NeoJSON/repository'.
	Receiver's instance variables: 
		root: 	nil
		projectSpec: 	spec 
	name: 'JSON';
	repository: 'github://svenvc/NeoJSON/rep[..]
		options: 	a Dictionary()


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [ spec projectPackage load ]
	Arguments and temporary variables: 
		exception: 	MetacelloIgnorePackageLoaded
		handlerAction: 	[ :ex | 
      "see https://github.com/dalehenrich/metacello[..]
	Receiver's instance variables: 
		outerContext: 	MetacelloScriptEngine>>getBaselineUnconditionalLoad:
		compiledBlock: 	a CompiledBlock: [ spec projectPackage load ]
		numArgs: 	0
		receiver: 	a MetacelloScriptEngine


MetacelloScriptEngine>>getBaselineUnconditionalLoad:
	Receiver: a MetacelloScriptEngine
	Arguments and temporary variables: 
		unconditionalLoad: 	true
		spec: 	spec 
	name: 'JSON';
	repository: 'github://svenvc/NeoJSON/repository'.
	Receiver's instance variables: 
		root: 	nil
		projectSpec: 	spec 
	name: 'JSON';
	repository: 'github://svenvc/NeoJSON/rep[..]
		options: 	a Dictionary()


MetacelloScriptEngine>>getBaselineProjectUnconditionalLoad:
	Receiver: a MetacelloScriptEngine
	Arguments and temporary variables: 
		unconditionalLoad: 	true
		project: 	nil
	Receiver's instance variables: 
		root: 	nil
		projectSpec: 	spec 
	name: 'JSON';
	repository: 'github://svenvc/NeoJSON/rep[..]
		options: 	a Dictionary()


MetacelloMCBaselineProject>>projectForScriptEngine:unconditionalLoad:
	Receiver: <<error during printing>>
	Arguments and temporary variables: 
		aMetacelloScriptEngine: 	a MetacelloScriptEngine
		aBool: 	false
	Receiver's instance variables: 
		versionMap: 	nil
		symbolicVersionMap: 	nil
		errorMap: 	nil
		loader: 	nil
		loaderClass: 	MetacelloLoadingMCSpecLoader
		loadType: 	nil
		configuration: 	<<error during printing>>

MetacelloMCBaselineProject(MetacelloProject)>>projectForScriptEngine:
	Receiver: <<error during printing>>
	Arguments and temporary variables: 
		aMetacelloScriptEngine: 	a MetacelloScriptEngine
	Receiver's instance variables: 
		versionMap: 	nil
		symbolicVersionMap: 	nil
		errorMap: 	nil
		loader: 	nil
		loaderClass: 	MetacelloLoadingMCSpecLoader
		loadType: 	nil
		configuration: 	<<error during printing>>

MetacelloMCBaselineOfProjectSpec(MetacelloMCProjectSpec)>>versionForScriptEngine:
	Receiver: spec 
	name: 'JSON';
	repository: 'github://svenvc/NeoJSON/repository'.
	Arguments and temporary variables: 
<<error during printing>>
	Receiver's instance variables: 
		project: 	<<error during printing>>

[ 
          | version loadedSpec |
          self setDefaultsAndValidateProjectSpec.
          [ loadedSpec := (self lookupProjectSpecFor: self projectSpec) copy ]
            on: MetacelloAllowProjectDowngrade , MetacelloAllowProjectUpgrade
            do: [ :ex | ex handleOnDownGrade: onDownGradeBlock onUpgrade: onUpgradeBlock ].
          version := loadedSpec versionForScriptEngine: self.
          self
            root:
              (required isEmpty
                ifTrue: [ version load ]
                ifFalse: [ version load: required ]) loadDirective.
          loadedSpec loads: required.
          MetacelloProjectRegistration
            registrationForProjectSpec: loadedSpec
            ifAbsent: [ :new | 
              new
                loadedInImage: true;
                registerProject ]
            ifPresent: [ :existing :new | 
              existing
                copyOnWrite: [ :existingCopy | 
                  existingCopy
                    loadedInImage: true;
                    merge: new ] ] ] in [ 
      self
        handleNotificationsForAction: [ 
          | version loadedSpec |
          self setDefaultsAndValidateProjectSpec.
          [ loadedSpec := (self lookupProjectSpecFor: self projectSpec) copy ]
            on: MetacelloAllowProjectDowngrade , MetacelloAllowProjectUpgrade
            do: [ :ex | ex handleOnDownGrade: onDownGradeBlock onUpgrade: onUpgradeBlock ].
          version := loadedSpec versionForScriptEngine: self.
          self
            root:
              (required isEmpty
                ifTrue: [ version load ]
                ifFalse: [ version load: required ]) loadDirective.
          loadedSpec loads: required.
          MetacelloProjectRegistration
            registrationForProjectSpec: loadedSpec
            ifAbsent: [ :new | 
              new
                loadedInImage: true;
                registerProject ]
            ifPresent: [ :existing :new | 
              existing
                copyOnWrite: [ :existingCopy | 
                  existingCopy
                    loadedInImage: true;
                    merge: new ] ] ] ] in MetacelloScriptEngine>>load:onProjectDownGrade:onProjectUpgrade:
	Receiver: a MetacelloScriptEngine
	Arguments and temporary variables: 
		required: 	#()
		onDownGradeBlock: 	[ :ex :existing :new | ex allowEvenIfLocked ]
		onUpgradeBlock: 	[ :ex :existing :new | ex allowEvenIfLocked ]
		loadedSpec: 	spec 
	name: 'JSON';
	repository: 'github://svenvc/NeoJSON/repo[..]
		version: 	nil
	Receiver's instance variables: 
		root: 	nil
		projectSpec: 	spec 
	name: 'JSON';
	repository: 'github://svenvc/NeoJSON/rep[..]
		options: 	a Dictionary()


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [ 
          | version loadedSpec |
          self setDefaultsAndValidateProjectSpec.
[..]
	Arguments and temporary variables: 
		exception: 	an ExceptionSet
		handlerAction: 	[ :ex | 
      "lookup and registration handlers need to be [..]
	Receiver's instance variables: 
		outerContext: 	[ 
      self
        handleNotificationsForAction: [ 
      [..]
		compiledBlock: 	a CompiledBlock: [ 
          | version loadedSpec |
       [..]
		numArgs: 	0
		receiver: 	a MetacelloScriptEngine


[ 
  actionBlock
    on:
      MetacelloLookupProjectSpec , MetacelloLookupProjectSpecForLoad
        , MetacelloProjectSpecLoadedNotification
        , MetacelloScriptEnsureProjectLoadedForDevelopment
        , MetacelloLookupBaselineSpecForEnsureLoad
    do: [ :ex | 
      "lookup and registration handlers need to be innermost set of handlers ...they may throw option notifications"
      ex handleResolutionFor: self ] ] in [ 
  [ 
  actionBlock
    on:
      MetacelloLookupProjectSpec , MetacelloLookupProjectSpecForLoad
        , MetacelloProjectSpecLoadedNotification
        , MetacelloScriptEnsureProjectLoadedForDevelopment
        , MetacelloLookupBaselineSpecForEnsureLoad
    do: [ :ex | 
      "lookup and registration handlers need to be innermost set of handlers ...they may throw option notifications"
      ex handleResolutionFor: self ] ]
    on:
      MetacelloAllowProjectDowngrade , MetacelloAllowProjectUpgrade
        , MetacelloAllowConflictingProjectUpgrade
    do: [ :ex | 
      "option handlers need to be outermost set of handlers ... last line of defense before users are involved"
      ex handleResolutionFor: self ] ] in [ 
  [ 
  [ 
  actionBlock
    on:
      MetacelloLookupProjectSpec , MetacelloLookupProjectSpecForLoad
        , MetacelloProjectSpecLoadedNotification
        , MetacelloScriptEnsureProjectLoadedForDevelopment
        , MetacelloLookupBaselineSpecForEnsureLoad
    do: [ :ex | 
      "lookup and registration handlers need to be innermost set of handlers ...they may throw option notifications"
      ex handleResolutionFor: self ] ]
    on:
      MetacelloAllowProjectDowngrade , MetacelloAllowProjectUpgrade
        , MetacelloAllowConflictingProjectUpgrade
    do: [ :ex | 
      "option handlers need to be outermost set of handlers ... last line of defense before users are involved"
      ex handleResolutionFor: self ] ]
    on: MetacelloAllowLockedProjectChange
    do: [ :ex | 
      "MetacelloAllowLockedProjectChange need to be outermost handler ... since it is signaled from second line of handlers"
      ex handleResolutionFor: self ] ] in MetacelloScriptEngine>>handleNotificationsForAction:
	Receiver: a MetacelloScriptEngine
	Arguments and temporary variables: 
		actionBlock: 	[ 
          | version loadedSpec |
          self setDefaults[..]
	Receiver's instance variables: 
		root: 	nil
		projectSpec: 	spec 
	name: 'JSON';
	repository: 'github://svenvc/NeoJSON/rep[..]
		options: 	a Dictionary()


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [ 
  actionBlock
    on:
      MetacelloLookupProjectSpec , MetacelloLookupProjectSpec[..]
	Arguments and temporary variables: 
		exception: 	an ExceptionSet
		handlerAction: 	[ :ex | 
      "option handlers need to be outermost set of [..]
	Receiver's instance variables: 
		outerContext: 	[ 
  [ 
  actionBlock
    on:
      MetacelloLookupProjectSpe[..]
		compiledBlock: 	a CompiledBlock: [ 
  actionBlock
    on:
      MetacelloLoo[..]
		numArgs: 	0
		receiver: 	a MetacelloScriptEngine


[ 
  [ 
  actionBlock
    on:
      MetacelloLookupProjectSpec , MetacelloLookupProjectSpecForLoad
        , MetacelloProjectSpecLoadedNotification
        , MetacelloScriptEnsureProjectLoadedForDevelopment
        , MetacelloLookupBaselineSpecForEnsureLoad
    do: [ :ex | 
      "lookup and registration handlers need to be innermost set of handlers ...they may throw option notifications"
      ex handleResolutionFor: self ] ]
    on:
      MetacelloAllowProjectDowngrade , MetacelloAllowProjectUpgrade
        , MetacelloAllowConflictingProjectUpgrade
    do: [ :ex | 
      "option handlers need to be outermost set of handlers ... last line of defense before users are involved"
      ex handleResolutionFor: self ] ] in [ 
  [ 
  [ 
  actionBlock
    on:
      MetacelloLookupProjectSpec , MetacelloLookupProjectSpecForLoad
        , MetacelloProjectSpecLoadedNotification
        , MetacelloScriptEnsureProjectLoadedForDevelopment
        , MetacelloLookupBaselineSpecForEnsureLoad
    do: [ :ex | 
      "lookup and registration handlers need to be innermost set of handlers ...they may throw option notifications"
      ex handleResolutionFor: self ] ]
    on:
      MetacelloAllowProjectDowngrade , MetacelloAllowProjectUpgrade
        , MetacelloAllowConflictingProjectUpgrade
    do: [ :ex | 
      "option handlers need to be outermost set of handlers ... last line of defense before users are involved"
      ex handleResolutionFor: self ] ]
    on: MetacelloAllowLockedProjectChange
    do: [ :ex | 
      "MetacelloAllowLockedProjectChange need to be outermost handler ... since it is signaled from second line of handlers"
      ex handleResolutionFor: self ] ] in MetacelloScriptEngine>>handleNotificationsForAction:
	Receiver: a MetacelloScriptEngine
	Arguments and temporary variables: 
		actionBlock: 	[ 
          | version loadedSpec |
          self setDefaults[..]
	Receiver's instance variables: 
		root: 	nil
		projectSpec: 	spec 
	name: 'JSON';
	repository: 'github://svenvc/NeoJSON/rep[..]
		options: 	a Dictionary()



--- The full stack ---
MetacelloFetchingMCSpecLoader(MetacelloCommonMCSpecLoader)>>retryingResolvePackageSpecReferences:gofer:
[ 
      | references nearestReference cachedReference externalReference mcVersion loadedVersionInfos |
      cachedReference := nil.
      packageSpec
        searchCacheRepositoryForPackage: [ 
          "check to see if mcz file is already in cacheRepository"
          cachedReference := self
            resolvePackageSpec: packageSpec
            cachedGofer: self loaderPolicy cacheGofer.
          (cachedReference ~~ nil and: [ packageSpec getFile ~~ nil ])
            ifTrue: [ 
              cachedReference name = packageSpec file
                ifTrue: [ 
                  "exact match between packageSpec file and cache"
                  ^ self
                    scheduleFetchFor: packageSpec
                    cachedReference: cachedReference ] ] ].
      references := self
        retryingResolvePackageSpecReferences: packageSpec
        gofer: gofer.	"look up mcz file"
      nearestReference := references last asMetacelloCachingResolvedReference.
      (cachedReference ~~ nil
        and: [ cachedReference name = nearestReference name ])
        ifTrue: [ 
          "latest reference in repository matches cachedReference ... "
          ^ self
            scheduleFetchFor: packageSpec
            nearestReference: nearestReference ].
      (self ignoreImage not
        and: [ (loadedVersionInfos := self ancestorsFor: packageSpec) ~~ nil ])
        ifTrue: [ 
          "If the mcz is already loaded into the image, no need to copy"
          loadedVersionInfos
            do: [ :info | 
              info name = nearestReference name
                ifTrue: [ 
                  | spc |
                  spc := packageSpec copy.
                  spc file: info name.
                  (MetacelloIgnorePackageLoaded signal: spc)
                    ifFalse: [ ^ self ] ] ] ].
      externalReference := (references
        select: [ :ref | ref name = nearestReference name ]) first
        asMetacelloCachingResolvedReference.
      self repositoryMap
        at: externalReference name
        put: externalReference repository.
      (self
        resolveDependencies: externalReference
        nearest: nearestReference
        into: (OrderedCollection with: nearestReference))
        do: [ :reference | 
          | pSpec l |
          mcVersion := reference version.
          (l := (GoferVersionReference name: reference name)
            resolveAllWith: self loaderPolicy cacheGofer) isEmpty
            ifTrue: [ 
              self cacheRepository storeVersion: mcVersion.
              reference == nearestReference
                ifTrue: [ pSpec := packageSpec ]
                ifFalse: [ 
                  pSpec := packageSpec project packageSpec.
                  pSpec name: mcVersion package name ].
              self loadData
                addVersion: mcVersion
                versionInfo: mcVersion info
                resolvedReference: reference
                packageSpec: pSpec ] ].
      self scheduleFetchFor: packageSpec externalReference: externalReference ] in MetacelloFetchingMCSpecLoader>>linearLoadPackageSpec:gofer:
[:bar |
            bar value: 1.
            aBlock value.
            bar value: 2 ] in IceMetacelloPharoPlatform(MetacelloPharoCommonPlatform)>>do:displaying:
FullBlockClosure(BlockClosure)>>cull:
[ ^ block cull: self ] in [ self prepareForRunning.
	  CurrentJob value: self during: [ ^ block cull: self ] ] in Job>>run
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in CurrentJob(DynamicVariable)>>value:during:
FullBlockClosure(BlockClosure)>>ensure:
CurrentJob(DynamicVariable)>>value:during:
CurrentJob class(DynamicVariable class)>>value:during:
[ self prepareForRunning.
	  CurrentJob value: self during: [ ^ block cull: self ] ] in Job>>run
FullBlockClosure(BlockClosure)>>ensure:
Job>>run
MorphicUIManager(UIManager)>>displayProgress:from:to:during:
ByteString(String)>>displayProgressFrom:to:during:
IceMetacelloPharoPlatform(MetacelloPharoCommonPlatform)>>do:displaying:
MetacelloFetchingMCSpecLoader>>linearLoadPackageSpec:gofer:
MetacelloPackageSpec>>loadUsing:gofer:
[:pkg | pkg loadUsing: self gofer: gofer ] in MetacelloFetchingMCSpecLoader(MetacelloCommonMCSpecLoader)>>linearLoadPackageSpecs:repositories:
Array(SequenceableCollection)>>do:
MetacelloFetchingMCSpecLoader(MetacelloCommonMCSpecLoader)>>linearLoadPackageSpecs:repositories:
[ super linearLoadPackageSpecs: packageSpecs repositories: repositories ] in MetacelloFetchingMCSpecLoader>>explicitLoadPackageSpecs:repositories:
FullBlockClosure(BlockClosure)>>ensure:
MetacelloLoaderPolicy>>pushLoadDirective:during:
MetacelloLoaderPolicy>>pushExplicitLoadDirectivesDuring:for:
MetacelloFetchingMCSpecLoader>>explicitLoadPackageSpecs:repositories:
MetacelloPackageSpec>>explicitLoadUsing:
MetacelloPackageSpec>>load
[ spec projectPackage load ] in MetacelloScriptEngine>>getBaselineUnconditionalLoad:
FullBlockClosure(BlockClosure)>>on:do:
MetacelloScriptEngine>>getBaselineUnconditionalLoad:
MetacelloScriptEngine>>getBaselineProjectUnconditionalLoad:
MetacelloMCBaselineProject>>projectForScriptEngine:unconditionalLoad:
MetacelloMCBaselineProject(MetacelloProject)>>projectForScriptEngine:
MetacelloMCBaselineOfProjectSpec(MetacelloMCProjectSpec)>>versionForScriptEngine:
[ 
          | version loadedSpec |
          self setDefaultsAndValidateProjectSpec.
          [ loadedSpec := (self lookupProjectSpecFor: self projectSpec) copy ]
            on: MetacelloAllowProjectDowngrade , MetacelloAllowProjectUpgrade
            do: [ :ex | ex handleOnDownGrade: onDownGradeBlock onUpgrade: onUpgradeBlock ].
          version := loadedSpec versionForScriptEngine: self.
          self
            root:
              (required isEmpty
                ifTrue: [ version load ]
                ifFalse: [ version load: required ]) loadDirective.
          loadedSpec loads: required.
          MetacelloProjectRegistration
            registrationForProjectSpec: loadedSpec
            ifAbsent: [ :new | 
              new
                loadedInImage: true;
                registerProject ]
            ifPresent: [ :existing :new | 
              existing
                copyOnWrite: [ :existingCopy | 
                  existingCopy
                    loadedInImage: true;
                    merge: new ] ] ] in [ 
      self
        handleNotificationsForAction: [ 
          | version loadedSpec |
          self setDefaultsAndValidateProjectSpec.
          [ loadedSpec := (self lookupProjectSpecFor: self projectSpec) copy ]
            on: MetacelloAllowProjectDowngrade , MetacelloAllowProjectUpgrade
            do: [ :ex | ex handleOnDownGrade: onDownGradeBlock onUpgrade: onUpgradeBlock ].
          version := loadedSpec versionForScriptEngine: self.
          self
            root:
              (required isEmpty
                ifTrue: [ version load ]
                ifFalse: [ version load: required ]) loadDirective.
          loadedSpec loads: required.
          MetacelloProjectRegistration
            registrationForProjectSpec: loadedSpec
            ifAbsent: [ :new | 
              new
                loadedInImage: true;
                registerProject ]
            ifPresent: [ :existing :new | 
              existing
                copyOnWrite: [ :existingCopy | 
                  existingCopy
                    loadedInImage: true;
                    merge: new ] ] ] ] in MetacelloScriptEngine>>load:onProjectDownGrade:onProjectUpgrade:
FullBlockClosure(BlockClosure)>>on:do:
[ 
  actionBlock
    on:
      MetacelloLookupProjectSpec , MetacelloLookupProjectSpecForLoad
        , MetacelloProjectSpecLoadedNotification
        , MetacelloScriptEnsureProjectLoadedForDevelopment
        , MetacelloLookupBaselineSpecForEnsureLoad
    do: [ :ex | 
      "lookup and registration handlers need to be innermost set of handlers ...they may throw option notifications"
      ex handleResolutionFor: self ] ] in [ 
  [ 
  actionBlock
    on:
      MetacelloLookupProjectSpec , MetacelloLookupProjectSpecForLoad
        , MetacelloProjectSpecLoadedNotification
        , MetacelloScriptEnsureProjectLoadedForDevelopment
        , MetacelloLookupBaselineSpecForEnsureLoad
    do: [ :ex | 
      "lookup and registration handlers need to be innermost set of handlers ...they may throw option notifications"
      ex handleResolutionFor: self ] ]
    on:
      MetacelloAllowProjectDowngrade , MetacelloAllowProjectUpgrade
        , MetacelloAllowConflictingProjectUpgrade
    do: [ :ex | 
      "option handlers need to be outermost set of handlers ... last line of defense before users are involved"
      ex handleResolutionFor: self ] ] in [ 
  [ 
  [ 
  actionBlock
    on:
      MetacelloLookupProjectSpec , MetacelloLookupProjectSpecForLoad
        , MetacelloProjectSpecLoadedNotification
        , MetacelloScriptEnsureProjectLoadedForDevelopment
        , MetacelloLookupBaselineSpecForEnsureLoad
    do: [ :ex | 
      "lookup and registration handlers need to be innermost set of handlers ...they may throw option notifications"
      ex handleResolutionFor: self ] ]
    on:
      MetacelloAllowProjectDowngrade , MetacelloAllowProjectUpgrade
        , MetacelloAllowConflictingProjectUpgrade
    do: [ :ex | 
      "option handlers need to be outermost set of handlers ... last line of defense before users are involved"
      ex handleResolutionFor: self ] ]
    on: MetacelloAllowLockedProjectChange
    do: [ :ex | 
      "MetacelloAllowLockedProjectChange need to be outermost handler ... since it is signaled from second line of handlers"
      ex handleResolutionFor: self ] ] in MetacelloScriptEngine>>handleNotificationsForAction:
FullBlockClosure(BlockClosure)>>on:do:
[ 
  [ 
  actionBlock
    on:
      MetacelloLookupProjectSpec , MetacelloLookupProjectSpecForLoad
        , MetacelloProjectSpecLoadedNotification
        , MetacelloScriptEnsureProjectLoadedForDevelopment
        , MetacelloLookupBaselineSpecForEnsureLoad
    do: [ :ex | 
      "lookup and registration handlers need to be innermost set of handlers ...they may throw option notifications"
      ex handleResolutionFor: self ] ]
    on:
      MetacelloAllowProjectDowngrade , MetacelloAllowProjectUpgrade
        , MetacelloAllowConflictingProjectUpgrade
    do: [ :ex | 
      "option handlers need to be outermost set of handlers ... last line of defense before users are involved"
      ex handleResolutionFor: self ] ] in [ 
  [ 
  [ 
  actionBlock
    on:
      MetacelloLookupProjectSpec , MetacelloLookupProjectSpecForLoad
        , MetacelloProjectSpecLoadedNotification
        , MetacelloScriptEnsureProjectLoadedForDevelopment
        , MetacelloLookupBaselineSpecForEnsureLoad
    do: [ :ex | 
      "lookup and registration handlers need to be innermost set of handlers ...they may throw option notifications"
      ex handleResolutionFor: self ] ]
    on:
      MetacelloAllowProjectDowngrade , MetacelloAllowProjectUpgrade
        , MetacelloAllowConflictingProjectUpgrade
    do: [ :ex | 
      "option handlers need to be outermost set of handlers ... last line of defense before users are involved"
      ex handleResolutionFor: self ] ]
    on: MetacelloAllowLockedProjectChange
    do: [ :ex | 
      "MetacelloAllowLockedProjectChange need to be outermost handler ... since it is signaled from second line of handlers"
      ex handleResolutionFor: self ] ] in MetacelloScriptEngine>>handleNotificationsForAction:
 - - - - - - - - - - - - - - -
			- - - - - - - - - - - - - - - - - -
FullBlockClosure(BlockClosure)>>on:do:
[ 
  [ 
  [ 
  actionBlock
    on:
      MetacelloLookupProjectSpec , MetacelloLookupProjectSpecForLoad
        , MetacelloProjectSpecLoadedNotification
        , MetacelloScriptEnsureProjectLoadedForDevelopment
        , MetacelloLookupBaselineSpecForEnsureLoad
    do: [ :ex | 
      "lookup and registration handlers need to be innermost set of handlers ...they may throw option notifications"
      ex handleResolutionFor: self ] ]
    on:
      MetacelloAllowProjectDowngrade , MetacelloAllowProjectUpgrade
        , MetacelloAllowConflictingProjectUpgrade
    do: [ :ex | 
      "option handlers need to be outermost set of handlers ... last line of defense before users are involved"
      ex handleResolutionFor: self ] ]
    on: MetacelloAllowLockedProjectChange
    do: [ :ex | 
      "MetacelloAllowLockedProjectChange need to be outermost handler ... since it is signaled from second line of handlers"
      ex handleResolutionFor: self ] ] in MetacelloScriptEngine>>handleNotificationsForAction:
FullBlockClosure(BlockClosure)>>on:do:
MetacelloScriptEngine>>handleNotificationsForAction:
[ 
      self
        handleNotificationsForAction: [ 
          | version loadedSpec |
          self setDefaultsAndValidateProjectSpec.
          [ loadedSpec := (self lookupProjectSpecFor: self projectSpec) copy ]
            on: MetacelloAllowProjectDowngrade , MetacelloAllowProjectUpgrade
            do: [ :ex | ex handleOnDownGrade: onDownGradeBlock onUpgrade: onUpgradeBlock ].
          version := loadedSpec versionForScriptEngine: self.
          self
            root:
              (required isEmpty
                ifTrue: [ version load ]
                ifFalse: [ version load: required ]) loadDirective.
          loadedSpec loads: required.
          MetacelloProjectRegistration
            registrationForProjectSpec: loadedSpec
            ifAbsent: [ :new | 
              new
                loadedInImage: true;
                registerProject ]
            ifPresent: [ :existing :new | 
              existing
                copyOnWrite: [ :existingCopy | 
                  existingCopy
                    loadedInImage: true;
                    merge: new ] ] ] ] in MetacelloScriptEngine>>load:onProjectDownGrade:onProjectUpgrade:
FullBlockClosure(BlockClosure)>>ensure:
MetacelloProjectRegistration class>>copyRegistryRestoreOnErrorWhile:
MetacelloScriptEngine>>load:onProjectDownGrade:onProjectUpgrade:
MetacelloScriptEngine>>load:
[ :projectSpec | 
      | engine |
      engine := MetacelloScriptEngine new
        options: self options copy;
        projectSpec: projectSpec;
        yourself.
      engine perform: actionArg key withArguments: actionArg value.
      engine root ifNotNil: [ :root | self roots add: root ] ] in MetacelloScriptApiExecutor(MetacelloScriptExecutor)>>execute:
[ :projectSpec | 
      projectSpec
        ifNotNil: [ projectSpecBlock value: (self applyArgsToProjectSpec: projectSpec copy) ] ] in MetacelloScriptApiExecutor>>executeString:do:
Array(SequenceableCollection)>>do:
MetacelloScriptApiExecutor>>executeString:do:
ByteString(String)>>execute:against:
MetacelloScriptApiExecutor(MetacelloScriptExecutor)>>execute:
[ 
		super execute: statements ] in MetacelloScriptApiExecutor>>execute:
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in IceMetacelloLoadSessionContext(DynamicVariable)>>value:during:
FullBlockClosure(BlockClosure)>>ensure:
IceMetacelloLoadSessionContext(DynamicVariable)>>value:during:
IceMetacelloLoadSessionContext class(DynamicVariable class)>>value:during:
IceMetacelloPharoPlatform>>withMetacelloLoadSessionDo:
MetacelloScriptApiExecutor>>execute:
Metacello>>execute:args:
Metacello>>load
UndefinedObject>>DoIt
OCReceiverDoItSemanticScope(OCDoItSemanticScope)>>evaluateDoIt:
OpalCompiler>>evaluate
[
		self announcer announce: (SpCodeWillBeEvaluatedAnnouncement newContent: aString).
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionModel doItReceiver.
		result := receiver class compiler
			source: aString;
			context: self interactionModel doItContext;
			receiver: self interactionModel doItReceiver;
			requestor: self interactionModel;
			environment: self environment;
			failBlock:  [ 
				self announcer announce: (SpCodeEvaluationFailedAnnouncement newContent: aString).
				^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		self announcer announce: (SpCodeEvaluationSucceedAnnouncement newContent: aString).
		result ] in SpCodePresenter>>evaluate:onCompileError:onError:
FullBlockClosure(BlockClosure)>>on:do:
SpCodePresenter>>evaluate:onCompileError:onError:
StPlaygroundPagePresenter>>doEvaluateAndGo
StPlaygroundPagePresenter>>doEvaluateAllAndGo
StPlaygroundDoItCommand>>execute
SpCommand(CmCommandDecorator)>>execute
[ specCommand execute ] in [ :specCommand | 
			aButtonClass new
				label: specCommand name;
				help: specCommand description;
				in: [ :button | 
					specCommand hasIcon
						ifTrue: [ button icon: specCommand icon ] ];
				action: [ specCommand execute ];
				yourself ] in SpCommand>>configureAsButtonOfClass:
FullBlockClosure(BlockClosure)>>cull:
SpMorphicToolbarButtonAdapter>>execute
SpToolbarButtonMorph(PluggableButtonMorph)>>performAction:
[:m |
		(m containsPoint: evt cursorPoint) ifTrue: [m enabled ifTrue: [ m performAction: evt ]]] in SpToolbarButtonMorph(PluggableButtonMorph)>>mouseUp:
Array(SequenceableCollection)>>do:
SpToolbarButtonMorph(PluggableButtonMorph)>>mouseUp:
SpToolbarButtonMorph(Morph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
SpToolbarButtonMorph(Morph)>>handleEvent:
SpToolbarButtonMorph(Morph)>>handleFocusEvent:
[
		result := focusHolder handleFocusEvent: transformedEvent.
	] in HandMorph>>sendFocusEvent:to:clear:
FullBlockClosure(BlockClosure)>>on:do:
WorldMorph>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil ]) ifTrue: [
			morphicWorld activeHand handleEvent: anEvent
		]
	] in OSWindowMorphicEventHandler>>dispatchMorphicEvent:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycleNow
WorldMorph>>doOneCycle
[
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMutex critical: [
			                     self extraWorldList ].
		extraWorldsToDraw do: [ :world | world doOneCycle ].

		(self currentWorld isNotNil and: [
			 (extraWorldsToDraw includes: self currentWorld) not ]) ifTrue: [
			self currentWorld doOneCycle ] ] in WorldMorph class>>doOneCycle
FullBlockClosure(BlockClosure)>>ensure:
WorldState class>>doDrawCycleWith:
WorldMorph class>>doOneCycle
MorphicRenderLoop>>doOneCycle
MorphicRenderLoop>>doOneCycleWhile:
[ MorphicRenderLoop new doOneCycleWhile: [ true ] ] in MorphicUIManager>>spawnNewProcess
[self value.
			"IMPORTANT: Do not step over next line of code. See method comments for details"
			Processor terminateRealActive] in FullBlockClosure(BlockClosure)>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
Warning: Package *Roassal3-Pharo9 depends on the following classes:
  RSLayoutStudio
You must resolve these dependencies before you will be able to load these definitions: 
  RSLayoutStudio>>#defaultSpec

23 October 2023 11:25:38.372869 pm

VM: Mac OS - arm64 - 1000 - CoInterpreter VMMaker-tonel.1 uuid: 902dd483-c0c4-0d00-86f2-0f880df24b96 Oct 23 2023
StackToRegisterMappingCogit VMMaker-tonel.1 uuid: 902dd483-c0c4-0d00-86f2-0f880df24b96 Oct 23 2023
v10.0.8 - Commit: b323c5fb - Date: 2023-10-20 16:02:07 -0400

Image: Pharo11.0.0 [Build information: Pharo-11.0.0+build.710.sha.ea28d8552cac85a7ce1e9c34ab1e7bd45f7b9910 (64 Bit)]

MCPackageLoader(Object)>>notify:
	Receiver: a MCPackageLoader
	Arguments and temporary variables: 
		aString: 	'Package *Roassal3-Pharo9 depends on the following classes:
  RSLa[..]
	Receiver's instance variables: 
		requirements: 	#(#RSLayoutStudio)
		unloadableDefinitions: 	a SortedCollection(a MCMethodDefinition(RSLayoutStud[..]
		obsoletions: 	a Dictionary()
		additions: 	an OrderedCollection(a MCMethodDefinition(SpPresenter>>#open) a [..]
		removals: 	an OrderedCollection()
		errorDefinitions: 	nil
		provisions: 	a Set(#TRemoveTest #WeakSet #RSHorizontalLeftRightController #S[..]
		methodAdditions: 	an OrderedCollection()


MCPackageLoader>>warnAboutDependencies
	Receiver: a MCPackageLoader
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		requirements: 	#(#RSLayoutStudio)
		unloadableDefinitions: 	a SortedCollection(a MCMethodDefinition(RSLayoutStud[..]
		obsoletions: 	a Dictionary()
		additions: 	an OrderedCollection(a MCMethodDefinition(SpPresenter>>#open) a [..]
		removals: 	an OrderedCollection()
		errorDefinitions: 	nil
		provisions: 	a Set(#TRemoveTest #WeakSet #RSHorizontalLeftRightController #S[..]
		methodAdditions: 	an OrderedCollection()


MCPackageLoader>>validate
	Receiver: a MCPackageLoader
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		requirements: 	#(#RSLayoutStudio)
		unloadableDefinitions: 	a SortedCollection(a MCMethodDefinition(RSLayoutStud[..]
		obsoletions: 	a Dictionary()
		additions: 	an OrderedCollection(a MCMethodDefinition(SpPresenter>>#open) a [..]
		removals: 	an OrderedCollection()
		errorDefinitions: 	nil
		provisions: 	a Set(#TRemoveTest #WeakSet #RSHorizontalLeftRightController #S[..]
		methodAdditions: 	an OrderedCollection()


MCPackageLoader>>loadWithNameLike:
	Receiver: a MCPackageLoader
	Arguments and temporary variables: 
		baseName: 	'Roassal3-Pharo9-CompatibleUserName.1686657480'
	Receiver's instance variables: 
		requirements: 	#(#RSLayoutStudio)
		unloadableDefinitions: 	a SortedCollection(a MCMethodDefinition(RSLayoutStud[..]
		obsoletions: 	a Dictionary()
		additions: 	an OrderedCollection(a MCMethodDefinition(SpPresenter>>#open) a [..]
		removals: 	an OrderedCollection()
		errorDefinitions: 	nil
		provisions: 	a Set(#TRemoveTest #WeakSet #RSHorizontalLeftRightController #S[..]
		methodAdditions: 	an OrderedCollection()


MCVersionLoader>>basicLoadWithNameLike:
	Receiver: a MCVersionLoader
	Arguments and temporary variables: 
		aString: 	'Roassal3-Pharo9-CompatibleUserName.1686657480'
		loader: 	a MCPackageLoader
	Receiver's instance variables: 
		versions: 	an OrderedCollection(a MCVersion(an IceMCVersionInfo(Roassal3-Pha[..]


[ self basicLoadWithNameLike: aString ] in MCVersionLoader>>loadWithNameLike:
	Receiver: a MCVersionLoader
	Arguments and temporary variables: 
		aString: 	'Roassal3-Pharo9-CompatibleUserName.1686657480'
	Receiver's instance variables: 
		versions: 	an OrderedCollection(a MCVersion(an IceMCVersionInfo(Roassal3-Pha[..]


[ returnValue := aBlock value ] in [ 
		[ returnValue := aBlock value ] ensure: [ 
			self announceLoadStop: aString ] ] in MCVersionLoader>>announceLoad:do:
	Receiver: a MCVersionLoader
	Arguments and temporary variables: 
		aString: 	'Roassal3-Pharo9-CompatibleUserName.1686657480'
		aBlock: 	[ self basicLoadWithNameLike: aString ]
		returnValue: 	nil
	Receiver's instance variables: 
		versions: 	an OrderedCollection(a MCVersion(an IceMCVersionInfo(Roassal3-Pha[..]


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ returnValue := aBlock value ]
	Arguments and temporary variables: 
		aBlock: 	[ 
			self announceLoadStop: aString ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	[ 
		[ returnValue := aBlock value ] ensure: [ 
			self annou[..]
		compiledBlock: 	a CompiledBlock: [ returnValue := aBlock value ]
		numArgs: 	0
		receiver: 	a MCVersionLoader


[ 
		[ returnValue := aBlock value ] ensure: [ 
			self announceLoadStop: aString ] ] in MCVersionLoader>>announceLoad:do:
	Receiver: a MCVersionLoader
	Arguments and temporary variables: 
		aString: 	'Roassal3-Pharo9-CompatibleUserName.1686657480'
		aBlock: 	[ self basicLoadWithNameLike: aString ]
		returnValue: 	nil
	Receiver's instance variables: 
		versions: 	an OrderedCollection(a MCVersion(an IceMCVersionInfo(Roassal3-Pha[..]


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ self announceLoadStart: aString ]
	Arguments and temporary variables: 
		aBlock: 	[ 
		[ returnValue := aBlock value ] ensure: [ 
			self announceLoa[..]
		complete: 	true
		returnValue: 	a MCVersionLoader
	Receiver's instance variables: 
		outerContext: 	MCVersionLoader>>announceLoad:do:
		compiledBlock: 	a CompiledBlock: [ self announceLoadStart: aString ]
		numArgs: 	0
		receiver: 	a MCVersionLoader


MCVersionLoader>>announceLoad:do:
	Receiver: a MCVersionLoader
	Arguments and temporary variables: 
		returnValue: 	nil
		aString: 	'Roassal3-Pharo9-CompatibleUserName.1686657480'
		aBlock: 	[ self basicLoadWithNameLike: aString ]
	Receiver's instance variables: 
		versions: 	an OrderedCollection(a MCVersion(an IceMCVersionInfo(Roassal3-Pha[..]


MCVersionLoader>>loadWithNameLike:
	Receiver: a MCVersionLoader
	Arguments and temporary variables: 
		aString: 	'Roassal3-Pharo9-CompatibleUserName.1686657480'
	Receiver's instance variables: 
		versions: 	an OrderedCollection(a MCVersion(an IceMCVersionInfo(Roassal3-Pha[..]


[ self ensurePackage: version package.
		  self loadWithNameLike: version info name ] in [   
		| version |
		version := versions first. 
		[ self ensurePackage: version package.
		  self loadWithNameLike: version info name ] asJob
				title: 'Loading ', version info name asString;
				run ] in MCVersionLoader>>load
	Receiver: a MCVersionLoader
	Arguments and temporary variables: 
		version: 	a MCVersion(an IceMCVersionInfo(Roassal3-Pharo9-CompatibleUserName[..]
	Receiver's instance variables: 
		versions: 	an OrderedCollection(a MCVersion(an IceMCVersionInfo(Roassal3-Pha[..]


FullBlockClosure(BlockClosure)>>cull:
	Receiver: [ self ensurePackage: version package.
		  self loadWithNameLike: version info name ]
	Arguments and temporary variables: 
		anArg: 	a Job
	Receiver's instance variables: 
		outerContext: 	[   
		| version |
		version := versions first. 
		[ self ens[..]
		compiledBlock: 	a CompiledBlock: [ self ensurePackage: version package.
		  [..]
		numArgs: 	0
		receiver: 	a MCVersionLoader


[ ^ block cull: self ] in [ self prepareForRunning.
	  CurrentJob value: self during: [ ^ block cull: self ] ] in Job>>run
	Receiver: a Job
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		block: 	[ self ensurePackage: version package.
		  self loadWithNameLike: ve[..]
		currentValue: 	0
		min: 	0
		max: 	100
		title: 	'Loading Roassal3-Pharo9-CompatibleUserName.1686657480'
		children: 	an OrderedCollection()
		isRunning: 	true
		parent: 	a Job
		process: 	a Process in nil
		owner: 	a MCVersionLoader


[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in CurrentJob(DynamicVariable)>>value:during:
	Receiver: a CurrentJob
	Arguments and temporary variables: 
		anObject: 	a Job
		aBlock: 	[ ^ block cull: self ]
		activeProcess: 	a Process in nil
		oldValue: 	a Job
	Receiver's instance variables: 
		index: 	2


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ]
	Arguments and temporary variables: 
		aBlock: 	[
			activeProcess
				psValueAt: index
				put: oldValue ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	CurrentJob(DynamicVariable)>>value:during:
		compiledBlock: 	a CompiledBlock: [ activeProcess
			psValueAt: index
			put:[..]
		numArgs: 	0
		receiver: 	a CurrentJob


CurrentJob(DynamicVariable)>>value:during:
	Receiver: a CurrentJob
	Arguments and temporary variables: 
		anObject: 	a Job
		aBlock: 	[ ^ block cull: self ]
		activeProcess: 	a Process in nil
		oldValue: 	a Job
	Receiver's instance variables: 
		index: 	2


CurrentJob class(DynamicVariable class)>>value:during:
	Receiver: CurrentJob
	Arguments and temporary variables: 
		anObject: 	a Job
		aBlock: 	[ ^ block cull: self ]
	Receiver's instance variables: 
		superclass: 	DynamicVariable
		methodDict: 	a MethodDictionary()
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		commentSourcePointer: 	nil
		subclasses: 	nil
		name: 	#CurrentJob
		classPool: 	nil
		sharedPools: 	nil
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Jobs-Base'
		soleInstance: 	a CurrentJob


[ self prepareForRunning.
	  CurrentJob value: self during: [ ^ block cull: self ] ] in Job>>run
	Receiver: a Job
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		block: 	[ self ensurePackage: version package.
		  self loadWithNameLike: ve[..]
		currentValue: 	0
		min: 	0
		max: 	100
		title: 	'Loading Roassal3-Pharo9-CompatibleUserName.1686657480'
		children: 	an OrderedCollection()
		isRunning: 	true
		parent: 	a Job
		process: 	a Process in nil
		owner: 	a MCVersionLoader


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ self prepareForRunning.
	  CurrentJob value: self during: [ ^ block cull: self ] ]
	Arguments and temporary variables: 
		aBlock: 	[ self cleanupAfterRunning ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	Job>>run
		compiledBlock: 	a CompiledBlock: [ self prepareForRunning.
	  CurrentJob val[..]
		numArgs: 	0
		receiver: 	a Job


Job>>run
	Receiver: a Job
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		block: 	[ self ensurePackage: version package.
		  self loadWithNameLike: ve[..]
		currentValue: 	0
		min: 	0
		max: 	100
		title: 	'Loading Roassal3-Pharo9-CompatibleUserName.1686657480'
		children: 	an OrderedCollection()
		isRunning: 	true
		parent: 	a Job
		process: 	a Process in nil
		owner: 	a MCVersionLoader


[   
		| version |
		version := versions first. 
		[ self ensurePackage: version package.
		  self loadWithNameLike: version info name ] asJob
				title: 'Loading ', version info name asString;
				run ] in MCVersionLoader>>load
	Receiver: a MCVersionLoader
	Arguments and temporary variables: 
		version: 	a MCVersion(an IceMCVersionInfo(Roassal3-Pharo9-CompatibleUserName[..]
	Receiver's instance variables: 
		versions: 	an OrderedCollection(a MCVersion(an IceMCVersionInfo(Roassal3-Pha[..]


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [   
		| version |
		version := versions first. 
		[ self ensurePackage: version packa[..]
	Arguments and temporary variables: 
		aBlock: 	[
		self cacheActive: oldActive.
		self isCacheActive ifFalse: [ se[..]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	MCVersionLoader>>load
		compiledBlock: 	a CompiledBlock: [   
		| version |
		version := versions fi[..]
		numArgs: 	0
		receiver: 	a MCVersionLoader


RPackageSet class>>withCacheDo:
	Receiver: RPackageSet
	Arguments and temporary variables: 
		aBlock: 	[   
		| version |
		version := versions first. 
		[ self ensurePac[..]
		oldActive: 	false
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary(#asRPackageSet->RPackageSet>>#asRPackageSet [..]
		format: 	65543
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		commentSourcePointer: 	nil
		subclasses: 	{MetacelloTestsPackageSet}
		name: 	#RPackageSet
		classPool: 	nil
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'RPackage-Core-Base'
		cacheActive: 	true
		cachePackages: 	an IdentityDictionary(#'Roassal3-Pharo9'->a RPackageSet )


MCVersionLoader>>load
	Receiver: a MCVersionLoader
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		versions: 	an OrderedCollection(a MCVersion(an IceMCVersionInfo(Roassal3-Pha[..]


MetacelloGoferLoad(GoferLoad)>>execute
	Receiver: a MetacelloGoferLoad
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		gofer: 	a MetacelloGofer
		model: 	a MCVersionLoader


[ "mcLoader preLoad: packageSpec."
			goferLoad := MetacelloGoferLoad on: aGofer.
			goferLoad addResolved: resolvedReference.
			goferLoad execute.
			MetacelloPlatform current clearCurrentVersionCache	"mcLoader postLoad: packageSpec"
			] in [ | loadBlock goferLoad answers resolvedReference |

			aGofer disablePackageCache.	"for good luck:)"
			resolvedReference := self resolvePackageSpec: packageSpec gofer: aGofer.
			resolvedReference ifNil: [ "Package version already loaded into image" ^ self ].
			loadBlock := [ "mcLoader preLoad: packageSpec."
			goferLoad := MetacelloGoferLoad on: aGofer.
			goferLoad addResolved: resolvedReference.
			goferLoad execute.
			MetacelloPlatform current clearCurrentVersionCache	"mcLoader postLoad: packageSpec"
			].
			MetacelloNotification signal:
					'Loading -> ' , resolvedReference name , ' --- '
						, aPackageLoadDirective repository repositoryDescription , ' --- '
						, resolvedReference repository description.
			( answers := packageSpec answers ) notEmpty
				ifTrue: [ loadBlock valueSupplyingMetacelloAnswers: answers ]
				ifFalse: [ loadBlock value ].
			resolvedReference workingCopy repositoryGroup addRepository: aPackageLoadDirective repository.
			MetacelloNotification signal:
					'Loaded -> ' , resolvedReference name , ' --- '
						, aPackageLoadDirective repository repositoryDescription , ' --- '
						, resolvedReference repository description
			] in MetacelloLoadingMCSpecLoader(MetacelloCommonMCSpecLoader)>>loadPackageDirective:gofer:
	Receiver: a MetacelloLoadingMCSpecLoader
	Arguments and temporary variables: 
		aPackageLoadDirective: 	load : Roassal3-Pharo9-CompatibleUserName.1686657480
		aGofer: 	a MetacelloGofer
		packageSpec: 	spec name: #'Roassal3-Pharo9'
		loadBlock: 	[ "mcLoader preLoad: packageSpec."
			goferLoad := MetacelloGofe[..]
		answers: 	#()
		resolvedReference: 	a MetacelloCachingGoferResolvedReference name: 'Roassal3[..]
		goferLoad: 	a MetacelloGoferLoad
	Receiver's instance variables: 
		spec: 	a MetacelloMCVersionSpecLoader
		operator: 	nil
		loaderPolicy: 	a MetacelloLoaderPolicy
		disablePackageCache: 	false


[ | loadBlock goferLoad answers resolvedReference |

			aGofer disablePackageCache.	"for good luck:)"
			resolvedReference := self resolvePackageSpec: packageSpec gofer: aGofer.
			resolvedReference ifNil: [ "Package version already loaded into image" ^ self ].
			loadBlock := [ "mcLoader preLoad: packageSpec."
			goferLoad := MetacelloGoferLoad on: aGofer.
			goferLoad addResolved: resolvedReference.
			goferLoad execute.
			MetacelloPlatform current clearCurrentVersionCache	"mcLoader postLoad: packageSpec"
			].
			MetacelloNotification signal:
					'Loading -> ' , resolvedReference name , ' --- '
						, aPackageLoadDirective repository repositoryDescription , ' --- '
						, resolvedReference repository description.
			( answers := packageSpec answers ) notEmpty
				ifTrue: [ loadBlock valueSupplyingMetacelloAnswers: answers ]
				ifFalse: [ loadBlock value ].
			resolvedReference workingCopy repositoryGroup addRepository: aPackageLoadDirective repository.
			MetacelloNotification signal:
					'Loaded -> ' , resolvedReference name , ' --- '
						, aPackageLoadDirective repository repositoryDescription , ' --- '
						, resolvedReference repository description
			] in MetacelloLoadingMCSpecLoader(MetacelloCommonMCSpecLoader)>>loadPackageDirective:gofer:
	Receiver: a MetacelloLoadingMCSpecLoader
	Arguments and temporary variables: 
		aPackageLoadDirective: 	load : Roassal3-Pharo9-CompatibleUserName.1686657480
		aGofer: 	a MetacelloGofer
		packageSpec: 	spec name: #'Roassal3-Pharo9'
		goferLoad: 	a MetacelloGoferLoad
		loadBlock: 	[ "mcLoader preLoad: packageSpec."
			goferLoad := MetacelloGofe[..]
		answers: 	#()
		resolvedReference: 	a MetacelloCachingGoferResolvedReference name: 'Roassal3[..]
	Receiver's instance variables: 
		spec: 	a MetacelloMCVersionSpecLoader
		operator: 	nil
		loaderPolicy: 	a MetacelloLoaderPolicy
		disablePackageCache: 	false


[:bar |
            bar value: 1.
            aBlock value.
            bar value: 2 ] in IceMetacelloPharoPlatform(MetacelloPharoCommonPlatform)>>do:displaying:
	Receiver: an IceMetacelloPharoPlatform
	Arguments and temporary variables: 
		aBlock: 	[ | loadBlock goferLoad answers resolvedReference |

			aGofer disa[..]
		aString: 	'Loading Roassal3-Pharo9'
		bar: 	a Job
	Receiver's instance variables: 
		bypassProgressBars: 	false
		bypassGoferLoadUpdateCategories: 	false


FullBlockClosure(BlockClosure)>>cull:
	Receiver: [:bar |
            bar value: 1.
            aBlock value.
            bar value: 2 ]
	Arguments and temporary variables: 
		anArg: 	a Job
	Receiver's instance variables: 
		outerContext: 	IceMetacelloPharoPlatform(MetacelloPharoCommonPlatform)>>do:d[..]
		compiledBlock: 	a CompiledBlock: [:bar |
            bar value: 1.
         [..]
		numArgs: 	1
		receiver: 	an IceMetacelloPharoPlatform


[ ^ block cull: self ] in [ self prepareForRunning.
	  CurrentJob value: self during: [ ^ block cull: self ] ] in Job>>run
	Receiver: a Job
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		block: 	[:bar |
            bar value: 1.
            aBlock value.
        [..]
		currentValue: 	1
		min: 	0
		max: 	2
		title: 	'Loading Roassal3-Pharo9'
		children: 	an OrderedCollection(a Job)
		isRunning: 	true
		parent: 	a Job
		process: 	a Process in nil
		owner: 	a MorphicUIManager


[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in CurrentJob(DynamicVariable)>>value:during:
	Receiver: a CurrentJob
	Arguments and temporary variables: 
		anObject: 	a Job
		aBlock: 	[ ^ block cull: self ]
		activeProcess: 	a Process in nil
		oldValue: 	a Job
	Receiver's instance variables: 
		index: 	2


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ]
	Arguments and temporary variables: 
		aBlock: 	[
			activeProcess
				psValueAt: index
				put: oldValue ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	CurrentJob(DynamicVariable)>>value:during:
		compiledBlock: 	a CompiledBlock: [ activeProcess
			psValueAt: index
			put:[..]
		numArgs: 	0
		receiver: 	a CurrentJob


CurrentJob(DynamicVariable)>>value:during:
	Receiver: a CurrentJob
	Arguments and temporary variables: 
		anObject: 	a Job
		aBlock: 	[ ^ block cull: self ]
		activeProcess: 	a Process in nil
		oldValue: 	a Job
	Receiver's instance variables: 
		index: 	2


CurrentJob class(DynamicVariable class)>>value:during:
	Receiver: CurrentJob
	Arguments and temporary variables: 
		anObject: 	a Job
		aBlock: 	[ ^ block cull: self ]
	Receiver's instance variables: 
		superclass: 	DynamicVariable
		methodDict: 	a MethodDictionary()
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		commentSourcePointer: 	nil
		subclasses: 	nil
		name: 	#CurrentJob
		classPool: 	nil
		sharedPools: 	nil
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Jobs-Base'
		soleInstance: 	a CurrentJob


[ self prepareForRunning.
	  CurrentJob value: self during: [ ^ block cull: self ] ] in Job>>run
	Receiver: a Job
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		block: 	[:bar |
            bar value: 1.
            aBlock value.
        [..]
		currentValue: 	1
		min: 	0
		max: 	2
		title: 	'Loading Roassal3-Pharo9'
		children: 	an OrderedCollection(a Job)
		isRunning: 	true
		parent: 	a Job
		process: 	a Process in nil
		owner: 	a MorphicUIManager


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ self prepareForRunning.
	  CurrentJob value: self during: [ ^ block cull: self ] ]
	Arguments and temporary variables: 
		aBlock: 	[ self cleanupAfterRunning ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	Job>>run
		compiledBlock: 	a CompiledBlock: [ self prepareForRunning.
	  CurrentJob val[..]
		numArgs: 	0
		receiver: 	a Job


Job>>run
	Receiver: a Job
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		block: 	[:bar |
            bar value: 1.
            aBlock value.
        [..]
		currentValue: 	1
		min: 	0
		max: 	2
		title: 	'Loading Roassal3-Pharo9'
		children: 	an OrderedCollection(a Job)
		isRunning: 	true
		parent: 	a Job
		process: 	a Process in nil
		owner: 	a MorphicUIManager



--- The full stack ---
MCPackageLoader(Object)>>notify:
MCPackageLoader>>warnAboutDependencies
MCPackageLoader>>validate
MCPackageLoader>>loadWithNameLike:
MCVersionLoader>>basicLoadWithNameLike:
[ self basicLoadWithNameLike: aString ] in MCVersionLoader>>loadWithNameLike:
[ returnValue := aBlock value ] in [ 
		[ returnValue := aBlock value ] ensure: [ 
			self announceLoadStop: aString ] ] in MCVersionLoader>>announceLoad:do:
FullBlockClosure(BlockClosure)>>ensure:
[ 
		[ returnValue := aBlock value ] ensure: [ 
			self announceLoadStop: aString ] ] in MCVersionLoader>>announceLoad:do:
FullBlockClosure(BlockClosure)>>ensure:
MCVersionLoader>>announceLoad:do:
MCVersionLoader>>loadWithNameLike:
[ self ensurePackage: version package.
		  self loadWithNameLike: version info name ] in [   
		| version |
		version := versions first. 
		[ self ensurePackage: version package.
		  self loadWithNameLike: version info name ] asJob
				title: 'Loading ', version info name asString;
				run ] in MCVersionLoader>>load
FullBlockClosure(BlockClosure)>>cull:
[ ^ block cull: self ] in [ self prepareForRunning.
	  CurrentJob value: self during: [ ^ block cull: self ] ] in Job>>run
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in CurrentJob(DynamicVariable)>>value:during:
FullBlockClosure(BlockClosure)>>ensure:
CurrentJob(DynamicVariable)>>value:during:
CurrentJob class(DynamicVariable class)>>value:during:
[ self prepareForRunning.
	  CurrentJob value: self during: [ ^ block cull: self ] ] in Job>>run
FullBlockClosure(BlockClosure)>>ensure:
Job>>run
[   
		| version |
		version := versions first. 
		[ self ensurePackage: version package.
		  self loadWithNameLike: version info name ] asJob
				title: 'Loading ', version info name asString;
				run ] in MCVersionLoader>>load
FullBlockClosure(BlockClosure)>>ensure:
RPackageSet class>>withCacheDo:
MCVersionLoader>>load
MetacelloGoferLoad(GoferLoad)>>execute
[ "mcLoader preLoad: packageSpec."
			goferLoad := MetacelloGoferLoad on: aGofer.
			goferLoad addResolved: resolvedReference.
			goferLoad execute.
			MetacelloPlatform current clearCurrentVersionCache	"mcLoader postLoad: packageSpec"
			] in [ | loadBlock goferLoad answers resolvedReference |

			aGofer disablePackageCache.	"for good luck:)"
			resolvedReference := self resolvePackageSpec: packageSpec gofer: aGofer.
			resolvedReference ifNil: [ "Package version already loaded into image" ^ self ].
			loadBlock := [ "mcLoader preLoad: packageSpec."
			goferLoad := MetacelloGoferLoad on: aGofer.
			goferLoad addResolved: resolvedReference.
			goferLoad execute.
			MetacelloPlatform current clearCurrentVersionCache	"mcLoader postLoad: packageSpec"
			].
			MetacelloNotification signal:
					'Loading -> ' , resolvedReference name , ' --- '
						, aPackageLoadDirective repository repositoryDescription , ' --- '
						, resolvedReference repository description.
			( answers := packageSpec answers ) notEmpty
				ifTrue: [ loadBlock valueSupplyingMetacelloAnswers: answers ]
				ifFalse: [ loadBlock value ].
			resolvedReference workingCopy repositoryGroup addRepository: aPackageLoadDirective repository.
			MetacelloNotification signal:
					'Loaded -> ' , resolvedReference name , ' --- '
						, aPackageLoadDirective repository repositoryDescription , ' --- '
						, resolvedReference repository description
			] in MetacelloLoadingMCSpecLoader(MetacelloCommonMCSpecLoader)>>loadPackageDirective:gofer:
[ | loadBlock goferLoad answers resolvedReference |

			aGofer disablePackageCache.	"for good luck:)"
			resolvedReference := self resolvePackageSpec: packageSpec gofer: aGofer.
			resolvedReference ifNil: [ "Package version already loaded into image" ^ self ].
			loadBlock := [ "mcLoader preLoad: packageSpec."
			goferLoad := MetacelloGoferLoad on: aGofer.
			goferLoad addResolved: resolvedReference.
			goferLoad execute.
			MetacelloPlatform current clearCurrentVersionCache	"mcLoader postLoad: packageSpec"
			].
			MetacelloNotification signal:
					'Loading -> ' , resolvedReference name , ' --- '
						, aPackageLoadDirective repository repositoryDescription , ' --- '
						, resolvedReference repository description.
			( answers := packageSpec answers ) notEmpty
				ifTrue: [ loadBlock valueSupplyingMetacelloAnswers: answers ]
				ifFalse: [ loadBlock value ].
			resolvedReference workingCopy repositoryGroup addRepository: aPackageLoadDirective repository.
			MetacelloNotification signal:
					'Loaded -> ' , resolvedReference name , ' --- '
						, aPackageLoadDirective repository repositoryDescription , ' --- '
						, resolvedReference repository description
			] in MetacelloLoadingMCSpecLoader(MetacelloCommonMCSpecLoader)>>loadPackageDirective:gofer:
[:bar |
            bar value: 1.
            aBlock value.
            bar value: 2 ] in IceMetacelloPharoPlatform(MetacelloPharoCommonPlatform)>>do:displaying:
FullBlockClosure(BlockClosure)>>cull:
[ ^ block cull: self ] in [ self prepareForRunning.
	  CurrentJob value: self during: [ ^ block cull: self ] ] in Job>>run
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in CurrentJob(DynamicVariable)>>value:during:
FullBlockClosure(BlockClosure)>>ensure:
CurrentJob(DynamicVariable)>>value:during:
CurrentJob class(DynamicVariable class)>>value:during:
[ self prepareForRunning.
	  CurrentJob value: self during: [ ^ block cull: self ] ] in Job>>run
FullBlockClosure(BlockClosure)>>ensure:
Job>>run
 - - - - - - - - - - - - - - -
			- - - - - - - - - - - - - - - - - -
MorphicUIManager(UIManager)>>displayProgress:from:to:during:
ByteString(String)>>displayProgressFrom:to:during:
IceMetacelloPharoPlatform(MetacelloPharoCommonPlatform)>>do:displaying:
MetacelloLoadingMCSpecLoader(MetacelloCommonMCSpecLoader)>>loadPackageDirective:gofer:
MetacelloLinearLoadDirective(MetacelloVersionLoadDirective)>>loadPackageDirective:gofer:
MetacelloPackageLoadDirective>>loadUsing:gofer:
[:directive | directive loadUsing: aLoaderDirective gofer: aGofer ] in MetacelloLinearLoadDirective(MetacelloVersionLoadDirective)>>loadLinearLoadDirective:gofer:
OrderedCollection>>do:
MetacelloLinearLoadDirective(MetacelloVersionLoadDirective)>>loadLinearLoadDirective:gofer:
MetacelloLinearLoadDirective>>loadUsing:gofer:
[:directive | directive loadUsing: aLoaderDirective gofer: aGofer ] in MetacelloLinearLoadDirective(MetacelloVersionLoadDirective)>>loadLinearLoadDirective:gofer:
OrderedCollection>>do:
MetacelloLinearLoadDirective(MetacelloVersionLoadDirective)>>loadLinearLoadDirective:gofer:
MetacelloLinearLoadDirective>>loadUsing:gofer:
MetacelloLinearLoadDirective(MetacelloVersionLoadDirective)>>loadWithPolicy:
MetacelloLoaderPolicy>>load
MetacelloFetchingMCSpecLoader>>doLoad
[  fetchLoader doLoad ] in [	| fetchLoader |
		fetchLoader := self fetchRequiredFromArray: (self defaultPackageNamesToLoad: anArray).
		MetacelloPlatform current
			do:  [  fetchLoader doLoad ]
			displaying: 'Loading ', displayString.
		MetacelloNotification signal: ('...finished ', self versionNumber printString).
		^fetchLoader ] in MetacelloMCVersion>>doLoadRequiredFromArray:
[:bar |
            bar value: 1.
            aBlock value.
            bar value: 2 ] in IceMetacelloPharoPlatform(MetacelloPharoCommonPlatform)>>do:displaying:
FullBlockClosure(BlockClosure)>>cull:
[ ^ block cull: self ] in [ self prepareForRunning.
	  CurrentJob value: self during: [ ^ block cull: self ] ] in Job>>run
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in CurrentJob(DynamicVariable)>>value:during:
FullBlockClosure(BlockClosure)>>ensure:
CurrentJob(DynamicVariable)>>value:during:
CurrentJob class(DynamicVariable class)>>value:during:
[ self prepareForRunning.
	  CurrentJob value: self during: [ ^ block cull: self ] ] in Job>>run
FullBlockClosure(BlockClosure)>>ensure:
Job>>run
MorphicUIManager(UIManager)>>displayProgress:from:to:during:
ByteString(String)>>displayProgressFrom:to:during:
IceMetacelloPharoPlatform(MetacelloPharoCommonPlatform)>>do:displaying:
[	| fetchLoader |
		fetchLoader := self fetchRequiredFromArray: (self defaultPackageNamesToLoad: anArray).
		MetacelloPlatform current
			do:  [  fetchLoader doLoad ]
			displaying: 'Loading ', displayString.
		MetacelloNotification signal: ('...finished ', self versionNumber printString).
		^fetchLoader ] in MetacelloMCVersion>>doLoadRequiredFromArray:
FullBlockClosure(BlockClosure)>>ensure:
MetacelloMCVersion>>doLoadRequiredFromArray:
MetacelloMCVersion>>load
[ 
          | version loadedSpec |
          self setDefaultsAndValidateProjectSpec.
          [ loadedSpec := (self lookupProjectSpecFor: self projectSpec) copy ]
            on: MetacelloAllowProjectDowngrade , MetacelloAllowProjectUpgrade
            do: [ :ex | ex handleOnDownGrade: onDownGradeBlock onUpgrade: onUpgradeBlock ].
          version := loadedSpec versionForScriptEngine: self.
          self
            root:
              (required isEmpty
                ifTrue: [ version load ]
                ifFalse: [ version load: required ]) loadDirective.
          loadedSpec loads: required.
          MetacelloProjectRegistration
            registrationForProjectSpec: loadedSpec
            ifAbsent: [ :new | 
              new
                loadedInImage: true;
                registerProject ]
            ifPresent: [ :existing :new | 
              existing
                copyOnWrite: [ :existingCopy | 
                  existingCopy
                    loadedInImage: true;
                    merge: new ] ] ] in [ 
      self
        handleNotificationsForAction: [ 
          | version loadedSpec |
          self setDefaultsAndValidateProjectSpec.
          [ loadedSpec := (self lookupProjectSpecFor: self projectSpec) copy ]
            on: MetacelloAllowProjectDowngrade , MetacelloAllowProjectUpgrade
            do: [ :ex | ex handleOnDownGrade: onDownGradeBlock onUpgrade: onUpgradeBlock ].
          version := loadedSpec versionForScriptEngine: self.
          self
            root:
              (required isEmpty
                ifTrue: [ version load ]
                ifFalse: [ version load: required ]) loadDirective.
          loadedSpec loads: required.
          MetacelloProjectRegistration
            registrationForProjectSpec: loadedSpec
            ifAbsent: [ :new | 
              new
                loadedInImage: true;
                registerProject ]
            ifPresent: [ :existing :new | 
              existing
                copyOnWrite: [ :existingCopy | 
                  existingCopy
                    loadedInImage: true;
                    merge: new ] ] ] ] in MetacelloScriptEngine>>load:onProjectDownGrade:onProjectUpgrade:
FullBlockClosure(BlockClosure)>>on:do:
[ 
  actionBlock
    on:
      MetacelloLookupProjectSpec , MetacelloLookupProjectSpecForLoad
        , MetacelloProjectSpecLoadedNotification
        , MetacelloScriptEnsureProjectLoadedForDevelopment
        , MetacelloLookupBaselineSpecForEnsureLoad
    do: [ :ex | 
      "lookup and registration handlers need to be innermost set of handlers ...they may throw option notifications"
      ex handleResolutionFor: self ] ] in [ 
  [ 
  actionBlock
    on:
      MetacelloLookupProjectSpec , MetacelloLookupProjectSpecForLoad
        , MetacelloProjectSpecLoadedNotification
        , MetacelloScriptEnsureProjectLoadedForDevelopment
        , MetacelloLookupBaselineSpecForEnsureLoad
    do: [ :ex | 
      "lookup and registration handlers need to be innermost set of handlers ...they may throw option notifications"
      ex handleResolutionFor: self ] ]
    on:
      MetacelloAllowProjectDowngrade , MetacelloAllowProjectUpgrade
        , MetacelloAllowConflictingProjectUpgrade
    do: [ :ex | 
      "option handlers need to be outermost set of handlers ... last line of defense before users are involved"
      ex handleResolutionFor: self ] ] in [ 
  [ 
  [ 
  actionBlock
    on:
      MetacelloLookupProjectSpec , MetacelloLookupProjectSpecForLoad
        , MetacelloProjectSpecLoadedNotification
        , MetacelloScriptEnsureProjectLoadedForDevelopment
        , MetacelloLookupBaselineSpecForEnsureLoad
    do: [ :ex | 
      "lookup and registration handlers need to be innermost set of handlers ...they may throw option notifications"
      ex handleResolutionFor: self ] ]
    on:
      MetacelloAllowProjectDowngrade , MetacelloAllowProjectUpgrade
        , MetacelloAllowConflictingProjectUpgrade
    do: [ :ex | 
      "option handlers need to be outermost set of handlers ... last line of defense before users are involved"
      ex handleResolutionFor: self ] ]
    on: MetacelloAllowLockedProjectChange
    do: [ :ex | 
      "MetacelloAllowLockedProjectChange need to be outermost handler ... since it is signaled from second line of handlers"
      ex handleResolutionFor: self ] ] in MetacelloScriptEngine>>handleNotificationsForAction:
FullBlockClosure(BlockClosure)>>on:do:
[ 
  [ 
  actionBlock
    on:
      MetacelloLookupProjectSpec , MetacelloLookupProjectSpecForLoad
        , MetacelloProjectSpecLoadedNotification
        , MetacelloScriptEnsureProjectLoadedForDevelopment
        , MetacelloLookupBaselineSpecForEnsureLoad
    do: [ :ex | 
      "lookup and registration handlers need to be innermost set of handlers ...they may throw option notifications"
      ex handleResolutionFor: self ] ]
    on:
      MetacelloAllowProjectDowngrade , MetacelloAllowProjectUpgrade
        , MetacelloAllowConflictingProjectUpgrade
    do: [ :ex | 
      "option handlers need to be outermost set of handlers ... last line of defense before users are involved"
      ex handleResolutionFor: self ] ] in [ 
  [ 
  [ 
  actionBlock
    on:
      MetacelloLookupProjectSpec , MetacelloLookupProjectSpecForLoad
        , MetacelloProjectSpecLoadedNotification
        , MetacelloScriptEnsureProjectLoadedForDevelopment
        , MetacelloLookupBaselineSpecForEnsureLoad
    do: [ :ex | 
      "lookup and registration handlers need to be innermost set of handlers ...they may throw option notifications"
      ex handleResolutionFor: self ] ]
    on:
      MetacelloAllowProjectDowngrade , MetacelloAllowProjectUpgrade
        , MetacelloAllowConflictingProjectUpgrade
    do: [ :ex | 
      "option handlers need to be outermost set of handlers ... last line of defense before users are involved"
      ex handleResolutionFor: self ] ]
    on: MetacelloAllowLockedProjectChange
    do: [ :ex | 
      "MetacelloAllowLockedProjectChange need to be outermost handler ... since it is signaled from second line of handlers"
      ex handleResolutionFor: self ] ] in MetacelloScriptEngine>>handleNotificationsForAction:
FullBlockClosure(BlockClosure)>>on:do:
[ 
  [ 
  [ 
  actionBlock
    on:
      MetacelloLookupProjectSpec , MetacelloLookupProjectSpecForLoad
        , MetacelloProjectSpecLoadedNotification
        , MetacelloScriptEnsureProjectLoadedForDevelopment
        , MetacelloLookupBaselineSpecForEnsureLoad
    do: [ :ex | 
      "lookup and registration handlers need to be innermost set of handlers ...they may throw option notifications"
      ex handleResolutionFor: self ] ]
    on:
      MetacelloAllowProjectDowngrade , MetacelloAllowProjectUpgrade
        , MetacelloAllowConflictingProjectUpgrade
    do: [ :ex | 
      "option handlers need to be outermost set of handlers ... last line of defense before users are involved"
      ex handleResolutionFor: self ] ]
    on: MetacelloAllowLockedProjectChange
    do: [ :ex | 
      "MetacelloAllowLockedProjectChange need to be outermost handler ... since it is signaled from second line of handlers"
      ex handleResolutionFor: self ] ] in MetacelloScriptEngine>>handleNotificationsForAction:
FullBlockClosure(BlockClosure)>>on:do:
MetacelloScriptEngine>>handleNotificationsForAction:
[ 
      self
        handleNotificationsForAction: [ 
          | version loadedSpec |
          self setDefaultsAndValidateProjectSpec.
          [ loadedSpec := (self lookupProjectSpecFor: self projectSpec) copy ]
            on: MetacelloAllowProjectDowngrade , MetacelloAllowProjectUpgrade
            do: [ :ex | ex handleOnDownGrade: onDownGradeBlock onUpgrade: onUpgradeBlock ].
          version := loadedSpec versionForScriptEngine: self.
          self
            root:
              (required isEmpty
                ifTrue: [ version load ]
                ifFalse: [ version load: required ]) loadDirective.
          loadedSpec loads: required.
          MetacelloProjectRegistration
            registrationForProjectSpec: loadedSpec
            ifAbsent: [ :new | 
              new
                loadedInImage: true;
                registerProject ]
            ifPresent: [ :existing :new | 
              existing
                copyOnWrite: [ :existingCopy | 
                  existingCopy
                    loadedInImage: true;
                    merge: new ] ] ] ] in MetacelloScriptEngine>>load:onProjectDownGrade:onProjectUpgrade:
FullBlockClosure(BlockClosure)>>ensure:
MetacelloProjectRegistration class>>copyRegistryRestoreOnErrorWhile:
MetacelloScriptEngine>>load:onProjectDownGrade:onProjectUpgrade:
MetacelloScriptEngine>>load:
[ :projectSpec | 
      | engine |
      engine := MetacelloScriptEngine new
        options: self options copy;
        projectSpec: projectSpec;
        yourself.
      engine perform: actionArg key withArguments: actionArg value.
      engine root ifNotNil: [ :root | self roots add: root ] ] in MetacelloScriptApiExecutor(MetacelloScriptExecutor)>>execute:
[ :projectSpec | 
      projectSpec
        ifNotNil: [ projectSpecBlock value: (self applyArgsToProjectSpec: projectSpec copy) ] ] in MetacelloScriptApiExecutor>>executeString:do:
Array(SequenceableCollection)>>do:
MetacelloScriptApiExecutor>>executeString:do:
ByteString(String)>>execute:against:
MetacelloScriptApiExecutor(MetacelloScriptExecutor)>>execute:
[ 
		super execute: statements ] in MetacelloScriptApiExecutor>>execute:
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in IceMetacelloLoadSessionContext(DynamicVariable)>>value:during:
FullBlockClosure(BlockClosure)>>ensure:
IceMetacelloLoadSessionContext(DynamicVariable)>>value:during:
IceMetacelloLoadSessionContext class(DynamicVariable class)>>value:during:
IceMetacelloPharoPlatform>>withMetacelloLoadSessionDo:
MetacelloScriptApiExecutor>>execute:
Metacello>>execute:args:
Metacello>>load
UndefinedObject>>DoIt
OCReceiverDoItSemanticScope(OCDoItSemanticScope)>>evaluateDoIt:
OpalCompiler>>evaluate
[
		self announcer announce: (SpCodeWillBeEvaluatedAnnouncement newContent: aString).
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionModel doItReceiver.
		result := receiver class compiler
			source: aString;
			context: self interactionModel doItContext;
			receiver: self interactionModel doItReceiver;
			requestor: self interactionModel;
			environment: self environment;
			failBlock:  [ 
				self announcer announce: (SpCodeEvaluationFailedAnnouncement newContent: aString).
				^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		self announcer announce: (SpCodeEvaluationSucceedAnnouncement newContent: aString).
		result ] in SpCodePresenter>>evaluate:onCompileError:onError:
FullBlockClosure(BlockClosure)>>on:do:
SpCodePresenter>>evaluate:onCompileError:onError:
StPlaygroundPagePresenter>>doEvaluateAndGo
StPlaygroundPagePresenter>>doEvaluateAllAndGo
StPlaygroundDoItCommand>>execute
SpCommand(CmCommandDecorator)>>execute
[ specCommand execute ] in [ :specCommand | 
			aButtonClass new
				label: specCommand name;
				help: specCommand description;
				in: [ :button | 
					specCommand hasIcon
						ifTrue: [ button icon: specCommand icon ] ];
				action: [ specCommand execute ];
				yourself ] in SpCommand>>configureAsButtonOfClass:
FullBlockClosure(BlockClosure)>>cull:
SpMorphicToolbarButtonAdapter>>execute
SpToolbarButtonMorph(PluggableButtonMorph)>>performAction:
[:m |
		(m containsPoint: evt cursorPoint) ifTrue: [m enabled ifTrue: [ m performAction: evt ]]] in SpToolbarButtonMorph(PluggableButtonMorph)>>mouseUp:
Array(SequenceableCollection)>>do:
SpToolbarButtonMorph(PluggableButtonMorph)>>mouseUp:
SpToolbarButtonMorph(Morph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
SpToolbarButtonMorph(Morph)>>handleEvent:
SpToolbarButtonMorph(Morph)>>handleFocusEvent:
[
		result := focusHolder handleFocusEvent: transformedEvent.
	] in HandMorph>>sendFocusEvent:to:clear:
FullBlockClosure(BlockClosure)>>on:do:
WorldMorph>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil ]) ifTrue: [
			morphicWorld activeHand handleEvent: anEvent
		]
	] in OSWindowMorphicEventHandler>>dispatchMorphicEvent:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycleNow
WorldMorph>>doOneCycle
[
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMutex critical: [
			                     self extraWorldList ].
		extraWorldsToDraw do: [ :world | world doOneCycle ].

		(self currentWorld isNotNil and: [
			 (extraWorldsToDraw includes: self currentWorld) not ]) ifTrue: [
			self currentWorld doOneCycle ] ] in WorldMorph class>>doOneCycle
FullBlockClosure(BlockClosure)>>ensure:
WorldState class>>doDrawCycleWith:
WorldMorph class>>doOneCycle
MorphicRenderLoop>>doOneCycle
MorphicRenderLoop>>doOneCycleWhile:
[ MorphicRenderLoop new doOneCycleWhile: [ true ] ] in MorphicUIManager>>spawnNewProcess
[self value.
			"IMPORTANT: Do not step over next line of code. See method comments for details"
			Processor terminateRealActive] in FullBlockClosure(BlockClosure)>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
Warning: Package *Roassal3-Pharo9 depends on the following classes:
  RSLayoutStudio
You must resolve these dependencies before you will be able to load these definitions: 
  RSLayoutStudio>>#defaultSpec

23 October 2023 11:25:38.392139 pm

VM: Mac OS - arm64 - 1000 - CoInterpreter VMMaker-tonel.1 uuid: 902dd483-c0c4-0d00-86f2-0f880df24b96 Oct 23 2023
StackToRegisterMappingCogit VMMaker-tonel.1 uuid: 902dd483-c0c4-0d00-86f2-0f880df24b96 Oct 23 2023
v10.0.8 - Commit: b323c5fb - Date: 2023-10-20 16:02:07 -0400

Image: Pharo11.0.0 [Build information: Pharo-11.0.0+build.710.sha.ea28d8552cac85a7ce1e9c34ab1e7bd45f7b9910 (64 Bit)]

MCPackageLoader(Object)>>notify:
	Receiver: a MCPackageLoader
	Arguments and temporary variables: 
		aString: 	'Package *Roassal3-Pharo9 depends on the following classes:
  RSLa[..]
	Receiver's instance variables: 
		requirements: 	#(#RSLayoutStudio)
		unloadableDefinitions: 	a SortedCollection(a MCMethodDefinition(RSLayoutStud[..]
		obsoletions: 	a Dictionary()
		additions: 	an OrderedCollection(a MCMethodDefinition(SpPresenter>>#open) a [..]
		removals: 	an OrderedCollection()
		errorDefinitions: 	nil
		provisions: 	a Set(#TRemoveTest #WeakSet #RSHorizontalLeftRightController #S[..]
		methodAdditions: 	an OrderedCollection()


MCPackageLoader>>warnAboutDependencies
	Receiver: a MCPackageLoader
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		requirements: 	#(#RSLayoutStudio)
		unloadableDefinitions: 	a SortedCollection(a MCMethodDefinition(RSLayoutStud[..]
		obsoletions: 	a Dictionary()
		additions: 	an OrderedCollection(a MCMethodDefinition(SpPresenter>>#open) a [..]
		removals: 	an OrderedCollection()
		errorDefinitions: 	nil
		provisions: 	a Set(#TRemoveTest #WeakSet #RSHorizontalLeftRightController #S[..]
		methodAdditions: 	an OrderedCollection()


MCPackageLoader>>validate
	Receiver: a MCPackageLoader
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		requirements: 	#(#RSLayoutStudio)
		unloadableDefinitions: 	a SortedCollection(a MCMethodDefinition(RSLayoutStud[..]
		obsoletions: 	a Dictionary()
		additions: 	an OrderedCollection(a MCMethodDefinition(SpPresenter>>#open) a [..]
		removals: 	an OrderedCollection()
		errorDefinitions: 	nil
		provisions: 	a Set(#TRemoveTest #WeakSet #RSHorizontalLeftRightController #S[..]
		methodAdditions: 	an OrderedCollection()


MCPackageLoader>>loadWithNameLike:
	Receiver: a MCPackageLoader
	Arguments and temporary variables: 
		baseName: 	'Roassal3-Pharo9-CompatibleUserName.1686657480'
	Receiver's instance variables: 
		requirements: 	#(#RSLayoutStudio)
		unloadableDefinitions: 	a SortedCollection(a MCMethodDefinition(RSLayoutStud[..]
		obsoletions: 	a Dictionary()
		additions: 	an OrderedCollection(a MCMethodDefinition(SpPresenter>>#open) a [..]
		removals: 	an OrderedCollection()
		errorDefinitions: 	nil
		provisions: 	a Set(#TRemoveTest #WeakSet #RSHorizontalLeftRightController #S[..]
		methodAdditions: 	an OrderedCollection()


MCVersionLoader>>basicLoadWithNameLike:
	Receiver: a MCVersionLoader
	Arguments and temporary variables: 
		aString: 	'Roassal3-Pharo9-CompatibleUserName.1686657480'
		loader: 	a MCPackageLoader
	Receiver's instance variables: 
		versions: 	an OrderedCollection(a MCVersion(an IceMCVersionInfo(Roassal3-Pha[..]


[ self basicLoadWithNameLike: aString ] in MCVersionLoader>>loadWithNameLike:
	Receiver: a MCVersionLoader
	Arguments and temporary variables: 
		aString: 	'Roassal3-Pharo9-CompatibleUserName.1686657480'
	Receiver's instance variables: 
		versions: 	an OrderedCollection(a MCVersion(an IceMCVersionInfo(Roassal3-Pha[..]


[ returnValue := aBlock value ] in [ 
		[ returnValue := aBlock value ] ensure: [ 
			self announceLoadStop: aString ] ] in MCVersionLoader>>announceLoad:do:
	Receiver: a MCVersionLoader
	Arguments and temporary variables: 
		aString: 	'Roassal3-Pharo9-CompatibleUserName.1686657480'
		aBlock: 	[ self basicLoadWithNameLike: aString ]
		returnValue: 	nil
	Receiver's instance variables: 
		versions: 	an OrderedCollection(a MCVersion(an IceMCVersionInfo(Roassal3-Pha[..]


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ returnValue := aBlock value ]
	Arguments and temporary variables: 
		aBlock: 	[ 
			self announceLoadStop: aString ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	[ 
		[ returnValue := aBlock value ] ensure: [ 
			self annou[..]
		compiledBlock: 	a CompiledBlock: [ returnValue := aBlock value ]
		numArgs: 	0
		receiver: 	a MCVersionLoader


[ 
		[ returnValue := aBlock value ] ensure: [ 
			self announceLoadStop: aString ] ] in MCVersionLoader>>announceLoad:do:
	Receiver: a MCVersionLoader
	Arguments and temporary variables: 
		aString: 	'Roassal3-Pharo9-CompatibleUserName.1686657480'
		aBlock: 	[ self basicLoadWithNameLike: aString ]
		returnValue: 	nil
	Receiver's instance variables: 
		versions: 	an OrderedCollection(a MCVersion(an IceMCVersionInfo(Roassal3-Pha[..]


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ self announceLoadStart: aString ]
	Arguments and temporary variables: 
		aBlock: 	[ 
		[ returnValue := aBlock value ] ensure: [ 
			self announceLoa[..]
		complete: 	true
		returnValue: 	a MCVersionLoader
	Receiver's instance variables: 
		outerContext: 	MCVersionLoader>>announceLoad:do:
		compiledBlock: 	a CompiledBlock: [ self announceLoadStart: aString ]
		numArgs: 	0
		receiver: 	a MCVersionLoader


MCVersionLoader>>announceLoad:do:
	Receiver: a MCVersionLoader
	Arguments and temporary variables: 
		returnValue: 	nil
		aString: 	'Roassal3-Pharo9-CompatibleUserName.1686657480'
		aBlock: 	[ self basicLoadWithNameLike: aString ]
	Receiver's instance variables: 
		versions: 	an OrderedCollection(a MCVersion(an IceMCVersionInfo(Roassal3-Pha[..]


MCVersionLoader>>loadWithNameLike:
	Receiver: a MCVersionLoader
	Arguments and temporary variables: 
		aString: 	'Roassal3-Pharo9-CompatibleUserName.1686657480'
	Receiver's instance variables: 
		versions: 	an OrderedCollection(a MCVersion(an IceMCVersionInfo(Roassal3-Pha[..]


[ self ensurePackage: version package.
		  self loadWithNameLike: version info name ] in [   
		| version |
		version := versions first. 
		[ self ensurePackage: version package.
		  self loadWithNameLike: version info name ] asJob
				title: 'Loading ', version info name asString;
				run ] in MCVersionLoader>>load
	Receiver: a MCVersionLoader
	Arguments and temporary variables: 
		version: 	a MCVersion(an IceMCVersionInfo(Roassal3-Pharo9-CompatibleUserName[..]
	Receiver's instance variables: 
		versions: 	an OrderedCollection(a MCVersion(an IceMCVersionInfo(Roassal3-Pha[..]


FullBlockClosure(BlockClosure)>>cull:
	Receiver: [ self ensurePackage: version package.
		  self loadWithNameLike: version info name ]
	Arguments and temporary variables: 
		anArg: 	a Job
	Receiver's instance variables: 
		outerContext: 	[   
		| version |
		version := versions first. 
		[ self ens[..]
		compiledBlock: 	a CompiledBlock: [ self ensurePackage: version package.
		  [..]
		numArgs: 	0
		receiver: 	a MCVersionLoader


[ ^ block cull: self ] in [ self prepareForRunning.
	  CurrentJob value: self during: [ ^ block cull: self ] ] in Job>>run
	Receiver: a Job
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		block: 	[ self ensurePackage: version package.
		  self loadWithNameLike: ve[..]
		currentValue: 	0
		min: 	0
		max: 	100
		title: 	'Loading Roassal3-Pharo9-CompatibleUserName.1686657480'
		children: 	an OrderedCollection()
		isRunning: 	true
		parent: 	a Job
		process: 	a Process in nil
		owner: 	a MCVersionLoader


[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in CurrentJob(DynamicVariable)>>value:during:
	Receiver: a CurrentJob
	Arguments and temporary variables: 
		anObject: 	a Job
		aBlock: 	[ ^ block cull: self ]
		activeProcess: 	a Process in nil
		oldValue: 	a Job
	Receiver's instance variables: 
		index: 	2


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ]
	Arguments and temporary variables: 
		aBlock: 	[
			activeProcess
				psValueAt: index
				put: oldValue ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	CurrentJob(DynamicVariable)>>value:during:
		compiledBlock: 	a CompiledBlock: [ activeProcess
			psValueAt: index
			put:[..]
		numArgs: 	0
		receiver: 	a CurrentJob


CurrentJob(DynamicVariable)>>value:during:
	Receiver: a CurrentJob
	Arguments and temporary variables: 
		anObject: 	a Job
		aBlock: 	[ ^ block cull: self ]
		activeProcess: 	a Process in nil
		oldValue: 	a Job
	Receiver's instance variables: 
		index: 	2


CurrentJob class(DynamicVariable class)>>value:during:
	Receiver: CurrentJob
	Arguments and temporary variables: 
		anObject: 	a Job
		aBlock: 	[ ^ block cull: self ]
	Receiver's instance variables: 
		superclass: 	DynamicVariable
		methodDict: 	a MethodDictionary()
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		commentSourcePointer: 	nil
		subclasses: 	nil
		name: 	#CurrentJob
		classPool: 	nil
		sharedPools: 	nil
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Jobs-Base'
		soleInstance: 	a CurrentJob


[ self prepareForRunning.
	  CurrentJob value: self during: [ ^ block cull: self ] ] in Job>>run
	Receiver: a Job
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		block: 	[ self ensurePackage: version package.
		  self loadWithNameLike: ve[..]
		currentValue: 	0
		min: 	0
		max: 	100
		title: 	'Loading Roassal3-Pharo9-CompatibleUserName.1686657480'
		children: 	an OrderedCollection()
		isRunning: 	true
		parent: 	a Job
		process: 	a Process in nil
		owner: 	a MCVersionLoader


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ self prepareForRunning.
	  CurrentJob value: self during: [ ^ block cull: self ] ]
	Arguments and temporary variables: 
		aBlock: 	[ self cleanupAfterRunning ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	Job>>run
		compiledBlock: 	a CompiledBlock: [ self prepareForRunning.
	  CurrentJob val[..]
		numArgs: 	0
		receiver: 	a Job


Job>>run
	Receiver: a Job
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		block: 	[ self ensurePackage: version package.
		  self loadWithNameLike: ve[..]
		currentValue: 	0
		min: 	0
		max: 	100
		title: 	'Loading Roassal3-Pharo9-CompatibleUserName.1686657480'
		children: 	an OrderedCollection()
		isRunning: 	true
		parent: 	a Job
		process: 	a Process in nil
		owner: 	a MCVersionLoader


[   
		| version |
		version := versions first. 
		[ self ensurePackage: version package.
		  self loadWithNameLike: version info name ] asJob
				title: 'Loading ', version info name asString;
				run ] in MCVersionLoader>>load
	Receiver: a MCVersionLoader
	Arguments and temporary variables: 
		version: 	a MCVersion(an IceMCVersionInfo(Roassal3-Pharo9-CompatibleUserName[..]
	Receiver's instance variables: 
		versions: 	an OrderedCollection(a MCVersion(an IceMCVersionInfo(Roassal3-Pha[..]


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [   
		| version |
		version := versions first. 
		[ self ensurePackage: version packa[..]
	Arguments and temporary variables: 
		aBlock: 	[
		self cacheActive: oldActive.
		self isCacheActive ifFalse: [ se[..]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	MCVersionLoader>>load
		compiledBlock: 	a CompiledBlock: [   
		| version |
		version := versions fi[..]
		numArgs: 	0
		receiver: 	a MCVersionLoader


RPackageSet class>>withCacheDo:
	Receiver: RPackageSet
	Arguments and temporary variables: 
		aBlock: 	[   
		| version |
		version := versions first. 
		[ self ensurePac[..]
		oldActive: 	false
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary(#asRPackageSet->RPackageSet>>#asRPackageSet [..]
		format: 	65543
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		commentSourcePointer: 	nil
		subclasses: 	{MetacelloTestsPackageSet}
		name: 	#RPackageSet
		classPool: 	nil
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'RPackage-Core-Base'
		cacheActive: 	true
		cachePackages: 	an IdentityDictionary(#'Roassal3-Pharo9'->a RPackageSet )


MCVersionLoader>>load
	Receiver: a MCVersionLoader
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		versions: 	an OrderedCollection(a MCVersion(an IceMCVersionInfo(Roassal3-Pha[..]


MetacelloGoferLoad(GoferLoad)>>execute
	Receiver: a MetacelloGoferLoad
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		gofer: 	a MetacelloGofer
		model: 	a MCVersionLoader


[ "mcLoader preLoad: packageSpec."
			goferLoad := MetacelloGoferLoad on: aGofer.
			goferLoad addResolved: resolvedReference.
			goferLoad execute.
			MetacelloPlatform current clearCurrentVersionCache	"mcLoader postLoad: packageSpec"
			] in [ | loadBlock goferLoad answers resolvedReference |

			aGofer disablePackageCache.	"for good luck:)"
			resolvedReference := self resolvePackageSpec: packageSpec gofer: aGofer.
			resolvedReference ifNil: [ "Package version already loaded into image" ^ self ].
			loadBlock := [ "mcLoader preLoad: packageSpec."
			goferLoad := MetacelloGoferLoad on: aGofer.
			goferLoad addResolved: resolvedReference.
			goferLoad execute.
			MetacelloPlatform current clearCurrentVersionCache	"mcLoader postLoad: packageSpec"
			].
			MetacelloNotification signal:
					'Loading -> ' , resolvedReference name , ' --- '
						, aPackageLoadDirective repository repositoryDescription , ' --- '
						, resolvedReference repository description.
			( answers := packageSpec answers ) notEmpty
				ifTrue: [ loadBlock valueSupplyingMetacelloAnswers: answers ]
				ifFalse: [ loadBlock value ].
			resolvedReference workingCopy repositoryGroup addRepository: aPackageLoadDirective repository.
			MetacelloNotification signal:
					'Loaded -> ' , resolvedReference name , ' --- '
						, aPackageLoadDirective repository repositoryDescription , ' --- '
						, resolvedReference repository description
			] in MetacelloLoadingMCSpecLoader(MetacelloCommonMCSpecLoader)>>loadPackageDirective:gofer:
	Receiver: a MetacelloLoadingMCSpecLoader
	Arguments and temporary variables: 
		aPackageLoadDirective: 	load : Roassal3-Pharo9-CompatibleUserName.1686657480
		aGofer: 	a MetacelloGofer
		packageSpec: 	spec name: #'Roassal3-Pharo9'
		loadBlock: 	[ "mcLoader preLoad: packageSpec."
			goferLoad := MetacelloGofe[..]
		answers: 	#()
		resolvedReference: 	a MetacelloCachingGoferResolvedReference name: 'Roassal3[..]
		goferLoad: 	a MetacelloGoferLoad
	Receiver's instance variables: 
		spec: 	a MetacelloMCVersionSpecLoader
		operator: 	nil
		loaderPolicy: 	a MetacelloLoaderPolicy
		disablePackageCache: 	false


[ | loadBlock goferLoad answers resolvedReference |

			aGofer disablePackageCache.	"for good luck:)"
			resolvedReference := self resolvePackageSpec: packageSpec gofer: aGofer.
			resolvedReference ifNil: [ "Package version already loaded into image" ^ self ].
			loadBlock := [ "mcLoader preLoad: packageSpec."
			goferLoad := MetacelloGoferLoad on: aGofer.
			goferLoad addResolved: resolvedReference.
			goferLoad execute.
			MetacelloPlatform current clearCurrentVersionCache	"mcLoader postLoad: packageSpec"
			].
			MetacelloNotification signal:
					'Loading -> ' , resolvedReference name , ' --- '
						, aPackageLoadDirective repository repositoryDescription , ' --- '
						, resolvedReference repository description.
			( answers := packageSpec answers ) notEmpty
				ifTrue: [ loadBlock valueSupplyingMetacelloAnswers: answers ]
				ifFalse: [ loadBlock value ].
			resolvedReference workingCopy repositoryGroup addRepository: aPackageLoadDirective repository.
			MetacelloNotification signal:
					'Loaded -> ' , resolvedReference name , ' --- '
						, aPackageLoadDirective repository repositoryDescription , ' --- '
						, resolvedReference repository description
			] in MetacelloLoadingMCSpecLoader(MetacelloCommonMCSpecLoader)>>loadPackageDirective:gofer:
	Receiver: a MetacelloLoadingMCSpecLoader
	Arguments and temporary variables: 
		aPackageLoadDirective: 	load : Roassal3-Pharo9-CompatibleUserName.1686657480
		aGofer: 	a MetacelloGofer
		packageSpec: 	spec name: #'Roassal3-Pharo9'
		goferLoad: 	a MetacelloGoferLoad
		loadBlock: 	[ "mcLoader preLoad: packageSpec."
			goferLoad := MetacelloGofe[..]
		answers: 	#()
		resolvedReference: 	a MetacelloCachingGoferResolvedReference name: 'Roassal3[..]
	Receiver's instance variables: 
		spec: 	a MetacelloMCVersionSpecLoader
		operator: 	nil
		loaderPolicy: 	a MetacelloLoaderPolicy
		disablePackageCache: 	false


[:bar |
            bar value: 1.
            aBlock value.
            bar value: 2 ] in IceMetacelloPharoPlatform(MetacelloPharoCommonPlatform)>>do:displaying:
	Receiver: an IceMetacelloPharoPlatform
	Arguments and temporary variables: 
		aBlock: 	[ | loadBlock goferLoad answers resolvedReference |

			aGofer disa[..]
		aString: 	'Loading Roassal3-Pharo9'
		bar: 	a Job
	Receiver's instance variables: 
		bypassProgressBars: 	false
		bypassGoferLoadUpdateCategories: 	false


FullBlockClosure(BlockClosure)>>cull:
	Receiver: [:bar |
            bar value: 1.
            aBlock value.
            bar value: 2 ]
	Arguments and temporary variables: 
		anArg: 	a Job
	Receiver's instance variables: 
		outerContext: 	IceMetacelloPharoPlatform(MetacelloPharoCommonPlatform)>>do:d[..]
		compiledBlock: 	a CompiledBlock: [:bar |
            bar value: 1.
         [..]
		numArgs: 	1
		receiver: 	an IceMetacelloPharoPlatform


[ ^ block cull: self ] in [ self prepareForRunning.
	  CurrentJob value: self during: [ ^ block cull: self ] ] in Job>>run
	Receiver: a Job
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		block: 	[:bar |
            bar value: 1.
            aBlock value.
        [..]
		currentValue: 	1
		min: 	0
		max: 	2
		title: 	'Loading Roassal3-Pharo9'
		children: 	an OrderedCollection(a Job)
		isRunning: 	true
		parent: 	a Job
		process: 	a Process in nil
		owner: 	a MorphicUIManager


[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in CurrentJob(DynamicVariable)>>value:during:
	Receiver: a CurrentJob
	Arguments and temporary variables: 
		anObject: 	a Job
		aBlock: 	[ ^ block cull: self ]
		activeProcess: 	a Process in nil
		oldValue: 	a Job
	Receiver's instance variables: 
		index: 	2


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ]
	Arguments and temporary variables: 
		aBlock: 	[
			activeProcess
				psValueAt: index
				put: oldValue ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	CurrentJob(DynamicVariable)>>value:during:
		compiledBlock: 	a CompiledBlock: [ activeProcess
			psValueAt: index
			put:[..]
		numArgs: 	0
		receiver: 	a CurrentJob


CurrentJob(DynamicVariable)>>value:during:
	Receiver: a CurrentJob
	Arguments and temporary variables: 
		anObject: 	a Job
		aBlock: 	[ ^ block cull: self ]
		activeProcess: 	a Process in nil
		oldValue: 	a Job
	Receiver's instance variables: 
		index: 	2


CurrentJob class(DynamicVariable class)>>value:during:
	Receiver: CurrentJob
	Arguments and temporary variables: 
		anObject: 	a Job
		aBlock: 	[ ^ block cull: self ]
	Receiver's instance variables: 
		superclass: 	DynamicVariable
		methodDict: 	a MethodDictionary()
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		commentSourcePointer: 	nil
		subclasses: 	nil
		name: 	#CurrentJob
		classPool: 	nil
		sharedPools: 	nil
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Jobs-Base'
		soleInstance: 	a CurrentJob


[ self prepareForRunning.
	  CurrentJob value: self during: [ ^ block cull: self ] ] in Job>>run
	Receiver: a Job
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		block: 	[:bar |
            bar value: 1.
            aBlock value.
        [..]
		currentValue: 	1
		min: 	0
		max: 	2
		title: 	'Loading Roassal3-Pharo9'
		children: 	an OrderedCollection(a Job)
		isRunning: 	true
		parent: 	a Job
		process: 	a Process in nil
		owner: 	a MorphicUIManager


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ self prepareForRunning.
	  CurrentJob value: self during: [ ^ block cull: self ] ]
	Arguments and temporary variables: 
		aBlock: 	[ self cleanupAfterRunning ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	Job>>run
		compiledBlock: 	a CompiledBlock: [ self prepareForRunning.
	  CurrentJob val[..]
		numArgs: 	0
		receiver: 	a Job


Job>>run
	Receiver: a Job
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		block: 	[:bar |
            bar value: 1.
            aBlock value.
        [..]
		currentValue: 	1
		min: 	0
		max: 	2
		title: 	'Loading Roassal3-Pharo9'
		children: 	an OrderedCollection(a Job)
		isRunning: 	true
		parent: 	a Job
		process: 	a Process in nil
		owner: 	a MorphicUIManager



--- The full stack ---
MCPackageLoader(Object)>>notify:
MCPackageLoader>>warnAboutDependencies
MCPackageLoader>>validate
MCPackageLoader>>loadWithNameLike:
MCVersionLoader>>basicLoadWithNameLike:
[ self basicLoadWithNameLike: aString ] in MCVersionLoader>>loadWithNameLike:
[ returnValue := aBlock value ] in [ 
		[ returnValue := aBlock value ] ensure: [ 
			self announceLoadStop: aString ] ] in MCVersionLoader>>announceLoad:do:
FullBlockClosure(BlockClosure)>>ensure:
[ 
		[ returnValue := aBlock value ] ensure: [ 
			self announceLoadStop: aString ] ] in MCVersionLoader>>announceLoad:do:
FullBlockClosure(BlockClosure)>>ensure:
MCVersionLoader>>announceLoad:do:
MCVersionLoader>>loadWithNameLike:
[ self ensurePackage: version package.
		  self loadWithNameLike: version info name ] in [   
		| version |
		version := versions first. 
		[ self ensurePackage: version package.
		  self loadWithNameLike: version info name ] asJob
				title: 'Loading ', version info name asString;
				run ] in MCVersionLoader>>load
FullBlockClosure(BlockClosure)>>cull:
[ ^ block cull: self ] in [ self prepareForRunning.
	  CurrentJob value: self during: [ ^ block cull: self ] ] in Job>>run
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in CurrentJob(DynamicVariable)>>value:during:
FullBlockClosure(BlockClosure)>>ensure:
CurrentJob(DynamicVariable)>>value:during:
CurrentJob class(DynamicVariable class)>>value:during:
[ self prepareForRunning.
	  CurrentJob value: self during: [ ^ block cull: self ] ] in Job>>run
FullBlockClosure(BlockClosure)>>ensure:
Job>>run
[   
		| version |
		version := versions first. 
		[ self ensurePackage: version package.
		  self loadWithNameLike: version info name ] asJob
				title: 'Loading ', version info name asString;
				run ] in MCVersionLoader>>load
FullBlockClosure(BlockClosure)>>ensure:
RPackageSet class>>withCacheDo:
MCVersionLoader>>load
MetacelloGoferLoad(GoferLoad)>>execute
[ "mcLoader preLoad: packageSpec."
			goferLoad := MetacelloGoferLoad on: aGofer.
			goferLoad addResolved: resolvedReference.
			goferLoad execute.
			MetacelloPlatform current clearCurrentVersionCache	"mcLoader postLoad: packageSpec"
			] in [ | loadBlock goferLoad answers resolvedReference |

			aGofer disablePackageCache.	"for good luck:)"
			resolvedReference := self resolvePackageSpec: packageSpec gofer: aGofer.
			resolvedReference ifNil: [ "Package version already loaded into image" ^ self ].
			loadBlock := [ "mcLoader preLoad: packageSpec."
			goferLoad := MetacelloGoferLoad on: aGofer.
			goferLoad addResolved: resolvedReference.
			goferLoad execute.
			MetacelloPlatform current clearCurrentVersionCache	"mcLoader postLoad: packageSpec"
			].
			MetacelloNotification signal:
					'Loading -> ' , resolvedReference name , ' --- '
						, aPackageLoadDirective repository repositoryDescription , ' --- '
						, resolvedReference repository description.
			( answers := packageSpec answers ) notEmpty
				ifTrue: [ loadBlock valueSupplyingMetacelloAnswers: answers ]
				ifFalse: [ loadBlock value ].
			resolvedReference workingCopy repositoryGroup addRepository: aPackageLoadDirective repository.
			MetacelloNotification signal:
					'Loaded -> ' , resolvedReference name , ' --- '
						, aPackageLoadDirective repository repositoryDescription , ' --- '
						, resolvedReference repository description
			] in MetacelloLoadingMCSpecLoader(MetacelloCommonMCSpecLoader)>>loadPackageDirective:gofer:
[ | loadBlock goferLoad answers resolvedReference |

			aGofer disablePackageCache.	"for good luck:)"
			resolvedReference := self resolvePackageSpec: packageSpec gofer: aGofer.
			resolvedReference ifNil: [ "Package version already loaded into image" ^ self ].
			loadBlock := [ "mcLoader preLoad: packageSpec."
			goferLoad := MetacelloGoferLoad on: aGofer.
			goferLoad addResolved: resolvedReference.
			goferLoad execute.
			MetacelloPlatform current clearCurrentVersionCache	"mcLoader postLoad: packageSpec"
			].
			MetacelloNotification signal:
					'Loading -> ' , resolvedReference name , ' --- '
						, aPackageLoadDirective repository repositoryDescription , ' --- '
						, resolvedReference repository description.
			( answers := packageSpec answers ) notEmpty
				ifTrue: [ loadBlock valueSupplyingMetacelloAnswers: answers ]
				ifFalse: [ loadBlock value ].
			resolvedReference workingCopy repositoryGroup addRepository: aPackageLoadDirective repository.
			MetacelloNotification signal:
					'Loaded -> ' , resolvedReference name , ' --- '
						, aPackageLoadDirective repository repositoryDescription , ' --- '
						, resolvedReference repository description
			] in MetacelloLoadingMCSpecLoader(MetacelloCommonMCSpecLoader)>>loadPackageDirective:gofer:
[:bar |
            bar value: 1.
            aBlock value.
            bar value: 2 ] in IceMetacelloPharoPlatform(MetacelloPharoCommonPlatform)>>do:displaying:
FullBlockClosure(BlockClosure)>>cull:
[ ^ block cull: self ] in [ self prepareForRunning.
	  CurrentJob value: self during: [ ^ block cull: self ] ] in Job>>run
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in CurrentJob(DynamicVariable)>>value:during:
FullBlockClosure(BlockClosure)>>ensure:
CurrentJob(DynamicVariable)>>value:during:
CurrentJob class(DynamicVariable class)>>value:during:
[ self prepareForRunning.
	  CurrentJob value: self during: [ ^ block cull: self ] ] in Job>>run
FullBlockClosure(BlockClosure)>>ensure:
Job>>run
 - - - - - - - - - - - - - - -
			- - - - - - - - - - - - - - - - - -
MorphicUIManager(UIManager)>>displayProgress:from:to:during:
ByteString(String)>>displayProgressFrom:to:during:
IceMetacelloPharoPlatform(MetacelloPharoCommonPlatform)>>do:displaying:
MetacelloLoadingMCSpecLoader(MetacelloCommonMCSpecLoader)>>loadPackageDirective:gofer:
MetacelloLinearLoadDirective(MetacelloVersionLoadDirective)>>loadPackageDirective:gofer:
MetacelloPackageLoadDirective>>loadUsing:gofer:
[:directive | directive loadUsing: aLoaderDirective gofer: aGofer ] in MetacelloLinearLoadDirective(MetacelloVersionLoadDirective)>>loadLinearLoadDirective:gofer:
OrderedCollection>>do:
MetacelloLinearLoadDirective(MetacelloVersionLoadDirective)>>loadLinearLoadDirective:gofer:
MetacelloLinearLoadDirective>>loadUsing:gofer:
[:directive | directive loadUsing: aLoaderDirective gofer: aGofer ] in MetacelloLinearLoadDirective(MetacelloVersionLoadDirective)>>loadLinearLoadDirective:gofer:
OrderedCollection>>do:
MetacelloLinearLoadDirective(MetacelloVersionLoadDirective)>>loadLinearLoadDirective:gofer:
MetacelloLinearLoadDirective>>loadUsing:gofer:
MetacelloLinearLoadDirective(MetacelloVersionLoadDirective)>>loadWithPolicy:
MetacelloLoaderPolicy>>load
MetacelloFetchingMCSpecLoader>>doLoad
[  fetchLoader doLoad ] in [	| fetchLoader |
		fetchLoader := self fetchRequiredFromArray: (self defaultPackageNamesToLoad: anArray).
		MetacelloPlatform current
			do:  [  fetchLoader doLoad ]
			displaying: 'Loading ', displayString.
		MetacelloNotification signal: ('...finished ', self versionNumber printString).
		^fetchLoader ] in MetacelloMCVersion>>doLoadRequiredFromArray:
[:bar |
            bar value: 1.
            aBlock value.
            bar value: 2 ] in IceMetacelloPharoPlatform(MetacelloPharoCommonPlatform)>>do:displaying:
FullBlockClosure(BlockClosure)>>cull:
[ ^ block cull: self ] in [ self prepareForRunning.
	  CurrentJob value: self during: [ ^ block cull: self ] ] in Job>>run
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in CurrentJob(DynamicVariable)>>value:during:
FullBlockClosure(BlockClosure)>>ensure:
CurrentJob(DynamicVariable)>>value:during:
CurrentJob class(DynamicVariable class)>>value:during:
[ self prepareForRunning.
	  CurrentJob value: self during: [ ^ block cull: self ] ] in Job>>run
FullBlockClosure(BlockClosure)>>ensure:
Job>>run
MorphicUIManager(UIManager)>>displayProgress:from:to:during:
ByteString(String)>>displayProgressFrom:to:during:
IceMetacelloPharoPlatform(MetacelloPharoCommonPlatform)>>do:displaying:
[	| fetchLoader |
		fetchLoader := self fetchRequiredFromArray: (self defaultPackageNamesToLoad: anArray).
		MetacelloPlatform current
			do:  [  fetchLoader doLoad ]
			displaying: 'Loading ', displayString.
		MetacelloNotification signal: ('...finished ', self versionNumber printString).
		^fetchLoader ] in MetacelloMCVersion>>doLoadRequiredFromArray:
FullBlockClosure(BlockClosure)>>ensure:
MetacelloMCVersion>>doLoadRequiredFromArray:
MetacelloMCVersion>>load
[ 
          | version loadedSpec |
          self setDefaultsAndValidateProjectSpec.
          [ loadedSpec := (self lookupProjectSpecFor: self projectSpec) copy ]
            on: MetacelloAllowProjectDowngrade , MetacelloAllowProjectUpgrade
            do: [ :ex | ex handleOnDownGrade: onDownGradeBlock onUpgrade: onUpgradeBlock ].
          version := loadedSpec versionForScriptEngine: self.
          self
            root:
              (required isEmpty
                ifTrue: [ version load ]
                ifFalse: [ version load: required ]) loadDirective.
          loadedSpec loads: required.
          MetacelloProjectRegistration
            registrationForProjectSpec: loadedSpec
            ifAbsent: [ :new | 
              new
                loadedInImage: true;
                registerProject ]
            ifPresent: [ :existing :new | 
              existing
                copyOnWrite: [ :existingCopy | 
                  existingCopy
                    loadedInImage: true;
                    merge: new ] ] ] in [ 
      self
        handleNotificationsForAction: [ 
          | version loadedSpec |
          self setDefaultsAndValidateProjectSpec.
          [ loadedSpec := (self lookupProjectSpecFor: self projectSpec) copy ]
            on: MetacelloAllowProjectDowngrade , MetacelloAllowProjectUpgrade
            do: [ :ex | ex handleOnDownGrade: onDownGradeBlock onUpgrade: onUpgradeBlock ].
          version := loadedSpec versionForScriptEngine: self.
          self
            root:
              (required isEmpty
                ifTrue: [ version load ]
                ifFalse: [ version load: required ]) loadDirective.
          loadedSpec loads: required.
          MetacelloProjectRegistration
            registrationForProjectSpec: loadedSpec
            ifAbsent: [ :new | 
              new
                loadedInImage: true;
                registerProject ]
            ifPresent: [ :existing :new | 
              existing
                copyOnWrite: [ :existingCopy | 
                  existingCopy
                    loadedInImage: true;
                    merge: new ] ] ] ] in MetacelloScriptEngine>>load:onProjectDownGrade:onProjectUpgrade:
FullBlockClosure(BlockClosure)>>on:do:
[ 
  actionBlock
    on:
      MetacelloLookupProjectSpec , MetacelloLookupProjectSpecForLoad
        , MetacelloProjectSpecLoadedNotification
        , MetacelloScriptEnsureProjectLoadedForDevelopment
        , MetacelloLookupBaselineSpecForEnsureLoad
    do: [ :ex | 
      "lookup and registration handlers need to be innermost set of handlers ...they may throw option notifications"
      ex handleResolutionFor: self ] ] in [ 
  [ 
  actionBlock
    on:
      MetacelloLookupProjectSpec , MetacelloLookupProjectSpecForLoad
        , MetacelloProjectSpecLoadedNotification
        , MetacelloScriptEnsureProjectLoadedForDevelopment
        , MetacelloLookupBaselineSpecForEnsureLoad
    do: [ :ex | 
      "lookup and registration handlers need to be innermost set of handlers ...they may throw option notifications"
      ex handleResolutionFor: self ] ]
    on:
      MetacelloAllowProjectDowngrade , MetacelloAllowProjectUpgrade
        , MetacelloAllowConflictingProjectUpgrade
    do: [ :ex | 
      "option handlers need to be outermost set of handlers ... last line of defense before users are involved"
      ex handleResolutionFor: self ] ] in [ 
  [ 
  [ 
  actionBlock
    on:
      MetacelloLookupProjectSpec , MetacelloLookupProjectSpecForLoad
        , MetacelloProjectSpecLoadedNotification
        , MetacelloScriptEnsureProjectLoadedForDevelopment
        , MetacelloLookupBaselineSpecForEnsureLoad
    do: [ :ex | 
      "lookup and registration handlers need to be innermost set of handlers ...they may throw option notifications"
      ex handleResolutionFor: self ] ]
    on:
      MetacelloAllowProjectDowngrade , MetacelloAllowProjectUpgrade
        , MetacelloAllowConflictingProjectUpgrade
    do: [ :ex | 
      "option handlers need to be outermost set of handlers ... last line of defense before users are involved"
      ex handleResolutionFor: self ] ]
    on: MetacelloAllowLockedProjectChange
    do: [ :ex | 
      "MetacelloAllowLockedProjectChange need to be outermost handler ... since it is signaled from second line of handlers"
      ex handleResolutionFor: self ] ] in MetacelloScriptEngine>>handleNotificationsForAction:
FullBlockClosure(BlockClosure)>>on:do:
[ 
  [ 
  actionBlock
    on:
      MetacelloLookupProjectSpec , MetacelloLookupProjectSpecForLoad
        , MetacelloProjectSpecLoadedNotification
        , MetacelloScriptEnsureProjectLoadedForDevelopment
        , MetacelloLookupBaselineSpecForEnsureLoad
    do: [ :ex | 
      "lookup and registration handlers need to be innermost set of handlers ...they may throw option notifications"
      ex handleResolutionFor: self ] ]
    on:
      MetacelloAllowProjectDowngrade , MetacelloAllowProjectUpgrade
        , MetacelloAllowConflictingProjectUpgrade
    do: [ :ex | 
      "option handlers need to be outermost set of handlers ... last line of defense before users are involved"
      ex handleResolutionFor: self ] ] in [ 
  [ 
  [ 
  actionBlock
    on:
      MetacelloLookupProjectSpec , MetacelloLookupProjectSpecForLoad
        , MetacelloProjectSpecLoadedNotification
        , MetacelloScriptEnsureProjectLoadedForDevelopment
        , MetacelloLookupBaselineSpecForEnsureLoad
    do: [ :ex | 
      "lookup and registration handlers need to be innermost set of handlers ...they may throw option notifications"
      ex handleResolutionFor: self ] ]
    on:
      MetacelloAllowProjectDowngrade , MetacelloAllowProjectUpgrade
        , MetacelloAllowConflictingProjectUpgrade
    do: [ :ex | 
      "option handlers need to be outermost set of handlers ... last line of defense before users are involved"
      ex handleResolutionFor: self ] ]
    on: MetacelloAllowLockedProjectChange
    do: [ :ex | 
      "MetacelloAllowLockedProjectChange need to be outermost handler ... since it is signaled from second line of handlers"
      ex handleResolutionFor: self ] ] in MetacelloScriptEngine>>handleNotificationsForAction:
FullBlockClosure(BlockClosure)>>on:do:
[ 
  [ 
  [ 
  actionBlock
    on:
      MetacelloLookupProjectSpec , MetacelloLookupProjectSpecForLoad
        , MetacelloProjectSpecLoadedNotification
        , MetacelloScriptEnsureProjectLoadedForDevelopment
        , MetacelloLookupBaselineSpecForEnsureLoad
    do: [ :ex | 
      "lookup and registration handlers need to be innermost set of handlers ...they may throw option notifications"
      ex handleResolutionFor: self ] ]
    on:
      MetacelloAllowProjectDowngrade , MetacelloAllowProjectUpgrade
        , MetacelloAllowConflictingProjectUpgrade
    do: [ :ex | 
      "option handlers need to be outermost set of handlers ... last line of defense before users are involved"
      ex handleResolutionFor: self ] ]
    on: MetacelloAllowLockedProjectChange
    do: [ :ex | 
      "MetacelloAllowLockedProjectChange need to be outermost handler ... since it is signaled from second line of handlers"
      ex handleResolutionFor: self ] ] in MetacelloScriptEngine>>handleNotificationsForAction:
FullBlockClosure(BlockClosure)>>on:do:
MetacelloScriptEngine>>handleNotificationsForAction:
[ 
      self
        handleNotificationsForAction: [ 
          | version loadedSpec |
          self setDefaultsAndValidateProjectSpec.
          [ loadedSpec := (self lookupProjectSpecFor: self projectSpec) copy ]
            on: MetacelloAllowProjectDowngrade , MetacelloAllowProjectUpgrade
            do: [ :ex | ex handleOnDownGrade: onDownGradeBlock onUpgrade: onUpgradeBlock ].
          version := loadedSpec versionForScriptEngine: self.
          self
            root:
              (required isEmpty
                ifTrue: [ version load ]
                ifFalse: [ version load: required ]) loadDirective.
          loadedSpec loads: required.
          MetacelloProjectRegistration
            registrationForProjectSpec: loadedSpec
            ifAbsent: [ :new | 
              new
                loadedInImage: true;
                registerProject ]
            ifPresent: [ :existing :new | 
              existing
                copyOnWrite: [ :existingCopy | 
                  existingCopy
                    loadedInImage: true;
                    merge: new ] ] ] ] in MetacelloScriptEngine>>load:onProjectDownGrade:onProjectUpgrade:
FullBlockClosure(BlockClosure)>>ensure:
MetacelloProjectRegistration class>>copyRegistryRestoreOnErrorWhile:
MetacelloScriptEngine>>load:onProjectDownGrade:onProjectUpgrade:
MetacelloScriptEngine>>load:
[ :projectSpec | 
      | engine |
      engine := MetacelloScriptEngine new
        options: self options copy;
        projectSpec: projectSpec;
        yourself.
      engine perform: actionArg key withArguments: actionArg value.
      engine root ifNotNil: [ :root | self roots add: root ] ] in MetacelloScriptApiExecutor(MetacelloScriptExecutor)>>execute:
[ :projectSpec | 
      projectSpec
        ifNotNil: [ projectSpecBlock value: (self applyArgsToProjectSpec: projectSpec copy) ] ] in MetacelloScriptApiExecutor>>executeString:do:
Array(SequenceableCollection)>>do:
MetacelloScriptApiExecutor>>executeString:do:
ByteString(String)>>execute:against:
MetacelloScriptApiExecutor(MetacelloScriptExecutor)>>execute:
[ 
		super execute: statements ] in MetacelloScriptApiExecutor>>execute:
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in IceMetacelloLoadSessionContext(DynamicVariable)>>value:during:
FullBlockClosure(BlockClosure)>>ensure:
IceMetacelloLoadSessionContext(DynamicVariable)>>value:during:
IceMetacelloLoadSessionContext class(DynamicVariable class)>>value:during:
IceMetacelloPharoPlatform>>withMetacelloLoadSessionDo:
MetacelloScriptApiExecutor>>execute:
Metacello>>execute:args:
Metacello>>load
UndefinedObject>>DoIt
OCReceiverDoItSemanticScope(OCDoItSemanticScope)>>evaluateDoIt:
OpalCompiler>>evaluate
[
		self announcer announce: (SpCodeWillBeEvaluatedAnnouncement newContent: aString).
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionModel doItReceiver.
		result := receiver class compiler
			source: aString;
			context: self interactionModel doItContext;
			receiver: self interactionModel doItReceiver;
			requestor: self interactionModel;
			environment: self environment;
			failBlock:  [ 
				self announcer announce: (SpCodeEvaluationFailedAnnouncement newContent: aString).
				^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		self announcer announce: (SpCodeEvaluationSucceedAnnouncement newContent: aString).
		result ] in SpCodePresenter>>evaluate:onCompileError:onError:
FullBlockClosure(BlockClosure)>>on:do:
SpCodePresenter>>evaluate:onCompileError:onError:
StPlaygroundPagePresenter>>doEvaluateAndGo
StPlaygroundPagePresenter>>doEvaluateAllAndGo
StPlaygroundDoItCommand>>execute
SpCommand(CmCommandDecorator)>>execute
[ specCommand execute ] in [ :specCommand | 
			aButtonClass new
				label: specCommand name;
				help: specCommand description;
				in: [ :button | 
					specCommand hasIcon
						ifTrue: [ button icon: specCommand icon ] ];
				action: [ specCommand execute ];
				yourself ] in SpCommand>>configureAsButtonOfClass:
FullBlockClosure(BlockClosure)>>cull:
SpMorphicToolbarButtonAdapter>>execute
SpToolbarButtonMorph(PluggableButtonMorph)>>performAction:
[:m |
		(m containsPoint: evt cursorPoint) ifTrue: [m enabled ifTrue: [ m performAction: evt ]]] in SpToolbarButtonMorph(PluggableButtonMorph)>>mouseUp:
Array(SequenceableCollection)>>do:
SpToolbarButtonMorph(PluggableButtonMorph)>>mouseUp:
SpToolbarButtonMorph(Morph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
SpToolbarButtonMorph(Morph)>>handleEvent:
SpToolbarButtonMorph(Morph)>>handleFocusEvent:
[
		result := focusHolder handleFocusEvent: transformedEvent.
	] in HandMorph>>sendFocusEvent:to:clear:
FullBlockClosure(BlockClosure)>>on:do:
WorldMorph>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil ]) ifTrue: [
			morphicWorld activeHand handleEvent: anEvent
		]
	] in OSWindowMorphicEventHandler>>dispatchMorphicEvent:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycleNow
WorldMorph>>doOneCycle
[
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMutex critical: [
			                     self extraWorldList ].
		extraWorldsToDraw do: [ :world | world doOneCycle ].

		(self currentWorld isNotNil and: [
			 (extraWorldsToDraw includes: self currentWorld) not ]) ifTrue: [
			self currentWorld doOneCycle ] ] in WorldMorph class>>doOneCycle
FullBlockClosure(BlockClosure)>>ensure:
WorldState class>>doDrawCycleWith:
WorldMorph class>>doOneCycle
MorphicRenderLoop>>doOneCycle
MorphicRenderLoop>>doOneCycleWhile:
[ MorphicRenderLoop new doOneCycleWhile: [ true ] ] in MorphicUIManager>>spawnNewProcess
[self value.
			"IMPORTANT: Do not step over next line of code. See method comments for details"
			Processor terminateRealActive] in FullBlockClosure(BlockClosure)>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
#setToEnd was sent to nil
23 October 2023 11:47:51.479918 pm

VM: Mac OS - arm64 - 1000 - CoInterpreter VMMaker-tonel.1 uuid: 902dd483-c0c4-0d00-86f2-0f880df24b96 Oct 23 2023
StackToRegisterMappingCogit VMMaker-tonel.1 uuid: 902dd483-c0c4-0d00-86f2-0f880df24b96 Oct 23 2023
v10.0.8 - Commit: b323c5fb - Date: 2023-10-20 16:02:07 -0400

Image: Pharo11.0.0 [Build information: Pharo-11.0.0+build.710.sha.ea28d8552cac85a7ce1e9c34ab1e7bd45f7b9910 (64 Bit)]

UndefinedObject(Object)>>doesNotUnderstand: #setToEnd
	Receiver: nil
	Arguments and temporary variables: 
		aMessage: 	setToEnd
		exception: 	#setToEnd was sent to nil
		resumeValue: 	nil
	Receiver's instance variables: 
nil

UndefinedObject>>doesNotUnderstand: #setToEnd
	Receiver: nil
	Arguments and temporary variables: 
		node: 	nil
		aMessage: 	setToEnd
		exception: 	nil
		resumeValue: 	nil
	Receiver's instance variables: 
nil

SourceFile>>setToEnd
	Receiver: SourceFile(/Users/ryanperez/Documents/Pharo/images/Visualizer/Visualizer.changes)
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		path: 	'/Users/ryanperez/Documents/Pharo/images/Visualizer/Visualizer.changes'
		stream: 	nil
		potentialLocations: 	an Array({imageDirectory} File @ .)


SourceFileArray>>forceChangesToDisk
	Receiver: a SourceFileArray
	Arguments and temporary variables: 
		changesFile: 	SourceFile(/Users/ryanperez/Documents/Pharo/images/Visualizer/[..]
	Receiver's instance variables: 
		files: 	an Array(SourceFile(/Users/ryanperez/Documents/Pharo/images/Visualiz[..]
		readOnlyQueue: 	SharedQueue with 1 items
		flushChanges: 	true


ChangesLog>>logChange:
	Receiver: a ChangesLog
	Arguments and temporary variables: 
		aStringOrText: 	'----QUIT/NOSAVE----2023-10-23T23:47:51.177477-05:00 Visuali[..]
		aString: 	'----QUIT/NOSAVE----2023-10-23T23:47:51.177477-05:00 Visualizer.im[..]
	Receiver's instance variables: 
		startupStamp: 	nil


ChangesLog>>logSnapshot:andQuit:
	Receiver: a ChangesLog
	Arguments and temporary variables: 
		save: 	false
		quit: 	true
		message: 	'----QUIT/NOSAVE----2023-10-23T23:47:51.177477-05:00 Visualizer.im[..]
	Receiver's instance variables: 
		startupStamp: 	nil


SessionManager>>launchSnapshot:andQuit:
	Receiver: a SessionManager
	Arguments and temporary variables: 
		save: 	false
		quit: 	true
		isImageStarting: 	nil
		snapshotResult: 	nil
	Receiver's instance variables: 
		currentSession: 	a WorkingSession
		categories: 	an OrderedCollection(a SessionCategory(System) a SessionCategor[..]
		guiCategory: 	a SessionCategory(Graphical User Interface)
		toolsCategory: 	a SessionCategory(Tools)
		networkCategory: 	a SessionCategory(Network)
		systemCategory: 	a SessionCategory(System)
		userCategory: 	a SessionCategory(User)


[ isImageStarting := self launchSnapshot: save andQuit: quit.
	  wait signal. ] in SessionManager>>snapshot:andQuit:
	Receiver: a SessionManager
	Arguments and temporary variables: 
		save: 	false
		quit: 	true
		wait: 	a Semaphore()
		isImageStarting: 	nil
	Receiver's instance variables: 
		currentSession: 	a WorkingSession
		categories: 	an OrderedCollection(a SessionCategory(System) a SessionCategor[..]
		guiCategory: 	a SessionCategory(Graphical User Interface)
		toolsCategory: 	a SessionCategory(Tools)
		networkCategory: 	a SessionCategory(Network)
		systemCategory: 	a SessionCategory(System)
		userCategory: 	a SessionCategory(User)


[self value.
			"IMPORTANT: Do not step over next line of code. See method comments for details"
			Processor terminateRealActive] in FullBlockClosure(BlockClosure)>>newProcess
	Receiver: [ isImageStarting := self launchSnapshot: save andQuit: quit.
	  wait signal. ]
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		outerContext: 	SessionManager>>snapshot:andQuit:
		compiledBlock: 	a CompiledBlock: [ isImageStarting := self launchSnapshot: s[..]
		numArgs: 	0
		receiver: 	a SessionManager



--- The full stack ---
UndefinedObject(Object)>>doesNotUnderstand: #setToEnd
UndefinedObject>>doesNotUnderstand: #setToEnd
SourceFile>>setToEnd
SourceFileArray>>forceChangesToDisk
ChangesLog>>logChange:
ChangesLog>>logSnapshot:andQuit:
SessionManager>>launchSnapshot:andQuit:
[ isImageStarting := self launchSnapshot: save andQuit: quit.
	  wait signal. ] in SessionManager>>snapshot:andQuit:
[self value.
			"IMPORTANT: Do not step over next line of code. See method comments for details"
			Processor terminateRealActive] in FullBlockClosure(BlockClosure)>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
#setToEnd was sent to nil
23 October 2023 11:47:51.487211 pm

VM: Mac OS - arm64 - 1000 - CoInterpreter VMMaker-tonel.1 uuid: 902dd483-c0c4-0d00-86f2-0f880df24b96 Oct 23 2023
StackToRegisterMappingCogit VMMaker-tonel.1 uuid: 902dd483-c0c4-0d00-86f2-0f880df24b96 Oct 23 2023
v10.0.8 - Commit: b323c5fb - Date: 2023-10-20 16:02:07 -0400

Image: Pharo11.0.0 [Build information: Pharo-11.0.0+build.710.sha.ea28d8552cac85a7ce1e9c34ab1e7bd45f7b9910 (64 Bit)]

UndefinedObject(Object)>>doesNotUnderstand: #setToEnd
	Receiver: nil
	Arguments and temporary variables: 
		aMessage: 	setToEnd
		exception: 	#setToEnd was sent to nil
		resumeValue: 	nil
	Receiver's instance variables: 
nil

UndefinedObject>>doesNotUnderstand: #setToEnd
	Receiver: nil
	Arguments and temporary variables: 
		node: 	nil
		aMessage: 	setToEnd
		exception: 	nil
		resumeValue: 	nil
	Receiver's instance variables: 
nil

SourceFile>>setToEnd
	Receiver: SourceFile(/Users/ryanperez/Documents/Pharo/images/Visualizer/Visualizer.changes)
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		path: 	'/Users/ryanperez/Documents/Pharo/images/Visualizer/Visualizer.changes'
		stream: 	nil
		potentialLocations: 	an Array({imageDirectory} File @ .)


SourceFileArray>>forceChangesToDisk
	Receiver: a SourceFileArray
	Arguments and temporary variables: 
		changesFile: 	SourceFile(/Users/ryanperez/Documents/Pharo/images/Visualizer/[..]
	Receiver's instance variables: 
		files: 	an Array(SourceFile(/Users/ryanperez/Documents/Pharo/images/Visualiz[..]
		readOnlyQueue: 	SharedQueue with 1 items
		flushChanges: 	true


ChangesLog>>logChange:
	Receiver: a ChangesLog
	Arguments and temporary variables: 
		aStringOrText: 	'----QUIT/NOSAVE----2023-10-23T23:47:51.177477-05:00 Visuali[..]
		aString: 	'----QUIT/NOSAVE----2023-10-23T23:47:51.177477-05:00 Visualizer.im[..]
	Receiver's instance variables: 
		startupStamp: 	nil


ChangesLog>>logSnapshot:andQuit:
	Receiver: a ChangesLog
	Arguments and temporary variables: 
		save: 	false
		quit: 	true
		message: 	'----QUIT/NOSAVE----2023-10-23T23:47:51.177477-05:00 Visualizer.im[..]
	Receiver's instance variables: 
		startupStamp: 	nil


SessionManager>>launchSnapshot:andQuit:
	Receiver: a SessionManager
	Arguments and temporary variables: 
		save: 	false
		quit: 	true
		isImageStarting: 	nil
		snapshotResult: 	nil
	Receiver's instance variables: 
		currentSession: 	a WorkingSession
		categories: 	an OrderedCollection(a SessionCategory(System) a SessionCategor[..]
		guiCategory: 	a SessionCategory(Graphical User Interface)
		toolsCategory: 	a SessionCategory(Tools)
		networkCategory: 	a SessionCategory(Network)
		systemCategory: 	a SessionCategory(System)
		userCategory: 	a SessionCategory(User)


[ isImageStarting := self launchSnapshot: save andQuit: quit.
	  wait signal. ] in SessionManager>>snapshot:andQuit:
	Receiver: a SessionManager
	Arguments and temporary variables: 
		save: 	false
		quit: 	true
		wait: 	a Semaphore()
		isImageStarting: 	nil
	Receiver's instance variables: 
		currentSession: 	a WorkingSession
		categories: 	an OrderedCollection(a SessionCategory(System) a SessionCategor[..]
		guiCategory: 	a SessionCategory(Graphical User Interface)
		toolsCategory: 	a SessionCategory(Tools)
		networkCategory: 	a SessionCategory(Network)
		systemCategory: 	a SessionCategory(System)
		userCategory: 	a SessionCategory(User)


[self value.
			"IMPORTANT: Do not step over next line of code. See method comments for details"
			Processor terminateRealActive] in FullBlockClosure(BlockClosure)>>newProcess
	Receiver: [ isImageStarting := self launchSnapshot: save andQuit: quit.
	  wait signal. ]
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		outerContext: 	SessionManager>>snapshot:andQuit:
		compiledBlock: 	a CompiledBlock: [ isImageStarting := self launchSnapshot: s[..]
		numArgs: 	0
		receiver: 	a SessionManager



--- The full stack ---
UndefinedObject(Object)>>doesNotUnderstand: #setToEnd
UndefinedObject>>doesNotUnderstand: #setToEnd
SourceFile>>setToEnd
SourceFileArray>>forceChangesToDisk
ChangesLog>>logChange:
ChangesLog>>logSnapshot:andQuit:
SessionManager>>launchSnapshot:andQuit:
[ isImageStarting := self launchSnapshot: save andQuit: quit.
	  wait signal. ] in SessionManager>>snapshot:andQuit:
[self value.
			"IMPORTANT: Do not step over next line of code. See method comments for details"
			Processor terminateRealActive] in FullBlockClosure(BlockClosure)>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
Instance of RSBox did not understand #+
23 October 2023 11:55:23.35736 pm

VM: Mac OS - arm64 - 1000 - CoInterpreter VMMaker-tonel.1 uuid: 902dd483-c0c4-0d00-86f2-0f880df24b96 Oct 23 2023
StackToRegisterMappingCogit VMMaker-tonel.1 uuid: 902dd483-c0c4-0d00-86f2-0f880df24b96 Oct 23 2023
v10.0.8 - Commit: b323c5fb - Date: 2023-10-20 16:02:07 -0400

Image: Pharo11.0.0 [Build information: Pharo-11.0.0+build.710.sha.ea28d8552cac85a7ce1e9c34ab1e7bd45f7b9910 (64 Bit)]

RSBox(Object)>>doesNotUnderstand: #+
	Receiver: a RSBox
	Arguments and temporary variables: 
		aMessage: 	+ 'Alice'
		exception: 	Instance of RSBox did not understand #+
		resumeValue: 	nil
	Receiver's instance variables: 
		announcer: 	nil
		properties: 	nil
		paint: 	Color blue
		path: 	(-25.0@ -25.0) corner: (25.0@25.0)
		border: 	nil
		parent: 	nil
		isFixed: 	false
		encompassingRectangle: 	nil
		model: 	nil
		baseRectangle: 	(-25.0@ -25.0) corner: (25.0@25.0)
		matrix: 	x: 0.0 y: 0.0 sx: 1.0 sy: 1.0 shx: 0.0 shy: 0.0
		connectedLines: 	nil
		shouldUpdateLines: 	true
		cornerRadius: 	nil


VisualizerMain>>createSampleGraph
	Receiver: a VisualizerMain
	Arguments and temporary variables: 
		view: 	a RSCanvas
		alice: 	nil
		bob: 	nil
	Receiver's instance variables: 
a VisualizerMain

UndefinedObject>>DoIt
	Receiver: nil
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
nil

OCReceiverDoItSemanticScope(OCDoItSemanticScope)>>evaluateDoIt:
	Receiver: an OCReceiverDoItSemanticScope
	Arguments and temporary variables: 
		doItMethod: 	UndefinedObject>>#DoIt
	Receiver's instance variables: 
		outerScope: 	nil
		targetReceiver: 	nil


OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
		doItMethod: 	UndefinedObject>>#DoIt
	Receiver's instance variables: 
		ast: 	DoIt

	^ VisualizerMain new createSampleGraph open
		source: 	a ReadStream
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil


[
		self announcer announce: (SpCodeWillBeEvaluatedAnnouncement newContent: aString).
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionModel doItReceiver.
		result := receiver class compiler
			source: aString;
			context: self interactionModel doItContext;
			receiver: self interactionModel doItReceiver;
			requestor: self interactionModel;
			environment: self environment;
			failBlock:  [ 
				self announcer announce: (SpCodeEvaluationFailedAnnouncement newContent: aString).
				^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		self announcer announce: (SpCodeEvaluationSucceedAnnouncement newContent: aString).
		result ] in SpCodePresenter>>evaluate:onCompileError:onError:
	Receiver: a SpCodePresenter
	Arguments and temporary variables: 
		aString: 	'(VisualizerMain new createSampleGraph) open.
'
		compileErrorBlock: 	[ ^ self ]
		errorBlock: 	[ :e | e pass ]
		receiver: 	nil
		result: 	nil
		oldBindings: 	a Dictionary()
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicCodeAdapter)
		announcer: 	an Announcer
		owner: 	a StPlaygroundPagePresenter
		adapter: 	a SpMorphicCodeAdapter
		needRebuild: 	true
		eventHandler: 	a SpEventHandler
		application: 	nil
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ a KMCategory ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Code' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpAbstractWidgetLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		borderWidth: 	an ObservableValueHolder[ nil ]
		borderColor: 	an ObservableValueHolder[ nil ]
		dragEnabled: 	an ObservableValueHolder[ false ]
		dropEnabled: 	an ObservableValueHolder[ false ]
		color: 	an ObservableValueHolder[ nil ]
		help: 	an ObservableValueHolder[ nil ]
		enabled: 	an ObservableValueHolder[ true ]
		wantsDrop: 	an ObservableValueHolder[ [ :transfer | self dropEnabled ] ]
		acceptDrop: 	an ObservableValueHolder[ [ :transfer | ] ]
		deferredActions: 	nil
		hasUnacceptedEdits: 	an ObservableValueHolder[ false ]
		selection: 	an ObservableValueHolder[ (1 to: 45) ]
		wantsVisualFeedback: 	an ObservableValueHolder[ true ]
		askBeforeDiscardingEdits: 	an ObservableValueHolder[ true ]
		text: 	an ObservableValueHolder[ '(VisualizerMain new createSampleGraph) ope[..]
		actionToPerform: 	an ObservableValueHolder[ [ :txt |  ] ]
		readSelection: 	an ObservableValueHolder[ [ selection ] ]
		placeholder: 	an ObservableValueHolder[ '' ]
		contextMenu: 	an ObservableValueHolder[ [ (self menuActionsFor: text) asMenu[..]
		scrollValue: 	an ObservableValueHolder[ (0@0) ]
		editionContextMenu: 	an ObservableValueHolder[ true ]
		editable: 	an ObservableValueHolder[ true ]
		wrapWord: 	an ObservableValueHolder[ true ]
		undoRedoHistory: 	true
		wrapScrollBars: 	true
		propagateNaturalHeight: 	false
		propagateNaturalWidth: 	false
		scrollBarStyles: 	#()
		syntaxHighlight: 	an ObservableValueHolder[ true ]
		smartCharacters: 	an ObservableValueHolder[ true ]
		lineNumbers: 	an ObservableValueHolder[ true ]
		interactionModel: 	an ObservableValueHolder[ a StPlaygroundInteractionModel ]
		overrideContextMenu: 	true
		submitBlock: 	nil
		resetBlock: 	nil
		environment: 	nil
		systemNavigation: 	nil
		syntaxHighlightTheme: 	an ObservableValueHolder[ nil ]


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
		self announcer announce: (SpCodeWillBeEvaluatedAnnouncement newContent: aString).
[..]
	Arguments and temporary variables: 
		exception: 	Error
		handlerAction: 	[ :e |
		self announcer announce: (SpCodeEvaluationFailedAnn[..]
	Receiver's instance variables: 
		outerContext: 	SpCodePresenter>>evaluate:onCompileError:onError:
		compiledBlock: 	a CompiledBlock: [
		self announcer announce: (SpCodeWillBeE[..]
		numArgs: 	0
		receiver: 	a SpCodePresenter


SpCodePresenter>>evaluate:onCompileError:onError:
	Receiver: a SpCodePresenter
	Arguments and temporary variables: 
		receiver: 	nil
		result: 	nil
		oldBindings: 	a Dictionary()
		aString: 	'(VisualizerMain new createSampleGraph) open.
'
		compileErrorBlock: 	[ ^ self ]
		errorBlock: 	[ :e | e pass ]
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicCodeAdapter)
		announcer: 	an Announcer
		owner: 	a StPlaygroundPagePresenter
		adapter: 	a SpMorphicCodeAdapter
		needRebuild: 	true
		eventHandler: 	a SpEventHandler
		application: 	nil
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ a KMCategory ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Code' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpAbstractWidgetLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		borderWidth: 	an ObservableValueHolder[ nil ]
		borderColor: 	an ObservableValueHolder[ nil ]
		dragEnabled: 	an ObservableValueHolder[ false ]
		dropEnabled: 	an ObservableValueHolder[ false ]
		color: 	an ObservableValueHolder[ nil ]
		help: 	an ObservableValueHolder[ nil ]
		enabled: 	an ObservableValueHolder[ true ]
		wantsDrop: 	an ObservableValueHolder[ [ :transfer | self dropEnabled ] ]
		acceptDrop: 	an ObservableValueHolder[ [ :transfer | ] ]
		deferredActions: 	nil
		hasUnacceptedEdits: 	an ObservableValueHolder[ false ]
		selection: 	an ObservableValueHolder[ (1 to: 45) ]
		wantsVisualFeedback: 	an ObservableValueHolder[ true ]
		askBeforeDiscardingEdits: 	an ObservableValueHolder[ true ]
		text: 	an ObservableValueHolder[ '(VisualizerMain new createSampleGraph) ope[..]
		actionToPerform: 	an ObservableValueHolder[ [ :txt |  ] ]
		readSelection: 	an ObservableValueHolder[ [ selection ] ]
		placeholder: 	an ObservableValueHolder[ '' ]
		contextMenu: 	an ObservableValueHolder[ [ (self menuActionsFor: text) asMenu[..]
		scrollValue: 	an ObservableValueHolder[ (0@0) ]
		editionContextMenu: 	an ObservableValueHolder[ true ]
		editable: 	an ObservableValueHolder[ true ]
		wrapWord: 	an ObservableValueHolder[ true ]
		undoRedoHistory: 	true
		wrapScrollBars: 	true
		propagateNaturalHeight: 	false
		propagateNaturalWidth: 	false
		scrollBarStyles: 	#()
		syntaxHighlight: 	an ObservableValueHolder[ true ]
		smartCharacters: 	an ObservableValueHolder[ true ]
		lineNumbers: 	an ObservableValueHolder[ true ]
		interactionModel: 	an ObservableValueHolder[ a StPlaygroundInteractionModel ]
		overrideContextMenu: 	true
		submitBlock: 	nil
		resetBlock: 	nil
		environment: 	nil
		systemNavigation: 	nil
		syntaxHighlightTheme: 	an ObservableValueHolder[ nil ]


StPlaygroundPagePresenter>>doEvaluateAndGo
	Receiver: a StPlaygroundPagePresenter
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicBoxAdapter)
		announcer: 	an Announcer
		owner: 	a SpMillerColumnPresenter
		adapter: 	a SpMorphicBoxAdapter
		needRebuild: 	true
		eventHandler: 	nil
		application: 	a StPharoApplication
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ nil ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Untitled window' ]
		additionalSubpresentersMap: 	a Dictionary()
		layout: 	an ObservableValueHolder[ a SpBoxLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		text: 	a SpCodePresenter
		toolbar: 	a SpToolbarPresenter
		statusbar: 	a SpPresenter
		lineLabel: 	a SpLabelPresenter
		toggleLineNumberButton: 	a SpToggleButtonPresenter
		page: 	a StPlaygroundPage
		activationBlock: 	[ :selection |
		self changeSelection: selection from: new[..]


StPlaygroundPagePresenter>>doEvaluateAllAndGo
	Receiver: a StPlaygroundPagePresenter
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicBoxAdapter)
		announcer: 	an Announcer
		owner: 	a SpMillerColumnPresenter
		adapter: 	a SpMorphicBoxAdapter
		needRebuild: 	true
		eventHandler: 	nil
		application: 	a StPharoApplication
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ nil ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Untitled window' ]
		additionalSubpresentersMap: 	a Dictionary()
		layout: 	an ObservableValueHolder[ a SpBoxLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		text: 	a SpCodePresenter
		toolbar: 	a SpToolbarPresenter
		statusbar: 	a SpPresenter
		lineLabel: 	a SpLabelPresenter
		toggleLineNumberButton: 	a SpToggleButtonPresenter
		page: 	a StPlaygroundPage
		activationBlock: 	[ :selection |
		self changeSelection: selection from: new[..]


StPlaygroundDoItCommand>>execute
	Receiver: a StPlaygroundDoItCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		context: 	a StPlaygroundPagePresenter
		basicName: 	'Do it'
		basicDescription: 	'Do it all and inspect.'


SpCommand(CmCommandDecorator)>>execute
	Receiver: a SpCommand(Do it)
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a StPlaygroundDoItCommand
		iconProvider: 	a StPharoApplication
		iconName: 	#glamorousGo
		shortcutKey: 	nil
		displayStrategy: 	a CmUIDisableWhenCantBeRun
		positionStrategy: 	a CmUILeftPositionStrategy
		buildPresenterBlock: 	[ :specCommand | 
			aButtonClass new
				label: specC[..]
		presenter: 	a SpToolbarButtonPresenter


[ specCommand execute ] in [ :specCommand | 
			aButtonClass new
				label: specCommand name;
				help: specCommand description;
				in: [ :button | 
					specCommand hasIcon
						ifTrue: [ button icon: specCommand icon ] ];
				action: [ specCommand execute ];
				yourself ] in SpCommand>>configureAsButtonOfClass:
	Receiver: a SpCommand(Do it)
	Arguments and temporary variables: 
		aButtonClass: 	nil
		specCommand: 	a SpCommand(Do it)
	Receiver's instance variables: 
		decoratedCommand: 	a StPlaygroundDoItCommand
		iconProvider: 	a StPharoApplication
		iconName: 	#glamorousGo
		shortcutKey: 	nil
		displayStrategy: 	a CmUIDisableWhenCantBeRun
		positionStrategy: 	a CmUILeftPositionStrategy
		buildPresenterBlock: 	[ :specCommand | 
			aButtonClass new
				label: specC[..]
		presenter: 	a SpToolbarButtonPresenter


FullBlockClosure(BlockClosure)>>cull:
	Receiver: [ specCommand execute ]
	Arguments and temporary variables: 
		anArg: 	a SpToolbarButtonPresenter
	Receiver's instance variables: 
		outerContext: 	[ :specCommand | 
			aButtonClass new
				label: specCommand [..]
		compiledBlock: 	a CompiledBlock: [ specCommand execute ]
		numArgs: 	0
		receiver: 	a SpCommand(Do it)


SpMorphicToolbarButtonAdapter>>execute
	Receiver: a SpMorphicToolbarButtonAdapter
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpToolbarButtonMorph(692492032))
		announcer: 	nil
		model: 	a SpToolbarButtonPresenter
		widget: 	a SpToolbarButtonMorph(692492032)
		selector: 	nil
		owner: 	a SpToolbarButtonPresenter
		unsubscribed: 	false


SpToolbarButtonMorph(PluggableButtonMorph)>>performAction:
	Receiver: a SpToolbarButtonMorph(692492032)
	Arguments and temporary variables: 
		event: 	[(20.0@15.0) mouseUp 188268 nil]
	Receiver's instance variables: 
		bounds: 	(0.0@5.0) corner: (45.0@39.0)
		owner: 	a Morph(1030908416)
		submorphs: 	an Array(an AlignmentMorph(828633088))
		fullBounds: 	nil
		color: 	(Color r: 0.9012707722385142 g: 0.9012707722385142 b: 0.901270772238[..]
		extension: 	a MorphExtension (411870464) [balloonText]  [other:  (presenter [..]
		borderWidth: 	0
		borderColor: 	#simple
		model: 	a SpMorphicToolbarButtonAdapter
		label: 	'Do it'
		icon: 	Form(13x13x32)
		getIconSelector: 	#icon
		getStateSelector: 	#state
		actionSelector: 	#execute
		font: 	a LogicalFont
 familyName: 'Source Sans Pro'
 emphasis: nil
 pointSiz[..]
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	nil
		getFontSelector: 	nil
		labelMorph: 	a LabelMorph(968973312)'Do it'
		iconMorph: 	an ImageMorph(406735104)
		iconPosition: 	#top
		lastState: 	false
		badgeFont: 	nil
		badgeSelector: 	#badge


[:m |
		(m containsPoint: evt cursorPoint) ifTrue: [m enabled ifTrue: [ m performAction: evt ]]] in SpToolbarButtonMorph(PluggableButtonMorph)>>mouseUp:
	Receiver: a SpToolbarButtonMorph(692492032)
	Arguments and temporary variables: 
		evt: 	[(20.0@15.0) mouseUp 188268 nil]
		all: 	an Array(a SpToolbarButtonMorph(692492032) a SpToolbarButtonMorph(3319[..]
		m: 	a SpToolbarButtonMorph(692492032)
	Receiver's instance variables: 
		bounds: 	(0.0@5.0) corner: (45.0@39.0)
		owner: 	a Morph(1030908416)
		submorphs: 	an Array(an AlignmentMorph(828633088))
		fullBounds: 	nil
		color: 	(Color r: 0.9012707722385142 g: 0.9012707722385142 b: 0.901270772238[..]
		extension: 	a MorphExtension (411870464) [balloonText]  [other:  (presenter [..]
		borderWidth: 	0
		borderColor: 	#simple
		model: 	a SpMorphicToolbarButtonAdapter
		label: 	'Do it'
		icon: 	Form(13x13x32)
		getIconSelector: 	#icon
		getStateSelector: 	#state
		actionSelector: 	#execute
		font: 	a LogicalFont
 familyName: 'Source Sans Pro'
 emphasis: nil
 pointSiz[..]
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	nil
		getFontSelector: 	nil
		labelMorph: 	a LabelMorph(968973312)'Do it'
		iconMorph: 	an ImageMorph(406735104)
		iconPosition: 	#top
		lastState: 	false
		badgeFont: 	nil
		badgeSelector: 	#badge


Array(SequenceableCollection)>>do:
	Receiver: an Array(a SpToolbarButtonMorph(692492032) a SpToolbarButtonMorph(331952128) a SpToolb[..]
	Arguments and temporary variables: 
		aBlock: 	[:m |
		(m containsPoint: evt cursorPoint) ifTrue: [m enabled ifTru[..]
		index: 	1
	Receiver's instance variables: 
an Array(a SpToolbarButtonMorph(692492032) a SpToolbarButtonMorph(331952128) a SpToolb[..]

SpToolbarButtonMorph(PluggableButtonMorph)>>mouseUp:
	Receiver: a SpToolbarButtonMorph(692492032)
	Arguments and temporary variables: 
		evt: 	[(20.0@15.0) mouseUp 188268 nil]
		all: 	an Array(a SpToolbarButtonMorph(692492032) a SpToolbarButtonMorph(3319[..]
	Receiver's instance variables: 
		bounds: 	(0.0@5.0) corner: (45.0@39.0)
		owner: 	a Morph(1030908416)
		submorphs: 	an Array(an AlignmentMorph(828633088))
		fullBounds: 	nil
		color: 	(Color r: 0.9012707722385142 g: 0.9012707722385142 b: 0.901270772238[..]
		extension: 	a MorphExtension (411870464) [balloonText]  [other:  (presenter [..]
		borderWidth: 	0
		borderColor: 	#simple
		model: 	a SpMorphicToolbarButtonAdapter
		label: 	'Do it'
		icon: 	Form(13x13x32)
		getIconSelector: 	#icon
		getStateSelector: 	#state
		actionSelector: 	#execute
		font: 	a LogicalFont
 familyName: 'Source Sans Pro'
 emphasis: nil
 pointSiz[..]
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	nil
		getFontSelector: 	nil
		labelMorph: 	a LabelMorph(968973312)'Do it'
		iconMorph: 	an ImageMorph(406735104)
		iconPosition: 	#top
		lastState: 	false
		badgeFont: 	nil
		badgeSelector: 	#badge


SpToolbarButtonMorph(Morph)>>handleMouseUp:
	Receiver: a SpToolbarButtonMorph(692492032)
	Arguments and temporary variables: 
		anEvent: 	[(20.0@15.0) mouseUp 188268 nil]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(0.0@5.0) corner: (45.0@39.0)
		owner: 	a Morph(1030908416)
		submorphs: 	an Array(an AlignmentMorph(828633088))
		fullBounds: 	nil
		color: 	(Color r: 0.9012707722385142 g: 0.9012707722385142 b: 0.901270772238[..]
		extension: 	a MorphExtension (411870464) [balloonText]  [other:  (presenter [..]
		borderWidth: 	0
		borderColor: 	#simple
		model: 	a SpMorphicToolbarButtonAdapter
		label: 	'Do it'
		icon: 	Form(13x13x32)
		getIconSelector: 	#icon
		getStateSelector: 	#state
		actionSelector: 	#execute
		font: 	a LogicalFont
 familyName: 'Source Sans Pro'
 emphasis: nil
 pointSiz[..]
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	nil
		getFontSelector: 	nil
		labelMorph: 	a LabelMorph(968973312)'Do it'
		iconMorph: 	an ImageMorph(406735104)
		iconPosition: 	#top
		lastState: 	false
		badgeFont: 	nil
		badgeSelector: 	#badge


MouseButtonEvent>>sentTo:
	Receiver: [(20.0@15.0) mouseUp 188268 nil]
	Arguments and temporary variables: 
		anObject: 	a SpToolbarButtonMorph(692492032)
	Receiver's instance variables: 
		timeStamp: 	188268
		source: 	a HandMorph(337424384)
		windowIndex: 	nil
		type: 	#mouseUp
		buttons: 	0
		position: 	(20.0@15.0)
		handler: 	nil
		wasHandled: 	true
		whichButton: 	4


SpToolbarButtonMorph(Morph)>>handleEvent:
	Receiver: a SpToolbarButtonMorph(692492032)
	Arguments and temporary variables: 
		anEvent: 	[(20.0@15.0) mouseUp 188268 nil]
	Receiver's instance variables: 
		bounds: 	(0.0@5.0) corner: (45.0@39.0)
		owner: 	a Morph(1030908416)
		submorphs: 	an Array(an AlignmentMorph(828633088))
		fullBounds: 	nil
		color: 	(Color r: 0.9012707722385142 g: 0.9012707722385142 b: 0.901270772238[..]
		extension: 	a MorphExtension (411870464) [balloonText]  [other:  (presenter [..]
		borderWidth: 	0
		borderColor: 	#simple
		model: 	a SpMorphicToolbarButtonAdapter
		label: 	'Do it'
		icon: 	Form(13x13x32)
		getIconSelector: 	#icon
		getStateSelector: 	#state
		actionSelector: 	#execute
		font: 	a LogicalFont
 familyName: 'Source Sans Pro'
 emphasis: nil
 pointSiz[..]
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	nil
		getFontSelector: 	nil
		labelMorph: 	a LabelMorph(968973312)'Do it'
		iconMorph: 	an ImageMorph(406735104)
		iconPosition: 	#top
		lastState: 	false
		badgeFont: 	nil
		badgeSelector: 	#badge


SpToolbarButtonMorph(Morph)>>handleFocusEvent:
	Receiver: a SpToolbarButtonMorph(692492032)
	Arguments and temporary variables: 
		anEvent: 	[(20.0@15.0) mouseUp 188268 nil]
	Receiver's instance variables: 
		bounds: 	(0.0@5.0) corner: (45.0@39.0)
		owner: 	a Morph(1030908416)
		submorphs: 	an Array(an AlignmentMorph(828633088))
		fullBounds: 	nil
		color: 	(Color r: 0.9012707722385142 g: 0.9012707722385142 b: 0.901270772238[..]
		extension: 	a MorphExtension (411870464) [balloonText]  [other:  (presenter [..]
		borderWidth: 	0
		borderColor: 	#simple
		model: 	a SpMorphicToolbarButtonAdapter
		label: 	'Do it'
		icon: 	Form(13x13x32)
		getIconSelector: 	#icon
		getStateSelector: 	#state
		actionSelector: 	#execute
		font: 	a LogicalFont
 familyName: 'Source Sans Pro'
 emphasis: nil
 pointSiz[..]
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	nil
		getFontSelector: 	nil
		labelMorph: 	a LabelMorph(968973312)'Do it'
		iconMorph: 	an ImageMorph(406735104)
		iconPosition: 	#top
		lastState: 	false
		badgeFont: 	nil
		badgeSelector: 	#badge


[
		result := focusHolder handleFocusEvent: transformedEvent.
	] in HandMorph>>sendFocusEvent:to:clear:
	Receiver: a HandMorph(337424384)
	Arguments and temporary variables: 
		anEvent: 	[(539@318) mouseUp 188268 nil]
		focusHolder: 	a SpToolbarButtonMorph(692492032)
		aBlock: 	[self mouseFocus: nil]
		w: 	a WorldMorph(341720576) [world]
		transformedEvent: 	[(20.0@15.0) mouseUp 188268 nil]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(539@318.0) corner: (555@334.0)
		owner: 	a WorldMorph(341720576) [world]
		submorphs: 	#()
		fullBounds: 	(539@318.0) corner: (555@334.0)
		color: 	Color blue
		extension: 	a MorphExtension (370611968)
		mouseFocus: 	nil
		keyboardFocus: 	a RubEditingArea(981474304)
		eventListeners: 	nil
		mouseListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(539@318) mouseUp 188268 nil]
		targetOffset: 	(20.0@10.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 0 0 0 0 0 nil nil)
		captureBlock: 	nil
		recentModifiers: 	0
		pendingEventQueue: 	WaitfreeQueue with 0 items
		supressNextKeyPress: 	false


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
		result := focusHolder handleFocusEvent: transformedEvent.
	]
	Arguments and temporary variables: 
		exception: 	Error
		handlerAction: 	[ :ex |
			ActiveWorld := priorWorld.
			ex pass ]
	Receiver's instance variables: 
		outerContext: 	HandMorph>>sendFocusEvent:to:clear:
		compiledBlock: 	a CompiledBlock: [
		result := focusHolder handleFocusEvent:[..]
		numArgs: 	0
		receiver: 	a HandMorph(337424384)


WorldMorph>>becomeActiveDuring:
	Receiver: a WorldMorph(341720576) [world]
	Arguments and temporary variables: 
		aBlock: 	[
		result := focusHolder handleFocusEvent: transformedEvent.
	]
		priorWorld: 	a WorldMorph(341720576) [world]
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1728@1051)
		owner: 	nil
		submorphs: 	an Array(a MenubarMorph(112886016) a TaskbarMorph(279458560) a S[..]
		fullBounds: 	(0@0) corner: (1728@1051)
		color: 	(Color r: 0.9403714565004888 g: 0.9403714565004888 b: 0.940371456500[..]
		extension: 	a MorphExtension (1012946432) [other:  (dragEnabled -> true) (dr[..]
		borderWidth: 	0
		borderColor: 	(Color r: 0.8611925708699902 g: 1.0 b: 0.7223851417399805 alph[..]
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil


HandMorph>>sendFocusEvent:to:clear:
	Receiver: a HandMorph(337424384)
	Arguments and temporary variables: 
		result: 	nil
		anEvent: 	[(539@318) mouseUp 188268 nil]
		focusHolder: 	a SpToolbarButtonMorph(692492032)
		aBlock: 	[self mouseFocus: nil]
		w: 	a WorldMorph(341720576) [world]
		transformedEvent: 	[(20.0@15.0) mouseUp 188268 nil]
	Receiver's instance variables: 
		bounds: 	(539@318.0) corner: (555@334.0)
		owner: 	a WorldMorph(341720576) [world]
		submorphs: 	#()
		fullBounds: 	(539@318.0) corner: (555@334.0)
		color: 	Color blue
		extension: 	a MorphExtension (370611968)
		mouseFocus: 	nil
		keyboardFocus: 	a RubEditingArea(981474304)
		eventListeners: 	nil
		mouseListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(539@318) mouseUp 188268 nil]
		targetOffset: 	(20.0@10.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 0 0 0 0 0 nil nil)
		captureBlock: 	nil
		recentModifiers: 	0
		pendingEventQueue: 	WaitfreeQueue with 0 items
		supressNextKeyPress: 	false


HandMorph>>sendEvent:focus:clear:
	Receiver: a HandMorph(337424384)
	Arguments and temporary variables: 
		anEvent: 	[(539@318) mouseUp 188268 nil]
		focusHolder: 	a SpToolbarButtonMorph(692492032)
		aBlock: 	[self mouseFocus: nil]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(539@318.0) corner: (555@334.0)
		owner: 	a WorldMorph(341720576) [world]
		submorphs: 	#()
		fullBounds: 	(539@318.0) corner: (555@334.0)
		color: 	Color blue
		extension: 	a MorphExtension (370611968)
		mouseFocus: 	nil
		keyboardFocus: 	a RubEditingArea(981474304)
		eventListeners: 	nil
		mouseListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(539@318) mouseUp 188268 nil]
		targetOffset: 	(20.0@10.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 0 0 0 0 0 nil nil)
		captureBlock: 	nil
		recentModifiers: 	0
		pendingEventQueue: 	WaitfreeQueue with 0 items
		supressNextKeyPress: 	false


HandMorph>>sendMouseEvent:
	Receiver: a HandMorph(337424384)
	Arguments and temporary variables: 
		anEvent: 	[(539@318) mouseUp 188268 nil]
	Receiver's instance variables: 
		bounds: 	(539@318.0) corner: (555@334.0)
		owner: 	a WorldMorph(341720576) [world]
		submorphs: 	#()
		fullBounds: 	(539@318.0) corner: (555@334.0)
		color: 	Color blue
		extension: 	a MorphExtension (370611968)
		mouseFocus: 	nil
		keyboardFocus: 	a RubEditingArea(981474304)
		eventListeners: 	nil
		mouseListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(539@318) mouseUp 188268 nil]
		targetOffset: 	(20.0@10.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 0 0 0 0 0 nil nil)
		captureBlock: 	nil
		recentModifiers: 	0
		pendingEventQueue: 	WaitfreeQueue with 0 items
		supressNextKeyPress: 	false


HandMorph>>handleEvent:
	Receiver: a HandMorph(337424384)
	Arguments and temporary variables: 
		anEvent: 	[(539@318) mouseUp 188268 nil]
		evt: 	[(539@318) mouseUp 188268 nil]
	Receiver's instance variables: 
		bounds: 	(539@318.0) corner: (555@334.0)
		owner: 	a WorldMorph(341720576) [world]
		submorphs: 	#()
		fullBounds: 	(539@318.0) corner: (555@334.0)
		color: 	Color blue
		extension: 	a MorphExtension (370611968)
		mouseFocus: 	nil
		keyboardFocus: 	a RubEditingArea(981474304)
		eventListeners: 	nil
		mouseListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(539@318) mouseUp 188268 nil]
		targetOffset: 	(20.0@10.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 0 0 0 0 0 nil nil)
		captureBlock: 	nil
		recentModifiers: 	0
		pendingEventQueue: 	WaitfreeQueue with 0 items
		supressNextKeyPress: 	false


[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil ]) ifTrue: [
			morphicWorld activeHand handleEvent: anEvent
		]
	] in OSWindowMorphicEventHandler>>dispatchMorphicEvent:
	Receiver: an OSWindowMorphicEventHandler
	Arguments and temporary variables: 
		anEvent: 	[(539@318) mouseUp 188268 nil]
	Receiver's instance variables: 
		morphicWorld: 	a WorldMorph(341720576) [world]


WorldState>>runStepMethodsIn:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(341720576) [world]
		queue: 	WaitfreeQueue with 0 items
		nextInQueue: 	[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNo[..]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(337424384))
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap()
		lastStepTime: 	182375
		lastStepMessage: 	nil
		alarms: 	a Heap(MorphicAlarm(#hideShow -> a RubCursor(266344960)))
		lastAlarmTime: 	188246
		activeHand: 	a HandMorph(337424384)
		currentCursor: 	((CursorWithMask
	extent: (16@16)
	depth: 1
	fromArray: #(
	[..]
		worldRenderer: 	an OSWorldRenderer
		realWindowExtent: 	(1728@1051)
		deferredUIMessages: 	WaitfreeQueue with 0 items


WorldMorph>>runStepMethods
	Receiver: a WorldMorph(341720576) [world]
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1728@1051)
		owner: 	nil
		submorphs: 	an Array(a MenubarMorph(112886016) a TaskbarMorph(279458560) a S[..]
		fullBounds: 	(0@0) corner: (1728@1051)
		color: 	(Color r: 0.9403714565004888 g: 0.9403714565004888 b: 0.940371456500[..]
		extension: 	a MorphExtension (1012946432) [other:  (dragEnabled -> true) (dr[..]
		borderWidth: 	0
		borderColor: 	(Color r: 0.8611925708699902 g: 1.0 b: 0.7223851417399805 alph[..]
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil


WorldState>>doOneCycleFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(341720576) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(337424384))
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap()
		lastStepTime: 	182375
		lastStepMessage: 	nil
		alarms: 	a Heap(MorphicAlarm(#hideShow -> a RubCursor(266344960)))
		lastAlarmTime: 	188246
		activeHand: 	a HandMorph(337424384)
		currentCursor: 	((CursorWithMask
	extent: (16@16)
	depth: 1
	fromArray: #(
	[..]
		worldRenderer: 	an OSWorldRenderer
		realWindowExtent: 	(1728@1051)
		deferredUIMessages: 	WaitfreeQueue with 0 items


WorldMorph>>doOneCycleNow
	Receiver: a WorldMorph(341720576) [world]
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1728@1051)
		owner: 	nil
		submorphs: 	an Array(a MenubarMorph(112886016) a TaskbarMorph(279458560) a S[..]
		fullBounds: 	(0@0) corner: (1728@1051)
		color: 	(Color r: 0.9403714565004888 g: 0.9403714565004888 b: 0.940371456500[..]
		extension: 	a MorphExtension (1012946432) [other:  (dragEnabled -> true) (dr[..]
		borderWidth: 	0
		borderColor: 	(Color r: 0.8611925708699902 g: 1.0 b: 0.7223851417399805 alph[..]
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil


WorldMorph>>doOneCycle
	Receiver: a WorldMorph(341720576) [world]
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1728@1051)
		owner: 	nil
		submorphs: 	an Array(a MenubarMorph(112886016) a TaskbarMorph(279458560) a S[..]
		fullBounds: 	(0@0) corner: (1728@1051)
		color: 	(Color r: 0.9403714565004888 g: 0.9403714565004888 b: 0.940371456500[..]
		extension: 	a MorphExtension (1012946432) [other:  (dragEnabled -> true) (dr[..]
		borderWidth: 	0
		borderColor: 	(Color r: 0.8611925708699902 g: 1.0 b: 0.7223851417399805 alph[..]
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil


[
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMutex critical: [
			                     self extraWorldList ].
		extraWorldsToDraw do: [ :world | world doOneCycle ].

		(self currentWorld isNotNil and: [
			 (extraWorldsToDraw includes: self currentWorld) not ]) ifTrue: [
			self currentWorld doOneCycle ] ] in WorldMorph class>>doOneCycle
	Receiver: WorldMorph
	Arguments and temporary variables: 
		extraWorldsToDraw: 	#()
	Receiver's instance variables: 
		superclass: 	PasteUpMorph
		methodDict: 	a MethodDictionary(#acceptDroppingMorph:event:->WorldMorph>>#ac[..]
		format: 	65547
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		commentSourcePointer: 	nil
		subclasses: 	{AthensWorldMorph. OSWindowWorldMorph}
		name: 	#WorldMorph
		classPool: 	a Dictionary(#AllowDropFiles->nil #CursorOwnerWorld->a WorldMorp[..]
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Morphic-Core-Worlds'
		announcer: 	nil
		displayScaleFactor: 	1


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMutex critical: [
			  [..]
	Arguments and temporary variables: 
		aBlock: 	[
		self doInterCycleWait
	]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	WorldMorph class>>doOneCycle
		compiledBlock: 	a CompiledBlock: [
		| extraWorldsToDraw |
		extraWorldsToDr[..]
		numArgs: 	0
		receiver: 	WorldMorph


WorldState class>>doDrawCycleWith:
	Receiver: WorldState
	Arguments and temporary variables: 
		aBlock: 	[
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMute[..]
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary(#activeHand->WorldState>>#activeHand #active[..]
		format: 	65548
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		commentSourcePointer: 	nil
		subclasses: 	{AthensWorldState}
		name: 	#WorldState
		classPool: 	a Dictionary(#CanSurrenderToOS->nil #DebugShowDamage->false #Des[..]
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Morphic-Core-Worlds'



--- The full stack ---
RSBox(Object)>>doesNotUnderstand: #+
VisualizerMain>>createSampleGraph
UndefinedObject>>DoIt
OCReceiverDoItSemanticScope(OCDoItSemanticScope)>>evaluateDoIt:
OpalCompiler>>evaluate
[
		self announcer announce: (SpCodeWillBeEvaluatedAnnouncement newContent: aString).
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionModel doItReceiver.
		result := receiver class compiler
			source: aString;
			context: self interactionModel doItContext;
			receiver: self interactionModel doItReceiver;
			requestor: self interactionModel;
			environment: self environment;
			failBlock:  [ 
				self announcer announce: (SpCodeEvaluationFailedAnnouncement newContent: aString).
				^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		self announcer announce: (SpCodeEvaluationSucceedAnnouncement newContent: aString).
		result ] in SpCodePresenter>>evaluate:onCompileError:onError:
FullBlockClosure(BlockClosure)>>on:do:
SpCodePresenter>>evaluate:onCompileError:onError:
StPlaygroundPagePresenter>>doEvaluateAndGo
StPlaygroundPagePresenter>>doEvaluateAllAndGo
StPlaygroundDoItCommand>>execute
SpCommand(CmCommandDecorator)>>execute
[ specCommand execute ] in [ :specCommand | 
			aButtonClass new
				label: specCommand name;
				help: specCommand description;
				in: [ :button | 
					specCommand hasIcon
						ifTrue: [ button icon: specCommand icon ] ];
				action: [ specCommand execute ];
				yourself ] in SpCommand>>configureAsButtonOfClass:
FullBlockClosure(BlockClosure)>>cull:
SpMorphicToolbarButtonAdapter>>execute
SpToolbarButtonMorph(PluggableButtonMorph)>>performAction:
[:m |
		(m containsPoint: evt cursorPoint) ifTrue: [m enabled ifTrue: [ m performAction: evt ]]] in SpToolbarButtonMorph(PluggableButtonMorph)>>mouseUp:
Array(SequenceableCollection)>>do:
SpToolbarButtonMorph(PluggableButtonMorph)>>mouseUp:
SpToolbarButtonMorph(Morph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
SpToolbarButtonMorph(Morph)>>handleEvent:
SpToolbarButtonMorph(Morph)>>handleFocusEvent:
[
		result := focusHolder handleFocusEvent: transformedEvent.
	] in HandMorph>>sendFocusEvent:to:clear:
FullBlockClosure(BlockClosure)>>on:do:
WorldMorph>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil ]) ifTrue: [
			morphicWorld activeHand handleEvent: anEvent
		]
	] in OSWindowMorphicEventHandler>>dispatchMorphicEvent:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycleNow
WorldMorph>>doOneCycle
[
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMutex critical: [
			                     self extraWorldList ].
		extraWorldsToDraw do: [ :world | world doOneCycle ].

		(self currentWorld isNotNil and: [
			 (extraWorldsToDraw includes: self currentWorld) not ]) ifTrue: [
			self currentWorld doOneCycle ] ] in WorldMorph class>>doOneCycle
FullBlockClosure(BlockClosure)>>ensure:
WorldState class>>doDrawCycleWith:
 - - - - - - - - - - - - - - -
			- - - - - - - - - - - - - - - - - -
WorldMorph class>>doOneCycle
MorphicRenderLoop>>doOneCycle
MorphicRenderLoop>>doOneCycleWhile:
[ MorphicRenderLoop new doOneCycleWhile: [ true ] ] in MorphicUIManager>>spawnNewProcess
[self value.
			"IMPORTANT: Do not step over next line of code. See method comments for details"
			Processor terminateRealActive] in FullBlockClosure(BlockClosure)>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
Instance of RSBox did not understand #+
23 October 2023 11:55:23.396471 pm

VM: Mac OS - arm64 - 1000 - CoInterpreter VMMaker-tonel.1 uuid: 902dd483-c0c4-0d00-86f2-0f880df24b96 Oct 23 2023
StackToRegisterMappingCogit VMMaker-tonel.1 uuid: 902dd483-c0c4-0d00-86f2-0f880df24b96 Oct 23 2023
v10.0.8 - Commit: b323c5fb - Date: 2023-10-20 16:02:07 -0400

Image: Pharo11.0.0 [Build information: Pharo-11.0.0+build.710.sha.ea28d8552cac85a7ce1e9c34ab1e7bd45f7b9910 (64 Bit)]

RSBox(Object)>>doesNotUnderstand: #+
	Receiver: a RSBox
	Arguments and temporary variables: 
		aMessage: 	+ 'Alice'
		exception: 	Instance of RSBox did not understand #+
		resumeValue: 	nil
	Receiver's instance variables: 
		announcer: 	nil
		properties: 	nil
		paint: 	Color blue
		path: 	(-25.0@ -25.0) corner: (25.0@25.0)
		border: 	nil
		parent: 	nil
		isFixed: 	false
		encompassingRectangle: 	nil
		model: 	nil
		baseRectangle: 	(-25.0@ -25.0) corner: (25.0@25.0)
		matrix: 	x: 0.0 y: 0.0 sx: 1.0 sy: 1.0 shx: 0.0 shy: 0.0
		connectedLines: 	nil
		shouldUpdateLines: 	true
		cornerRadius: 	nil


VisualizerMain>>createSampleGraph
	Receiver: a VisualizerMain
	Arguments and temporary variables: 
		view: 	a RSCanvas
		alice: 	nil
		bob: 	nil
	Receiver's instance variables: 
a VisualizerMain

UndefinedObject>>DoIt
	Receiver: nil
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
nil

OCReceiverDoItSemanticScope(OCDoItSemanticScope)>>evaluateDoIt:
	Receiver: an OCReceiverDoItSemanticScope
	Arguments and temporary variables: 
		doItMethod: 	UndefinedObject>>#DoIt
	Receiver's instance variables: 
		outerScope: 	nil
		targetReceiver: 	nil


OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
		doItMethod: 	UndefinedObject>>#DoIt
	Receiver's instance variables: 
		ast: 	DoIt

	^ VisualizerMain new createSampleGraph open
		source: 	a ReadStream
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil


[
		self announcer announce: (SpCodeWillBeEvaluatedAnnouncement newContent: aString).
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionModel doItReceiver.
		result := receiver class compiler
			source: aString;
			context: self interactionModel doItContext;
			receiver: self interactionModel doItReceiver;
			requestor: self interactionModel;
			environment: self environment;
			failBlock:  [ 
				self announcer announce: (SpCodeEvaluationFailedAnnouncement newContent: aString).
				^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		self announcer announce: (SpCodeEvaluationSucceedAnnouncement newContent: aString).
		result ] in SpCodePresenter>>evaluate:onCompileError:onError:
	Receiver: a SpCodePresenter
	Arguments and temporary variables: 
		aString: 	'(VisualizerMain new createSampleGraph) open.
'
		compileErrorBlock: 	[ ^ self ]
		errorBlock: 	[ :e | e pass ]
		receiver: 	nil
		result: 	nil
		oldBindings: 	a Dictionary()
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicCodeAdapter)
		announcer: 	an Announcer
		owner: 	a StPlaygroundPagePresenter
		adapter: 	a SpMorphicCodeAdapter
		needRebuild: 	true
		eventHandler: 	a SpEventHandler
		application: 	nil
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ a KMCategory ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Code' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpAbstractWidgetLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		borderWidth: 	an ObservableValueHolder[ nil ]
		borderColor: 	an ObservableValueHolder[ nil ]
		dragEnabled: 	an ObservableValueHolder[ false ]
		dropEnabled: 	an ObservableValueHolder[ false ]
		color: 	an ObservableValueHolder[ nil ]
		help: 	an ObservableValueHolder[ nil ]
		enabled: 	an ObservableValueHolder[ true ]
		wantsDrop: 	an ObservableValueHolder[ [ :transfer | self dropEnabled ] ]
		acceptDrop: 	an ObservableValueHolder[ [ :transfer | ] ]
		deferredActions: 	nil
		hasUnacceptedEdits: 	an ObservableValueHolder[ false ]
		selection: 	an ObservableValueHolder[ (1 to: 45) ]
		wantsVisualFeedback: 	an ObservableValueHolder[ true ]
		askBeforeDiscardingEdits: 	an ObservableValueHolder[ true ]
		text: 	an ObservableValueHolder[ '(VisualizerMain new createSampleGraph) ope[..]
		actionToPerform: 	an ObservableValueHolder[ [ :txt |  ] ]
		readSelection: 	an ObservableValueHolder[ [ selection ] ]
		placeholder: 	an ObservableValueHolder[ '' ]
		contextMenu: 	an ObservableValueHolder[ [ (self menuActionsFor: text) asMenu[..]
		scrollValue: 	an ObservableValueHolder[ (0@0) ]
		editionContextMenu: 	an ObservableValueHolder[ true ]
		editable: 	an ObservableValueHolder[ true ]
		wrapWord: 	an ObservableValueHolder[ true ]
		undoRedoHistory: 	true
		wrapScrollBars: 	true
		propagateNaturalHeight: 	false
		propagateNaturalWidth: 	false
		scrollBarStyles: 	#()
		syntaxHighlight: 	an ObservableValueHolder[ true ]
		smartCharacters: 	an ObservableValueHolder[ true ]
		lineNumbers: 	an ObservableValueHolder[ true ]
		interactionModel: 	an ObservableValueHolder[ a StPlaygroundInteractionModel ]
		overrideContextMenu: 	true
		submitBlock: 	nil
		resetBlock: 	nil
		environment: 	nil
		systemNavigation: 	nil
		syntaxHighlightTheme: 	an ObservableValueHolder[ nil ]


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
		self announcer announce: (SpCodeWillBeEvaluatedAnnouncement newContent: aString).
[..]
	Arguments and temporary variables: 
		exception: 	Error
		handlerAction: 	[ :e |
		self announcer announce: (SpCodeEvaluationFailedAnn[..]
	Receiver's instance variables: 
		outerContext: 	SpCodePresenter>>evaluate:onCompileError:onError:
		compiledBlock: 	a CompiledBlock: [
		self announcer announce: (SpCodeWillBeE[..]
		numArgs: 	0
		receiver: 	a SpCodePresenter


SpCodePresenter>>evaluate:onCompileError:onError:
	Receiver: a SpCodePresenter
	Arguments and temporary variables: 
		receiver: 	nil
		result: 	nil
		oldBindings: 	a Dictionary()
		aString: 	'(VisualizerMain new createSampleGraph) open.
'
		compileErrorBlock: 	[ ^ self ]
		errorBlock: 	[ :e | e pass ]
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicCodeAdapter)
		announcer: 	an Announcer
		owner: 	a StPlaygroundPagePresenter
		adapter: 	a SpMorphicCodeAdapter
		needRebuild: 	true
		eventHandler: 	a SpEventHandler
		application: 	nil
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ a KMCategory ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Code' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpAbstractWidgetLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		borderWidth: 	an ObservableValueHolder[ nil ]
		borderColor: 	an ObservableValueHolder[ nil ]
		dragEnabled: 	an ObservableValueHolder[ false ]
		dropEnabled: 	an ObservableValueHolder[ false ]
		color: 	an ObservableValueHolder[ nil ]
		help: 	an ObservableValueHolder[ nil ]
		enabled: 	an ObservableValueHolder[ true ]
		wantsDrop: 	an ObservableValueHolder[ [ :transfer | self dropEnabled ] ]
		acceptDrop: 	an ObservableValueHolder[ [ :transfer | ] ]
		deferredActions: 	nil
		hasUnacceptedEdits: 	an ObservableValueHolder[ false ]
		selection: 	an ObservableValueHolder[ (1 to: 45) ]
		wantsVisualFeedback: 	an ObservableValueHolder[ true ]
		askBeforeDiscardingEdits: 	an ObservableValueHolder[ true ]
		text: 	an ObservableValueHolder[ '(VisualizerMain new createSampleGraph) ope[..]
		actionToPerform: 	an ObservableValueHolder[ [ :txt |  ] ]
		readSelection: 	an ObservableValueHolder[ [ selection ] ]
		placeholder: 	an ObservableValueHolder[ '' ]
		contextMenu: 	an ObservableValueHolder[ [ (self menuActionsFor: text) asMenu[..]
		scrollValue: 	an ObservableValueHolder[ (0@0) ]
		editionContextMenu: 	an ObservableValueHolder[ true ]
		editable: 	an ObservableValueHolder[ true ]
		wrapWord: 	an ObservableValueHolder[ true ]
		undoRedoHistory: 	true
		wrapScrollBars: 	true
		propagateNaturalHeight: 	false
		propagateNaturalWidth: 	false
		scrollBarStyles: 	#()
		syntaxHighlight: 	an ObservableValueHolder[ true ]
		smartCharacters: 	an ObservableValueHolder[ true ]
		lineNumbers: 	an ObservableValueHolder[ true ]
		interactionModel: 	an ObservableValueHolder[ a StPlaygroundInteractionModel ]
		overrideContextMenu: 	true
		submitBlock: 	nil
		resetBlock: 	nil
		environment: 	nil
		systemNavigation: 	nil
		syntaxHighlightTheme: 	an ObservableValueHolder[ nil ]


StPlaygroundPagePresenter>>doEvaluateAndGo
	Receiver: a StPlaygroundPagePresenter
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicBoxAdapter)
		announcer: 	an Announcer
		owner: 	a SpMillerColumnPresenter
		adapter: 	a SpMorphicBoxAdapter
		needRebuild: 	true
		eventHandler: 	nil
		application: 	a StPharoApplication
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ nil ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Untitled window' ]
		additionalSubpresentersMap: 	a Dictionary()
		layout: 	an ObservableValueHolder[ a SpBoxLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		text: 	a SpCodePresenter
		toolbar: 	a SpToolbarPresenter
		statusbar: 	a SpPresenter
		lineLabel: 	a SpLabelPresenter
		toggleLineNumberButton: 	a SpToggleButtonPresenter
		page: 	a StPlaygroundPage
		activationBlock: 	[ :selection |
		self changeSelection: selection from: new[..]


StPlaygroundPagePresenter>>doEvaluateAllAndGo
	Receiver: a StPlaygroundPagePresenter
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicBoxAdapter)
		announcer: 	an Announcer
		owner: 	a SpMillerColumnPresenter
		adapter: 	a SpMorphicBoxAdapter
		needRebuild: 	true
		eventHandler: 	nil
		application: 	a StPharoApplication
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ nil ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Untitled window' ]
		additionalSubpresentersMap: 	a Dictionary()
		layout: 	an ObservableValueHolder[ a SpBoxLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		text: 	a SpCodePresenter
		toolbar: 	a SpToolbarPresenter
		statusbar: 	a SpPresenter
		lineLabel: 	a SpLabelPresenter
		toggleLineNumberButton: 	a SpToggleButtonPresenter
		page: 	a StPlaygroundPage
		activationBlock: 	[ :selection |
		self changeSelection: selection from: new[..]


StPlaygroundDoItCommand>>execute
	Receiver: a StPlaygroundDoItCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		context: 	a StPlaygroundPagePresenter
		basicName: 	'Do it'
		basicDescription: 	'Do it all and inspect.'


SpCommand(CmCommandDecorator)>>execute
	Receiver: a SpCommand(Do it)
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a StPlaygroundDoItCommand
		iconProvider: 	a StPharoApplication
		iconName: 	#glamorousGo
		shortcutKey: 	nil
		displayStrategy: 	a CmUIDisableWhenCantBeRun
		positionStrategy: 	a CmUILeftPositionStrategy
		buildPresenterBlock: 	[ :specCommand | 
			aButtonClass new
				label: specC[..]
		presenter: 	a SpToolbarButtonPresenter


[ specCommand execute ] in [ :specCommand | 
			aButtonClass new
				label: specCommand name;
				help: specCommand description;
				in: [ :button | 
					specCommand hasIcon
						ifTrue: [ button icon: specCommand icon ] ];
				action: [ specCommand execute ];
				yourself ] in SpCommand>>configureAsButtonOfClass:
	Receiver: a SpCommand(Do it)
	Arguments and temporary variables: 
		aButtonClass: 	nil
		specCommand: 	a SpCommand(Do it)
	Receiver's instance variables: 
		decoratedCommand: 	a StPlaygroundDoItCommand
		iconProvider: 	a StPharoApplication
		iconName: 	#glamorousGo
		shortcutKey: 	nil
		displayStrategy: 	a CmUIDisableWhenCantBeRun
		positionStrategy: 	a CmUILeftPositionStrategy
		buildPresenterBlock: 	[ :specCommand | 
			aButtonClass new
				label: specC[..]
		presenter: 	a SpToolbarButtonPresenter


FullBlockClosure(BlockClosure)>>cull:
	Receiver: [ specCommand execute ]
	Arguments and temporary variables: 
		anArg: 	a SpToolbarButtonPresenter
	Receiver's instance variables: 
		outerContext: 	[ :specCommand | 
			aButtonClass new
				label: specCommand [..]
		compiledBlock: 	a CompiledBlock: [ specCommand execute ]
		numArgs: 	0
		receiver: 	a SpCommand(Do it)


SpMorphicToolbarButtonAdapter>>execute
	Receiver: a SpMorphicToolbarButtonAdapter
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpToolbarButtonMorph(692492032))
		announcer: 	nil
		model: 	a SpToolbarButtonPresenter
		widget: 	a SpToolbarButtonMorph(692492032)
		selector: 	nil
		owner: 	a SpToolbarButtonPresenter
		unsubscribed: 	false


SpToolbarButtonMorph(PluggableButtonMorph)>>performAction:
	Receiver: a SpToolbarButtonMorph(692492032)
	Arguments and temporary variables: 
		event: 	[(20.0@15.0) mouseUp 188268 nil]
	Receiver's instance variables: 
		bounds: 	(0.0@5.0) corner: (45.0@39.0)
		owner: 	a Morph(1030908416)
		submorphs: 	an Array(an AlignmentMorph(828633088))
		fullBounds: 	nil
		color: 	(Color r: 0.9012707722385142 g: 0.9012707722385142 b: 0.901270772238[..]
		extension: 	a MorphExtension (411870464) [balloonText]  [other:  (presenter [..]
		borderWidth: 	0
		borderColor: 	#simple
		model: 	a SpMorphicToolbarButtonAdapter
		label: 	'Do it'
		icon: 	Form(13x13x32)
		getIconSelector: 	#icon
		getStateSelector: 	#state
		actionSelector: 	#execute
		font: 	a LogicalFont
 familyName: 'Source Sans Pro'
 emphasis: nil
 pointSiz[..]
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	nil
		getFontSelector: 	nil
		labelMorph: 	a LabelMorph(968973312)'Do it'
		iconMorph: 	an ImageMorph(406735104)
		iconPosition: 	#top
		lastState: 	false
		badgeFont: 	nil
		badgeSelector: 	#badge


[:m |
		(m containsPoint: evt cursorPoint) ifTrue: [m enabled ifTrue: [ m performAction: evt ]]] in SpToolbarButtonMorph(PluggableButtonMorph)>>mouseUp:
	Receiver: a SpToolbarButtonMorph(692492032)
	Arguments and temporary variables: 
		evt: 	[(20.0@15.0) mouseUp 188268 nil]
		all: 	an Array(a SpToolbarButtonMorph(692492032) a SpToolbarButtonMorph(3319[..]
		m: 	a SpToolbarButtonMorph(692492032)
	Receiver's instance variables: 
		bounds: 	(0.0@5.0) corner: (45.0@39.0)
		owner: 	a Morph(1030908416)
		submorphs: 	an Array(an AlignmentMorph(828633088))
		fullBounds: 	nil
		color: 	(Color r: 0.9012707722385142 g: 0.9012707722385142 b: 0.901270772238[..]
		extension: 	a MorphExtension (411870464) [balloonText]  [other:  (presenter [..]
		borderWidth: 	0
		borderColor: 	#simple
		model: 	a SpMorphicToolbarButtonAdapter
		label: 	'Do it'
		icon: 	Form(13x13x32)
		getIconSelector: 	#icon
		getStateSelector: 	#state
		actionSelector: 	#execute
		font: 	a LogicalFont
 familyName: 'Source Sans Pro'
 emphasis: nil
 pointSiz[..]
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	nil
		getFontSelector: 	nil
		labelMorph: 	a LabelMorph(968973312)'Do it'
		iconMorph: 	an ImageMorph(406735104)
		iconPosition: 	#top
		lastState: 	false
		badgeFont: 	nil
		badgeSelector: 	#badge


Array(SequenceableCollection)>>do:
	Receiver: an Array(a SpToolbarButtonMorph(692492032) a SpToolbarButtonMorph(331952128) a SpToolb[..]
	Arguments and temporary variables: 
		aBlock: 	[:m |
		(m containsPoint: evt cursorPoint) ifTrue: [m enabled ifTru[..]
		index: 	1
	Receiver's instance variables: 
an Array(a SpToolbarButtonMorph(692492032) a SpToolbarButtonMorph(331952128) a SpToolb[..]

SpToolbarButtonMorph(PluggableButtonMorph)>>mouseUp:
	Receiver: a SpToolbarButtonMorph(692492032)
	Arguments and temporary variables: 
		evt: 	[(20.0@15.0) mouseUp 188268 nil]
		all: 	an Array(a SpToolbarButtonMorph(692492032) a SpToolbarButtonMorph(3319[..]
	Receiver's instance variables: 
		bounds: 	(0.0@5.0) corner: (45.0@39.0)
		owner: 	a Morph(1030908416)
		submorphs: 	an Array(an AlignmentMorph(828633088))
		fullBounds: 	nil
		color: 	(Color r: 0.9012707722385142 g: 0.9012707722385142 b: 0.901270772238[..]
		extension: 	a MorphExtension (411870464) [balloonText]  [other:  (presenter [..]
		borderWidth: 	0
		borderColor: 	#simple
		model: 	a SpMorphicToolbarButtonAdapter
		label: 	'Do it'
		icon: 	Form(13x13x32)
		getIconSelector: 	#icon
		getStateSelector: 	#state
		actionSelector: 	#execute
		font: 	a LogicalFont
 familyName: 'Source Sans Pro'
 emphasis: nil
 pointSiz[..]
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	nil
		getFontSelector: 	nil
		labelMorph: 	a LabelMorph(968973312)'Do it'
		iconMorph: 	an ImageMorph(406735104)
		iconPosition: 	#top
		lastState: 	false
		badgeFont: 	nil
		badgeSelector: 	#badge


SpToolbarButtonMorph(Morph)>>handleMouseUp:
	Receiver: a SpToolbarButtonMorph(692492032)
	Arguments and temporary variables: 
		anEvent: 	[(20.0@15.0) mouseUp 188268 nil]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(0.0@5.0) corner: (45.0@39.0)
		owner: 	a Morph(1030908416)
		submorphs: 	an Array(an AlignmentMorph(828633088))
		fullBounds: 	nil
		color: 	(Color r: 0.9012707722385142 g: 0.9012707722385142 b: 0.901270772238[..]
		extension: 	a MorphExtension (411870464) [balloonText]  [other:  (presenter [..]
		borderWidth: 	0
		borderColor: 	#simple
		model: 	a SpMorphicToolbarButtonAdapter
		label: 	'Do it'
		icon: 	Form(13x13x32)
		getIconSelector: 	#icon
		getStateSelector: 	#state
		actionSelector: 	#execute
		font: 	a LogicalFont
 familyName: 'Source Sans Pro'
 emphasis: nil
 pointSiz[..]
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	nil
		getFontSelector: 	nil
		labelMorph: 	a LabelMorph(968973312)'Do it'
		iconMorph: 	an ImageMorph(406735104)
		iconPosition: 	#top
		lastState: 	false
		badgeFont: 	nil
		badgeSelector: 	#badge


MouseButtonEvent>>sentTo:
	Receiver: [(20.0@15.0) mouseUp 188268 nil]
	Arguments and temporary variables: 
		anObject: 	a SpToolbarButtonMorph(692492032)
	Receiver's instance variables: 
		timeStamp: 	188268
		source: 	a HandMorph(337424384)
		windowIndex: 	nil
		type: 	#mouseUp
		buttons: 	0
		position: 	(20.0@15.0)
		handler: 	nil
		wasHandled: 	true
		whichButton: 	4


SpToolbarButtonMorph(Morph)>>handleEvent:
	Receiver: a SpToolbarButtonMorph(692492032)
	Arguments and temporary variables: 
		anEvent: 	[(20.0@15.0) mouseUp 188268 nil]
	Receiver's instance variables: 
		bounds: 	(0.0@5.0) corner: (45.0@39.0)
		owner: 	a Morph(1030908416)
		submorphs: 	an Array(an AlignmentMorph(828633088))
		fullBounds: 	nil
		color: 	(Color r: 0.9012707722385142 g: 0.9012707722385142 b: 0.901270772238[..]
		extension: 	a MorphExtension (411870464) [balloonText]  [other:  (presenter [..]
		borderWidth: 	0
		borderColor: 	#simple
		model: 	a SpMorphicToolbarButtonAdapter
		label: 	'Do it'
		icon: 	Form(13x13x32)
		getIconSelector: 	#icon
		getStateSelector: 	#state
		actionSelector: 	#execute
		font: 	a LogicalFont
 familyName: 'Source Sans Pro'
 emphasis: nil
 pointSiz[..]
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	nil
		getFontSelector: 	nil
		labelMorph: 	a LabelMorph(968973312)'Do it'
		iconMorph: 	an ImageMorph(406735104)
		iconPosition: 	#top
		lastState: 	false
		badgeFont: 	nil
		badgeSelector: 	#badge


SpToolbarButtonMorph(Morph)>>handleFocusEvent:
	Receiver: a SpToolbarButtonMorph(692492032)
	Arguments and temporary variables: 
		anEvent: 	[(20.0@15.0) mouseUp 188268 nil]
	Receiver's instance variables: 
		bounds: 	(0.0@5.0) corner: (45.0@39.0)
		owner: 	a Morph(1030908416)
		submorphs: 	an Array(an AlignmentMorph(828633088))
		fullBounds: 	nil
		color: 	(Color r: 0.9012707722385142 g: 0.9012707722385142 b: 0.901270772238[..]
		extension: 	a MorphExtension (411870464) [balloonText]  [other:  (presenter [..]
		borderWidth: 	0
		borderColor: 	#simple
		model: 	a SpMorphicToolbarButtonAdapter
		label: 	'Do it'
		icon: 	Form(13x13x32)
		getIconSelector: 	#icon
		getStateSelector: 	#state
		actionSelector: 	#execute
		font: 	a LogicalFont
 familyName: 'Source Sans Pro'
 emphasis: nil
 pointSiz[..]
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	nil
		getFontSelector: 	nil
		labelMorph: 	a LabelMorph(968973312)'Do it'
		iconMorph: 	an ImageMorph(406735104)
		iconPosition: 	#top
		lastState: 	false
		badgeFont: 	nil
		badgeSelector: 	#badge


[
		result := focusHolder handleFocusEvent: transformedEvent.
	] in HandMorph>>sendFocusEvent:to:clear:
	Receiver: a HandMorph(337424384)
	Arguments and temporary variables: 
		anEvent: 	[(539@318) mouseUp 188268 nil]
		focusHolder: 	a SpToolbarButtonMorph(692492032)
		aBlock: 	[self mouseFocus: nil]
		w: 	a WorldMorph(341720576) [world]
		transformedEvent: 	[(20.0@15.0) mouseUp 188268 nil]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(539@318.0) corner: (555@334.0)
		owner: 	a WorldMorph(341720576) [world]
		submorphs: 	#()
		fullBounds: 	(539@318.0) corner: (555@334.0)
		color: 	Color blue
		extension: 	a MorphExtension (370611968)
		mouseFocus: 	nil
		keyboardFocus: 	a RubEditingArea(981474304)
		eventListeners: 	nil
		mouseListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(539@318) mouseUp 188268 nil]
		targetOffset: 	(20.0@10.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 0 0 0 0 0 nil nil)
		captureBlock: 	nil
		recentModifiers: 	0
		pendingEventQueue: 	WaitfreeQueue with 0 items
		supressNextKeyPress: 	false


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
		result := focusHolder handleFocusEvent: transformedEvent.
	]
	Arguments and temporary variables: 
		exception: 	Error
		handlerAction: 	[ :ex |
			ActiveWorld := priorWorld.
			ex pass ]
	Receiver's instance variables: 
		outerContext: 	HandMorph>>sendFocusEvent:to:clear:
		compiledBlock: 	a CompiledBlock: [
		result := focusHolder handleFocusEvent:[..]
		numArgs: 	0
		receiver: 	a HandMorph(337424384)


WorldMorph>>becomeActiveDuring:
	Receiver: a WorldMorph(341720576) [world]
	Arguments and temporary variables: 
		aBlock: 	[
		result := focusHolder handleFocusEvent: transformedEvent.
	]
		priorWorld: 	a WorldMorph(341720576) [world]
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1728@1051)
		owner: 	nil
		submorphs: 	an Array(a MenubarMorph(112886016) a TaskbarMorph(279458560) a S[..]
		fullBounds: 	(0@0) corner: (1728@1051)
		color: 	(Color r: 0.9403714565004888 g: 0.9403714565004888 b: 0.940371456500[..]
		extension: 	a MorphExtension (1012946432) [other:  (dragEnabled -> true) (dr[..]
		borderWidth: 	0
		borderColor: 	(Color r: 0.8611925708699902 g: 1.0 b: 0.7223851417399805 alph[..]
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil


HandMorph>>sendFocusEvent:to:clear:
	Receiver: a HandMorph(337424384)
	Arguments and temporary variables: 
		result: 	nil
		anEvent: 	[(539@318) mouseUp 188268 nil]
		focusHolder: 	a SpToolbarButtonMorph(692492032)
		aBlock: 	[self mouseFocus: nil]
		w: 	a WorldMorph(341720576) [world]
		transformedEvent: 	[(20.0@15.0) mouseUp 188268 nil]
	Receiver's instance variables: 
		bounds: 	(539@318.0) corner: (555@334.0)
		owner: 	a WorldMorph(341720576) [world]
		submorphs: 	#()
		fullBounds: 	(539@318.0) corner: (555@334.0)
		color: 	Color blue
		extension: 	a MorphExtension (370611968)
		mouseFocus: 	nil
		keyboardFocus: 	a RubEditingArea(981474304)
		eventListeners: 	nil
		mouseListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(539@318) mouseUp 188268 nil]
		targetOffset: 	(20.0@10.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 0 0 0 0 0 nil nil)
		captureBlock: 	nil
		recentModifiers: 	0
		pendingEventQueue: 	WaitfreeQueue with 0 items
		supressNextKeyPress: 	false


HandMorph>>sendEvent:focus:clear:
	Receiver: a HandMorph(337424384)
	Arguments and temporary variables: 
		anEvent: 	[(539@318) mouseUp 188268 nil]
		focusHolder: 	a SpToolbarButtonMorph(692492032)
		aBlock: 	[self mouseFocus: nil]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(539@318.0) corner: (555@334.0)
		owner: 	a WorldMorph(341720576) [world]
		submorphs: 	#()
		fullBounds: 	(539@318.0) corner: (555@334.0)
		color: 	Color blue
		extension: 	a MorphExtension (370611968)
		mouseFocus: 	nil
		keyboardFocus: 	a RubEditingArea(981474304)
		eventListeners: 	nil
		mouseListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(539@318) mouseUp 188268 nil]
		targetOffset: 	(20.0@10.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 0 0 0 0 0 nil nil)
		captureBlock: 	nil
		recentModifiers: 	0
		pendingEventQueue: 	WaitfreeQueue with 0 items
		supressNextKeyPress: 	false


HandMorph>>sendMouseEvent:
	Receiver: a HandMorph(337424384)
	Arguments and temporary variables: 
		anEvent: 	[(539@318) mouseUp 188268 nil]
	Receiver's instance variables: 
		bounds: 	(539@318.0) corner: (555@334.0)
		owner: 	a WorldMorph(341720576) [world]
		submorphs: 	#()
		fullBounds: 	(539@318.0) corner: (555@334.0)
		color: 	Color blue
		extension: 	a MorphExtension (370611968)
		mouseFocus: 	nil
		keyboardFocus: 	a RubEditingArea(981474304)
		eventListeners: 	nil
		mouseListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(539@318) mouseUp 188268 nil]
		targetOffset: 	(20.0@10.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 0 0 0 0 0 nil nil)
		captureBlock: 	nil
		recentModifiers: 	0
		pendingEventQueue: 	WaitfreeQueue with 0 items
		supressNextKeyPress: 	false


HandMorph>>handleEvent:
	Receiver: a HandMorph(337424384)
	Arguments and temporary variables: 
		anEvent: 	[(539@318) mouseUp 188268 nil]
		evt: 	[(539@318) mouseUp 188268 nil]
	Receiver's instance variables: 
		bounds: 	(539@318.0) corner: (555@334.0)
		owner: 	a WorldMorph(341720576) [world]
		submorphs: 	#()
		fullBounds: 	(539@318.0) corner: (555@334.0)
		color: 	Color blue
		extension: 	a MorphExtension (370611968)
		mouseFocus: 	nil
		keyboardFocus: 	a RubEditingArea(981474304)
		eventListeners: 	nil
		mouseListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(539@318) mouseUp 188268 nil]
		targetOffset: 	(20.0@10.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 0 0 0 0 0 nil nil)
		captureBlock: 	nil
		recentModifiers: 	0
		pendingEventQueue: 	WaitfreeQueue with 0 items
		supressNextKeyPress: 	false


[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil ]) ifTrue: [
			morphicWorld activeHand handleEvent: anEvent
		]
	] in OSWindowMorphicEventHandler>>dispatchMorphicEvent:
	Receiver: an OSWindowMorphicEventHandler
	Arguments and temporary variables: 
		anEvent: 	[(539@318) mouseUp 188268 nil]
	Receiver's instance variables: 
		morphicWorld: 	a WorldMorph(341720576) [world]


WorldState>>runStepMethodsIn:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(341720576) [world]
		queue: 	WaitfreeQueue with 0 items
		nextInQueue: 	[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNo[..]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(337424384))
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap()
		lastStepTime: 	182375
		lastStepMessage: 	nil
		alarms: 	a Heap(MorphicAlarm(#hideShow -> a RubCursor(266344960)))
		lastAlarmTime: 	188246
		activeHand: 	a HandMorph(337424384)
		currentCursor: 	((CursorWithMask
	extent: (16@16)
	depth: 1
	fromArray: #(
	[..]
		worldRenderer: 	an OSWorldRenderer
		realWindowExtent: 	(1728@1051)
		deferredUIMessages: 	WaitfreeQueue with 0 items


WorldMorph>>runStepMethods
	Receiver: a WorldMorph(341720576) [world]
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1728@1051)
		owner: 	nil
		submorphs: 	an Array(a MenubarMorph(112886016) a TaskbarMorph(279458560) a S[..]
		fullBounds: 	(0@0) corner: (1728@1051)
		color: 	(Color r: 0.9403714565004888 g: 0.9403714565004888 b: 0.940371456500[..]
		extension: 	a MorphExtension (1012946432) [other:  (dragEnabled -> true) (dr[..]
		borderWidth: 	0
		borderColor: 	(Color r: 0.8611925708699902 g: 1.0 b: 0.7223851417399805 alph[..]
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil


WorldState>>doOneCycleFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(341720576) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(337424384))
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap()
		lastStepTime: 	182375
		lastStepMessage: 	nil
		alarms: 	a Heap(MorphicAlarm(#hideShow -> a RubCursor(266344960)))
		lastAlarmTime: 	188246
		activeHand: 	a HandMorph(337424384)
		currentCursor: 	((CursorWithMask
	extent: (16@16)
	depth: 1
	fromArray: #(
	[..]
		worldRenderer: 	an OSWorldRenderer
		realWindowExtent: 	(1728@1051)
		deferredUIMessages: 	WaitfreeQueue with 0 items


WorldMorph>>doOneCycleNow
	Receiver: a WorldMorph(341720576) [world]
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1728@1051)
		owner: 	nil
		submorphs: 	an Array(a MenubarMorph(112886016) a TaskbarMorph(279458560) a S[..]
		fullBounds: 	(0@0) corner: (1728@1051)
		color: 	(Color r: 0.9403714565004888 g: 0.9403714565004888 b: 0.940371456500[..]
		extension: 	a MorphExtension (1012946432) [other:  (dragEnabled -> true) (dr[..]
		borderWidth: 	0
		borderColor: 	(Color r: 0.8611925708699902 g: 1.0 b: 0.7223851417399805 alph[..]
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil


WorldMorph>>doOneCycle
	Receiver: a WorldMorph(341720576) [world]
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1728@1051)
		owner: 	nil
		submorphs: 	an Array(a MenubarMorph(112886016) a TaskbarMorph(279458560) a S[..]
		fullBounds: 	(0@0) corner: (1728@1051)
		color: 	(Color r: 0.9403714565004888 g: 0.9403714565004888 b: 0.940371456500[..]
		extension: 	a MorphExtension (1012946432) [other:  (dragEnabled -> true) (dr[..]
		borderWidth: 	0
		borderColor: 	(Color r: 0.8611925708699902 g: 1.0 b: 0.7223851417399805 alph[..]
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil


[
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMutex critical: [
			                     self extraWorldList ].
		extraWorldsToDraw do: [ :world | world doOneCycle ].

		(self currentWorld isNotNil and: [
			 (extraWorldsToDraw includes: self currentWorld) not ]) ifTrue: [
			self currentWorld doOneCycle ] ] in WorldMorph class>>doOneCycle
	Receiver: WorldMorph
	Arguments and temporary variables: 
		extraWorldsToDraw: 	#()
	Receiver's instance variables: 
		superclass: 	PasteUpMorph
		methodDict: 	a MethodDictionary(#acceptDroppingMorph:event:->WorldMorph>>#ac[..]
		format: 	65547
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		commentSourcePointer: 	nil
		subclasses: 	{AthensWorldMorph. OSWindowWorldMorph}
		name: 	#WorldMorph
		classPool: 	a Dictionary(#AllowDropFiles->nil #CursorOwnerWorld->a WorldMorp[..]
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Morphic-Core-Worlds'
		announcer: 	nil
		displayScaleFactor: 	1


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMutex critical: [
			  [..]
	Arguments and temporary variables: 
		aBlock: 	[
		self doInterCycleWait
	]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	WorldMorph class>>doOneCycle
		compiledBlock: 	a CompiledBlock: [
		| extraWorldsToDraw |
		extraWorldsToDr[..]
		numArgs: 	0
		receiver: 	WorldMorph


WorldState class>>doDrawCycleWith:
	Receiver: WorldState
	Arguments and temporary variables: 
		aBlock: 	[
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMute[..]
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary(#activeHand->WorldState>>#activeHand #active[..]
		format: 	65548
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		commentSourcePointer: 	nil
		subclasses: 	{AthensWorldState}
		name: 	#WorldState
		classPool: 	a Dictionary(#CanSurrenderToOS->nil #DebugShowDamage->false #Des[..]
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Morphic-Core-Worlds'



--- The full stack ---
RSBox(Object)>>doesNotUnderstand: #+
VisualizerMain>>createSampleGraph
UndefinedObject>>DoIt
OCReceiverDoItSemanticScope(OCDoItSemanticScope)>>evaluateDoIt:
OpalCompiler>>evaluate
[
		self announcer announce: (SpCodeWillBeEvaluatedAnnouncement newContent: aString).
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionModel doItReceiver.
		result := receiver class compiler
			source: aString;
			context: self interactionModel doItContext;
			receiver: self interactionModel doItReceiver;
			requestor: self interactionModel;
			environment: self environment;
			failBlock:  [ 
				self announcer announce: (SpCodeEvaluationFailedAnnouncement newContent: aString).
				^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		self announcer announce: (SpCodeEvaluationSucceedAnnouncement newContent: aString).
		result ] in SpCodePresenter>>evaluate:onCompileError:onError:
FullBlockClosure(BlockClosure)>>on:do:
SpCodePresenter>>evaluate:onCompileError:onError:
StPlaygroundPagePresenter>>doEvaluateAndGo
StPlaygroundPagePresenter>>doEvaluateAllAndGo
StPlaygroundDoItCommand>>execute
SpCommand(CmCommandDecorator)>>execute
[ specCommand execute ] in [ :specCommand | 
			aButtonClass new
				label: specCommand name;
				help: specCommand description;
				in: [ :button | 
					specCommand hasIcon
						ifTrue: [ button icon: specCommand icon ] ];
				action: [ specCommand execute ];
				yourself ] in SpCommand>>configureAsButtonOfClass:
FullBlockClosure(BlockClosure)>>cull:
SpMorphicToolbarButtonAdapter>>execute
SpToolbarButtonMorph(PluggableButtonMorph)>>performAction:
[:m |
		(m containsPoint: evt cursorPoint) ifTrue: [m enabled ifTrue: [ m performAction: evt ]]] in SpToolbarButtonMorph(PluggableButtonMorph)>>mouseUp:
Array(SequenceableCollection)>>do:
SpToolbarButtonMorph(PluggableButtonMorph)>>mouseUp:
SpToolbarButtonMorph(Morph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
SpToolbarButtonMorph(Morph)>>handleEvent:
SpToolbarButtonMorph(Morph)>>handleFocusEvent:
[
		result := focusHolder handleFocusEvent: transformedEvent.
	] in HandMorph>>sendFocusEvent:to:clear:
FullBlockClosure(BlockClosure)>>on:do:
WorldMorph>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil ]) ifTrue: [
			morphicWorld activeHand handleEvent: anEvent
		]
	] in OSWindowMorphicEventHandler>>dispatchMorphicEvent:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycleNow
WorldMorph>>doOneCycle
[
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMutex critical: [
			                     self extraWorldList ].
		extraWorldsToDraw do: [ :world | world doOneCycle ].

		(self currentWorld isNotNil and: [
			 (extraWorldsToDraw includes: self currentWorld) not ]) ifTrue: [
			self currentWorld doOneCycle ] ] in WorldMorph class>>doOneCycle
FullBlockClosure(BlockClosure)>>ensure:
WorldState class>>doDrawCycleWith:
 - - - - - - - - - - - - - - -
			- - - - - - - - - - - - - - - - - -
WorldMorph class>>doOneCycle
MorphicRenderLoop>>doOneCycle
MorphicRenderLoop>>doOneCycleWhile:
[ MorphicRenderLoop new doOneCycleWhile: [ true ] ] in MorphicUIManager>>spawnNewProcess
[self value.
			"IMPORTANT: Do not step over next line of code. See method comments for details"
			Processor terminateRealActive] in FullBlockClosure(BlockClosure)>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
Instance of RSBox did not understand #+
23 October 2023 11:57:55.26105 pm

VM: Mac OS - arm64 - 1000 - CoInterpreter VMMaker-tonel.1 uuid: 902dd483-c0c4-0d00-86f2-0f880df24b96 Oct 23 2023
StackToRegisterMappingCogit VMMaker-tonel.1 uuid: 902dd483-c0c4-0d00-86f2-0f880df24b96 Oct 23 2023
v10.0.8 - Commit: b323c5fb - Date: 2023-10-20 16:02:07 -0400

Image: Pharo11.0.0 [Build information: Pharo-11.0.0+build.710.sha.ea28d8552cac85a7ce1e9c34ab1e7bd45f7b9910 (64 Bit)]

RSBox(Object)>>doesNotUnderstand: #+
	Receiver: a RSBox
	Arguments and temporary variables: 
		aMessage: 	+ 'Alice'
		exception: 	Instance of RSBox did not understand #+
		resumeValue: 	nil
	Receiver's instance variables: 
		announcer: 	nil
		properties: 	nil
		paint: 	Color blue
		path: 	(-25.0@ -25.0) corner: (25.0@25.0)
		border: 	nil
		parent: 	nil
		isFixed: 	false
		encompassingRectangle: 	nil
		model: 	nil
		baseRectangle: 	(-25.0@ -25.0) corner: (25.0@25.0)
		matrix: 	x: 0.0 y: 0.0 sx: 1.0 sy: 1.0 shx: 0.0 shy: 0.0
		connectedLines: 	nil
		shouldUpdateLines: 	true
		cornerRadius: 	nil


VisualizerMain>>createSampleGraph
	Receiver: a VisualizerMain
	Arguments and temporary variables: 
		view: 	a RSCanvas
		alice: 	nil
		bob: 	nil
	Receiver's instance variables: 
a VisualizerMain

UndefinedObject>>DoIt
	Receiver: nil
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
nil

OCReceiverDoItSemanticScope(OCDoItSemanticScope)>>evaluateDoIt:
	Receiver: an OCReceiverDoItSemanticScope
	Arguments and temporary variables: 
		doItMethod: 	UndefinedObject>>#DoIt
	Receiver's instance variables: 
		outerScope: 	nil
		targetReceiver: 	nil


OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
		doItMethod: 	UndefinedObject>>#DoIt
	Receiver's instance variables: 
		ast: 	DoIt

	^ VisualizerMain new createSampleGraph open
		source: 	a ReadStream
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil


[
		self announcer announce: (SpCodeWillBeEvaluatedAnnouncement newContent: aString).
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionModel doItReceiver.
		result := receiver class compiler
			source: aString;
			context: self interactionModel doItContext;
			receiver: self interactionModel doItReceiver;
			requestor: self interactionModel;
			environment: self environment;
			failBlock:  [ 
				self announcer announce: (SpCodeEvaluationFailedAnnouncement newContent: aString).
				^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		self announcer announce: (SpCodeEvaluationSucceedAnnouncement newContent: aString).
		result ] in SpCodePresenter>>evaluate:onCompileError:onError:
	Receiver: a SpCodePresenter
	Arguments and temporary variables: 
		aString: 	'(VisualizerMain new createSampleGraph) open.
'
		compileErrorBlock: 	[ ^ self ]
		errorBlock: 	[ :e | e pass ]
		receiver: 	nil
		result: 	nil
		oldBindings: 	a Dictionary()
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicCodeAdapter)
		announcer: 	an Announcer
		owner: 	a StPlaygroundPagePresenter
		adapter: 	a SpMorphicCodeAdapter
		needRebuild: 	true
		eventHandler: 	a SpEventHandler
		application: 	nil
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ a KMCategory ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Code' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpAbstractWidgetLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		borderWidth: 	an ObservableValueHolder[ nil ]
		borderColor: 	an ObservableValueHolder[ nil ]
		dragEnabled: 	an ObservableValueHolder[ false ]
		dropEnabled: 	an ObservableValueHolder[ false ]
		color: 	an ObservableValueHolder[ nil ]
		help: 	an ObservableValueHolder[ nil ]
		enabled: 	an ObservableValueHolder[ true ]
		wantsDrop: 	an ObservableValueHolder[ [ :transfer | self dropEnabled ] ]
		acceptDrop: 	an ObservableValueHolder[ [ :transfer | ] ]
		deferredActions: 	nil
		hasUnacceptedEdits: 	an ObservableValueHolder[ false ]
		selection: 	an ObservableValueHolder[ (1 to: 45) ]
		wantsVisualFeedback: 	an ObservableValueHolder[ true ]
		askBeforeDiscardingEdits: 	an ObservableValueHolder[ true ]
		text: 	an ObservableValueHolder[ '(VisualizerMain new createSampleGraph) ope[..]
		actionToPerform: 	an ObservableValueHolder[ [ :txt |  ] ]
		readSelection: 	an ObservableValueHolder[ [ selection ] ]
		placeholder: 	an ObservableValueHolder[ '' ]
		contextMenu: 	an ObservableValueHolder[ [ (self menuActionsFor: text) asMenu[..]
		scrollValue: 	an ObservableValueHolder[ (0@0) ]
		editionContextMenu: 	an ObservableValueHolder[ true ]
		editable: 	an ObservableValueHolder[ true ]
		wrapWord: 	an ObservableValueHolder[ true ]
		undoRedoHistory: 	true
		wrapScrollBars: 	true
		propagateNaturalHeight: 	false
		propagateNaturalWidth: 	false
		scrollBarStyles: 	#()
		syntaxHighlight: 	an ObservableValueHolder[ true ]
		smartCharacters: 	an ObservableValueHolder[ true ]
		lineNumbers: 	an ObservableValueHolder[ true ]
		interactionModel: 	an ObservableValueHolder[ a StPlaygroundInteractionModel ]
		overrideContextMenu: 	true
		submitBlock: 	nil
		resetBlock: 	nil
		environment: 	nil
		systemNavigation: 	nil
		syntaxHighlightTheme: 	an ObservableValueHolder[ nil ]


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
		self announcer announce: (SpCodeWillBeEvaluatedAnnouncement newContent: aString).
[..]
	Arguments and temporary variables: 
		exception: 	Error
		handlerAction: 	[ :e |
		self announcer announce: (SpCodeEvaluationFailedAnn[..]
	Receiver's instance variables: 
		outerContext: 	SpCodePresenter>>evaluate:onCompileError:onError:
		compiledBlock: 	a CompiledBlock: [
		self announcer announce: (SpCodeWillBeE[..]
		numArgs: 	0
		receiver: 	a SpCodePresenter


SpCodePresenter>>evaluate:onCompileError:onError:
	Receiver: a SpCodePresenter
	Arguments and temporary variables: 
		receiver: 	nil
		result: 	nil
		oldBindings: 	a Dictionary()
		aString: 	'(VisualizerMain new createSampleGraph) open.
'
		compileErrorBlock: 	[ ^ self ]
		errorBlock: 	[ :e | e pass ]
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicCodeAdapter)
		announcer: 	an Announcer
		owner: 	a StPlaygroundPagePresenter
		adapter: 	a SpMorphicCodeAdapter
		needRebuild: 	true
		eventHandler: 	a SpEventHandler
		application: 	nil
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ a KMCategory ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Code' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpAbstractWidgetLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		borderWidth: 	an ObservableValueHolder[ nil ]
		borderColor: 	an ObservableValueHolder[ nil ]
		dragEnabled: 	an ObservableValueHolder[ false ]
		dropEnabled: 	an ObservableValueHolder[ false ]
		color: 	an ObservableValueHolder[ nil ]
		help: 	an ObservableValueHolder[ nil ]
		enabled: 	an ObservableValueHolder[ true ]
		wantsDrop: 	an ObservableValueHolder[ [ :transfer | self dropEnabled ] ]
		acceptDrop: 	an ObservableValueHolder[ [ :transfer | ] ]
		deferredActions: 	nil
		hasUnacceptedEdits: 	an ObservableValueHolder[ false ]
		selection: 	an ObservableValueHolder[ (1 to: 45) ]
		wantsVisualFeedback: 	an ObservableValueHolder[ true ]
		askBeforeDiscardingEdits: 	an ObservableValueHolder[ true ]
		text: 	an ObservableValueHolder[ '(VisualizerMain new createSampleGraph) ope[..]
		actionToPerform: 	an ObservableValueHolder[ [ :txt |  ] ]
		readSelection: 	an ObservableValueHolder[ [ selection ] ]
		placeholder: 	an ObservableValueHolder[ '' ]
		contextMenu: 	an ObservableValueHolder[ [ (self menuActionsFor: text) asMenu[..]
		scrollValue: 	an ObservableValueHolder[ (0@0) ]
		editionContextMenu: 	an ObservableValueHolder[ true ]
		editable: 	an ObservableValueHolder[ true ]
		wrapWord: 	an ObservableValueHolder[ true ]
		undoRedoHistory: 	true
		wrapScrollBars: 	true
		propagateNaturalHeight: 	false
		propagateNaturalWidth: 	false
		scrollBarStyles: 	#()
		syntaxHighlight: 	an ObservableValueHolder[ true ]
		smartCharacters: 	an ObservableValueHolder[ true ]
		lineNumbers: 	an ObservableValueHolder[ true ]
		interactionModel: 	an ObservableValueHolder[ a StPlaygroundInteractionModel ]
		overrideContextMenu: 	true
		submitBlock: 	nil
		resetBlock: 	nil
		environment: 	nil
		systemNavigation: 	nil
		syntaxHighlightTheme: 	an ObservableValueHolder[ nil ]


StPlaygroundPagePresenter>>doEvaluateAndGo
	Receiver: a StPlaygroundPagePresenter
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicBoxAdapter)
		announcer: 	an Announcer
		owner: 	a SpMillerColumnPresenter
		adapter: 	a SpMorphicBoxAdapter
		needRebuild: 	true
		eventHandler: 	nil
		application: 	a StPharoApplication
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ nil ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Untitled window' ]
		additionalSubpresentersMap: 	a Dictionary()
		layout: 	an ObservableValueHolder[ a SpBoxLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		text: 	a SpCodePresenter
		toolbar: 	a SpToolbarPresenter
		statusbar: 	a SpPresenter
		lineLabel: 	a SpLabelPresenter
		toggleLineNumberButton: 	a SpToggleButtonPresenter
		page: 	a StPlaygroundPage
		activationBlock: 	[ :selection |
		self changeSelection: selection from: new[..]


StPlaygroundPagePresenter>>doEvaluateAllAndGo
	Receiver: a StPlaygroundPagePresenter
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicBoxAdapter)
		announcer: 	an Announcer
		owner: 	a SpMillerColumnPresenter
		adapter: 	a SpMorphicBoxAdapter
		needRebuild: 	true
		eventHandler: 	nil
		application: 	a StPharoApplication
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ nil ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Untitled window' ]
		additionalSubpresentersMap: 	a Dictionary()
		layout: 	an ObservableValueHolder[ a SpBoxLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		text: 	a SpCodePresenter
		toolbar: 	a SpToolbarPresenter
		statusbar: 	a SpPresenter
		lineLabel: 	a SpLabelPresenter
		toggleLineNumberButton: 	a SpToggleButtonPresenter
		page: 	a StPlaygroundPage
		activationBlock: 	[ :selection |
		self changeSelection: selection from: new[..]


StPlaygroundDoItCommand>>execute
	Receiver: a StPlaygroundDoItCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		context: 	a StPlaygroundPagePresenter
		basicName: 	'Do it'
		basicDescription: 	'Do it all and inspect.'


SpCommand(CmCommandDecorator)>>execute
	Receiver: a SpCommand(Do it)
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a StPlaygroundDoItCommand
		iconProvider: 	a StPharoApplication
		iconName: 	#glamorousGo
		shortcutKey: 	nil
		displayStrategy: 	a CmUIDisableWhenCantBeRun
		positionStrategy: 	a CmUILeftPositionStrategy
		buildPresenterBlock: 	[ :specCommand | 
			aButtonClass new
				label: specC[..]
		presenter: 	a SpToolbarButtonPresenter


[ specCommand execute ] in [ :specCommand | 
			aButtonClass new
				label: specCommand name;
				help: specCommand description;
				in: [ :button | 
					specCommand hasIcon
						ifTrue: [ button icon: specCommand icon ] ];
				action: [ specCommand execute ];
				yourself ] in SpCommand>>configureAsButtonOfClass:
	Receiver: a SpCommand(Do it)
	Arguments and temporary variables: 
		aButtonClass: 	nil
		specCommand: 	a SpCommand(Do it)
	Receiver's instance variables: 
		decoratedCommand: 	a StPlaygroundDoItCommand
		iconProvider: 	a StPharoApplication
		iconName: 	#glamorousGo
		shortcutKey: 	nil
		displayStrategy: 	a CmUIDisableWhenCantBeRun
		positionStrategy: 	a CmUILeftPositionStrategy
		buildPresenterBlock: 	[ :specCommand | 
			aButtonClass new
				label: specC[..]
		presenter: 	a SpToolbarButtonPresenter


FullBlockClosure(BlockClosure)>>cull:
	Receiver: [ specCommand execute ]
	Arguments and temporary variables: 
		anArg: 	a SpToolbarButtonPresenter
	Receiver's instance variables: 
		outerContext: 	[ :specCommand | 
			aButtonClass new
				label: specCommand [..]
		compiledBlock: 	a CompiledBlock: [ specCommand execute ]
		numArgs: 	0
		receiver: 	a SpCommand(Do it)


SpMorphicToolbarButtonAdapter>>execute
	Receiver: a SpMorphicToolbarButtonAdapter
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpToolbarButtonMorph(449631488))
		announcer: 	nil
		model: 	a SpToolbarButtonPresenter
		widget: 	a SpToolbarButtonMorph(449631488)
		selector: 	nil
		owner: 	a SpToolbarButtonPresenter
		unsubscribed: 	false


SpToolbarButtonMorph(PluggableButtonMorph)>>performAction:
	Receiver: a SpToolbarButtonMorph(449631488)
	Arguments and temporary variables: 
		event: 	[(18.0@20.0) mouseUp 340110 nil]
	Receiver's instance variables: 
		bounds: 	(0.0@5.0) corner: (45.0@39.0)
		owner: 	a Morph(1035472128)
		submorphs: 	an Array(an AlignmentMorph(149947904))
		fullBounds: 	nil
		color: 	(Color r: 0.9012707722385142 g: 0.9012707722385142 b: 0.901270772238[..]
		extension: 	a MorphExtension (703115520) [balloonText]  [other:  (presenter [..]
		borderWidth: 	0
		borderColor: 	#simple
		model: 	a SpMorphicToolbarButtonAdapter
		label: 	'Do it'
		icon: 	Form(13x13x32)
		getIconSelector: 	#icon
		getStateSelector: 	#state
		actionSelector: 	#execute
		font: 	a LogicalFont
 familyName: 'Source Sans Pro'
 emphasis: nil
 pointSiz[..]
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	nil
		getFontSelector: 	nil
		labelMorph: 	a LabelMorph(104243968)'Do it'
		iconMorph: 	an ImageMorph(734040320)
		iconPosition: 	#top
		lastState: 	false
		badgeFont: 	nil
		badgeSelector: 	#badge


[:m |
		(m containsPoint: evt cursorPoint) ifTrue: [m enabled ifTrue: [ m performAction: evt ]]] in SpToolbarButtonMorph(PluggableButtonMorph)>>mouseUp:
	Receiver: a SpToolbarButtonMorph(449631488)
	Arguments and temporary variables: 
		evt: 	[(18.0@20.0) mouseUp 340110 nil]
		all: 	an Array(a SpToolbarButtonMorph(449631488) a SpToolbarButtonMorph(7977[..]
		m: 	a SpToolbarButtonMorph(449631488)
	Receiver's instance variables: 
		bounds: 	(0.0@5.0) corner: (45.0@39.0)
		owner: 	a Morph(1035472128)
		submorphs: 	an Array(an AlignmentMorph(149947904))
		fullBounds: 	nil
		color: 	(Color r: 0.9012707722385142 g: 0.9012707722385142 b: 0.901270772238[..]
		extension: 	a MorphExtension (703115520) [balloonText]  [other:  (presenter [..]
		borderWidth: 	0
		borderColor: 	#simple
		model: 	a SpMorphicToolbarButtonAdapter
		label: 	'Do it'
		icon: 	Form(13x13x32)
		getIconSelector: 	#icon
		getStateSelector: 	#state
		actionSelector: 	#execute
		font: 	a LogicalFont
 familyName: 'Source Sans Pro'
 emphasis: nil
 pointSiz[..]
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	nil
		getFontSelector: 	nil
		labelMorph: 	a LabelMorph(104243968)'Do it'
		iconMorph: 	an ImageMorph(734040320)
		iconPosition: 	#top
		lastState: 	false
		badgeFont: 	nil
		badgeSelector: 	#badge


Array(SequenceableCollection)>>do:
	Receiver: an Array(a SpToolbarButtonMorph(449631488) a SpToolbarButtonMorph(797724672) a SpToolb[..]
	Arguments and temporary variables: 
		aBlock: 	[:m |
		(m containsPoint: evt cursorPoint) ifTrue: [m enabled ifTru[..]
		index: 	1
	Receiver's instance variables: 
an Array(a SpToolbarButtonMorph(449631488) a SpToolbarButtonMorph(797724672) a SpToolb[..]

SpToolbarButtonMorph(PluggableButtonMorph)>>mouseUp:
	Receiver: a SpToolbarButtonMorph(449631488)
	Arguments and temporary variables: 
		evt: 	[(18.0@20.0) mouseUp 340110 nil]
		all: 	an Array(a SpToolbarButtonMorph(449631488) a SpToolbarButtonMorph(7977[..]
	Receiver's instance variables: 
		bounds: 	(0.0@5.0) corner: (45.0@39.0)
		owner: 	a Morph(1035472128)
		submorphs: 	an Array(an AlignmentMorph(149947904))
		fullBounds: 	nil
		color: 	(Color r: 0.9012707722385142 g: 0.9012707722385142 b: 0.901270772238[..]
		extension: 	a MorphExtension (703115520) [balloonText]  [other:  (presenter [..]
		borderWidth: 	0
		borderColor: 	#simple
		model: 	a SpMorphicToolbarButtonAdapter
		label: 	'Do it'
		icon: 	Form(13x13x32)
		getIconSelector: 	#icon
		getStateSelector: 	#state
		actionSelector: 	#execute
		font: 	a LogicalFont
 familyName: 'Source Sans Pro'
 emphasis: nil
 pointSiz[..]
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	nil
		getFontSelector: 	nil
		labelMorph: 	a LabelMorph(104243968)'Do it'
		iconMorph: 	an ImageMorph(734040320)
		iconPosition: 	#top
		lastState: 	false
		badgeFont: 	nil
		badgeSelector: 	#badge


SpToolbarButtonMorph(Morph)>>handleMouseUp:
	Receiver: a SpToolbarButtonMorph(449631488)
	Arguments and temporary variables: 
		anEvent: 	[(18.0@20.0) mouseUp 340110 nil]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(0.0@5.0) corner: (45.0@39.0)
		owner: 	a Morph(1035472128)
		submorphs: 	an Array(an AlignmentMorph(149947904))
		fullBounds: 	nil
		color: 	(Color r: 0.9012707722385142 g: 0.9012707722385142 b: 0.901270772238[..]
		extension: 	a MorphExtension (703115520) [balloonText]  [other:  (presenter [..]
		borderWidth: 	0
		borderColor: 	#simple
		model: 	a SpMorphicToolbarButtonAdapter
		label: 	'Do it'
		icon: 	Form(13x13x32)
		getIconSelector: 	#icon
		getStateSelector: 	#state
		actionSelector: 	#execute
		font: 	a LogicalFont
 familyName: 'Source Sans Pro'
 emphasis: nil
 pointSiz[..]
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	nil
		getFontSelector: 	nil
		labelMorph: 	a LabelMorph(104243968)'Do it'
		iconMorph: 	an ImageMorph(734040320)
		iconPosition: 	#top
		lastState: 	false
		badgeFont: 	nil
		badgeSelector: 	#badge


MouseButtonEvent>>sentTo:
	Receiver: [(18.0@20.0) mouseUp 340110 nil]
	Arguments and temporary variables: 
		anObject: 	a SpToolbarButtonMorph(449631488)
	Receiver's instance variables: 
		timeStamp: 	340110
		source: 	a HandMorph(337424384)
		windowIndex: 	nil
		type: 	#mouseUp
		buttons: 	0
		position: 	(18.0@20.0)
		handler: 	nil
		wasHandled: 	true
		whichButton: 	4


SpToolbarButtonMorph(Morph)>>handleEvent:
	Receiver: a SpToolbarButtonMorph(449631488)
	Arguments and temporary variables: 
		anEvent: 	[(18.0@20.0) mouseUp 340110 nil]
	Receiver's instance variables: 
		bounds: 	(0.0@5.0) corner: (45.0@39.0)
		owner: 	a Morph(1035472128)
		submorphs: 	an Array(an AlignmentMorph(149947904))
		fullBounds: 	nil
		color: 	(Color r: 0.9012707722385142 g: 0.9012707722385142 b: 0.901270772238[..]
		extension: 	a MorphExtension (703115520) [balloonText]  [other:  (presenter [..]
		borderWidth: 	0
		borderColor: 	#simple
		model: 	a SpMorphicToolbarButtonAdapter
		label: 	'Do it'
		icon: 	Form(13x13x32)
		getIconSelector: 	#icon
		getStateSelector: 	#state
		actionSelector: 	#execute
		font: 	a LogicalFont
 familyName: 'Source Sans Pro'
 emphasis: nil
 pointSiz[..]
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	nil
		getFontSelector: 	nil
		labelMorph: 	a LabelMorph(104243968)'Do it'
		iconMorph: 	an ImageMorph(734040320)
		iconPosition: 	#top
		lastState: 	false
		badgeFont: 	nil
		badgeSelector: 	#badge


SpToolbarButtonMorph(Morph)>>handleFocusEvent:
	Receiver: a SpToolbarButtonMorph(449631488)
	Arguments and temporary variables: 
		anEvent: 	[(18.0@20.0) mouseUp 340110 nil]
	Receiver's instance variables: 
		bounds: 	(0.0@5.0) corner: (45.0@39.0)
		owner: 	a Morph(1035472128)
		submorphs: 	an Array(an AlignmentMorph(149947904))
		fullBounds: 	nil
		color: 	(Color r: 0.9012707722385142 g: 0.9012707722385142 b: 0.901270772238[..]
		extension: 	a MorphExtension (703115520) [balloonText]  [other:  (presenter [..]
		borderWidth: 	0
		borderColor: 	#simple
		model: 	a SpMorphicToolbarButtonAdapter
		label: 	'Do it'
		icon: 	Form(13x13x32)
		getIconSelector: 	#icon
		getStateSelector: 	#state
		actionSelector: 	#execute
		font: 	a LogicalFont
 familyName: 'Source Sans Pro'
 emphasis: nil
 pointSiz[..]
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	nil
		getFontSelector: 	nil
		labelMorph: 	a LabelMorph(104243968)'Do it'
		iconMorph: 	an ImageMorph(734040320)
		iconPosition: 	#top
		lastState: 	false
		badgeFont: 	nil
		badgeSelector: 	#badge


[
		result := focusHolder handleFocusEvent: transformedEvent.
	] in HandMorph>>sendFocusEvent:to:clear:
	Receiver: a HandMorph(337424384)
	Arguments and temporary variables: 
		anEvent: 	[(537@323) mouseUp 340110 nil]
		focusHolder: 	a SpToolbarButtonMorph(449631488)
		aBlock: 	[self mouseFocus: nil]
		w: 	a WorldMorph(341720576) [world]
		transformedEvent: 	[(18.0@20.0) mouseUp 340110 nil]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(537@323.0) corner: (553@339.0)
		owner: 	a WorldMorph(341720576) [world]
		submorphs: 	#()
		fullBounds: 	(537@323.0) corner: (553@339.0)
		color: 	Color blue
		extension: 	a MorphExtension (370611968)
		mouseFocus: 	nil
		keyboardFocus: 	a RubEditingArea(80907264)
		eventListeners: 	nil
		mouseListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(537@323) mouseUp 340110 nil]
		targetOffset: 	(18.0@16.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 0 0 0 0 0 nil nil)
		captureBlock: 	nil
		recentModifiers: 	0
		pendingEventQueue: 	WaitfreeQueue with 0 items
		supressNextKeyPress: 	false


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
		result := focusHolder handleFocusEvent: transformedEvent.
	]
	Arguments and temporary variables: 
		exception: 	Error
		handlerAction: 	[ :ex |
			ActiveWorld := priorWorld.
			ex pass ]
	Receiver's instance variables: 
		outerContext: 	HandMorph>>sendFocusEvent:to:clear:
		compiledBlock: 	a CompiledBlock: [
		result := focusHolder handleFocusEvent:[..]
		numArgs: 	0
		receiver: 	a HandMorph(337424384)


WorldMorph>>becomeActiveDuring:
	Receiver: a WorldMorph(341720576) [world]
	Arguments and temporary variables: 
		aBlock: 	[
		result := focusHolder handleFocusEvent: transformedEvent.
	]
		priorWorld: 	a WorldMorph(341720576) [world]
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1728@1051)
		owner: 	nil
		submorphs: 	an Array(a MenubarMorph(112886016) a TaskbarMorph(279458560) a S[..]
		fullBounds: 	(0@0) corner: (1728@1051)
		color: 	(Color r: 0.9403714565004888 g: 0.9403714565004888 b: 0.940371456500[..]
		extension: 	a MorphExtension (1012946432) [other:  (dragEnabled -> true) (dr[..]
		borderWidth: 	0
		borderColor: 	(Color r: 0.8611925708699902 g: 1.0 b: 0.7223851417399805 alph[..]
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil


HandMorph>>sendFocusEvent:to:clear:
	Receiver: a HandMorph(337424384)
	Arguments and temporary variables: 
		result: 	nil
		anEvent: 	[(537@323) mouseUp 340110 nil]
		focusHolder: 	a SpToolbarButtonMorph(449631488)
		aBlock: 	[self mouseFocus: nil]
		w: 	a WorldMorph(341720576) [world]
		transformedEvent: 	[(18.0@20.0) mouseUp 340110 nil]
	Receiver's instance variables: 
		bounds: 	(537@323.0) corner: (553@339.0)
		owner: 	a WorldMorph(341720576) [world]
		submorphs: 	#()
		fullBounds: 	(537@323.0) corner: (553@339.0)
		color: 	Color blue
		extension: 	a MorphExtension (370611968)
		mouseFocus: 	nil
		keyboardFocus: 	a RubEditingArea(80907264)
		eventListeners: 	nil
		mouseListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(537@323) mouseUp 340110 nil]
		targetOffset: 	(18.0@16.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 0 0 0 0 0 nil nil)
		captureBlock: 	nil
		recentModifiers: 	0
		pendingEventQueue: 	WaitfreeQueue with 0 items
		supressNextKeyPress: 	false


HandMorph>>sendEvent:focus:clear:
	Receiver: a HandMorph(337424384)
	Arguments and temporary variables: 
		anEvent: 	[(537@323) mouseUp 340110 nil]
		focusHolder: 	a SpToolbarButtonMorph(449631488)
		aBlock: 	[self mouseFocus: nil]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(537@323.0) corner: (553@339.0)
		owner: 	a WorldMorph(341720576) [world]
		submorphs: 	#()
		fullBounds: 	(537@323.0) corner: (553@339.0)
		color: 	Color blue
		extension: 	a MorphExtension (370611968)
		mouseFocus: 	nil
		keyboardFocus: 	a RubEditingArea(80907264)
		eventListeners: 	nil
		mouseListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(537@323) mouseUp 340110 nil]
		targetOffset: 	(18.0@16.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 0 0 0 0 0 nil nil)
		captureBlock: 	nil
		recentModifiers: 	0
		pendingEventQueue: 	WaitfreeQueue with 0 items
		supressNextKeyPress: 	false


HandMorph>>sendMouseEvent:
	Receiver: a HandMorph(337424384)
	Arguments and temporary variables: 
		anEvent: 	[(537@323) mouseUp 340110 nil]
	Receiver's instance variables: 
		bounds: 	(537@323.0) corner: (553@339.0)
		owner: 	a WorldMorph(341720576) [world]
		submorphs: 	#()
		fullBounds: 	(537@323.0) corner: (553@339.0)
		color: 	Color blue
		extension: 	a MorphExtension (370611968)
		mouseFocus: 	nil
		keyboardFocus: 	a RubEditingArea(80907264)
		eventListeners: 	nil
		mouseListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(537@323) mouseUp 340110 nil]
		targetOffset: 	(18.0@16.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 0 0 0 0 0 nil nil)
		captureBlock: 	nil
		recentModifiers: 	0
		pendingEventQueue: 	WaitfreeQueue with 0 items
		supressNextKeyPress: 	false


HandMorph>>handleEvent:
	Receiver: a HandMorph(337424384)
	Arguments and temporary variables: 
		anEvent: 	[(537@323) mouseUp 340110 nil]
		evt: 	[(537@323) mouseUp 340110 nil]
	Receiver's instance variables: 
		bounds: 	(537@323.0) corner: (553@339.0)
		owner: 	a WorldMorph(341720576) [world]
		submorphs: 	#()
		fullBounds: 	(537@323.0) corner: (553@339.0)
		color: 	Color blue
		extension: 	a MorphExtension (370611968)
		mouseFocus: 	nil
		keyboardFocus: 	a RubEditingArea(80907264)
		eventListeners: 	nil
		mouseListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(537@323) mouseUp 340110 nil]
		targetOffset: 	(18.0@16.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 0 0 0 0 0 nil nil)
		captureBlock: 	nil
		recentModifiers: 	0
		pendingEventQueue: 	WaitfreeQueue with 0 items
		supressNextKeyPress: 	false


[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil ]) ifTrue: [
			morphicWorld activeHand handleEvent: anEvent
		]
	] in OSWindowMorphicEventHandler>>dispatchMorphicEvent:
	Receiver: an OSWindowMorphicEventHandler
	Arguments and temporary variables: 
		anEvent: 	[(537@323) mouseUp 340110 nil]
	Receiver's instance variables: 
		morphicWorld: 	a WorldMorph(341720576) [world]


WorldState>>runStepMethodsIn:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(341720576) [world]
		queue: 	WaitfreeQueue with 0 items
		nextInQueue: 	[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNo[..]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(337424384))
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap()
		lastStepTime: 	326872
		lastStepMessage: 	nil
		alarms: 	a Heap(MorphicAlarm(#hideShow -> a RubCursor(618416640)))
		lastAlarmTime: 	340098
		activeHand: 	a HandMorph(337424384)
		currentCursor: 	((CursorWithMask
	extent: (16@16)
	depth: 1
	fromArray: #(
	[..]
		worldRenderer: 	an OSWorldRenderer
		realWindowExtent: 	(1728@1051)
		deferredUIMessages: 	WaitfreeQueue with 0 items


WorldMorph>>runStepMethods
	Receiver: a WorldMorph(341720576) [world]
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1728@1051)
		owner: 	nil
		submorphs: 	an Array(a MenubarMorph(112886016) a TaskbarMorph(279458560) a S[..]
		fullBounds: 	(0@0) corner: (1728@1051)
		color: 	(Color r: 0.9403714565004888 g: 0.9403714565004888 b: 0.940371456500[..]
		extension: 	a MorphExtension (1012946432) [other:  (dragEnabled -> true) (dr[..]
		borderWidth: 	0
		borderColor: 	(Color r: 0.8611925708699902 g: 1.0 b: 0.7223851417399805 alph[..]
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil


WorldState>>doOneCycleFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(341720576) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(337424384))
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap()
		lastStepTime: 	326872
		lastStepMessage: 	nil
		alarms: 	a Heap(MorphicAlarm(#hideShow -> a RubCursor(618416640)))
		lastAlarmTime: 	340098
		activeHand: 	a HandMorph(337424384)
		currentCursor: 	((CursorWithMask
	extent: (16@16)
	depth: 1
	fromArray: #(
	[..]
		worldRenderer: 	an OSWorldRenderer
		realWindowExtent: 	(1728@1051)
		deferredUIMessages: 	WaitfreeQueue with 0 items


WorldMorph>>doOneCycleNow
	Receiver: a WorldMorph(341720576) [world]
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1728@1051)
		owner: 	nil
		submorphs: 	an Array(a MenubarMorph(112886016) a TaskbarMorph(279458560) a S[..]
		fullBounds: 	(0@0) corner: (1728@1051)
		color: 	(Color r: 0.9403714565004888 g: 0.9403714565004888 b: 0.940371456500[..]
		extension: 	a MorphExtension (1012946432) [other:  (dragEnabled -> true) (dr[..]
		borderWidth: 	0
		borderColor: 	(Color r: 0.8611925708699902 g: 1.0 b: 0.7223851417399805 alph[..]
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil


WorldMorph>>doOneCycle
	Receiver: a WorldMorph(341720576) [world]
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1728@1051)
		owner: 	nil
		submorphs: 	an Array(a MenubarMorph(112886016) a TaskbarMorph(279458560) a S[..]
		fullBounds: 	(0@0) corner: (1728@1051)
		color: 	(Color r: 0.9403714565004888 g: 0.9403714565004888 b: 0.940371456500[..]
		extension: 	a MorphExtension (1012946432) [other:  (dragEnabled -> true) (dr[..]
		borderWidth: 	0
		borderColor: 	(Color r: 0.8611925708699902 g: 1.0 b: 0.7223851417399805 alph[..]
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil


[
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMutex critical: [
			                     self extraWorldList ].
		extraWorldsToDraw do: [ :world | world doOneCycle ].

		(self currentWorld isNotNil and: [
			 (extraWorldsToDraw includes: self currentWorld) not ]) ifTrue: [
			self currentWorld doOneCycle ] ] in WorldMorph class>>doOneCycle
	Receiver: WorldMorph
	Arguments and temporary variables: 
		extraWorldsToDraw: 	#()
	Receiver's instance variables: 
		superclass: 	PasteUpMorph
		methodDict: 	a MethodDictionary(#acceptDroppingMorph:event:->WorldMorph>>#ac[..]
		format: 	65547
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		commentSourcePointer: 	nil
		subclasses: 	{AthensWorldMorph. OSWindowWorldMorph}
		name: 	#WorldMorph
		classPool: 	a Dictionary(#AllowDropFiles->nil #CursorOwnerWorld->a WorldMorp[..]
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Morphic-Core-Worlds'
		announcer: 	nil
		displayScaleFactor: 	1


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMutex critical: [
			  [..]
	Arguments and temporary variables: 
		aBlock: 	[
		self doInterCycleWait
	]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	WorldMorph class>>doOneCycle
		compiledBlock: 	a CompiledBlock: [
		| extraWorldsToDraw |
		extraWorldsToDr[..]
		numArgs: 	0
		receiver: 	WorldMorph


WorldState class>>doDrawCycleWith:
	Receiver: WorldState
	Arguments and temporary variables: 
		aBlock: 	[
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMute[..]
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary(#activeHand->WorldState>>#activeHand #active[..]
		format: 	65548
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		commentSourcePointer: 	nil
		subclasses: 	{AthensWorldState}
		name: 	#WorldState
		classPool: 	a Dictionary(#CanSurrenderToOS->nil #DebugShowDamage->false #Des[..]
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Morphic-Core-Worlds'



--- The full stack ---
RSBox(Object)>>doesNotUnderstand: #+
VisualizerMain>>createSampleGraph
UndefinedObject>>DoIt
OCReceiverDoItSemanticScope(OCDoItSemanticScope)>>evaluateDoIt:
OpalCompiler>>evaluate
[
		self announcer announce: (SpCodeWillBeEvaluatedAnnouncement newContent: aString).
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionModel doItReceiver.
		result := receiver class compiler
			source: aString;
			context: self interactionModel doItContext;
			receiver: self interactionModel doItReceiver;
			requestor: self interactionModel;
			environment: self environment;
			failBlock:  [ 
				self announcer announce: (SpCodeEvaluationFailedAnnouncement newContent: aString).
				^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		self announcer announce: (SpCodeEvaluationSucceedAnnouncement newContent: aString).
		result ] in SpCodePresenter>>evaluate:onCompileError:onError:
FullBlockClosure(BlockClosure)>>on:do:
SpCodePresenter>>evaluate:onCompileError:onError:
StPlaygroundPagePresenter>>doEvaluateAndGo
StPlaygroundPagePresenter>>doEvaluateAllAndGo
StPlaygroundDoItCommand>>execute
SpCommand(CmCommandDecorator)>>execute
[ specCommand execute ] in [ :specCommand | 
			aButtonClass new
				label: specCommand name;
				help: specCommand description;
				in: [ :button | 
					specCommand hasIcon
						ifTrue: [ button icon: specCommand icon ] ];
				action: [ specCommand execute ];
				yourself ] in SpCommand>>configureAsButtonOfClass:
FullBlockClosure(BlockClosure)>>cull:
SpMorphicToolbarButtonAdapter>>execute
SpToolbarButtonMorph(PluggableButtonMorph)>>performAction:
[:m |
		(m containsPoint: evt cursorPoint) ifTrue: [m enabled ifTrue: [ m performAction: evt ]]] in SpToolbarButtonMorph(PluggableButtonMorph)>>mouseUp:
Array(SequenceableCollection)>>do:
SpToolbarButtonMorph(PluggableButtonMorph)>>mouseUp:
SpToolbarButtonMorph(Morph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
SpToolbarButtonMorph(Morph)>>handleEvent:
SpToolbarButtonMorph(Morph)>>handleFocusEvent:
[
		result := focusHolder handleFocusEvent: transformedEvent.
	] in HandMorph>>sendFocusEvent:to:clear:
FullBlockClosure(BlockClosure)>>on:do:
WorldMorph>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil ]) ifTrue: [
			morphicWorld activeHand handleEvent: anEvent
		]
	] in OSWindowMorphicEventHandler>>dispatchMorphicEvent:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycleNow
WorldMorph>>doOneCycle
[
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMutex critical: [
			                     self extraWorldList ].
		extraWorldsToDraw do: [ :world | world doOneCycle ].

		(self currentWorld isNotNil and: [
			 (extraWorldsToDraw includes: self currentWorld) not ]) ifTrue: [
			self currentWorld doOneCycle ] ] in WorldMorph class>>doOneCycle
FullBlockClosure(BlockClosure)>>ensure:
WorldState class>>doDrawCycleWith:
 - - - - - - - - - - - - - - -
			- - - - - - - - - - - - - - - - - -
WorldMorph class>>doOneCycle
MorphicRenderLoop>>doOneCycle
MorphicRenderLoop>>doOneCycleWhile:
[ MorphicRenderLoop new doOneCycleWhile: [ true ] ] in MorphicUIManager>>spawnNewProcess
[self value.
			"IMPORTANT: Do not step over next line of code. See method comments for details"
			Processor terminateRealActive] in FullBlockClosure(BlockClosure)>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
Instance of RSBox did not understand #+
23 October 2023 11:57:55.291185 pm

VM: Mac OS - arm64 - 1000 - CoInterpreter VMMaker-tonel.1 uuid: 902dd483-c0c4-0d00-86f2-0f880df24b96 Oct 23 2023
StackToRegisterMappingCogit VMMaker-tonel.1 uuid: 902dd483-c0c4-0d00-86f2-0f880df24b96 Oct 23 2023
v10.0.8 - Commit: b323c5fb - Date: 2023-10-20 16:02:07 -0400

Image: Pharo11.0.0 [Build information: Pharo-11.0.0+build.710.sha.ea28d8552cac85a7ce1e9c34ab1e7bd45f7b9910 (64 Bit)]

RSBox(Object)>>doesNotUnderstand: #+
	Receiver: a RSBox
	Arguments and temporary variables: 
		aMessage: 	+ 'Alice'
		exception: 	Instance of RSBox did not understand #+
		resumeValue: 	nil
	Receiver's instance variables: 
		announcer: 	nil
		properties: 	nil
		paint: 	Color blue
		path: 	(-25.0@ -25.0) corner: (25.0@25.0)
		border: 	nil
		parent: 	nil
		isFixed: 	false
		encompassingRectangle: 	nil
		model: 	nil
		baseRectangle: 	(-25.0@ -25.0) corner: (25.0@25.0)
		matrix: 	x: 0.0 y: 0.0 sx: 1.0 sy: 1.0 shx: 0.0 shy: 0.0
		connectedLines: 	nil
		shouldUpdateLines: 	true
		cornerRadius: 	nil


VisualizerMain>>createSampleGraph
	Receiver: a VisualizerMain
	Arguments and temporary variables: 
		view: 	a RSCanvas
		alice: 	nil
		bob: 	nil
	Receiver's instance variables: 
a VisualizerMain

UndefinedObject>>DoIt
	Receiver: nil
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
nil

OCReceiverDoItSemanticScope(OCDoItSemanticScope)>>evaluateDoIt:
	Receiver: an OCReceiverDoItSemanticScope
	Arguments and temporary variables: 
		doItMethod: 	UndefinedObject>>#DoIt
	Receiver's instance variables: 
		outerScope: 	nil
		targetReceiver: 	nil


OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
		doItMethod: 	UndefinedObject>>#DoIt
	Receiver's instance variables: 
		ast: 	DoIt

	^ VisualizerMain new createSampleGraph open
		source: 	a ReadStream
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil


[
		self announcer announce: (SpCodeWillBeEvaluatedAnnouncement newContent: aString).
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionModel doItReceiver.
		result := receiver class compiler
			source: aString;
			context: self interactionModel doItContext;
			receiver: self interactionModel doItReceiver;
			requestor: self interactionModel;
			environment: self environment;
			failBlock:  [ 
				self announcer announce: (SpCodeEvaluationFailedAnnouncement newContent: aString).
				^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		self announcer announce: (SpCodeEvaluationSucceedAnnouncement newContent: aString).
		result ] in SpCodePresenter>>evaluate:onCompileError:onError:
	Receiver: a SpCodePresenter
	Arguments and temporary variables: 
		aString: 	'(VisualizerMain new createSampleGraph) open.
'
		compileErrorBlock: 	[ ^ self ]
		errorBlock: 	[ :e | e pass ]
		receiver: 	nil
		result: 	nil
		oldBindings: 	a Dictionary()
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicCodeAdapter)
		announcer: 	an Announcer
		owner: 	a StPlaygroundPagePresenter
		adapter: 	a SpMorphicCodeAdapter
		needRebuild: 	true
		eventHandler: 	a SpEventHandler
		application: 	nil
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ a KMCategory ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Code' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpAbstractWidgetLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		borderWidth: 	an ObservableValueHolder[ nil ]
		borderColor: 	an ObservableValueHolder[ nil ]
		dragEnabled: 	an ObservableValueHolder[ false ]
		dropEnabled: 	an ObservableValueHolder[ false ]
		color: 	an ObservableValueHolder[ nil ]
		help: 	an ObservableValueHolder[ nil ]
		enabled: 	an ObservableValueHolder[ true ]
		wantsDrop: 	an ObservableValueHolder[ [ :transfer | self dropEnabled ] ]
		acceptDrop: 	an ObservableValueHolder[ [ :transfer | ] ]
		deferredActions: 	nil
		hasUnacceptedEdits: 	an ObservableValueHolder[ false ]
		selection: 	an ObservableValueHolder[ (1 to: 45) ]
		wantsVisualFeedback: 	an ObservableValueHolder[ true ]
		askBeforeDiscardingEdits: 	an ObservableValueHolder[ true ]
		text: 	an ObservableValueHolder[ '(VisualizerMain new createSampleGraph) ope[..]
		actionToPerform: 	an ObservableValueHolder[ [ :txt |  ] ]
		readSelection: 	an ObservableValueHolder[ [ selection ] ]
		placeholder: 	an ObservableValueHolder[ '' ]
		contextMenu: 	an ObservableValueHolder[ [ (self menuActionsFor: text) asMenu[..]
		scrollValue: 	an ObservableValueHolder[ (0@0) ]
		editionContextMenu: 	an ObservableValueHolder[ true ]
		editable: 	an ObservableValueHolder[ true ]
		wrapWord: 	an ObservableValueHolder[ true ]
		undoRedoHistory: 	true
		wrapScrollBars: 	true
		propagateNaturalHeight: 	false
		propagateNaturalWidth: 	false
		scrollBarStyles: 	#()
		syntaxHighlight: 	an ObservableValueHolder[ true ]
		smartCharacters: 	an ObservableValueHolder[ true ]
		lineNumbers: 	an ObservableValueHolder[ true ]
		interactionModel: 	an ObservableValueHolder[ a StPlaygroundInteractionModel ]
		overrideContextMenu: 	true
		submitBlock: 	nil
		resetBlock: 	nil
		environment: 	nil
		systemNavigation: 	nil
		syntaxHighlightTheme: 	an ObservableValueHolder[ nil ]


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
		self announcer announce: (SpCodeWillBeEvaluatedAnnouncement newContent: aString).
[..]
	Arguments and temporary variables: 
		exception: 	Error
		handlerAction: 	[ :e |
		self announcer announce: (SpCodeEvaluationFailedAnn[..]
	Receiver's instance variables: 
		outerContext: 	SpCodePresenter>>evaluate:onCompileError:onError:
		compiledBlock: 	a CompiledBlock: [
		self announcer announce: (SpCodeWillBeE[..]
		numArgs: 	0
		receiver: 	a SpCodePresenter


SpCodePresenter>>evaluate:onCompileError:onError:
	Receiver: a SpCodePresenter
	Arguments and temporary variables: 
		receiver: 	nil
		result: 	nil
		oldBindings: 	a Dictionary()
		aString: 	'(VisualizerMain new createSampleGraph) open.
'
		compileErrorBlock: 	[ ^ self ]
		errorBlock: 	[ :e | e pass ]
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicCodeAdapter)
		announcer: 	an Announcer
		owner: 	a StPlaygroundPagePresenter
		adapter: 	a SpMorphicCodeAdapter
		needRebuild: 	true
		eventHandler: 	a SpEventHandler
		application: 	nil
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ a KMCategory ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Code' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpAbstractWidgetLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		borderWidth: 	an ObservableValueHolder[ nil ]
		borderColor: 	an ObservableValueHolder[ nil ]
		dragEnabled: 	an ObservableValueHolder[ false ]
		dropEnabled: 	an ObservableValueHolder[ false ]
		color: 	an ObservableValueHolder[ nil ]
		help: 	an ObservableValueHolder[ nil ]
		enabled: 	an ObservableValueHolder[ true ]
		wantsDrop: 	an ObservableValueHolder[ [ :transfer | self dropEnabled ] ]
		acceptDrop: 	an ObservableValueHolder[ [ :transfer | ] ]
		deferredActions: 	nil
		hasUnacceptedEdits: 	an ObservableValueHolder[ false ]
		selection: 	an ObservableValueHolder[ (1 to: 45) ]
		wantsVisualFeedback: 	an ObservableValueHolder[ true ]
		askBeforeDiscardingEdits: 	an ObservableValueHolder[ true ]
		text: 	an ObservableValueHolder[ '(VisualizerMain new createSampleGraph) ope[..]
		actionToPerform: 	an ObservableValueHolder[ [ :txt |  ] ]
		readSelection: 	an ObservableValueHolder[ [ selection ] ]
		placeholder: 	an ObservableValueHolder[ '' ]
		contextMenu: 	an ObservableValueHolder[ [ (self menuActionsFor: text) asMenu[..]
		scrollValue: 	an ObservableValueHolder[ (0@0) ]
		editionContextMenu: 	an ObservableValueHolder[ true ]
		editable: 	an ObservableValueHolder[ true ]
		wrapWord: 	an ObservableValueHolder[ true ]
		undoRedoHistory: 	true
		wrapScrollBars: 	true
		propagateNaturalHeight: 	false
		propagateNaturalWidth: 	false
		scrollBarStyles: 	#()
		syntaxHighlight: 	an ObservableValueHolder[ true ]
		smartCharacters: 	an ObservableValueHolder[ true ]
		lineNumbers: 	an ObservableValueHolder[ true ]
		interactionModel: 	an ObservableValueHolder[ a StPlaygroundInteractionModel ]
		overrideContextMenu: 	true
		submitBlock: 	nil
		resetBlock: 	nil
		environment: 	nil
		systemNavigation: 	nil
		syntaxHighlightTheme: 	an ObservableValueHolder[ nil ]


StPlaygroundPagePresenter>>doEvaluateAndGo
	Receiver: a StPlaygroundPagePresenter
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicBoxAdapter)
		announcer: 	an Announcer
		owner: 	a SpMillerColumnPresenter
		adapter: 	a SpMorphicBoxAdapter
		needRebuild: 	true
		eventHandler: 	nil
		application: 	a StPharoApplication
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ nil ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Untitled window' ]
		additionalSubpresentersMap: 	a Dictionary()
		layout: 	an ObservableValueHolder[ a SpBoxLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		text: 	a SpCodePresenter
		toolbar: 	a SpToolbarPresenter
		statusbar: 	a SpPresenter
		lineLabel: 	a SpLabelPresenter
		toggleLineNumberButton: 	a SpToggleButtonPresenter
		page: 	a StPlaygroundPage
		activationBlock: 	[ :selection |
		self changeSelection: selection from: new[..]


StPlaygroundPagePresenter>>doEvaluateAllAndGo
	Receiver: a StPlaygroundPagePresenter
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicBoxAdapter)
		announcer: 	an Announcer
		owner: 	a SpMillerColumnPresenter
		adapter: 	a SpMorphicBoxAdapter
		needRebuild: 	true
		eventHandler: 	nil
		application: 	a StPharoApplication
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ nil ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Untitled window' ]
		additionalSubpresentersMap: 	a Dictionary()
		layout: 	an ObservableValueHolder[ a SpBoxLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		text: 	a SpCodePresenter
		toolbar: 	a SpToolbarPresenter
		statusbar: 	a SpPresenter
		lineLabel: 	a SpLabelPresenter
		toggleLineNumberButton: 	a SpToggleButtonPresenter
		page: 	a StPlaygroundPage
		activationBlock: 	[ :selection |
		self changeSelection: selection from: new[..]


StPlaygroundDoItCommand>>execute
	Receiver: a StPlaygroundDoItCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		context: 	a StPlaygroundPagePresenter
		basicName: 	'Do it'
		basicDescription: 	'Do it all and inspect.'


SpCommand(CmCommandDecorator)>>execute
	Receiver: a SpCommand(Do it)
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a StPlaygroundDoItCommand
		iconProvider: 	a StPharoApplication
		iconName: 	#glamorousGo
		shortcutKey: 	nil
		displayStrategy: 	a CmUIDisableWhenCantBeRun
		positionStrategy: 	a CmUILeftPositionStrategy
		buildPresenterBlock: 	[ :specCommand | 
			aButtonClass new
				label: specC[..]
		presenter: 	a SpToolbarButtonPresenter


[ specCommand execute ] in [ :specCommand | 
			aButtonClass new
				label: specCommand name;
				help: specCommand description;
				in: [ :button | 
					specCommand hasIcon
						ifTrue: [ button icon: specCommand icon ] ];
				action: [ specCommand execute ];
				yourself ] in SpCommand>>configureAsButtonOfClass:
	Receiver: a SpCommand(Do it)
	Arguments and temporary variables: 
		aButtonClass: 	nil
		specCommand: 	a SpCommand(Do it)
	Receiver's instance variables: 
		decoratedCommand: 	a StPlaygroundDoItCommand
		iconProvider: 	a StPharoApplication
		iconName: 	#glamorousGo
		shortcutKey: 	nil
		displayStrategy: 	a CmUIDisableWhenCantBeRun
		positionStrategy: 	a CmUILeftPositionStrategy
		buildPresenterBlock: 	[ :specCommand | 
			aButtonClass new
				label: specC[..]
		presenter: 	a SpToolbarButtonPresenter


FullBlockClosure(BlockClosure)>>cull:
	Receiver: [ specCommand execute ]
	Arguments and temporary variables: 
		anArg: 	a SpToolbarButtonPresenter
	Receiver's instance variables: 
		outerContext: 	[ :specCommand | 
			aButtonClass new
				label: specCommand [..]
		compiledBlock: 	a CompiledBlock: [ specCommand execute ]
		numArgs: 	0
		receiver: 	a SpCommand(Do it)


SpMorphicToolbarButtonAdapter>>execute
	Receiver: a SpMorphicToolbarButtonAdapter
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpToolbarButtonMorph(449631488))
		announcer: 	nil
		model: 	a SpToolbarButtonPresenter
		widget: 	a SpToolbarButtonMorph(449631488)
		selector: 	nil
		owner: 	a SpToolbarButtonPresenter
		unsubscribed: 	false


SpToolbarButtonMorph(PluggableButtonMorph)>>performAction:
	Receiver: a SpToolbarButtonMorph(449631488)
	Arguments and temporary variables: 
		event: 	[(18.0@20.0) mouseUp 340110 nil]
	Receiver's instance variables: 
		bounds: 	(0.0@5.0) corner: (45.0@39.0)
		owner: 	a Morph(1035472128)
		submorphs: 	an Array(an AlignmentMorph(149947904))
		fullBounds: 	nil
		color: 	(Color r: 0.9012707722385142 g: 0.9012707722385142 b: 0.901270772238[..]
		extension: 	a MorphExtension (703115520) [balloonText]  [other:  (presenter [..]
		borderWidth: 	0
		borderColor: 	#simple
		model: 	a SpMorphicToolbarButtonAdapter
		label: 	'Do it'
		icon: 	Form(13x13x32)
		getIconSelector: 	#icon
		getStateSelector: 	#state
		actionSelector: 	#execute
		font: 	a LogicalFont
 familyName: 'Source Sans Pro'
 emphasis: nil
 pointSiz[..]
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	nil
		getFontSelector: 	nil
		labelMorph: 	a LabelMorph(104243968)'Do it'
		iconMorph: 	an ImageMorph(734040320)
		iconPosition: 	#top
		lastState: 	false
		badgeFont: 	nil
		badgeSelector: 	#badge


[:m |
		(m containsPoint: evt cursorPoint) ifTrue: [m enabled ifTrue: [ m performAction: evt ]]] in SpToolbarButtonMorph(PluggableButtonMorph)>>mouseUp:
	Receiver: a SpToolbarButtonMorph(449631488)
	Arguments and temporary variables: 
		evt: 	[(18.0@20.0) mouseUp 340110 nil]
		all: 	an Array(a SpToolbarButtonMorph(449631488) a SpToolbarButtonMorph(7977[..]
		m: 	a SpToolbarButtonMorph(449631488)
	Receiver's instance variables: 
		bounds: 	(0.0@5.0) corner: (45.0@39.0)
		owner: 	a Morph(1035472128)
		submorphs: 	an Array(an AlignmentMorph(149947904))
		fullBounds: 	nil
		color: 	(Color r: 0.9012707722385142 g: 0.9012707722385142 b: 0.901270772238[..]
		extension: 	a MorphExtension (703115520) [balloonText]  [other:  (presenter [..]
		borderWidth: 	0
		borderColor: 	#simple
		model: 	a SpMorphicToolbarButtonAdapter
		label: 	'Do it'
		icon: 	Form(13x13x32)
		getIconSelector: 	#icon
		getStateSelector: 	#state
		actionSelector: 	#execute
		font: 	a LogicalFont
 familyName: 'Source Sans Pro'
 emphasis: nil
 pointSiz[..]
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	nil
		getFontSelector: 	nil
		labelMorph: 	a LabelMorph(104243968)'Do it'
		iconMorph: 	an ImageMorph(734040320)
		iconPosition: 	#top
		lastState: 	false
		badgeFont: 	nil
		badgeSelector: 	#badge


Array(SequenceableCollection)>>do:
	Receiver: an Array(a SpToolbarButtonMorph(449631488) a SpToolbarButtonMorph(797724672) a SpToolb[..]
	Arguments and temporary variables: 
		aBlock: 	[:m |
		(m containsPoint: evt cursorPoint) ifTrue: [m enabled ifTru[..]
		index: 	1
	Receiver's instance variables: 
an Array(a SpToolbarButtonMorph(449631488) a SpToolbarButtonMorph(797724672) a SpToolb[..]

SpToolbarButtonMorph(PluggableButtonMorph)>>mouseUp:
	Receiver: a SpToolbarButtonMorph(449631488)
	Arguments and temporary variables: 
		evt: 	[(18.0@20.0) mouseUp 340110 nil]
		all: 	an Array(a SpToolbarButtonMorph(449631488) a SpToolbarButtonMorph(7977[..]
	Receiver's instance variables: 
		bounds: 	(0.0@5.0) corner: (45.0@39.0)
		owner: 	a Morph(1035472128)
		submorphs: 	an Array(an AlignmentMorph(149947904))
		fullBounds: 	nil
		color: 	(Color r: 0.9012707722385142 g: 0.9012707722385142 b: 0.901270772238[..]
		extension: 	a MorphExtension (703115520) [balloonText]  [other:  (presenter [..]
		borderWidth: 	0
		borderColor: 	#simple
		model: 	a SpMorphicToolbarButtonAdapter
		label: 	'Do it'
		icon: 	Form(13x13x32)
		getIconSelector: 	#icon
		getStateSelector: 	#state
		actionSelector: 	#execute
		font: 	a LogicalFont
 familyName: 'Source Sans Pro'
 emphasis: nil
 pointSiz[..]
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	nil
		getFontSelector: 	nil
		labelMorph: 	a LabelMorph(104243968)'Do it'
		iconMorph: 	an ImageMorph(734040320)
		iconPosition: 	#top
		lastState: 	false
		badgeFont: 	nil
		badgeSelector: 	#badge


SpToolbarButtonMorph(Morph)>>handleMouseUp:
	Receiver: a SpToolbarButtonMorph(449631488)
	Arguments and temporary variables: 
		anEvent: 	[(18.0@20.0) mouseUp 340110 nil]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(0.0@5.0) corner: (45.0@39.0)
		owner: 	a Morph(1035472128)
		submorphs: 	an Array(an AlignmentMorph(149947904))
		fullBounds: 	nil
		color: 	(Color r: 0.9012707722385142 g: 0.9012707722385142 b: 0.901270772238[..]
		extension: 	a MorphExtension (703115520) [balloonText]  [other:  (presenter [..]
		borderWidth: 	0
		borderColor: 	#simple
		model: 	a SpMorphicToolbarButtonAdapter
		label: 	'Do it'
		icon: 	Form(13x13x32)
		getIconSelector: 	#icon
		getStateSelector: 	#state
		actionSelector: 	#execute
		font: 	a LogicalFont
 familyName: 'Source Sans Pro'
 emphasis: nil
 pointSiz[..]
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	nil
		getFontSelector: 	nil
		labelMorph: 	a LabelMorph(104243968)'Do it'
		iconMorph: 	an ImageMorph(734040320)
		iconPosition: 	#top
		lastState: 	false
		badgeFont: 	nil
		badgeSelector: 	#badge


MouseButtonEvent>>sentTo:
	Receiver: [(18.0@20.0) mouseUp 340110 nil]
	Arguments and temporary variables: 
		anObject: 	a SpToolbarButtonMorph(449631488)
	Receiver's instance variables: 
		timeStamp: 	340110
		source: 	a HandMorph(337424384)
		windowIndex: 	nil
		type: 	#mouseUp
		buttons: 	0
		position: 	(18.0@20.0)
		handler: 	nil
		wasHandled: 	true
		whichButton: 	4


SpToolbarButtonMorph(Morph)>>handleEvent:
	Receiver: a SpToolbarButtonMorph(449631488)
	Arguments and temporary variables: 
		anEvent: 	[(18.0@20.0) mouseUp 340110 nil]
	Receiver's instance variables: 
		bounds: 	(0.0@5.0) corner: (45.0@39.0)
		owner: 	a Morph(1035472128)
		submorphs: 	an Array(an AlignmentMorph(149947904))
		fullBounds: 	nil
		color: 	(Color r: 0.9012707722385142 g: 0.9012707722385142 b: 0.901270772238[..]
		extension: 	a MorphExtension (703115520) [balloonText]  [other:  (presenter [..]
		borderWidth: 	0
		borderColor: 	#simple
		model: 	a SpMorphicToolbarButtonAdapter
		label: 	'Do it'
		icon: 	Form(13x13x32)
		getIconSelector: 	#icon
		getStateSelector: 	#state
		actionSelector: 	#execute
		font: 	a LogicalFont
 familyName: 'Source Sans Pro'
 emphasis: nil
 pointSiz[..]
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	nil
		getFontSelector: 	nil
		labelMorph: 	a LabelMorph(104243968)'Do it'
		iconMorph: 	an ImageMorph(734040320)
		iconPosition: 	#top
		lastState: 	false
		badgeFont: 	nil
		badgeSelector: 	#badge


SpToolbarButtonMorph(Morph)>>handleFocusEvent:
	Receiver: a SpToolbarButtonMorph(449631488)
	Arguments and temporary variables: 
		anEvent: 	[(18.0@20.0) mouseUp 340110 nil]
	Receiver's instance variables: 
		bounds: 	(0.0@5.0) corner: (45.0@39.0)
		owner: 	a Morph(1035472128)
		submorphs: 	an Array(an AlignmentMorph(149947904))
		fullBounds: 	nil
		color: 	(Color r: 0.9012707722385142 g: 0.9012707722385142 b: 0.901270772238[..]
		extension: 	a MorphExtension (703115520) [balloonText]  [other:  (presenter [..]
		borderWidth: 	0
		borderColor: 	#simple
		model: 	a SpMorphicToolbarButtonAdapter
		label: 	'Do it'
		icon: 	Form(13x13x32)
		getIconSelector: 	#icon
		getStateSelector: 	#state
		actionSelector: 	#execute
		font: 	a LogicalFont
 familyName: 'Source Sans Pro'
 emphasis: nil
 pointSiz[..]
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	nil
		getFontSelector: 	nil
		labelMorph: 	a LabelMorph(104243968)'Do it'
		iconMorph: 	an ImageMorph(734040320)
		iconPosition: 	#top
		lastState: 	false
		badgeFont: 	nil
		badgeSelector: 	#badge


[
		result := focusHolder handleFocusEvent: transformedEvent.
	] in HandMorph>>sendFocusEvent:to:clear:
	Receiver: a HandMorph(337424384)
	Arguments and temporary variables: 
		anEvent: 	[(537@323) mouseUp 340110 nil]
		focusHolder: 	a SpToolbarButtonMorph(449631488)
		aBlock: 	[self mouseFocus: nil]
		w: 	a WorldMorph(341720576) [world]
		transformedEvent: 	[(18.0@20.0) mouseUp 340110 nil]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(537@323.0) corner: (553@339.0)
		owner: 	a WorldMorph(341720576) [world]
		submorphs: 	#()
		fullBounds: 	(537@323.0) corner: (553@339.0)
		color: 	Color blue
		extension: 	a MorphExtension (370611968)
		mouseFocus: 	nil
		keyboardFocus: 	a RubEditingArea(80907264)
		eventListeners: 	nil
		mouseListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(537@323) mouseUp 340110 nil]
		targetOffset: 	(18.0@16.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 0 0 0 0 0 nil nil)
		captureBlock: 	nil
		recentModifiers: 	0
		pendingEventQueue: 	WaitfreeQueue with 0 items
		supressNextKeyPress: 	false


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
		result := focusHolder handleFocusEvent: transformedEvent.
	]
	Arguments and temporary variables: 
		exception: 	Error
		handlerAction: 	[ :ex |
			ActiveWorld := priorWorld.
			ex pass ]
	Receiver's instance variables: 
		outerContext: 	HandMorph>>sendFocusEvent:to:clear:
		compiledBlock: 	a CompiledBlock: [
		result := focusHolder handleFocusEvent:[..]
		numArgs: 	0
		receiver: 	a HandMorph(337424384)


WorldMorph>>becomeActiveDuring:
	Receiver: a WorldMorph(341720576) [world]
	Arguments and temporary variables: 
		aBlock: 	[
		result := focusHolder handleFocusEvent: transformedEvent.
	]
		priorWorld: 	a WorldMorph(341720576) [world]
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1728@1051)
		owner: 	nil
		submorphs: 	an Array(a MenubarMorph(112886016) a TaskbarMorph(279458560) a S[..]
		fullBounds: 	(0@0) corner: (1728@1051)
		color: 	(Color r: 0.9403714565004888 g: 0.9403714565004888 b: 0.940371456500[..]
		extension: 	a MorphExtension (1012946432) [other:  (dragEnabled -> true) (dr[..]
		borderWidth: 	0
		borderColor: 	(Color r: 0.8611925708699902 g: 1.0 b: 0.7223851417399805 alph[..]
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil


HandMorph>>sendFocusEvent:to:clear:
	Receiver: a HandMorph(337424384)
	Arguments and temporary variables: 
		result: 	nil
		anEvent: 	[(537@323) mouseUp 340110 nil]
		focusHolder: 	a SpToolbarButtonMorph(449631488)
		aBlock: 	[self mouseFocus: nil]
		w: 	a WorldMorph(341720576) [world]
		transformedEvent: 	[(18.0@20.0) mouseUp 340110 nil]
	Receiver's instance variables: 
		bounds: 	(537@323.0) corner: (553@339.0)
		owner: 	a WorldMorph(341720576) [world]
		submorphs: 	#()
		fullBounds: 	(537@323.0) corner: (553@339.0)
		color: 	Color blue
		extension: 	a MorphExtension (370611968)
		mouseFocus: 	nil
		keyboardFocus: 	a RubEditingArea(80907264)
		eventListeners: 	nil
		mouseListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(537@323) mouseUp 340110 nil]
		targetOffset: 	(18.0@16.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 0 0 0 0 0 nil nil)
		captureBlock: 	nil
		recentModifiers: 	0
		pendingEventQueue: 	WaitfreeQueue with 0 items
		supressNextKeyPress: 	false


HandMorph>>sendEvent:focus:clear:
	Receiver: a HandMorph(337424384)
	Arguments and temporary variables: 
		anEvent: 	[(537@323) mouseUp 340110 nil]
		focusHolder: 	a SpToolbarButtonMorph(449631488)
		aBlock: 	[self mouseFocus: nil]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(537@323.0) corner: (553@339.0)
		owner: 	a WorldMorph(341720576) [world]
		submorphs: 	#()
		fullBounds: 	(537@323.0) corner: (553@339.0)
		color: 	Color blue
		extension: 	a MorphExtension (370611968)
		mouseFocus: 	nil
		keyboardFocus: 	a RubEditingArea(80907264)
		eventListeners: 	nil
		mouseListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(537@323) mouseUp 340110 nil]
		targetOffset: 	(18.0@16.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 0 0 0 0 0 nil nil)
		captureBlock: 	nil
		recentModifiers: 	0
		pendingEventQueue: 	WaitfreeQueue with 0 items
		supressNextKeyPress: 	false


HandMorph>>sendMouseEvent:
	Receiver: a HandMorph(337424384)
	Arguments and temporary variables: 
		anEvent: 	[(537@323) mouseUp 340110 nil]
	Receiver's instance variables: 
		bounds: 	(537@323.0) corner: (553@339.0)
		owner: 	a WorldMorph(341720576) [world]
		submorphs: 	#()
		fullBounds: 	(537@323.0) corner: (553@339.0)
		color: 	Color blue
		extension: 	a MorphExtension (370611968)
		mouseFocus: 	nil
		keyboardFocus: 	a RubEditingArea(80907264)
		eventListeners: 	nil
		mouseListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(537@323) mouseUp 340110 nil]
		targetOffset: 	(18.0@16.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 0 0 0 0 0 nil nil)
		captureBlock: 	nil
		recentModifiers: 	0
		pendingEventQueue: 	WaitfreeQueue with 0 items
		supressNextKeyPress: 	false


HandMorph>>handleEvent:
	Receiver: a HandMorph(337424384)
	Arguments and temporary variables: 
		anEvent: 	[(537@323) mouseUp 340110 nil]
		evt: 	[(537@323) mouseUp 340110 nil]
	Receiver's instance variables: 
		bounds: 	(537@323.0) corner: (553@339.0)
		owner: 	a WorldMorph(341720576) [world]
		submorphs: 	#()
		fullBounds: 	(537@323.0) corner: (553@339.0)
		color: 	Color blue
		extension: 	a MorphExtension (370611968)
		mouseFocus: 	nil
		keyboardFocus: 	a RubEditingArea(80907264)
		eventListeners: 	nil
		mouseListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(537@323) mouseUp 340110 nil]
		targetOffset: 	(18.0@16.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 0 0 0 0 0 nil nil)
		captureBlock: 	nil
		recentModifiers: 	0
		pendingEventQueue: 	WaitfreeQueue with 0 items
		supressNextKeyPress: 	false


[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil ]) ifTrue: [
			morphicWorld activeHand handleEvent: anEvent
		]
	] in OSWindowMorphicEventHandler>>dispatchMorphicEvent:
	Receiver: an OSWindowMorphicEventHandler
	Arguments and temporary variables: 
		anEvent: 	[(537@323) mouseUp 340110 nil]
	Receiver's instance variables: 
		morphicWorld: 	a WorldMorph(341720576) [world]


WorldState>>runStepMethodsIn:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(341720576) [world]
		queue: 	WaitfreeQueue with 0 items
		nextInQueue: 	[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNo[..]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(337424384))
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap()
		lastStepTime: 	326872
		lastStepMessage: 	nil
		alarms: 	a Heap(MorphicAlarm(#hideShow -> a RubCursor(618416640)))
		lastAlarmTime: 	340098
		activeHand: 	a HandMorph(337424384)
		currentCursor: 	((CursorWithMask
	extent: (16@16)
	depth: 1
	fromArray: #(
	[..]
		worldRenderer: 	an OSWorldRenderer
		realWindowExtent: 	(1728@1051)
		deferredUIMessages: 	WaitfreeQueue with 0 items


WorldMorph>>runStepMethods
	Receiver: a WorldMorph(341720576) [world]
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1728@1051)
		owner: 	nil
		submorphs: 	an Array(a MenubarMorph(112886016) a TaskbarMorph(279458560) a S[..]
		fullBounds: 	(0@0) corner: (1728@1051)
		color: 	(Color r: 0.9403714565004888 g: 0.9403714565004888 b: 0.940371456500[..]
		extension: 	a MorphExtension (1012946432) [other:  (dragEnabled -> true) (dr[..]
		borderWidth: 	0
		borderColor: 	(Color r: 0.8611925708699902 g: 1.0 b: 0.7223851417399805 alph[..]
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil


WorldState>>doOneCycleFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(341720576) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(337424384))
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap()
		lastStepTime: 	326872
		lastStepMessage: 	nil
		alarms: 	a Heap(MorphicAlarm(#hideShow -> a RubCursor(618416640)))
		lastAlarmTime: 	340098
		activeHand: 	a HandMorph(337424384)
		currentCursor: 	((CursorWithMask
	extent: (16@16)
	depth: 1
	fromArray: #(
	[..]
		worldRenderer: 	an OSWorldRenderer
		realWindowExtent: 	(1728@1051)
		deferredUIMessages: 	WaitfreeQueue with 0 items


WorldMorph>>doOneCycleNow
	Receiver: a WorldMorph(341720576) [world]
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1728@1051)
		owner: 	nil
		submorphs: 	an Array(a MenubarMorph(112886016) a TaskbarMorph(279458560) a S[..]
		fullBounds: 	(0@0) corner: (1728@1051)
		color: 	(Color r: 0.9403714565004888 g: 0.9403714565004888 b: 0.940371456500[..]
		extension: 	a MorphExtension (1012946432) [other:  (dragEnabled -> true) (dr[..]
		borderWidth: 	0
		borderColor: 	(Color r: 0.8611925708699902 g: 1.0 b: 0.7223851417399805 alph[..]
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil


WorldMorph>>doOneCycle
	Receiver: a WorldMorph(341720576) [world]
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1728@1051)
		owner: 	nil
		submorphs: 	an Array(a MenubarMorph(112886016) a TaskbarMorph(279458560) a S[..]
		fullBounds: 	(0@0) corner: (1728@1051)
		color: 	(Color r: 0.9403714565004888 g: 0.9403714565004888 b: 0.940371456500[..]
		extension: 	a MorphExtension (1012946432) [other:  (dragEnabled -> true) (dr[..]
		borderWidth: 	0
		borderColor: 	(Color r: 0.8611925708699902 g: 1.0 b: 0.7223851417399805 alph[..]
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil


[
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMutex critical: [
			                     self extraWorldList ].
		extraWorldsToDraw do: [ :world | world doOneCycle ].

		(self currentWorld isNotNil and: [
			 (extraWorldsToDraw includes: self currentWorld) not ]) ifTrue: [
			self currentWorld doOneCycle ] ] in WorldMorph class>>doOneCycle
	Receiver: WorldMorph
	Arguments and temporary variables: 
		extraWorldsToDraw: 	#()
	Receiver's instance variables: 
		superclass: 	PasteUpMorph
		methodDict: 	a MethodDictionary(#acceptDroppingMorph:event:->WorldMorph>>#ac[..]
		format: 	65547
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		commentSourcePointer: 	nil
		subclasses: 	{AthensWorldMorph. OSWindowWorldMorph}
		name: 	#WorldMorph
		classPool: 	a Dictionary(#AllowDropFiles->nil #CursorOwnerWorld->a WorldMorp[..]
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Morphic-Core-Worlds'
		announcer: 	nil
		displayScaleFactor: 	1


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMutex critical: [
			  [..]
	Arguments and temporary variables: 
		aBlock: 	[
		self doInterCycleWait
	]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	WorldMorph class>>doOneCycle
		compiledBlock: 	a CompiledBlock: [
		| extraWorldsToDraw |
		extraWorldsToDr[..]
		numArgs: 	0
		receiver: 	WorldMorph


WorldState class>>doDrawCycleWith:
	Receiver: WorldState
	Arguments and temporary variables: 
		aBlock: 	[
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMute[..]
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary(#activeHand->WorldState>>#activeHand #active[..]
		format: 	65548
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		commentSourcePointer: 	nil
		subclasses: 	{AthensWorldState}
		name: 	#WorldState
		classPool: 	a Dictionary(#CanSurrenderToOS->nil #DebugShowDamage->false #Des[..]
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Morphic-Core-Worlds'



--- The full stack ---
RSBox(Object)>>doesNotUnderstand: #+
VisualizerMain>>createSampleGraph
UndefinedObject>>DoIt
OCReceiverDoItSemanticScope(OCDoItSemanticScope)>>evaluateDoIt:
OpalCompiler>>evaluate
[
		self announcer announce: (SpCodeWillBeEvaluatedAnnouncement newContent: aString).
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionModel doItReceiver.
		result := receiver class compiler
			source: aString;
			context: self interactionModel doItContext;
			receiver: self interactionModel doItReceiver;
			requestor: self interactionModel;
			environment: self environment;
			failBlock:  [ 
				self announcer announce: (SpCodeEvaluationFailedAnnouncement newContent: aString).
				^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		self announcer announce: (SpCodeEvaluationSucceedAnnouncement newContent: aString).
		result ] in SpCodePresenter>>evaluate:onCompileError:onError:
FullBlockClosure(BlockClosure)>>on:do:
SpCodePresenter>>evaluate:onCompileError:onError:
StPlaygroundPagePresenter>>doEvaluateAndGo
StPlaygroundPagePresenter>>doEvaluateAllAndGo
StPlaygroundDoItCommand>>execute
SpCommand(CmCommandDecorator)>>execute
[ specCommand execute ] in [ :specCommand | 
			aButtonClass new
				label: specCommand name;
				help: specCommand description;
				in: [ :button | 
					specCommand hasIcon
						ifTrue: [ button icon: specCommand icon ] ];
				action: [ specCommand execute ];
				yourself ] in SpCommand>>configureAsButtonOfClass:
FullBlockClosure(BlockClosure)>>cull:
SpMorphicToolbarButtonAdapter>>execute
SpToolbarButtonMorph(PluggableButtonMorph)>>performAction:
[:m |
		(m containsPoint: evt cursorPoint) ifTrue: [m enabled ifTrue: [ m performAction: evt ]]] in SpToolbarButtonMorph(PluggableButtonMorph)>>mouseUp:
Array(SequenceableCollection)>>do:
SpToolbarButtonMorph(PluggableButtonMorph)>>mouseUp:
SpToolbarButtonMorph(Morph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
SpToolbarButtonMorph(Morph)>>handleEvent:
SpToolbarButtonMorph(Morph)>>handleFocusEvent:
[
		result := focusHolder handleFocusEvent: transformedEvent.
	] in HandMorph>>sendFocusEvent:to:clear:
FullBlockClosure(BlockClosure)>>on:do:
WorldMorph>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil ]) ifTrue: [
			morphicWorld activeHand handleEvent: anEvent
		]
	] in OSWindowMorphicEventHandler>>dispatchMorphicEvent:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycleNow
WorldMorph>>doOneCycle
[
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMutex critical: [
			                     self extraWorldList ].
		extraWorldsToDraw do: [ :world | world doOneCycle ].

		(self currentWorld isNotNil and: [
			 (extraWorldsToDraw includes: self currentWorld) not ]) ifTrue: [
			self currentWorld doOneCycle ] ] in WorldMorph class>>doOneCycle
FullBlockClosure(BlockClosure)>>ensure:
WorldState class>>doDrawCycleWith:
 - - - - - - - - - - - - - - -
			- - - - - - - - - - - - - - - - - -
WorldMorph class>>doOneCycle
MorphicRenderLoop>>doOneCycle
MorphicRenderLoop>>doOneCycleWhile:
[ MorphicRenderLoop new doOneCycleWhile: [ true ] ] in MorphicUIManager>>spawnNewProcess
[self value.
			"IMPORTANT: Do not step over next line of code. See method comments for details"
			Processor terminateRealActive] in FullBlockClosure(BlockClosure)>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
Instance of RSBox did not understand #text:
23 October 2023 11:59:19.066187 pm

VM: Mac OS - arm64 - 1000 - CoInterpreter VMMaker-tonel.1 uuid: 902dd483-c0c4-0d00-86f2-0f880df24b96 Oct 23 2023
StackToRegisterMappingCogit VMMaker-tonel.1 uuid: 902dd483-c0c4-0d00-86f2-0f880df24b96 Oct 23 2023
v10.0.8 - Commit: b323c5fb - Date: 2023-10-20 16:02:07 -0400

Image: Pharo11.0.0 [Build information: Pharo-11.0.0+build.710.sha.ea28d8552cac85a7ce1e9c34ab1e7bd45f7b9910 (64 Bit)]

RSBox(Object)>>doesNotUnderstand: #text:
	Receiver: a RSBox
	Arguments and temporary variables: 
		aMessage: 	text: 'Alice'
		exception: 	Instance of RSBox did not understand #text:
		resumeValue: 	nil
	Receiver's instance variables: 
		announcer: 	nil
		properties: 	nil
		paint: 	Color blue
		path: 	(-25.0@ -25.0) corner: (25.0@25.0)
		border: 	nil
		parent: 	nil
		isFixed: 	false
		encompassingRectangle: 	nil
		model: 	nil
		baseRectangle: 	(-25.0@ -25.0) corner: (25.0@25.0)
		matrix: 	x: 0.0 y: 0.0 sx: 1.0 sy: 1.0 shx: 0.0 shy: 0.0
		connectedLines: 	nil
		shouldUpdateLines: 	true
		cornerRadius: 	nil


VisualizerMain>>createSampleGraph
	Receiver: a VisualizerMain
	Arguments and temporary variables: 
		view: 	a RSCanvas
		alice: 	nil
		bob: 	nil
	Receiver's instance variables: 
a VisualizerMain

UndefinedObject>>DoIt
	Receiver: nil
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
nil

OCReceiverDoItSemanticScope(OCDoItSemanticScope)>>evaluateDoIt:
	Receiver: an OCReceiverDoItSemanticScope
	Arguments and temporary variables: 
		doItMethod: 	UndefinedObject>>#DoIt
	Receiver's instance variables: 
		outerScope: 	nil
		targetReceiver: 	nil


OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
		doItMethod: 	UndefinedObject>>#DoIt
	Receiver's instance variables: 
		ast: 	DoIt

	^ VisualizerMain new createSampleGraph open
		source: 	a ReadStream
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil


[
		self announcer announce: (SpCodeWillBeEvaluatedAnnouncement newContent: aString).
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionModel doItReceiver.
		result := receiver class compiler
			source: aString;
			context: self interactionModel doItContext;
			receiver: self interactionModel doItReceiver;
			requestor: self interactionModel;
			environment: self environment;
			failBlock:  [ 
				self announcer announce: (SpCodeEvaluationFailedAnnouncement newContent: aString).
				^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		self announcer announce: (SpCodeEvaluationSucceedAnnouncement newContent: aString).
		result ] in SpCodePresenter>>evaluate:onCompileError:onError:
	Receiver: a SpCodePresenter
	Arguments and temporary variables: 
		aString: 	'(VisualizerMain new createSampleGraph) open.
'
		compileErrorBlock: 	[ ^ self ]
		errorBlock: 	[ :e | e pass ]
		receiver: 	nil
		result: 	nil
		oldBindings: 	a Dictionary()
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicCodeAdapter)
		announcer: 	an Announcer
		owner: 	a StPlaygroundPagePresenter
		adapter: 	a SpMorphicCodeAdapter
		needRebuild: 	true
		eventHandler: 	a SpEventHandler
		application: 	nil
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ a KMCategory ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Code' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpAbstractWidgetLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		borderWidth: 	an ObservableValueHolder[ nil ]
		borderColor: 	an ObservableValueHolder[ nil ]
		dragEnabled: 	an ObservableValueHolder[ false ]
		dropEnabled: 	an ObservableValueHolder[ false ]
		color: 	an ObservableValueHolder[ nil ]
		help: 	an ObservableValueHolder[ nil ]
		enabled: 	an ObservableValueHolder[ true ]
		wantsDrop: 	an ObservableValueHolder[ [ :transfer | self dropEnabled ] ]
		acceptDrop: 	an ObservableValueHolder[ [ :transfer | ] ]
		deferredActions: 	nil
		hasUnacceptedEdits: 	an ObservableValueHolder[ false ]
		selection: 	an ObservableValueHolder[ (1 to: 45) ]
		wantsVisualFeedback: 	an ObservableValueHolder[ true ]
		askBeforeDiscardingEdits: 	an ObservableValueHolder[ true ]
		text: 	an ObservableValueHolder[ '(VisualizerMain new createSampleGraph) ope[..]
		actionToPerform: 	an ObservableValueHolder[ [ :txt |  ] ]
		readSelection: 	an ObservableValueHolder[ [ selection ] ]
		placeholder: 	an ObservableValueHolder[ '' ]
		contextMenu: 	an ObservableValueHolder[ [ (self menuActionsFor: text) asMenu[..]
		scrollValue: 	an ObservableValueHolder[ (0@0) ]
		editionContextMenu: 	an ObservableValueHolder[ true ]
		editable: 	an ObservableValueHolder[ true ]
		wrapWord: 	an ObservableValueHolder[ true ]
		undoRedoHistory: 	true
		wrapScrollBars: 	true
		propagateNaturalHeight: 	false
		propagateNaturalWidth: 	false
		scrollBarStyles: 	#()
		syntaxHighlight: 	an ObservableValueHolder[ true ]
		smartCharacters: 	an ObservableValueHolder[ true ]
		lineNumbers: 	an ObservableValueHolder[ true ]
		interactionModel: 	an ObservableValueHolder[ a StPlaygroundInteractionModel ]
		overrideContextMenu: 	true
		submitBlock: 	nil
		resetBlock: 	nil
		environment: 	nil
		systemNavigation: 	nil
		syntaxHighlightTheme: 	an ObservableValueHolder[ nil ]


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
		self announcer announce: (SpCodeWillBeEvaluatedAnnouncement newContent: aString).
[..]
	Arguments and temporary variables: 
		exception: 	Error
		handlerAction: 	[ :e |
		self announcer announce: (SpCodeEvaluationFailedAnn[..]
	Receiver's instance variables: 
		outerContext: 	SpCodePresenter>>evaluate:onCompileError:onError:
		compiledBlock: 	a CompiledBlock: [
		self announcer announce: (SpCodeWillBeE[..]
		numArgs: 	0
		receiver: 	a SpCodePresenter


SpCodePresenter>>evaluate:onCompileError:onError:
	Receiver: a SpCodePresenter
	Arguments and temporary variables: 
		receiver: 	nil
		result: 	nil
		oldBindings: 	a Dictionary()
		aString: 	'(VisualizerMain new createSampleGraph) open.
'
		compileErrorBlock: 	[ ^ self ]
		errorBlock: 	[ :e | e pass ]
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicCodeAdapter)
		announcer: 	an Announcer
		owner: 	a StPlaygroundPagePresenter
		adapter: 	a SpMorphicCodeAdapter
		needRebuild: 	true
		eventHandler: 	a SpEventHandler
		application: 	nil
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ a KMCategory ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Code' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpAbstractWidgetLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		borderWidth: 	an ObservableValueHolder[ nil ]
		borderColor: 	an ObservableValueHolder[ nil ]
		dragEnabled: 	an ObservableValueHolder[ false ]
		dropEnabled: 	an ObservableValueHolder[ false ]
		color: 	an ObservableValueHolder[ nil ]
		help: 	an ObservableValueHolder[ nil ]
		enabled: 	an ObservableValueHolder[ true ]
		wantsDrop: 	an ObservableValueHolder[ [ :transfer | self dropEnabled ] ]
		acceptDrop: 	an ObservableValueHolder[ [ :transfer | ] ]
		deferredActions: 	nil
		hasUnacceptedEdits: 	an ObservableValueHolder[ false ]
		selection: 	an ObservableValueHolder[ (1 to: 45) ]
		wantsVisualFeedback: 	an ObservableValueHolder[ true ]
		askBeforeDiscardingEdits: 	an ObservableValueHolder[ true ]
		text: 	an ObservableValueHolder[ '(VisualizerMain new createSampleGraph) ope[..]
		actionToPerform: 	an ObservableValueHolder[ [ :txt |  ] ]
		readSelection: 	an ObservableValueHolder[ [ selection ] ]
		placeholder: 	an ObservableValueHolder[ '' ]
		contextMenu: 	an ObservableValueHolder[ [ (self menuActionsFor: text) asMenu[..]
		scrollValue: 	an ObservableValueHolder[ (0@0) ]
		editionContextMenu: 	an ObservableValueHolder[ true ]
		editable: 	an ObservableValueHolder[ true ]
		wrapWord: 	an ObservableValueHolder[ true ]
		undoRedoHistory: 	true
		wrapScrollBars: 	true
		propagateNaturalHeight: 	false
		propagateNaturalWidth: 	false
		scrollBarStyles: 	#()
		syntaxHighlight: 	an ObservableValueHolder[ true ]
		smartCharacters: 	an ObservableValueHolder[ true ]
		lineNumbers: 	an ObservableValueHolder[ true ]
		interactionModel: 	an ObservableValueHolder[ a StPlaygroundInteractionModel ]
		overrideContextMenu: 	true
		submitBlock: 	nil
		resetBlock: 	nil
		environment: 	nil
		systemNavigation: 	nil
		syntaxHighlightTheme: 	an ObservableValueHolder[ nil ]


StPlaygroundPagePresenter>>doEvaluateAndGo
	Receiver: a StPlaygroundPagePresenter
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicBoxAdapter)
		announcer: 	an Announcer
		owner: 	a SpMillerColumnPresenter
		adapter: 	a SpMorphicBoxAdapter
		needRebuild: 	true
		eventHandler: 	nil
		application: 	a StPharoApplication
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ nil ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Untitled window' ]
		additionalSubpresentersMap: 	a Dictionary()
		layout: 	an ObservableValueHolder[ a SpBoxLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		text: 	a SpCodePresenter
		toolbar: 	a SpToolbarPresenter
		statusbar: 	a SpPresenter
		lineLabel: 	a SpLabelPresenter
		toggleLineNumberButton: 	a SpToggleButtonPresenter
		page: 	a StPlaygroundPage
		activationBlock: 	[ :selection |
		self changeSelection: selection from: new[..]


StPlaygroundPagePresenter>>doEvaluateAllAndGo
	Receiver: a StPlaygroundPagePresenter
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicBoxAdapter)
		announcer: 	an Announcer
		owner: 	a SpMillerColumnPresenter
		adapter: 	a SpMorphicBoxAdapter
		needRebuild: 	true
		eventHandler: 	nil
		application: 	a StPharoApplication
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ nil ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Untitled window' ]
		additionalSubpresentersMap: 	a Dictionary()
		layout: 	an ObservableValueHolder[ a SpBoxLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		text: 	a SpCodePresenter
		toolbar: 	a SpToolbarPresenter
		statusbar: 	a SpPresenter
		lineLabel: 	a SpLabelPresenter
		toggleLineNumberButton: 	a SpToggleButtonPresenter
		page: 	a StPlaygroundPage
		activationBlock: 	[ :selection |
		self changeSelection: selection from: new[..]


StPlaygroundDoItCommand>>execute
	Receiver: a StPlaygroundDoItCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		context: 	a StPlaygroundPagePresenter
		basicName: 	'Do it'
		basicDescription: 	'Do it all and inspect.'


SpCommand(CmCommandDecorator)>>execute
	Receiver: a SpCommand(Do it)
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a StPlaygroundDoItCommand
		iconProvider: 	a StPharoApplication
		iconName: 	#glamorousGo
		shortcutKey: 	nil
		displayStrategy: 	a CmUIDisableWhenCantBeRun
		positionStrategy: 	a CmUILeftPositionStrategy
		buildPresenterBlock: 	[ :specCommand | 
			aButtonClass new
				label: specC[..]
		presenter: 	a SpToolbarButtonPresenter


[ specCommand execute ] in [ :specCommand | 
			aButtonClass new
				label: specCommand name;
				help: specCommand description;
				in: [ :button | 
					specCommand hasIcon
						ifTrue: [ button icon: specCommand icon ] ];
				action: [ specCommand execute ];
				yourself ] in SpCommand>>configureAsButtonOfClass:
	Receiver: a SpCommand(Do it)
	Arguments and temporary variables: 
		aButtonClass: 	nil
		specCommand: 	a SpCommand(Do it)
	Receiver's instance variables: 
		decoratedCommand: 	a StPlaygroundDoItCommand
		iconProvider: 	a StPharoApplication
		iconName: 	#glamorousGo
		shortcutKey: 	nil
		displayStrategy: 	a CmUIDisableWhenCantBeRun
		positionStrategy: 	a CmUILeftPositionStrategy
		buildPresenterBlock: 	[ :specCommand | 
			aButtonClass new
				label: specC[..]
		presenter: 	a SpToolbarButtonPresenter


FullBlockClosure(BlockClosure)>>cull:
	Receiver: [ specCommand execute ]
	Arguments and temporary variables: 
		anArg: 	a SpToolbarButtonPresenter
	Receiver's instance variables: 
		outerContext: 	[ :specCommand | 
			aButtonClass new
				label: specCommand [..]
		compiledBlock: 	a CompiledBlock: [ specCommand execute ]
		numArgs: 	0
		receiver: 	a SpCommand(Do it)


SpMorphicToolbarButtonAdapter>>execute
	Receiver: a SpMorphicToolbarButtonAdapter
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpToolbarButtonMorph(888790016))
		announcer: 	nil
		model: 	a SpToolbarButtonPresenter
		widget: 	a SpToolbarButtonMorph(888790016)
		selector: 	nil
		owner: 	a SpToolbarButtonPresenter
		unsubscribed: 	false


SpToolbarButtonMorph(PluggableButtonMorph)>>performAction:
	Receiver: a SpToolbarButtonMorph(888790016)
	Arguments and temporary variables: 
		event: 	[(21.0@24.0) mouseUp 423991 nil]
	Receiver's instance variables: 
		bounds: 	(0.0@5.0) corner: (45.0@39.0)
		owner: 	a Morph(1073167616)
		submorphs: 	an Array(an AlignmentMorph(116792320))
		fullBounds: 	nil
		color: 	(Color r: 0.9012707722385142 g: 0.9012707722385142 b: 0.901270772238[..]
		extension: 	a MorphExtension (509491200) [balloonText]  [other:  (presenter [..]
		borderWidth: 	0
		borderColor: 	#simple
		model: 	a SpMorphicToolbarButtonAdapter
		label: 	'Do it'
		icon: 	Form(13x13x32)
		getIconSelector: 	#icon
		getStateSelector: 	#state
		actionSelector: 	#execute
		font: 	a LogicalFont
 familyName: 'Source Sans Pro'
 emphasis: nil
 pointSiz[..]
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	nil
		getFontSelector: 	nil
		labelMorph: 	a LabelMorph(128736768)'Do it'
		iconMorph: 	an ImageMorph(1001562624)
		iconPosition: 	#top
		lastState: 	false
		badgeFont: 	nil
		badgeSelector: 	#badge


[:m |
		(m containsPoint: evt cursorPoint) ifTrue: [m enabled ifTrue: [ m performAction: evt ]]] in SpToolbarButtonMorph(PluggableButtonMorph)>>mouseUp:
	Receiver: a SpToolbarButtonMorph(888790016)
	Arguments and temporary variables: 
		evt: 	[(21.0@24.0) mouseUp 423991 nil]
		all: 	an Array(a SpToolbarButtonMorph(888790016) a SpToolbarButtonMorph(2143[..]
		m: 	a SpToolbarButtonMorph(888790016)
	Receiver's instance variables: 
		bounds: 	(0.0@5.0) corner: (45.0@39.0)
		owner: 	a Morph(1073167616)
		submorphs: 	an Array(an AlignmentMorph(116792320))
		fullBounds: 	nil
		color: 	(Color r: 0.9012707722385142 g: 0.9012707722385142 b: 0.901270772238[..]
		extension: 	a MorphExtension (509491200) [balloonText]  [other:  (presenter [..]
		borderWidth: 	0
		borderColor: 	#simple
		model: 	a SpMorphicToolbarButtonAdapter
		label: 	'Do it'
		icon: 	Form(13x13x32)
		getIconSelector: 	#icon
		getStateSelector: 	#state
		actionSelector: 	#execute
		font: 	a LogicalFont
 familyName: 'Source Sans Pro'
 emphasis: nil
 pointSiz[..]
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	nil
		getFontSelector: 	nil
		labelMorph: 	a LabelMorph(128736768)'Do it'
		iconMorph: 	an ImageMorph(1001562624)
		iconPosition: 	#top
		lastState: 	false
		badgeFont: 	nil
		badgeSelector: 	#badge


Array(SequenceableCollection)>>do:
	Receiver: an Array(a SpToolbarButtonMorph(888790016) a SpToolbarButtonMorph(214329088) a SpToolb[..]
	Arguments and temporary variables: 
		aBlock: 	[:m |
		(m containsPoint: evt cursorPoint) ifTrue: [m enabled ifTru[..]
		index: 	1
	Receiver's instance variables: 
an Array(a SpToolbarButtonMorph(888790016) a SpToolbarButtonMorph(214329088) a SpToolb[..]

SpToolbarButtonMorph(PluggableButtonMorph)>>mouseUp:
	Receiver: a SpToolbarButtonMorph(888790016)
	Arguments and temporary variables: 
		evt: 	[(21.0@24.0) mouseUp 423991 nil]
		all: 	an Array(a SpToolbarButtonMorph(888790016) a SpToolbarButtonMorph(2143[..]
	Receiver's instance variables: 
		bounds: 	(0.0@5.0) corner: (45.0@39.0)
		owner: 	a Morph(1073167616)
		submorphs: 	an Array(an AlignmentMorph(116792320))
		fullBounds: 	nil
		color: 	(Color r: 0.9012707722385142 g: 0.9012707722385142 b: 0.901270772238[..]
		extension: 	a MorphExtension (509491200) [balloonText]  [other:  (presenter [..]
		borderWidth: 	0
		borderColor: 	#simple
		model: 	a SpMorphicToolbarButtonAdapter
		label: 	'Do it'
		icon: 	Form(13x13x32)
		getIconSelector: 	#icon
		getStateSelector: 	#state
		actionSelector: 	#execute
		font: 	a LogicalFont
 familyName: 'Source Sans Pro'
 emphasis: nil
 pointSiz[..]
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	nil
		getFontSelector: 	nil
		labelMorph: 	a LabelMorph(128736768)'Do it'
		iconMorph: 	an ImageMorph(1001562624)
		iconPosition: 	#top
		lastState: 	false
		badgeFont: 	nil
		badgeSelector: 	#badge


SpToolbarButtonMorph(Morph)>>handleMouseUp:
	Receiver: a SpToolbarButtonMorph(888790016)
	Arguments and temporary variables: 
		anEvent: 	[(21.0@24.0) mouseUp 423991 nil]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(0.0@5.0) corner: (45.0@39.0)
		owner: 	a Morph(1073167616)
		submorphs: 	an Array(an AlignmentMorph(116792320))
		fullBounds: 	nil
		color: 	(Color r: 0.9012707722385142 g: 0.9012707722385142 b: 0.901270772238[..]
		extension: 	a MorphExtension (509491200) [balloonText]  [other:  (presenter [..]
		borderWidth: 	0
		borderColor: 	#simple
		model: 	a SpMorphicToolbarButtonAdapter
		label: 	'Do it'
		icon: 	Form(13x13x32)
		getIconSelector: 	#icon
		getStateSelector: 	#state
		actionSelector: 	#execute
		font: 	a LogicalFont
 familyName: 'Source Sans Pro'
 emphasis: nil
 pointSiz[..]
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	nil
		getFontSelector: 	nil
		labelMorph: 	a LabelMorph(128736768)'Do it'
		iconMorph: 	an ImageMorph(1001562624)
		iconPosition: 	#top
		lastState: 	false
		badgeFont: 	nil
		badgeSelector: 	#badge


MouseButtonEvent>>sentTo:
	Receiver: [(21.0@24.0) mouseUp 423991 nil]
	Arguments and temporary variables: 
		anObject: 	a SpToolbarButtonMorph(888790016)
	Receiver's instance variables: 
		timeStamp: 	423991
		source: 	a HandMorph(337424384)
		windowIndex: 	nil
		type: 	#mouseUp
		buttons: 	0
		position: 	(21.0@24.0)
		handler: 	nil
		wasHandled: 	true
		whichButton: 	4


SpToolbarButtonMorph(Morph)>>handleEvent:
	Receiver: a SpToolbarButtonMorph(888790016)
	Arguments and temporary variables: 
		anEvent: 	[(21.0@24.0) mouseUp 423991 nil]
	Receiver's instance variables: 
		bounds: 	(0.0@5.0) corner: (45.0@39.0)
		owner: 	a Morph(1073167616)
		submorphs: 	an Array(an AlignmentMorph(116792320))
		fullBounds: 	nil
		color: 	(Color r: 0.9012707722385142 g: 0.9012707722385142 b: 0.901270772238[..]
		extension: 	a MorphExtension (509491200) [balloonText]  [other:  (presenter [..]
		borderWidth: 	0
		borderColor: 	#simple
		model: 	a SpMorphicToolbarButtonAdapter
		label: 	'Do it'
		icon: 	Form(13x13x32)
		getIconSelector: 	#icon
		getStateSelector: 	#state
		actionSelector: 	#execute
		font: 	a LogicalFont
 familyName: 'Source Sans Pro'
 emphasis: nil
 pointSiz[..]
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	nil
		getFontSelector: 	nil
		labelMorph: 	a LabelMorph(128736768)'Do it'
		iconMorph: 	an ImageMorph(1001562624)
		iconPosition: 	#top
		lastState: 	false
		badgeFont: 	nil
		badgeSelector: 	#badge


SpToolbarButtonMorph(Morph)>>handleFocusEvent:
	Receiver: a SpToolbarButtonMorph(888790016)
	Arguments and temporary variables: 
		anEvent: 	[(21.0@24.0) mouseUp 423991 nil]
	Receiver's instance variables: 
		bounds: 	(0.0@5.0) corner: (45.0@39.0)
		owner: 	a Morph(1073167616)
		submorphs: 	an Array(an AlignmentMorph(116792320))
		fullBounds: 	nil
		color: 	(Color r: 0.9012707722385142 g: 0.9012707722385142 b: 0.901270772238[..]
		extension: 	a MorphExtension (509491200) [balloonText]  [other:  (presenter [..]
		borderWidth: 	0
		borderColor: 	#simple
		model: 	a SpMorphicToolbarButtonAdapter
		label: 	'Do it'
		icon: 	Form(13x13x32)
		getIconSelector: 	#icon
		getStateSelector: 	#state
		actionSelector: 	#execute
		font: 	a LogicalFont
 familyName: 'Source Sans Pro'
 emphasis: nil
 pointSiz[..]
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	nil
		getFontSelector: 	nil
		labelMorph: 	a LabelMorph(128736768)'Do it'
		iconMorph: 	an ImageMorph(1001562624)
		iconPosition: 	#top
		lastState: 	false
		badgeFont: 	nil
		badgeSelector: 	#badge


[
		result := focusHolder handleFocusEvent: transformedEvent.
	] in HandMorph>>sendFocusEvent:to:clear:
	Receiver: a HandMorph(337424384)
	Arguments and temporary variables: 
		anEvent: 	[(540@327) mouseUp 423991 nil]
		focusHolder: 	a SpToolbarButtonMorph(888790016)
		aBlock: 	[self mouseFocus: nil]
		w: 	a WorldMorph(341720576) [world]
		transformedEvent: 	[(21.0@24.0) mouseUp 423991 nil]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(540@327.0) corner: (556@343.0)
		owner: 	a WorldMorph(341720576) [world]
		submorphs: 	#()
		fullBounds: 	(540@327.0) corner: (556@343.0)
		color: 	Color blue
		extension: 	a MorphExtension (370611968)
		mouseFocus: 	nil
		keyboardFocus: 	a RubEditingArea(919167488)
		eventListeners: 	nil
		mouseListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(540@327) mouseUp 423991 nil]
		targetOffset: 	(21.0@19.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 0 0 0 0 0 nil nil)
		captureBlock: 	nil
		recentModifiers: 	0
		pendingEventQueue: 	WaitfreeQueue with 0 items
		supressNextKeyPress: 	false


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
		result := focusHolder handleFocusEvent: transformedEvent.
	]
	Arguments and temporary variables: 
		exception: 	Error
		handlerAction: 	[ :ex |
			ActiveWorld := priorWorld.
			ex pass ]
	Receiver's instance variables: 
		outerContext: 	HandMorph>>sendFocusEvent:to:clear:
		compiledBlock: 	a CompiledBlock: [
		result := focusHolder handleFocusEvent:[..]
		numArgs: 	0
		receiver: 	a HandMorph(337424384)


WorldMorph>>becomeActiveDuring:
	Receiver: a WorldMorph(341720576) [world]
	Arguments and temporary variables: 
		aBlock: 	[
		result := focusHolder handleFocusEvent: transformedEvent.
	]
		priorWorld: 	a WorldMorph(341720576) [world]
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1728@1051)
		owner: 	nil
		submorphs: 	an Array(a MenubarMorph(112886016) a TaskbarMorph(279458560) a S[..]
		fullBounds: 	(0@0) corner: (1728@1051)
		color: 	(Color r: 0.9403714565004888 g: 0.9403714565004888 b: 0.940371456500[..]
		extension: 	a MorphExtension (1012946432) [other:  (dragEnabled -> true) (dr[..]
		borderWidth: 	0
		borderColor: 	(Color r: 0.8611925708699902 g: 1.0 b: 0.7223851417399805 alph[..]
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil


HandMorph>>sendFocusEvent:to:clear:
	Receiver: a HandMorph(337424384)
	Arguments and temporary variables: 
		result: 	nil
		anEvent: 	[(540@327) mouseUp 423991 nil]
		focusHolder: 	a SpToolbarButtonMorph(888790016)
		aBlock: 	[self mouseFocus: nil]
		w: 	a WorldMorph(341720576) [world]
		transformedEvent: 	[(21.0@24.0) mouseUp 423991 nil]
	Receiver's instance variables: 
		bounds: 	(540@327.0) corner: (556@343.0)
		owner: 	a WorldMorph(341720576) [world]
		submorphs: 	#()
		fullBounds: 	(540@327.0) corner: (556@343.0)
		color: 	Color blue
		extension: 	a MorphExtension (370611968)
		mouseFocus: 	nil
		keyboardFocus: 	a RubEditingArea(919167488)
		eventListeners: 	nil
		mouseListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(540@327) mouseUp 423991 nil]
		targetOffset: 	(21.0@19.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 0 0 0 0 0 nil nil)
		captureBlock: 	nil
		recentModifiers: 	0
		pendingEventQueue: 	WaitfreeQueue with 0 items
		supressNextKeyPress: 	false


HandMorph>>sendEvent:focus:clear:
	Receiver: a HandMorph(337424384)
	Arguments and temporary variables: 
		anEvent: 	[(540@327) mouseUp 423991 nil]
		focusHolder: 	a SpToolbarButtonMorph(888790016)
		aBlock: 	[self mouseFocus: nil]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(540@327.0) corner: (556@343.0)
		owner: 	a WorldMorph(341720576) [world]
		submorphs: 	#()
		fullBounds: 	(540@327.0) corner: (556@343.0)
		color: 	Color blue
		extension: 	a MorphExtension (370611968)
		mouseFocus: 	nil
		keyboardFocus: 	a RubEditingArea(919167488)
		eventListeners: 	nil
		mouseListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(540@327) mouseUp 423991 nil]
		targetOffset: 	(21.0@19.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 0 0 0 0 0 nil nil)
		captureBlock: 	nil
		recentModifiers: 	0
		pendingEventQueue: 	WaitfreeQueue with 0 items
		supressNextKeyPress: 	false


HandMorph>>sendMouseEvent:
	Receiver: a HandMorph(337424384)
	Arguments and temporary variables: 
		anEvent: 	[(540@327) mouseUp 423991 nil]
	Receiver's instance variables: 
		bounds: 	(540@327.0) corner: (556@343.0)
		owner: 	a WorldMorph(341720576) [world]
		submorphs: 	#()
		fullBounds: 	(540@327.0) corner: (556@343.0)
		color: 	Color blue
		extension: 	a MorphExtension (370611968)
		mouseFocus: 	nil
		keyboardFocus: 	a RubEditingArea(919167488)
		eventListeners: 	nil
		mouseListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(540@327) mouseUp 423991 nil]
		targetOffset: 	(21.0@19.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 0 0 0 0 0 nil nil)
		captureBlock: 	nil
		recentModifiers: 	0
		pendingEventQueue: 	WaitfreeQueue with 0 items
		supressNextKeyPress: 	false


HandMorph>>handleEvent:
	Receiver: a HandMorph(337424384)
	Arguments and temporary variables: 
		anEvent: 	[(540@327) mouseUp 423991 nil]
		evt: 	[(540@327) mouseUp 423991 nil]
	Receiver's instance variables: 
		bounds: 	(540@327.0) corner: (556@343.0)
		owner: 	a WorldMorph(341720576) [world]
		submorphs: 	#()
		fullBounds: 	(540@327.0) corner: (556@343.0)
		color: 	Color blue
		extension: 	a MorphExtension (370611968)
		mouseFocus: 	nil
		keyboardFocus: 	a RubEditingArea(919167488)
		eventListeners: 	nil
		mouseListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(540@327) mouseUp 423991 nil]
		targetOffset: 	(21.0@19.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 0 0 0 0 0 nil nil)
		captureBlock: 	nil
		recentModifiers: 	0
		pendingEventQueue: 	WaitfreeQueue with 0 items
		supressNextKeyPress: 	false


[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil ]) ifTrue: [
			morphicWorld activeHand handleEvent: anEvent
		]
	] in OSWindowMorphicEventHandler>>dispatchMorphicEvent:
	Receiver: an OSWindowMorphicEventHandler
	Arguments and temporary variables: 
		anEvent: 	[(540@327) mouseUp 423991 nil]
	Receiver's instance variables: 
		morphicWorld: 	a WorldMorph(341720576) [world]


WorldState>>runStepMethodsIn:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(341720576) [world]
		queue: 	WaitfreeQueue with 0 items
		nextInQueue: 	[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNo[..]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(337424384))
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap()
		lastStepTime: 	407290
		lastStepMessage: 	nil
		alarms: 	a Heap(MorphicAlarm(#hideShow -> a RubCursor(899173120)))
		lastAlarmTime: 	423969
		activeHand: 	a HandMorph(337424384)
		currentCursor: 	((CursorWithMask
	extent: (16@16)
	depth: 1
	fromArray: #(
	[..]
		worldRenderer: 	an OSWorldRenderer
		realWindowExtent: 	(1728@1051)
		deferredUIMessages: 	WaitfreeQueue with 0 items


WorldMorph>>runStepMethods
	Receiver: a WorldMorph(341720576) [world]
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1728@1051)
		owner: 	nil
		submorphs: 	an Array(a MenubarMorph(112886016) a TaskbarMorph(279458560) a S[..]
		fullBounds: 	(0@0) corner: (1728@1051)
		color: 	(Color r: 0.9403714565004888 g: 0.9403714565004888 b: 0.940371456500[..]
		extension: 	a MorphExtension (1012946432) [other:  (dragEnabled -> true) (dr[..]
		borderWidth: 	0
		borderColor: 	(Color r: 0.8611925708699902 g: 1.0 b: 0.7223851417399805 alph[..]
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil


WorldState>>doOneCycleFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(341720576) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(337424384))
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap()
		lastStepTime: 	407290
		lastStepMessage: 	nil
		alarms: 	a Heap(MorphicAlarm(#hideShow -> a RubCursor(899173120)))
		lastAlarmTime: 	423969
		activeHand: 	a HandMorph(337424384)
		currentCursor: 	((CursorWithMask
	extent: (16@16)
	depth: 1
	fromArray: #(
	[..]
		worldRenderer: 	an OSWorldRenderer
		realWindowExtent: 	(1728@1051)
		deferredUIMessages: 	WaitfreeQueue with 0 items


WorldMorph>>doOneCycleNow
	Receiver: a WorldMorph(341720576) [world]
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1728@1051)
		owner: 	nil
		submorphs: 	an Array(a MenubarMorph(112886016) a TaskbarMorph(279458560) a S[..]
		fullBounds: 	(0@0) corner: (1728@1051)
		color: 	(Color r: 0.9403714565004888 g: 0.9403714565004888 b: 0.940371456500[..]
		extension: 	a MorphExtension (1012946432) [other:  (dragEnabled -> true) (dr[..]
		borderWidth: 	0
		borderColor: 	(Color r: 0.8611925708699902 g: 1.0 b: 0.7223851417399805 alph[..]
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil


WorldMorph>>doOneCycle
	Receiver: a WorldMorph(341720576) [world]
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1728@1051)
		owner: 	nil
		submorphs: 	an Array(a MenubarMorph(112886016) a TaskbarMorph(279458560) a S[..]
		fullBounds: 	(0@0) corner: (1728@1051)
		color: 	(Color r: 0.9403714565004888 g: 0.9403714565004888 b: 0.940371456500[..]
		extension: 	a MorphExtension (1012946432) [other:  (dragEnabled -> true) (dr[..]
		borderWidth: 	0
		borderColor: 	(Color r: 0.8611925708699902 g: 1.0 b: 0.7223851417399805 alph[..]
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil


[
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMutex critical: [
			                     self extraWorldList ].
		extraWorldsToDraw do: [ :world | world doOneCycle ].

		(self currentWorld isNotNil and: [
			 (extraWorldsToDraw includes: self currentWorld) not ]) ifTrue: [
			self currentWorld doOneCycle ] ] in WorldMorph class>>doOneCycle
	Receiver: WorldMorph
	Arguments and temporary variables: 
		extraWorldsToDraw: 	#()
	Receiver's instance variables: 
		superclass: 	PasteUpMorph
		methodDict: 	a MethodDictionary(#acceptDroppingMorph:event:->WorldMorph>>#ac[..]
		format: 	65547
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		commentSourcePointer: 	nil
		subclasses: 	{AthensWorldMorph. OSWindowWorldMorph}
		name: 	#WorldMorph
		classPool: 	a Dictionary(#AllowDropFiles->nil #CursorOwnerWorld->a WorldMorp[..]
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Morphic-Core-Worlds'
		announcer: 	nil
		displayScaleFactor: 	1


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMutex critical: [
			  [..]
	Arguments and temporary variables: 
		aBlock: 	[
		self doInterCycleWait
	]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	WorldMorph class>>doOneCycle
		compiledBlock: 	a CompiledBlock: [
		| extraWorldsToDraw |
		extraWorldsToDr[..]
		numArgs: 	0
		receiver: 	WorldMorph


WorldState class>>doDrawCycleWith:
	Receiver: WorldState
	Arguments and temporary variables: 
		aBlock: 	[
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMute[..]
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary(#activeHand->WorldState>>#activeHand #active[..]
		format: 	65548
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		commentSourcePointer: 	nil
		subclasses: 	{AthensWorldState}
		name: 	#WorldState
		classPool: 	a Dictionary(#CanSurrenderToOS->nil #DebugShowDamage->false #Des[..]
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Morphic-Core-Worlds'



--- The full stack ---
RSBox(Object)>>doesNotUnderstand: #text:
VisualizerMain>>createSampleGraph
UndefinedObject>>DoIt
OCReceiverDoItSemanticScope(OCDoItSemanticScope)>>evaluateDoIt:
OpalCompiler>>evaluate
[
		self announcer announce: (SpCodeWillBeEvaluatedAnnouncement newContent: aString).
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionModel doItReceiver.
		result := receiver class compiler
			source: aString;
			context: self interactionModel doItContext;
			receiver: self interactionModel doItReceiver;
			requestor: self interactionModel;
			environment: self environment;
			failBlock:  [ 
				self announcer announce: (SpCodeEvaluationFailedAnnouncement newContent: aString).
				^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		self announcer announce: (SpCodeEvaluationSucceedAnnouncement newContent: aString).
		result ] in SpCodePresenter>>evaluate:onCompileError:onError:
FullBlockClosure(BlockClosure)>>on:do:
SpCodePresenter>>evaluate:onCompileError:onError:
StPlaygroundPagePresenter>>doEvaluateAndGo
StPlaygroundPagePresenter>>doEvaluateAllAndGo
StPlaygroundDoItCommand>>execute
SpCommand(CmCommandDecorator)>>execute
[ specCommand execute ] in [ :specCommand | 
			aButtonClass new
				label: specCommand name;
				help: specCommand description;
				in: [ :button | 
					specCommand hasIcon
						ifTrue: [ button icon: specCommand icon ] ];
				action: [ specCommand execute ];
				yourself ] in SpCommand>>configureAsButtonOfClass:
FullBlockClosure(BlockClosure)>>cull:
SpMorphicToolbarButtonAdapter>>execute
SpToolbarButtonMorph(PluggableButtonMorph)>>performAction:
[:m |
		(m containsPoint: evt cursorPoint) ifTrue: [m enabled ifTrue: [ m performAction: evt ]]] in SpToolbarButtonMorph(PluggableButtonMorph)>>mouseUp:
Array(SequenceableCollection)>>do:
SpToolbarButtonMorph(PluggableButtonMorph)>>mouseUp:
SpToolbarButtonMorph(Morph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
SpToolbarButtonMorph(Morph)>>handleEvent:
SpToolbarButtonMorph(Morph)>>handleFocusEvent:
[
		result := focusHolder handleFocusEvent: transformedEvent.
	] in HandMorph>>sendFocusEvent:to:clear:
FullBlockClosure(BlockClosure)>>on:do:
WorldMorph>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil ]) ifTrue: [
			morphicWorld activeHand handleEvent: anEvent
		]
	] in OSWindowMorphicEventHandler>>dispatchMorphicEvent:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycleNow
WorldMorph>>doOneCycle
[
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMutex critical: [
			                     self extraWorldList ].
		extraWorldsToDraw do: [ :world | world doOneCycle ].

		(self currentWorld isNotNil and: [
			 (extraWorldsToDraw includes: self currentWorld) not ]) ifTrue: [
			self currentWorld doOneCycle ] ] in WorldMorph class>>doOneCycle
FullBlockClosure(BlockClosure)>>ensure:
WorldState class>>doDrawCycleWith:
 - - - - - - - - - - - - - - -
			- - - - - - - - - - - - - - - - - -
WorldMorph class>>doOneCycle
MorphicRenderLoop>>doOneCycle
MorphicRenderLoop>>doOneCycleWhile:
[ MorphicRenderLoop new doOneCycleWhile: [ true ] ] in MorphicUIManager>>spawnNewProcess
[self value.
			"IMPORTANT: Do not step over next line of code. See method comments for details"
			Processor terminateRealActive] in FullBlockClosure(BlockClosure)>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
Instance of RSBox did not understand #text:
23 October 2023 11:59:19.09101 pm

VM: Mac OS - arm64 - 1000 - CoInterpreter VMMaker-tonel.1 uuid: 902dd483-c0c4-0d00-86f2-0f880df24b96 Oct 23 2023
StackToRegisterMappingCogit VMMaker-tonel.1 uuid: 902dd483-c0c4-0d00-86f2-0f880df24b96 Oct 23 2023
v10.0.8 - Commit: b323c5fb - Date: 2023-10-20 16:02:07 -0400

Image: Pharo11.0.0 [Build information: Pharo-11.0.0+build.710.sha.ea28d8552cac85a7ce1e9c34ab1e7bd45f7b9910 (64 Bit)]

RSBox(Object)>>doesNotUnderstand: #text:
	Receiver: a RSBox
	Arguments and temporary variables: 
		aMessage: 	text: 'Alice'
		exception: 	Instance of RSBox did not understand #text:
		resumeValue: 	nil
	Receiver's instance variables: 
		announcer: 	nil
		properties: 	nil
		paint: 	Color blue
		path: 	(-25.0@ -25.0) corner: (25.0@25.0)
		border: 	nil
		parent: 	nil
		isFixed: 	false
		encompassingRectangle: 	nil
		model: 	nil
		baseRectangle: 	(-25.0@ -25.0) corner: (25.0@25.0)
		matrix: 	x: 0.0 y: 0.0 sx: 1.0 sy: 1.0 shx: 0.0 shy: 0.0
		connectedLines: 	nil
		shouldUpdateLines: 	true
		cornerRadius: 	nil


VisualizerMain>>createSampleGraph
	Receiver: a VisualizerMain
	Arguments and temporary variables: 
		view: 	a RSCanvas
		alice: 	nil
		bob: 	nil
	Receiver's instance variables: 
a VisualizerMain

UndefinedObject>>DoIt
	Receiver: nil
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
nil

OCReceiverDoItSemanticScope(OCDoItSemanticScope)>>evaluateDoIt:
	Receiver: an OCReceiverDoItSemanticScope
	Arguments and temporary variables: 
		doItMethod: 	UndefinedObject>>#DoIt
	Receiver's instance variables: 
		outerScope: 	nil
		targetReceiver: 	nil


OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
		doItMethod: 	UndefinedObject>>#DoIt
	Receiver's instance variables: 
		ast: 	DoIt

	^ VisualizerMain new createSampleGraph open
		source: 	a ReadStream
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil


[
		self announcer announce: (SpCodeWillBeEvaluatedAnnouncement newContent: aString).
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionModel doItReceiver.
		result := receiver class compiler
			source: aString;
			context: self interactionModel doItContext;
			receiver: self interactionModel doItReceiver;
			requestor: self interactionModel;
			environment: self environment;
			failBlock:  [ 
				self announcer announce: (SpCodeEvaluationFailedAnnouncement newContent: aString).
				^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		self announcer announce: (SpCodeEvaluationSucceedAnnouncement newContent: aString).
		result ] in SpCodePresenter>>evaluate:onCompileError:onError:
	Receiver: a SpCodePresenter
	Arguments and temporary variables: 
		aString: 	'(VisualizerMain new createSampleGraph) open.
'
		compileErrorBlock: 	[ ^ self ]
		errorBlock: 	[ :e | e pass ]
		receiver: 	nil
		result: 	nil
		oldBindings: 	a Dictionary()
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicCodeAdapter)
		announcer: 	an Announcer
		owner: 	a StPlaygroundPagePresenter
		adapter: 	a SpMorphicCodeAdapter
		needRebuild: 	true
		eventHandler: 	a SpEventHandler
		application: 	nil
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ a KMCategory ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Code' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpAbstractWidgetLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		borderWidth: 	an ObservableValueHolder[ nil ]
		borderColor: 	an ObservableValueHolder[ nil ]
		dragEnabled: 	an ObservableValueHolder[ false ]
		dropEnabled: 	an ObservableValueHolder[ false ]
		color: 	an ObservableValueHolder[ nil ]
		help: 	an ObservableValueHolder[ nil ]
		enabled: 	an ObservableValueHolder[ true ]
		wantsDrop: 	an ObservableValueHolder[ [ :transfer | self dropEnabled ] ]
		acceptDrop: 	an ObservableValueHolder[ [ :transfer | ] ]
		deferredActions: 	nil
		hasUnacceptedEdits: 	an ObservableValueHolder[ false ]
		selection: 	an ObservableValueHolder[ (1 to: 45) ]
		wantsVisualFeedback: 	an ObservableValueHolder[ true ]
		askBeforeDiscardingEdits: 	an ObservableValueHolder[ true ]
		text: 	an ObservableValueHolder[ '(VisualizerMain new createSampleGraph) ope[..]
		actionToPerform: 	an ObservableValueHolder[ [ :txt |  ] ]
		readSelection: 	an ObservableValueHolder[ [ selection ] ]
		placeholder: 	an ObservableValueHolder[ '' ]
		contextMenu: 	an ObservableValueHolder[ [ (self menuActionsFor: text) asMenu[..]
		scrollValue: 	an ObservableValueHolder[ (0@0) ]
		editionContextMenu: 	an ObservableValueHolder[ true ]
		editable: 	an ObservableValueHolder[ true ]
		wrapWord: 	an ObservableValueHolder[ true ]
		undoRedoHistory: 	true
		wrapScrollBars: 	true
		propagateNaturalHeight: 	false
		propagateNaturalWidth: 	false
		scrollBarStyles: 	#()
		syntaxHighlight: 	an ObservableValueHolder[ true ]
		smartCharacters: 	an ObservableValueHolder[ true ]
		lineNumbers: 	an ObservableValueHolder[ true ]
		interactionModel: 	an ObservableValueHolder[ a StPlaygroundInteractionModel ]
		overrideContextMenu: 	true
		submitBlock: 	nil
		resetBlock: 	nil
		environment: 	nil
		systemNavigation: 	nil
		syntaxHighlightTheme: 	an ObservableValueHolder[ nil ]


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
		self announcer announce: (SpCodeWillBeEvaluatedAnnouncement newContent: aString).
[..]
	Arguments and temporary variables: 
		exception: 	Error
		handlerAction: 	[ :e |
		self announcer announce: (SpCodeEvaluationFailedAnn[..]
	Receiver's instance variables: 
		outerContext: 	SpCodePresenter>>evaluate:onCompileError:onError:
		compiledBlock: 	a CompiledBlock: [
		self announcer announce: (SpCodeWillBeE[..]
		numArgs: 	0
		receiver: 	a SpCodePresenter


SpCodePresenter>>evaluate:onCompileError:onError:
	Receiver: a SpCodePresenter
	Arguments and temporary variables: 
		receiver: 	nil
		result: 	nil
		oldBindings: 	a Dictionary()
		aString: 	'(VisualizerMain new createSampleGraph) open.
'
		compileErrorBlock: 	[ ^ self ]
		errorBlock: 	[ :e | e pass ]
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicCodeAdapter)
		announcer: 	an Announcer
		owner: 	a StPlaygroundPagePresenter
		adapter: 	a SpMorphicCodeAdapter
		needRebuild: 	true
		eventHandler: 	a SpEventHandler
		application: 	nil
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ a KMCategory ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Code' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpAbstractWidgetLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		borderWidth: 	an ObservableValueHolder[ nil ]
		borderColor: 	an ObservableValueHolder[ nil ]
		dragEnabled: 	an ObservableValueHolder[ false ]
		dropEnabled: 	an ObservableValueHolder[ false ]
		color: 	an ObservableValueHolder[ nil ]
		help: 	an ObservableValueHolder[ nil ]
		enabled: 	an ObservableValueHolder[ true ]
		wantsDrop: 	an ObservableValueHolder[ [ :transfer | self dropEnabled ] ]
		acceptDrop: 	an ObservableValueHolder[ [ :transfer | ] ]
		deferredActions: 	nil
		hasUnacceptedEdits: 	an ObservableValueHolder[ false ]
		selection: 	an ObservableValueHolder[ (1 to: 45) ]
		wantsVisualFeedback: 	an ObservableValueHolder[ true ]
		askBeforeDiscardingEdits: 	an ObservableValueHolder[ true ]
		text: 	an ObservableValueHolder[ '(VisualizerMain new createSampleGraph) ope[..]
		actionToPerform: 	an ObservableValueHolder[ [ :txt |  ] ]
		readSelection: 	an ObservableValueHolder[ [ selection ] ]
		placeholder: 	an ObservableValueHolder[ '' ]
		contextMenu: 	an ObservableValueHolder[ [ (self menuActionsFor: text) asMenu[..]
		scrollValue: 	an ObservableValueHolder[ (0@0) ]
		editionContextMenu: 	an ObservableValueHolder[ true ]
		editable: 	an ObservableValueHolder[ true ]
		wrapWord: 	an ObservableValueHolder[ true ]
		undoRedoHistory: 	true
		wrapScrollBars: 	true
		propagateNaturalHeight: 	false
		propagateNaturalWidth: 	false
		scrollBarStyles: 	#()
		syntaxHighlight: 	an ObservableValueHolder[ true ]
		smartCharacters: 	an ObservableValueHolder[ true ]
		lineNumbers: 	an ObservableValueHolder[ true ]
		interactionModel: 	an ObservableValueHolder[ a StPlaygroundInteractionModel ]
		overrideContextMenu: 	true
		submitBlock: 	nil
		resetBlock: 	nil
		environment: 	nil
		systemNavigation: 	nil
		syntaxHighlightTheme: 	an ObservableValueHolder[ nil ]


StPlaygroundPagePresenter>>doEvaluateAndGo
	Receiver: a StPlaygroundPagePresenter
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicBoxAdapter)
		announcer: 	an Announcer
		owner: 	a SpMillerColumnPresenter
		adapter: 	a SpMorphicBoxAdapter
		needRebuild: 	true
		eventHandler: 	nil
		application: 	a StPharoApplication
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ nil ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Untitled window' ]
		additionalSubpresentersMap: 	a Dictionary()
		layout: 	an ObservableValueHolder[ a SpBoxLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		text: 	a SpCodePresenter
		toolbar: 	a SpToolbarPresenter
		statusbar: 	a SpPresenter
		lineLabel: 	a SpLabelPresenter
		toggleLineNumberButton: 	a SpToggleButtonPresenter
		page: 	a StPlaygroundPage
		activationBlock: 	[ :selection |
		self changeSelection: selection from: new[..]


StPlaygroundPagePresenter>>doEvaluateAllAndGo
	Receiver: a StPlaygroundPagePresenter
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicBoxAdapter)
		announcer: 	an Announcer
		owner: 	a SpMillerColumnPresenter
		adapter: 	a SpMorphicBoxAdapter
		needRebuild: 	true
		eventHandler: 	nil
		application: 	a StPharoApplication
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ nil ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Untitled window' ]
		additionalSubpresentersMap: 	a Dictionary()
		layout: 	an ObservableValueHolder[ a SpBoxLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		text: 	a SpCodePresenter
		toolbar: 	a SpToolbarPresenter
		statusbar: 	a SpPresenter
		lineLabel: 	a SpLabelPresenter
		toggleLineNumberButton: 	a SpToggleButtonPresenter
		page: 	a StPlaygroundPage
		activationBlock: 	[ :selection |
		self changeSelection: selection from: new[..]


StPlaygroundDoItCommand>>execute
	Receiver: a StPlaygroundDoItCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		context: 	a StPlaygroundPagePresenter
		basicName: 	'Do it'
		basicDescription: 	'Do it all and inspect.'


SpCommand(CmCommandDecorator)>>execute
	Receiver: a SpCommand(Do it)
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a StPlaygroundDoItCommand
		iconProvider: 	a StPharoApplication
		iconName: 	#glamorousGo
		shortcutKey: 	nil
		displayStrategy: 	a CmUIDisableWhenCantBeRun
		positionStrategy: 	a CmUILeftPositionStrategy
		buildPresenterBlock: 	[ :specCommand | 
			aButtonClass new
				label: specC[..]
		presenter: 	a SpToolbarButtonPresenter


[ specCommand execute ] in [ :specCommand | 
			aButtonClass new
				label: specCommand name;
				help: specCommand description;
				in: [ :button | 
					specCommand hasIcon
						ifTrue: [ button icon: specCommand icon ] ];
				action: [ specCommand execute ];
				yourself ] in SpCommand>>configureAsButtonOfClass:
	Receiver: a SpCommand(Do it)
	Arguments and temporary variables: 
		aButtonClass: 	nil
		specCommand: 	a SpCommand(Do it)
	Receiver's instance variables: 
		decoratedCommand: 	a StPlaygroundDoItCommand
		iconProvider: 	a StPharoApplication
		iconName: 	#glamorousGo
		shortcutKey: 	nil
		displayStrategy: 	a CmUIDisableWhenCantBeRun
		positionStrategy: 	a CmUILeftPositionStrategy
		buildPresenterBlock: 	[ :specCommand | 
			aButtonClass new
				label: specC[..]
		presenter: 	a SpToolbarButtonPresenter


FullBlockClosure(BlockClosure)>>cull:
	Receiver: [ specCommand execute ]
	Arguments and temporary variables: 
		anArg: 	a SpToolbarButtonPresenter
	Receiver's instance variables: 
		outerContext: 	[ :specCommand | 
			aButtonClass new
				label: specCommand [..]
		compiledBlock: 	a CompiledBlock: [ specCommand execute ]
		numArgs: 	0
		receiver: 	a SpCommand(Do it)


SpMorphicToolbarButtonAdapter>>execute
	Receiver: a SpMorphicToolbarButtonAdapter
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpToolbarButtonMorph(888790016))
		announcer: 	nil
		model: 	a SpToolbarButtonPresenter
		widget: 	a SpToolbarButtonMorph(888790016)
		selector: 	nil
		owner: 	a SpToolbarButtonPresenter
		unsubscribed: 	false


SpToolbarButtonMorph(PluggableButtonMorph)>>performAction:
	Receiver: a SpToolbarButtonMorph(888790016)
	Arguments and temporary variables: 
		event: 	[(21.0@24.0) mouseUp 423991 nil]
	Receiver's instance variables: 
		bounds: 	(0.0@5.0) corner: (45.0@39.0)
		owner: 	a Morph(1073167616)
		submorphs: 	an Array(an AlignmentMorph(116792320))
		fullBounds: 	nil
		color: 	(Color r: 0.9012707722385142 g: 0.9012707722385142 b: 0.901270772238[..]
		extension: 	a MorphExtension (509491200) [balloonText]  [other:  (presenter [..]
		borderWidth: 	0
		borderColor: 	#simple
		model: 	a SpMorphicToolbarButtonAdapter
		label: 	'Do it'
		icon: 	Form(13x13x32)
		getIconSelector: 	#icon
		getStateSelector: 	#state
		actionSelector: 	#execute
		font: 	a LogicalFont
 familyName: 'Source Sans Pro'
 emphasis: nil
 pointSiz[..]
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	nil
		getFontSelector: 	nil
		labelMorph: 	a LabelMorph(128736768)'Do it'
		iconMorph: 	an ImageMorph(1001562624)
		iconPosition: 	#top
		lastState: 	false
		badgeFont: 	nil
		badgeSelector: 	#badge


[:m |
		(m containsPoint: evt cursorPoint) ifTrue: [m enabled ifTrue: [ m performAction: evt ]]] in SpToolbarButtonMorph(PluggableButtonMorph)>>mouseUp:
	Receiver: a SpToolbarButtonMorph(888790016)
	Arguments and temporary variables: 
		evt: 	[(21.0@24.0) mouseUp 423991 nil]
		all: 	an Array(a SpToolbarButtonMorph(888790016) a SpToolbarButtonMorph(2143[..]
		m: 	a SpToolbarButtonMorph(888790016)
	Receiver's instance variables: 
		bounds: 	(0.0@5.0) corner: (45.0@39.0)
		owner: 	a Morph(1073167616)
		submorphs: 	an Array(an AlignmentMorph(116792320))
		fullBounds: 	nil
		color: 	(Color r: 0.9012707722385142 g: 0.9012707722385142 b: 0.901270772238[..]
		extension: 	a MorphExtension (509491200) [balloonText]  [other:  (presenter [..]
		borderWidth: 	0
		borderColor: 	#simple
		model: 	a SpMorphicToolbarButtonAdapter
		label: 	'Do it'
		icon: 	Form(13x13x32)
		getIconSelector: 	#icon
		getStateSelector: 	#state
		actionSelector: 	#execute
		font: 	a LogicalFont
 familyName: 'Source Sans Pro'
 emphasis: nil
 pointSiz[..]
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	nil
		getFontSelector: 	nil
		labelMorph: 	a LabelMorph(128736768)'Do it'
		iconMorph: 	an ImageMorph(1001562624)
		iconPosition: 	#top
		lastState: 	false
		badgeFont: 	nil
		badgeSelector: 	#badge


Array(SequenceableCollection)>>do:
	Receiver: an Array(a SpToolbarButtonMorph(888790016) a SpToolbarButtonMorph(214329088) a SpToolb[..]
	Arguments and temporary variables: 
		aBlock: 	[:m |
		(m containsPoint: evt cursorPoint) ifTrue: [m enabled ifTru[..]
		index: 	1
	Receiver's instance variables: 
an Array(a SpToolbarButtonMorph(888790016) a SpToolbarButtonMorph(214329088) a SpToolb[..]

SpToolbarButtonMorph(PluggableButtonMorph)>>mouseUp:
	Receiver: a SpToolbarButtonMorph(888790016)
	Arguments and temporary variables: 
		evt: 	[(21.0@24.0) mouseUp 423991 nil]
		all: 	an Array(a SpToolbarButtonMorph(888790016) a SpToolbarButtonMorph(2143[..]
	Receiver's instance variables: 
		bounds: 	(0.0@5.0) corner: (45.0@39.0)
		owner: 	a Morph(1073167616)
		submorphs: 	an Array(an AlignmentMorph(116792320))
		fullBounds: 	nil
		color: 	(Color r: 0.9012707722385142 g: 0.9012707722385142 b: 0.901270772238[..]
		extension: 	a MorphExtension (509491200) [balloonText]  [other:  (presenter [..]
		borderWidth: 	0
		borderColor: 	#simple
		model: 	a SpMorphicToolbarButtonAdapter
		label: 	'Do it'
		icon: 	Form(13x13x32)
		getIconSelector: 	#icon
		getStateSelector: 	#state
		actionSelector: 	#execute
		font: 	a LogicalFont
 familyName: 'Source Sans Pro'
 emphasis: nil
 pointSiz[..]
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	nil
		getFontSelector: 	nil
		labelMorph: 	a LabelMorph(128736768)'Do it'
		iconMorph: 	an ImageMorph(1001562624)
		iconPosition: 	#top
		lastState: 	false
		badgeFont: 	nil
		badgeSelector: 	#badge


SpToolbarButtonMorph(Morph)>>handleMouseUp:
	Receiver: a SpToolbarButtonMorph(888790016)
	Arguments and temporary variables: 
		anEvent: 	[(21.0@24.0) mouseUp 423991 nil]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(0.0@5.0) corner: (45.0@39.0)
		owner: 	a Morph(1073167616)
		submorphs: 	an Array(an AlignmentMorph(116792320))
		fullBounds: 	nil
		color: 	(Color r: 0.9012707722385142 g: 0.9012707722385142 b: 0.901270772238[..]
		extension: 	a MorphExtension (509491200) [balloonText]  [other:  (presenter [..]
		borderWidth: 	0
		borderColor: 	#simple
		model: 	a SpMorphicToolbarButtonAdapter
		label: 	'Do it'
		icon: 	Form(13x13x32)
		getIconSelector: 	#icon
		getStateSelector: 	#state
		actionSelector: 	#execute
		font: 	a LogicalFont
 familyName: 'Source Sans Pro'
 emphasis: nil
 pointSiz[..]
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	nil
		getFontSelector: 	nil
		labelMorph: 	a LabelMorph(128736768)'Do it'
		iconMorph: 	an ImageMorph(1001562624)
		iconPosition: 	#top
		lastState: 	false
		badgeFont: 	nil
		badgeSelector: 	#badge


MouseButtonEvent>>sentTo:
	Receiver: [(21.0@24.0) mouseUp 423991 nil]
	Arguments and temporary variables: 
		anObject: 	a SpToolbarButtonMorph(888790016)
	Receiver's instance variables: 
		timeStamp: 	423991
		source: 	a HandMorph(337424384)
		windowIndex: 	nil
		type: 	#mouseUp
		buttons: 	0
		position: 	(21.0@24.0)
		handler: 	nil
		wasHandled: 	true
		whichButton: 	4


SpToolbarButtonMorph(Morph)>>handleEvent:
	Receiver: a SpToolbarButtonMorph(888790016)
	Arguments and temporary variables: 
		anEvent: 	[(21.0@24.0) mouseUp 423991 nil]
	Receiver's instance variables: 
		bounds: 	(0.0@5.0) corner: (45.0@39.0)
		owner: 	a Morph(1073167616)
		submorphs: 	an Array(an AlignmentMorph(116792320))
		fullBounds: 	nil
		color: 	(Color r: 0.9012707722385142 g: 0.9012707722385142 b: 0.901270772238[..]
		extension: 	a MorphExtension (509491200) [balloonText]  [other:  (presenter [..]
		borderWidth: 	0
		borderColor: 	#simple
		model: 	a SpMorphicToolbarButtonAdapter
		label: 	'Do it'
		icon: 	Form(13x13x32)
		getIconSelector: 	#icon
		getStateSelector: 	#state
		actionSelector: 	#execute
		font: 	a LogicalFont
 familyName: 'Source Sans Pro'
 emphasis: nil
 pointSiz[..]
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	nil
		getFontSelector: 	nil
		labelMorph: 	a LabelMorph(128736768)'Do it'
		iconMorph: 	an ImageMorph(1001562624)
		iconPosition: 	#top
		lastState: 	false
		badgeFont: 	nil
		badgeSelector: 	#badge


SpToolbarButtonMorph(Morph)>>handleFocusEvent:
	Receiver: a SpToolbarButtonMorph(888790016)
	Arguments and temporary variables: 
		anEvent: 	[(21.0@24.0) mouseUp 423991 nil]
	Receiver's instance variables: 
		bounds: 	(0.0@5.0) corner: (45.0@39.0)
		owner: 	a Morph(1073167616)
		submorphs: 	an Array(an AlignmentMorph(116792320))
		fullBounds: 	nil
		color: 	(Color r: 0.9012707722385142 g: 0.9012707722385142 b: 0.901270772238[..]
		extension: 	a MorphExtension (509491200) [balloonText]  [other:  (presenter [..]
		borderWidth: 	0
		borderColor: 	#simple
		model: 	a SpMorphicToolbarButtonAdapter
		label: 	'Do it'
		icon: 	Form(13x13x32)
		getIconSelector: 	#icon
		getStateSelector: 	#state
		actionSelector: 	#execute
		font: 	a LogicalFont
 familyName: 'Source Sans Pro'
 emphasis: nil
 pointSiz[..]
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	nil
		getFontSelector: 	nil
		labelMorph: 	a LabelMorph(128736768)'Do it'
		iconMorph: 	an ImageMorph(1001562624)
		iconPosition: 	#top
		lastState: 	false
		badgeFont: 	nil
		badgeSelector: 	#badge


[
		result := focusHolder handleFocusEvent: transformedEvent.
	] in HandMorph>>sendFocusEvent:to:clear:
	Receiver: a HandMorph(337424384)
	Arguments and temporary variables: 
		anEvent: 	[(540@327) mouseUp 423991 nil]
		focusHolder: 	a SpToolbarButtonMorph(888790016)
		aBlock: 	[self mouseFocus: nil]
		w: 	a WorldMorph(341720576) [world]
		transformedEvent: 	[(21.0@24.0) mouseUp 423991 nil]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(540@327.0) corner: (556@343.0)
		owner: 	a WorldMorph(341720576) [world]
		submorphs: 	#()
		fullBounds: 	(540@327.0) corner: (556@343.0)
		color: 	Color blue
		extension: 	a MorphExtension (370611968)
		mouseFocus: 	nil
		keyboardFocus: 	a RubEditingArea(919167488)
		eventListeners: 	nil
		mouseListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(540@327) mouseUp 423991 nil]
		targetOffset: 	(21.0@19.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 0 0 0 0 0 nil nil)
		captureBlock: 	nil
		recentModifiers: 	0
		pendingEventQueue: 	WaitfreeQueue with 0 items
		supressNextKeyPress: 	false


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
		result := focusHolder handleFocusEvent: transformedEvent.
	]
	Arguments and temporary variables: 
		exception: 	Error
		handlerAction: 	[ :ex |
			ActiveWorld := priorWorld.
			ex pass ]
	Receiver's instance variables: 
		outerContext: 	HandMorph>>sendFocusEvent:to:clear:
		compiledBlock: 	a CompiledBlock: [
		result := focusHolder handleFocusEvent:[..]
		numArgs: 	0
		receiver: 	a HandMorph(337424384)


WorldMorph>>becomeActiveDuring:
	Receiver: a WorldMorph(341720576) [world]
	Arguments and temporary variables: 
		aBlock: 	[
		result := focusHolder handleFocusEvent: transformedEvent.
	]
		priorWorld: 	a WorldMorph(341720576) [world]
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1728@1051)
		owner: 	nil
		submorphs: 	an Array(a MenubarMorph(112886016) a TaskbarMorph(279458560) a S[..]
		fullBounds: 	(0@0) corner: (1728@1051)
		color: 	(Color r: 0.9403714565004888 g: 0.9403714565004888 b: 0.940371456500[..]
		extension: 	a MorphExtension (1012946432) [other:  (dragEnabled -> true) (dr[..]
		borderWidth: 	0
		borderColor: 	(Color r: 0.8611925708699902 g: 1.0 b: 0.7223851417399805 alph[..]
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil


HandMorph>>sendFocusEvent:to:clear:
	Receiver: a HandMorph(337424384)
	Arguments and temporary variables: 
		result: 	nil
		anEvent: 	[(540@327) mouseUp 423991 nil]
		focusHolder: 	a SpToolbarButtonMorph(888790016)
		aBlock: 	[self mouseFocus: nil]
		w: 	a WorldMorph(341720576) [world]
		transformedEvent: 	[(21.0@24.0) mouseUp 423991 nil]
	Receiver's instance variables: 
		bounds: 	(540@327.0) corner: (556@343.0)
		owner: 	a WorldMorph(341720576) [world]
		submorphs: 	#()
		fullBounds: 	(540@327.0) corner: (556@343.0)
		color: 	Color blue
		extension: 	a MorphExtension (370611968)
		mouseFocus: 	nil
		keyboardFocus: 	a RubEditingArea(919167488)
		eventListeners: 	nil
		mouseListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(540@327) mouseUp 423991 nil]
		targetOffset: 	(21.0@19.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 0 0 0 0 0 nil nil)
		captureBlock: 	nil
		recentModifiers: 	0
		pendingEventQueue: 	WaitfreeQueue with 0 items
		supressNextKeyPress: 	false


HandMorph>>sendEvent:focus:clear:
	Receiver: a HandMorph(337424384)
	Arguments and temporary variables: 
		anEvent: 	[(540@327) mouseUp 423991 nil]
		focusHolder: 	a SpToolbarButtonMorph(888790016)
		aBlock: 	[self mouseFocus: nil]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(540@327.0) corner: (556@343.0)
		owner: 	a WorldMorph(341720576) [world]
		submorphs: 	#()
		fullBounds: 	(540@327.0) corner: (556@343.0)
		color: 	Color blue
		extension: 	a MorphExtension (370611968)
		mouseFocus: 	nil
		keyboardFocus: 	a RubEditingArea(919167488)
		eventListeners: 	nil
		mouseListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(540@327) mouseUp 423991 nil]
		targetOffset: 	(21.0@19.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 0 0 0 0 0 nil nil)
		captureBlock: 	nil
		recentModifiers: 	0
		pendingEventQueue: 	WaitfreeQueue with 0 items
		supressNextKeyPress: 	false


HandMorph>>sendMouseEvent:
	Receiver: a HandMorph(337424384)
	Arguments and temporary variables: 
		anEvent: 	[(540@327) mouseUp 423991 nil]
	Receiver's instance variables: 
		bounds: 	(540@327.0) corner: (556@343.0)
		owner: 	a WorldMorph(341720576) [world]
		submorphs: 	#()
		fullBounds: 	(540@327.0) corner: (556@343.0)
		color: 	Color blue
		extension: 	a MorphExtension (370611968)
		mouseFocus: 	nil
		keyboardFocus: 	a RubEditingArea(919167488)
		eventListeners: 	nil
		mouseListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(540@327) mouseUp 423991 nil]
		targetOffset: 	(21.0@19.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 0 0 0 0 0 nil nil)
		captureBlock: 	nil
		recentModifiers: 	0
		pendingEventQueue: 	WaitfreeQueue with 0 items
		supressNextKeyPress: 	false


HandMorph>>handleEvent:
	Receiver: a HandMorph(337424384)
	Arguments and temporary variables: 
		anEvent: 	[(540@327) mouseUp 423991 nil]
		evt: 	[(540@327) mouseUp 423991 nil]
	Receiver's instance variables: 
		bounds: 	(540@327.0) corner: (556@343.0)
		owner: 	a WorldMorph(341720576) [world]
		submorphs: 	#()
		fullBounds: 	(540@327.0) corner: (556@343.0)
		color: 	Color blue
		extension: 	a MorphExtension (370611968)
		mouseFocus: 	nil
		keyboardFocus: 	a RubEditingArea(919167488)
		eventListeners: 	nil
		mouseListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(540@327) mouseUp 423991 nil]
		targetOffset: 	(21.0@19.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 0 0 0 0 0 nil nil)
		captureBlock: 	nil
		recentModifiers: 	0
		pendingEventQueue: 	WaitfreeQueue with 0 items
		supressNextKeyPress: 	false


[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil ]) ifTrue: [
			morphicWorld activeHand handleEvent: anEvent
		]
	] in OSWindowMorphicEventHandler>>dispatchMorphicEvent:
	Receiver: an OSWindowMorphicEventHandler
	Arguments and temporary variables: 
		anEvent: 	[(540@327) mouseUp 423991 nil]
	Receiver's instance variables: 
		morphicWorld: 	a WorldMorph(341720576) [world]


WorldState>>runStepMethodsIn:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(341720576) [world]
		queue: 	WaitfreeQueue with 0 items
		nextInQueue: 	[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNo[..]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(337424384))
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap()
		lastStepTime: 	407290
		lastStepMessage: 	nil
		alarms: 	a Heap(MorphicAlarm(#hideShow -> a RubCursor(899173120)))
		lastAlarmTime: 	423969
		activeHand: 	a HandMorph(337424384)
		currentCursor: 	((CursorWithMask
	extent: (16@16)
	depth: 1
	fromArray: #(
	[..]
		worldRenderer: 	an OSWorldRenderer
		realWindowExtent: 	(1728@1051)
		deferredUIMessages: 	WaitfreeQueue with 0 items


WorldMorph>>runStepMethods
	Receiver: a WorldMorph(341720576) [world]
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1728@1051)
		owner: 	nil
		submorphs: 	an Array(a MenubarMorph(112886016) a TaskbarMorph(279458560) a S[..]
		fullBounds: 	(0@0) corner: (1728@1051)
		color: 	(Color r: 0.9403714565004888 g: 0.9403714565004888 b: 0.940371456500[..]
		extension: 	a MorphExtension (1012946432) [other:  (dragEnabled -> true) (dr[..]
		borderWidth: 	0
		borderColor: 	(Color r: 0.8611925708699902 g: 1.0 b: 0.7223851417399805 alph[..]
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil


WorldState>>doOneCycleFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(341720576) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(337424384))
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap()
		lastStepTime: 	407290
		lastStepMessage: 	nil
		alarms: 	a Heap(MorphicAlarm(#hideShow -> a RubCursor(899173120)))
		lastAlarmTime: 	423969
		activeHand: 	a HandMorph(337424384)
		currentCursor: 	((CursorWithMask
	extent: (16@16)
	depth: 1
	fromArray: #(
	[..]
		worldRenderer: 	an OSWorldRenderer
		realWindowExtent: 	(1728@1051)
		deferredUIMessages: 	WaitfreeQueue with 0 items


WorldMorph>>doOneCycleNow
	Receiver: a WorldMorph(341720576) [world]
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1728@1051)
		owner: 	nil
		submorphs: 	an Array(a MenubarMorph(112886016) a TaskbarMorph(279458560) a S[..]
		fullBounds: 	(0@0) corner: (1728@1051)
		color: 	(Color r: 0.9403714565004888 g: 0.9403714565004888 b: 0.940371456500[..]
		extension: 	a MorphExtension (1012946432) [other:  (dragEnabled -> true) (dr[..]
		borderWidth: 	0
		borderColor: 	(Color r: 0.8611925708699902 g: 1.0 b: 0.7223851417399805 alph[..]
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil


WorldMorph>>doOneCycle
	Receiver: a WorldMorph(341720576) [world]
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1728@1051)
		owner: 	nil
		submorphs: 	an Array(a MenubarMorph(112886016) a TaskbarMorph(279458560) a S[..]
		fullBounds: 	(0@0) corner: (1728@1051)
		color: 	(Color r: 0.9403714565004888 g: 0.9403714565004888 b: 0.940371456500[..]
		extension: 	a MorphExtension (1012946432) [other:  (dragEnabled -> true) (dr[..]
		borderWidth: 	0
		borderColor: 	(Color r: 0.8611925708699902 g: 1.0 b: 0.7223851417399805 alph[..]
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil


[
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMutex critical: [
			                     self extraWorldList ].
		extraWorldsToDraw do: [ :world | world doOneCycle ].

		(self currentWorld isNotNil and: [
			 (extraWorldsToDraw includes: self currentWorld) not ]) ifTrue: [
			self currentWorld doOneCycle ] ] in WorldMorph class>>doOneCycle
	Receiver: WorldMorph
	Arguments and temporary variables: 
		extraWorldsToDraw: 	#()
	Receiver's instance variables: 
		superclass: 	PasteUpMorph
		methodDict: 	a MethodDictionary(#acceptDroppingMorph:event:->WorldMorph>>#ac[..]
		format: 	65547
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		commentSourcePointer: 	nil
		subclasses: 	{AthensWorldMorph. OSWindowWorldMorph}
		name: 	#WorldMorph
		classPool: 	a Dictionary(#AllowDropFiles->nil #CursorOwnerWorld->a WorldMorp[..]
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Morphic-Core-Worlds'
		announcer: 	nil
		displayScaleFactor: 	1


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMutex critical: [
			  [..]
	Arguments and temporary variables: 
		aBlock: 	[
		self doInterCycleWait
	]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	WorldMorph class>>doOneCycle
		compiledBlock: 	a CompiledBlock: [
		| extraWorldsToDraw |
		extraWorldsToDr[..]
		numArgs: 	0
		receiver: 	WorldMorph


WorldState class>>doDrawCycleWith:
	Receiver: WorldState
	Arguments and temporary variables: 
		aBlock: 	[
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMute[..]
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary(#activeHand->WorldState>>#activeHand #active[..]
		format: 	65548
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		commentSourcePointer: 	nil
		subclasses: 	{AthensWorldState}
		name: 	#WorldState
		classPool: 	a Dictionary(#CanSurrenderToOS->nil #DebugShowDamage->false #Des[..]
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Morphic-Core-Worlds'



--- The full stack ---
RSBox(Object)>>doesNotUnderstand: #text:
VisualizerMain>>createSampleGraph
UndefinedObject>>DoIt
OCReceiverDoItSemanticScope(OCDoItSemanticScope)>>evaluateDoIt:
OpalCompiler>>evaluate
[
		self announcer announce: (SpCodeWillBeEvaluatedAnnouncement newContent: aString).
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionModel doItReceiver.
		result := receiver class compiler
			source: aString;
			context: self interactionModel doItContext;
			receiver: self interactionModel doItReceiver;
			requestor: self interactionModel;
			environment: self environment;
			failBlock:  [ 
				self announcer announce: (SpCodeEvaluationFailedAnnouncement newContent: aString).
				^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		self announcer announce: (SpCodeEvaluationSucceedAnnouncement newContent: aString).
		result ] in SpCodePresenter>>evaluate:onCompileError:onError:
FullBlockClosure(BlockClosure)>>on:do:
SpCodePresenter>>evaluate:onCompileError:onError:
StPlaygroundPagePresenter>>doEvaluateAndGo
StPlaygroundPagePresenter>>doEvaluateAllAndGo
StPlaygroundDoItCommand>>execute
SpCommand(CmCommandDecorator)>>execute
[ specCommand execute ] in [ :specCommand | 
			aButtonClass new
				label: specCommand name;
				help: specCommand description;
				in: [ :button | 
					specCommand hasIcon
						ifTrue: [ button icon: specCommand icon ] ];
				action: [ specCommand execute ];
				yourself ] in SpCommand>>configureAsButtonOfClass:
FullBlockClosure(BlockClosure)>>cull:
SpMorphicToolbarButtonAdapter>>execute
SpToolbarButtonMorph(PluggableButtonMorph)>>performAction:
[:m |
		(m containsPoint: evt cursorPoint) ifTrue: [m enabled ifTrue: [ m performAction: evt ]]] in SpToolbarButtonMorph(PluggableButtonMorph)>>mouseUp:
Array(SequenceableCollection)>>do:
SpToolbarButtonMorph(PluggableButtonMorph)>>mouseUp:
SpToolbarButtonMorph(Morph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
SpToolbarButtonMorph(Morph)>>handleEvent:
SpToolbarButtonMorph(Morph)>>handleFocusEvent:
[
		result := focusHolder handleFocusEvent: transformedEvent.
	] in HandMorph>>sendFocusEvent:to:clear:
FullBlockClosure(BlockClosure)>>on:do:
WorldMorph>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil ]) ifTrue: [
			morphicWorld activeHand handleEvent: anEvent
		]
	] in OSWindowMorphicEventHandler>>dispatchMorphicEvent:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycleNow
WorldMorph>>doOneCycle
[
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMutex critical: [
			                     self extraWorldList ].
		extraWorldsToDraw do: [ :world | world doOneCycle ].

		(self currentWorld isNotNil and: [
			 (extraWorldsToDraw includes: self currentWorld) not ]) ifTrue: [
			self currentWorld doOneCycle ] ] in WorldMorph class>>doOneCycle
FullBlockClosure(BlockClosure)>>ensure:
WorldState class>>doDrawCycleWith:
 - - - - - - - - - - - - - - -
			- - - - - - - - - - - - - - - - - -
WorldMorph class>>doOneCycle
MorphicRenderLoop>>doOneCycle
MorphicRenderLoop>>doOneCycleWhile:
[ MorphicRenderLoop new doOneCycleWhile: [ true ] ] in MorphicUIManager>>spawnNewProcess
[self value.
			"IMPORTANT: Do not step over next line of code. See method comments for details"
			Processor terminateRealActive] in FullBlockClosure(BlockClosure)>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
Instance of RSBox did not understand #center
24 October 2023 9:44:56.121025 am

VM: Mac OS - arm64 - 1000 - CoInterpreter VMMaker-tonel.1 uuid: 902dd483-c0c4-0d00-86f2-0f880df24b96 Oct 23 2023
StackToRegisterMappingCogit VMMaker-tonel.1 uuid: 902dd483-c0c4-0d00-86f2-0f880df24b96 Oct 23 2023
v10.0.8 - Commit: b323c5fb - Date: 2023-10-20 16:02:07 -0400

Image: Pharo11.0.0 [Build information: Pharo-11.0.0+build.710.sha.ea28d8552cac85a7ce1e9c34ab1e7bd45f7b9910 (64 Bit)]

RSBox(Object)>>doesNotUnderstand: #center
	Receiver: a RSBox
	Arguments and temporary variables: 
		aMessage: 	center
		exception: 	Instance of RSBox did not understand #center
		resumeValue: 	nil
	Receiver's instance variables: 
		announcer: 	nil
		properties: 	nil
		paint: 	Color blue
		path: 	(-25.0@ -25.0) corner: (25.0@25.0)
		border: 	nil
		parent: 	a RSCanvas
		isFixed: 	false
		encompassingRectangle: 	nil
		model: 	nil
		baseRectangle: 	(-25.0@ -25.0) corner: (25.0@25.0)
		matrix: 	x: 0.0 y: 0.0 sx: 1.0 sy: 1.0 shx: 0.0 shy: 0.0
		connectedLines: 	nil
		shouldUpdateLines: 	true
		cornerRadius: 	nil


VisualizerMain>>createSampleGraph
	Receiver: a VisualizerMain
	Arguments and temporary variables: 
		view: 	a RSCanvas
		alice: 	a RSBox
		bob: 	a RSBox
		aliceLabel: 	a RSLabel
		bobLabel: 	a RSLabel
	Receiver's instance variables: 
a VisualizerMain

UndefinedObject>>DoIt
	Receiver: nil
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
nil

OCReceiverDoItSemanticScope(OCDoItSemanticScope)>>evaluateDoIt:
	Receiver: an OCReceiverDoItSemanticScope
	Arguments and temporary variables: 
		doItMethod: 	UndefinedObject>>#DoIt
	Receiver's instance variables: 
		outerScope: 	nil
		targetReceiver: 	nil


OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
		doItMethod: 	UndefinedObject>>#DoIt
	Receiver's instance variables: 
		ast: 	DoIt

	^ VisualizerMain new createSampleGraph open
		source: 	a ReadStream
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil


[
		self announcer announce: (SpCodeWillBeEvaluatedAnnouncement newContent: aString).
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionModel doItReceiver.
		result := receiver class compiler
			source: aString;
			context: self interactionModel doItContext;
			receiver: self interactionModel doItReceiver;
			requestor: self interactionModel;
			environment: self environment;
			failBlock:  [ 
				self announcer announce: (SpCodeEvaluationFailedAnnouncement newContent: aString).
				^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		self announcer announce: (SpCodeEvaluationSucceedAnnouncement newContent: aString).
		result ] in SpCodePresenter>>evaluate:onCompileError:onError:
	Receiver: a SpCodePresenter
	Arguments and temporary variables: 
		aString: 	'(VisualizerMain new createSampleGraph) open.
'
		compileErrorBlock: 	[ ^ self ]
		errorBlock: 	[ :e | e pass ]
		receiver: 	nil
		result: 	nil
		oldBindings: 	a Dictionary()
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicCodeAdapter)
		announcer: 	an Announcer
		owner: 	a StPlaygroundPagePresenter
		adapter: 	a SpMorphicCodeAdapter
		needRebuild: 	true
		eventHandler: 	a SpEventHandler
		application: 	nil
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ a KMCategory ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Code' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpAbstractWidgetLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		borderWidth: 	an ObservableValueHolder[ nil ]
		borderColor: 	an ObservableValueHolder[ nil ]
		dragEnabled: 	an ObservableValueHolder[ false ]
		dropEnabled: 	an ObservableValueHolder[ false ]
		color: 	an ObservableValueHolder[ nil ]
		help: 	an ObservableValueHolder[ nil ]
		enabled: 	an ObservableValueHolder[ true ]
		wantsDrop: 	an ObservableValueHolder[ [ :transfer | self dropEnabled ] ]
		acceptDrop: 	an ObservableValueHolder[ [ :transfer | ] ]
		deferredActions: 	nil
		hasUnacceptedEdits: 	an ObservableValueHolder[ false ]
		selection: 	an ObservableValueHolder[ (1 to: 45) ]
		wantsVisualFeedback: 	an ObservableValueHolder[ true ]
		askBeforeDiscardingEdits: 	an ObservableValueHolder[ true ]
		text: 	an ObservableValueHolder[ '(VisualizerMain new createSampleGraph) ope[..]
		actionToPerform: 	an ObservableValueHolder[ [ :txt |  ] ]
		readSelection: 	an ObservableValueHolder[ [ selection ] ]
		placeholder: 	an ObservableValueHolder[ '' ]
		contextMenu: 	an ObservableValueHolder[ [ (self menuActionsFor: text) asMenu[..]
		scrollValue: 	an ObservableValueHolder[ (0@0) ]
		editionContextMenu: 	an ObservableValueHolder[ true ]
		editable: 	an ObservableValueHolder[ true ]
		wrapWord: 	an ObservableValueHolder[ true ]
		undoRedoHistory: 	true
		wrapScrollBars: 	true
		propagateNaturalHeight: 	false
		propagateNaturalWidth: 	false
		scrollBarStyles: 	#()
		syntaxHighlight: 	an ObservableValueHolder[ true ]
		smartCharacters: 	an ObservableValueHolder[ true ]
		lineNumbers: 	an ObservableValueHolder[ true ]
		interactionModel: 	an ObservableValueHolder[ a StPlaygroundInteractionModel ]
		overrideContextMenu: 	true
		submitBlock: 	nil
		resetBlock: 	nil
		environment: 	nil
		systemNavigation: 	nil
		syntaxHighlightTheme: 	an ObservableValueHolder[ nil ]


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
		self announcer announce: (SpCodeWillBeEvaluatedAnnouncement newContent: aString).
[..]
	Arguments and temporary variables: 
		exception: 	Error
		handlerAction: 	[ :e |
		self announcer announce: (SpCodeEvaluationFailedAnn[..]
	Receiver's instance variables: 
		outerContext: 	SpCodePresenter>>evaluate:onCompileError:onError:
		compiledBlock: 	a CompiledBlock: [
		self announcer announce: (SpCodeWillBeE[..]
		numArgs: 	0
		receiver: 	a SpCodePresenter


SpCodePresenter>>evaluate:onCompileError:onError:
	Receiver: a SpCodePresenter
	Arguments and temporary variables: 
		receiver: 	nil
		result: 	nil
		oldBindings: 	a Dictionary()
		aString: 	'(VisualizerMain new createSampleGraph) open.
'
		compileErrorBlock: 	[ ^ self ]
		errorBlock: 	[ :e | e pass ]
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicCodeAdapter)
		announcer: 	an Announcer
		owner: 	a StPlaygroundPagePresenter
		adapter: 	a SpMorphicCodeAdapter
		needRebuild: 	true
		eventHandler: 	a SpEventHandler
		application: 	nil
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ a KMCategory ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Code' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpAbstractWidgetLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		borderWidth: 	an ObservableValueHolder[ nil ]
		borderColor: 	an ObservableValueHolder[ nil ]
		dragEnabled: 	an ObservableValueHolder[ false ]
		dropEnabled: 	an ObservableValueHolder[ false ]
		color: 	an ObservableValueHolder[ nil ]
		help: 	an ObservableValueHolder[ nil ]
		enabled: 	an ObservableValueHolder[ true ]
		wantsDrop: 	an ObservableValueHolder[ [ :transfer | self dropEnabled ] ]
		acceptDrop: 	an ObservableValueHolder[ [ :transfer | ] ]
		deferredActions: 	nil
		hasUnacceptedEdits: 	an ObservableValueHolder[ false ]
		selection: 	an ObservableValueHolder[ (1 to: 45) ]
		wantsVisualFeedback: 	an ObservableValueHolder[ true ]
		askBeforeDiscardingEdits: 	an ObservableValueHolder[ true ]
		text: 	an ObservableValueHolder[ '(VisualizerMain new createSampleGraph) ope[..]
		actionToPerform: 	an ObservableValueHolder[ [ :txt |  ] ]
		readSelection: 	an ObservableValueHolder[ [ selection ] ]
		placeholder: 	an ObservableValueHolder[ '' ]
		contextMenu: 	an ObservableValueHolder[ [ (self menuActionsFor: text) asMenu[..]
		scrollValue: 	an ObservableValueHolder[ (0@0) ]
		editionContextMenu: 	an ObservableValueHolder[ true ]
		editable: 	an ObservableValueHolder[ true ]
		wrapWord: 	an ObservableValueHolder[ true ]
		undoRedoHistory: 	true
		wrapScrollBars: 	true
		propagateNaturalHeight: 	false
		propagateNaturalWidth: 	false
		scrollBarStyles: 	#()
		syntaxHighlight: 	an ObservableValueHolder[ true ]
		smartCharacters: 	an ObservableValueHolder[ true ]
		lineNumbers: 	an ObservableValueHolder[ true ]
		interactionModel: 	an ObservableValueHolder[ a StPlaygroundInteractionModel ]
		overrideContextMenu: 	true
		submitBlock: 	nil
		resetBlock: 	nil
		environment: 	nil
		systemNavigation: 	nil
		syntaxHighlightTheme: 	an ObservableValueHolder[ nil ]


StPlaygroundPagePresenter>>doEvaluateAndGo
	Receiver: a StPlaygroundPagePresenter
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicBoxAdapter)
		announcer: 	an Announcer
		owner: 	a SpMillerColumnPresenter
		adapter: 	a SpMorphicBoxAdapter
		needRebuild: 	true
		eventHandler: 	nil
		application: 	a StPharoApplication
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ nil ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Untitled window' ]
		additionalSubpresentersMap: 	a Dictionary()
		layout: 	an ObservableValueHolder[ a SpBoxLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		text: 	a SpCodePresenter
		toolbar: 	a SpToolbarPresenter
		statusbar: 	a SpPresenter
		lineLabel: 	a SpLabelPresenter
		toggleLineNumberButton: 	a SpToggleButtonPresenter
		page: 	a StPlaygroundPage
		activationBlock: 	[ :selection |
		self changeSelection: selection from: new[..]


StPlaygroundPagePresenter>>doEvaluateAllAndGo
	Receiver: a StPlaygroundPagePresenter
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicBoxAdapter)
		announcer: 	an Announcer
		owner: 	a SpMillerColumnPresenter
		adapter: 	a SpMorphicBoxAdapter
		needRebuild: 	true
		eventHandler: 	nil
		application: 	a StPharoApplication
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ nil ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Untitled window' ]
		additionalSubpresentersMap: 	a Dictionary()
		layout: 	an ObservableValueHolder[ a SpBoxLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		text: 	a SpCodePresenter
		toolbar: 	a SpToolbarPresenter
		statusbar: 	a SpPresenter
		lineLabel: 	a SpLabelPresenter
		toggleLineNumberButton: 	a SpToggleButtonPresenter
		page: 	a StPlaygroundPage
		activationBlock: 	[ :selection |
		self changeSelection: selection from: new[..]


StPlaygroundDoItCommand>>execute
	Receiver: a StPlaygroundDoItCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		context: 	a StPlaygroundPagePresenter
		basicName: 	'Do it'
		basicDescription: 	'Do it all and inspect.'


SpCommand(CmCommandDecorator)>>execute
	Receiver: a SpCommand(Do it)
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a StPlaygroundDoItCommand
		iconProvider: 	a StPharoApplication
		iconName: 	#glamorousGo
		shortcutKey: 	nil
		displayStrategy: 	a CmUIDisableWhenCantBeRun
		positionStrategy: 	a CmUILeftPositionStrategy
		buildPresenterBlock: 	[ :specCommand | 
			aButtonClass new
				label: specC[..]
		presenter: 	a SpToolbarButtonPresenter


[ specCommand execute ] in [ :specCommand | 
			aButtonClass new
				label: specCommand name;
				help: specCommand description;
				in: [ :button | 
					specCommand hasIcon
						ifTrue: [ button icon: specCommand icon ] ];
				action: [ specCommand execute ];
				yourself ] in SpCommand>>configureAsButtonOfClass:
	Receiver: a SpCommand(Do it)
	Arguments and temporary variables: 
		aButtonClass: 	nil
		specCommand: 	a SpCommand(Do it)
	Receiver's instance variables: 
		decoratedCommand: 	a StPlaygroundDoItCommand
		iconProvider: 	a StPharoApplication
		iconName: 	#glamorousGo
		shortcutKey: 	nil
		displayStrategy: 	a CmUIDisableWhenCantBeRun
		positionStrategy: 	a CmUILeftPositionStrategy
		buildPresenterBlock: 	[ :specCommand | 
			aButtonClass new
				label: specC[..]
		presenter: 	a SpToolbarButtonPresenter


FullBlockClosure(BlockClosure)>>cull:
	Receiver: [ specCommand execute ]
	Arguments and temporary variables: 
		anArg: 	a SpToolbarButtonPresenter
	Receiver's instance variables: 
		outerContext: 	[ :specCommand | 
			aButtonClass new
				label: specCommand [..]
		compiledBlock: 	a CompiledBlock: [ specCommand execute ]
		numArgs: 	0
		receiver: 	a SpCommand(Do it)


SpMorphicToolbarButtonAdapter>>execute
	Receiver: a SpMorphicToolbarButtonAdapter
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpToolbarButtonMorph(888790016))
		announcer: 	nil
		model: 	a SpToolbarButtonPresenter
		widget: 	a SpToolbarButtonMorph(888790016)
		selector: 	nil
		owner: 	a SpToolbarButtonPresenter
		unsubscribed: 	false


SpToolbarButtonMorph(PluggableButtonMorph)>>performAction:
	Receiver: a SpToolbarButtonMorph(888790016)
	Arguments and temporary variables: 
		event: 	[(20.0@28.0) mouseUp 35561039 nil]
	Receiver's instance variables: 
		bounds: 	(0.0@5.0) corner: (45.0@39.0)
		owner: 	a Morph(1073167616)
		submorphs: 	an Array(an AlignmentMorph(116792320))
		fullBounds: 	nil
		color: 	(Color r: 0.9012707722385142 g: 0.9012707722385142 b: 0.901270772238[..]
		extension: 	a MorphExtension (509491200) [balloonText]  [other:  (presenter [..]
		borderWidth: 	0
		borderColor: 	#simple
		model: 	a SpMorphicToolbarButtonAdapter
		label: 	'Do it'
		icon: 	Form(13x13x32)
		getIconSelector: 	#icon
		getStateSelector: 	#state
		actionSelector: 	#execute
		font: 	a LogicalFont
 familyName: 'Source Sans Pro'
 emphasis: nil
 pointSiz[..]
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	nil
		getFontSelector: 	nil
		labelMorph: 	a LabelMorph(128736768)'Do it'
		iconMorph: 	an ImageMorph(1001562624)
		iconPosition: 	#top
		lastState: 	false
		badgeFont: 	nil
		badgeSelector: 	#badge


[:m |
		(m containsPoint: evt cursorPoint) ifTrue: [m enabled ifTrue: [ m performAction: evt ]]] in SpToolbarButtonMorph(PluggableButtonMorph)>>mouseUp:
	Receiver: a SpToolbarButtonMorph(888790016)
	Arguments and temporary variables: 
		evt: 	[(20.0@28.0) mouseUp 35561039 nil]
		all: 	an Array(a SpToolbarButtonMorph(888790016) a SpToolbarButtonMorph(2143[..]
		m: 	a SpToolbarButtonMorph(888790016)
	Receiver's instance variables: 
		bounds: 	(0.0@5.0) corner: (45.0@39.0)
		owner: 	a Morph(1073167616)
		submorphs: 	an Array(an AlignmentMorph(116792320))
		fullBounds: 	nil
		color: 	(Color r: 0.9012707722385142 g: 0.9012707722385142 b: 0.901270772238[..]
		extension: 	a MorphExtension (509491200) [balloonText]  [other:  (presenter [..]
		borderWidth: 	0
		borderColor: 	#simple
		model: 	a SpMorphicToolbarButtonAdapter
		label: 	'Do it'
		icon: 	Form(13x13x32)
		getIconSelector: 	#icon
		getStateSelector: 	#state
		actionSelector: 	#execute
		font: 	a LogicalFont
 familyName: 'Source Sans Pro'
 emphasis: nil
 pointSiz[..]
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	nil
		getFontSelector: 	nil
		labelMorph: 	a LabelMorph(128736768)'Do it'
		iconMorph: 	an ImageMorph(1001562624)
		iconPosition: 	#top
		lastState: 	false
		badgeFont: 	nil
		badgeSelector: 	#badge


Array(SequenceableCollection)>>do:
	Receiver: an Array(a SpToolbarButtonMorph(888790016) a SpToolbarButtonMorph(214329088) a SpToolb[..]
	Arguments and temporary variables: 
		aBlock: 	[:m |
		(m containsPoint: evt cursorPoint) ifTrue: [m enabled ifTru[..]
		index: 	1
	Receiver's instance variables: 
an Array(a SpToolbarButtonMorph(888790016) a SpToolbarButtonMorph(214329088) a SpToolb[..]

SpToolbarButtonMorph(PluggableButtonMorph)>>mouseUp:
	Receiver: a SpToolbarButtonMorph(888790016)
	Arguments and temporary variables: 
		evt: 	[(20.0@28.0) mouseUp 35561039 nil]
		all: 	an Array(a SpToolbarButtonMorph(888790016) a SpToolbarButtonMorph(2143[..]
	Receiver's instance variables: 
		bounds: 	(0.0@5.0) corner: (45.0@39.0)
		owner: 	a Morph(1073167616)
		submorphs: 	an Array(an AlignmentMorph(116792320))
		fullBounds: 	nil
		color: 	(Color r: 0.9012707722385142 g: 0.9012707722385142 b: 0.901270772238[..]
		extension: 	a MorphExtension (509491200) [balloonText]  [other:  (presenter [..]
		borderWidth: 	0
		borderColor: 	#simple
		model: 	a SpMorphicToolbarButtonAdapter
		label: 	'Do it'
		icon: 	Form(13x13x32)
		getIconSelector: 	#icon
		getStateSelector: 	#state
		actionSelector: 	#execute
		font: 	a LogicalFont
 familyName: 'Source Sans Pro'
 emphasis: nil
 pointSiz[..]
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	nil
		getFontSelector: 	nil
		labelMorph: 	a LabelMorph(128736768)'Do it'
		iconMorph: 	an ImageMorph(1001562624)
		iconPosition: 	#top
		lastState: 	false
		badgeFont: 	nil
		badgeSelector: 	#badge


SpToolbarButtonMorph(Morph)>>handleMouseUp:
	Receiver: a SpToolbarButtonMorph(888790016)
	Arguments and temporary variables: 
		anEvent: 	[(20.0@28.0) mouseUp 35561039 nil]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(0.0@5.0) corner: (45.0@39.0)
		owner: 	a Morph(1073167616)
		submorphs: 	an Array(an AlignmentMorph(116792320))
		fullBounds: 	nil
		color: 	(Color r: 0.9012707722385142 g: 0.9012707722385142 b: 0.901270772238[..]
		extension: 	a MorphExtension (509491200) [balloonText]  [other:  (presenter [..]
		borderWidth: 	0
		borderColor: 	#simple
		model: 	a SpMorphicToolbarButtonAdapter
		label: 	'Do it'
		icon: 	Form(13x13x32)
		getIconSelector: 	#icon
		getStateSelector: 	#state
		actionSelector: 	#execute
		font: 	a LogicalFont
 familyName: 'Source Sans Pro'
 emphasis: nil
 pointSiz[..]
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	nil
		getFontSelector: 	nil
		labelMorph: 	a LabelMorph(128736768)'Do it'
		iconMorph: 	an ImageMorph(1001562624)
		iconPosition: 	#top
		lastState: 	false
		badgeFont: 	nil
		badgeSelector: 	#badge


MouseButtonEvent>>sentTo:
	Receiver: [(20.0@28.0) mouseUp 35561039 nil]
	Arguments and temporary variables: 
		anObject: 	a SpToolbarButtonMorph(888790016)
	Receiver's instance variables: 
		timeStamp: 	35561039
		source: 	a HandMorph(337424384)
		windowIndex: 	nil
		type: 	#mouseUp
		buttons: 	0
		position: 	(20.0@28.0)
		handler: 	nil
		wasHandled: 	true
		whichButton: 	4


SpToolbarButtonMorph(Morph)>>handleEvent:
	Receiver: a SpToolbarButtonMorph(888790016)
	Arguments and temporary variables: 
		anEvent: 	[(20.0@28.0) mouseUp 35561039 nil]
	Receiver's instance variables: 
		bounds: 	(0.0@5.0) corner: (45.0@39.0)
		owner: 	a Morph(1073167616)
		submorphs: 	an Array(an AlignmentMorph(116792320))
		fullBounds: 	nil
		color: 	(Color r: 0.9012707722385142 g: 0.9012707722385142 b: 0.901270772238[..]
		extension: 	a MorphExtension (509491200) [balloonText]  [other:  (presenter [..]
		borderWidth: 	0
		borderColor: 	#simple
		model: 	a SpMorphicToolbarButtonAdapter
		label: 	'Do it'
		icon: 	Form(13x13x32)
		getIconSelector: 	#icon
		getStateSelector: 	#state
		actionSelector: 	#execute
		font: 	a LogicalFont
 familyName: 'Source Sans Pro'
 emphasis: nil
 pointSiz[..]
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	nil
		getFontSelector: 	nil
		labelMorph: 	a LabelMorph(128736768)'Do it'
		iconMorph: 	an ImageMorph(1001562624)
		iconPosition: 	#top
		lastState: 	false
		badgeFont: 	nil
		badgeSelector: 	#badge


SpToolbarButtonMorph(Morph)>>handleFocusEvent:
	Receiver: a SpToolbarButtonMorph(888790016)
	Arguments and temporary variables: 
		anEvent: 	[(20.0@28.0) mouseUp 35561039 nil]
	Receiver's instance variables: 
		bounds: 	(0.0@5.0) corner: (45.0@39.0)
		owner: 	a Morph(1073167616)
		submorphs: 	an Array(an AlignmentMorph(116792320))
		fullBounds: 	nil
		color: 	(Color r: 0.9012707722385142 g: 0.9012707722385142 b: 0.901270772238[..]
		extension: 	a MorphExtension (509491200) [balloonText]  [other:  (presenter [..]
		borderWidth: 	0
		borderColor: 	#simple
		model: 	a SpMorphicToolbarButtonAdapter
		label: 	'Do it'
		icon: 	Form(13x13x32)
		getIconSelector: 	#icon
		getStateSelector: 	#state
		actionSelector: 	#execute
		font: 	a LogicalFont
 familyName: 'Source Sans Pro'
 emphasis: nil
 pointSiz[..]
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	nil
		getFontSelector: 	nil
		labelMorph: 	a LabelMorph(128736768)'Do it'
		iconMorph: 	an ImageMorph(1001562624)
		iconPosition: 	#top
		lastState: 	false
		badgeFont: 	nil
		badgeSelector: 	#badge


[
		result := focusHolder handleFocusEvent: transformedEvent.
	] in HandMorph>>sendFocusEvent:to:clear:
	Receiver: a HandMorph(337424384)
	Arguments and temporary variables: 
		anEvent: 	[(398@270) mouseUp 35561039 nil]
		focusHolder: 	a SpToolbarButtonMorph(888790016)
		aBlock: 	[self mouseFocus: nil]
		w: 	a WorldMorph(341720576) [world]
		transformedEvent: 	[(20.0@28.0) mouseUp 35561039 nil]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(398@270.0) corner: (414@286.0)
		owner: 	a WorldMorph(341720576) [world]
		submorphs: 	#()
		fullBounds: 	(398@270.0) corner: (414@286.0)
		color: 	Color blue
		extension: 	a MorphExtension (370611968)
		mouseFocus: 	nil
		keyboardFocus: 	a RubEditingArea(919167488)
		eventListeners: 	nil
		mouseListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(398@270) mouseUp 35561039 nil]
		targetOffset: 	(20.0@23.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 0 0 0 0 0 nil nil)
		captureBlock: 	nil
		recentModifiers: 	0
		pendingEventQueue: 	WaitfreeQueue with 0 items
		supressNextKeyPress: 	false


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
		result := focusHolder handleFocusEvent: transformedEvent.
	]
	Arguments and temporary variables: 
		exception: 	Error
		handlerAction: 	[ :ex |
			ActiveWorld := priorWorld.
			ex pass ]
	Receiver's instance variables: 
		outerContext: 	HandMorph>>sendFocusEvent:to:clear:
		compiledBlock: 	a CompiledBlock: [
		result := focusHolder handleFocusEvent:[..]
		numArgs: 	0
		receiver: 	a HandMorph(337424384)


WorldMorph>>becomeActiveDuring:
	Receiver: a WorldMorph(341720576) [world]
	Arguments and temporary variables: 
		aBlock: 	[
		result := focusHolder handleFocusEvent: transformedEvent.
	]
		priorWorld: 	a WorldMorph(341720576) [world]
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1728@1051)
		owner: 	nil
		submorphs: 	an Array(a MenubarMorph(112886016) a TaskbarMorph(279458560) a S[..]
		fullBounds: 	nil
		color: 	(Color r: 0.9403714565004888 g: 0.9403714565004888 b: 0.940371456500[..]
		extension: 	a MorphExtension (1012946432) [other:  (dragEnabled -> true) (dr[..]
		borderWidth: 	0
		borderColor: 	(Color r: 0.8611925708699902 g: 1.0 b: 0.7223851417399805 alph[..]
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil


HandMorph>>sendFocusEvent:to:clear:
	Receiver: a HandMorph(337424384)
	Arguments and temporary variables: 
		result: 	nil
		anEvent: 	[(398@270) mouseUp 35561039 nil]
		focusHolder: 	a SpToolbarButtonMorph(888790016)
		aBlock: 	[self mouseFocus: nil]
		w: 	a WorldMorph(341720576) [world]
		transformedEvent: 	[(20.0@28.0) mouseUp 35561039 nil]
	Receiver's instance variables: 
		bounds: 	(398@270.0) corner: (414@286.0)
		owner: 	a WorldMorph(341720576) [world]
		submorphs: 	#()
		fullBounds: 	(398@270.0) corner: (414@286.0)
		color: 	Color blue
		extension: 	a MorphExtension (370611968)
		mouseFocus: 	nil
		keyboardFocus: 	a RubEditingArea(919167488)
		eventListeners: 	nil
		mouseListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(398@270) mouseUp 35561039 nil]
		targetOffset: 	(20.0@23.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 0 0 0 0 0 nil nil)
		captureBlock: 	nil
		recentModifiers: 	0
		pendingEventQueue: 	WaitfreeQueue with 0 items
		supressNextKeyPress: 	false


HandMorph>>sendEvent:focus:clear:
	Receiver: a HandMorph(337424384)
	Arguments and temporary variables: 
		anEvent: 	[(398@270) mouseUp 35561039 nil]
		focusHolder: 	a SpToolbarButtonMorph(888790016)
		aBlock: 	[self mouseFocus: nil]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(398@270.0) corner: (414@286.0)
		owner: 	a WorldMorph(341720576) [world]
		submorphs: 	#()
		fullBounds: 	(398@270.0) corner: (414@286.0)
		color: 	Color blue
		extension: 	a MorphExtension (370611968)
		mouseFocus: 	nil
		keyboardFocus: 	a RubEditingArea(919167488)
		eventListeners: 	nil
		mouseListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(398@270) mouseUp 35561039 nil]
		targetOffset: 	(20.0@23.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 0 0 0 0 0 nil nil)
		captureBlock: 	nil
		recentModifiers: 	0
		pendingEventQueue: 	WaitfreeQueue with 0 items
		supressNextKeyPress: 	false


HandMorph>>sendMouseEvent:
	Receiver: a HandMorph(337424384)
	Arguments and temporary variables: 
		anEvent: 	[(398@270) mouseUp 35561039 nil]
	Receiver's instance variables: 
		bounds: 	(398@270.0) corner: (414@286.0)
		owner: 	a WorldMorph(341720576) [world]
		submorphs: 	#()
		fullBounds: 	(398@270.0) corner: (414@286.0)
		color: 	Color blue
		extension: 	a MorphExtension (370611968)
		mouseFocus: 	nil
		keyboardFocus: 	a RubEditingArea(919167488)
		eventListeners: 	nil
		mouseListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(398@270) mouseUp 35561039 nil]
		targetOffset: 	(20.0@23.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 0 0 0 0 0 nil nil)
		captureBlock: 	nil
		recentModifiers: 	0
		pendingEventQueue: 	WaitfreeQueue with 0 items
		supressNextKeyPress: 	false


HandMorph>>handleEvent:
	Receiver: a HandMorph(337424384)
	Arguments and temporary variables: 
		anEvent: 	[(398@270) mouseUp 35561039 nil]
		evt: 	[(398@270) mouseUp 35561039 nil]
	Receiver's instance variables: 
		bounds: 	(398@270.0) corner: (414@286.0)
		owner: 	a WorldMorph(341720576) [world]
		submorphs: 	#()
		fullBounds: 	(398@270.0) corner: (414@286.0)
		color: 	Color blue
		extension: 	a MorphExtension (370611968)
		mouseFocus: 	nil
		keyboardFocus: 	a RubEditingArea(919167488)
		eventListeners: 	nil
		mouseListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(398@270) mouseUp 35561039 nil]
		targetOffset: 	(20.0@23.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 0 0 0 0 0 nil nil)
		captureBlock: 	nil
		recentModifiers: 	0
		pendingEventQueue: 	WaitfreeQueue with 0 items
		supressNextKeyPress: 	false


[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil ]) ifTrue: [
			morphicWorld activeHand handleEvent: anEvent
		]
	] in OSWindowMorphicEventHandler>>dispatchMorphicEvent:
	Receiver: an OSWindowMorphicEventHandler
	Arguments and temporary variables: 
		anEvent: 	[(398@270) mouseUp 35561039 nil]
	Receiver's instance variables: 
		morphicWorld: 	a WorldMorph(341720576) [world]


WorldState>>runStepMethodsIn:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(341720576) [world]
		queue: 	WaitfreeQueue with 0 items
		nextInQueue: 	[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNo[..]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(337424384))
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap()
		lastStepTime: 	35560931
		lastStepMessage: 	nil
		alarms: 	a Heap(MorphicAlarm(#hideShow -> a RubCursor(899173120)))
		lastAlarmTime: 	35561026
		activeHand: 	a HandMorph(337424384)
		currentCursor: 	((CursorWithMask
	extent: (16@16)
	depth: 1
	fromArray: #(
	[..]
		worldRenderer: 	an OSWorldRenderer
		realWindowExtent: 	(1728@1051)
		deferredUIMessages: 	WaitfreeQueue with 0 items


WorldMorph>>runStepMethods
	Receiver: a WorldMorph(341720576) [world]
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1728@1051)
		owner: 	nil
		submorphs: 	an Array(a MenubarMorph(112886016) a TaskbarMorph(279458560) a S[..]
		fullBounds: 	nil
		color: 	(Color r: 0.9403714565004888 g: 0.9403714565004888 b: 0.940371456500[..]
		extension: 	a MorphExtension (1012946432) [other:  (dragEnabled -> true) (dr[..]
		borderWidth: 	0
		borderColor: 	(Color r: 0.8611925708699902 g: 1.0 b: 0.7223851417399805 alph[..]
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil


WorldState>>doOneCycleFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(341720576) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(337424384))
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap()
		lastStepTime: 	35560931
		lastStepMessage: 	nil
		alarms: 	a Heap(MorphicAlarm(#hideShow -> a RubCursor(899173120)))
		lastAlarmTime: 	35561026
		activeHand: 	a HandMorph(337424384)
		currentCursor: 	((CursorWithMask
	extent: (16@16)
	depth: 1
	fromArray: #(
	[..]
		worldRenderer: 	an OSWorldRenderer
		realWindowExtent: 	(1728@1051)
		deferredUIMessages: 	WaitfreeQueue with 0 items


WorldMorph>>doOneCycleNow
	Receiver: a WorldMorph(341720576) [world]
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1728@1051)
		owner: 	nil
		submorphs: 	an Array(a MenubarMorph(112886016) a TaskbarMorph(279458560) a S[..]
		fullBounds: 	nil
		color: 	(Color r: 0.9403714565004888 g: 0.9403714565004888 b: 0.940371456500[..]
		extension: 	a MorphExtension (1012946432) [other:  (dragEnabled -> true) (dr[..]
		borderWidth: 	0
		borderColor: 	(Color r: 0.8611925708699902 g: 1.0 b: 0.7223851417399805 alph[..]
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil


WorldMorph>>doOneCycle
	Receiver: a WorldMorph(341720576) [world]
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1728@1051)
		owner: 	nil
		submorphs: 	an Array(a MenubarMorph(112886016) a TaskbarMorph(279458560) a S[..]
		fullBounds: 	nil
		color: 	(Color r: 0.9403714565004888 g: 0.9403714565004888 b: 0.940371456500[..]
		extension: 	a MorphExtension (1012946432) [other:  (dragEnabled -> true) (dr[..]
		borderWidth: 	0
		borderColor: 	(Color r: 0.8611925708699902 g: 1.0 b: 0.7223851417399805 alph[..]
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil


[
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMutex critical: [
			                     self extraWorldList ].
		extraWorldsToDraw do: [ :world | world doOneCycle ].

		(self currentWorld isNotNil and: [
			 (extraWorldsToDraw includes: self currentWorld) not ]) ifTrue: [
			self currentWorld doOneCycle ] ] in WorldMorph class>>doOneCycle
	Receiver: WorldMorph
	Arguments and temporary variables: 
		extraWorldsToDraw: 	#()
	Receiver's instance variables: 
		superclass: 	PasteUpMorph
		methodDict: 	a MethodDictionary(#acceptDroppingMorph:event:->WorldMorph>>#ac[..]
		format: 	65547
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		commentSourcePointer: 	nil
		subclasses: 	{AthensWorldMorph. OSWindowWorldMorph}
		name: 	#WorldMorph
		classPool: 	a Dictionary(#AllowDropFiles->nil #CursorOwnerWorld->a WorldMorp[..]
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Morphic-Core-Worlds'
		announcer: 	nil
		displayScaleFactor: 	1


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMutex critical: [
			  [..]
	Arguments and temporary variables: 
		aBlock: 	[
		self doInterCycleWait
	]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	WorldMorph class>>doOneCycle
		compiledBlock: 	a CompiledBlock: [
		| extraWorldsToDraw |
		extraWorldsToDr[..]
		numArgs: 	0
		receiver: 	WorldMorph


WorldState class>>doDrawCycleWith:
	Receiver: WorldState
	Arguments and temporary variables: 
		aBlock: 	[
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMute[..]
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary(#activeHand->WorldState>>#activeHand #active[..]
		format: 	65548
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		commentSourcePointer: 	nil
		subclasses: 	{AthensWorldState}
		name: 	#WorldState
		classPool: 	a Dictionary(#CanSurrenderToOS->nil #DebugShowDamage->false #Des[..]
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Morphic-Core-Worlds'



--- The full stack ---
RSBox(Object)>>doesNotUnderstand: #center
VisualizerMain>>createSampleGraph
UndefinedObject>>DoIt
OCReceiverDoItSemanticScope(OCDoItSemanticScope)>>evaluateDoIt:
OpalCompiler>>evaluate
[
		self announcer announce: (SpCodeWillBeEvaluatedAnnouncement newContent: aString).
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionModel doItReceiver.
		result := receiver class compiler
			source: aString;
			context: self interactionModel doItContext;
			receiver: self interactionModel doItReceiver;
			requestor: self interactionModel;
			environment: self environment;
			failBlock:  [ 
				self announcer announce: (SpCodeEvaluationFailedAnnouncement newContent: aString).
				^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		self announcer announce: (SpCodeEvaluationSucceedAnnouncement newContent: aString).
		result ] in SpCodePresenter>>evaluate:onCompileError:onError:
FullBlockClosure(BlockClosure)>>on:do:
SpCodePresenter>>evaluate:onCompileError:onError:
StPlaygroundPagePresenter>>doEvaluateAndGo
StPlaygroundPagePresenter>>doEvaluateAllAndGo
StPlaygroundDoItCommand>>execute
SpCommand(CmCommandDecorator)>>execute
[ specCommand execute ] in [ :specCommand | 
			aButtonClass new
				label: specCommand name;
				help: specCommand description;
				in: [ :button | 
					specCommand hasIcon
						ifTrue: [ button icon: specCommand icon ] ];
				action: [ specCommand execute ];
				yourself ] in SpCommand>>configureAsButtonOfClass:
FullBlockClosure(BlockClosure)>>cull:
SpMorphicToolbarButtonAdapter>>execute
SpToolbarButtonMorph(PluggableButtonMorph)>>performAction:
[:m |
		(m containsPoint: evt cursorPoint) ifTrue: [m enabled ifTrue: [ m performAction: evt ]]] in SpToolbarButtonMorph(PluggableButtonMorph)>>mouseUp:
Array(SequenceableCollection)>>do:
SpToolbarButtonMorph(PluggableButtonMorph)>>mouseUp:
SpToolbarButtonMorph(Morph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
SpToolbarButtonMorph(Morph)>>handleEvent:
SpToolbarButtonMorph(Morph)>>handleFocusEvent:
[
		result := focusHolder handleFocusEvent: transformedEvent.
	] in HandMorph>>sendFocusEvent:to:clear:
FullBlockClosure(BlockClosure)>>on:do:
WorldMorph>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil ]) ifTrue: [
			morphicWorld activeHand handleEvent: anEvent
		]
	] in OSWindowMorphicEventHandler>>dispatchMorphicEvent:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycleNow
WorldMorph>>doOneCycle
[
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMutex critical: [
			                     self extraWorldList ].
		extraWorldsToDraw do: [ :world | world doOneCycle ].

		(self currentWorld isNotNil and: [
			 (extraWorldsToDraw includes: self currentWorld) not ]) ifTrue: [
			self currentWorld doOneCycle ] ] in WorldMorph class>>doOneCycle
FullBlockClosure(BlockClosure)>>ensure:
WorldState class>>doDrawCycleWith:
 - - - - - - - - - - - - - - -
			- - - - - - - - - - - - - - - - - -
WorldMorph class>>doOneCycle
MorphicRenderLoop>>doOneCycle
MorphicRenderLoop>>doOneCycleWhile:
[ MorphicRenderLoop new doOneCycleWhile: [ true ] ] in MorphicUIManager>>spawnNewProcess
[self value.
			"IMPORTANT: Do not step over next line of code. See method comments for details"
			Processor terminateRealActive] in FullBlockClosure(BlockClosure)>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
Instance of RSBox did not understand #center
24 October 2023 9:44:56.147925 am

VM: Mac OS - arm64 - 1000 - CoInterpreter VMMaker-tonel.1 uuid: 902dd483-c0c4-0d00-86f2-0f880df24b96 Oct 23 2023
StackToRegisterMappingCogit VMMaker-tonel.1 uuid: 902dd483-c0c4-0d00-86f2-0f880df24b96 Oct 23 2023
v10.0.8 - Commit: b323c5fb - Date: 2023-10-20 16:02:07 -0400

Image: Pharo11.0.0 [Build information: Pharo-11.0.0+build.710.sha.ea28d8552cac85a7ce1e9c34ab1e7bd45f7b9910 (64 Bit)]

RSBox(Object)>>doesNotUnderstand: #center
	Receiver: a RSBox
	Arguments and temporary variables: 
		aMessage: 	center
		exception: 	Instance of RSBox did not understand #center
		resumeValue: 	nil
	Receiver's instance variables: 
		announcer: 	nil
		properties: 	nil
		paint: 	Color blue
		path: 	(-25.0@ -25.0) corner: (25.0@25.0)
		border: 	nil
		parent: 	a RSCanvas
		isFixed: 	false
		encompassingRectangle: 	nil
		model: 	nil
		baseRectangle: 	(-25.0@ -25.0) corner: (25.0@25.0)
		matrix: 	x: 0.0 y: 0.0 sx: 1.0 sy: 1.0 shx: 0.0 shy: 0.0
		connectedLines: 	nil
		shouldUpdateLines: 	true
		cornerRadius: 	nil


VisualizerMain>>createSampleGraph
	Receiver: a VisualizerMain
	Arguments and temporary variables: 
		view: 	a RSCanvas
		alice: 	a RSBox
		bob: 	a RSBox
		aliceLabel: 	a RSLabel
		bobLabel: 	a RSLabel
	Receiver's instance variables: 
a VisualizerMain

UndefinedObject>>DoIt
	Receiver: nil
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
nil

OCReceiverDoItSemanticScope(OCDoItSemanticScope)>>evaluateDoIt:
	Receiver: an OCReceiverDoItSemanticScope
	Arguments and temporary variables: 
		doItMethod: 	UndefinedObject>>#DoIt
	Receiver's instance variables: 
		outerScope: 	nil
		targetReceiver: 	nil


OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
		doItMethod: 	UndefinedObject>>#DoIt
	Receiver's instance variables: 
		ast: 	DoIt

	^ VisualizerMain new createSampleGraph open
		source: 	a ReadStream
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil


[
		self announcer announce: (SpCodeWillBeEvaluatedAnnouncement newContent: aString).
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionModel doItReceiver.
		result := receiver class compiler
			source: aString;
			context: self interactionModel doItContext;
			receiver: self interactionModel doItReceiver;
			requestor: self interactionModel;
			environment: self environment;
			failBlock:  [ 
				self announcer announce: (SpCodeEvaluationFailedAnnouncement newContent: aString).
				^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		self announcer announce: (SpCodeEvaluationSucceedAnnouncement newContent: aString).
		result ] in SpCodePresenter>>evaluate:onCompileError:onError:
	Receiver: a SpCodePresenter
	Arguments and temporary variables: 
		aString: 	'(VisualizerMain new createSampleGraph) open.
'
		compileErrorBlock: 	[ ^ self ]
		errorBlock: 	[ :e | e pass ]
		receiver: 	nil
		result: 	nil
		oldBindings: 	a Dictionary()
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicCodeAdapter)
		announcer: 	an Announcer
		owner: 	a StPlaygroundPagePresenter
		adapter: 	a SpMorphicCodeAdapter
		needRebuild: 	true
		eventHandler: 	a SpEventHandler
		application: 	nil
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ a KMCategory ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Code' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpAbstractWidgetLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		borderWidth: 	an ObservableValueHolder[ nil ]
		borderColor: 	an ObservableValueHolder[ nil ]
		dragEnabled: 	an ObservableValueHolder[ false ]
		dropEnabled: 	an ObservableValueHolder[ false ]
		color: 	an ObservableValueHolder[ nil ]
		help: 	an ObservableValueHolder[ nil ]
		enabled: 	an ObservableValueHolder[ true ]
		wantsDrop: 	an ObservableValueHolder[ [ :transfer | self dropEnabled ] ]
		acceptDrop: 	an ObservableValueHolder[ [ :transfer | ] ]
		deferredActions: 	nil
		hasUnacceptedEdits: 	an ObservableValueHolder[ false ]
		selection: 	an ObservableValueHolder[ (1 to: 45) ]
		wantsVisualFeedback: 	an ObservableValueHolder[ true ]
		askBeforeDiscardingEdits: 	an ObservableValueHolder[ true ]
		text: 	an ObservableValueHolder[ '(VisualizerMain new createSampleGraph) ope[..]
		actionToPerform: 	an ObservableValueHolder[ [ :txt |  ] ]
		readSelection: 	an ObservableValueHolder[ [ selection ] ]
		placeholder: 	an ObservableValueHolder[ '' ]
		contextMenu: 	an ObservableValueHolder[ [ (self menuActionsFor: text) asMenu[..]
		scrollValue: 	an ObservableValueHolder[ (0@0) ]
		editionContextMenu: 	an ObservableValueHolder[ true ]
		editable: 	an ObservableValueHolder[ true ]
		wrapWord: 	an ObservableValueHolder[ true ]
		undoRedoHistory: 	true
		wrapScrollBars: 	true
		propagateNaturalHeight: 	false
		propagateNaturalWidth: 	false
		scrollBarStyles: 	#()
		syntaxHighlight: 	an ObservableValueHolder[ true ]
		smartCharacters: 	an ObservableValueHolder[ true ]
		lineNumbers: 	an ObservableValueHolder[ true ]
		interactionModel: 	an ObservableValueHolder[ a StPlaygroundInteractionModel ]
		overrideContextMenu: 	true
		submitBlock: 	nil
		resetBlock: 	nil
		environment: 	nil
		systemNavigation: 	nil
		syntaxHighlightTheme: 	an ObservableValueHolder[ nil ]


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
		self announcer announce: (SpCodeWillBeEvaluatedAnnouncement newContent: aString).
[..]
	Arguments and temporary variables: 
		exception: 	Error
		handlerAction: 	[ :e |
		self announcer announce: (SpCodeEvaluationFailedAnn[..]
	Receiver's instance variables: 
		outerContext: 	SpCodePresenter>>evaluate:onCompileError:onError:
		compiledBlock: 	a CompiledBlock: [
		self announcer announce: (SpCodeWillBeE[..]
		numArgs: 	0
		receiver: 	a SpCodePresenter


SpCodePresenter>>evaluate:onCompileError:onError:
	Receiver: a SpCodePresenter
	Arguments and temporary variables: 
		receiver: 	nil
		result: 	nil
		oldBindings: 	a Dictionary()
		aString: 	'(VisualizerMain new createSampleGraph) open.
'
		compileErrorBlock: 	[ ^ self ]
		errorBlock: 	[ :e | e pass ]
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicCodeAdapter)
		announcer: 	an Announcer
		owner: 	a StPlaygroundPagePresenter
		adapter: 	a SpMorphicCodeAdapter
		needRebuild: 	true
		eventHandler: 	a SpEventHandler
		application: 	nil
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ a KMCategory ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Code' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpAbstractWidgetLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		borderWidth: 	an ObservableValueHolder[ nil ]
		borderColor: 	an ObservableValueHolder[ nil ]
		dragEnabled: 	an ObservableValueHolder[ false ]
		dropEnabled: 	an ObservableValueHolder[ false ]
		color: 	an ObservableValueHolder[ nil ]
		help: 	an ObservableValueHolder[ nil ]
		enabled: 	an ObservableValueHolder[ true ]
		wantsDrop: 	an ObservableValueHolder[ [ :transfer | self dropEnabled ] ]
		acceptDrop: 	an ObservableValueHolder[ [ :transfer | ] ]
		deferredActions: 	nil
		hasUnacceptedEdits: 	an ObservableValueHolder[ false ]
		selection: 	an ObservableValueHolder[ (1 to: 45) ]
		wantsVisualFeedback: 	an ObservableValueHolder[ true ]
		askBeforeDiscardingEdits: 	an ObservableValueHolder[ true ]
		text: 	an ObservableValueHolder[ '(VisualizerMain new createSampleGraph) ope[..]
		actionToPerform: 	an ObservableValueHolder[ [ :txt |  ] ]
		readSelection: 	an ObservableValueHolder[ [ selection ] ]
		placeholder: 	an ObservableValueHolder[ '' ]
		contextMenu: 	an ObservableValueHolder[ [ (self menuActionsFor: text) asMenu[..]
		scrollValue: 	an ObservableValueHolder[ (0@0) ]
		editionContextMenu: 	an ObservableValueHolder[ true ]
		editable: 	an ObservableValueHolder[ true ]
		wrapWord: 	an ObservableValueHolder[ true ]
		undoRedoHistory: 	true
		wrapScrollBars: 	true
		propagateNaturalHeight: 	false
		propagateNaturalWidth: 	false
		scrollBarStyles: 	#()
		syntaxHighlight: 	an ObservableValueHolder[ true ]
		smartCharacters: 	an ObservableValueHolder[ true ]
		lineNumbers: 	an ObservableValueHolder[ true ]
		interactionModel: 	an ObservableValueHolder[ a StPlaygroundInteractionModel ]
		overrideContextMenu: 	true
		submitBlock: 	nil
		resetBlock: 	nil
		environment: 	nil
		systemNavigation: 	nil
		syntaxHighlightTheme: 	an ObservableValueHolder[ nil ]


StPlaygroundPagePresenter>>doEvaluateAndGo
	Receiver: a StPlaygroundPagePresenter
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicBoxAdapter)
		announcer: 	an Announcer
		owner: 	a SpMillerColumnPresenter
		adapter: 	a SpMorphicBoxAdapter
		needRebuild: 	true
		eventHandler: 	nil
		application: 	a StPharoApplication
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ nil ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Untitled window' ]
		additionalSubpresentersMap: 	a Dictionary()
		layout: 	an ObservableValueHolder[ a SpBoxLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		text: 	a SpCodePresenter
		toolbar: 	a SpToolbarPresenter
		statusbar: 	a SpPresenter
		lineLabel: 	a SpLabelPresenter
		toggleLineNumberButton: 	a SpToggleButtonPresenter
		page: 	a StPlaygroundPage
		activationBlock: 	[ :selection |
		self changeSelection: selection from: new[..]


StPlaygroundPagePresenter>>doEvaluateAllAndGo
	Receiver: a StPlaygroundPagePresenter
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicBoxAdapter)
		announcer: 	an Announcer
		owner: 	a SpMillerColumnPresenter
		adapter: 	a SpMorphicBoxAdapter
		needRebuild: 	true
		eventHandler: 	nil
		application: 	a StPharoApplication
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ nil ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Untitled window' ]
		additionalSubpresentersMap: 	a Dictionary()
		layout: 	an ObservableValueHolder[ a SpBoxLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		text: 	a SpCodePresenter
		toolbar: 	a SpToolbarPresenter
		statusbar: 	a SpPresenter
		lineLabel: 	a SpLabelPresenter
		toggleLineNumberButton: 	a SpToggleButtonPresenter
		page: 	a StPlaygroundPage
		activationBlock: 	[ :selection |
		self changeSelection: selection from: new[..]


StPlaygroundDoItCommand>>execute
	Receiver: a StPlaygroundDoItCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		context: 	a StPlaygroundPagePresenter
		basicName: 	'Do it'
		basicDescription: 	'Do it all and inspect.'


SpCommand(CmCommandDecorator)>>execute
	Receiver: a SpCommand(Do it)
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a StPlaygroundDoItCommand
		iconProvider: 	a StPharoApplication
		iconName: 	#glamorousGo
		shortcutKey: 	nil
		displayStrategy: 	a CmUIDisableWhenCantBeRun
		positionStrategy: 	a CmUILeftPositionStrategy
		buildPresenterBlock: 	[ :specCommand | 
			aButtonClass new
				label: specC[..]
		presenter: 	a SpToolbarButtonPresenter


[ specCommand execute ] in [ :specCommand | 
			aButtonClass new
				label: specCommand name;
				help: specCommand description;
				in: [ :button | 
					specCommand hasIcon
						ifTrue: [ button icon: specCommand icon ] ];
				action: [ specCommand execute ];
				yourself ] in SpCommand>>configureAsButtonOfClass:
	Receiver: a SpCommand(Do it)
	Arguments and temporary variables: 
		aButtonClass: 	nil
		specCommand: 	a SpCommand(Do it)
	Receiver's instance variables: 
		decoratedCommand: 	a StPlaygroundDoItCommand
		iconProvider: 	a StPharoApplication
		iconName: 	#glamorousGo
		shortcutKey: 	nil
		displayStrategy: 	a CmUIDisableWhenCantBeRun
		positionStrategy: 	a CmUILeftPositionStrategy
		buildPresenterBlock: 	[ :specCommand | 
			aButtonClass new
				label: specC[..]
		presenter: 	a SpToolbarButtonPresenter


FullBlockClosure(BlockClosure)>>cull:
	Receiver: [ specCommand execute ]
	Arguments and temporary variables: 
		anArg: 	a SpToolbarButtonPresenter
	Receiver's instance variables: 
		outerContext: 	[ :specCommand | 
			aButtonClass new
				label: specCommand [..]
		compiledBlock: 	a CompiledBlock: [ specCommand execute ]
		numArgs: 	0
		receiver: 	a SpCommand(Do it)


SpMorphicToolbarButtonAdapter>>execute
	Receiver: a SpMorphicToolbarButtonAdapter
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpToolbarButtonMorph(888790016))
		announcer: 	nil
		model: 	a SpToolbarButtonPresenter
		widget: 	a SpToolbarButtonMorph(888790016)
		selector: 	nil
		owner: 	a SpToolbarButtonPresenter
		unsubscribed: 	false


SpToolbarButtonMorph(PluggableButtonMorph)>>performAction:
	Receiver: a SpToolbarButtonMorph(888790016)
	Arguments and temporary variables: 
		event: 	[(20.0@28.0) mouseUp 35561039 nil]
	Receiver's instance variables: 
		bounds: 	(0.0@5.0) corner: (45.0@39.0)
		owner: 	a Morph(1073167616)
		submorphs: 	an Array(an AlignmentMorph(116792320))
		fullBounds: 	nil
		color: 	(Color r: 0.9012707722385142 g: 0.9012707722385142 b: 0.901270772238[..]
		extension: 	a MorphExtension (509491200) [balloonText]  [other:  (presenter [..]
		borderWidth: 	0
		borderColor: 	#simple
		model: 	a SpMorphicToolbarButtonAdapter
		label: 	'Do it'
		icon: 	Form(13x13x32)
		getIconSelector: 	#icon
		getStateSelector: 	#state
		actionSelector: 	#execute
		font: 	a LogicalFont
 familyName: 'Source Sans Pro'
 emphasis: nil
 pointSiz[..]
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	nil
		getFontSelector: 	nil
		labelMorph: 	a LabelMorph(128736768)'Do it'
		iconMorph: 	an ImageMorph(1001562624)
		iconPosition: 	#top
		lastState: 	false
		badgeFont: 	nil
		badgeSelector: 	#badge


[:m |
		(m containsPoint: evt cursorPoint) ifTrue: [m enabled ifTrue: [ m performAction: evt ]]] in SpToolbarButtonMorph(PluggableButtonMorph)>>mouseUp:
	Receiver: a SpToolbarButtonMorph(888790016)
	Arguments and temporary variables: 
		evt: 	[(20.0@28.0) mouseUp 35561039 nil]
		all: 	an Array(a SpToolbarButtonMorph(888790016) a SpToolbarButtonMorph(2143[..]
		m: 	a SpToolbarButtonMorph(888790016)
	Receiver's instance variables: 
		bounds: 	(0.0@5.0) corner: (45.0@39.0)
		owner: 	a Morph(1073167616)
		submorphs: 	an Array(an AlignmentMorph(116792320))
		fullBounds: 	nil
		color: 	(Color r: 0.9012707722385142 g: 0.9012707722385142 b: 0.901270772238[..]
		extension: 	a MorphExtension (509491200) [balloonText]  [other:  (presenter [..]
		borderWidth: 	0
		borderColor: 	#simple
		model: 	a SpMorphicToolbarButtonAdapter
		label: 	'Do it'
		icon: 	Form(13x13x32)
		getIconSelector: 	#icon
		getStateSelector: 	#state
		actionSelector: 	#execute
		font: 	a LogicalFont
 familyName: 'Source Sans Pro'
 emphasis: nil
 pointSiz[..]
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	nil
		getFontSelector: 	nil
		labelMorph: 	a LabelMorph(128736768)'Do it'
		iconMorph: 	an ImageMorph(1001562624)
		iconPosition: 	#top
		lastState: 	false
		badgeFont: 	nil
		badgeSelector: 	#badge


Array(SequenceableCollection)>>do:
	Receiver: an Array(a SpToolbarButtonMorph(888790016) a SpToolbarButtonMorph(214329088) a SpToolb[..]
	Arguments and temporary variables: 
		aBlock: 	[:m |
		(m containsPoint: evt cursorPoint) ifTrue: [m enabled ifTru[..]
		index: 	1
	Receiver's instance variables: 
an Array(a SpToolbarButtonMorph(888790016) a SpToolbarButtonMorph(214329088) a SpToolb[..]

SpToolbarButtonMorph(PluggableButtonMorph)>>mouseUp:
	Receiver: a SpToolbarButtonMorph(888790016)
	Arguments and temporary variables: 
		evt: 	[(20.0@28.0) mouseUp 35561039 nil]
		all: 	an Array(a SpToolbarButtonMorph(888790016) a SpToolbarButtonMorph(2143[..]
	Receiver's instance variables: 
		bounds: 	(0.0@5.0) corner: (45.0@39.0)
		owner: 	a Morph(1073167616)
		submorphs: 	an Array(an AlignmentMorph(116792320))
		fullBounds: 	nil
		color: 	(Color r: 0.9012707722385142 g: 0.9012707722385142 b: 0.901270772238[..]
		extension: 	a MorphExtension (509491200) [balloonText]  [other:  (presenter [..]
		borderWidth: 	0
		borderColor: 	#simple
		model: 	a SpMorphicToolbarButtonAdapter
		label: 	'Do it'
		icon: 	Form(13x13x32)
		getIconSelector: 	#icon
		getStateSelector: 	#state
		actionSelector: 	#execute
		font: 	a LogicalFont
 familyName: 'Source Sans Pro'
 emphasis: nil
 pointSiz[..]
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	nil
		getFontSelector: 	nil
		labelMorph: 	a LabelMorph(128736768)'Do it'
		iconMorph: 	an ImageMorph(1001562624)
		iconPosition: 	#top
		lastState: 	false
		badgeFont: 	nil
		badgeSelector: 	#badge


SpToolbarButtonMorph(Morph)>>handleMouseUp:
	Receiver: a SpToolbarButtonMorph(888790016)
	Arguments and temporary variables: 
		anEvent: 	[(20.0@28.0) mouseUp 35561039 nil]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(0.0@5.0) corner: (45.0@39.0)
		owner: 	a Morph(1073167616)
		submorphs: 	an Array(an AlignmentMorph(116792320))
		fullBounds: 	nil
		color: 	(Color r: 0.9012707722385142 g: 0.9012707722385142 b: 0.901270772238[..]
		extension: 	a MorphExtension (509491200) [balloonText]  [other:  (presenter [..]
		borderWidth: 	0
		borderColor: 	#simple
		model: 	a SpMorphicToolbarButtonAdapter
		label: 	'Do it'
		icon: 	Form(13x13x32)
		getIconSelector: 	#icon
		getStateSelector: 	#state
		actionSelector: 	#execute
		font: 	a LogicalFont
 familyName: 'Source Sans Pro'
 emphasis: nil
 pointSiz[..]
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	nil
		getFontSelector: 	nil
		labelMorph: 	a LabelMorph(128736768)'Do it'
		iconMorph: 	an ImageMorph(1001562624)
		iconPosition: 	#top
		lastState: 	false
		badgeFont: 	nil
		badgeSelector: 	#badge


MouseButtonEvent>>sentTo:
	Receiver: [(20.0@28.0) mouseUp 35561039 nil]
	Arguments and temporary variables: 
		anObject: 	a SpToolbarButtonMorph(888790016)
	Receiver's instance variables: 
		timeStamp: 	35561039
		source: 	a HandMorph(337424384)
		windowIndex: 	nil
		type: 	#mouseUp
		buttons: 	0
		position: 	(20.0@28.0)
		handler: 	nil
		wasHandled: 	true
		whichButton: 	4


SpToolbarButtonMorph(Morph)>>handleEvent:
	Receiver: a SpToolbarButtonMorph(888790016)
	Arguments and temporary variables: 
		anEvent: 	[(20.0@28.0) mouseUp 35561039 nil]
	Receiver's instance variables: 
		bounds: 	(0.0@5.0) corner: (45.0@39.0)
		owner: 	a Morph(1073167616)
		submorphs: 	an Array(an AlignmentMorph(116792320))
		fullBounds: 	nil
		color: 	(Color r: 0.9012707722385142 g: 0.9012707722385142 b: 0.901270772238[..]
		extension: 	a MorphExtension (509491200) [balloonText]  [other:  (presenter [..]
		borderWidth: 	0
		borderColor: 	#simple
		model: 	a SpMorphicToolbarButtonAdapter
		label: 	'Do it'
		icon: 	Form(13x13x32)
		getIconSelector: 	#icon
		getStateSelector: 	#state
		actionSelector: 	#execute
		font: 	a LogicalFont
 familyName: 'Source Sans Pro'
 emphasis: nil
 pointSiz[..]
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	nil
		getFontSelector: 	nil
		labelMorph: 	a LabelMorph(128736768)'Do it'
		iconMorph: 	an ImageMorph(1001562624)
		iconPosition: 	#top
		lastState: 	false
		badgeFont: 	nil
		badgeSelector: 	#badge


SpToolbarButtonMorph(Morph)>>handleFocusEvent:
	Receiver: a SpToolbarButtonMorph(888790016)
	Arguments and temporary variables: 
		anEvent: 	[(20.0@28.0) mouseUp 35561039 nil]
	Receiver's instance variables: 
		bounds: 	(0.0@5.0) corner: (45.0@39.0)
		owner: 	a Morph(1073167616)
		submorphs: 	an Array(an AlignmentMorph(116792320))
		fullBounds: 	nil
		color: 	(Color r: 0.9012707722385142 g: 0.9012707722385142 b: 0.901270772238[..]
		extension: 	a MorphExtension (509491200) [balloonText]  [other:  (presenter [..]
		borderWidth: 	0
		borderColor: 	#simple
		model: 	a SpMorphicToolbarButtonAdapter
		label: 	'Do it'
		icon: 	Form(13x13x32)
		getIconSelector: 	#icon
		getStateSelector: 	#state
		actionSelector: 	#execute
		font: 	a LogicalFont
 familyName: 'Source Sans Pro'
 emphasis: nil
 pointSiz[..]
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	nil
		getFontSelector: 	nil
		labelMorph: 	a LabelMorph(128736768)'Do it'
		iconMorph: 	an ImageMorph(1001562624)
		iconPosition: 	#top
		lastState: 	false
		badgeFont: 	nil
		badgeSelector: 	#badge


[
		result := focusHolder handleFocusEvent: transformedEvent.
	] in HandMorph>>sendFocusEvent:to:clear:
	Receiver: a HandMorph(337424384)
	Arguments and temporary variables: 
		anEvent: 	[(398@270) mouseUp 35561039 nil]
		focusHolder: 	a SpToolbarButtonMorph(888790016)
		aBlock: 	[self mouseFocus: nil]
		w: 	a WorldMorph(341720576) [world]
		transformedEvent: 	[(20.0@28.0) mouseUp 35561039 nil]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(398@270.0) corner: (414@286.0)
		owner: 	a WorldMorph(341720576) [world]
		submorphs: 	#()
		fullBounds: 	(398@270.0) corner: (414@286.0)
		color: 	Color blue
		extension: 	a MorphExtension (370611968)
		mouseFocus: 	nil
		keyboardFocus: 	a RubEditingArea(919167488)
		eventListeners: 	nil
		mouseListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(398@270) mouseUp 35561039 nil]
		targetOffset: 	(20.0@23.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 0 0 0 0 0 nil nil)
		captureBlock: 	nil
		recentModifiers: 	0
		pendingEventQueue: 	WaitfreeQueue with 0 items
		supressNextKeyPress: 	false


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
		result := focusHolder handleFocusEvent: transformedEvent.
	]
	Arguments and temporary variables: 
		exception: 	Error
		handlerAction: 	[ :ex |
			ActiveWorld := priorWorld.
			ex pass ]
	Receiver's instance variables: 
		outerContext: 	HandMorph>>sendFocusEvent:to:clear:
		compiledBlock: 	a CompiledBlock: [
		result := focusHolder handleFocusEvent:[..]
		numArgs: 	0
		receiver: 	a HandMorph(337424384)


WorldMorph>>becomeActiveDuring:
	Receiver: a WorldMorph(341720576) [world]
	Arguments and temporary variables: 
		aBlock: 	[
		result := focusHolder handleFocusEvent: transformedEvent.
	]
		priorWorld: 	a WorldMorph(341720576) [world]
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1728@1051)
		owner: 	nil
		submorphs: 	an Array(a MenubarMorph(112886016) a TaskbarMorph(279458560) a S[..]
		fullBounds: 	nil
		color: 	(Color r: 0.9403714565004888 g: 0.9403714565004888 b: 0.940371456500[..]
		extension: 	a MorphExtension (1012946432) [other:  (dragEnabled -> true) (dr[..]
		borderWidth: 	0
		borderColor: 	(Color r: 0.8611925708699902 g: 1.0 b: 0.7223851417399805 alph[..]
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil


HandMorph>>sendFocusEvent:to:clear:
	Receiver: a HandMorph(337424384)
	Arguments and temporary variables: 
		result: 	nil
		anEvent: 	[(398@270) mouseUp 35561039 nil]
		focusHolder: 	a SpToolbarButtonMorph(888790016)
		aBlock: 	[self mouseFocus: nil]
		w: 	a WorldMorph(341720576) [world]
		transformedEvent: 	[(20.0@28.0) mouseUp 35561039 nil]
	Receiver's instance variables: 
		bounds: 	(398@270.0) corner: (414@286.0)
		owner: 	a WorldMorph(341720576) [world]
		submorphs: 	#()
		fullBounds: 	(398@270.0) corner: (414@286.0)
		color: 	Color blue
		extension: 	a MorphExtension (370611968)
		mouseFocus: 	nil
		keyboardFocus: 	a RubEditingArea(919167488)
		eventListeners: 	nil
		mouseListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(398@270) mouseUp 35561039 nil]
		targetOffset: 	(20.0@23.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 0 0 0 0 0 nil nil)
		captureBlock: 	nil
		recentModifiers: 	0
		pendingEventQueue: 	WaitfreeQueue with 0 items
		supressNextKeyPress: 	false


HandMorph>>sendEvent:focus:clear:
	Receiver: a HandMorph(337424384)
	Arguments and temporary variables: 
		anEvent: 	[(398@270) mouseUp 35561039 nil]
		focusHolder: 	a SpToolbarButtonMorph(888790016)
		aBlock: 	[self mouseFocus: nil]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(398@270.0) corner: (414@286.0)
		owner: 	a WorldMorph(341720576) [world]
		submorphs: 	#()
		fullBounds: 	(398@270.0) corner: (414@286.0)
		color: 	Color blue
		extension: 	a MorphExtension (370611968)
		mouseFocus: 	nil
		keyboardFocus: 	a RubEditingArea(919167488)
		eventListeners: 	nil
		mouseListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(398@270) mouseUp 35561039 nil]
		targetOffset: 	(20.0@23.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 0 0 0 0 0 nil nil)
		captureBlock: 	nil
		recentModifiers: 	0
		pendingEventQueue: 	WaitfreeQueue with 0 items
		supressNextKeyPress: 	false


HandMorph>>sendMouseEvent:
	Receiver: a HandMorph(337424384)
	Arguments and temporary variables: 
		anEvent: 	[(398@270) mouseUp 35561039 nil]
	Receiver's instance variables: 
		bounds: 	(398@270.0) corner: (414@286.0)
		owner: 	a WorldMorph(341720576) [world]
		submorphs: 	#()
		fullBounds: 	(398@270.0) corner: (414@286.0)
		color: 	Color blue
		extension: 	a MorphExtension (370611968)
		mouseFocus: 	nil
		keyboardFocus: 	a RubEditingArea(919167488)
		eventListeners: 	nil
		mouseListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(398@270) mouseUp 35561039 nil]
		targetOffset: 	(20.0@23.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 0 0 0 0 0 nil nil)
		captureBlock: 	nil
		recentModifiers: 	0
		pendingEventQueue: 	WaitfreeQueue with 0 items
		supressNextKeyPress: 	false


HandMorph>>handleEvent:
	Receiver: a HandMorph(337424384)
	Arguments and temporary variables: 
		anEvent: 	[(398@270) mouseUp 35561039 nil]
		evt: 	[(398@270) mouseUp 35561039 nil]
	Receiver's instance variables: 
		bounds: 	(398@270.0) corner: (414@286.0)
		owner: 	a WorldMorph(341720576) [world]
		submorphs: 	#()
		fullBounds: 	(398@270.0) corner: (414@286.0)
		color: 	Color blue
		extension: 	a MorphExtension (370611968)
		mouseFocus: 	nil
		keyboardFocus: 	a RubEditingArea(919167488)
		eventListeners: 	nil
		mouseListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(398@270) mouseUp 35561039 nil]
		targetOffset: 	(20.0@23.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 0 0 0 0 0 nil nil)
		captureBlock: 	nil
		recentModifiers: 	0
		pendingEventQueue: 	WaitfreeQueue with 0 items
		supressNextKeyPress: 	false


[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil ]) ifTrue: [
			morphicWorld activeHand handleEvent: anEvent
		]
	] in OSWindowMorphicEventHandler>>dispatchMorphicEvent:
	Receiver: an OSWindowMorphicEventHandler
	Arguments and temporary variables: 
		anEvent: 	[(398@270) mouseUp 35561039 nil]
	Receiver's instance variables: 
		morphicWorld: 	a WorldMorph(341720576) [world]


WorldState>>runStepMethodsIn:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(341720576) [world]
		queue: 	WaitfreeQueue with 0 items
		nextInQueue: 	[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNo[..]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(337424384))
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap()
		lastStepTime: 	35560931
		lastStepMessage: 	nil
		alarms: 	a Heap(MorphicAlarm(#hideShow -> a RubCursor(899173120)))
		lastAlarmTime: 	35561026
		activeHand: 	a HandMorph(337424384)
		currentCursor: 	((CursorWithMask
	extent: (16@16)
	depth: 1
	fromArray: #(
	[..]
		worldRenderer: 	an OSWorldRenderer
		realWindowExtent: 	(1728@1051)
		deferredUIMessages: 	WaitfreeQueue with 0 items


WorldMorph>>runStepMethods
	Receiver: a WorldMorph(341720576) [world]
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1728@1051)
		owner: 	nil
		submorphs: 	an Array(a MenubarMorph(112886016) a TaskbarMorph(279458560) a S[..]
		fullBounds: 	nil
		color: 	(Color r: 0.9403714565004888 g: 0.9403714565004888 b: 0.940371456500[..]
		extension: 	a MorphExtension (1012946432) [other:  (dragEnabled -> true) (dr[..]
		borderWidth: 	0
		borderColor: 	(Color r: 0.8611925708699902 g: 1.0 b: 0.7223851417399805 alph[..]
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil


WorldState>>doOneCycleFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(341720576) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(337424384))
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap()
		lastStepTime: 	35560931
		lastStepMessage: 	nil
		alarms: 	a Heap(MorphicAlarm(#hideShow -> a RubCursor(899173120)))
		lastAlarmTime: 	35561026
		activeHand: 	a HandMorph(337424384)
		currentCursor: 	((CursorWithMask
	extent: (16@16)
	depth: 1
	fromArray: #(
	[..]
		worldRenderer: 	an OSWorldRenderer
		realWindowExtent: 	(1728@1051)
		deferredUIMessages: 	WaitfreeQueue with 0 items


WorldMorph>>doOneCycleNow
	Receiver: a WorldMorph(341720576) [world]
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1728@1051)
		owner: 	nil
		submorphs: 	an Array(a MenubarMorph(112886016) a TaskbarMorph(279458560) a S[..]
		fullBounds: 	nil
		color: 	(Color r: 0.9403714565004888 g: 0.9403714565004888 b: 0.940371456500[..]
		extension: 	a MorphExtension (1012946432) [other:  (dragEnabled -> true) (dr[..]
		borderWidth: 	0
		borderColor: 	(Color r: 0.8611925708699902 g: 1.0 b: 0.7223851417399805 alph[..]
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil


WorldMorph>>doOneCycle
	Receiver: a WorldMorph(341720576) [world]
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1728@1051)
		owner: 	nil
		submorphs: 	an Array(a MenubarMorph(112886016) a TaskbarMorph(279458560) a S[..]
		fullBounds: 	nil
		color: 	(Color r: 0.9403714565004888 g: 0.9403714565004888 b: 0.940371456500[..]
		extension: 	a MorphExtension (1012946432) [other:  (dragEnabled -> true) (dr[..]
		borderWidth: 	0
		borderColor: 	(Color r: 0.8611925708699902 g: 1.0 b: 0.7223851417399805 alph[..]
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil


[
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMutex critical: [
			                     self extraWorldList ].
		extraWorldsToDraw do: [ :world | world doOneCycle ].

		(self currentWorld isNotNil and: [
			 (extraWorldsToDraw includes: self currentWorld) not ]) ifTrue: [
			self currentWorld doOneCycle ] ] in WorldMorph class>>doOneCycle
	Receiver: WorldMorph
	Arguments and temporary variables: 
		extraWorldsToDraw: 	#()
	Receiver's instance variables: 
		superclass: 	PasteUpMorph
		methodDict: 	a MethodDictionary(#acceptDroppingMorph:event:->WorldMorph>>#ac[..]
		format: 	65547
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		commentSourcePointer: 	nil
		subclasses: 	{AthensWorldMorph. OSWindowWorldMorph}
		name: 	#WorldMorph
		classPool: 	a Dictionary(#AllowDropFiles->nil #CursorOwnerWorld->a WorldMorp[..]
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Morphic-Core-Worlds'
		announcer: 	nil
		displayScaleFactor: 	1


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMutex critical: [
			  [..]
	Arguments and temporary variables: 
		aBlock: 	[
		self doInterCycleWait
	]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	WorldMorph class>>doOneCycle
		compiledBlock: 	a CompiledBlock: [
		| extraWorldsToDraw |
		extraWorldsToDr[..]
		numArgs: 	0
		receiver: 	WorldMorph


WorldState class>>doDrawCycleWith:
	Receiver: WorldState
	Arguments and temporary variables: 
		aBlock: 	[
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMute[..]
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary(#activeHand->WorldState>>#activeHand #active[..]
		format: 	65548
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		commentSourcePointer: 	nil
		subclasses: 	{AthensWorldState}
		name: 	#WorldState
		classPool: 	a Dictionary(#CanSurrenderToOS->nil #DebugShowDamage->false #Des[..]
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Morphic-Core-Worlds'



--- The full stack ---
RSBox(Object)>>doesNotUnderstand: #center
VisualizerMain>>createSampleGraph
UndefinedObject>>DoIt
OCReceiverDoItSemanticScope(OCDoItSemanticScope)>>evaluateDoIt:
OpalCompiler>>evaluate
[
		self announcer announce: (SpCodeWillBeEvaluatedAnnouncement newContent: aString).
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionModel doItReceiver.
		result := receiver class compiler
			source: aString;
			context: self interactionModel doItContext;
			receiver: self interactionModel doItReceiver;
			requestor: self interactionModel;
			environment: self environment;
			failBlock:  [ 
				self announcer announce: (SpCodeEvaluationFailedAnnouncement newContent: aString).
				^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		self announcer announce: (SpCodeEvaluationSucceedAnnouncement newContent: aString).
		result ] in SpCodePresenter>>evaluate:onCompileError:onError:
FullBlockClosure(BlockClosure)>>on:do:
SpCodePresenter>>evaluate:onCompileError:onError:
StPlaygroundPagePresenter>>doEvaluateAndGo
StPlaygroundPagePresenter>>doEvaluateAllAndGo
StPlaygroundDoItCommand>>execute
SpCommand(CmCommandDecorator)>>execute
[ specCommand execute ] in [ :specCommand | 
			aButtonClass new
				label: specCommand name;
				help: specCommand description;
				in: [ :button | 
					specCommand hasIcon
						ifTrue: [ button icon: specCommand icon ] ];
				action: [ specCommand execute ];
				yourself ] in SpCommand>>configureAsButtonOfClass:
FullBlockClosure(BlockClosure)>>cull:
SpMorphicToolbarButtonAdapter>>execute
SpToolbarButtonMorph(PluggableButtonMorph)>>performAction:
[:m |
		(m containsPoint: evt cursorPoint) ifTrue: [m enabled ifTrue: [ m performAction: evt ]]] in SpToolbarButtonMorph(PluggableButtonMorph)>>mouseUp:
Array(SequenceableCollection)>>do:
SpToolbarButtonMorph(PluggableButtonMorph)>>mouseUp:
SpToolbarButtonMorph(Morph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
SpToolbarButtonMorph(Morph)>>handleEvent:
SpToolbarButtonMorph(Morph)>>handleFocusEvent:
[
		result := focusHolder handleFocusEvent: transformedEvent.
	] in HandMorph>>sendFocusEvent:to:clear:
FullBlockClosure(BlockClosure)>>on:do:
WorldMorph>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil ]) ifTrue: [
			morphicWorld activeHand handleEvent: anEvent
		]
	] in OSWindowMorphicEventHandler>>dispatchMorphicEvent:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycleNow
WorldMorph>>doOneCycle
[
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMutex critical: [
			                     self extraWorldList ].
		extraWorldsToDraw do: [ :world | world doOneCycle ].

		(self currentWorld isNotNil and: [
			 (extraWorldsToDraw includes: self currentWorld) not ]) ifTrue: [
			self currentWorld doOneCycle ] ] in WorldMorph class>>doOneCycle
FullBlockClosure(BlockClosure)>>ensure:
WorldState class>>doDrawCycleWith:
 - - - - - - - - - - - - - - -
			- - - - - - - - - - - - - - - - - -
WorldMorph class>>doOneCycle
MorphicRenderLoop>>doOneCycle
MorphicRenderLoop>>doOneCycleWhile:
[ MorphicRenderLoop new doOneCycleWhile: [ true ] ] in MorphicUIManager>>spawnNewProcess
[self value.
			"IMPORTANT: Do not step over next line of code. See method comments for details"
			Processor terminateRealActive] in FullBlockClosure(BlockClosure)>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
Instance of RSBox did not understand #label:
24 October 2023 5:32:40.808361 pm

VM: Mac OS - arm64 - 1000 - CoInterpreter VMMaker-tonel.1 uuid: 902dd483-c0c4-0d00-86f2-0f880df24b96 Oct 23 2023
StackToRegisterMappingCogit VMMaker-tonel.1 uuid: 902dd483-c0c4-0d00-86f2-0f880df24b96 Oct 23 2023
v10.0.8 - Commit: b323c5fb - Date: 2023-10-20 16:02:07 -0400

Image: Pharo11.0.0 [Build information: Pharo-11.0.0+build.710.sha.ea28d8552cac85a7ce1e9c34ab1e7bd45f7b9910 (64 Bit)]

RSBox(Object)>>doesNotUnderstand: #label:
	Receiver: a RSBox
	Arguments and temporary variables: 
		aMessage: 	label: 'Alice'
		exception: 	Instance of RSBox did not understand #label:
		resumeValue: 	nil
	Receiver's instance variables: 
		announcer: 	nil
		properties: 	nil
		paint: 	Color blue
		path: 	(-25.0@ -25.0) corner: (25.0@25.0)
		border: 	nil
		parent: 	nil
		isFixed: 	false
		encompassingRectangle: 	nil
		model: 	nil
		baseRectangle: 	(-25.0@ -25.0) corner: (25.0@25.0)
		matrix: 	x: 0.0 y: 0.0 sx: 1.0 sy: 1.0 shx: 0.0 shy: 0.0
		connectedLines: 	nil
		shouldUpdateLines: 	true
		cornerRadius: 	nil


VisualizerMain>>createSampleGraph
	Receiver: a VisualizerMain
	Arguments and temporary variables: 
		view: 	a RSCanvas
		alice: 	nil
		bob: 	nil
	Receiver's instance variables: 
a VisualizerMain

UndefinedObject>>DoIt
	Receiver: nil
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
nil

OCReceiverDoItSemanticScope(OCDoItSemanticScope)>>evaluateDoIt:
	Receiver: an OCReceiverDoItSemanticScope
	Arguments and temporary variables: 
		doItMethod: 	UndefinedObject>>#DoIt
	Receiver's instance variables: 
		outerScope: 	nil
		targetReceiver: 	nil


OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
		doItMethod: 	UndefinedObject>>#DoIt
	Receiver's instance variables: 
		ast: 	DoIt

	^ VisualizerMain new createSampleGraph open
		source: 	a ReadStream
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil


[
		self announcer announce: (SpCodeWillBeEvaluatedAnnouncement newContent: aString).
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionModel doItReceiver.
		result := receiver class compiler
			source: aString;
			context: self interactionModel doItContext;
			receiver: self interactionModel doItReceiver;
			requestor: self interactionModel;
			environment: self environment;
			failBlock:  [ 
				self announcer announce: (SpCodeEvaluationFailedAnnouncement newContent: aString).
				^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		self announcer announce: (SpCodeEvaluationSucceedAnnouncement newContent: aString).
		result ] in SpCodePresenter>>evaluate:onCompileError:onError:
	Receiver: a SpCodePresenter
	Arguments and temporary variables: 
		aString: 	'(VisualizerMain new createSampleGraph) open.
'
		compileErrorBlock: 	[ ^ self ]
		errorBlock: 	[ :e | e pass ]
		receiver: 	nil
		result: 	nil
		oldBindings: 	a Dictionary()
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicCodeAdapter)
		announcer: 	an Announcer
		owner: 	a StPlaygroundPagePresenter
		adapter: 	a SpMorphicCodeAdapter
		needRebuild: 	true
		eventHandler: 	a SpEventHandler
		application: 	nil
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ a KMCategory ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Code' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpAbstractWidgetLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		borderWidth: 	an ObservableValueHolder[ nil ]
		borderColor: 	an ObservableValueHolder[ nil ]
		dragEnabled: 	an ObservableValueHolder[ false ]
		dropEnabled: 	an ObservableValueHolder[ false ]
		color: 	an ObservableValueHolder[ nil ]
		help: 	an ObservableValueHolder[ nil ]
		enabled: 	an ObservableValueHolder[ true ]
		wantsDrop: 	an ObservableValueHolder[ [ :transfer | self dropEnabled ] ]
		acceptDrop: 	an ObservableValueHolder[ [ :transfer | ] ]
		deferredActions: 	nil
		hasUnacceptedEdits: 	an ObservableValueHolder[ false ]
		selection: 	an ObservableValueHolder[ (1 to: 45) ]
		wantsVisualFeedback: 	an ObservableValueHolder[ true ]
		askBeforeDiscardingEdits: 	an ObservableValueHolder[ true ]
		text: 	an ObservableValueHolder[ '(VisualizerMain new createSampleGraph) ope[..]
		actionToPerform: 	an ObservableValueHolder[ [ :txt |  ] ]
		readSelection: 	an ObservableValueHolder[ [ selection ] ]
		placeholder: 	an ObservableValueHolder[ '' ]
		contextMenu: 	an ObservableValueHolder[ [ (self menuActionsFor: text) asMenu[..]
		scrollValue: 	an ObservableValueHolder[ (0@0) ]
		editionContextMenu: 	an ObservableValueHolder[ true ]
		editable: 	an ObservableValueHolder[ true ]
		wrapWord: 	an ObservableValueHolder[ true ]
		undoRedoHistory: 	true
		wrapScrollBars: 	true
		propagateNaturalHeight: 	false
		propagateNaturalWidth: 	false
		scrollBarStyles: 	#()
		syntaxHighlight: 	an ObservableValueHolder[ true ]
		smartCharacters: 	an ObservableValueHolder[ true ]
		lineNumbers: 	an ObservableValueHolder[ true ]
		interactionModel: 	an ObservableValueHolder[ a StPlaygroundInteractionModel ]
		overrideContextMenu: 	true
		submitBlock: 	nil
		resetBlock: 	nil
		environment: 	nil
		systemNavigation: 	nil
		syntaxHighlightTheme: 	an ObservableValueHolder[ nil ]


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
		self announcer announce: (SpCodeWillBeEvaluatedAnnouncement newContent: aString).
[..]
	Arguments and temporary variables: 
		exception: 	Error
		handlerAction: 	[ :e |
		self announcer announce: (SpCodeEvaluationFailedAnn[..]
	Receiver's instance variables: 
		outerContext: 	SpCodePresenter>>evaluate:onCompileError:onError:
		compiledBlock: 	a CompiledBlock: [
		self announcer announce: (SpCodeWillBeE[..]
		numArgs: 	0
		receiver: 	a SpCodePresenter


SpCodePresenter>>evaluate:onCompileError:onError:
	Receiver: a SpCodePresenter
	Arguments and temporary variables: 
		receiver: 	nil
		result: 	nil
		oldBindings: 	a Dictionary()
		aString: 	'(VisualizerMain new createSampleGraph) open.
'
		compileErrorBlock: 	[ ^ self ]
		errorBlock: 	[ :e | e pass ]
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicCodeAdapter)
		announcer: 	an Announcer
		owner: 	a StPlaygroundPagePresenter
		adapter: 	a SpMorphicCodeAdapter
		needRebuild: 	true
		eventHandler: 	a SpEventHandler
		application: 	nil
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ a KMCategory ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Code' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpAbstractWidgetLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		borderWidth: 	an ObservableValueHolder[ nil ]
		borderColor: 	an ObservableValueHolder[ nil ]
		dragEnabled: 	an ObservableValueHolder[ false ]
		dropEnabled: 	an ObservableValueHolder[ false ]
		color: 	an ObservableValueHolder[ nil ]
		help: 	an ObservableValueHolder[ nil ]
		enabled: 	an ObservableValueHolder[ true ]
		wantsDrop: 	an ObservableValueHolder[ [ :transfer | self dropEnabled ] ]
		acceptDrop: 	an ObservableValueHolder[ [ :transfer | ] ]
		deferredActions: 	nil
		hasUnacceptedEdits: 	an ObservableValueHolder[ false ]
		selection: 	an ObservableValueHolder[ (1 to: 45) ]
		wantsVisualFeedback: 	an ObservableValueHolder[ true ]
		askBeforeDiscardingEdits: 	an ObservableValueHolder[ true ]
		text: 	an ObservableValueHolder[ '(VisualizerMain new createSampleGraph) ope[..]
		actionToPerform: 	an ObservableValueHolder[ [ :txt |  ] ]
		readSelection: 	an ObservableValueHolder[ [ selection ] ]
		placeholder: 	an ObservableValueHolder[ '' ]
		contextMenu: 	an ObservableValueHolder[ [ (self menuActionsFor: text) asMenu[..]
		scrollValue: 	an ObservableValueHolder[ (0@0) ]
		editionContextMenu: 	an ObservableValueHolder[ true ]
		editable: 	an ObservableValueHolder[ true ]
		wrapWord: 	an ObservableValueHolder[ true ]
		undoRedoHistory: 	true
		wrapScrollBars: 	true
		propagateNaturalHeight: 	false
		propagateNaturalWidth: 	false
		scrollBarStyles: 	#()
		syntaxHighlight: 	an ObservableValueHolder[ true ]
		smartCharacters: 	an ObservableValueHolder[ true ]
		lineNumbers: 	an ObservableValueHolder[ true ]
		interactionModel: 	an ObservableValueHolder[ a StPlaygroundInteractionModel ]
		overrideContextMenu: 	true
		submitBlock: 	nil
		resetBlock: 	nil
		environment: 	nil
		systemNavigation: 	nil
		syntaxHighlightTheme: 	an ObservableValueHolder[ nil ]


StPlaygroundPagePresenter>>doEvaluateAndGo
	Receiver: a StPlaygroundPagePresenter
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicBoxAdapter)
		announcer: 	an Announcer
		owner: 	a SpMillerColumnPresenter
		adapter: 	a SpMorphicBoxAdapter
		needRebuild: 	true
		eventHandler: 	nil
		application: 	a StPharoApplication
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ nil ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Untitled window' ]
		additionalSubpresentersMap: 	a Dictionary()
		layout: 	an ObservableValueHolder[ a SpBoxLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		text: 	a SpCodePresenter
		toolbar: 	a SpToolbarPresenter
		statusbar: 	a SpPresenter
		lineLabel: 	a SpLabelPresenter
		toggleLineNumberButton: 	a SpToggleButtonPresenter
		page: 	a StPlaygroundPage
		activationBlock: 	[ :selection |
		self changeSelection: selection from: new[..]


StPlaygroundPagePresenter>>doEvaluateAllAndGo
	Receiver: a StPlaygroundPagePresenter
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicBoxAdapter)
		announcer: 	an Announcer
		owner: 	a SpMillerColumnPresenter
		adapter: 	a SpMorphicBoxAdapter
		needRebuild: 	true
		eventHandler: 	nil
		application: 	a StPharoApplication
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ nil ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Untitled window' ]
		additionalSubpresentersMap: 	a Dictionary()
		layout: 	an ObservableValueHolder[ a SpBoxLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		text: 	a SpCodePresenter
		toolbar: 	a SpToolbarPresenter
		statusbar: 	a SpPresenter
		lineLabel: 	a SpLabelPresenter
		toggleLineNumberButton: 	a SpToggleButtonPresenter
		page: 	a StPlaygroundPage
		activationBlock: 	[ :selection |
		self changeSelection: selection from: new[..]


StPlaygroundDoItCommand>>execute
	Receiver: a StPlaygroundDoItCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		context: 	a StPlaygroundPagePresenter
		basicName: 	'Do it'
		basicDescription: 	'Do it all and inspect.'


SpCommand(CmCommandDecorator)>>execute
	Receiver: a SpCommand(Do it)
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a StPlaygroundDoItCommand
		iconProvider: 	a StPharoApplication
		iconName: 	#glamorousGo
		shortcutKey: 	nil
		displayStrategy: 	a CmUIDisableWhenCantBeRun
		positionStrategy: 	a CmUILeftPositionStrategy
		buildPresenterBlock: 	[ :specCommand | 
			aButtonClass new
				label: specC[..]
		presenter: 	a SpToolbarButtonPresenter


[ specCommand execute ] in [ :specCommand | 
			aButtonClass new
				label: specCommand name;
				help: specCommand description;
				in: [ :button | 
					specCommand hasIcon
						ifTrue: [ button icon: specCommand icon ] ];
				action: [ specCommand execute ];
				yourself ] in SpCommand>>configureAsButtonOfClass:
	Receiver: a SpCommand(Do it)
	Arguments and temporary variables: 
		aButtonClass: 	nil
		specCommand: 	a SpCommand(Do it)
	Receiver's instance variables: 
		decoratedCommand: 	a StPlaygroundDoItCommand
		iconProvider: 	a StPharoApplication
		iconName: 	#glamorousGo
		shortcutKey: 	nil
		displayStrategy: 	a CmUIDisableWhenCantBeRun
		positionStrategy: 	a CmUILeftPositionStrategy
		buildPresenterBlock: 	[ :specCommand | 
			aButtonClass new
				label: specC[..]
		presenter: 	a SpToolbarButtonPresenter


FullBlockClosure(BlockClosure)>>cull:
	Receiver: [ specCommand execute ]
	Arguments and temporary variables: 
		anArg: 	a SpToolbarButtonPresenter
	Receiver's instance variables: 
		outerContext: 	[ :specCommand | 
			aButtonClass new
				label: specCommand [..]
		compiledBlock: 	a CompiledBlock: [ specCommand execute ]
		numArgs: 	0
		receiver: 	a SpCommand(Do it)


SpMorphicToolbarButtonAdapter>>execute
	Receiver: a SpMorphicToolbarButtonAdapter
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpToolbarButtonMorph(888790016))
		announcer: 	nil
		model: 	a SpToolbarButtonPresenter
		widget: 	a SpToolbarButtonMorph(888790016)
		selector: 	nil
		owner: 	a SpToolbarButtonPresenter
		unsubscribed: 	false


SpToolbarButtonMorph(PluggableButtonMorph)>>performAction:
	Receiver: a SpToolbarButtonMorph(888790016)
	Arguments and temporary variables: 
		event: 	[(19.0@15.0) mouseUp 63625693 nil]
	Receiver's instance variables: 
		bounds: 	(0.0@5.0) corner: (45.0@39.0)
		owner: 	a Morph(1073167616)
		submorphs: 	an Array(an AlignmentMorph(116792320))
		fullBounds: 	nil
		color: 	(Color r: 0.9012707722385142 g: 0.9012707722385142 b: 0.901270772238[..]
		extension: 	a MorphExtension (509491200) [balloonText]  [other:  (presenter [..]
		borderWidth: 	0
		borderColor: 	#simple
		model: 	a SpMorphicToolbarButtonAdapter
		label: 	'Do it'
		icon: 	Form(13x13x32)
		getIconSelector: 	#icon
		getStateSelector: 	#state
		actionSelector: 	#execute
		font: 	a LogicalFont
 familyName: 'Source Sans Pro'
 emphasis: nil
 pointSiz[..]
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	nil
		getFontSelector: 	nil
		labelMorph: 	a LabelMorph(128736768)'Do it'
		iconMorph: 	an ImageMorph(1001562624)
		iconPosition: 	#top
		lastState: 	false
		badgeFont: 	nil
		badgeSelector: 	#badge


[:m |
		(m containsPoint: evt cursorPoint) ifTrue: [m enabled ifTrue: [ m performAction: evt ]]] in SpToolbarButtonMorph(PluggableButtonMorph)>>mouseUp:
	Receiver: a SpToolbarButtonMorph(888790016)
	Arguments and temporary variables: 
		evt: 	[(19.0@15.0) mouseUp 63625693 nil]
		all: 	an Array(a SpToolbarButtonMorph(888790016) a SpToolbarButtonMorph(2143[..]
		m: 	a SpToolbarButtonMorph(888790016)
	Receiver's instance variables: 
		bounds: 	(0.0@5.0) corner: (45.0@39.0)
		owner: 	a Morph(1073167616)
		submorphs: 	an Array(an AlignmentMorph(116792320))
		fullBounds: 	nil
		color: 	(Color r: 0.9012707722385142 g: 0.9012707722385142 b: 0.901270772238[..]
		extension: 	a MorphExtension (509491200) [balloonText]  [other:  (presenter [..]
		borderWidth: 	0
		borderColor: 	#simple
		model: 	a SpMorphicToolbarButtonAdapter
		label: 	'Do it'
		icon: 	Form(13x13x32)
		getIconSelector: 	#icon
		getStateSelector: 	#state
		actionSelector: 	#execute
		font: 	a LogicalFont
 familyName: 'Source Sans Pro'
 emphasis: nil
 pointSiz[..]
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	nil
		getFontSelector: 	nil
		labelMorph: 	a LabelMorph(128736768)'Do it'
		iconMorph: 	an ImageMorph(1001562624)
		iconPosition: 	#top
		lastState: 	false
		badgeFont: 	nil
		badgeSelector: 	#badge


Array(SequenceableCollection)>>do:
	Receiver: an Array(a SpToolbarButtonMorph(888790016) a SpToolbarButtonMorph(214329088) a SpToolb[..]
	Arguments and temporary variables: 
		aBlock: 	[:m |
		(m containsPoint: evt cursorPoint) ifTrue: [m enabled ifTru[..]
		index: 	1
	Receiver's instance variables: 
an Array(a SpToolbarButtonMorph(888790016) a SpToolbarButtonMorph(214329088) a SpToolb[..]

SpToolbarButtonMorph(PluggableButtonMorph)>>mouseUp:
	Receiver: a SpToolbarButtonMorph(888790016)
	Arguments and temporary variables: 
		evt: 	[(19.0@15.0) mouseUp 63625693 nil]
		all: 	an Array(a SpToolbarButtonMorph(888790016) a SpToolbarButtonMorph(2143[..]
	Receiver's instance variables: 
		bounds: 	(0.0@5.0) corner: (45.0@39.0)
		owner: 	a Morph(1073167616)
		submorphs: 	an Array(an AlignmentMorph(116792320))
		fullBounds: 	nil
		color: 	(Color r: 0.9012707722385142 g: 0.9012707722385142 b: 0.901270772238[..]
		extension: 	a MorphExtension (509491200) [balloonText]  [other:  (presenter [..]
		borderWidth: 	0
		borderColor: 	#simple
		model: 	a SpMorphicToolbarButtonAdapter
		label: 	'Do it'
		icon: 	Form(13x13x32)
		getIconSelector: 	#icon
		getStateSelector: 	#state
		actionSelector: 	#execute
		font: 	a LogicalFont
 familyName: 'Source Sans Pro'
 emphasis: nil
 pointSiz[..]
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	nil
		getFontSelector: 	nil
		labelMorph: 	a LabelMorph(128736768)'Do it'
		iconMorph: 	an ImageMorph(1001562624)
		iconPosition: 	#top
		lastState: 	false
		badgeFont: 	nil
		badgeSelector: 	#badge


SpToolbarButtonMorph(Morph)>>handleMouseUp:
	Receiver: a SpToolbarButtonMorph(888790016)
	Arguments and temporary variables: 
		anEvent: 	[(19.0@15.0) mouseUp 63625693 nil]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(0.0@5.0) corner: (45.0@39.0)
		owner: 	a Morph(1073167616)
		submorphs: 	an Array(an AlignmentMorph(116792320))
		fullBounds: 	nil
		color: 	(Color r: 0.9012707722385142 g: 0.9012707722385142 b: 0.901270772238[..]
		extension: 	a MorphExtension (509491200) [balloonText]  [other:  (presenter [..]
		borderWidth: 	0
		borderColor: 	#simple
		model: 	a SpMorphicToolbarButtonAdapter
		label: 	'Do it'
		icon: 	Form(13x13x32)
		getIconSelector: 	#icon
		getStateSelector: 	#state
		actionSelector: 	#execute
		font: 	a LogicalFont
 familyName: 'Source Sans Pro'
 emphasis: nil
 pointSiz[..]
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	nil
		getFontSelector: 	nil
		labelMorph: 	a LabelMorph(128736768)'Do it'
		iconMorph: 	an ImageMorph(1001562624)
		iconPosition: 	#top
		lastState: 	false
		badgeFont: 	nil
		badgeSelector: 	#badge


MouseButtonEvent>>sentTo:
	Receiver: [(19.0@15.0) mouseUp 63625693 nil]
	Arguments and temporary variables: 
		anObject: 	a SpToolbarButtonMorph(888790016)
	Receiver's instance variables: 
		timeStamp: 	63625693
		source: 	a HandMorph(337424384)
		windowIndex: 	nil
		type: 	#mouseUp
		buttons: 	0
		position: 	(19.0@15.0)
		handler: 	nil
		wasHandled: 	true
		whichButton: 	4


SpToolbarButtonMorph(Morph)>>handleEvent:
	Receiver: a SpToolbarButtonMorph(888790016)
	Arguments and temporary variables: 
		anEvent: 	[(19.0@15.0) mouseUp 63625693 nil]
	Receiver's instance variables: 
		bounds: 	(0.0@5.0) corner: (45.0@39.0)
		owner: 	a Morph(1073167616)
		submorphs: 	an Array(an AlignmentMorph(116792320))
		fullBounds: 	nil
		color: 	(Color r: 0.9012707722385142 g: 0.9012707722385142 b: 0.901270772238[..]
		extension: 	a MorphExtension (509491200) [balloonText]  [other:  (presenter [..]
		borderWidth: 	0
		borderColor: 	#simple
		model: 	a SpMorphicToolbarButtonAdapter
		label: 	'Do it'
		icon: 	Form(13x13x32)
		getIconSelector: 	#icon
		getStateSelector: 	#state
		actionSelector: 	#execute
		font: 	a LogicalFont
 familyName: 'Source Sans Pro'
 emphasis: nil
 pointSiz[..]
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	nil
		getFontSelector: 	nil
		labelMorph: 	a LabelMorph(128736768)'Do it'
		iconMorph: 	an ImageMorph(1001562624)
		iconPosition: 	#top
		lastState: 	false
		badgeFont: 	nil
		badgeSelector: 	#badge


SpToolbarButtonMorph(Morph)>>handleFocusEvent:
	Receiver: a SpToolbarButtonMorph(888790016)
	Arguments and temporary variables: 
		anEvent: 	[(19.0@15.0) mouseUp 63625693 nil]
	Receiver's instance variables: 
		bounds: 	(0.0@5.0) corner: (45.0@39.0)
		owner: 	a Morph(1073167616)
		submorphs: 	an Array(an AlignmentMorph(116792320))
		fullBounds: 	nil
		color: 	(Color r: 0.9012707722385142 g: 0.9012707722385142 b: 0.901270772238[..]
		extension: 	a MorphExtension (509491200) [balloonText]  [other:  (presenter [..]
		borderWidth: 	0
		borderColor: 	#simple
		model: 	a SpMorphicToolbarButtonAdapter
		label: 	'Do it'
		icon: 	Form(13x13x32)
		getIconSelector: 	#icon
		getStateSelector: 	#state
		actionSelector: 	#execute
		font: 	a LogicalFont
 familyName: 'Source Sans Pro'
 emphasis: nil
 pointSiz[..]
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	nil
		getFontSelector: 	nil
		labelMorph: 	a LabelMorph(128736768)'Do it'
		iconMorph: 	an ImageMorph(1001562624)
		iconPosition: 	#top
		lastState: 	false
		badgeFont: 	nil
		badgeSelector: 	#badge


[
		result := focusHolder handleFocusEvent: transformedEvent.
	] in HandMorph>>sendFocusEvent:to:clear:
	Receiver: a HandMorph(337424384)
	Arguments and temporary variables: 
		anEvent: 	[(397@257) mouseUp 63625693 nil]
		focusHolder: 	a SpToolbarButtonMorph(888790016)
		aBlock: 	[self mouseFocus: nil]
		w: 	a WorldMorph(341720576) [world]
		transformedEvent: 	[(19.0@15.0) mouseUp 63625693 nil]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(397@257.0) corner: (413@273.0)
		owner: 	a WorldMorph(341720576) [world]
		submorphs: 	#()
		fullBounds: 	(397@257.0) corner: (413@273.0)
		color: 	Color blue
		extension: 	a MorphExtension (370611968)
		mouseFocus: 	nil
		keyboardFocus: 	a RubEditingArea(919167488)
		eventListeners: 	nil
		mouseListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(397@257) mouseUp 63625693 nil]
		targetOffset: 	(19.0@10.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 0 0 0 0 0 nil nil)
		captureBlock: 	nil
		recentModifiers: 	0
		pendingEventQueue: 	WaitfreeQueue with 0 items
		supressNextKeyPress: 	false


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
		result := focusHolder handleFocusEvent: transformedEvent.
	]
	Arguments and temporary variables: 
		exception: 	Error
		handlerAction: 	[ :ex |
			ActiveWorld := priorWorld.
			ex pass ]
	Receiver's instance variables: 
		outerContext: 	HandMorph>>sendFocusEvent:to:clear:
		compiledBlock: 	a CompiledBlock: [
		result := focusHolder handleFocusEvent:[..]
		numArgs: 	0
		receiver: 	a HandMorph(337424384)


WorldMorph>>becomeActiveDuring:
	Receiver: a WorldMorph(341720576) [world]
	Arguments and temporary variables: 
		aBlock: 	[
		result := focusHolder handleFocusEvent: transformedEvent.
	]
		priorWorld: 	a WorldMorph(341720576) [world]
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1728@1051)
		owner: 	nil
		submorphs: 	an Array(a MenubarMorph(112886016) a TaskbarMorph(279458560) a S[..]
		fullBounds: 	(0@0) corner: (1728@1051)
		color: 	(Color r: 0.9403714565004888 g: 0.9403714565004888 b: 0.940371456500[..]
		extension: 	a MorphExtension (1012946432) [other:  (dragEnabled -> true) (dr[..]
		borderWidth: 	0
		borderColor: 	(Color r: 0.8611925708699902 g: 1.0 b: 0.7223851417399805 alph[..]
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil


HandMorph>>sendFocusEvent:to:clear:
	Receiver: a HandMorph(337424384)
	Arguments and temporary variables: 
		result: 	nil
		anEvent: 	[(397@257) mouseUp 63625693 nil]
		focusHolder: 	a SpToolbarButtonMorph(888790016)
		aBlock: 	[self mouseFocus: nil]
		w: 	a WorldMorph(341720576) [world]
		transformedEvent: 	[(19.0@15.0) mouseUp 63625693 nil]
	Receiver's instance variables: 
		bounds: 	(397@257.0) corner: (413@273.0)
		owner: 	a WorldMorph(341720576) [world]
		submorphs: 	#()
		fullBounds: 	(397@257.0) corner: (413@273.0)
		color: 	Color blue
		extension: 	a MorphExtension (370611968)
		mouseFocus: 	nil
		keyboardFocus: 	a RubEditingArea(919167488)
		eventListeners: 	nil
		mouseListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(397@257) mouseUp 63625693 nil]
		targetOffset: 	(19.0@10.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 0 0 0 0 0 nil nil)
		captureBlock: 	nil
		recentModifiers: 	0
		pendingEventQueue: 	WaitfreeQueue with 0 items
		supressNextKeyPress: 	false


HandMorph>>sendEvent:focus:clear:
	Receiver: a HandMorph(337424384)
	Arguments and temporary variables: 
		anEvent: 	[(397@257) mouseUp 63625693 nil]
		focusHolder: 	a SpToolbarButtonMorph(888790016)
		aBlock: 	[self mouseFocus: nil]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(397@257.0) corner: (413@273.0)
		owner: 	a WorldMorph(341720576) [world]
		submorphs: 	#()
		fullBounds: 	(397@257.0) corner: (413@273.0)
		color: 	Color blue
		extension: 	a MorphExtension (370611968)
		mouseFocus: 	nil
		keyboardFocus: 	a RubEditingArea(919167488)
		eventListeners: 	nil
		mouseListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(397@257) mouseUp 63625693 nil]
		targetOffset: 	(19.0@10.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 0 0 0 0 0 nil nil)
		captureBlock: 	nil
		recentModifiers: 	0
		pendingEventQueue: 	WaitfreeQueue with 0 items
		supressNextKeyPress: 	false


HandMorph>>sendMouseEvent:
	Receiver: a HandMorph(337424384)
	Arguments and temporary variables: 
		anEvent: 	[(397@257) mouseUp 63625693 nil]
	Receiver's instance variables: 
		bounds: 	(397@257.0) corner: (413@273.0)
		owner: 	a WorldMorph(341720576) [world]
		submorphs: 	#()
		fullBounds: 	(397@257.0) corner: (413@273.0)
		color: 	Color blue
		extension: 	a MorphExtension (370611968)
		mouseFocus: 	nil
		keyboardFocus: 	a RubEditingArea(919167488)
		eventListeners: 	nil
		mouseListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(397@257) mouseUp 63625693 nil]
		targetOffset: 	(19.0@10.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 0 0 0 0 0 nil nil)
		captureBlock: 	nil
		recentModifiers: 	0
		pendingEventQueue: 	WaitfreeQueue with 0 items
		supressNextKeyPress: 	false


HandMorph>>handleEvent:
	Receiver: a HandMorph(337424384)
	Arguments and temporary variables: 
		anEvent: 	[(397@257) mouseUp 63625693 nil]
		evt: 	[(397@257) mouseUp 63625693 nil]
	Receiver's instance variables: 
		bounds: 	(397@257.0) corner: (413@273.0)
		owner: 	a WorldMorph(341720576) [world]
		submorphs: 	#()
		fullBounds: 	(397@257.0) corner: (413@273.0)
		color: 	Color blue
		extension: 	a MorphExtension (370611968)
		mouseFocus: 	nil
		keyboardFocus: 	a RubEditingArea(919167488)
		eventListeners: 	nil
		mouseListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(397@257) mouseUp 63625693 nil]
		targetOffset: 	(19.0@10.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 0 0 0 0 0 nil nil)
		captureBlock: 	nil
		recentModifiers: 	0
		pendingEventQueue: 	WaitfreeQueue with 0 items
		supressNextKeyPress: 	false


[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil ]) ifTrue: [
			morphicWorld activeHand handleEvent: anEvent
		]
	] in OSWindowMorphicEventHandler>>dispatchMorphicEvent:
	Receiver: an OSWindowMorphicEventHandler
	Arguments and temporary variables: 
		anEvent: 	[(397@257) mouseUp 63625693 nil]
	Receiver's instance variables: 
		morphicWorld: 	a WorldMorph(341720576) [world]


WorldState>>runStepMethodsIn:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(341720576) [world]
		queue: 	WaitfreeQueue with 0 items
		nextInQueue: 	[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNo[..]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(337424384))
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap()
		lastStepTime: 	35939115
		lastStepMessage: 	nil
		alarms: 	a Heap(MorphicAlarm(#hideShow -> a RubCursor(899173120)))
		lastAlarmTime: 	63625680
		activeHand: 	a HandMorph(337424384)
		currentCursor: 	((CursorWithMask
	extent: (16@16)
	depth: 1
	fromArray: #(
	[..]
		worldRenderer: 	an OSWorldRenderer
		realWindowExtent: 	(1728@1051)
		deferredUIMessages: 	WaitfreeQueue with 0 items


WorldMorph>>runStepMethods
	Receiver: a WorldMorph(341720576) [world]
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1728@1051)
		owner: 	nil
		submorphs: 	an Array(a MenubarMorph(112886016) a TaskbarMorph(279458560) a S[..]
		fullBounds: 	(0@0) corner: (1728@1051)
		color: 	(Color r: 0.9403714565004888 g: 0.9403714565004888 b: 0.940371456500[..]
		extension: 	a MorphExtension (1012946432) [other:  (dragEnabled -> true) (dr[..]
		borderWidth: 	0
		borderColor: 	(Color r: 0.8611925708699902 g: 1.0 b: 0.7223851417399805 alph[..]
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil


WorldState>>doOneCycleFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(341720576) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(337424384))
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap()
		lastStepTime: 	35939115
		lastStepMessage: 	nil
		alarms: 	a Heap(MorphicAlarm(#hideShow -> a RubCursor(899173120)))
		lastAlarmTime: 	63625680
		activeHand: 	a HandMorph(337424384)
		currentCursor: 	((CursorWithMask
	extent: (16@16)
	depth: 1
	fromArray: #(
	[..]
		worldRenderer: 	an OSWorldRenderer
		realWindowExtent: 	(1728@1051)
		deferredUIMessages: 	WaitfreeQueue with 0 items


WorldMorph>>doOneCycleNow
	Receiver: a WorldMorph(341720576) [world]
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1728@1051)
		owner: 	nil
		submorphs: 	an Array(a MenubarMorph(112886016) a TaskbarMorph(279458560) a S[..]
		fullBounds: 	(0@0) corner: (1728@1051)
		color: 	(Color r: 0.9403714565004888 g: 0.9403714565004888 b: 0.940371456500[..]
		extension: 	a MorphExtension (1012946432) [other:  (dragEnabled -> true) (dr[..]
		borderWidth: 	0
		borderColor: 	(Color r: 0.8611925708699902 g: 1.0 b: 0.7223851417399805 alph[..]
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil


WorldMorph>>doOneCycle
	Receiver: a WorldMorph(341720576) [world]
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1728@1051)
		owner: 	nil
		submorphs: 	an Array(a MenubarMorph(112886016) a TaskbarMorph(279458560) a S[..]
		fullBounds: 	(0@0) corner: (1728@1051)
		color: 	(Color r: 0.9403714565004888 g: 0.9403714565004888 b: 0.940371456500[..]
		extension: 	a MorphExtension (1012946432) [other:  (dragEnabled -> true) (dr[..]
		borderWidth: 	0
		borderColor: 	(Color r: 0.8611925708699902 g: 1.0 b: 0.7223851417399805 alph[..]
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil


[
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMutex critical: [
			                     self extraWorldList ].
		extraWorldsToDraw do: [ :world | world doOneCycle ].

		(self currentWorld isNotNil and: [
			 (extraWorldsToDraw includes: self currentWorld) not ]) ifTrue: [
			self currentWorld doOneCycle ] ] in WorldMorph class>>doOneCycle
	Receiver: WorldMorph
	Arguments and temporary variables: 
		extraWorldsToDraw: 	#()
	Receiver's instance variables: 
		superclass: 	PasteUpMorph
		methodDict: 	a MethodDictionary(#acceptDroppingMorph:event:->WorldMorph>>#ac[..]
		format: 	65547
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		commentSourcePointer: 	nil
		subclasses: 	{AthensWorldMorph. OSWindowWorldMorph}
		name: 	#WorldMorph
		classPool: 	a Dictionary(#AllowDropFiles->nil #CursorOwnerWorld->a WorldMorp[..]
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Morphic-Core-Worlds'
		announcer: 	nil
		displayScaleFactor: 	1


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMutex critical: [
			  [..]
	Arguments and temporary variables: 
		aBlock: 	[
		self doInterCycleWait
	]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	WorldMorph class>>doOneCycle
		compiledBlock: 	a CompiledBlock: [
		| extraWorldsToDraw |
		extraWorldsToDr[..]
		numArgs: 	0
		receiver: 	WorldMorph


WorldState class>>doDrawCycleWith:
	Receiver: WorldState
	Arguments and temporary variables: 
		aBlock: 	[
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMute[..]
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary(#activeHand->WorldState>>#activeHand #active[..]
		format: 	65548
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		commentSourcePointer: 	nil
		subclasses: 	{AthensWorldState}
		name: 	#WorldState
		classPool: 	a Dictionary(#CanSurrenderToOS->nil #DebugShowDamage->false #Des[..]
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Morphic-Core-Worlds'



--- The full stack ---
RSBox(Object)>>doesNotUnderstand: #label:
VisualizerMain>>createSampleGraph
UndefinedObject>>DoIt
OCReceiverDoItSemanticScope(OCDoItSemanticScope)>>evaluateDoIt:
OpalCompiler>>evaluate
[
		self announcer announce: (SpCodeWillBeEvaluatedAnnouncement newContent: aString).
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionModel doItReceiver.
		result := receiver class compiler
			source: aString;
			context: self interactionModel doItContext;
			receiver: self interactionModel doItReceiver;
			requestor: self interactionModel;
			environment: self environment;
			failBlock:  [ 
				self announcer announce: (SpCodeEvaluationFailedAnnouncement newContent: aString).
				^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		self announcer announce: (SpCodeEvaluationSucceedAnnouncement newContent: aString).
		result ] in SpCodePresenter>>evaluate:onCompileError:onError:
FullBlockClosure(BlockClosure)>>on:do:
SpCodePresenter>>evaluate:onCompileError:onError:
StPlaygroundPagePresenter>>doEvaluateAndGo
StPlaygroundPagePresenter>>doEvaluateAllAndGo
StPlaygroundDoItCommand>>execute
SpCommand(CmCommandDecorator)>>execute
[ specCommand execute ] in [ :specCommand | 
			aButtonClass new
				label: specCommand name;
				help: specCommand description;
				in: [ :button | 
					specCommand hasIcon
						ifTrue: [ button icon: specCommand icon ] ];
				action: [ specCommand execute ];
				yourself ] in SpCommand>>configureAsButtonOfClass:
FullBlockClosure(BlockClosure)>>cull:
SpMorphicToolbarButtonAdapter>>execute
SpToolbarButtonMorph(PluggableButtonMorph)>>performAction:
[:m |
		(m containsPoint: evt cursorPoint) ifTrue: [m enabled ifTrue: [ m performAction: evt ]]] in SpToolbarButtonMorph(PluggableButtonMorph)>>mouseUp:
Array(SequenceableCollection)>>do:
SpToolbarButtonMorph(PluggableButtonMorph)>>mouseUp:
SpToolbarButtonMorph(Morph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
SpToolbarButtonMorph(Morph)>>handleEvent:
SpToolbarButtonMorph(Morph)>>handleFocusEvent:
[
		result := focusHolder handleFocusEvent: transformedEvent.
	] in HandMorph>>sendFocusEvent:to:clear:
FullBlockClosure(BlockClosure)>>on:do:
WorldMorph>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil ]) ifTrue: [
			morphicWorld activeHand handleEvent: anEvent
		]
	] in OSWindowMorphicEventHandler>>dispatchMorphicEvent:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycleNow
WorldMorph>>doOneCycle
[
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMutex critical: [
			                     self extraWorldList ].
		extraWorldsToDraw do: [ :world | world doOneCycle ].

		(self currentWorld isNotNil and: [
			 (extraWorldsToDraw includes: self currentWorld) not ]) ifTrue: [
			self currentWorld doOneCycle ] ] in WorldMorph class>>doOneCycle
FullBlockClosure(BlockClosure)>>ensure:
WorldState class>>doDrawCycleWith:
 - - - - - - - - - - - - - - -
			- - - - - - - - - - - - - - - - - -
WorldMorph class>>doOneCycle
MorphicRenderLoop>>doOneCycle
MorphicRenderLoop>>doOneCycleWhile:
LongMessageDialogWindow(SystemWindow)>>openModal
PharoLightTheme(UITheme)>>longMessageIn:text:title:
MorphicUIManager>>longMessage:title:
ClyShowCritiqueDetailsCommand>>execute
ClyCriticContext>>executeCommand:by:
[self prepareCommandForExecution.
	context executeCommand: command by: self.
	self applyCommandResult] in CmdCommandActivator>>executeCommand
FullBlockClosure(BlockClosure)>>on:do:
CmdCommandActivator>>executeCommand
[target perform: actionSelector withArguments: arguments] in IconicButtonMorph(SimpleButtonMorph)>>doButtonAction
FullBlockClosure(BlockClosure)>>ensure:
CursorWithMask(Cursor)>>showWhile:
IconicButtonMorph(SimpleButtonMorph)>>doButtonAction
IconicButtonMorph(SimpleButtonMorph)>>mouseUp:
IconicButtonMorph(Morph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
IconicButtonMorph(Morph)>>handleEvent:
IconicButtonMorph(Morph)>>handleFocusEvent:
[
		result := focusHolder handleFocusEvent: transformedEvent.
	] in HandMorph>>sendFocusEvent:to:clear:
FullBlockClosure(BlockClosure)>>on:do:
WorldMorph>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil ]) ifTrue: [
			morphicWorld activeHand handleEvent: anEvent
		]
	] in OSWindowMorphicEventHandler>>dispatchMorphicEvent:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycleNow
WorldMorph>>doOneCycle
[
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMutex critical: [
			                     self extraWorldList ].
		extraWorldsToDraw do: [ :world | world doOneCycle ].

		(self currentWorld isNotNil and: [
			 (extraWorldsToDraw includes: self currentWorld) not ]) ifTrue: [
			self currentWorld doOneCycle ] ] in WorldMorph class>>doOneCycle
FullBlockClosure(BlockClosure)>>ensure:
WorldState class>>doDrawCycleWith:
WorldMorph class>>doOneCycle
MorphicRenderLoop>>doOneCycle
MorphicRenderLoop>>doOneCycleWhile:
[ MorphicRenderLoop new doOneCycleWhile: [ true ] ] in MorphicUIManager>>spawnNewProcess
[self value.
			"IMPORTANT: Do not step over next line of code. See method comments for details"
			Processor terminateRealActive] in FullBlockClosure(BlockClosure)>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
Instance of RSBox did not understand #label:
24 October 2023 5:32:40.83047 pm

VM: Mac OS - arm64 - 1000 - CoInterpreter VMMaker-tonel.1 uuid: 902dd483-c0c4-0d00-86f2-0f880df24b96 Oct 23 2023
StackToRegisterMappingCogit VMMaker-tonel.1 uuid: 902dd483-c0c4-0d00-86f2-0f880df24b96 Oct 23 2023
v10.0.8 - Commit: b323c5fb - Date: 2023-10-20 16:02:07 -0400

Image: Pharo11.0.0 [Build information: Pharo-11.0.0+build.710.sha.ea28d8552cac85a7ce1e9c34ab1e7bd45f7b9910 (64 Bit)]

RSBox(Object)>>doesNotUnderstand: #label:
	Receiver: a RSBox
	Arguments and temporary variables: 
		aMessage: 	label: 'Alice'
		exception: 	Instance of RSBox did not understand #label:
		resumeValue: 	nil
	Receiver's instance variables: 
		announcer: 	nil
		properties: 	nil
		paint: 	Color blue
		path: 	(-25.0@ -25.0) corner: (25.0@25.0)
		border: 	nil
		parent: 	nil
		isFixed: 	false
		encompassingRectangle: 	nil
		model: 	nil
		baseRectangle: 	(-25.0@ -25.0) corner: (25.0@25.0)
		matrix: 	x: 0.0 y: 0.0 sx: 1.0 sy: 1.0 shx: 0.0 shy: 0.0
		connectedLines: 	nil
		shouldUpdateLines: 	true
		cornerRadius: 	nil


VisualizerMain>>createSampleGraph
	Receiver: a VisualizerMain
	Arguments and temporary variables: 
		view: 	a RSCanvas
		alice: 	nil
		bob: 	nil
	Receiver's instance variables: 
a VisualizerMain

UndefinedObject>>DoIt
	Receiver: nil
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
nil

OCReceiverDoItSemanticScope(OCDoItSemanticScope)>>evaluateDoIt:
	Receiver: an OCReceiverDoItSemanticScope
	Arguments and temporary variables: 
		doItMethod: 	UndefinedObject>>#DoIt
	Receiver's instance variables: 
		outerScope: 	nil
		targetReceiver: 	nil


OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
		doItMethod: 	UndefinedObject>>#DoIt
	Receiver's instance variables: 
		ast: 	DoIt

	^ VisualizerMain new createSampleGraph open
		source: 	a ReadStream
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil


[
		self announcer announce: (SpCodeWillBeEvaluatedAnnouncement newContent: aString).
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionModel doItReceiver.
		result := receiver class compiler
			source: aString;
			context: self interactionModel doItContext;
			receiver: self interactionModel doItReceiver;
			requestor: self interactionModel;
			environment: self environment;
			failBlock:  [ 
				self announcer announce: (SpCodeEvaluationFailedAnnouncement newContent: aString).
				^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		self announcer announce: (SpCodeEvaluationSucceedAnnouncement newContent: aString).
		result ] in SpCodePresenter>>evaluate:onCompileError:onError:
	Receiver: a SpCodePresenter
	Arguments and temporary variables: 
		aString: 	'(VisualizerMain new createSampleGraph) open.
'
		compileErrorBlock: 	[ ^ self ]
		errorBlock: 	[ :e | e pass ]
		receiver: 	nil
		result: 	nil
		oldBindings: 	a Dictionary()
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicCodeAdapter)
		announcer: 	an Announcer
		owner: 	a StPlaygroundPagePresenter
		adapter: 	a SpMorphicCodeAdapter
		needRebuild: 	true
		eventHandler: 	a SpEventHandler
		application: 	nil
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ a KMCategory ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Code' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpAbstractWidgetLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		borderWidth: 	an ObservableValueHolder[ nil ]
		borderColor: 	an ObservableValueHolder[ nil ]
		dragEnabled: 	an ObservableValueHolder[ false ]
		dropEnabled: 	an ObservableValueHolder[ false ]
		color: 	an ObservableValueHolder[ nil ]
		help: 	an ObservableValueHolder[ nil ]
		enabled: 	an ObservableValueHolder[ true ]
		wantsDrop: 	an ObservableValueHolder[ [ :transfer | self dropEnabled ] ]
		acceptDrop: 	an ObservableValueHolder[ [ :transfer | ] ]
		deferredActions: 	nil
		hasUnacceptedEdits: 	an ObservableValueHolder[ false ]
		selection: 	an ObservableValueHolder[ (1 to: 45) ]
		wantsVisualFeedback: 	an ObservableValueHolder[ true ]
		askBeforeDiscardingEdits: 	an ObservableValueHolder[ true ]
		text: 	an ObservableValueHolder[ '(VisualizerMain new createSampleGraph) ope[..]
		actionToPerform: 	an ObservableValueHolder[ [ :txt |  ] ]
		readSelection: 	an ObservableValueHolder[ [ selection ] ]
		placeholder: 	an ObservableValueHolder[ '' ]
		contextMenu: 	an ObservableValueHolder[ [ (self menuActionsFor: text) asMenu[..]
		scrollValue: 	an ObservableValueHolder[ (0@0) ]
		editionContextMenu: 	an ObservableValueHolder[ true ]
		editable: 	an ObservableValueHolder[ true ]
		wrapWord: 	an ObservableValueHolder[ true ]
		undoRedoHistory: 	true
		wrapScrollBars: 	true
		propagateNaturalHeight: 	false
		propagateNaturalWidth: 	false
		scrollBarStyles: 	#()
		syntaxHighlight: 	an ObservableValueHolder[ true ]
		smartCharacters: 	an ObservableValueHolder[ true ]
		lineNumbers: 	an ObservableValueHolder[ true ]
		interactionModel: 	an ObservableValueHolder[ a StPlaygroundInteractionModel ]
		overrideContextMenu: 	true
		submitBlock: 	nil
		resetBlock: 	nil
		environment: 	nil
		systemNavigation: 	nil
		syntaxHighlightTheme: 	an ObservableValueHolder[ nil ]


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
		self announcer announce: (SpCodeWillBeEvaluatedAnnouncement newContent: aString).
[..]
	Arguments and temporary variables: 
		exception: 	Error
		handlerAction: 	[ :e |
		self announcer announce: (SpCodeEvaluationFailedAnn[..]
	Receiver's instance variables: 
		outerContext: 	SpCodePresenter>>evaluate:onCompileError:onError:
		compiledBlock: 	a CompiledBlock: [
		self announcer announce: (SpCodeWillBeE[..]
		numArgs: 	0
		receiver: 	a SpCodePresenter


SpCodePresenter>>evaluate:onCompileError:onError:
	Receiver: a SpCodePresenter
	Arguments and temporary variables: 
		receiver: 	nil
		result: 	nil
		oldBindings: 	a Dictionary()
		aString: 	'(VisualizerMain new createSampleGraph) open.
'
		compileErrorBlock: 	[ ^ self ]
		errorBlock: 	[ :e | e pass ]
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicCodeAdapter)
		announcer: 	an Announcer
		owner: 	a StPlaygroundPagePresenter
		adapter: 	a SpMorphicCodeAdapter
		needRebuild: 	true
		eventHandler: 	a SpEventHandler
		application: 	nil
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ a KMCategory ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Code' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpAbstractWidgetLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		borderWidth: 	an ObservableValueHolder[ nil ]
		borderColor: 	an ObservableValueHolder[ nil ]
		dragEnabled: 	an ObservableValueHolder[ false ]
		dropEnabled: 	an ObservableValueHolder[ false ]
		color: 	an ObservableValueHolder[ nil ]
		help: 	an ObservableValueHolder[ nil ]
		enabled: 	an ObservableValueHolder[ true ]
		wantsDrop: 	an ObservableValueHolder[ [ :transfer | self dropEnabled ] ]
		acceptDrop: 	an ObservableValueHolder[ [ :transfer | ] ]
		deferredActions: 	nil
		hasUnacceptedEdits: 	an ObservableValueHolder[ false ]
		selection: 	an ObservableValueHolder[ (1 to: 45) ]
		wantsVisualFeedback: 	an ObservableValueHolder[ true ]
		askBeforeDiscardingEdits: 	an ObservableValueHolder[ true ]
		text: 	an ObservableValueHolder[ '(VisualizerMain new createSampleGraph) ope[..]
		actionToPerform: 	an ObservableValueHolder[ [ :txt |  ] ]
		readSelection: 	an ObservableValueHolder[ [ selection ] ]
		placeholder: 	an ObservableValueHolder[ '' ]
		contextMenu: 	an ObservableValueHolder[ [ (self menuActionsFor: text) asMenu[..]
		scrollValue: 	an ObservableValueHolder[ (0@0) ]
		editionContextMenu: 	an ObservableValueHolder[ true ]
		editable: 	an ObservableValueHolder[ true ]
		wrapWord: 	an ObservableValueHolder[ true ]
		undoRedoHistory: 	true
		wrapScrollBars: 	true
		propagateNaturalHeight: 	false
		propagateNaturalWidth: 	false
		scrollBarStyles: 	#()
		syntaxHighlight: 	an ObservableValueHolder[ true ]
		smartCharacters: 	an ObservableValueHolder[ true ]
		lineNumbers: 	an ObservableValueHolder[ true ]
		interactionModel: 	an ObservableValueHolder[ a StPlaygroundInteractionModel ]
		overrideContextMenu: 	true
		submitBlock: 	nil
		resetBlock: 	nil
		environment: 	nil
		systemNavigation: 	nil
		syntaxHighlightTheme: 	an ObservableValueHolder[ nil ]


StPlaygroundPagePresenter>>doEvaluateAndGo
	Receiver: a StPlaygroundPagePresenter
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicBoxAdapter)
		announcer: 	an Announcer
		owner: 	a SpMillerColumnPresenter
		adapter: 	a SpMorphicBoxAdapter
		needRebuild: 	true
		eventHandler: 	nil
		application: 	a StPharoApplication
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ nil ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Untitled window' ]
		additionalSubpresentersMap: 	a Dictionary()
		layout: 	an ObservableValueHolder[ a SpBoxLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		text: 	a SpCodePresenter
		toolbar: 	a SpToolbarPresenter
		statusbar: 	a SpPresenter
		lineLabel: 	a SpLabelPresenter
		toggleLineNumberButton: 	a SpToggleButtonPresenter
		page: 	a StPlaygroundPage
		activationBlock: 	[ :selection |
		self changeSelection: selection from: new[..]


StPlaygroundPagePresenter>>doEvaluateAllAndGo
	Receiver: a StPlaygroundPagePresenter
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicBoxAdapter)
		announcer: 	an Announcer
		owner: 	a SpMillerColumnPresenter
		adapter: 	a SpMorphicBoxAdapter
		needRebuild: 	true
		eventHandler: 	nil
		application: 	a StPharoApplication
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ nil ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Untitled window' ]
		additionalSubpresentersMap: 	a Dictionary()
		layout: 	an ObservableValueHolder[ a SpBoxLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		text: 	a SpCodePresenter
		toolbar: 	a SpToolbarPresenter
		statusbar: 	a SpPresenter
		lineLabel: 	a SpLabelPresenter
		toggleLineNumberButton: 	a SpToggleButtonPresenter
		page: 	a StPlaygroundPage
		activationBlock: 	[ :selection |
		self changeSelection: selection from: new[..]


StPlaygroundDoItCommand>>execute
	Receiver: a StPlaygroundDoItCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		context: 	a StPlaygroundPagePresenter
		basicName: 	'Do it'
		basicDescription: 	'Do it all and inspect.'


SpCommand(CmCommandDecorator)>>execute
	Receiver: a SpCommand(Do it)
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a StPlaygroundDoItCommand
		iconProvider: 	a StPharoApplication
		iconName: 	#glamorousGo
		shortcutKey: 	nil
		displayStrategy: 	a CmUIDisableWhenCantBeRun
		positionStrategy: 	a CmUILeftPositionStrategy
		buildPresenterBlock: 	[ :specCommand | 
			aButtonClass new
				label: specC[..]
		presenter: 	a SpToolbarButtonPresenter


[ specCommand execute ] in [ :specCommand | 
			aButtonClass new
				label: specCommand name;
				help: specCommand description;
				in: [ :button | 
					specCommand hasIcon
						ifTrue: [ button icon: specCommand icon ] ];
				action: [ specCommand execute ];
				yourself ] in SpCommand>>configureAsButtonOfClass:
	Receiver: a SpCommand(Do it)
	Arguments and temporary variables: 
		aButtonClass: 	nil
		specCommand: 	a SpCommand(Do it)
	Receiver's instance variables: 
		decoratedCommand: 	a StPlaygroundDoItCommand
		iconProvider: 	a StPharoApplication
		iconName: 	#glamorousGo
		shortcutKey: 	nil
		displayStrategy: 	a CmUIDisableWhenCantBeRun
		positionStrategy: 	a CmUILeftPositionStrategy
		buildPresenterBlock: 	[ :specCommand | 
			aButtonClass new
				label: specC[..]
		presenter: 	a SpToolbarButtonPresenter


FullBlockClosure(BlockClosure)>>cull:
	Receiver: [ specCommand execute ]
	Arguments and temporary variables: 
		anArg: 	a SpToolbarButtonPresenter
	Receiver's instance variables: 
		outerContext: 	[ :specCommand | 
			aButtonClass new
				label: specCommand [..]
		compiledBlock: 	a CompiledBlock: [ specCommand execute ]
		numArgs: 	0
		receiver: 	a SpCommand(Do it)


SpMorphicToolbarButtonAdapter>>execute
	Receiver: a SpMorphicToolbarButtonAdapter
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpToolbarButtonMorph(888790016))
		announcer: 	nil
		model: 	a SpToolbarButtonPresenter
		widget: 	a SpToolbarButtonMorph(888790016)
		selector: 	nil
		owner: 	a SpToolbarButtonPresenter
		unsubscribed: 	false


SpToolbarButtonMorph(PluggableButtonMorph)>>performAction:
	Receiver: a SpToolbarButtonMorph(888790016)
	Arguments and temporary variables: 
		event: 	[(19.0@15.0) mouseUp 63625693 nil]
	Receiver's instance variables: 
		bounds: 	(0.0@5.0) corner: (45.0@39.0)
		owner: 	a Morph(1073167616)
		submorphs: 	an Array(an AlignmentMorph(116792320))
		fullBounds: 	nil
		color: 	(Color r: 0.9012707722385142 g: 0.9012707722385142 b: 0.901270772238[..]
		extension: 	a MorphExtension (509491200) [balloonText]  [other:  (presenter [..]
		borderWidth: 	0
		borderColor: 	#simple
		model: 	a SpMorphicToolbarButtonAdapter
		label: 	'Do it'
		icon: 	Form(13x13x32)
		getIconSelector: 	#icon
		getStateSelector: 	#state
		actionSelector: 	#execute
		font: 	a LogicalFont
 familyName: 'Source Sans Pro'
 emphasis: nil
 pointSiz[..]
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	nil
		getFontSelector: 	nil
		labelMorph: 	a LabelMorph(128736768)'Do it'
		iconMorph: 	an ImageMorph(1001562624)
		iconPosition: 	#top
		lastState: 	false
		badgeFont: 	nil
		badgeSelector: 	#badge


[:m |
		(m containsPoint: evt cursorPoint) ifTrue: [m enabled ifTrue: [ m performAction: evt ]]] in SpToolbarButtonMorph(PluggableButtonMorph)>>mouseUp:
	Receiver: a SpToolbarButtonMorph(888790016)
	Arguments and temporary variables: 
		evt: 	[(19.0@15.0) mouseUp 63625693 nil]
		all: 	an Array(a SpToolbarButtonMorph(888790016) a SpToolbarButtonMorph(2143[..]
		m: 	a SpToolbarButtonMorph(888790016)
	Receiver's instance variables: 
		bounds: 	(0.0@5.0) corner: (45.0@39.0)
		owner: 	a Morph(1073167616)
		submorphs: 	an Array(an AlignmentMorph(116792320))
		fullBounds: 	nil
		color: 	(Color r: 0.9012707722385142 g: 0.9012707722385142 b: 0.901270772238[..]
		extension: 	a MorphExtension (509491200) [balloonText]  [other:  (presenter [..]
		borderWidth: 	0
		borderColor: 	#simple
		model: 	a SpMorphicToolbarButtonAdapter
		label: 	'Do it'
		icon: 	Form(13x13x32)
		getIconSelector: 	#icon
		getStateSelector: 	#state
		actionSelector: 	#execute
		font: 	a LogicalFont
 familyName: 'Source Sans Pro'
 emphasis: nil
 pointSiz[..]
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	nil
		getFontSelector: 	nil
		labelMorph: 	a LabelMorph(128736768)'Do it'
		iconMorph: 	an ImageMorph(1001562624)
		iconPosition: 	#top
		lastState: 	false
		badgeFont: 	nil
		badgeSelector: 	#badge


Array(SequenceableCollection)>>do:
	Receiver: an Array(a SpToolbarButtonMorph(888790016) a SpToolbarButtonMorph(214329088) a SpToolb[..]
	Arguments and temporary variables: 
		aBlock: 	[:m |
		(m containsPoint: evt cursorPoint) ifTrue: [m enabled ifTru[..]
		index: 	1
	Receiver's instance variables: 
an Array(a SpToolbarButtonMorph(888790016) a SpToolbarButtonMorph(214329088) a SpToolb[..]

SpToolbarButtonMorph(PluggableButtonMorph)>>mouseUp:
	Receiver: a SpToolbarButtonMorph(888790016)
	Arguments and temporary variables: 
		evt: 	[(19.0@15.0) mouseUp 63625693 nil]
		all: 	an Array(a SpToolbarButtonMorph(888790016) a SpToolbarButtonMorph(2143[..]
	Receiver's instance variables: 
		bounds: 	(0.0@5.0) corner: (45.0@39.0)
		owner: 	a Morph(1073167616)
		submorphs: 	an Array(an AlignmentMorph(116792320))
		fullBounds: 	nil
		color: 	(Color r: 0.9012707722385142 g: 0.9012707722385142 b: 0.901270772238[..]
		extension: 	a MorphExtension (509491200) [balloonText]  [other:  (presenter [..]
		borderWidth: 	0
		borderColor: 	#simple
		model: 	a SpMorphicToolbarButtonAdapter
		label: 	'Do it'
		icon: 	Form(13x13x32)
		getIconSelector: 	#icon
		getStateSelector: 	#state
		actionSelector: 	#execute
		font: 	a LogicalFont
 familyName: 'Source Sans Pro'
 emphasis: nil
 pointSiz[..]
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	nil
		getFontSelector: 	nil
		labelMorph: 	a LabelMorph(128736768)'Do it'
		iconMorph: 	an ImageMorph(1001562624)
		iconPosition: 	#top
		lastState: 	false
		badgeFont: 	nil
		badgeSelector: 	#badge


SpToolbarButtonMorph(Morph)>>handleMouseUp:
	Receiver: a SpToolbarButtonMorph(888790016)
	Arguments and temporary variables: 
		anEvent: 	[(19.0@15.0) mouseUp 63625693 nil]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(0.0@5.0) corner: (45.0@39.0)
		owner: 	a Morph(1073167616)
		submorphs: 	an Array(an AlignmentMorph(116792320))
		fullBounds: 	nil
		color: 	(Color r: 0.9012707722385142 g: 0.9012707722385142 b: 0.901270772238[..]
		extension: 	a MorphExtension (509491200) [balloonText]  [other:  (presenter [..]
		borderWidth: 	0
		borderColor: 	#simple
		model: 	a SpMorphicToolbarButtonAdapter
		label: 	'Do it'
		icon: 	Form(13x13x32)
		getIconSelector: 	#icon
		getStateSelector: 	#state
		actionSelector: 	#execute
		font: 	a LogicalFont
 familyName: 'Source Sans Pro'
 emphasis: nil
 pointSiz[..]
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	nil
		getFontSelector: 	nil
		labelMorph: 	a LabelMorph(128736768)'Do it'
		iconMorph: 	an ImageMorph(1001562624)
		iconPosition: 	#top
		lastState: 	false
		badgeFont: 	nil
		badgeSelector: 	#badge


MouseButtonEvent>>sentTo:
	Receiver: [(19.0@15.0) mouseUp 63625693 nil]
	Arguments and temporary variables: 
		anObject: 	a SpToolbarButtonMorph(888790016)
	Receiver's instance variables: 
		timeStamp: 	63625693
		source: 	a HandMorph(337424384)
		windowIndex: 	nil
		type: 	#mouseUp
		buttons: 	0
		position: 	(19.0@15.0)
		handler: 	nil
		wasHandled: 	true
		whichButton: 	4


SpToolbarButtonMorph(Morph)>>handleEvent:
	Receiver: a SpToolbarButtonMorph(888790016)
	Arguments and temporary variables: 
		anEvent: 	[(19.0@15.0) mouseUp 63625693 nil]
	Receiver's instance variables: 
		bounds: 	(0.0@5.0) corner: (45.0@39.0)
		owner: 	a Morph(1073167616)
		submorphs: 	an Array(an AlignmentMorph(116792320))
		fullBounds: 	nil
		color: 	(Color r: 0.9012707722385142 g: 0.9012707722385142 b: 0.901270772238[..]
		extension: 	a MorphExtension (509491200) [balloonText]  [other:  (presenter [..]
		borderWidth: 	0
		borderColor: 	#simple
		model: 	a SpMorphicToolbarButtonAdapter
		label: 	'Do it'
		icon: 	Form(13x13x32)
		getIconSelector: 	#icon
		getStateSelector: 	#state
		actionSelector: 	#execute
		font: 	a LogicalFont
 familyName: 'Source Sans Pro'
 emphasis: nil
 pointSiz[..]
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	nil
		getFontSelector: 	nil
		labelMorph: 	a LabelMorph(128736768)'Do it'
		iconMorph: 	an ImageMorph(1001562624)
		iconPosition: 	#top
		lastState: 	false
		badgeFont: 	nil
		badgeSelector: 	#badge


SpToolbarButtonMorph(Morph)>>handleFocusEvent:
	Receiver: a SpToolbarButtonMorph(888790016)
	Arguments and temporary variables: 
		anEvent: 	[(19.0@15.0) mouseUp 63625693 nil]
	Receiver's instance variables: 
		bounds: 	(0.0@5.0) corner: (45.0@39.0)
		owner: 	a Morph(1073167616)
		submorphs: 	an Array(an AlignmentMorph(116792320))
		fullBounds: 	nil
		color: 	(Color r: 0.9012707722385142 g: 0.9012707722385142 b: 0.901270772238[..]
		extension: 	a MorphExtension (509491200) [balloonText]  [other:  (presenter [..]
		borderWidth: 	0
		borderColor: 	#simple
		model: 	a SpMorphicToolbarButtonAdapter
		label: 	'Do it'
		icon: 	Form(13x13x32)
		getIconSelector: 	#icon
		getStateSelector: 	#state
		actionSelector: 	#execute
		font: 	a LogicalFont
 familyName: 'Source Sans Pro'
 emphasis: nil
 pointSiz[..]
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	nil
		getFontSelector: 	nil
		labelMorph: 	a LabelMorph(128736768)'Do it'
		iconMorph: 	an ImageMorph(1001562624)
		iconPosition: 	#top
		lastState: 	false
		badgeFont: 	nil
		badgeSelector: 	#badge


[
		result := focusHolder handleFocusEvent: transformedEvent.
	] in HandMorph>>sendFocusEvent:to:clear:
	Receiver: a HandMorph(337424384)
	Arguments and temporary variables: 
		anEvent: 	[(397@257) mouseUp 63625693 nil]
		focusHolder: 	a SpToolbarButtonMorph(888790016)
		aBlock: 	[self mouseFocus: nil]
		w: 	a WorldMorph(341720576) [world]
		transformedEvent: 	[(19.0@15.0) mouseUp 63625693 nil]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(397@257.0) corner: (413@273.0)
		owner: 	a WorldMorph(341720576) [world]
		submorphs: 	#()
		fullBounds: 	(397@257.0) corner: (413@273.0)
		color: 	Color blue
		extension: 	a MorphExtension (370611968)
		mouseFocus: 	nil
		keyboardFocus: 	a RubEditingArea(919167488)
		eventListeners: 	nil
		mouseListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(397@257) mouseUp 63625693 nil]
		targetOffset: 	(19.0@10.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 0 0 0 0 0 nil nil)
		captureBlock: 	nil
		recentModifiers: 	0
		pendingEventQueue: 	WaitfreeQueue with 0 items
		supressNextKeyPress: 	false


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
		result := focusHolder handleFocusEvent: transformedEvent.
	]
	Arguments and temporary variables: 
		exception: 	Error
		handlerAction: 	[ :ex |
			ActiveWorld := priorWorld.
			ex pass ]
	Receiver's instance variables: 
		outerContext: 	HandMorph>>sendFocusEvent:to:clear:
		compiledBlock: 	a CompiledBlock: [
		result := focusHolder handleFocusEvent:[..]
		numArgs: 	0
		receiver: 	a HandMorph(337424384)


WorldMorph>>becomeActiveDuring:
	Receiver: a WorldMorph(341720576) [world]
	Arguments and temporary variables: 
		aBlock: 	[
		result := focusHolder handleFocusEvent: transformedEvent.
	]
		priorWorld: 	a WorldMorph(341720576) [world]
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1728@1051)
		owner: 	nil
		submorphs: 	an Array(a MenubarMorph(112886016) a TaskbarMorph(279458560) a S[..]
		fullBounds: 	(0@0) corner: (1728@1051)
		color: 	(Color r: 0.9403714565004888 g: 0.9403714565004888 b: 0.940371456500[..]
		extension: 	a MorphExtension (1012946432) [other:  (dragEnabled -> true) (dr[..]
		borderWidth: 	0
		borderColor: 	(Color r: 0.8611925708699902 g: 1.0 b: 0.7223851417399805 alph[..]
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil


HandMorph>>sendFocusEvent:to:clear:
	Receiver: a HandMorph(337424384)
	Arguments and temporary variables: 
		result: 	nil
		anEvent: 	[(397@257) mouseUp 63625693 nil]
		focusHolder: 	a SpToolbarButtonMorph(888790016)
		aBlock: 	[self mouseFocus: nil]
		w: 	a WorldMorph(341720576) [world]
		transformedEvent: 	[(19.0@15.0) mouseUp 63625693 nil]
	Receiver's instance variables: 
		bounds: 	(397@257.0) corner: (413@273.0)
		owner: 	a WorldMorph(341720576) [world]
		submorphs: 	#()
		fullBounds: 	(397@257.0) corner: (413@273.0)
		color: 	Color blue
		extension: 	a MorphExtension (370611968)
		mouseFocus: 	nil
		keyboardFocus: 	a RubEditingArea(919167488)
		eventListeners: 	nil
		mouseListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(397@257) mouseUp 63625693 nil]
		targetOffset: 	(19.0@10.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 0 0 0 0 0 nil nil)
		captureBlock: 	nil
		recentModifiers: 	0
		pendingEventQueue: 	WaitfreeQueue with 0 items
		supressNextKeyPress: 	false


HandMorph>>sendEvent:focus:clear:
	Receiver: a HandMorph(337424384)
	Arguments and temporary variables: 
		anEvent: 	[(397@257) mouseUp 63625693 nil]
		focusHolder: 	a SpToolbarButtonMorph(888790016)
		aBlock: 	[self mouseFocus: nil]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(397@257.0) corner: (413@273.0)
		owner: 	a WorldMorph(341720576) [world]
		submorphs: 	#()
		fullBounds: 	(397@257.0) corner: (413@273.0)
		color: 	Color blue
		extension: 	a MorphExtension (370611968)
		mouseFocus: 	nil
		keyboardFocus: 	a RubEditingArea(919167488)
		eventListeners: 	nil
		mouseListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(397@257) mouseUp 63625693 nil]
		targetOffset: 	(19.0@10.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 0 0 0 0 0 nil nil)
		captureBlock: 	nil
		recentModifiers: 	0
		pendingEventQueue: 	WaitfreeQueue with 0 items
		supressNextKeyPress: 	false


HandMorph>>sendMouseEvent:
	Receiver: a HandMorph(337424384)
	Arguments and temporary variables: 
		anEvent: 	[(397@257) mouseUp 63625693 nil]
	Receiver's instance variables: 
		bounds: 	(397@257.0) corner: (413@273.0)
		owner: 	a WorldMorph(341720576) [world]
		submorphs: 	#()
		fullBounds: 	(397@257.0) corner: (413@273.0)
		color: 	Color blue
		extension: 	a MorphExtension (370611968)
		mouseFocus: 	nil
		keyboardFocus: 	a RubEditingArea(919167488)
		eventListeners: 	nil
		mouseListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(397@257) mouseUp 63625693 nil]
		targetOffset: 	(19.0@10.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 0 0 0 0 0 nil nil)
		captureBlock: 	nil
		recentModifiers: 	0
		pendingEventQueue: 	WaitfreeQueue with 0 items
		supressNextKeyPress: 	false


HandMorph>>handleEvent:
	Receiver: a HandMorph(337424384)
	Arguments and temporary variables: 
		anEvent: 	[(397@257) mouseUp 63625693 nil]
		evt: 	[(397@257) mouseUp 63625693 nil]
	Receiver's instance variables: 
		bounds: 	(397@257.0) corner: (413@273.0)
		owner: 	a WorldMorph(341720576) [world]
		submorphs: 	#()
		fullBounds: 	(397@257.0) corner: (413@273.0)
		color: 	Color blue
		extension: 	a MorphExtension (370611968)
		mouseFocus: 	nil
		keyboardFocus: 	a RubEditingArea(919167488)
		eventListeners: 	nil
		mouseListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(397@257) mouseUp 63625693 nil]
		targetOffset: 	(19.0@10.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 0 0 0 0 0 nil nil)
		captureBlock: 	nil
		recentModifiers: 	0
		pendingEventQueue: 	WaitfreeQueue with 0 items
		supressNextKeyPress: 	false


[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil ]) ifTrue: [
			morphicWorld activeHand handleEvent: anEvent
		]
	] in OSWindowMorphicEventHandler>>dispatchMorphicEvent:
	Receiver: an OSWindowMorphicEventHandler
	Arguments and temporary variables: 
		anEvent: 	[(397@257) mouseUp 63625693 nil]
	Receiver's instance variables: 
		morphicWorld: 	a WorldMorph(341720576) [world]


WorldState>>runStepMethodsIn:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(341720576) [world]
		queue: 	WaitfreeQueue with 0 items
		nextInQueue: 	[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNo[..]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(337424384))
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap()
		lastStepTime: 	35939115
		lastStepMessage: 	nil
		alarms: 	a Heap(MorphicAlarm(#hideShow -> a RubCursor(899173120)))
		lastAlarmTime: 	63625680
		activeHand: 	a HandMorph(337424384)
		currentCursor: 	((CursorWithMask
	extent: (16@16)
	depth: 1
	fromArray: #(
	[..]
		worldRenderer: 	an OSWorldRenderer
		realWindowExtent: 	(1728@1051)
		deferredUIMessages: 	WaitfreeQueue with 0 items


WorldMorph>>runStepMethods
	Receiver: a WorldMorph(341720576) [world]
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1728@1051)
		owner: 	nil
		submorphs: 	an Array(a MenubarMorph(112886016) a TaskbarMorph(279458560) a S[..]
		fullBounds: 	(0@0) corner: (1728@1051)
		color: 	(Color r: 0.9403714565004888 g: 0.9403714565004888 b: 0.940371456500[..]
		extension: 	a MorphExtension (1012946432) [other:  (dragEnabled -> true) (dr[..]
		borderWidth: 	0
		borderColor: 	(Color r: 0.8611925708699902 g: 1.0 b: 0.7223851417399805 alph[..]
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil


WorldState>>doOneCycleFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(341720576) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(337424384))
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap()
		lastStepTime: 	35939115
		lastStepMessage: 	nil
		alarms: 	a Heap(MorphicAlarm(#hideShow -> a RubCursor(899173120)))
		lastAlarmTime: 	63625680
		activeHand: 	a HandMorph(337424384)
		currentCursor: 	((CursorWithMask
	extent: (16@16)
	depth: 1
	fromArray: #(
	[..]
		worldRenderer: 	an OSWorldRenderer
		realWindowExtent: 	(1728@1051)
		deferredUIMessages: 	WaitfreeQueue with 0 items


WorldMorph>>doOneCycleNow
	Receiver: a WorldMorph(341720576) [world]
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1728@1051)
		owner: 	nil
		submorphs: 	an Array(a MenubarMorph(112886016) a TaskbarMorph(279458560) a S[..]
		fullBounds: 	(0@0) corner: (1728@1051)
		color: 	(Color r: 0.9403714565004888 g: 0.9403714565004888 b: 0.940371456500[..]
		extension: 	a MorphExtension (1012946432) [other:  (dragEnabled -> true) (dr[..]
		borderWidth: 	0
		borderColor: 	(Color r: 0.8611925708699902 g: 1.0 b: 0.7223851417399805 alph[..]
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil


WorldMorph>>doOneCycle
	Receiver: a WorldMorph(341720576) [world]
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1728@1051)
		owner: 	nil
		submorphs: 	an Array(a MenubarMorph(112886016) a TaskbarMorph(279458560) a S[..]
		fullBounds: 	(0@0) corner: (1728@1051)
		color: 	(Color r: 0.9403714565004888 g: 0.9403714565004888 b: 0.940371456500[..]
		extension: 	a MorphExtension (1012946432) [other:  (dragEnabled -> true) (dr[..]
		borderWidth: 	0
		borderColor: 	(Color r: 0.8611925708699902 g: 1.0 b: 0.7223851417399805 alph[..]
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil


[
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMutex critical: [
			                     self extraWorldList ].
		extraWorldsToDraw do: [ :world | world doOneCycle ].

		(self currentWorld isNotNil and: [
			 (extraWorldsToDraw includes: self currentWorld) not ]) ifTrue: [
			self currentWorld doOneCycle ] ] in WorldMorph class>>doOneCycle
	Receiver: WorldMorph
	Arguments and temporary variables: 
		extraWorldsToDraw: 	#()
	Receiver's instance variables: 
		superclass: 	PasteUpMorph
		methodDict: 	a MethodDictionary(#acceptDroppingMorph:event:->WorldMorph>>#ac[..]
		format: 	65547
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		commentSourcePointer: 	nil
		subclasses: 	{AthensWorldMorph. OSWindowWorldMorph}
		name: 	#WorldMorph
		classPool: 	a Dictionary(#AllowDropFiles->nil #CursorOwnerWorld->a WorldMorp[..]
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Morphic-Core-Worlds'
		announcer: 	nil
		displayScaleFactor: 	1


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMutex critical: [
			  [..]
	Arguments and temporary variables: 
		aBlock: 	[
		self doInterCycleWait
	]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	WorldMorph class>>doOneCycle
		compiledBlock: 	a CompiledBlock: [
		| extraWorldsToDraw |
		extraWorldsToDr[..]
		numArgs: 	0
		receiver: 	WorldMorph


WorldState class>>doDrawCycleWith:
	Receiver: WorldState
	Arguments and temporary variables: 
		aBlock: 	[
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMute[..]
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary(#activeHand->WorldState>>#activeHand #active[..]
		format: 	65548
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		commentSourcePointer: 	nil
		subclasses: 	{AthensWorldState}
		name: 	#WorldState
		classPool: 	a Dictionary(#CanSurrenderToOS->nil #DebugShowDamage->false #Des[..]
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Morphic-Core-Worlds'



--- The full stack ---
RSBox(Object)>>doesNotUnderstand: #label:
VisualizerMain>>createSampleGraph
UndefinedObject>>DoIt
OCReceiverDoItSemanticScope(OCDoItSemanticScope)>>evaluateDoIt:
OpalCompiler>>evaluate
[
		self announcer announce: (SpCodeWillBeEvaluatedAnnouncement newContent: aString).
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionModel doItReceiver.
		result := receiver class compiler
			source: aString;
			context: self interactionModel doItContext;
			receiver: self interactionModel doItReceiver;
			requestor: self interactionModel;
			environment: self environment;
			failBlock:  [ 
				self announcer announce: (SpCodeEvaluationFailedAnnouncement newContent: aString).
				^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		self announcer announce: (SpCodeEvaluationSucceedAnnouncement newContent: aString).
		result ] in SpCodePresenter>>evaluate:onCompileError:onError:
FullBlockClosure(BlockClosure)>>on:do:
SpCodePresenter>>evaluate:onCompileError:onError:
StPlaygroundPagePresenter>>doEvaluateAndGo
StPlaygroundPagePresenter>>doEvaluateAllAndGo
StPlaygroundDoItCommand>>execute
SpCommand(CmCommandDecorator)>>execute
[ specCommand execute ] in [ :specCommand | 
			aButtonClass new
				label: specCommand name;
				help: specCommand description;
				in: [ :button | 
					specCommand hasIcon
						ifTrue: [ button icon: specCommand icon ] ];
				action: [ specCommand execute ];
				yourself ] in SpCommand>>configureAsButtonOfClass:
FullBlockClosure(BlockClosure)>>cull:
SpMorphicToolbarButtonAdapter>>execute
SpToolbarButtonMorph(PluggableButtonMorph)>>performAction:
[:m |
		(m containsPoint: evt cursorPoint) ifTrue: [m enabled ifTrue: [ m performAction: evt ]]] in SpToolbarButtonMorph(PluggableButtonMorph)>>mouseUp:
Array(SequenceableCollection)>>do:
SpToolbarButtonMorph(PluggableButtonMorph)>>mouseUp:
SpToolbarButtonMorph(Morph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
SpToolbarButtonMorph(Morph)>>handleEvent:
SpToolbarButtonMorph(Morph)>>handleFocusEvent:
[
		result := focusHolder handleFocusEvent: transformedEvent.
	] in HandMorph>>sendFocusEvent:to:clear:
FullBlockClosure(BlockClosure)>>on:do:
WorldMorph>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil ]) ifTrue: [
			morphicWorld activeHand handleEvent: anEvent
		]
	] in OSWindowMorphicEventHandler>>dispatchMorphicEvent:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycleNow
WorldMorph>>doOneCycle
[
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMutex critical: [
			                     self extraWorldList ].
		extraWorldsToDraw do: [ :world | world doOneCycle ].

		(self currentWorld isNotNil and: [
			 (extraWorldsToDraw includes: self currentWorld) not ]) ifTrue: [
			self currentWorld doOneCycle ] ] in WorldMorph class>>doOneCycle
FullBlockClosure(BlockClosure)>>ensure:
WorldState class>>doDrawCycleWith:
 - - - - - - - - - - - - - - -
			- - - - - - - - - - - - - - - - - -
WorldMorph class>>doOneCycle
MorphicRenderLoop>>doOneCycle
MorphicRenderLoop>>doOneCycleWhile:
LongMessageDialogWindow(SystemWindow)>>openModal
PharoLightTheme(UITheme)>>longMessageIn:text:title:
MorphicUIManager>>longMessage:title:
ClyShowCritiqueDetailsCommand>>execute
ClyCriticContext>>executeCommand:by:
[self prepareCommandForExecution.
	context executeCommand: command by: self.
	self applyCommandResult] in CmdCommandActivator>>executeCommand
FullBlockClosure(BlockClosure)>>on:do:
CmdCommandActivator>>executeCommand
[target perform: actionSelector withArguments: arguments] in IconicButtonMorph(SimpleButtonMorph)>>doButtonAction
FullBlockClosure(BlockClosure)>>ensure:
CursorWithMask(Cursor)>>showWhile:
IconicButtonMorph(SimpleButtonMorph)>>doButtonAction
IconicButtonMorph(SimpleButtonMorph)>>mouseUp:
IconicButtonMorph(Morph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
IconicButtonMorph(Morph)>>handleEvent:
IconicButtonMorph(Morph)>>handleFocusEvent:
[
		result := focusHolder handleFocusEvent: transformedEvent.
	] in HandMorph>>sendFocusEvent:to:clear:
FullBlockClosure(BlockClosure)>>on:do:
WorldMorph>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil ]) ifTrue: [
			morphicWorld activeHand handleEvent: anEvent
		]
	] in OSWindowMorphicEventHandler>>dispatchMorphicEvent:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycleNow
WorldMorph>>doOneCycle
[
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMutex critical: [
			                     self extraWorldList ].
		extraWorldsToDraw do: [ :world | world doOneCycle ].

		(self currentWorld isNotNil and: [
			 (extraWorldsToDraw includes: self currentWorld) not ]) ifTrue: [
			self currentWorld doOneCycle ] ] in WorldMorph class>>doOneCycle
FullBlockClosure(BlockClosure)>>ensure:
WorldState class>>doDrawCycleWith:
WorldMorph class>>doOneCycle
MorphicRenderLoop>>doOneCycle
MorphicRenderLoop>>doOneCycleWhile:
[ MorphicRenderLoop new doOneCycleWhile: [ true ] ] in MorphicUIManager>>spawnNewProcess
[self value.
			"IMPORTANT: Do not step over next line of code. See method comments for details"
			Processor terminateRealActive] in FullBlockClosure(BlockClosure)>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
Instance of RSBox did not understand #label:
12 November 2023 11:57:42.756114 am

VM: Mac OS - arm64 - 1000 - CoInterpreter VMMaker-tonel.1 uuid: 902dd483-c0c4-0d00-86f2-0f880df24b96 Oct 23 2023
StackToRegisterMappingCogit VMMaker-tonel.1 uuid: 902dd483-c0c4-0d00-86f2-0f880df24b96 Oct 23 2023
v10.0.8 - Commit: b323c5fb - Date: 2023-10-20 16:02:07 -0400

Image: Pharo11.0.0 [Build information: Pharo-11.0.0+build.710.sha.ea28d8552cac85a7ce1e9c34ab1e7bd45f7b9910 (64 Bit)]

RSBox(Object)>>doesNotUnderstand: #label:
	Receiver: a RSBox
	Arguments and temporary variables: 
		aMessage: 	label: 'Alice'
		exception: 	Instance of RSBox did not understand #label:
		resumeValue: 	nil
	Receiver's instance variables: 
		announcer: 	nil
		properties: 	nil
		paint: 	Color blue
		path: 	(-25.0@ -25.0) corner: (25.0@25.0)
		border: 	nil
		parent: 	nil
		isFixed: 	false
		encompassingRectangle: 	nil
		model: 	nil
		baseRectangle: 	(-25.0@ -25.0) corner: (25.0@25.0)
		matrix: 	x: 0.0 y: 0.0 sx: 1.0 sy: 1.0 shx: 0.0 shy: 0.0
		connectedLines: 	nil
		shouldUpdateLines: 	true
		cornerRadius: 	nil


VisualizerMain>>createSampleGraph
	Receiver: a VisualizerMain
	Arguments and temporary variables: 
		view: 	a RSCanvas
		alice: 	nil
		bob: 	nil
	Receiver's instance variables: 
a VisualizerMain

UndefinedObject>>DoIt
	Receiver: nil
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
nil

OCReceiverDoItSemanticScope(OCDoItSemanticScope)>>evaluateDoIt:
	Receiver: an OCReceiverDoItSemanticScope
	Arguments and temporary variables: 
		doItMethod: 	UndefinedObject>>#DoIt
	Receiver's instance variables: 
		outerScope: 	nil
		targetReceiver: 	nil


OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
		doItMethod: 	UndefinedObject>>#DoIt
	Receiver's instance variables: 
		ast: 	DoIt

	^ VisualizerMain new createSampleGraph open
		source: 	a ReadStream
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil


[
		self announcer announce: (SpCodeWillBeEvaluatedAnnouncement newContent: aString).
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionModel doItReceiver.
		result := receiver class compiler
			source: aString;
			context: self interactionModel doItContext;
			receiver: self interactionModel doItReceiver;
			requestor: self interactionModel;
			environment: self environment;
			failBlock:  [ 
				self announcer announce: (SpCodeEvaluationFailedAnnouncement newContent: aString).
				^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		self announcer announce: (SpCodeEvaluationSucceedAnnouncement newContent: aString).
		result ] in SpCodePresenter>>evaluate:onCompileError:onError:
	Receiver: a SpCodePresenter
	Arguments and temporary variables: 
		aString: 	'(VisualizerMain new createSampleGraph) open.
'
		compileErrorBlock: 	[ ^ self ]
		errorBlock: 	[ :e | e pass ]
		receiver: 	nil
		result: 	nil
		oldBindings: 	a Dictionary()
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicCodeAdapter)
		announcer: 	an Announcer
		owner: 	a StPlaygroundPagePresenter
		adapter: 	a SpMorphicCodeAdapter
		needRebuild: 	true
		eventHandler: 	a SpEventHandler
		application: 	nil
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ a KMCategory ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Code' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpAbstractWidgetLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		borderWidth: 	an ObservableValueHolder[ nil ]
		borderColor: 	an ObservableValueHolder[ nil ]
		dragEnabled: 	an ObservableValueHolder[ false ]
		dropEnabled: 	an ObservableValueHolder[ false ]
		color: 	an ObservableValueHolder[ nil ]
		help: 	an ObservableValueHolder[ nil ]
		enabled: 	an ObservableValueHolder[ true ]
		wantsDrop: 	an ObservableValueHolder[ [ :transfer | self dropEnabled ] ]
		acceptDrop: 	an ObservableValueHolder[ [ :transfer | ] ]
		deferredActions: 	nil
		hasUnacceptedEdits: 	an ObservableValueHolder[ false ]
		selection: 	an ObservableValueHolder[ (1 to: 45) ]
		wantsVisualFeedback: 	an ObservableValueHolder[ true ]
		askBeforeDiscardingEdits: 	an ObservableValueHolder[ true ]
		text: 	an ObservableValueHolder[ '(VisualizerMain new createSampleGraph) ope[..]
		actionToPerform: 	an ObservableValueHolder[ [ :txt |  ] ]
		readSelection: 	an ObservableValueHolder[ [ selection ] ]
		placeholder: 	an ObservableValueHolder[ '' ]
		contextMenu: 	an ObservableValueHolder[ [ (self menuActionsFor: text) asMenu[..]
		scrollValue: 	an ObservableValueHolder[ (0@0) ]
		editionContextMenu: 	an ObservableValueHolder[ true ]
		editable: 	an ObservableValueHolder[ true ]
		wrapWord: 	an ObservableValueHolder[ true ]
		undoRedoHistory: 	true
		wrapScrollBars: 	true
		propagateNaturalHeight: 	false
		propagateNaturalWidth: 	false
		scrollBarStyles: 	#()
		syntaxHighlight: 	an ObservableValueHolder[ true ]
		smartCharacters: 	an ObservableValueHolder[ true ]
		lineNumbers: 	an ObservableValueHolder[ true ]
		interactionModel: 	an ObservableValueHolder[ a StPlaygroundInteractionModel ]
		overrideContextMenu: 	true
		submitBlock: 	nil
		resetBlock: 	nil
		environment: 	nil
		systemNavigation: 	nil
		syntaxHighlightTheme: 	an ObservableValueHolder[ nil ]


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
		self announcer announce: (SpCodeWillBeEvaluatedAnnouncement newContent: aString).
[..]
	Arguments and temporary variables: 
		exception: 	Error
		handlerAction: 	[ :e |
		self announcer announce: (SpCodeEvaluationFailedAnn[..]
	Receiver's instance variables: 
		outerContext: 	SpCodePresenter>>evaluate:onCompileError:onError:
		compiledBlock: 	a CompiledBlock: [
		self announcer announce: (SpCodeWillBeE[..]
		numArgs: 	0
		receiver: 	a SpCodePresenter


SpCodePresenter>>evaluate:onCompileError:onError:
	Receiver: a SpCodePresenter
	Arguments and temporary variables: 
		receiver: 	nil
		result: 	nil
		oldBindings: 	a Dictionary()
		aString: 	'(VisualizerMain new createSampleGraph) open.
'
		compileErrorBlock: 	[ ^ self ]
		errorBlock: 	[ :e | e pass ]
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicCodeAdapter)
		announcer: 	an Announcer
		owner: 	a StPlaygroundPagePresenter
		adapter: 	a SpMorphicCodeAdapter
		needRebuild: 	true
		eventHandler: 	a SpEventHandler
		application: 	nil
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ a KMCategory ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Code' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpAbstractWidgetLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		borderWidth: 	an ObservableValueHolder[ nil ]
		borderColor: 	an ObservableValueHolder[ nil ]
		dragEnabled: 	an ObservableValueHolder[ false ]
		dropEnabled: 	an ObservableValueHolder[ false ]
		color: 	an ObservableValueHolder[ nil ]
		help: 	an ObservableValueHolder[ nil ]
		enabled: 	an ObservableValueHolder[ true ]
		wantsDrop: 	an ObservableValueHolder[ [ :transfer | self dropEnabled ] ]
		acceptDrop: 	an ObservableValueHolder[ [ :transfer | ] ]
		deferredActions: 	nil
		hasUnacceptedEdits: 	an ObservableValueHolder[ false ]
		selection: 	an ObservableValueHolder[ (1 to: 45) ]
		wantsVisualFeedback: 	an ObservableValueHolder[ true ]
		askBeforeDiscardingEdits: 	an ObservableValueHolder[ true ]
		text: 	an ObservableValueHolder[ '(VisualizerMain new createSampleGraph) ope[..]
		actionToPerform: 	an ObservableValueHolder[ [ :txt |  ] ]
		readSelection: 	an ObservableValueHolder[ [ selection ] ]
		placeholder: 	an ObservableValueHolder[ '' ]
		contextMenu: 	an ObservableValueHolder[ [ (self menuActionsFor: text) asMenu[..]
		scrollValue: 	an ObservableValueHolder[ (0@0) ]
		editionContextMenu: 	an ObservableValueHolder[ true ]
		editable: 	an ObservableValueHolder[ true ]
		wrapWord: 	an ObservableValueHolder[ true ]
		undoRedoHistory: 	true
		wrapScrollBars: 	true
		propagateNaturalHeight: 	false
		propagateNaturalWidth: 	false
		scrollBarStyles: 	#()
		syntaxHighlight: 	an ObservableValueHolder[ true ]
		smartCharacters: 	an ObservableValueHolder[ true ]
		lineNumbers: 	an ObservableValueHolder[ true ]
		interactionModel: 	an ObservableValueHolder[ a StPlaygroundInteractionModel ]
		overrideContextMenu: 	true
		submitBlock: 	nil
		resetBlock: 	nil
		environment: 	nil
		systemNavigation: 	nil
		syntaxHighlightTheme: 	an ObservableValueHolder[ nil ]


StPlaygroundPagePresenter>>doEvaluateAndGo
	Receiver: a StPlaygroundPagePresenter
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicBoxAdapter)
		announcer: 	an Announcer
		owner: 	a SpMillerColumnPresenter
		adapter: 	a SpMorphicBoxAdapter
		needRebuild: 	true
		eventHandler: 	nil
		application: 	a StPharoApplication
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ nil ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Untitled window' ]
		additionalSubpresentersMap: 	a Dictionary()
		layout: 	an ObservableValueHolder[ a SpBoxLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		text: 	a SpCodePresenter
		toolbar: 	a SpToolbarPresenter
		statusbar: 	a SpPresenter
		lineLabel: 	a SpLabelPresenter
		toggleLineNumberButton: 	a SpToggleButtonPresenter
		page: 	a StPlaygroundPage
		activationBlock: 	[ :selection |
		self changeSelection: selection from: new[..]


StPlaygroundPagePresenter>>doEvaluateAllAndGo
	Receiver: a StPlaygroundPagePresenter
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicBoxAdapter)
		announcer: 	an Announcer
		owner: 	a SpMillerColumnPresenter
		adapter: 	a SpMorphicBoxAdapter
		needRebuild: 	true
		eventHandler: 	nil
		application: 	a StPharoApplication
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ nil ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Untitled window' ]
		additionalSubpresentersMap: 	a Dictionary()
		layout: 	an ObservableValueHolder[ a SpBoxLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		text: 	a SpCodePresenter
		toolbar: 	a SpToolbarPresenter
		statusbar: 	a SpPresenter
		lineLabel: 	a SpLabelPresenter
		toggleLineNumberButton: 	a SpToggleButtonPresenter
		page: 	a StPlaygroundPage
		activationBlock: 	[ :selection |
		self changeSelection: selection from: new[..]


StPlaygroundDoItCommand>>execute
	Receiver: a StPlaygroundDoItCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		context: 	a StPlaygroundPagePresenter
		basicName: 	'Do it'
		basicDescription: 	'Do it all and inspect.'


SpCommand(CmCommandDecorator)>>execute
	Receiver: a SpCommand(Do it)
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a StPlaygroundDoItCommand
		iconProvider: 	a StPharoApplication
		iconName: 	#glamorousGo
		shortcutKey: 	nil
		displayStrategy: 	a CmUIDisableWhenCantBeRun
		positionStrategy: 	a CmUILeftPositionStrategy
		buildPresenterBlock: 	[ :specCommand | 
			aButtonClass new
				label: specC[..]
		presenter: 	a SpToolbarButtonPresenter


[ specCommand execute ] in [ :specCommand | 
			aButtonClass new
				label: specCommand name;
				help: specCommand description;
				in: [ :button | 
					specCommand hasIcon
						ifTrue: [ button icon: specCommand icon ] ];
				action: [ specCommand execute ];
				yourself ] in SpCommand>>configureAsButtonOfClass:
	Receiver: a SpCommand(Do it)
	Arguments and temporary variables: 
		aButtonClass: 	nil
		specCommand: 	a SpCommand(Do it)
	Receiver's instance variables: 
		decoratedCommand: 	a StPlaygroundDoItCommand
		iconProvider: 	a StPharoApplication
		iconName: 	#glamorousGo
		shortcutKey: 	nil
		displayStrategy: 	a CmUIDisableWhenCantBeRun
		positionStrategy: 	a CmUILeftPositionStrategy
		buildPresenterBlock: 	[ :specCommand | 
			aButtonClass new
				label: specC[..]
		presenter: 	a SpToolbarButtonPresenter


FullBlockClosure(BlockClosure)>>cull:
	Receiver: [ specCommand execute ]
	Arguments and temporary variables: 
		anArg: 	a SpToolbarButtonPresenter
	Receiver's instance variables: 
		outerContext: 	[ :specCommand | 
			aButtonClass new
				label: specCommand [..]
		compiledBlock: 	a CompiledBlock: [ specCommand execute ]
		numArgs: 	0
		receiver: 	a SpCommand(Do it)


SpMorphicToolbarButtonAdapter>>execute
	Receiver: a SpMorphicToolbarButtonAdapter
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpToolbarButtonMorph(888790016))
		announcer: 	nil
		model: 	a SpToolbarButtonPresenter
		widget: 	a SpToolbarButtonMorph(888790016)
		selector: 	nil
		owner: 	a SpToolbarButtonPresenter
		unsubscribed: 	false


SpToolbarButtonMorph(PluggableButtonMorph)>>performAction:
	Receiver: a SpToolbarButtonMorph(888790016)
	Arguments and temporary variables: 
		event: 	[(23.0@21.0) mouseUp 44405 nil]
	Receiver's instance variables: 
		bounds: 	(0.0@5.0) corner: (45.0@39.0)
		owner: 	a Morph(1073167616)
		submorphs: 	an Array(an AlignmentMorph(116792320))
		fullBounds: 	nil
		color: 	(Color r: 0.9012707722385142 g: 0.9012707722385142 b: 0.901270772238[..]
		extension: 	a MorphExtension (509491200) [balloonText]  [other:  (presenter [..]
		borderWidth: 	0
		borderColor: 	#simple
		model: 	a SpMorphicToolbarButtonAdapter
		label: 	'Do it'
		icon: 	Form(13x13x32)
		getIconSelector: 	#icon
		getStateSelector: 	#state
		actionSelector: 	#execute
		font: 	a LogicalFont
 familyName: 'Source Sans Pro'
 emphasis: nil
 pointSiz[..]
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	nil
		getFontSelector: 	nil
		labelMorph: 	a LabelMorph(128736768)'Do it'
		iconMorph: 	an ImageMorph(1001562624)
		iconPosition: 	#top
		lastState: 	false
		badgeFont: 	nil
		badgeSelector: 	#badge


[:m |
		(m containsPoint: evt cursorPoint) ifTrue: [m enabled ifTrue: [ m performAction: evt ]]] in SpToolbarButtonMorph(PluggableButtonMorph)>>mouseUp:
	Receiver: a SpToolbarButtonMorph(888790016)
	Arguments and temporary variables: 
		evt: 	[(23.0@21.0) mouseUp 44405 nil]
		all: 	an Array(a SpToolbarButtonMorph(888790016) a SpToolbarButtonMorph(2143[..]
		m: 	a SpToolbarButtonMorph(888790016)
	Receiver's instance variables: 
		bounds: 	(0.0@5.0) corner: (45.0@39.0)
		owner: 	a Morph(1073167616)
		submorphs: 	an Array(an AlignmentMorph(116792320))
		fullBounds: 	nil
		color: 	(Color r: 0.9012707722385142 g: 0.9012707722385142 b: 0.901270772238[..]
		extension: 	a MorphExtension (509491200) [balloonText]  [other:  (presenter [..]
		borderWidth: 	0
		borderColor: 	#simple
		model: 	a SpMorphicToolbarButtonAdapter
		label: 	'Do it'
		icon: 	Form(13x13x32)
		getIconSelector: 	#icon
		getStateSelector: 	#state
		actionSelector: 	#execute
		font: 	a LogicalFont
 familyName: 'Source Sans Pro'
 emphasis: nil
 pointSiz[..]
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	nil
		getFontSelector: 	nil
		labelMorph: 	a LabelMorph(128736768)'Do it'
		iconMorph: 	an ImageMorph(1001562624)
		iconPosition: 	#top
		lastState: 	false
		badgeFont: 	nil
		badgeSelector: 	#badge


Array(SequenceableCollection)>>do:
	Receiver: an Array(a SpToolbarButtonMorph(888790016) a SpToolbarButtonMorph(214329088) a SpToolb[..]
	Arguments and temporary variables: 
		aBlock: 	[:m |
		(m containsPoint: evt cursorPoint) ifTrue: [m enabled ifTru[..]
		index: 	1
	Receiver's instance variables: 
an Array(a SpToolbarButtonMorph(888790016) a SpToolbarButtonMorph(214329088) a SpToolb[..]

SpToolbarButtonMorph(PluggableButtonMorph)>>mouseUp:
	Receiver: a SpToolbarButtonMorph(888790016)
	Arguments and temporary variables: 
		evt: 	[(23.0@21.0) mouseUp 44405 nil]
		all: 	an Array(a SpToolbarButtonMorph(888790016) a SpToolbarButtonMorph(2143[..]
	Receiver's instance variables: 
		bounds: 	(0.0@5.0) corner: (45.0@39.0)
		owner: 	a Morph(1073167616)
		submorphs: 	an Array(an AlignmentMorph(116792320))
		fullBounds: 	nil
		color: 	(Color r: 0.9012707722385142 g: 0.9012707722385142 b: 0.901270772238[..]
		extension: 	a MorphExtension (509491200) [balloonText]  [other:  (presenter [..]
		borderWidth: 	0
		borderColor: 	#simple
		model: 	a SpMorphicToolbarButtonAdapter
		label: 	'Do it'
		icon: 	Form(13x13x32)
		getIconSelector: 	#icon
		getStateSelector: 	#state
		actionSelector: 	#execute
		font: 	a LogicalFont
 familyName: 'Source Sans Pro'
 emphasis: nil
 pointSiz[..]
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	nil
		getFontSelector: 	nil
		labelMorph: 	a LabelMorph(128736768)'Do it'
		iconMorph: 	an ImageMorph(1001562624)
		iconPosition: 	#top
		lastState: 	false
		badgeFont: 	nil
		badgeSelector: 	#badge


SpToolbarButtonMorph(Morph)>>handleMouseUp:
	Receiver: a SpToolbarButtonMorph(888790016)
	Arguments and temporary variables: 
		anEvent: 	[(23.0@21.0) mouseUp 44405 nil]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(0.0@5.0) corner: (45.0@39.0)
		owner: 	a Morph(1073167616)
		submorphs: 	an Array(an AlignmentMorph(116792320))
		fullBounds: 	nil
		color: 	(Color r: 0.9012707722385142 g: 0.9012707722385142 b: 0.901270772238[..]
		extension: 	a MorphExtension (509491200) [balloonText]  [other:  (presenter [..]
		borderWidth: 	0
		borderColor: 	#simple
		model: 	a SpMorphicToolbarButtonAdapter
		label: 	'Do it'
		icon: 	Form(13x13x32)
		getIconSelector: 	#icon
		getStateSelector: 	#state
		actionSelector: 	#execute
		font: 	a LogicalFont
 familyName: 'Source Sans Pro'
 emphasis: nil
 pointSiz[..]
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	nil
		getFontSelector: 	nil
		labelMorph: 	a LabelMorph(128736768)'Do it'
		iconMorph: 	an ImageMorph(1001562624)
		iconPosition: 	#top
		lastState: 	false
		badgeFont: 	nil
		badgeSelector: 	#badge


MouseButtonEvent>>sentTo:
	Receiver: [(23.0@21.0) mouseUp 44405 nil]
	Arguments and temporary variables: 
		anObject: 	a SpToolbarButtonMorph(888790016)
	Receiver's instance variables: 
		timeStamp: 	44405
		source: 	a HandMorph(337424384)
		windowIndex: 	nil
		type: 	#mouseUp
		buttons: 	0
		position: 	(23.0@21.0)
		handler: 	nil
		wasHandled: 	true
		whichButton: 	4


SpToolbarButtonMorph(Morph)>>handleEvent:
	Receiver: a SpToolbarButtonMorph(888790016)
	Arguments and temporary variables: 
		anEvent: 	[(23.0@21.0) mouseUp 44405 nil]
	Receiver's instance variables: 
		bounds: 	(0.0@5.0) corner: (45.0@39.0)
		owner: 	a Morph(1073167616)
		submorphs: 	an Array(an AlignmentMorph(116792320))
		fullBounds: 	nil
		color: 	(Color r: 0.9012707722385142 g: 0.9012707722385142 b: 0.901270772238[..]
		extension: 	a MorphExtension (509491200) [balloonText]  [other:  (presenter [..]
		borderWidth: 	0
		borderColor: 	#simple
		model: 	a SpMorphicToolbarButtonAdapter
		label: 	'Do it'
		icon: 	Form(13x13x32)
		getIconSelector: 	#icon
		getStateSelector: 	#state
		actionSelector: 	#execute
		font: 	a LogicalFont
 familyName: 'Source Sans Pro'
 emphasis: nil
 pointSiz[..]
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	nil
		getFontSelector: 	nil
		labelMorph: 	a LabelMorph(128736768)'Do it'
		iconMorph: 	an ImageMorph(1001562624)
		iconPosition: 	#top
		lastState: 	false
		badgeFont: 	nil
		badgeSelector: 	#badge


SpToolbarButtonMorph(Morph)>>handleFocusEvent:
	Receiver: a SpToolbarButtonMorph(888790016)
	Arguments and temporary variables: 
		anEvent: 	[(23.0@21.0) mouseUp 44405 nil]
	Receiver's instance variables: 
		bounds: 	(0.0@5.0) corner: (45.0@39.0)
		owner: 	a Morph(1073167616)
		submorphs: 	an Array(an AlignmentMorph(116792320))
		fullBounds: 	nil
		color: 	(Color r: 0.9012707722385142 g: 0.9012707722385142 b: 0.901270772238[..]
		extension: 	a MorphExtension (509491200) [balloonText]  [other:  (presenter [..]
		borderWidth: 	0
		borderColor: 	#simple
		model: 	a SpMorphicToolbarButtonAdapter
		label: 	'Do it'
		icon: 	Form(13x13x32)
		getIconSelector: 	#icon
		getStateSelector: 	#state
		actionSelector: 	#execute
		font: 	a LogicalFont
 familyName: 'Source Sans Pro'
 emphasis: nil
 pointSiz[..]
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	nil
		getFontSelector: 	nil
		labelMorph: 	a LabelMorph(128736768)'Do it'
		iconMorph: 	an ImageMorph(1001562624)
		iconPosition: 	#top
		lastState: 	false
		badgeFont: 	nil
		badgeSelector: 	#badge


[
		result := focusHolder handleFocusEvent: transformedEvent.
	] in HandMorph>>sendFocusEvent:to:clear:
	Receiver: a HandMorph(337424384)
	Arguments and temporary variables: 
		anEvent: 	[(587@126) mouseUp 44405 nil]
		focusHolder: 	a SpToolbarButtonMorph(888790016)
		aBlock: 	[self mouseFocus: nil]
		w: 	a WorldMorph(341720576) [world]
		transformedEvent: 	[(23.0@21.0) mouseUp 44405 nil]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(587@126.0) corner: (603@142.0)
		owner: 	a WorldMorph(341720576) [world]
		submorphs: 	#()
		fullBounds: 	(587@126.0) corner: (603@142.0)
		color: 	Color blue
		extension: 	a MorphExtension (370611968)
		mouseFocus: 	nil
		keyboardFocus: 	a RubEditingArea(919167488)
		eventListeners: 	nil
		mouseListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(587@126) mouseUp 44405 nil]
		targetOffset: 	(23.0@16.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 0 0 0 0 0 nil nil)
		captureBlock: 	nil
		recentModifiers: 	0
		pendingEventQueue: 	WaitfreeQueue with 0 items
		supressNextKeyPress: 	false


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
		result := focusHolder handleFocusEvent: transformedEvent.
	]
	Arguments and temporary variables: 
		exception: 	Error
		handlerAction: 	[ :ex |
			ActiveWorld := priorWorld.
			ex pass ]
	Receiver's instance variables: 
		outerContext: 	HandMorph>>sendFocusEvent:to:clear:
		compiledBlock: 	a CompiledBlock: [
		result := focusHolder handleFocusEvent:[..]
		numArgs: 	0
		receiver: 	a HandMorph(337424384)


WorldMorph>>becomeActiveDuring:
	Receiver: a WorldMorph(341720576) [world]
	Arguments and temporary variables: 
		aBlock: 	[
		result := focusHolder handleFocusEvent: transformedEvent.
	]
		priorWorld: 	a WorldMorph(341720576) [world]
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1728@1051)
		owner: 	nil
		submorphs: 	an Array(a MenubarMorph(112886016) a TaskbarMorph(279458560) a S[..]
		fullBounds: 	(0@0) corner: (1728@1051)
		color: 	(Color r: 0.9403714565004888 g: 0.9403714565004888 b: 0.940371456500[..]
		extension: 	a MorphExtension (1012946432) [other:  (dragEnabled -> true) (dr[..]
		borderWidth: 	0
		borderColor: 	(Color r: 0.8611925708699902 g: 1.0 b: 0.7223851417399805 alph[..]
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil


HandMorph>>sendFocusEvent:to:clear:
	Receiver: a HandMorph(337424384)
	Arguments and temporary variables: 
		result: 	nil
		anEvent: 	[(587@126) mouseUp 44405 nil]
		focusHolder: 	a SpToolbarButtonMorph(888790016)
		aBlock: 	[self mouseFocus: nil]
		w: 	a WorldMorph(341720576) [world]
		transformedEvent: 	[(23.0@21.0) mouseUp 44405 nil]
	Receiver's instance variables: 
		bounds: 	(587@126.0) corner: (603@142.0)
		owner: 	a WorldMorph(341720576) [world]
		submorphs: 	#()
		fullBounds: 	(587@126.0) corner: (603@142.0)
		color: 	Color blue
		extension: 	a MorphExtension (370611968)
		mouseFocus: 	nil
		keyboardFocus: 	a RubEditingArea(919167488)
		eventListeners: 	nil
		mouseListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(587@126) mouseUp 44405 nil]
		targetOffset: 	(23.0@16.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 0 0 0 0 0 nil nil)
		captureBlock: 	nil
		recentModifiers: 	0
		pendingEventQueue: 	WaitfreeQueue with 0 items
		supressNextKeyPress: 	false


HandMorph>>sendEvent:focus:clear:
	Receiver: a HandMorph(337424384)
	Arguments and temporary variables: 
		anEvent: 	[(587@126) mouseUp 44405 nil]
		focusHolder: 	a SpToolbarButtonMorph(888790016)
		aBlock: 	[self mouseFocus: nil]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(587@126.0) corner: (603@142.0)
		owner: 	a WorldMorph(341720576) [world]
		submorphs: 	#()
		fullBounds: 	(587@126.0) corner: (603@142.0)
		color: 	Color blue
		extension: 	a MorphExtension (370611968)
		mouseFocus: 	nil
		keyboardFocus: 	a RubEditingArea(919167488)
		eventListeners: 	nil
		mouseListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(587@126) mouseUp 44405 nil]
		targetOffset: 	(23.0@16.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 0 0 0 0 0 nil nil)
		captureBlock: 	nil
		recentModifiers: 	0
		pendingEventQueue: 	WaitfreeQueue with 0 items
		supressNextKeyPress: 	false


HandMorph>>sendMouseEvent:
	Receiver: a HandMorph(337424384)
	Arguments and temporary variables: 
		anEvent: 	[(587@126) mouseUp 44405 nil]
	Receiver's instance variables: 
		bounds: 	(587@126.0) corner: (603@142.0)
		owner: 	a WorldMorph(341720576) [world]
		submorphs: 	#()
		fullBounds: 	(587@126.0) corner: (603@142.0)
		color: 	Color blue
		extension: 	a MorphExtension (370611968)
		mouseFocus: 	nil
		keyboardFocus: 	a RubEditingArea(919167488)
		eventListeners: 	nil
		mouseListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(587@126) mouseUp 44405 nil]
		targetOffset: 	(23.0@16.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 0 0 0 0 0 nil nil)
		captureBlock: 	nil
		recentModifiers: 	0
		pendingEventQueue: 	WaitfreeQueue with 0 items
		supressNextKeyPress: 	false


HandMorph>>handleEvent:
	Receiver: a HandMorph(337424384)
	Arguments and temporary variables: 
		anEvent: 	[(587@126) mouseUp 44405 nil]
		evt: 	[(587@126) mouseUp 44405 nil]
	Receiver's instance variables: 
		bounds: 	(587@126.0) corner: (603@142.0)
		owner: 	a WorldMorph(341720576) [world]
		submorphs: 	#()
		fullBounds: 	(587@126.0) corner: (603@142.0)
		color: 	Color blue
		extension: 	a MorphExtension (370611968)
		mouseFocus: 	nil
		keyboardFocus: 	a RubEditingArea(919167488)
		eventListeners: 	nil
		mouseListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(587@126) mouseUp 44405 nil]
		targetOffset: 	(23.0@16.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 0 0 0 0 0 nil nil)
		captureBlock: 	nil
		recentModifiers: 	0
		pendingEventQueue: 	WaitfreeQueue with 0 items
		supressNextKeyPress: 	false


[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil ]) ifTrue: [
			morphicWorld activeHand handleEvent: anEvent
		]
	] in OSWindowMorphicEventHandler>>dispatchMorphicEvent:
	Receiver: an OSWindowMorphicEventHandler
	Arguments and temporary variables: 
		anEvent: 	[(587@126) mouseUp 44405 nil]
	Receiver's instance variables: 
		morphicWorld: 	a WorldMorph(341720576) [world]


WorldState>>runStepMethodsIn:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(341720576) [world]
		queue: 	WaitfreeQueue with 0 items
		nextInQueue: 	[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNo[..]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(337424384))
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap()
		lastStepTime: 	43477
		lastStepMessage: 	nil
		alarms: 	a Heap(MorphicAlarm(#hideShow -> a RubCursor(899173120)))
		lastAlarmTime: 	44392
		activeHand: 	a HandMorph(337424384)
		currentCursor: 	((CursorWithMask
	extent: (16@16)
	depth: 1
	fromArray: #(
	[..]
		worldRenderer: 	an OSWorldRenderer
		realWindowExtent: 	(1728@1051)
		deferredUIMessages: 	WaitfreeQueue with 0 items


WorldMorph>>runStepMethods
	Receiver: a WorldMorph(341720576) [world]
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1728@1051)
		owner: 	nil
		submorphs: 	an Array(a MenubarMorph(112886016) a TaskbarMorph(279458560) a S[..]
		fullBounds: 	(0@0) corner: (1728@1051)
		color: 	(Color r: 0.9403714565004888 g: 0.9403714565004888 b: 0.940371456500[..]
		extension: 	a MorphExtension (1012946432) [other:  (dragEnabled -> true) (dr[..]
		borderWidth: 	0
		borderColor: 	(Color r: 0.8611925708699902 g: 1.0 b: 0.7223851417399805 alph[..]
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil


WorldState>>doOneCycleFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(341720576) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(337424384))
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap()
		lastStepTime: 	43477
		lastStepMessage: 	nil
		alarms: 	a Heap(MorphicAlarm(#hideShow -> a RubCursor(899173120)))
		lastAlarmTime: 	44392
		activeHand: 	a HandMorph(337424384)
		currentCursor: 	((CursorWithMask
	extent: (16@16)
	depth: 1
	fromArray: #(
	[..]
		worldRenderer: 	an OSWorldRenderer
		realWindowExtent: 	(1728@1051)
		deferredUIMessages: 	WaitfreeQueue with 0 items


WorldMorph>>doOneCycleNow
	Receiver: a WorldMorph(341720576) [world]
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1728@1051)
		owner: 	nil
		submorphs: 	an Array(a MenubarMorph(112886016) a TaskbarMorph(279458560) a S[..]
		fullBounds: 	(0@0) corner: (1728@1051)
		color: 	(Color r: 0.9403714565004888 g: 0.9403714565004888 b: 0.940371456500[..]
		extension: 	a MorphExtension (1012946432) [other:  (dragEnabled -> true) (dr[..]
		borderWidth: 	0
		borderColor: 	(Color r: 0.8611925708699902 g: 1.0 b: 0.7223851417399805 alph[..]
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil


WorldMorph>>doOneCycle
	Receiver: a WorldMorph(341720576) [world]
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1728@1051)
		owner: 	nil
		submorphs: 	an Array(a MenubarMorph(112886016) a TaskbarMorph(279458560) a S[..]
		fullBounds: 	(0@0) corner: (1728@1051)
		color: 	(Color r: 0.9403714565004888 g: 0.9403714565004888 b: 0.940371456500[..]
		extension: 	a MorphExtension (1012946432) [other:  (dragEnabled -> true) (dr[..]
		borderWidth: 	0
		borderColor: 	(Color r: 0.8611925708699902 g: 1.0 b: 0.7223851417399805 alph[..]
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil


[
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMutex critical: [
			                     self extraWorldList ].
		extraWorldsToDraw do: [ :world | world doOneCycle ].

		(self currentWorld isNotNil and: [
			 (extraWorldsToDraw includes: self currentWorld) not ]) ifTrue: [
			self currentWorld doOneCycle ] ] in WorldMorph class>>doOneCycle
	Receiver: WorldMorph
	Arguments and temporary variables: 
		extraWorldsToDraw: 	#()
	Receiver's instance variables: 
		superclass: 	PasteUpMorph
		methodDict: 	a MethodDictionary(#acceptDroppingMorph:event:->WorldMorph>>#ac[..]
		format: 	65547
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		commentSourcePointer: 	nil
		subclasses: 	{AthensWorldMorph. OSWindowWorldMorph}
		name: 	#WorldMorph
		classPool: 	a Dictionary(#AllowDropFiles->nil #CursorOwnerWorld->a WorldMorp[..]
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Morphic-Core-Worlds'
		announcer: 	nil
		displayScaleFactor: 	1


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMutex critical: [
			  [..]
	Arguments and temporary variables: 
		aBlock: 	[
		self doInterCycleWait
	]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	WorldMorph class>>doOneCycle
		compiledBlock: 	a CompiledBlock: [
		| extraWorldsToDraw |
		extraWorldsToDr[..]
		numArgs: 	0
		receiver: 	WorldMorph


WorldState class>>doDrawCycleWith:
	Receiver: WorldState
	Arguments and temporary variables: 
		aBlock: 	[
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMute[..]
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary(#activeHand->WorldState>>#activeHand #active[..]
		format: 	65548
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		commentSourcePointer: 	nil
		subclasses: 	{AthensWorldState}
		name: 	#WorldState
		classPool: 	a Dictionary(#CanSurrenderToOS->nil #DebugShowDamage->false #Des[..]
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Morphic-Core-Worlds'



--- The full stack ---
RSBox(Object)>>doesNotUnderstand: #label:
VisualizerMain>>createSampleGraph
UndefinedObject>>DoIt
OCReceiverDoItSemanticScope(OCDoItSemanticScope)>>evaluateDoIt:
OpalCompiler>>evaluate
[
		self announcer announce: (SpCodeWillBeEvaluatedAnnouncement newContent: aString).
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionModel doItReceiver.
		result := receiver class compiler
			source: aString;
			context: self interactionModel doItContext;
			receiver: self interactionModel doItReceiver;
			requestor: self interactionModel;
			environment: self environment;
			failBlock:  [ 
				self announcer announce: (SpCodeEvaluationFailedAnnouncement newContent: aString).
				^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		self announcer announce: (SpCodeEvaluationSucceedAnnouncement newContent: aString).
		result ] in SpCodePresenter>>evaluate:onCompileError:onError:
FullBlockClosure(BlockClosure)>>on:do:
SpCodePresenter>>evaluate:onCompileError:onError:
StPlaygroundPagePresenter>>doEvaluateAndGo
StPlaygroundPagePresenter>>doEvaluateAllAndGo
StPlaygroundDoItCommand>>execute
SpCommand(CmCommandDecorator)>>execute
[ specCommand execute ] in [ :specCommand | 
			aButtonClass new
				label: specCommand name;
				help: specCommand description;
				in: [ :button | 
					specCommand hasIcon
						ifTrue: [ button icon: specCommand icon ] ];
				action: [ specCommand execute ];
				yourself ] in SpCommand>>configureAsButtonOfClass:
FullBlockClosure(BlockClosure)>>cull:
SpMorphicToolbarButtonAdapter>>execute
SpToolbarButtonMorph(PluggableButtonMorph)>>performAction:
[:m |
		(m containsPoint: evt cursorPoint) ifTrue: [m enabled ifTrue: [ m performAction: evt ]]] in SpToolbarButtonMorph(PluggableButtonMorph)>>mouseUp:
Array(SequenceableCollection)>>do:
SpToolbarButtonMorph(PluggableButtonMorph)>>mouseUp:
SpToolbarButtonMorph(Morph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
SpToolbarButtonMorph(Morph)>>handleEvent:
SpToolbarButtonMorph(Morph)>>handleFocusEvent:
[
		result := focusHolder handleFocusEvent: transformedEvent.
	] in HandMorph>>sendFocusEvent:to:clear:
FullBlockClosure(BlockClosure)>>on:do:
WorldMorph>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil ]) ifTrue: [
			morphicWorld activeHand handleEvent: anEvent
		]
	] in OSWindowMorphicEventHandler>>dispatchMorphicEvent:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycleNow
WorldMorph>>doOneCycle
[
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMutex critical: [
			                     self extraWorldList ].
		extraWorldsToDraw do: [ :world | world doOneCycle ].

		(self currentWorld isNotNil and: [
			 (extraWorldsToDraw includes: self currentWorld) not ]) ifTrue: [
			self currentWorld doOneCycle ] ] in WorldMorph class>>doOneCycle
FullBlockClosure(BlockClosure)>>ensure:
WorldState class>>doDrawCycleWith:
 - - - - - - - - - - - - - - -
			- - - - - - - - - - - - - - - - - -
WorldMorph class>>doOneCycle
MorphicRenderLoop>>doOneCycle
MorphicRenderLoop>>doOneCycleWhile:
[ MorphicRenderLoop new doOneCycleWhile: [ true ] ] in MorphicUIManager>>spawnNewProcess
[self value.
			"IMPORTANT: Do not step over next line of code. See method comments for details"
			Processor terminateRealActive] in FullBlockClosure(BlockClosure)>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
Instance of RSBox did not understand #label:
12 November 2023 11:57:42.798015 am

VM: Mac OS - arm64 - 1000 - CoInterpreter VMMaker-tonel.1 uuid: 902dd483-c0c4-0d00-86f2-0f880df24b96 Oct 23 2023
StackToRegisterMappingCogit VMMaker-tonel.1 uuid: 902dd483-c0c4-0d00-86f2-0f880df24b96 Oct 23 2023
v10.0.8 - Commit: b323c5fb - Date: 2023-10-20 16:02:07 -0400

Image: Pharo11.0.0 [Build information: Pharo-11.0.0+build.710.sha.ea28d8552cac85a7ce1e9c34ab1e7bd45f7b9910 (64 Bit)]

RSBox(Object)>>doesNotUnderstand: #label:
	Receiver: a RSBox
	Arguments and temporary variables: 
		aMessage: 	label: 'Alice'
		exception: 	Instance of RSBox did not understand #label:
		resumeValue: 	nil
	Receiver's instance variables: 
		announcer: 	nil
		properties: 	nil
		paint: 	Color blue
		path: 	(-25.0@ -25.0) corner: (25.0@25.0)
		border: 	nil
		parent: 	nil
		isFixed: 	false
		encompassingRectangle: 	nil
		model: 	nil
		baseRectangle: 	(-25.0@ -25.0) corner: (25.0@25.0)
		matrix: 	x: 0.0 y: 0.0 sx: 1.0 sy: 1.0 shx: 0.0 shy: 0.0
		connectedLines: 	nil
		shouldUpdateLines: 	true
		cornerRadius: 	nil


VisualizerMain>>createSampleGraph
	Receiver: a VisualizerMain
	Arguments and temporary variables: 
		view: 	a RSCanvas
		alice: 	nil
		bob: 	nil
	Receiver's instance variables: 
a VisualizerMain

UndefinedObject>>DoIt
	Receiver: nil
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
nil

OCReceiverDoItSemanticScope(OCDoItSemanticScope)>>evaluateDoIt:
	Receiver: an OCReceiverDoItSemanticScope
	Arguments and temporary variables: 
		doItMethod: 	UndefinedObject>>#DoIt
	Receiver's instance variables: 
		outerScope: 	nil
		targetReceiver: 	nil


OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
		doItMethod: 	UndefinedObject>>#DoIt
	Receiver's instance variables: 
		ast: 	DoIt

	^ VisualizerMain new createSampleGraph open
		source: 	a ReadStream
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil


[
		self announcer announce: (SpCodeWillBeEvaluatedAnnouncement newContent: aString).
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionModel doItReceiver.
		result := receiver class compiler
			source: aString;
			context: self interactionModel doItContext;
			receiver: self interactionModel doItReceiver;
			requestor: self interactionModel;
			environment: self environment;
			failBlock:  [ 
				self announcer announce: (SpCodeEvaluationFailedAnnouncement newContent: aString).
				^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		self announcer announce: (SpCodeEvaluationSucceedAnnouncement newContent: aString).
		result ] in SpCodePresenter>>evaluate:onCompileError:onError:
	Receiver: a SpCodePresenter
	Arguments and temporary variables: 
		aString: 	'(VisualizerMain new createSampleGraph) open.
'
		compileErrorBlock: 	[ ^ self ]
		errorBlock: 	[ :e | e pass ]
		receiver: 	nil
		result: 	nil
		oldBindings: 	a Dictionary()
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicCodeAdapter)
		announcer: 	an Announcer
		owner: 	a StPlaygroundPagePresenter
		adapter: 	a SpMorphicCodeAdapter
		needRebuild: 	true
		eventHandler: 	a SpEventHandler
		application: 	nil
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ a KMCategory ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Code' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpAbstractWidgetLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		borderWidth: 	an ObservableValueHolder[ nil ]
		borderColor: 	an ObservableValueHolder[ nil ]
		dragEnabled: 	an ObservableValueHolder[ false ]
		dropEnabled: 	an ObservableValueHolder[ false ]
		color: 	an ObservableValueHolder[ nil ]
		help: 	an ObservableValueHolder[ nil ]
		enabled: 	an ObservableValueHolder[ true ]
		wantsDrop: 	an ObservableValueHolder[ [ :transfer | self dropEnabled ] ]
		acceptDrop: 	an ObservableValueHolder[ [ :transfer | ] ]
		deferredActions: 	nil
		hasUnacceptedEdits: 	an ObservableValueHolder[ false ]
		selection: 	an ObservableValueHolder[ (1 to: 45) ]
		wantsVisualFeedback: 	an ObservableValueHolder[ true ]
		askBeforeDiscardingEdits: 	an ObservableValueHolder[ true ]
		text: 	an ObservableValueHolder[ '(VisualizerMain new createSampleGraph) ope[..]
		actionToPerform: 	an ObservableValueHolder[ [ :txt |  ] ]
		readSelection: 	an ObservableValueHolder[ [ selection ] ]
		placeholder: 	an ObservableValueHolder[ '' ]
		contextMenu: 	an ObservableValueHolder[ [ (self menuActionsFor: text) asMenu[..]
		scrollValue: 	an ObservableValueHolder[ (0@0) ]
		editionContextMenu: 	an ObservableValueHolder[ true ]
		editable: 	an ObservableValueHolder[ true ]
		wrapWord: 	an ObservableValueHolder[ true ]
		undoRedoHistory: 	true
		wrapScrollBars: 	true
		propagateNaturalHeight: 	false
		propagateNaturalWidth: 	false
		scrollBarStyles: 	#()
		syntaxHighlight: 	an ObservableValueHolder[ true ]
		smartCharacters: 	an ObservableValueHolder[ true ]
		lineNumbers: 	an ObservableValueHolder[ true ]
		interactionModel: 	an ObservableValueHolder[ a StPlaygroundInteractionModel ]
		overrideContextMenu: 	true
		submitBlock: 	nil
		resetBlock: 	nil
		environment: 	nil
		systemNavigation: 	nil
		syntaxHighlightTheme: 	an ObservableValueHolder[ nil ]


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
		self announcer announce: (SpCodeWillBeEvaluatedAnnouncement newContent: aString).
[..]
	Arguments and temporary variables: 
		exception: 	Error
		handlerAction: 	[ :e |
		self announcer announce: (SpCodeEvaluationFailedAnn[..]
	Receiver's instance variables: 
		outerContext: 	SpCodePresenter>>evaluate:onCompileError:onError:
		compiledBlock: 	a CompiledBlock: [
		self announcer announce: (SpCodeWillBeE[..]
		numArgs: 	0
		receiver: 	a SpCodePresenter


SpCodePresenter>>evaluate:onCompileError:onError:
	Receiver: a SpCodePresenter
	Arguments and temporary variables: 
		receiver: 	nil
		result: 	nil
		oldBindings: 	a Dictionary()
		aString: 	'(VisualizerMain new createSampleGraph) open.
'
		compileErrorBlock: 	[ ^ self ]
		errorBlock: 	[ :e | e pass ]
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicCodeAdapter)
		announcer: 	an Announcer
		owner: 	a StPlaygroundPagePresenter
		adapter: 	a SpMorphicCodeAdapter
		needRebuild: 	true
		eventHandler: 	a SpEventHandler
		application: 	nil
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ a KMCategory ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Code' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpAbstractWidgetLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		borderWidth: 	an ObservableValueHolder[ nil ]
		borderColor: 	an ObservableValueHolder[ nil ]
		dragEnabled: 	an ObservableValueHolder[ false ]
		dropEnabled: 	an ObservableValueHolder[ false ]
		color: 	an ObservableValueHolder[ nil ]
		help: 	an ObservableValueHolder[ nil ]
		enabled: 	an ObservableValueHolder[ true ]
		wantsDrop: 	an ObservableValueHolder[ [ :transfer | self dropEnabled ] ]
		acceptDrop: 	an ObservableValueHolder[ [ :transfer | ] ]
		deferredActions: 	nil
		hasUnacceptedEdits: 	an ObservableValueHolder[ false ]
		selection: 	an ObservableValueHolder[ (1 to: 45) ]
		wantsVisualFeedback: 	an ObservableValueHolder[ true ]
		askBeforeDiscardingEdits: 	an ObservableValueHolder[ true ]
		text: 	an ObservableValueHolder[ '(VisualizerMain new createSampleGraph) ope[..]
		actionToPerform: 	an ObservableValueHolder[ [ :txt |  ] ]
		readSelection: 	an ObservableValueHolder[ [ selection ] ]
		placeholder: 	an ObservableValueHolder[ '' ]
		contextMenu: 	an ObservableValueHolder[ [ (self menuActionsFor: text) asMenu[..]
		scrollValue: 	an ObservableValueHolder[ (0@0) ]
		editionContextMenu: 	an ObservableValueHolder[ true ]
		editable: 	an ObservableValueHolder[ true ]
		wrapWord: 	an ObservableValueHolder[ true ]
		undoRedoHistory: 	true
		wrapScrollBars: 	true
		propagateNaturalHeight: 	false
		propagateNaturalWidth: 	false
		scrollBarStyles: 	#()
		syntaxHighlight: 	an ObservableValueHolder[ true ]
		smartCharacters: 	an ObservableValueHolder[ true ]
		lineNumbers: 	an ObservableValueHolder[ true ]
		interactionModel: 	an ObservableValueHolder[ a StPlaygroundInteractionModel ]
		overrideContextMenu: 	true
		submitBlock: 	nil
		resetBlock: 	nil
		environment: 	nil
		systemNavigation: 	nil
		syntaxHighlightTheme: 	an ObservableValueHolder[ nil ]


StPlaygroundPagePresenter>>doEvaluateAndGo
	Receiver: a StPlaygroundPagePresenter
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicBoxAdapter)
		announcer: 	an Announcer
		owner: 	a SpMillerColumnPresenter
		adapter: 	a SpMorphicBoxAdapter
		needRebuild: 	true
		eventHandler: 	nil
		application: 	a StPharoApplication
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ nil ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Untitled window' ]
		additionalSubpresentersMap: 	a Dictionary()
		layout: 	an ObservableValueHolder[ a SpBoxLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		text: 	a SpCodePresenter
		toolbar: 	a SpToolbarPresenter
		statusbar: 	a SpPresenter
		lineLabel: 	a SpLabelPresenter
		toggleLineNumberButton: 	a SpToggleButtonPresenter
		page: 	a StPlaygroundPage
		activationBlock: 	[ :selection |
		self changeSelection: selection from: new[..]


StPlaygroundPagePresenter>>doEvaluateAllAndGo
	Receiver: a StPlaygroundPagePresenter
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicBoxAdapter)
		announcer: 	an Announcer
		owner: 	a SpMillerColumnPresenter
		adapter: 	a SpMorphicBoxAdapter
		needRebuild: 	true
		eventHandler: 	nil
		application: 	a StPharoApplication
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ nil ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Untitled window' ]
		additionalSubpresentersMap: 	a Dictionary()
		layout: 	an ObservableValueHolder[ a SpBoxLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		text: 	a SpCodePresenter
		toolbar: 	a SpToolbarPresenter
		statusbar: 	a SpPresenter
		lineLabel: 	a SpLabelPresenter
		toggleLineNumberButton: 	a SpToggleButtonPresenter
		page: 	a StPlaygroundPage
		activationBlock: 	[ :selection |
		self changeSelection: selection from: new[..]


StPlaygroundDoItCommand>>execute
	Receiver: a StPlaygroundDoItCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		context: 	a StPlaygroundPagePresenter
		basicName: 	'Do it'
		basicDescription: 	'Do it all and inspect.'


SpCommand(CmCommandDecorator)>>execute
	Receiver: a SpCommand(Do it)
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a StPlaygroundDoItCommand
		iconProvider: 	a StPharoApplication
		iconName: 	#glamorousGo
		shortcutKey: 	nil
		displayStrategy: 	a CmUIDisableWhenCantBeRun
		positionStrategy: 	a CmUILeftPositionStrategy
		buildPresenterBlock: 	[ :specCommand | 
			aButtonClass new
				label: specC[..]
		presenter: 	a SpToolbarButtonPresenter


[ specCommand execute ] in [ :specCommand | 
			aButtonClass new
				label: specCommand name;
				help: specCommand description;
				in: [ :button | 
					specCommand hasIcon
						ifTrue: [ button icon: specCommand icon ] ];
				action: [ specCommand execute ];
				yourself ] in SpCommand>>configureAsButtonOfClass:
	Receiver: a SpCommand(Do it)
	Arguments and temporary variables: 
		aButtonClass: 	nil
		specCommand: 	a SpCommand(Do it)
	Receiver's instance variables: 
		decoratedCommand: 	a StPlaygroundDoItCommand
		iconProvider: 	a StPharoApplication
		iconName: 	#glamorousGo
		shortcutKey: 	nil
		displayStrategy: 	a CmUIDisableWhenCantBeRun
		positionStrategy: 	a CmUILeftPositionStrategy
		buildPresenterBlock: 	[ :specCommand | 
			aButtonClass new
				label: specC[..]
		presenter: 	a SpToolbarButtonPresenter


FullBlockClosure(BlockClosure)>>cull:
	Receiver: [ specCommand execute ]
	Arguments and temporary variables: 
		anArg: 	a SpToolbarButtonPresenter
	Receiver's instance variables: 
		outerContext: 	[ :specCommand | 
			aButtonClass new
				label: specCommand [..]
		compiledBlock: 	a CompiledBlock: [ specCommand execute ]
		numArgs: 	0
		receiver: 	a SpCommand(Do it)


SpMorphicToolbarButtonAdapter>>execute
	Receiver: a SpMorphicToolbarButtonAdapter
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpToolbarButtonMorph(888790016))
		announcer: 	nil
		model: 	a SpToolbarButtonPresenter
		widget: 	a SpToolbarButtonMorph(888790016)
		selector: 	nil
		owner: 	a SpToolbarButtonPresenter
		unsubscribed: 	false


SpToolbarButtonMorph(PluggableButtonMorph)>>performAction:
	Receiver: a SpToolbarButtonMorph(888790016)
	Arguments and temporary variables: 
		event: 	[(23.0@21.0) mouseUp 44405 nil]
	Receiver's instance variables: 
		bounds: 	(0.0@5.0) corner: (45.0@39.0)
		owner: 	a Morph(1073167616)
		submorphs: 	an Array(an AlignmentMorph(116792320))
		fullBounds: 	nil
		color: 	(Color r: 0.9012707722385142 g: 0.9012707722385142 b: 0.901270772238[..]
		extension: 	a MorphExtension (509491200) [balloonText]  [other:  (presenter [..]
		borderWidth: 	0
		borderColor: 	#simple
		model: 	a SpMorphicToolbarButtonAdapter
		label: 	'Do it'
		icon: 	Form(13x13x32)
		getIconSelector: 	#icon
		getStateSelector: 	#state
		actionSelector: 	#execute
		font: 	a LogicalFont
 familyName: 'Source Sans Pro'
 emphasis: nil
 pointSiz[..]
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	nil
		getFontSelector: 	nil
		labelMorph: 	a LabelMorph(128736768)'Do it'
		iconMorph: 	an ImageMorph(1001562624)
		iconPosition: 	#top
		lastState: 	false
		badgeFont: 	nil
		badgeSelector: 	#badge


[:m |
		(m containsPoint: evt cursorPoint) ifTrue: [m enabled ifTrue: [ m performAction: evt ]]] in SpToolbarButtonMorph(PluggableButtonMorph)>>mouseUp:
	Receiver: a SpToolbarButtonMorph(888790016)
	Arguments and temporary variables: 
		evt: 	[(23.0@21.0) mouseUp 44405 nil]
		all: 	an Array(a SpToolbarButtonMorph(888790016) a SpToolbarButtonMorph(2143[..]
		m: 	a SpToolbarButtonMorph(888790016)
	Receiver's instance variables: 
		bounds: 	(0.0@5.0) corner: (45.0@39.0)
		owner: 	a Morph(1073167616)
		submorphs: 	an Array(an AlignmentMorph(116792320))
		fullBounds: 	nil
		color: 	(Color r: 0.9012707722385142 g: 0.9012707722385142 b: 0.901270772238[..]
		extension: 	a MorphExtension (509491200) [balloonText]  [other:  (presenter [..]
		borderWidth: 	0
		borderColor: 	#simple
		model: 	a SpMorphicToolbarButtonAdapter
		label: 	'Do it'
		icon: 	Form(13x13x32)
		getIconSelector: 	#icon
		getStateSelector: 	#state
		actionSelector: 	#execute
		font: 	a LogicalFont
 familyName: 'Source Sans Pro'
 emphasis: nil
 pointSiz[..]
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	nil
		getFontSelector: 	nil
		labelMorph: 	a LabelMorph(128736768)'Do it'
		iconMorph: 	an ImageMorph(1001562624)
		iconPosition: 	#top
		lastState: 	false
		badgeFont: 	nil
		badgeSelector: 	#badge


Array(SequenceableCollection)>>do:
	Receiver: an Array(a SpToolbarButtonMorph(888790016) a SpToolbarButtonMorph(214329088) a SpToolb[..]
	Arguments and temporary variables: 
		aBlock: 	[:m |
		(m containsPoint: evt cursorPoint) ifTrue: [m enabled ifTru[..]
		index: 	1
	Receiver's instance variables: 
an Array(a SpToolbarButtonMorph(888790016) a SpToolbarButtonMorph(214329088) a SpToolb[..]

SpToolbarButtonMorph(PluggableButtonMorph)>>mouseUp:
	Receiver: a SpToolbarButtonMorph(888790016)
	Arguments and temporary variables: 
		evt: 	[(23.0@21.0) mouseUp 44405 nil]
		all: 	an Array(a SpToolbarButtonMorph(888790016) a SpToolbarButtonMorph(2143[..]
	Receiver's instance variables: 
		bounds: 	(0.0@5.0) corner: (45.0@39.0)
		owner: 	a Morph(1073167616)
		submorphs: 	an Array(an AlignmentMorph(116792320))
		fullBounds: 	nil
		color: 	(Color r: 0.9012707722385142 g: 0.9012707722385142 b: 0.901270772238[..]
		extension: 	a MorphExtension (509491200) [balloonText]  [other:  (presenter [..]
		borderWidth: 	0
		borderColor: 	#simple
		model: 	a SpMorphicToolbarButtonAdapter
		label: 	'Do it'
		icon: 	Form(13x13x32)
		getIconSelector: 	#icon
		getStateSelector: 	#state
		actionSelector: 	#execute
		font: 	a LogicalFont
 familyName: 'Source Sans Pro'
 emphasis: nil
 pointSiz[..]
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	nil
		getFontSelector: 	nil
		labelMorph: 	a LabelMorph(128736768)'Do it'
		iconMorph: 	an ImageMorph(1001562624)
		iconPosition: 	#top
		lastState: 	false
		badgeFont: 	nil
		badgeSelector: 	#badge


SpToolbarButtonMorph(Morph)>>handleMouseUp:
	Receiver: a SpToolbarButtonMorph(888790016)
	Arguments and temporary variables: 
		anEvent: 	[(23.0@21.0) mouseUp 44405 nil]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(0.0@5.0) corner: (45.0@39.0)
		owner: 	a Morph(1073167616)
		submorphs: 	an Array(an AlignmentMorph(116792320))
		fullBounds: 	nil
		color: 	(Color r: 0.9012707722385142 g: 0.9012707722385142 b: 0.901270772238[..]
		extension: 	a MorphExtension (509491200) [balloonText]  [other:  (presenter [..]
		borderWidth: 	0
		borderColor: 	#simple
		model: 	a SpMorphicToolbarButtonAdapter
		label: 	'Do it'
		icon: 	Form(13x13x32)
		getIconSelector: 	#icon
		getStateSelector: 	#state
		actionSelector: 	#execute
		font: 	a LogicalFont
 familyName: 'Source Sans Pro'
 emphasis: nil
 pointSiz[..]
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	nil
		getFontSelector: 	nil
		labelMorph: 	a LabelMorph(128736768)'Do it'
		iconMorph: 	an ImageMorph(1001562624)
		iconPosition: 	#top
		lastState: 	false
		badgeFont: 	nil
		badgeSelector: 	#badge


MouseButtonEvent>>sentTo:
	Receiver: [(23.0@21.0) mouseUp 44405 nil]
	Arguments and temporary variables: 
		anObject: 	a SpToolbarButtonMorph(888790016)
	Receiver's instance variables: 
		timeStamp: 	44405
		source: 	a HandMorph(337424384)
		windowIndex: 	nil
		type: 	#mouseUp
		buttons: 	0
		position: 	(23.0@21.0)
		handler: 	nil
		wasHandled: 	true
		whichButton: 	4


SpToolbarButtonMorph(Morph)>>handleEvent:
	Receiver: a SpToolbarButtonMorph(888790016)
	Arguments and temporary variables: 
		anEvent: 	[(23.0@21.0) mouseUp 44405 nil]
	Receiver's instance variables: 
		bounds: 	(0.0@5.0) corner: (45.0@39.0)
		owner: 	a Morph(1073167616)
		submorphs: 	an Array(an AlignmentMorph(116792320))
		fullBounds: 	nil
		color: 	(Color r: 0.9012707722385142 g: 0.9012707722385142 b: 0.901270772238[..]
		extension: 	a MorphExtension (509491200) [balloonText]  [other:  (presenter [..]
		borderWidth: 	0
		borderColor: 	#simple
		model: 	a SpMorphicToolbarButtonAdapter
		label: 	'Do it'
		icon: 	Form(13x13x32)
		getIconSelector: 	#icon
		getStateSelector: 	#state
		actionSelector: 	#execute
		font: 	a LogicalFont
 familyName: 'Source Sans Pro'
 emphasis: nil
 pointSiz[..]
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	nil
		getFontSelector: 	nil
		labelMorph: 	a LabelMorph(128736768)'Do it'
		iconMorph: 	an ImageMorph(1001562624)
		iconPosition: 	#top
		lastState: 	false
		badgeFont: 	nil
		badgeSelector: 	#badge


SpToolbarButtonMorph(Morph)>>handleFocusEvent:
	Receiver: a SpToolbarButtonMorph(888790016)
	Arguments and temporary variables: 
		anEvent: 	[(23.0@21.0) mouseUp 44405 nil]
	Receiver's instance variables: 
		bounds: 	(0.0@5.0) corner: (45.0@39.0)
		owner: 	a Morph(1073167616)
		submorphs: 	an Array(an AlignmentMorph(116792320))
		fullBounds: 	nil
		color: 	(Color r: 0.9012707722385142 g: 0.9012707722385142 b: 0.901270772238[..]
		extension: 	a MorphExtension (509491200) [balloonText]  [other:  (presenter [..]
		borderWidth: 	0
		borderColor: 	#simple
		model: 	a SpMorphicToolbarButtonAdapter
		label: 	'Do it'
		icon: 	Form(13x13x32)
		getIconSelector: 	#icon
		getStateSelector: 	#state
		actionSelector: 	#execute
		font: 	a LogicalFont
 familyName: 'Source Sans Pro'
 emphasis: nil
 pointSiz[..]
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	nil
		getFontSelector: 	nil
		labelMorph: 	a LabelMorph(128736768)'Do it'
		iconMorph: 	an ImageMorph(1001562624)
		iconPosition: 	#top
		lastState: 	false
		badgeFont: 	nil
		badgeSelector: 	#badge


[
		result := focusHolder handleFocusEvent: transformedEvent.
	] in HandMorph>>sendFocusEvent:to:clear:
	Receiver: a HandMorph(337424384)
	Arguments and temporary variables: 
		anEvent: 	[(587@126) mouseUp 44405 nil]
		focusHolder: 	a SpToolbarButtonMorph(888790016)
		aBlock: 	[self mouseFocus: nil]
		w: 	a WorldMorph(341720576) [world]
		transformedEvent: 	[(23.0@21.0) mouseUp 44405 nil]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(587@126.0) corner: (603@142.0)
		owner: 	a WorldMorph(341720576) [world]
		submorphs: 	#()
		fullBounds: 	(587@126.0) corner: (603@142.0)
		color: 	Color blue
		extension: 	a MorphExtension (370611968)
		mouseFocus: 	nil
		keyboardFocus: 	a RubEditingArea(919167488)
		eventListeners: 	nil
		mouseListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(587@126) mouseUp 44405 nil]
		targetOffset: 	(23.0@16.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 0 0 0 0 0 nil nil)
		captureBlock: 	nil
		recentModifiers: 	0
		pendingEventQueue: 	WaitfreeQueue with 0 items
		supressNextKeyPress: 	false


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
		result := focusHolder handleFocusEvent: transformedEvent.
	]
	Arguments and temporary variables: 
		exception: 	Error
		handlerAction: 	[ :ex |
			ActiveWorld := priorWorld.
			ex pass ]
	Receiver's instance variables: 
		outerContext: 	HandMorph>>sendFocusEvent:to:clear:
		compiledBlock: 	a CompiledBlock: [
		result := focusHolder handleFocusEvent:[..]
		numArgs: 	0
		receiver: 	a HandMorph(337424384)


WorldMorph>>becomeActiveDuring:
	Receiver: a WorldMorph(341720576) [world]
	Arguments and temporary variables: 
		aBlock: 	[
		result := focusHolder handleFocusEvent: transformedEvent.
	]
		priorWorld: 	a WorldMorph(341720576) [world]
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1728@1051)
		owner: 	nil
		submorphs: 	an Array(a MenubarMorph(112886016) a TaskbarMorph(279458560) a S[..]
		fullBounds: 	(0@0) corner: (1728@1051)
		color: 	(Color r: 0.9403714565004888 g: 0.9403714565004888 b: 0.940371456500[..]
		extension: 	a MorphExtension (1012946432) [other:  (dragEnabled -> true) (dr[..]
		borderWidth: 	0
		borderColor: 	(Color r: 0.8611925708699902 g: 1.0 b: 0.7223851417399805 alph[..]
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil


HandMorph>>sendFocusEvent:to:clear:
	Receiver: a HandMorph(337424384)
	Arguments and temporary variables: 
		result: 	nil
		anEvent: 	[(587@126) mouseUp 44405 nil]
		focusHolder: 	a SpToolbarButtonMorph(888790016)
		aBlock: 	[self mouseFocus: nil]
		w: 	a WorldMorph(341720576) [world]
		transformedEvent: 	[(23.0@21.0) mouseUp 44405 nil]
	Receiver's instance variables: 
		bounds: 	(587@126.0) corner: (603@142.0)
		owner: 	a WorldMorph(341720576) [world]
		submorphs: 	#()
		fullBounds: 	(587@126.0) corner: (603@142.0)
		color: 	Color blue
		extension: 	a MorphExtension (370611968)
		mouseFocus: 	nil
		keyboardFocus: 	a RubEditingArea(919167488)
		eventListeners: 	nil
		mouseListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(587@126) mouseUp 44405 nil]
		targetOffset: 	(23.0@16.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 0 0 0 0 0 nil nil)
		captureBlock: 	nil
		recentModifiers: 	0
		pendingEventQueue: 	WaitfreeQueue with 0 items
		supressNextKeyPress: 	false


HandMorph>>sendEvent:focus:clear:
	Receiver: a HandMorph(337424384)
	Arguments and temporary variables: 
		anEvent: 	[(587@126) mouseUp 44405 nil]
		focusHolder: 	a SpToolbarButtonMorph(888790016)
		aBlock: 	[self mouseFocus: nil]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(587@126.0) corner: (603@142.0)
		owner: 	a WorldMorph(341720576) [world]
		submorphs: 	#()
		fullBounds: 	(587@126.0) corner: (603@142.0)
		color: 	Color blue
		extension: 	a MorphExtension (370611968)
		mouseFocus: 	nil
		keyboardFocus: 	a RubEditingArea(919167488)
		eventListeners: 	nil
		mouseListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(587@126) mouseUp 44405 nil]
		targetOffset: 	(23.0@16.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 0 0 0 0 0 nil nil)
		captureBlock: 	nil
		recentModifiers: 	0
		pendingEventQueue: 	WaitfreeQueue with 0 items
		supressNextKeyPress: 	false


HandMorph>>sendMouseEvent:
	Receiver: a HandMorph(337424384)
	Arguments and temporary variables: 
		anEvent: 	[(587@126) mouseUp 44405 nil]
	Receiver's instance variables: 
		bounds: 	(587@126.0) corner: (603@142.0)
		owner: 	a WorldMorph(341720576) [world]
		submorphs: 	#()
		fullBounds: 	(587@126.0) corner: (603@142.0)
		color: 	Color blue
		extension: 	a MorphExtension (370611968)
		mouseFocus: 	nil
		keyboardFocus: 	a RubEditingArea(919167488)
		eventListeners: 	nil
		mouseListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(587@126) mouseUp 44405 nil]
		targetOffset: 	(23.0@16.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 0 0 0 0 0 nil nil)
		captureBlock: 	nil
		recentModifiers: 	0
		pendingEventQueue: 	WaitfreeQueue with 0 items
		supressNextKeyPress: 	false


HandMorph>>handleEvent:
	Receiver: a HandMorph(337424384)
	Arguments and temporary variables: 
		anEvent: 	[(587@126) mouseUp 44405 nil]
		evt: 	[(587@126) mouseUp 44405 nil]
	Receiver's instance variables: 
		bounds: 	(587@126.0) corner: (603@142.0)
		owner: 	a WorldMorph(341720576) [world]
		submorphs: 	#()
		fullBounds: 	(587@126.0) corner: (603@142.0)
		color: 	Color blue
		extension: 	a MorphExtension (370611968)
		mouseFocus: 	nil
		keyboardFocus: 	a RubEditingArea(919167488)
		eventListeners: 	nil
		mouseListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(587@126) mouseUp 44405 nil]
		targetOffset: 	(23.0@16.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 0 0 0 0 0 nil nil)
		captureBlock: 	nil
		recentModifiers: 	0
		pendingEventQueue: 	WaitfreeQueue with 0 items
		supressNextKeyPress: 	false


[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil ]) ifTrue: [
			morphicWorld activeHand handleEvent: anEvent
		]
	] in OSWindowMorphicEventHandler>>dispatchMorphicEvent:
	Receiver: an OSWindowMorphicEventHandler
	Arguments and temporary variables: 
		anEvent: 	[(587@126) mouseUp 44405 nil]
	Receiver's instance variables: 
		morphicWorld: 	a WorldMorph(341720576) [world]


WorldState>>runStepMethodsIn:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(341720576) [world]
		queue: 	WaitfreeQueue with 0 items
		nextInQueue: 	[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNo[..]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(337424384))
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap()
		lastStepTime: 	43477
		lastStepMessage: 	nil
		alarms: 	a Heap(MorphicAlarm(#hideShow -> a RubCursor(899173120)))
		lastAlarmTime: 	44392
		activeHand: 	a HandMorph(337424384)
		currentCursor: 	((CursorWithMask
	extent: (16@16)
	depth: 1
	fromArray: #(
	[..]
		worldRenderer: 	an OSWorldRenderer
		realWindowExtent: 	(1728@1051)
		deferredUIMessages: 	WaitfreeQueue with 0 items


WorldMorph>>runStepMethods
	Receiver: a WorldMorph(341720576) [world]
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1728@1051)
		owner: 	nil
		submorphs: 	an Array(a MenubarMorph(112886016) a TaskbarMorph(279458560) a S[..]
		fullBounds: 	(0@0) corner: (1728@1051)
		color: 	(Color r: 0.9403714565004888 g: 0.9403714565004888 b: 0.940371456500[..]
		extension: 	a MorphExtension (1012946432) [other:  (dragEnabled -> true) (dr[..]
		borderWidth: 	0
		borderColor: 	(Color r: 0.8611925708699902 g: 1.0 b: 0.7223851417399805 alph[..]
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil


WorldState>>doOneCycleFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(341720576) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(337424384))
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap()
		lastStepTime: 	43477
		lastStepMessage: 	nil
		alarms: 	a Heap(MorphicAlarm(#hideShow -> a RubCursor(899173120)))
		lastAlarmTime: 	44392
		activeHand: 	a HandMorph(337424384)
		currentCursor: 	((CursorWithMask
	extent: (16@16)
	depth: 1
	fromArray: #(
	[..]
		worldRenderer: 	an OSWorldRenderer
		realWindowExtent: 	(1728@1051)
		deferredUIMessages: 	WaitfreeQueue with 0 items


WorldMorph>>doOneCycleNow
	Receiver: a WorldMorph(341720576) [world]
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1728@1051)
		owner: 	nil
		submorphs: 	an Array(a MenubarMorph(112886016) a TaskbarMorph(279458560) a S[..]
		fullBounds: 	(0@0) corner: (1728@1051)
		color: 	(Color r: 0.9403714565004888 g: 0.9403714565004888 b: 0.940371456500[..]
		extension: 	a MorphExtension (1012946432) [other:  (dragEnabled -> true) (dr[..]
		borderWidth: 	0
		borderColor: 	(Color r: 0.8611925708699902 g: 1.0 b: 0.7223851417399805 alph[..]
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil


WorldMorph>>doOneCycle
	Receiver: a WorldMorph(341720576) [world]
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1728@1051)
		owner: 	nil
		submorphs: 	an Array(a MenubarMorph(112886016) a TaskbarMorph(279458560) a S[..]
		fullBounds: 	(0@0) corner: (1728@1051)
		color: 	(Color r: 0.9403714565004888 g: 0.9403714565004888 b: 0.940371456500[..]
		extension: 	a MorphExtension (1012946432) [other:  (dragEnabled -> true) (dr[..]
		borderWidth: 	0
		borderColor: 	(Color r: 0.8611925708699902 g: 1.0 b: 0.7223851417399805 alph[..]
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil


[
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMutex critical: [
			                     self extraWorldList ].
		extraWorldsToDraw do: [ :world | world doOneCycle ].

		(self currentWorld isNotNil and: [
			 (extraWorldsToDraw includes: self currentWorld) not ]) ifTrue: [
			self currentWorld doOneCycle ] ] in WorldMorph class>>doOneCycle
	Receiver: WorldMorph
	Arguments and temporary variables: 
		extraWorldsToDraw: 	#()
	Receiver's instance variables: 
		superclass: 	PasteUpMorph
		methodDict: 	a MethodDictionary(#acceptDroppingMorph:event:->WorldMorph>>#ac[..]
		format: 	65547
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		commentSourcePointer: 	nil
		subclasses: 	{AthensWorldMorph. OSWindowWorldMorph}
		name: 	#WorldMorph
		classPool: 	a Dictionary(#AllowDropFiles->nil #CursorOwnerWorld->a WorldMorp[..]
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Morphic-Core-Worlds'
		announcer: 	nil
		displayScaleFactor: 	1


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMutex critical: [
			  [..]
	Arguments and temporary variables: 
		aBlock: 	[
		self doInterCycleWait
	]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	WorldMorph class>>doOneCycle
		compiledBlock: 	a CompiledBlock: [
		| extraWorldsToDraw |
		extraWorldsToDr[..]
		numArgs: 	0
		receiver: 	WorldMorph


WorldState class>>doDrawCycleWith:
	Receiver: WorldState
	Arguments and temporary variables: 
		aBlock: 	[
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMute[..]
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary(#activeHand->WorldState>>#activeHand #active[..]
		format: 	65548
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		commentSourcePointer: 	nil
		subclasses: 	{AthensWorldState}
		name: 	#WorldState
		classPool: 	a Dictionary(#CanSurrenderToOS->nil #DebugShowDamage->false #Des[..]
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Morphic-Core-Worlds'



--- The full stack ---
RSBox(Object)>>doesNotUnderstand: #label:
VisualizerMain>>createSampleGraph
UndefinedObject>>DoIt
OCReceiverDoItSemanticScope(OCDoItSemanticScope)>>evaluateDoIt:
OpalCompiler>>evaluate
[
		self announcer announce: (SpCodeWillBeEvaluatedAnnouncement newContent: aString).
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionModel doItReceiver.
		result := receiver class compiler
			source: aString;
			context: self interactionModel doItContext;
			receiver: self interactionModel doItReceiver;
			requestor: self interactionModel;
			environment: self environment;
			failBlock:  [ 
				self announcer announce: (SpCodeEvaluationFailedAnnouncement newContent: aString).
				^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		self announcer announce: (SpCodeEvaluationSucceedAnnouncement newContent: aString).
		result ] in SpCodePresenter>>evaluate:onCompileError:onError:
FullBlockClosure(BlockClosure)>>on:do:
SpCodePresenter>>evaluate:onCompileError:onError:
StPlaygroundPagePresenter>>doEvaluateAndGo
StPlaygroundPagePresenter>>doEvaluateAllAndGo
StPlaygroundDoItCommand>>execute
SpCommand(CmCommandDecorator)>>execute
[ specCommand execute ] in [ :specCommand | 
			aButtonClass new
				label: specCommand name;
				help: specCommand description;
				in: [ :button | 
					specCommand hasIcon
						ifTrue: [ button icon: specCommand icon ] ];
				action: [ specCommand execute ];
				yourself ] in SpCommand>>configureAsButtonOfClass:
FullBlockClosure(BlockClosure)>>cull:
SpMorphicToolbarButtonAdapter>>execute
SpToolbarButtonMorph(PluggableButtonMorph)>>performAction:
[:m |
		(m containsPoint: evt cursorPoint) ifTrue: [m enabled ifTrue: [ m performAction: evt ]]] in SpToolbarButtonMorph(PluggableButtonMorph)>>mouseUp:
Array(SequenceableCollection)>>do:
SpToolbarButtonMorph(PluggableButtonMorph)>>mouseUp:
SpToolbarButtonMorph(Morph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
SpToolbarButtonMorph(Morph)>>handleEvent:
SpToolbarButtonMorph(Morph)>>handleFocusEvent:
[
		result := focusHolder handleFocusEvent: transformedEvent.
	] in HandMorph>>sendFocusEvent:to:clear:
FullBlockClosure(BlockClosure)>>on:do:
WorldMorph>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil ]) ifTrue: [
			morphicWorld activeHand handleEvent: anEvent
		]
	] in OSWindowMorphicEventHandler>>dispatchMorphicEvent:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycleNow
WorldMorph>>doOneCycle
[
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMutex critical: [
			                     self extraWorldList ].
		extraWorldsToDraw do: [ :world | world doOneCycle ].

		(self currentWorld isNotNil and: [
			 (extraWorldsToDraw includes: self currentWorld) not ]) ifTrue: [
			self currentWorld doOneCycle ] ] in WorldMorph class>>doOneCycle
FullBlockClosure(BlockClosure)>>ensure:
WorldState class>>doDrawCycleWith:
 - - - - - - - - - - - - - - -
			- - - - - - - - - - - - - - - - - -
WorldMorph class>>doOneCycle
MorphicRenderLoop>>doOneCycle
MorphicRenderLoop>>doOneCycleWhile:
[ MorphicRenderLoop new doOneCycleWhile: [ true ] ] in MorphicUIManager>>spawnNewProcess
[self value.
			"IMPORTANT: Do not step over next line of code. See method comments for details"
			Processor terminateRealActive] in FullBlockClosure(BlockClosure)>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
Instance of RSBox did not understand #label:
12 November 2023 11:58:11.82508 am

VM: Mac OS - arm64 - 1000 - CoInterpreter VMMaker-tonel.1 uuid: 902dd483-c0c4-0d00-86f2-0f880df24b96 Oct 23 2023
StackToRegisterMappingCogit VMMaker-tonel.1 uuid: 902dd483-c0c4-0d00-86f2-0f880df24b96 Oct 23 2023
v10.0.8 - Commit: b323c5fb - Date: 2023-10-20 16:02:07 -0400

Image: Pharo11.0.0 [Build information: Pharo-11.0.0+build.710.sha.ea28d8552cac85a7ce1e9c34ab1e7bd45f7b9910 (64 Bit)]

RSBox(Object)>>doesNotUnderstand: #label:
	Receiver: a RSBox
	Arguments and temporary variables: 
		aMessage: 	label: 'Alice'
		exception: 	Instance of RSBox did not understand #label:
		resumeValue: 	nil
	Receiver's instance variables: 
		announcer: 	nil
		properties: 	nil
		paint: 	Color blue
		path: 	(-25.0@ -25.0) corner: (25.0@25.0)
		border: 	nil
		parent: 	nil
		isFixed: 	false
		encompassingRectangle: 	nil
		model: 	nil
		baseRectangle: 	(-25.0@ -25.0) corner: (25.0@25.0)
		matrix: 	x: 0.0 y: 0.0 sx: 1.0 sy: 1.0 shx: 0.0 shy: 0.0
		connectedLines: 	nil
		shouldUpdateLines: 	true
		cornerRadius: 	nil


VisualizerMain>>createSampleGraph
	Receiver: a VisualizerMain
	Arguments and temporary variables: 
		view: 	a RSCanvas
		alice: 	nil
		bob: 	nil
	Receiver's instance variables: 
a VisualizerMain

UndefinedObject>>DoIt
	Receiver: nil
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
nil

OCReceiverDoItSemanticScope(OCDoItSemanticScope)>>evaluateDoIt:
	Receiver: an OCReceiverDoItSemanticScope
	Arguments and temporary variables: 
		doItMethod: 	UndefinedObject>>#DoIt
	Receiver's instance variables: 
		outerScope: 	nil
		targetReceiver: 	nil


OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
		doItMethod: 	UndefinedObject>>#DoIt
	Receiver's instance variables: 
		ast: 	DoIt

	^ VisualizerMain new createSampleGraph open
		source: 	a ReadStream
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil


[
		self announcer announce: (SpCodeWillBeEvaluatedAnnouncement newContent: aString).
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionModel doItReceiver.
		result := receiver class compiler
			source: aString;
			context: self interactionModel doItContext;
			receiver: self interactionModel doItReceiver;
			requestor: self interactionModel;
			environment: self environment;
			failBlock:  [ 
				self announcer announce: (SpCodeEvaluationFailedAnnouncement newContent: aString).
				^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		self announcer announce: (SpCodeEvaluationSucceedAnnouncement newContent: aString).
		result ] in SpCodePresenter>>evaluate:onCompileError:onError:
	Receiver: a SpCodePresenter
	Arguments and temporary variables: 
		aString: 	'(VisualizerMain new createSampleGraph) open.
'
		compileErrorBlock: 	[ ^ self ]
		errorBlock: 	[ :e | e pass ]
		receiver: 	nil
		result: 	nil
		oldBindings: 	a Dictionary()
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicCodeAdapter)
		announcer: 	an Announcer
		owner: 	a StPlaygroundPagePresenter
		adapter: 	a SpMorphicCodeAdapter
		needRebuild: 	true
		eventHandler: 	a SpEventHandler
		application: 	nil
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ a KMCategory ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Code' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpAbstractWidgetLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		borderWidth: 	an ObservableValueHolder[ nil ]
		borderColor: 	an ObservableValueHolder[ nil ]
		dragEnabled: 	an ObservableValueHolder[ false ]
		dropEnabled: 	an ObservableValueHolder[ false ]
		color: 	an ObservableValueHolder[ nil ]
		help: 	an ObservableValueHolder[ nil ]
		enabled: 	an ObservableValueHolder[ true ]
		wantsDrop: 	an ObservableValueHolder[ [ :transfer | self dropEnabled ] ]
		acceptDrop: 	an ObservableValueHolder[ [ :transfer | ] ]
		deferredActions: 	nil
		hasUnacceptedEdits: 	an ObservableValueHolder[ false ]
		selection: 	an ObservableValueHolder[ (1 to: 45) ]
		wantsVisualFeedback: 	an ObservableValueHolder[ true ]
		askBeforeDiscardingEdits: 	an ObservableValueHolder[ true ]
		text: 	an ObservableValueHolder[ '(VisualizerMain new createSampleGraph) ope[..]
		actionToPerform: 	an ObservableValueHolder[ [ :txt |  ] ]
		readSelection: 	an ObservableValueHolder[ [ selection ] ]
		placeholder: 	an ObservableValueHolder[ '' ]
		contextMenu: 	an ObservableValueHolder[ [ (self menuActionsFor: text) asMenu[..]
		scrollValue: 	an ObservableValueHolder[ (0@0) ]
		editionContextMenu: 	an ObservableValueHolder[ true ]
		editable: 	an ObservableValueHolder[ true ]
		wrapWord: 	an ObservableValueHolder[ true ]
		undoRedoHistory: 	true
		wrapScrollBars: 	true
		propagateNaturalHeight: 	false
		propagateNaturalWidth: 	false
		scrollBarStyles: 	#()
		syntaxHighlight: 	an ObservableValueHolder[ true ]
		smartCharacters: 	an ObservableValueHolder[ true ]
		lineNumbers: 	an ObservableValueHolder[ true ]
		interactionModel: 	an ObservableValueHolder[ a StPlaygroundInteractionModel ]
		overrideContextMenu: 	true
		submitBlock: 	nil
		resetBlock: 	nil
		environment: 	nil
		systemNavigation: 	nil
		syntaxHighlightTheme: 	an ObservableValueHolder[ nil ]


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
		self announcer announce: (SpCodeWillBeEvaluatedAnnouncement newContent: aString).
[..]
	Arguments and temporary variables: 
		exception: 	Error
		handlerAction: 	[ :e |
		self announcer announce: (SpCodeEvaluationFailedAnn[..]
	Receiver's instance variables: 
		outerContext: 	SpCodePresenter>>evaluate:onCompileError:onError:
		compiledBlock: 	a CompiledBlock: [
		self announcer announce: (SpCodeWillBeE[..]
		numArgs: 	0
		receiver: 	a SpCodePresenter


SpCodePresenter>>evaluate:onCompileError:onError:
	Receiver: a SpCodePresenter
	Arguments and temporary variables: 
		receiver: 	nil
		result: 	nil
		oldBindings: 	a Dictionary()
		aString: 	'(VisualizerMain new createSampleGraph) open.
'
		compileErrorBlock: 	[ ^ self ]
		errorBlock: 	[ :e | e pass ]
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicCodeAdapter)
		announcer: 	an Announcer
		owner: 	a StPlaygroundPagePresenter
		adapter: 	a SpMorphicCodeAdapter
		needRebuild: 	true
		eventHandler: 	a SpEventHandler
		application: 	nil
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ a KMCategory ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Code' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpAbstractWidgetLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		borderWidth: 	an ObservableValueHolder[ nil ]
		borderColor: 	an ObservableValueHolder[ nil ]
		dragEnabled: 	an ObservableValueHolder[ false ]
		dropEnabled: 	an ObservableValueHolder[ false ]
		color: 	an ObservableValueHolder[ nil ]
		help: 	an ObservableValueHolder[ nil ]
		enabled: 	an ObservableValueHolder[ true ]
		wantsDrop: 	an ObservableValueHolder[ [ :transfer | self dropEnabled ] ]
		acceptDrop: 	an ObservableValueHolder[ [ :transfer | ] ]
		deferredActions: 	nil
		hasUnacceptedEdits: 	an ObservableValueHolder[ false ]
		selection: 	an ObservableValueHolder[ (1 to: 45) ]
		wantsVisualFeedback: 	an ObservableValueHolder[ true ]
		askBeforeDiscardingEdits: 	an ObservableValueHolder[ true ]
		text: 	an ObservableValueHolder[ '(VisualizerMain new createSampleGraph) ope[..]
		actionToPerform: 	an ObservableValueHolder[ [ :txt |  ] ]
		readSelection: 	an ObservableValueHolder[ [ selection ] ]
		placeholder: 	an ObservableValueHolder[ '' ]
		contextMenu: 	an ObservableValueHolder[ [ (self menuActionsFor: text) asMenu[..]
		scrollValue: 	an ObservableValueHolder[ (0@0) ]
		editionContextMenu: 	an ObservableValueHolder[ true ]
		editable: 	an ObservableValueHolder[ true ]
		wrapWord: 	an ObservableValueHolder[ true ]
		undoRedoHistory: 	true
		wrapScrollBars: 	true
		propagateNaturalHeight: 	false
		propagateNaturalWidth: 	false
		scrollBarStyles: 	#()
		syntaxHighlight: 	an ObservableValueHolder[ true ]
		smartCharacters: 	an ObservableValueHolder[ true ]
		lineNumbers: 	an ObservableValueHolder[ true ]
		interactionModel: 	an ObservableValueHolder[ a StPlaygroundInteractionModel ]
		overrideContextMenu: 	true
		submitBlock: 	nil
		resetBlock: 	nil
		environment: 	nil
		systemNavigation: 	nil
		syntaxHighlightTheme: 	an ObservableValueHolder[ nil ]


StPlaygroundPagePresenter>>doEvaluateAndGo
	Receiver: a StPlaygroundPagePresenter
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicBoxAdapter)
		announcer: 	an Announcer
		owner: 	a SpMillerColumnPresenter
		adapter: 	a SpMorphicBoxAdapter
		needRebuild: 	true
		eventHandler: 	nil
		application: 	a StPharoApplication
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ nil ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Untitled window' ]
		additionalSubpresentersMap: 	a Dictionary()
		layout: 	an ObservableValueHolder[ a SpBoxLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		text: 	a SpCodePresenter
		toolbar: 	a SpToolbarPresenter
		statusbar: 	a SpPresenter
		lineLabel: 	a SpLabelPresenter
		toggleLineNumberButton: 	a SpToggleButtonPresenter
		page: 	a StPlaygroundPage
		activationBlock: 	[ :selection |
		self changeSelection: selection from: new[..]


StPlaygroundPagePresenter>>doEvaluateAllAndGo
	Receiver: a StPlaygroundPagePresenter
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicBoxAdapter)
		announcer: 	an Announcer
		owner: 	a SpMillerColumnPresenter
		adapter: 	a SpMorphicBoxAdapter
		needRebuild: 	true
		eventHandler: 	nil
		application: 	a StPharoApplication
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ nil ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Untitled window' ]
		additionalSubpresentersMap: 	a Dictionary()
		layout: 	an ObservableValueHolder[ a SpBoxLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		text: 	a SpCodePresenter
		toolbar: 	a SpToolbarPresenter
		statusbar: 	a SpPresenter
		lineLabel: 	a SpLabelPresenter
		toggleLineNumberButton: 	a SpToggleButtonPresenter
		page: 	a StPlaygroundPage
		activationBlock: 	[ :selection |
		self changeSelection: selection from: new[..]


StPlaygroundDoItCommand>>execute
	Receiver: a StPlaygroundDoItCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		context: 	a StPlaygroundPagePresenter
		basicName: 	'Do it'
		basicDescription: 	'Do it all and inspect.'


SpCommand(CmCommandDecorator)>>execute
	Receiver: a SpCommand(Do it)
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a StPlaygroundDoItCommand
		iconProvider: 	a StPharoApplication
		iconName: 	#glamorousGo
		shortcutKey: 	nil
		displayStrategy: 	a CmUIDisableWhenCantBeRun
		positionStrategy: 	a CmUILeftPositionStrategy
		buildPresenterBlock: 	[ :specCommand | 
			aButtonClass new
				label: specC[..]
		presenter: 	a SpToolbarButtonPresenter


[ specCommand execute ] in [ :specCommand | 
			aButtonClass new
				label: specCommand name;
				help: specCommand description;
				in: [ :button | 
					specCommand hasIcon
						ifTrue: [ button icon: specCommand icon ] ];
				action: [ specCommand execute ];
				yourself ] in SpCommand>>configureAsButtonOfClass:
	Receiver: a SpCommand(Do it)
	Arguments and temporary variables: 
		aButtonClass: 	nil
		specCommand: 	a SpCommand(Do it)
	Receiver's instance variables: 
		decoratedCommand: 	a StPlaygroundDoItCommand
		iconProvider: 	a StPharoApplication
		iconName: 	#glamorousGo
		shortcutKey: 	nil
		displayStrategy: 	a CmUIDisableWhenCantBeRun
		positionStrategy: 	a CmUILeftPositionStrategy
		buildPresenterBlock: 	[ :specCommand | 
			aButtonClass new
				label: specC[..]
		presenter: 	a SpToolbarButtonPresenter


FullBlockClosure(BlockClosure)>>cull:
	Receiver: [ specCommand execute ]
	Arguments and temporary variables: 
		anArg: 	a SpToolbarButtonPresenter
	Receiver's instance variables: 
		outerContext: 	[ :specCommand | 
			aButtonClass new
				label: specCommand [..]
		compiledBlock: 	a CompiledBlock: [ specCommand execute ]
		numArgs: 	0
		receiver: 	a SpCommand(Do it)


SpMorphicToolbarButtonAdapter>>execute
	Receiver: a SpMorphicToolbarButtonAdapter
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpToolbarButtonMorph(449631488))
		announcer: 	nil
		model: 	a SpToolbarButtonPresenter
		widget: 	a SpToolbarButtonMorph(449631488)
		selector: 	nil
		owner: 	a SpToolbarButtonPresenter
		unsubscribed: 	false


SpToolbarButtonMorph(PluggableButtonMorph)>>performAction:
	Receiver: a SpToolbarButtonMorph(449631488)
	Arguments and temporary variables: 
		event: 	[(20.0@30.0) mouseUp 73495 nil]
	Receiver's instance variables: 
		bounds: 	(0.0@5.0) corner: (45.0@39.0)
		owner: 	a Morph(1035472128)
		submorphs: 	an Array(an AlignmentMorph(149947904))
		fullBounds: 	nil
		color: 	(Color r: 0.9012707722385142 g: 0.9012707722385142 b: 0.901270772238[..]
		extension: 	a MorphExtension (703115520) [balloonText]  [other:  (presenter [..]
		borderWidth: 	0
		borderColor: 	#simple
		model: 	a SpMorphicToolbarButtonAdapter
		label: 	'Do it'
		icon: 	Form(13x13x32)
		getIconSelector: 	#icon
		getStateSelector: 	#state
		actionSelector: 	#execute
		font: 	a LogicalFont
 familyName: 'Source Sans Pro'
 emphasis: nil
 pointSiz[..]
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	nil
		getFontSelector: 	nil
		labelMorph: 	a LabelMorph(104243968)'Do it'
		iconMorph: 	an ImageMorph(734040320)
		iconPosition: 	#top
		lastState: 	false
		badgeFont: 	nil
		badgeSelector: 	#badge


[:m |
		(m containsPoint: evt cursorPoint) ifTrue: [m enabled ifTrue: [ m performAction: evt ]]] in SpToolbarButtonMorph(PluggableButtonMorph)>>mouseUp:
	Receiver: a SpToolbarButtonMorph(449631488)
	Arguments and temporary variables: 
		evt: 	[(20.0@30.0) mouseUp 73495 nil]
		all: 	an Array(a SpToolbarButtonMorph(449631488) a SpToolbarButtonMorph(7977[..]
		m: 	a SpToolbarButtonMorph(449631488)
	Receiver's instance variables: 
		bounds: 	(0.0@5.0) corner: (45.0@39.0)
		owner: 	a Morph(1035472128)
		submorphs: 	an Array(an AlignmentMorph(149947904))
		fullBounds: 	nil
		color: 	(Color r: 0.9012707722385142 g: 0.9012707722385142 b: 0.901270772238[..]
		extension: 	a MorphExtension (703115520) [balloonText]  [other:  (presenter [..]
		borderWidth: 	0
		borderColor: 	#simple
		model: 	a SpMorphicToolbarButtonAdapter
		label: 	'Do it'
		icon: 	Form(13x13x32)
		getIconSelector: 	#icon
		getStateSelector: 	#state
		actionSelector: 	#execute
		font: 	a LogicalFont
 familyName: 'Source Sans Pro'
 emphasis: nil
 pointSiz[..]
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	nil
		getFontSelector: 	nil
		labelMorph: 	a LabelMorph(104243968)'Do it'
		iconMorph: 	an ImageMorph(734040320)
		iconPosition: 	#top
		lastState: 	false
		badgeFont: 	nil
		badgeSelector: 	#badge


Array(SequenceableCollection)>>do:
	Receiver: an Array(a SpToolbarButtonMorph(449631488) a SpToolbarButtonMorph(797724672) a SpToolb[..]
	Arguments and temporary variables: 
		aBlock: 	[:m |
		(m containsPoint: evt cursorPoint) ifTrue: [m enabled ifTru[..]
		index: 	1
	Receiver's instance variables: 
an Array(a SpToolbarButtonMorph(449631488) a SpToolbarButtonMorph(797724672) a SpToolb[..]

SpToolbarButtonMorph(PluggableButtonMorph)>>mouseUp:
	Receiver: a SpToolbarButtonMorph(449631488)
	Arguments and temporary variables: 
		evt: 	[(20.0@30.0) mouseUp 73495 nil]
		all: 	an Array(a SpToolbarButtonMorph(449631488) a SpToolbarButtonMorph(7977[..]
	Receiver's instance variables: 
		bounds: 	(0.0@5.0) corner: (45.0@39.0)
		owner: 	a Morph(1035472128)
		submorphs: 	an Array(an AlignmentMorph(149947904))
		fullBounds: 	nil
		color: 	(Color r: 0.9012707722385142 g: 0.9012707722385142 b: 0.901270772238[..]
		extension: 	a MorphExtension (703115520) [balloonText]  [other:  (presenter [..]
		borderWidth: 	0
		borderColor: 	#simple
		model: 	a SpMorphicToolbarButtonAdapter
		label: 	'Do it'
		icon: 	Form(13x13x32)
		getIconSelector: 	#icon
		getStateSelector: 	#state
		actionSelector: 	#execute
		font: 	a LogicalFont
 familyName: 'Source Sans Pro'
 emphasis: nil
 pointSiz[..]
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	nil
		getFontSelector: 	nil
		labelMorph: 	a LabelMorph(104243968)'Do it'
		iconMorph: 	an ImageMorph(734040320)
		iconPosition: 	#top
		lastState: 	false
		badgeFont: 	nil
		badgeSelector: 	#badge


SpToolbarButtonMorph(Morph)>>handleMouseUp:
	Receiver: a SpToolbarButtonMorph(449631488)
	Arguments and temporary variables: 
		anEvent: 	[(20.0@30.0) mouseUp 73495 nil]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(0.0@5.0) corner: (45.0@39.0)
		owner: 	a Morph(1035472128)
		submorphs: 	an Array(an AlignmentMorph(149947904))
		fullBounds: 	nil
		color: 	(Color r: 0.9012707722385142 g: 0.9012707722385142 b: 0.901270772238[..]
		extension: 	a MorphExtension (703115520) [balloonText]  [other:  (presenter [..]
		borderWidth: 	0
		borderColor: 	#simple
		model: 	a SpMorphicToolbarButtonAdapter
		label: 	'Do it'
		icon: 	Form(13x13x32)
		getIconSelector: 	#icon
		getStateSelector: 	#state
		actionSelector: 	#execute
		font: 	a LogicalFont
 familyName: 'Source Sans Pro'
 emphasis: nil
 pointSiz[..]
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	nil
		getFontSelector: 	nil
		labelMorph: 	a LabelMorph(104243968)'Do it'
		iconMorph: 	an ImageMorph(734040320)
		iconPosition: 	#top
		lastState: 	false
		badgeFont: 	nil
		badgeSelector: 	#badge


MouseButtonEvent>>sentTo:
	Receiver: [(20.0@30.0) mouseUp 73495 nil]
	Arguments and temporary variables: 
		anObject: 	a SpToolbarButtonMorph(449631488)
	Receiver's instance variables: 
		timeStamp: 	73495
		source: 	a HandMorph(337424384)
		windowIndex: 	nil
		type: 	#mouseUp
		buttons: 	0
		position: 	(20.0@30.0)
		handler: 	nil
		wasHandled: 	true
		whichButton: 	4


SpToolbarButtonMorph(Morph)>>handleEvent:
	Receiver: a SpToolbarButtonMorph(449631488)
	Arguments and temporary variables: 
		anEvent: 	[(20.0@30.0) mouseUp 73495 nil]
	Receiver's instance variables: 
		bounds: 	(0.0@5.0) corner: (45.0@39.0)
		owner: 	a Morph(1035472128)
		submorphs: 	an Array(an AlignmentMorph(149947904))
		fullBounds: 	nil
		color: 	(Color r: 0.9012707722385142 g: 0.9012707722385142 b: 0.901270772238[..]
		extension: 	a MorphExtension (703115520) [balloonText]  [other:  (presenter [..]
		borderWidth: 	0
		borderColor: 	#simple
		model: 	a SpMorphicToolbarButtonAdapter
		label: 	'Do it'
		icon: 	Form(13x13x32)
		getIconSelector: 	#icon
		getStateSelector: 	#state
		actionSelector: 	#execute
		font: 	a LogicalFont
 familyName: 'Source Sans Pro'
 emphasis: nil
 pointSiz[..]
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	nil
		getFontSelector: 	nil
		labelMorph: 	a LabelMorph(104243968)'Do it'
		iconMorph: 	an ImageMorph(734040320)
		iconPosition: 	#top
		lastState: 	false
		badgeFont: 	nil
		badgeSelector: 	#badge


SpToolbarButtonMorph(Morph)>>handleFocusEvent:
	Receiver: a SpToolbarButtonMorph(449631488)
	Arguments and temporary variables: 
		anEvent: 	[(20.0@30.0) mouseUp 73495 nil]
	Receiver's instance variables: 
		bounds: 	(0.0@5.0) corner: (45.0@39.0)
		owner: 	a Morph(1035472128)
		submorphs: 	an Array(an AlignmentMorph(149947904))
		fullBounds: 	nil
		color: 	(Color r: 0.9012707722385142 g: 0.9012707722385142 b: 0.901270772238[..]
		extension: 	a MorphExtension (703115520) [balloonText]  [other:  (presenter [..]
		borderWidth: 	0
		borderColor: 	#simple
		model: 	a SpMorphicToolbarButtonAdapter
		label: 	'Do it'
		icon: 	Form(13x13x32)
		getIconSelector: 	#icon
		getStateSelector: 	#state
		actionSelector: 	#execute
		font: 	a LogicalFont
 familyName: 'Source Sans Pro'
 emphasis: nil
 pointSiz[..]
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	nil
		getFontSelector: 	nil
		labelMorph: 	a LabelMorph(104243968)'Do it'
		iconMorph: 	an ImageMorph(734040320)
		iconPosition: 	#top
		lastState: 	false
		badgeFont: 	nil
		badgeSelector: 	#badge


[
		result := focusHolder handleFocusEvent: transformedEvent.
	] in HandMorph>>sendFocusEvent:to:clear:
	Receiver: a HandMorph(337424384)
	Arguments and temporary variables: 
		anEvent: 	[(539@333) mouseUp 73495 nil]
		focusHolder: 	a SpToolbarButtonMorph(449631488)
		aBlock: 	[self mouseFocus: nil]
		w: 	a WorldMorph(341720576) [world]
		transformedEvent: 	[(20.0@30.0) mouseUp 73495 nil]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(539@333.0) corner: (555@349.0)
		owner: 	a WorldMorph(341720576) [world]
		submorphs: 	#()
		fullBounds: 	(539@333.0) corner: (555@349.0)
		color: 	Color blue
		extension: 	a MorphExtension (370611968)
		mouseFocus: 	nil
		keyboardFocus: 	a RubEditingArea(80907264)
		eventListeners: 	nil
		mouseListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(539@333) mouseUp 73495 nil]
		targetOffset: 	(20.0@25.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 0 0 0 0 0 nil nil)
		captureBlock: 	nil
		recentModifiers: 	0
		pendingEventQueue: 	WaitfreeQueue with 0 items
		supressNextKeyPress: 	false


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
		result := focusHolder handleFocusEvent: transformedEvent.
	]
	Arguments and temporary variables: 
		exception: 	Error
		handlerAction: 	[ :ex |
			ActiveWorld := priorWorld.
			ex pass ]
	Receiver's instance variables: 
		outerContext: 	HandMorph>>sendFocusEvent:to:clear:
		compiledBlock: 	a CompiledBlock: [
		result := focusHolder handleFocusEvent:[..]
		numArgs: 	0
		receiver: 	a HandMorph(337424384)


WorldMorph>>becomeActiveDuring:
	Receiver: a WorldMorph(341720576) [world]
	Arguments and temporary variables: 
		aBlock: 	[
		result := focusHolder handleFocusEvent: transformedEvent.
	]
		priorWorld: 	a WorldMorph(341720576) [world]
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1728@1051)
		owner: 	nil
		submorphs: 	an Array(a MenubarMorph(112886016) a TaskbarMorph(279458560) a S[..]
		fullBounds: 	(0@0) corner: (1728@1051)
		color: 	(Color r: 0.9403714565004888 g: 0.9403714565004888 b: 0.940371456500[..]
		extension: 	a MorphExtension (1012946432) [other:  (dragEnabled -> true) (dr[..]
		borderWidth: 	0
		borderColor: 	(Color r: 0.8611925708699902 g: 1.0 b: 0.7223851417399805 alph[..]
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil


HandMorph>>sendFocusEvent:to:clear:
	Receiver: a HandMorph(337424384)
	Arguments and temporary variables: 
		result: 	nil
		anEvent: 	[(539@333) mouseUp 73495 nil]
		focusHolder: 	a SpToolbarButtonMorph(449631488)
		aBlock: 	[self mouseFocus: nil]
		w: 	a WorldMorph(341720576) [world]
		transformedEvent: 	[(20.0@30.0) mouseUp 73495 nil]
	Receiver's instance variables: 
		bounds: 	(539@333.0) corner: (555@349.0)
		owner: 	a WorldMorph(341720576) [world]
		submorphs: 	#()
		fullBounds: 	(539@333.0) corner: (555@349.0)
		color: 	Color blue
		extension: 	a MorphExtension (370611968)
		mouseFocus: 	nil
		keyboardFocus: 	a RubEditingArea(80907264)
		eventListeners: 	nil
		mouseListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(539@333) mouseUp 73495 nil]
		targetOffset: 	(20.0@25.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 0 0 0 0 0 nil nil)
		captureBlock: 	nil
		recentModifiers: 	0
		pendingEventQueue: 	WaitfreeQueue with 0 items
		supressNextKeyPress: 	false


HandMorph>>sendEvent:focus:clear:
	Receiver: a HandMorph(337424384)
	Arguments and temporary variables: 
		anEvent: 	[(539@333) mouseUp 73495 nil]
		focusHolder: 	a SpToolbarButtonMorph(449631488)
		aBlock: 	[self mouseFocus: nil]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(539@333.0) corner: (555@349.0)
		owner: 	a WorldMorph(341720576) [world]
		submorphs: 	#()
		fullBounds: 	(539@333.0) corner: (555@349.0)
		color: 	Color blue
		extension: 	a MorphExtension (370611968)
		mouseFocus: 	nil
		keyboardFocus: 	a RubEditingArea(80907264)
		eventListeners: 	nil
		mouseListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(539@333) mouseUp 73495 nil]
		targetOffset: 	(20.0@25.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 0 0 0 0 0 nil nil)
		captureBlock: 	nil
		recentModifiers: 	0
		pendingEventQueue: 	WaitfreeQueue with 0 items
		supressNextKeyPress: 	false


HandMorph>>sendMouseEvent:
	Receiver: a HandMorph(337424384)
	Arguments and temporary variables: 
		anEvent: 	[(539@333) mouseUp 73495 nil]
	Receiver's instance variables: 
		bounds: 	(539@333.0) corner: (555@349.0)
		owner: 	a WorldMorph(341720576) [world]
		submorphs: 	#()
		fullBounds: 	(539@333.0) corner: (555@349.0)
		color: 	Color blue
		extension: 	a MorphExtension (370611968)
		mouseFocus: 	nil
		keyboardFocus: 	a RubEditingArea(80907264)
		eventListeners: 	nil
		mouseListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(539@333) mouseUp 73495 nil]
		targetOffset: 	(20.0@25.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 0 0 0 0 0 nil nil)
		captureBlock: 	nil
		recentModifiers: 	0
		pendingEventQueue: 	WaitfreeQueue with 0 items
		supressNextKeyPress: 	false


HandMorph>>handleEvent:
	Receiver: a HandMorph(337424384)
	Arguments and temporary variables: 
		anEvent: 	[(539@333) mouseUp 73495 nil]
		evt: 	[(539@333) mouseUp 73495 nil]
	Receiver's instance variables: 
		bounds: 	(539@333.0) corner: (555@349.0)
		owner: 	a WorldMorph(341720576) [world]
		submorphs: 	#()
		fullBounds: 	(539@333.0) corner: (555@349.0)
		color: 	Color blue
		extension: 	a MorphExtension (370611968)
		mouseFocus: 	nil
		keyboardFocus: 	a RubEditingArea(80907264)
		eventListeners: 	nil
		mouseListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(539@333) mouseUp 73495 nil]
		targetOffset: 	(20.0@25.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 0 0 0 0 0 nil nil)
		captureBlock: 	nil
		recentModifiers: 	0
		pendingEventQueue: 	WaitfreeQueue with 0 items
		supressNextKeyPress: 	false


[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil ]) ifTrue: [
			morphicWorld activeHand handleEvent: anEvent
		]
	] in OSWindowMorphicEventHandler>>dispatchMorphicEvent:
	Receiver: an OSWindowMorphicEventHandler
	Arguments and temporary variables: 
		anEvent: 	[(539@333) mouseUp 73495 nil]
	Receiver's instance variables: 
		morphicWorld: 	a WorldMorph(341720576) [world]


WorldState>>runStepMethodsIn:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(341720576) [world]
		queue: 	WaitfreeQueue with 0 items
		nextInQueue: 	[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNo[..]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(337424384))
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap()
		lastStepTime: 	53956
		lastStepMessage: 	nil
		alarms: 	a Heap(MorphicAlarm(#hideShow -> a RubCursor(618416640)))
		lastAlarmTime: 	73483
		activeHand: 	a HandMorph(337424384)
		currentCursor: 	((CursorWithMask
	extent: (16@16)
	depth: 1
	fromArray: #(
	[..]
		worldRenderer: 	an OSWorldRenderer
		realWindowExtent: 	(1728@1051)
		deferredUIMessages: 	WaitfreeQueue with 0 items


WorldMorph>>runStepMethods
	Receiver: a WorldMorph(341720576) [world]
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1728@1051)
		owner: 	nil
		submorphs: 	an Array(a MenubarMorph(112886016) a TaskbarMorph(279458560) a S[..]
		fullBounds: 	(0@0) corner: (1728@1051)
		color: 	(Color r: 0.9403714565004888 g: 0.9403714565004888 b: 0.940371456500[..]
		extension: 	a MorphExtension (1012946432) [other:  (dragEnabled -> true) (dr[..]
		borderWidth: 	0
		borderColor: 	(Color r: 0.8611925708699902 g: 1.0 b: 0.7223851417399805 alph[..]
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil


WorldState>>doOneCycleFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(341720576) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(337424384))
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap()
		lastStepTime: 	53956
		lastStepMessage: 	nil
		alarms: 	a Heap(MorphicAlarm(#hideShow -> a RubCursor(618416640)))
		lastAlarmTime: 	73483
		activeHand: 	a HandMorph(337424384)
		currentCursor: 	((CursorWithMask
	extent: (16@16)
	depth: 1
	fromArray: #(
	[..]
		worldRenderer: 	an OSWorldRenderer
		realWindowExtent: 	(1728@1051)
		deferredUIMessages: 	WaitfreeQueue with 0 items


WorldMorph>>doOneCycleNow
	Receiver: a WorldMorph(341720576) [world]
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1728@1051)
		owner: 	nil
		submorphs: 	an Array(a MenubarMorph(112886016) a TaskbarMorph(279458560) a S[..]
		fullBounds: 	(0@0) corner: (1728@1051)
		color: 	(Color r: 0.9403714565004888 g: 0.9403714565004888 b: 0.940371456500[..]
		extension: 	a MorphExtension (1012946432) [other:  (dragEnabled -> true) (dr[..]
		borderWidth: 	0
		borderColor: 	(Color r: 0.8611925708699902 g: 1.0 b: 0.7223851417399805 alph[..]
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil


WorldMorph>>doOneCycle
	Receiver: a WorldMorph(341720576) [world]
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1728@1051)
		owner: 	nil
		submorphs: 	an Array(a MenubarMorph(112886016) a TaskbarMorph(279458560) a S[..]
		fullBounds: 	(0@0) corner: (1728@1051)
		color: 	(Color r: 0.9403714565004888 g: 0.9403714565004888 b: 0.940371456500[..]
		extension: 	a MorphExtension (1012946432) [other:  (dragEnabled -> true) (dr[..]
		borderWidth: 	0
		borderColor: 	(Color r: 0.8611925708699902 g: 1.0 b: 0.7223851417399805 alph[..]
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil


[
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMutex critical: [
			                     self extraWorldList ].
		extraWorldsToDraw do: [ :world | world doOneCycle ].

		(self currentWorld isNotNil and: [
			 (extraWorldsToDraw includes: self currentWorld) not ]) ifTrue: [
			self currentWorld doOneCycle ] ] in WorldMorph class>>doOneCycle
	Receiver: WorldMorph
	Arguments and temporary variables: 
		extraWorldsToDraw: 	#()
	Receiver's instance variables: 
		superclass: 	PasteUpMorph
		methodDict: 	a MethodDictionary(#acceptDroppingMorph:event:->WorldMorph>>#ac[..]
		format: 	65547
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		commentSourcePointer: 	nil
		subclasses: 	{AthensWorldMorph. OSWindowWorldMorph}
		name: 	#WorldMorph
		classPool: 	a Dictionary(#AllowDropFiles->nil #CursorOwnerWorld->a WorldMorp[..]
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Morphic-Core-Worlds'
		announcer: 	nil
		displayScaleFactor: 	1


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMutex critical: [
			  [..]
	Arguments and temporary variables: 
		aBlock: 	[
		self doInterCycleWait
	]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	WorldMorph class>>doOneCycle
		compiledBlock: 	a CompiledBlock: [
		| extraWorldsToDraw |
		extraWorldsToDr[..]
		numArgs: 	0
		receiver: 	WorldMorph


WorldState class>>doDrawCycleWith:
	Receiver: WorldState
	Arguments and temporary variables: 
		aBlock: 	[
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMute[..]
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary(#activeHand->WorldState>>#activeHand #active[..]
		format: 	65548
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		commentSourcePointer: 	nil
		subclasses: 	{AthensWorldState}
		name: 	#WorldState
		classPool: 	a Dictionary(#CanSurrenderToOS->nil #DebugShowDamage->false #Des[..]
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Morphic-Core-Worlds'



--- The full stack ---
RSBox(Object)>>doesNotUnderstand: #label:
VisualizerMain>>createSampleGraph
UndefinedObject>>DoIt
OCReceiverDoItSemanticScope(OCDoItSemanticScope)>>evaluateDoIt:
OpalCompiler>>evaluate
[
		self announcer announce: (SpCodeWillBeEvaluatedAnnouncement newContent: aString).
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionModel doItReceiver.
		result := receiver class compiler
			source: aString;
			context: self interactionModel doItContext;
			receiver: self interactionModel doItReceiver;
			requestor: self interactionModel;
			environment: self environment;
			failBlock:  [ 
				self announcer announce: (SpCodeEvaluationFailedAnnouncement newContent: aString).
				^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		self announcer announce: (SpCodeEvaluationSucceedAnnouncement newContent: aString).
		result ] in SpCodePresenter>>evaluate:onCompileError:onError:
FullBlockClosure(BlockClosure)>>on:do:
SpCodePresenter>>evaluate:onCompileError:onError:
StPlaygroundPagePresenter>>doEvaluateAndGo
StPlaygroundPagePresenter>>doEvaluateAllAndGo
StPlaygroundDoItCommand>>execute
SpCommand(CmCommandDecorator)>>execute
[ specCommand execute ] in [ :specCommand | 
			aButtonClass new
				label: specCommand name;
				help: specCommand description;
				in: [ :button | 
					specCommand hasIcon
						ifTrue: [ button icon: specCommand icon ] ];
				action: [ specCommand execute ];
				yourself ] in SpCommand>>configureAsButtonOfClass:
FullBlockClosure(BlockClosure)>>cull:
SpMorphicToolbarButtonAdapter>>execute
SpToolbarButtonMorph(PluggableButtonMorph)>>performAction:
[:m |
		(m containsPoint: evt cursorPoint) ifTrue: [m enabled ifTrue: [ m performAction: evt ]]] in SpToolbarButtonMorph(PluggableButtonMorph)>>mouseUp:
Array(SequenceableCollection)>>do:
SpToolbarButtonMorph(PluggableButtonMorph)>>mouseUp:
SpToolbarButtonMorph(Morph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
SpToolbarButtonMorph(Morph)>>handleEvent:
SpToolbarButtonMorph(Morph)>>handleFocusEvent:
[
		result := focusHolder handleFocusEvent: transformedEvent.
	] in HandMorph>>sendFocusEvent:to:clear:
FullBlockClosure(BlockClosure)>>on:do:
WorldMorph>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil ]) ifTrue: [
			morphicWorld activeHand handleEvent: anEvent
		]
	] in OSWindowMorphicEventHandler>>dispatchMorphicEvent:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycleNow
WorldMorph>>doOneCycle
[
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMutex critical: [
			                     self extraWorldList ].
		extraWorldsToDraw do: [ :world | world doOneCycle ].

		(self currentWorld isNotNil and: [
			 (extraWorldsToDraw includes: self currentWorld) not ]) ifTrue: [
			self currentWorld doOneCycle ] ] in WorldMorph class>>doOneCycle
FullBlockClosure(BlockClosure)>>ensure:
WorldState class>>doDrawCycleWith:
 - - - - - - - - - - - - - - -
			- - - - - - - - - - - - - - - - - -
WorldMorph class>>doOneCycle
MorphicRenderLoop>>doOneCycle
MorphicRenderLoop>>doOneCycleWhile:
[ MorphicRenderLoop new doOneCycleWhile: [ true ] ] in MorphicUIManager>>spawnNewProcess
[self value.
			"IMPORTANT: Do not step over next line of code. See method comments for details"
			Processor terminateRealActive] in FullBlockClosure(BlockClosure)>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
Instance of RSBox did not understand #label:
12 November 2023 11:58:11.848221 am

VM: Mac OS - arm64 - 1000 - CoInterpreter VMMaker-tonel.1 uuid: 902dd483-c0c4-0d00-86f2-0f880df24b96 Oct 23 2023
StackToRegisterMappingCogit VMMaker-tonel.1 uuid: 902dd483-c0c4-0d00-86f2-0f880df24b96 Oct 23 2023
v10.0.8 - Commit: b323c5fb - Date: 2023-10-20 16:02:07 -0400

Image: Pharo11.0.0 [Build information: Pharo-11.0.0+build.710.sha.ea28d8552cac85a7ce1e9c34ab1e7bd45f7b9910 (64 Bit)]

RSBox(Object)>>doesNotUnderstand: #label:
	Receiver: a RSBox
	Arguments and temporary variables: 
		aMessage: 	label: 'Alice'
		exception: 	Instance of RSBox did not understand #label:
		resumeValue: 	nil
	Receiver's instance variables: 
		announcer: 	nil
		properties: 	nil
		paint: 	Color blue
		path: 	(-25.0@ -25.0) corner: (25.0@25.0)
		border: 	nil
		parent: 	nil
		isFixed: 	false
		encompassingRectangle: 	nil
		model: 	nil
		baseRectangle: 	(-25.0@ -25.0) corner: (25.0@25.0)
		matrix: 	x: 0.0 y: 0.0 sx: 1.0 sy: 1.0 shx: 0.0 shy: 0.0
		connectedLines: 	nil
		shouldUpdateLines: 	true
		cornerRadius: 	nil


VisualizerMain>>createSampleGraph
	Receiver: a VisualizerMain
	Arguments and temporary variables: 
		view: 	a RSCanvas
		alice: 	nil
		bob: 	nil
	Receiver's instance variables: 
a VisualizerMain

UndefinedObject>>DoIt
	Receiver: nil
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
nil

OCReceiverDoItSemanticScope(OCDoItSemanticScope)>>evaluateDoIt:
	Receiver: an OCReceiverDoItSemanticScope
	Arguments and temporary variables: 
		doItMethod: 	UndefinedObject>>#DoIt
	Receiver's instance variables: 
		outerScope: 	nil
		targetReceiver: 	nil


OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
		doItMethod: 	UndefinedObject>>#DoIt
	Receiver's instance variables: 
		ast: 	DoIt

	^ VisualizerMain new createSampleGraph open
		source: 	a ReadStream
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil


[
		self announcer announce: (SpCodeWillBeEvaluatedAnnouncement newContent: aString).
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionModel doItReceiver.
		result := receiver class compiler
			source: aString;
			context: self interactionModel doItContext;
			receiver: self interactionModel doItReceiver;
			requestor: self interactionModel;
			environment: self environment;
			failBlock:  [ 
				self announcer announce: (SpCodeEvaluationFailedAnnouncement newContent: aString).
				^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		self announcer announce: (SpCodeEvaluationSucceedAnnouncement newContent: aString).
		result ] in SpCodePresenter>>evaluate:onCompileError:onError:
	Receiver: a SpCodePresenter
	Arguments and temporary variables: 
		aString: 	'(VisualizerMain new createSampleGraph) open.
'
		compileErrorBlock: 	[ ^ self ]
		errorBlock: 	[ :e | e pass ]
		receiver: 	nil
		result: 	nil
		oldBindings: 	a Dictionary()
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicCodeAdapter)
		announcer: 	an Announcer
		owner: 	a StPlaygroundPagePresenter
		adapter: 	a SpMorphicCodeAdapter
		needRebuild: 	true
		eventHandler: 	a SpEventHandler
		application: 	nil
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ a KMCategory ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Code' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpAbstractWidgetLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		borderWidth: 	an ObservableValueHolder[ nil ]
		borderColor: 	an ObservableValueHolder[ nil ]
		dragEnabled: 	an ObservableValueHolder[ false ]
		dropEnabled: 	an ObservableValueHolder[ false ]
		color: 	an ObservableValueHolder[ nil ]
		help: 	an ObservableValueHolder[ nil ]
		enabled: 	an ObservableValueHolder[ true ]
		wantsDrop: 	an ObservableValueHolder[ [ :transfer | self dropEnabled ] ]
		acceptDrop: 	an ObservableValueHolder[ [ :transfer | ] ]
		deferredActions: 	nil
		hasUnacceptedEdits: 	an ObservableValueHolder[ false ]
		selection: 	an ObservableValueHolder[ (1 to: 45) ]
		wantsVisualFeedback: 	an ObservableValueHolder[ true ]
		askBeforeDiscardingEdits: 	an ObservableValueHolder[ true ]
		text: 	an ObservableValueHolder[ '(VisualizerMain new createSampleGraph) ope[..]
		actionToPerform: 	an ObservableValueHolder[ [ :txt |  ] ]
		readSelection: 	an ObservableValueHolder[ [ selection ] ]
		placeholder: 	an ObservableValueHolder[ '' ]
		contextMenu: 	an ObservableValueHolder[ [ (self menuActionsFor: text) asMenu[..]
		scrollValue: 	an ObservableValueHolder[ (0@0) ]
		editionContextMenu: 	an ObservableValueHolder[ true ]
		editable: 	an ObservableValueHolder[ true ]
		wrapWord: 	an ObservableValueHolder[ true ]
		undoRedoHistory: 	true
		wrapScrollBars: 	true
		propagateNaturalHeight: 	false
		propagateNaturalWidth: 	false
		scrollBarStyles: 	#()
		syntaxHighlight: 	an ObservableValueHolder[ true ]
		smartCharacters: 	an ObservableValueHolder[ true ]
		lineNumbers: 	an ObservableValueHolder[ true ]
		interactionModel: 	an ObservableValueHolder[ a StPlaygroundInteractionModel ]
		overrideContextMenu: 	true
		submitBlock: 	nil
		resetBlock: 	nil
		environment: 	nil
		systemNavigation: 	nil
		syntaxHighlightTheme: 	an ObservableValueHolder[ nil ]


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
		self announcer announce: (SpCodeWillBeEvaluatedAnnouncement newContent: aString).
[..]
	Arguments and temporary variables: 
		exception: 	Error
		handlerAction: 	[ :e |
		self announcer announce: (SpCodeEvaluationFailedAnn[..]
	Receiver's instance variables: 
		outerContext: 	SpCodePresenter>>evaluate:onCompileError:onError:
		compiledBlock: 	a CompiledBlock: [
		self announcer announce: (SpCodeWillBeE[..]
		numArgs: 	0
		receiver: 	a SpCodePresenter


SpCodePresenter>>evaluate:onCompileError:onError:
	Receiver: a SpCodePresenter
	Arguments and temporary variables: 
		receiver: 	nil
		result: 	nil
		oldBindings: 	a Dictionary()
		aString: 	'(VisualizerMain new createSampleGraph) open.
'
		compileErrorBlock: 	[ ^ self ]
		errorBlock: 	[ :e | e pass ]
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicCodeAdapter)
		announcer: 	an Announcer
		owner: 	a StPlaygroundPagePresenter
		adapter: 	a SpMorphicCodeAdapter
		needRebuild: 	true
		eventHandler: 	a SpEventHandler
		application: 	nil
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ a KMCategory ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Code' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpAbstractWidgetLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		borderWidth: 	an ObservableValueHolder[ nil ]
		borderColor: 	an ObservableValueHolder[ nil ]
		dragEnabled: 	an ObservableValueHolder[ false ]
		dropEnabled: 	an ObservableValueHolder[ false ]
		color: 	an ObservableValueHolder[ nil ]
		help: 	an ObservableValueHolder[ nil ]
		enabled: 	an ObservableValueHolder[ true ]
		wantsDrop: 	an ObservableValueHolder[ [ :transfer | self dropEnabled ] ]
		acceptDrop: 	an ObservableValueHolder[ [ :transfer | ] ]
		deferredActions: 	nil
		hasUnacceptedEdits: 	an ObservableValueHolder[ false ]
		selection: 	an ObservableValueHolder[ (1 to: 45) ]
		wantsVisualFeedback: 	an ObservableValueHolder[ true ]
		askBeforeDiscardingEdits: 	an ObservableValueHolder[ true ]
		text: 	an ObservableValueHolder[ '(VisualizerMain new createSampleGraph) ope[..]
		actionToPerform: 	an ObservableValueHolder[ [ :txt |  ] ]
		readSelection: 	an ObservableValueHolder[ [ selection ] ]
		placeholder: 	an ObservableValueHolder[ '' ]
		contextMenu: 	an ObservableValueHolder[ [ (self menuActionsFor: text) asMenu[..]
		scrollValue: 	an ObservableValueHolder[ (0@0) ]
		editionContextMenu: 	an ObservableValueHolder[ true ]
		editable: 	an ObservableValueHolder[ true ]
		wrapWord: 	an ObservableValueHolder[ true ]
		undoRedoHistory: 	true
		wrapScrollBars: 	true
		propagateNaturalHeight: 	false
		propagateNaturalWidth: 	false
		scrollBarStyles: 	#()
		syntaxHighlight: 	an ObservableValueHolder[ true ]
		smartCharacters: 	an ObservableValueHolder[ true ]
		lineNumbers: 	an ObservableValueHolder[ true ]
		interactionModel: 	an ObservableValueHolder[ a StPlaygroundInteractionModel ]
		overrideContextMenu: 	true
		submitBlock: 	nil
		resetBlock: 	nil
		environment: 	nil
		systemNavigation: 	nil
		syntaxHighlightTheme: 	an ObservableValueHolder[ nil ]


StPlaygroundPagePresenter>>doEvaluateAndGo
	Receiver: a StPlaygroundPagePresenter
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicBoxAdapter)
		announcer: 	an Announcer
		owner: 	a SpMillerColumnPresenter
		adapter: 	a SpMorphicBoxAdapter
		needRebuild: 	true
		eventHandler: 	nil
		application: 	a StPharoApplication
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ nil ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Untitled window' ]
		additionalSubpresentersMap: 	a Dictionary()
		layout: 	an ObservableValueHolder[ a SpBoxLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		text: 	a SpCodePresenter
		toolbar: 	a SpToolbarPresenter
		statusbar: 	a SpPresenter
		lineLabel: 	a SpLabelPresenter
		toggleLineNumberButton: 	a SpToggleButtonPresenter
		page: 	a StPlaygroundPage
		activationBlock: 	[ :selection |
		self changeSelection: selection from: new[..]


StPlaygroundPagePresenter>>doEvaluateAllAndGo
	Receiver: a StPlaygroundPagePresenter
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicBoxAdapter)
		announcer: 	an Announcer
		owner: 	a SpMillerColumnPresenter
		adapter: 	a SpMorphicBoxAdapter
		needRebuild: 	true
		eventHandler: 	nil
		application: 	a StPharoApplication
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ nil ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Untitled window' ]
		additionalSubpresentersMap: 	a Dictionary()
		layout: 	an ObservableValueHolder[ a SpBoxLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		text: 	a SpCodePresenter
		toolbar: 	a SpToolbarPresenter
		statusbar: 	a SpPresenter
		lineLabel: 	a SpLabelPresenter
		toggleLineNumberButton: 	a SpToggleButtonPresenter
		page: 	a StPlaygroundPage
		activationBlock: 	[ :selection |
		self changeSelection: selection from: new[..]


StPlaygroundDoItCommand>>execute
	Receiver: a StPlaygroundDoItCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		context: 	a StPlaygroundPagePresenter
		basicName: 	'Do it'
		basicDescription: 	'Do it all and inspect.'


SpCommand(CmCommandDecorator)>>execute
	Receiver: a SpCommand(Do it)
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a StPlaygroundDoItCommand
		iconProvider: 	a StPharoApplication
		iconName: 	#glamorousGo
		shortcutKey: 	nil
		displayStrategy: 	a CmUIDisableWhenCantBeRun
		positionStrategy: 	a CmUILeftPositionStrategy
		buildPresenterBlock: 	[ :specCommand | 
			aButtonClass new
				label: specC[..]
		presenter: 	a SpToolbarButtonPresenter


[ specCommand execute ] in [ :specCommand | 
			aButtonClass new
				label: specCommand name;
				help: specCommand description;
				in: [ :button | 
					specCommand hasIcon
						ifTrue: [ button icon: specCommand icon ] ];
				action: [ specCommand execute ];
				yourself ] in SpCommand>>configureAsButtonOfClass:
	Receiver: a SpCommand(Do it)
	Arguments and temporary variables: 
		aButtonClass: 	nil
		specCommand: 	a SpCommand(Do it)
	Receiver's instance variables: 
		decoratedCommand: 	a StPlaygroundDoItCommand
		iconProvider: 	a StPharoApplication
		iconName: 	#glamorousGo
		shortcutKey: 	nil
		displayStrategy: 	a CmUIDisableWhenCantBeRun
		positionStrategy: 	a CmUILeftPositionStrategy
		buildPresenterBlock: 	[ :specCommand | 
			aButtonClass new
				label: specC[..]
		presenter: 	a SpToolbarButtonPresenter


FullBlockClosure(BlockClosure)>>cull:
	Receiver: [ specCommand execute ]
	Arguments and temporary variables: 
		anArg: 	a SpToolbarButtonPresenter
	Receiver's instance variables: 
		outerContext: 	[ :specCommand | 
			aButtonClass new
				label: specCommand [..]
		compiledBlock: 	a CompiledBlock: [ specCommand execute ]
		numArgs: 	0
		receiver: 	a SpCommand(Do it)


SpMorphicToolbarButtonAdapter>>execute
	Receiver: a SpMorphicToolbarButtonAdapter
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpToolbarButtonMorph(449631488))
		announcer: 	nil
		model: 	a SpToolbarButtonPresenter
		widget: 	a SpToolbarButtonMorph(449631488)
		selector: 	nil
		owner: 	a SpToolbarButtonPresenter
		unsubscribed: 	false


SpToolbarButtonMorph(PluggableButtonMorph)>>performAction:
	Receiver: a SpToolbarButtonMorph(449631488)
	Arguments and temporary variables: 
		event: 	[(20.0@30.0) mouseUp 73495 nil]
	Receiver's instance variables: 
		bounds: 	(0.0@5.0) corner: (45.0@39.0)
		owner: 	a Morph(1035472128)
		submorphs: 	an Array(an AlignmentMorph(149947904))
		fullBounds: 	nil
		color: 	(Color r: 0.9012707722385142 g: 0.9012707722385142 b: 0.901270772238[..]
		extension: 	a MorphExtension (703115520) [balloonText]  [other:  (presenter [..]
		borderWidth: 	0
		borderColor: 	#simple
		model: 	a SpMorphicToolbarButtonAdapter
		label: 	'Do it'
		icon: 	Form(13x13x32)
		getIconSelector: 	#icon
		getStateSelector: 	#state
		actionSelector: 	#execute
		font: 	a LogicalFont
 familyName: 'Source Sans Pro'
 emphasis: nil
 pointSiz[..]
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	nil
		getFontSelector: 	nil
		labelMorph: 	a LabelMorph(104243968)'Do it'
		iconMorph: 	an ImageMorph(734040320)
		iconPosition: 	#top
		lastState: 	false
		badgeFont: 	nil
		badgeSelector: 	#badge


[:m |
		(m containsPoint: evt cursorPoint) ifTrue: [m enabled ifTrue: [ m performAction: evt ]]] in SpToolbarButtonMorph(PluggableButtonMorph)>>mouseUp:
	Receiver: a SpToolbarButtonMorph(449631488)
	Arguments and temporary variables: 
		evt: 	[(20.0@30.0) mouseUp 73495 nil]
		all: 	an Array(a SpToolbarButtonMorph(449631488) a SpToolbarButtonMorph(7977[..]
		m: 	a SpToolbarButtonMorph(449631488)
	Receiver's instance variables: 
		bounds: 	(0.0@5.0) corner: (45.0@39.0)
		owner: 	a Morph(1035472128)
		submorphs: 	an Array(an AlignmentMorph(149947904))
		fullBounds: 	nil
		color: 	(Color r: 0.9012707722385142 g: 0.9012707722385142 b: 0.901270772238[..]
		extension: 	a MorphExtension (703115520) [balloonText]  [other:  (presenter [..]
		borderWidth: 	0
		borderColor: 	#simple
		model: 	a SpMorphicToolbarButtonAdapter
		label: 	'Do it'
		icon: 	Form(13x13x32)
		getIconSelector: 	#icon
		getStateSelector: 	#state
		actionSelector: 	#execute
		font: 	a LogicalFont
 familyName: 'Source Sans Pro'
 emphasis: nil
 pointSiz[..]
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	nil
		getFontSelector: 	nil
		labelMorph: 	a LabelMorph(104243968)'Do it'
		iconMorph: 	an ImageMorph(734040320)
		iconPosition: 	#top
		lastState: 	false
		badgeFont: 	nil
		badgeSelector: 	#badge


Array(SequenceableCollection)>>do:
	Receiver: an Array(a SpToolbarButtonMorph(449631488) a SpToolbarButtonMorph(797724672) a SpToolb[..]
	Arguments and temporary variables: 
		aBlock: 	[:m |
		(m containsPoint: evt cursorPoint) ifTrue: [m enabled ifTru[..]
		index: 	1
	Receiver's instance variables: 
an Array(a SpToolbarButtonMorph(449631488) a SpToolbarButtonMorph(797724672) a SpToolb[..]

SpToolbarButtonMorph(PluggableButtonMorph)>>mouseUp:
	Receiver: a SpToolbarButtonMorph(449631488)
	Arguments and temporary variables: 
		evt: 	[(20.0@30.0) mouseUp 73495 nil]
		all: 	an Array(a SpToolbarButtonMorph(449631488) a SpToolbarButtonMorph(7977[..]
	Receiver's instance variables: 
		bounds: 	(0.0@5.0) corner: (45.0@39.0)
		owner: 	a Morph(1035472128)
		submorphs: 	an Array(an AlignmentMorph(149947904))
		fullBounds: 	nil
		color: 	(Color r: 0.9012707722385142 g: 0.9012707722385142 b: 0.901270772238[..]
		extension: 	a MorphExtension (703115520) [balloonText]  [other:  (presenter [..]
		borderWidth: 	0
		borderColor: 	#simple
		model: 	a SpMorphicToolbarButtonAdapter
		label: 	'Do it'
		icon: 	Form(13x13x32)
		getIconSelector: 	#icon
		getStateSelector: 	#state
		actionSelector: 	#execute
		font: 	a LogicalFont
 familyName: 'Source Sans Pro'
 emphasis: nil
 pointSiz[..]
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	nil
		getFontSelector: 	nil
		labelMorph: 	a LabelMorph(104243968)'Do it'
		iconMorph: 	an ImageMorph(734040320)
		iconPosition: 	#top
		lastState: 	false
		badgeFont: 	nil
		badgeSelector: 	#badge


SpToolbarButtonMorph(Morph)>>handleMouseUp:
	Receiver: a SpToolbarButtonMorph(449631488)
	Arguments and temporary variables: 
		anEvent: 	[(20.0@30.0) mouseUp 73495 nil]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(0.0@5.0) corner: (45.0@39.0)
		owner: 	a Morph(1035472128)
		submorphs: 	an Array(an AlignmentMorph(149947904))
		fullBounds: 	nil
		color: 	(Color r: 0.9012707722385142 g: 0.9012707722385142 b: 0.901270772238[..]
		extension: 	a MorphExtension (703115520) [balloonText]  [other:  (presenter [..]
		borderWidth: 	0
		borderColor: 	#simple
		model: 	a SpMorphicToolbarButtonAdapter
		label: 	'Do it'
		icon: 	Form(13x13x32)
		getIconSelector: 	#icon
		getStateSelector: 	#state
		actionSelector: 	#execute
		font: 	a LogicalFont
 familyName: 'Source Sans Pro'
 emphasis: nil
 pointSiz[..]
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	nil
		getFontSelector: 	nil
		labelMorph: 	a LabelMorph(104243968)'Do it'
		iconMorph: 	an ImageMorph(734040320)
		iconPosition: 	#top
		lastState: 	false
		badgeFont: 	nil
		badgeSelector: 	#badge


MouseButtonEvent>>sentTo:
	Receiver: [(20.0@30.0) mouseUp 73495 nil]
	Arguments and temporary variables: 
		anObject: 	a SpToolbarButtonMorph(449631488)
	Receiver's instance variables: 
		timeStamp: 	73495
		source: 	a HandMorph(337424384)
		windowIndex: 	nil
		type: 	#mouseUp
		buttons: 	0
		position: 	(20.0@30.0)
		handler: 	nil
		wasHandled: 	true
		whichButton: 	4


SpToolbarButtonMorph(Morph)>>handleEvent:
	Receiver: a SpToolbarButtonMorph(449631488)
	Arguments and temporary variables: 
		anEvent: 	[(20.0@30.0) mouseUp 73495 nil]
	Receiver's instance variables: 
		bounds: 	(0.0@5.0) corner: (45.0@39.0)
		owner: 	a Morph(1035472128)
		submorphs: 	an Array(an AlignmentMorph(149947904))
		fullBounds: 	nil
		color: 	(Color r: 0.9012707722385142 g: 0.9012707722385142 b: 0.901270772238[..]
		extension: 	a MorphExtension (703115520) [balloonText]  [other:  (presenter [..]
		borderWidth: 	0
		borderColor: 	#simple
		model: 	a SpMorphicToolbarButtonAdapter
		label: 	'Do it'
		icon: 	Form(13x13x32)
		getIconSelector: 	#icon
		getStateSelector: 	#state
		actionSelector: 	#execute
		font: 	a LogicalFont
 familyName: 'Source Sans Pro'
 emphasis: nil
 pointSiz[..]
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	nil
		getFontSelector: 	nil
		labelMorph: 	a LabelMorph(104243968)'Do it'
		iconMorph: 	an ImageMorph(734040320)
		iconPosition: 	#top
		lastState: 	false
		badgeFont: 	nil
		badgeSelector: 	#badge


SpToolbarButtonMorph(Morph)>>handleFocusEvent:
	Receiver: a SpToolbarButtonMorph(449631488)
	Arguments and temporary variables: 
		anEvent: 	[(20.0@30.0) mouseUp 73495 nil]
	Receiver's instance variables: 
		bounds: 	(0.0@5.0) corner: (45.0@39.0)
		owner: 	a Morph(1035472128)
		submorphs: 	an Array(an AlignmentMorph(149947904))
		fullBounds: 	nil
		color: 	(Color r: 0.9012707722385142 g: 0.9012707722385142 b: 0.901270772238[..]
		extension: 	a MorphExtension (703115520) [balloonText]  [other:  (presenter [..]
		borderWidth: 	0
		borderColor: 	#simple
		model: 	a SpMorphicToolbarButtonAdapter
		label: 	'Do it'
		icon: 	Form(13x13x32)
		getIconSelector: 	#icon
		getStateSelector: 	#state
		actionSelector: 	#execute
		font: 	a LogicalFont
 familyName: 'Source Sans Pro'
 emphasis: nil
 pointSiz[..]
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	nil
		getFontSelector: 	nil
		labelMorph: 	a LabelMorph(104243968)'Do it'
		iconMorph: 	an ImageMorph(734040320)
		iconPosition: 	#top
		lastState: 	false
		badgeFont: 	nil
		badgeSelector: 	#badge


[
		result := focusHolder handleFocusEvent: transformedEvent.
	] in HandMorph>>sendFocusEvent:to:clear:
	Receiver: a HandMorph(337424384)
	Arguments and temporary variables: 
		anEvent: 	[(539@333) mouseUp 73495 nil]
		focusHolder: 	a SpToolbarButtonMorph(449631488)
		aBlock: 	[self mouseFocus: nil]
		w: 	a WorldMorph(341720576) [world]
		transformedEvent: 	[(20.0@30.0) mouseUp 73495 nil]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(539@333.0) corner: (555@349.0)
		owner: 	a WorldMorph(341720576) [world]
		submorphs: 	#()
		fullBounds: 	(539@333.0) corner: (555@349.0)
		color: 	Color blue
		extension: 	a MorphExtension (370611968)
		mouseFocus: 	nil
		keyboardFocus: 	a RubEditingArea(80907264)
		eventListeners: 	nil
		mouseListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(539@333) mouseUp 73495 nil]
		targetOffset: 	(20.0@25.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 0 0 0 0 0 nil nil)
		captureBlock: 	nil
		recentModifiers: 	0
		pendingEventQueue: 	WaitfreeQueue with 0 items
		supressNextKeyPress: 	false


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
		result := focusHolder handleFocusEvent: transformedEvent.
	]
	Arguments and temporary variables: 
		exception: 	Error
		handlerAction: 	[ :ex |
			ActiveWorld := priorWorld.
			ex pass ]
	Receiver's instance variables: 
		outerContext: 	HandMorph>>sendFocusEvent:to:clear:
		compiledBlock: 	a CompiledBlock: [
		result := focusHolder handleFocusEvent:[..]
		numArgs: 	0
		receiver: 	a HandMorph(337424384)


WorldMorph>>becomeActiveDuring:
	Receiver: a WorldMorph(341720576) [world]
	Arguments and temporary variables: 
		aBlock: 	[
		result := focusHolder handleFocusEvent: transformedEvent.
	]
		priorWorld: 	a WorldMorph(341720576) [world]
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1728@1051)
		owner: 	nil
		submorphs: 	an Array(a MenubarMorph(112886016) a TaskbarMorph(279458560) a S[..]
		fullBounds: 	(0@0) corner: (1728@1051)
		color: 	(Color r: 0.9403714565004888 g: 0.9403714565004888 b: 0.940371456500[..]
		extension: 	a MorphExtension (1012946432) [other:  (dragEnabled -> true) (dr[..]
		borderWidth: 	0
		borderColor: 	(Color r: 0.8611925708699902 g: 1.0 b: 0.7223851417399805 alph[..]
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil


HandMorph>>sendFocusEvent:to:clear:
	Receiver: a HandMorph(337424384)
	Arguments and temporary variables: 
		result: 	nil
		anEvent: 	[(539@333) mouseUp 73495 nil]
		focusHolder: 	a SpToolbarButtonMorph(449631488)
		aBlock: 	[self mouseFocus: nil]
		w: 	a WorldMorph(341720576) [world]
		transformedEvent: 	[(20.0@30.0) mouseUp 73495 nil]
	Receiver's instance variables: 
		bounds: 	(539@333.0) corner: (555@349.0)
		owner: 	a WorldMorph(341720576) [world]
		submorphs: 	#()
		fullBounds: 	(539@333.0) corner: (555@349.0)
		color: 	Color blue
		extension: 	a MorphExtension (370611968)
		mouseFocus: 	nil
		keyboardFocus: 	a RubEditingArea(80907264)
		eventListeners: 	nil
		mouseListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(539@333) mouseUp 73495 nil]
		targetOffset: 	(20.0@25.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 0 0 0 0 0 nil nil)
		captureBlock: 	nil
		recentModifiers: 	0
		pendingEventQueue: 	WaitfreeQueue with 0 items
		supressNextKeyPress: 	false


HandMorph>>sendEvent:focus:clear:
	Receiver: a HandMorph(337424384)
	Arguments and temporary variables: 
		anEvent: 	[(539@333) mouseUp 73495 nil]
		focusHolder: 	a SpToolbarButtonMorph(449631488)
		aBlock: 	[self mouseFocus: nil]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(539@333.0) corner: (555@349.0)
		owner: 	a WorldMorph(341720576) [world]
		submorphs: 	#()
		fullBounds: 	(539@333.0) corner: (555@349.0)
		color: 	Color blue
		extension: 	a MorphExtension (370611968)
		mouseFocus: 	nil
		keyboardFocus: 	a RubEditingArea(80907264)
		eventListeners: 	nil
		mouseListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(539@333) mouseUp 73495 nil]
		targetOffset: 	(20.0@25.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 0 0 0 0 0 nil nil)
		captureBlock: 	nil
		recentModifiers: 	0
		pendingEventQueue: 	WaitfreeQueue with 0 items
		supressNextKeyPress: 	false


HandMorph>>sendMouseEvent:
	Receiver: a HandMorph(337424384)
	Arguments and temporary variables: 
		anEvent: 	[(539@333) mouseUp 73495 nil]
	Receiver's instance variables: 
		bounds: 	(539@333.0) corner: (555@349.0)
		owner: 	a WorldMorph(341720576) [world]
		submorphs: 	#()
		fullBounds: 	(539@333.0) corner: (555@349.0)
		color: 	Color blue
		extension: 	a MorphExtension (370611968)
		mouseFocus: 	nil
		keyboardFocus: 	a RubEditingArea(80907264)
		eventListeners: 	nil
		mouseListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(539@333) mouseUp 73495 nil]
		targetOffset: 	(20.0@25.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 0 0 0 0 0 nil nil)
		captureBlock: 	nil
		recentModifiers: 	0
		pendingEventQueue: 	WaitfreeQueue with 0 items
		supressNextKeyPress: 	false


HandMorph>>handleEvent:
	Receiver: a HandMorph(337424384)
	Arguments and temporary variables: 
		anEvent: 	[(539@333) mouseUp 73495 nil]
		evt: 	[(539@333) mouseUp 73495 nil]
	Receiver's instance variables: 
		bounds: 	(539@333.0) corner: (555@349.0)
		owner: 	a WorldMorph(341720576) [world]
		submorphs: 	#()
		fullBounds: 	(539@333.0) corner: (555@349.0)
		color: 	Color blue
		extension: 	a MorphExtension (370611968)
		mouseFocus: 	nil
		keyboardFocus: 	a RubEditingArea(80907264)
		eventListeners: 	nil
		mouseListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(539@333) mouseUp 73495 nil]
		targetOffset: 	(20.0@25.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 0 0 0 0 0 nil nil)
		captureBlock: 	nil
		recentModifiers: 	0
		pendingEventQueue: 	WaitfreeQueue with 0 items
		supressNextKeyPress: 	false


[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil ]) ifTrue: [
			morphicWorld activeHand handleEvent: anEvent
		]
	] in OSWindowMorphicEventHandler>>dispatchMorphicEvent:
	Receiver: an OSWindowMorphicEventHandler
	Arguments and temporary variables: 
		anEvent: 	[(539@333) mouseUp 73495 nil]
	Receiver's instance variables: 
		morphicWorld: 	a WorldMorph(341720576) [world]


WorldState>>runStepMethodsIn:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(341720576) [world]
		queue: 	WaitfreeQueue with 0 items
		nextInQueue: 	[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNo[..]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(337424384))
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap()
		lastStepTime: 	53956
		lastStepMessage: 	nil
		alarms: 	a Heap(MorphicAlarm(#hideShow -> a RubCursor(618416640)))
		lastAlarmTime: 	73483
		activeHand: 	a HandMorph(337424384)
		currentCursor: 	((CursorWithMask
	extent: (16@16)
	depth: 1
	fromArray: #(
	[..]
		worldRenderer: 	an OSWorldRenderer
		realWindowExtent: 	(1728@1051)
		deferredUIMessages: 	WaitfreeQueue with 0 items


WorldMorph>>runStepMethods
	Receiver: a WorldMorph(341720576) [world]
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1728@1051)
		owner: 	nil
		submorphs: 	an Array(a MenubarMorph(112886016) a TaskbarMorph(279458560) a S[..]
		fullBounds: 	(0@0) corner: (1728@1051)
		color: 	(Color r: 0.9403714565004888 g: 0.9403714565004888 b: 0.940371456500[..]
		extension: 	a MorphExtension (1012946432) [other:  (dragEnabled -> true) (dr[..]
		borderWidth: 	0
		borderColor: 	(Color r: 0.8611925708699902 g: 1.0 b: 0.7223851417399805 alph[..]
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil


WorldState>>doOneCycleFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(341720576) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(337424384))
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap()
		lastStepTime: 	53956
		lastStepMessage: 	nil
		alarms: 	a Heap(MorphicAlarm(#hideShow -> a RubCursor(618416640)))
		lastAlarmTime: 	73483
		activeHand: 	a HandMorph(337424384)
		currentCursor: 	((CursorWithMask
	extent: (16@16)
	depth: 1
	fromArray: #(
	[..]
		worldRenderer: 	an OSWorldRenderer
		realWindowExtent: 	(1728@1051)
		deferredUIMessages: 	WaitfreeQueue with 0 items


WorldMorph>>doOneCycleNow
	Receiver: a WorldMorph(341720576) [world]
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1728@1051)
		owner: 	nil
		submorphs: 	an Array(a MenubarMorph(112886016) a TaskbarMorph(279458560) a S[..]
		fullBounds: 	(0@0) corner: (1728@1051)
		color: 	(Color r: 0.9403714565004888 g: 0.9403714565004888 b: 0.940371456500[..]
		extension: 	a MorphExtension (1012946432) [other:  (dragEnabled -> true) (dr[..]
		borderWidth: 	0
		borderColor: 	(Color r: 0.8611925708699902 g: 1.0 b: 0.7223851417399805 alph[..]
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil


WorldMorph>>doOneCycle
	Receiver: a WorldMorph(341720576) [world]
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1728@1051)
		owner: 	nil
		submorphs: 	an Array(a MenubarMorph(112886016) a TaskbarMorph(279458560) a S[..]
		fullBounds: 	(0@0) corner: (1728@1051)
		color: 	(Color r: 0.9403714565004888 g: 0.9403714565004888 b: 0.940371456500[..]
		extension: 	a MorphExtension (1012946432) [other:  (dragEnabled -> true) (dr[..]
		borderWidth: 	0
		borderColor: 	(Color r: 0.8611925708699902 g: 1.0 b: 0.7223851417399805 alph[..]
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil


[
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMutex critical: [
			                     self extraWorldList ].
		extraWorldsToDraw do: [ :world | world doOneCycle ].

		(self currentWorld isNotNil and: [
			 (extraWorldsToDraw includes: self currentWorld) not ]) ifTrue: [
			self currentWorld doOneCycle ] ] in WorldMorph class>>doOneCycle
	Receiver: WorldMorph
	Arguments and temporary variables: 
		extraWorldsToDraw: 	#()
	Receiver's instance variables: 
		superclass: 	PasteUpMorph
		methodDict: 	a MethodDictionary(#acceptDroppingMorph:event:->WorldMorph>>#ac[..]
		format: 	65547
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		commentSourcePointer: 	nil
		subclasses: 	{AthensWorldMorph. OSWindowWorldMorph}
		name: 	#WorldMorph
		classPool: 	a Dictionary(#AllowDropFiles->nil #CursorOwnerWorld->a WorldMorp[..]
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Morphic-Core-Worlds'
		announcer: 	nil
		displayScaleFactor: 	1


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMutex critical: [
			  [..]
	Arguments and temporary variables: 
		aBlock: 	[
		self doInterCycleWait
	]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	WorldMorph class>>doOneCycle
		compiledBlock: 	a CompiledBlock: [
		| extraWorldsToDraw |
		extraWorldsToDr[..]
		numArgs: 	0
		receiver: 	WorldMorph


WorldState class>>doDrawCycleWith:
	Receiver: WorldState
	Arguments and temporary variables: 
		aBlock: 	[
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMute[..]
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary(#activeHand->WorldState>>#activeHand #active[..]
		format: 	65548
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		commentSourcePointer: 	nil
		subclasses: 	{AthensWorldState}
		name: 	#WorldState
		classPool: 	a Dictionary(#CanSurrenderToOS->nil #DebugShowDamage->false #Des[..]
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Morphic-Core-Worlds'



--- The full stack ---
RSBox(Object)>>doesNotUnderstand: #label:
VisualizerMain>>createSampleGraph
UndefinedObject>>DoIt
OCReceiverDoItSemanticScope(OCDoItSemanticScope)>>evaluateDoIt:
OpalCompiler>>evaluate
[
		self announcer announce: (SpCodeWillBeEvaluatedAnnouncement newContent: aString).
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionModel doItReceiver.
		result := receiver class compiler
			source: aString;
			context: self interactionModel doItContext;
			receiver: self interactionModel doItReceiver;
			requestor: self interactionModel;
			environment: self environment;
			failBlock:  [ 
				self announcer announce: (SpCodeEvaluationFailedAnnouncement newContent: aString).
				^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		self announcer announce: (SpCodeEvaluationSucceedAnnouncement newContent: aString).
		result ] in SpCodePresenter>>evaluate:onCompileError:onError:
FullBlockClosure(BlockClosure)>>on:do:
SpCodePresenter>>evaluate:onCompileError:onError:
StPlaygroundPagePresenter>>doEvaluateAndGo
StPlaygroundPagePresenter>>doEvaluateAllAndGo
StPlaygroundDoItCommand>>execute
SpCommand(CmCommandDecorator)>>execute
[ specCommand execute ] in [ :specCommand | 
			aButtonClass new
				label: specCommand name;
				help: specCommand description;
				in: [ :button | 
					specCommand hasIcon
						ifTrue: [ button icon: specCommand icon ] ];
				action: [ specCommand execute ];
				yourself ] in SpCommand>>configureAsButtonOfClass:
FullBlockClosure(BlockClosure)>>cull:
SpMorphicToolbarButtonAdapter>>execute
SpToolbarButtonMorph(PluggableButtonMorph)>>performAction:
[:m |
		(m containsPoint: evt cursorPoint) ifTrue: [m enabled ifTrue: [ m performAction: evt ]]] in SpToolbarButtonMorph(PluggableButtonMorph)>>mouseUp:
Array(SequenceableCollection)>>do:
SpToolbarButtonMorph(PluggableButtonMorph)>>mouseUp:
SpToolbarButtonMorph(Morph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
SpToolbarButtonMorph(Morph)>>handleEvent:
SpToolbarButtonMorph(Morph)>>handleFocusEvent:
[
		result := focusHolder handleFocusEvent: transformedEvent.
	] in HandMorph>>sendFocusEvent:to:clear:
FullBlockClosure(BlockClosure)>>on:do:
WorldMorph>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil ]) ifTrue: [
			morphicWorld activeHand handleEvent: anEvent
		]
	] in OSWindowMorphicEventHandler>>dispatchMorphicEvent:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycleNow
WorldMorph>>doOneCycle
[
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMutex critical: [
			                     self extraWorldList ].
		extraWorldsToDraw do: [ :world | world doOneCycle ].

		(self currentWorld isNotNil and: [
			 (extraWorldsToDraw includes: self currentWorld) not ]) ifTrue: [
			self currentWorld doOneCycle ] ] in WorldMorph class>>doOneCycle
FullBlockClosure(BlockClosure)>>ensure:
WorldState class>>doDrawCycleWith:
 - - - - - - - - - - - - - - -
			- - - - - - - - - - - - - - - - - -
WorldMorph class>>doOneCycle
MorphicRenderLoop>>doOneCycle
MorphicRenderLoop>>doOneCycleWhile:
[ MorphicRenderLoop new doOneCycleWhile: [ true ] ] in MorphicUIManager>>spawnNewProcess
[self value.
			"IMPORTANT: Do not step over next line of code. See method comments for details"
			Processor terminateRealActive] in FullBlockClosure(BlockClosure)>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
AssertionFailure: Project location does not seems to be a valid git repository.
13 November 2023 5:24:51.992528 pm

VM: Mac OS - arm64 - 1000 - CoInterpreter VMMaker-tonel.1 uuid: 902dd483-c0c4-0d00-86f2-0f880df24b96 Oct 23 2023
StackToRegisterMappingCogit VMMaker-tonel.1 uuid: 902dd483-c0c4-0d00-86f2-0f880df24b96 Oct 23 2023
v10.0.8 - Commit: b323c5fb - Date: 2023-10-20 16:02:07 -0400

Image: Pharo11.0.0 [Build information: Pharo-11.0.0+build.710.sha.ea28d8552cac85a7ce1e9c34ab1e7bd45f7b9910 (64 Bit)]

IceTipLocalRepositoryPanel(Object)>>assert:description:
	Receiver: an IceTipLocalRepositoryPanel
	Arguments and temporary variables: 
		aBlock: 	false
		aStringOrBlock: 	'Project location does not seems to be a valid git repository.'
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicGridAdapter)
		announcer: 	an Announcer
		owner: 	a SpDialogWindowPresenter
		adapter: 	a SpMorphicGridAdapter
		needRebuild: 	true
		eventHandler: 	nil
		application: 	a StPharoApplication
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ nil ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Untitled window' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpGridLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		decorations: 	nil
		projectLocationLabel: 	a SpLabelPresenter
		projectLocation: 	an IceTipDirectoryPresenter
		remoteLabel: 	nil
		remoteInputText: 	nil
		repository: 	nil


IceTipLocalRepositoryPanel>>validate
	Receiver: an IceTipLocalRepositoryPanel
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicGridAdapter)
		announcer: 	an Announcer
		owner: 	a SpDialogWindowPresenter
		adapter: 	a SpMorphicGridAdapter
		needRebuild: 	true
		eventHandler: 	nil
		application: 	a StPharoApplication
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ nil ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Untitled window' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpGridLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		decorations: 	nil
		projectLocationLabel: 	a SpLabelPresenter
		projectLocation: 	an IceTipDirectoryPresenter
		remoteLabel: 	nil
		remoteInputText: 	nil
		repository: 	nil


[ 
			dialog validate.
			self repositoryModel updateLocation: dialog location.
			true ] in IceTipRepairLocateRepository>>basicExecute
	Receiver: an IceTipRepairLocateRepository
	Arguments and temporary variables: 
		dialog: 	an IceTipLocalRepositoryPanel
	Receiver's instance variables: 
		context: 	an IceTipRepairRepositoryDialog
		repository: 	nil
		successBlock: 	nil
		repositoryModel: 	an IceTipCachedModel(an IceTipRepositoryModel)


FullBlockClosure(BlockClosure)>>cull:
	Receiver: [ 
			dialog validate.
			self repositoryModel updateLocation: dialog location.
			true ]
	Arguments and temporary variables: 
		anArg: 	a SpDialogWindowPresenter
	Receiver's instance variables: 
		outerContext: 	IceTipRepairLocateRepository>>basicExecute
		compiledBlock: 	a CompiledBlock: [ 
			dialog validate.
			self repositoryMo[..]
		numArgs: 	0
		receiver: 	an IceTipRepairLocateRepository


SpDialogWindowPresenter>>triggerOkAction
	Receiver: a SpDialogWindowPresenter
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicDialogWindowAdapter a SpDialogWind[..]
		announcer: 	an Announcer
		owner: 	nil
		adapter: 	a SpMorphicDialogWindowAdapter
		needRebuild: 	true
		eventHandler: 	nil
		application: 	a StPharoApplication
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ nil ]
		windowIcon: 	an ObservableValueHolder[ Form(16x16x32) ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ true ]
		titleHolder: 	an ObservableValueHolder[ 'Import from existing clone' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ nil ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		borderWidth: 	an ObservableValueHolder[ nil ]
		borderColor: 	an ObservableValueHolder[ nil ]
		dragEnabled: 	an ObservableValueHolder[ false ]
		dropEnabled: 	an ObservableValueHolder[ false ]
		color: 	an ObservableValueHolder[ nil ]
		help: 	an ObservableValueHolder[ nil ]
		enabled: 	an ObservableValueHolder[ true ]
		wantsDrop: 	an ObservableValueHolder[ [ :transfer | self dropEnabled ] ]
		acceptDrop: 	an ObservableValueHolder[ [ :transfer | ] ]
		deferredActions: 	nil
		presenter: 	an ObservableValueHolder[ an IceTipLocalRepositoryPanel ]
		initialPosition: 	an ObservableValueHolder[ nil ]
		initialExtent: 	an ObservableValueHolder[ (500@137) ]
		menu: 	an ObservableValueHolder[ nil ]
		centered: 	an ObservableValueHolder[ false ]
		isClosed: 	an ObservableValueHolder[ false ]
		toolbar: 	an ObservableValueHolder[ nil ]
		statusbar: 	an ObservableValueHolder[ nil ]
		window: 	an ObservableValueHolder[ a SpDialogWindowMorph(272541184) named: I[..]
		decorations: 	an ObservableValueHolder[ true ]
		resizable: 	an ObservableValueHolder[ true ]
		buttons: 	an OrderedCollection(a SpButtonPresenter a SpButtonPresenter)
		okAction: 	[ 
			dialog validate.
			self repositoryModel updateLocation: di[..]
		cancelAction: 	[ 
		cancelled := true.
		self close ]
		cancelled: 	true
		defaultButton: 	nil


[ :presenter | 
			presenter triggerOkAction.
			presenter close ] in IceTipLocalRepositoryPanel(SpAbstractPresenter)>>initializeDialogWindow:
	Receiver: an IceTipLocalRepositoryPanel
	Arguments and temporary variables: 
		aDialogWindowPresenter: 	a SpDialogWindowPresenter
		presenter: 	a SpDialogWindowPresenter
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicGridAdapter)
		announcer: 	an Announcer
		owner: 	a SpDialogWindowPresenter
		adapter: 	a SpMorphicGridAdapter
		needRebuild: 	true
		eventHandler: 	nil
		application: 	a StPharoApplication
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ nil ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Untitled window' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpGridLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		decorations: 	nil
		projectLocationLabel: 	a SpLabelPresenter
		projectLocation: 	an IceTipDirectoryPresenter
		remoteLabel: 	nil
		remoteInputText: 	nil
		repository: 	nil


FullBlockClosure(BlockClosure)>>cull:
	Receiver: [ :presenter | 
			presenter triggerOkAction.
			presenter close ]
	Arguments and temporary variables: 
		anArg: 	a SpDialogWindowPresenter
	Receiver's instance variables: 
		outerContext: 	IceTipLocalRepositoryPanel(SpAbstractPresenter)>>initializeDi[..]
		compiledBlock: 	a CompiledBlock: [ :presenter | 
			presenter triggerOkActio[..]
		numArgs: 	1
		receiver: 	an IceTipLocalRepositoryPanel


[ aBlock cull: self ] in SpDialogWindowPresenter>>addButton:do:
	Receiver: a SpDialogWindowPresenter
	Arguments and temporary variables: 
		aString: 	'Ok'
		aBlock: 	[ :presenter | 
			presenter triggerOkAction.
			presenter close ]
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicDialogWindowAdapter a SpDialogWind[..]
		announcer: 	an Announcer
		owner: 	nil
		adapter: 	a SpMorphicDialogWindowAdapter
		needRebuild: 	true
		eventHandler: 	nil
		application: 	a StPharoApplication
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ nil ]
		windowIcon: 	an ObservableValueHolder[ Form(16x16x32) ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ true ]
		titleHolder: 	an ObservableValueHolder[ 'Import from existing clone' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ nil ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		borderWidth: 	an ObservableValueHolder[ nil ]
		borderColor: 	an ObservableValueHolder[ nil ]
		dragEnabled: 	an ObservableValueHolder[ false ]
		dropEnabled: 	an ObservableValueHolder[ false ]
		color: 	an ObservableValueHolder[ nil ]
		help: 	an ObservableValueHolder[ nil ]
		enabled: 	an ObservableValueHolder[ true ]
		wantsDrop: 	an ObservableValueHolder[ [ :transfer | self dropEnabled ] ]
		acceptDrop: 	an ObservableValueHolder[ [ :transfer | ] ]
		deferredActions: 	nil
		presenter: 	an ObservableValueHolder[ an IceTipLocalRepositoryPanel ]
		initialPosition: 	an ObservableValueHolder[ nil ]
		initialExtent: 	an ObservableValueHolder[ (500@137) ]
		menu: 	an ObservableValueHolder[ nil ]
		centered: 	an ObservableValueHolder[ false ]
		isClosed: 	an ObservableValueHolder[ false ]
		toolbar: 	an ObservableValueHolder[ nil ]
		statusbar: 	an ObservableValueHolder[ nil ]
		window: 	an ObservableValueHolder[ a SpDialogWindowMorph(272541184) named: I[..]
		decorations: 	an ObservableValueHolder[ true ]
		resizable: 	an ObservableValueHolder[ true ]
		buttons: 	an OrderedCollection(a SpButtonPresenter a SpButtonPresenter)
		okAction: 	[ 
			dialog validate.
			self repositoryModel updateLocation: di[..]
		cancelAction: 	[ 
		cancelled := true.
		self close ]
		cancelled: 	true
		defaultButton: 	nil


SpButtonPresenter>>performAction
	Receiver: a SpButtonPresenter
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicButtonAdapter)
		announcer: 	an Announcer
		owner: 	a SpButtonBarPresenter
		adapter: 	a SpMorphicButtonAdapter
		needRebuild: 	true
		eventHandler: 	nil
		application: 	nil
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ nil ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Button' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpAbstractWidgetLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		borderWidth: 	an ObservableValueHolder[ nil ]
		borderColor: 	an ObservableValueHolder[ nil ]
		dragEnabled: 	an ObservableValueHolder[ false ]
		dropEnabled: 	an ObservableValueHolder[ false ]
		color: 	an ObservableValueHolder[ nil ]
		help: 	an ObservableValueHolder[ nil ]
		enabled: 	an ObservableValueHolder[ true ]
		wantsDrop: 	an ObservableValueHolder[ [ :transfer | self dropEnabled ] ]
		acceptDrop: 	an ObservableValueHolder[ [ :transfer | ] ]
		deferredActions: 	nil
		icon: 	an ObservableValueHolder[ nil ]
		label: 	an ObservableValueHolder[ 'Ok' ]
		action: 	an ObservableValueHolder[ [ aBlock cull: self ] ]
		actionPerformed: 	an ObservableValueHolder[ nil ]
		askBeforeChanging: 	an ObservableValueHolder[ false ]
		font: 	an ObservableValueHolder[ nil ]
		shortcut: 	an ObservableValueHolder[ nil ]
		state: 	an ObservableValueHolder[ false ]
		contextMenu: 	an ObservableValueHolder[ nil ]


SpMorphicButtonAdapter>>action
	Receiver: a SpMorphicButtonAdapter
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpPluggableButtonMorph(190880000))
		announcer: 	nil
		model: 	a SpButtonPresenter
		widget: 	a SpPluggableButtonMorph(190880000)
		selector: 	nil
		owner: 	a SpButtonPresenter
		unsubscribed: 	false
		subMenuWidget: 	nil
		styleName: 	nil


SpPluggableButtonMorph(PluggableButtonMorph)>>performAction:
	Receiver: a SpPluggableButtonMorph(190880000)
	Arguments and temporary variables: 
		event: 	[(1205@510) mouseUp 4810089 nil]
	Receiver's instance variables: 
		bounds: 	(1138.0@503.0) corner: (1238.0@533.0)
		owner: 	a PanelMorph(996435712)
		submorphs: 	an Array(an AlignmentMorph(603547904))
		fullBounds: 	nil
		color: 	(Color r: 0.9012707722385142 g: 0.9012707722385142 b: 0.901270772238[..]
		extension: 	a MorphExtension (702656000) [eventHandler = a MorphicEventHandl[..]
		borderWidth: 	1
		borderColor: 	#simple
		model: 	a SpMorphicButtonAdapter
		label: 	'Ok'
		icon: 	nil
		getIconSelector: 	nil
		getStateSelector: 	#state
		actionSelector: 	#action
		font: 	nil
		getLabelSelector: 	#label
		getMenuSelector: 	#menu:
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	#enabled
		getFontSelector: 	#font
		labelMorph: 	a LabelMorph(527080448)'Ok'
		iconMorph: 	nil
		iconPosition: 	#left
		lastState: 	false
		backgroundColor: 	nil


[:m |
		(m containsPoint: evt cursorPoint) ifTrue: [m enabled ifTrue: [ m performAction: evt ]]] in SpPluggableButtonMorph(PluggableButtonMorph)>>mouseUp:
	Receiver: a SpPluggableButtonMorph(190880000)
	Arguments and temporary variables: 
		evt: 	[(1205@510) mouseUp 4810089 nil]
		all: 	an Array(a SpPluggableButtonMorph(1071948288) a SpPluggableButtonMorph[..]
		m: 	a SpPluggableButtonMorph(190880000)
	Receiver's instance variables: 
		bounds: 	(1138.0@503.0) corner: (1238.0@533.0)
		owner: 	a PanelMorph(996435712)
		submorphs: 	an Array(an AlignmentMorph(603547904))
		fullBounds: 	nil
		color: 	(Color r: 0.9012707722385142 g: 0.9012707722385142 b: 0.901270772238[..]
		extension: 	a MorphExtension (702656000) [eventHandler = a MorphicEventHandl[..]
		borderWidth: 	1
		borderColor: 	#simple
		model: 	a SpMorphicButtonAdapter
		label: 	'Ok'
		icon: 	nil
		getIconSelector: 	nil
		getStateSelector: 	#state
		actionSelector: 	#action
		font: 	nil
		getLabelSelector: 	#label
		getMenuSelector: 	#menu:
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	#enabled
		getFontSelector: 	#font
		labelMorph: 	a LabelMorph(527080448)'Ok'
		iconMorph: 	nil
		iconPosition: 	#left
		lastState: 	false
		backgroundColor: 	nil


Array(SequenceableCollection)>>do:
	Receiver: an Array(a SpPluggableButtonMorph(1071948288) a SpPluggableButtonMorph(190880000))
	Arguments and temporary variables: 
		aBlock: 	[:m |
		(m containsPoint: evt cursorPoint) ifTrue: [m enabled ifTru[..]
		index: 	2
	Receiver's instance variables: 
an Array(a SpPluggableButtonMorph(1071948288) a SpPluggableButtonMorph(190880000))

SpPluggableButtonMorph(PluggableButtonMorph)>>mouseUp:
	Receiver: a SpPluggableButtonMorph(190880000)
	Arguments and temporary variables: 
		evt: 	[(1205@510) mouseUp 4810089 nil]
		all: 	an Array(a SpPluggableButtonMorph(1071948288) a SpPluggableButtonMorph[..]
	Receiver's instance variables: 
		bounds: 	(1138.0@503.0) corner: (1238.0@533.0)
		owner: 	a PanelMorph(996435712)
		submorphs: 	an Array(an AlignmentMorph(603547904))
		fullBounds: 	nil
		color: 	(Color r: 0.9012707722385142 g: 0.9012707722385142 b: 0.901270772238[..]
		extension: 	a MorphExtension (702656000) [eventHandler = a MorphicEventHandl[..]
		borderWidth: 	1
		borderColor: 	#simple
		model: 	a SpMorphicButtonAdapter
		label: 	'Ok'
		icon: 	nil
		getIconSelector: 	nil
		getStateSelector: 	#state
		actionSelector: 	#action
		font: 	nil
		getLabelSelector: 	#label
		getMenuSelector: 	#menu:
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	#enabled
		getFontSelector: 	#font
		labelMorph: 	a LabelMorph(527080448)'Ok'
		iconMorph: 	nil
		iconPosition: 	#left
		lastState: 	false
		backgroundColor: 	nil


SpPluggableButtonMorph(Morph)>>handleMouseUp:
	Receiver: a SpPluggableButtonMorph(190880000)
	Arguments and temporary variables: 
		anEvent: 	[(1205@510) mouseUp 4810089 nil]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(1138.0@503.0) corner: (1238.0@533.0)
		owner: 	a PanelMorph(996435712)
		submorphs: 	an Array(an AlignmentMorph(603547904))
		fullBounds: 	nil
		color: 	(Color r: 0.9012707722385142 g: 0.9012707722385142 b: 0.901270772238[..]
		extension: 	a MorphExtension (702656000) [eventHandler = a MorphicEventHandl[..]
		borderWidth: 	1
		borderColor: 	#simple
		model: 	a SpMorphicButtonAdapter
		label: 	'Ok'
		icon: 	nil
		getIconSelector: 	nil
		getStateSelector: 	#state
		actionSelector: 	#action
		font: 	nil
		getLabelSelector: 	#label
		getMenuSelector: 	#menu:
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	#enabled
		getFontSelector: 	#font
		labelMorph: 	a LabelMorph(527080448)'Ok'
		iconMorph: 	nil
		iconPosition: 	#left
		lastState: 	false
		backgroundColor: 	nil


MouseButtonEvent>>sentTo:
	Receiver: [(1205@510) mouseUp 4810089 nil]
	Arguments and temporary variables: 
		anObject: 	a SpPluggableButtonMorph(190880000)
	Receiver's instance variables: 
		timeStamp: 	4810089
		source: 	a HandMorph(337424384)
		windowIndex: 	nil
		type: 	#mouseUp
		buttons: 	0
		position: 	(1205@510)
		handler: 	nil
		wasHandled: 	true
		whichButton: 	4


SpPluggableButtonMorph(Morph)>>handleEvent:
	Receiver: a SpPluggableButtonMorph(190880000)
	Arguments and temporary variables: 
		anEvent: 	[(1205@510) mouseUp 4810089 nil]
	Receiver's instance variables: 
		bounds: 	(1138.0@503.0) corner: (1238.0@533.0)
		owner: 	a PanelMorph(996435712)
		submorphs: 	an Array(an AlignmentMorph(603547904))
		fullBounds: 	nil
		color: 	(Color r: 0.9012707722385142 g: 0.9012707722385142 b: 0.901270772238[..]
		extension: 	a MorphExtension (702656000) [eventHandler = a MorphicEventHandl[..]
		borderWidth: 	1
		borderColor: 	#simple
		model: 	a SpMorphicButtonAdapter
		label: 	'Ok'
		icon: 	nil
		getIconSelector: 	nil
		getStateSelector: 	#state
		actionSelector: 	#action
		font: 	nil
		getLabelSelector: 	#label
		getMenuSelector: 	#menu:
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	#enabled
		getFontSelector: 	#font
		labelMorph: 	a LabelMorph(527080448)'Ok'
		iconMorph: 	nil
		iconPosition: 	#left
		lastState: 	false
		backgroundColor: 	nil


SpPluggableButtonMorph(Morph)>>handleFocusEvent:
	Receiver: a SpPluggableButtonMorph(190880000)
	Arguments and temporary variables: 
		anEvent: 	[(1205@510) mouseUp 4810089 nil]
	Receiver's instance variables: 
		bounds: 	(1138.0@503.0) corner: (1238.0@533.0)
		owner: 	a PanelMorph(996435712)
		submorphs: 	an Array(an AlignmentMorph(603547904))
		fullBounds: 	nil
		color: 	(Color r: 0.9012707722385142 g: 0.9012707722385142 b: 0.901270772238[..]
		extension: 	a MorphExtension (702656000) [eventHandler = a MorphicEventHandl[..]
		borderWidth: 	1
		borderColor: 	#simple
		model: 	a SpMorphicButtonAdapter
		label: 	'Ok'
		icon: 	nil
		getIconSelector: 	nil
		getStateSelector: 	#state
		actionSelector: 	#action
		font: 	nil
		getLabelSelector: 	#label
		getMenuSelector: 	#menu:
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	#enabled
		getFontSelector: 	#font
		labelMorph: 	a LabelMorph(527080448)'Ok'
		iconMorph: 	nil
		iconPosition: 	#left
		lastState: 	false
		backgroundColor: 	nil


[
		result := focusHolder handleFocusEvent: transformedEvent.
	] in HandMorph>>sendFocusEvent:to:clear:
	Receiver: a HandMorph(337424384)
	Arguments and temporary variables: 
		anEvent: 	[(1205@510) mouseUp 4810089 nil]
		focusHolder: 	a SpPluggableButtonMorph(190880000)
		aBlock: 	[self mouseFocus: nil]
		w: 	a WorldMorph(341720576) [world]
		transformedEvent: 	[(1205@510) mouseUp 4810089 nil]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(1205@510.0) corner: (1221@526.0)
		owner: 	a WorldMorph(341720576) [world]
		submorphs: 	#()
		fullBounds: 	nil
		color: 	Color blue
		extension: 	a MorphExtension (370611968)
		mouseFocus: 	nil
		keyboardFocus: 	a SpPluggableButtonMorph(190880000)
		eventListeners: 	nil
		mouseListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(1205@510) mouseUp 4810089 nil]
		targetOffset: 	(66.0@7.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 0 0 0 0 0 nil nil)
		captureBlock: 	nil
		recentModifiers: 	0
		pendingEventQueue: 	WaitfreeQueue with 0 items
		supressNextKeyPress: 	false


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
		result := focusHolder handleFocusEvent: transformedEvent.
	]
	Arguments and temporary variables: 
		exception: 	Error
		handlerAction: 	[ :ex |
			ActiveWorld := priorWorld.
			ex pass ]
	Receiver's instance variables: 
		outerContext: 	HandMorph>>sendFocusEvent:to:clear:
		compiledBlock: 	a CompiledBlock: [
		result := focusHolder handleFocusEvent:[..]
		numArgs: 	0
		receiver: 	a HandMorph(337424384)


WorldMorph>>becomeActiveDuring:
	Receiver: a WorldMorph(341720576) [world]
	Arguments and temporary variables: 
		aBlock: 	[
		result := focusHolder handleFocusEvent: transformedEvent.
	]
		priorWorld: 	a WorldMorph(341720576) [world]
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1728@1080)
		owner: 	nil
		submorphs: 	an Array(a MenubarMorph(112886016) a TaskbarMorph(279458560) a S[..]
		fullBounds: 	nil
		color: 	(Color r: 0.9403714565004888 g: 0.9403714565004888 b: 0.940371456500[..]
		extension: 	a MorphExtension (1012946432) [other:  (dragEnabled -> true) (dr[..]
		borderWidth: 	0
		borderColor: 	(Color r: 0.8611925708699902 g: 1.0 b: 0.7223851417399805 alph[..]
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil


HandMorph>>sendFocusEvent:to:clear:
	Receiver: a HandMorph(337424384)
	Arguments and temporary variables: 
		result: 	nil
		anEvent: 	[(1205@510) mouseUp 4810089 nil]
		focusHolder: 	a SpPluggableButtonMorph(190880000)
		aBlock: 	[self mouseFocus: nil]
		w: 	a WorldMorph(341720576) [world]
		transformedEvent: 	[(1205@510) mouseUp 4810089 nil]
	Receiver's instance variables: 
		bounds: 	(1205@510.0) corner: (1221@526.0)
		owner: 	a WorldMorph(341720576) [world]
		submorphs: 	#()
		fullBounds: 	nil
		color: 	Color blue
		extension: 	a MorphExtension (370611968)
		mouseFocus: 	nil
		keyboardFocus: 	a SpPluggableButtonMorph(190880000)
		eventListeners: 	nil
		mouseListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(1205@510) mouseUp 4810089 nil]
		targetOffset: 	(66.0@7.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 0 0 0 0 0 nil nil)
		captureBlock: 	nil
		recentModifiers: 	0
		pendingEventQueue: 	WaitfreeQueue with 0 items
		supressNextKeyPress: 	false


HandMorph>>sendEvent:focus:clear:
	Receiver: a HandMorph(337424384)
	Arguments and temporary variables: 
		anEvent: 	[(1205@510) mouseUp 4810089 nil]
		focusHolder: 	a SpPluggableButtonMorph(190880000)
		aBlock: 	[self mouseFocus: nil]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(1205@510.0) corner: (1221@526.0)
		owner: 	a WorldMorph(341720576) [world]
		submorphs: 	#()
		fullBounds: 	nil
		color: 	Color blue
		extension: 	a MorphExtension (370611968)
		mouseFocus: 	nil
		keyboardFocus: 	a SpPluggableButtonMorph(190880000)
		eventListeners: 	nil
		mouseListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(1205@510) mouseUp 4810089 nil]
		targetOffset: 	(66.0@7.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 0 0 0 0 0 nil nil)
		captureBlock: 	nil
		recentModifiers: 	0
		pendingEventQueue: 	WaitfreeQueue with 0 items
		supressNextKeyPress: 	false


HandMorph>>sendMouseEvent:
	Receiver: a HandMorph(337424384)
	Arguments and temporary variables: 
		anEvent: 	[(1205@510) mouseUp 4810089 nil]
	Receiver's instance variables: 
		bounds: 	(1205@510.0) corner: (1221@526.0)
		owner: 	a WorldMorph(341720576) [world]
		submorphs: 	#()
		fullBounds: 	nil
		color: 	Color blue
		extension: 	a MorphExtension (370611968)
		mouseFocus: 	nil
		keyboardFocus: 	a SpPluggableButtonMorph(190880000)
		eventListeners: 	nil
		mouseListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(1205@510) mouseUp 4810089 nil]
		targetOffset: 	(66.0@7.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 0 0 0 0 0 nil nil)
		captureBlock: 	nil
		recentModifiers: 	0
		pendingEventQueue: 	WaitfreeQueue with 0 items
		supressNextKeyPress: 	false


HandMorph>>handleEvent:
	Receiver: a HandMorph(337424384)
	Arguments and temporary variables: 
		anEvent: 	[(1205@510) mouseUp 4810089 nil]
		evt: 	[(1205@510) mouseUp 4810089 nil]
	Receiver's instance variables: 
		bounds: 	(1205@510.0) corner: (1221@526.0)
		owner: 	a WorldMorph(341720576) [world]
		submorphs: 	#()
		fullBounds: 	nil
		color: 	Color blue
		extension: 	a MorphExtension (370611968)
		mouseFocus: 	nil
		keyboardFocus: 	a SpPluggableButtonMorph(190880000)
		eventListeners: 	nil
		mouseListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(1205@510) mouseUp 4810089 nil]
		targetOffset: 	(66.0@7.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 0 0 0 0 0 nil nil)
		captureBlock: 	nil
		recentModifiers: 	0
		pendingEventQueue: 	WaitfreeQueue with 0 items
		supressNextKeyPress: 	false


[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil ]) ifTrue: [
			morphicWorld activeHand handleEvent: anEvent
		]
	] in OSWindowMorphicEventHandler>>dispatchMorphicEvent:
	Receiver: an OSWindowMorphicEventHandler
	Arguments and temporary variables: 
		anEvent: 	[(1205@510) mouseUp 4810089 nil]
	Receiver's instance variables: 
		morphicWorld: 	a WorldMorph(341720576) [world]


WorldState>>runStepMethodsIn:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(341720576) [world]
		queue: 	WaitfreeQueue with 0 items
		nextInQueue: 	[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNo[..]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(337424384))
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap()
		lastStepTime: 	4743121
		lastStepMessage: 	nil
		alarms: 	a Heap()
		lastAlarmTime: 	4810075
		activeHand: 	a HandMorph(337424384)
		currentCursor: 	((CursorWithMask
	extent: (16@16)
	depth: 1
	fromArray: #(
	[..]
		worldRenderer: 	an OSWorldRenderer
		realWindowExtent: 	(1728@1080)
		deferredUIMessages: 	WaitfreeQueue with 0 items


WorldMorph>>runStepMethods
	Receiver: a WorldMorph(341720576) [world]
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1728@1080)
		owner: 	nil
		submorphs: 	an Array(a MenubarMorph(112886016) a TaskbarMorph(279458560) a S[..]
		fullBounds: 	nil
		color: 	(Color r: 0.9403714565004888 g: 0.9403714565004888 b: 0.940371456500[..]
		extension: 	a MorphExtension (1012946432) [other:  (dragEnabled -> true) (dr[..]
		borderWidth: 	0
		borderColor: 	(Color r: 0.8611925708699902 g: 1.0 b: 0.7223851417399805 alph[..]
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil


WorldState>>doOneCycleFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(341720576) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(337424384))
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap()
		lastStepTime: 	4743121
		lastStepMessage: 	nil
		alarms: 	a Heap()
		lastAlarmTime: 	4810075
		activeHand: 	a HandMorph(337424384)
		currentCursor: 	((CursorWithMask
	extent: (16@16)
	depth: 1
	fromArray: #(
	[..]
		worldRenderer: 	an OSWorldRenderer
		realWindowExtent: 	(1728@1080)
		deferredUIMessages: 	WaitfreeQueue with 0 items


WorldMorph>>doOneCycleNow
	Receiver: a WorldMorph(341720576) [world]
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1728@1080)
		owner: 	nil
		submorphs: 	an Array(a MenubarMorph(112886016) a TaskbarMorph(279458560) a S[..]
		fullBounds: 	nil
		color: 	(Color r: 0.9403714565004888 g: 0.9403714565004888 b: 0.940371456500[..]
		extension: 	a MorphExtension (1012946432) [other:  (dragEnabled -> true) (dr[..]
		borderWidth: 	0
		borderColor: 	(Color r: 0.8611925708699902 g: 1.0 b: 0.7223851417399805 alph[..]
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil


WorldMorph>>doOneCycle
	Receiver: a WorldMorph(341720576) [world]
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1728@1080)
		owner: 	nil
		submorphs: 	an Array(a MenubarMorph(112886016) a TaskbarMorph(279458560) a S[..]
		fullBounds: 	nil
		color: 	(Color r: 0.9403714565004888 g: 0.9403714565004888 b: 0.940371456500[..]
		extension: 	a MorphExtension (1012946432) [other:  (dragEnabled -> true) (dr[..]
		borderWidth: 	0
		borderColor: 	(Color r: 0.8611925708699902 g: 1.0 b: 0.7223851417399805 alph[..]
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil


[
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMutex critical: [
			                     self extraWorldList ].
		extraWorldsToDraw do: [ :world | world doOneCycle ].

		(self currentWorld isNotNil and: [
			 (extraWorldsToDraw includes: self currentWorld) not ]) ifTrue: [
			self currentWorld doOneCycle ] ] in WorldMorph class>>doOneCycle
	Receiver: WorldMorph
	Arguments and temporary variables: 
		extraWorldsToDraw: 	#()
	Receiver's instance variables: 
		superclass: 	PasteUpMorph
		methodDict: 	a MethodDictionary(#acceptDroppingMorph:event:->WorldMorph>>#ac[..]
		format: 	65547
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		commentSourcePointer: 	nil
		subclasses: 	{AthensWorldMorph. OSWindowWorldMorph}
		name: 	#WorldMorph
		classPool: 	a Dictionary(#AllowDropFiles->nil #CursorOwnerWorld->a WorldMorp[..]
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Morphic-Core-Worlds'
		announcer: 	nil
		displayScaleFactor: 	1


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMutex critical: [
			  [..]
	Arguments and temporary variables: 
		aBlock: 	[
		self doInterCycleWait
	]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	WorldMorph class>>doOneCycle
		compiledBlock: 	a CompiledBlock: [
		| extraWorldsToDraw |
		extraWorldsToDr[..]
		numArgs: 	0
		receiver: 	WorldMorph


WorldState class>>doDrawCycleWith:
	Receiver: WorldState
	Arguments and temporary variables: 
		aBlock: 	[
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMute[..]
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary(#activeHand->WorldState>>#activeHand #active[..]
		format: 	65548
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		commentSourcePointer: 	nil
		subclasses: 	{AthensWorldState}
		name: 	#WorldState
		classPool: 	a Dictionary(#CanSurrenderToOS->nil #DebugShowDamage->false #Des[..]
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Morphic-Core-Worlds'


WorldMorph class>>doOneCycle
	Receiver: WorldMorph
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		superclass: 	PasteUpMorph
		methodDict: 	a MethodDictionary(#acceptDroppingMorph:event:->WorldMorph>>#ac[..]
		format: 	65547
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		commentSourcePointer: 	nil
		subclasses: 	{AthensWorldMorph. OSWindowWorldMorph}
		name: 	#WorldMorph
		classPool: 	a Dictionary(#AllowDropFiles->nil #CursorOwnerWorld->a WorldMorp[..]
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Morphic-Core-Worlds'
		announcer: 	nil
		displayScaleFactor: 	1


MorphicRenderLoop>>doOneCycle
	Receiver: a MorphicRenderLoop
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
a MorphicRenderLoop

MorphicRenderLoop>>doOneCycleWhile:
	Receiver: a MorphicRenderLoop
	Arguments and temporary variables: 
		aBlock: 	[ true ]
	Receiver's instance variables: 
a MorphicRenderLoop

[ MorphicRenderLoop new doOneCycleWhile: [ true ] ] in MorphicUIManager>>spawnNewProcess
	Receiver: a MorphicUIManager
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		activeTranscript: 	Transcript


[self value.
			"IMPORTANT: Do not step over next line of code. See method comments for details"
			Processor terminateRealActive] in FullBlockClosure(BlockClosure)>>newProcess
	Receiver: [ MorphicRenderLoop new doOneCycleWhile: [ true ] ]
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		outerContext: 	MorphicUIManager>>spawnNewProcess
		compiledBlock: 	a CompiledBlock: [ MorphicRenderLoop new doOneCycleWhile: [ [..]
		numArgs: 	0
		receiver: 	a MorphicUIManager



--- The full stack ---
IceTipLocalRepositoryPanel(Object)>>assert:description:
IceTipLocalRepositoryPanel>>validate
[ 
			dialog validate.
			self repositoryModel updateLocation: dialog location.
			true ] in IceTipRepairLocateRepository>>basicExecute
FullBlockClosure(BlockClosure)>>cull:
SpDialogWindowPresenter>>triggerOkAction
[ :presenter | 
			presenter triggerOkAction.
			presenter close ] in IceTipLocalRepositoryPanel(SpAbstractPresenter)>>initializeDialogWindow:
FullBlockClosure(BlockClosure)>>cull:
[ aBlock cull: self ] in SpDialogWindowPresenter>>addButton:do:
SpButtonPresenter>>performAction
SpMorphicButtonAdapter>>action
SpPluggableButtonMorph(PluggableButtonMorph)>>performAction:
[:m |
		(m containsPoint: evt cursorPoint) ifTrue: [m enabled ifTrue: [ m performAction: evt ]]] in SpPluggableButtonMorph(PluggableButtonMorph)>>mouseUp:
Array(SequenceableCollection)>>do:
SpPluggableButtonMorph(PluggableButtonMorph)>>mouseUp:
SpPluggableButtonMorph(Morph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
SpPluggableButtonMorph(Morph)>>handleEvent:
SpPluggableButtonMorph(Morph)>>handleFocusEvent:
[
		result := focusHolder handleFocusEvent: transformedEvent.
	] in HandMorph>>sendFocusEvent:to:clear:
FullBlockClosure(BlockClosure)>>on:do:
WorldMorph>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil ]) ifTrue: [
			morphicWorld activeHand handleEvent: anEvent
		]
	] in OSWindowMorphicEventHandler>>dispatchMorphicEvent:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycleNow
WorldMorph>>doOneCycle
[
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMutex critical: [
			                     self extraWorldList ].
		extraWorldsToDraw do: [ :world | world doOneCycle ].

		(self currentWorld isNotNil and: [
			 (extraWorldsToDraw includes: self currentWorld) not ]) ifTrue: [
			self currentWorld doOneCycle ] ] in WorldMorph class>>doOneCycle
FullBlockClosure(BlockClosure)>>ensure:
WorldState class>>doDrawCycleWith:
WorldMorph class>>doOneCycle
MorphicRenderLoop>>doOneCycle
MorphicRenderLoop>>doOneCycleWhile:
[ MorphicRenderLoop new doOneCycleWhile: [ true ] ] in MorphicUIManager>>spawnNewProcess
[self value.
			"IMPORTANT: Do not step over next line of code. See method comments for details"
			Processor terminateRealActive] in FullBlockClosure(BlockClosure)>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
AssertionFailure: Project location does not seems to be a valid git repository.
13 November 2023 5:24:52.025373 pm

VM: Mac OS - arm64 - 1000 - CoInterpreter VMMaker-tonel.1 uuid: 902dd483-c0c4-0d00-86f2-0f880df24b96 Oct 23 2023
StackToRegisterMappingCogit VMMaker-tonel.1 uuid: 902dd483-c0c4-0d00-86f2-0f880df24b96 Oct 23 2023
v10.0.8 - Commit: b323c5fb - Date: 2023-10-20 16:02:07 -0400

Image: Pharo11.0.0 [Build information: Pharo-11.0.0+build.710.sha.ea28d8552cac85a7ce1e9c34ab1e7bd45f7b9910 (64 Bit)]

IceTipLocalRepositoryPanel(Object)>>assert:description:
	Receiver: an IceTipLocalRepositoryPanel
	Arguments and temporary variables: 
		aBlock: 	false
		aStringOrBlock: 	'Project location does not seems to be a valid git repository.'
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicGridAdapter)
		announcer: 	an Announcer
		owner: 	a SpDialogWindowPresenter
		adapter: 	a SpMorphicGridAdapter
		needRebuild: 	true
		eventHandler: 	nil
		application: 	a StPharoApplication
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ nil ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Untitled window' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpGridLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		decorations: 	nil
		projectLocationLabel: 	a SpLabelPresenter
		projectLocation: 	an IceTipDirectoryPresenter
		remoteLabel: 	nil
		remoteInputText: 	nil
		repository: 	nil


IceTipLocalRepositoryPanel>>validate
	Receiver: an IceTipLocalRepositoryPanel
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicGridAdapter)
		announcer: 	an Announcer
		owner: 	a SpDialogWindowPresenter
		adapter: 	a SpMorphicGridAdapter
		needRebuild: 	true
		eventHandler: 	nil
		application: 	a StPharoApplication
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ nil ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Untitled window' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpGridLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		decorations: 	nil
		projectLocationLabel: 	a SpLabelPresenter
		projectLocation: 	an IceTipDirectoryPresenter
		remoteLabel: 	nil
		remoteInputText: 	nil
		repository: 	nil


[ 
			dialog validate.
			self repositoryModel updateLocation: dialog location.
			true ] in IceTipRepairLocateRepository>>basicExecute
	Receiver: an IceTipRepairLocateRepository
	Arguments and temporary variables: 
		dialog: 	an IceTipLocalRepositoryPanel
	Receiver's instance variables: 
		context: 	an IceTipRepairRepositoryDialog
		repository: 	nil
		successBlock: 	nil
		repositoryModel: 	an IceTipCachedModel(an IceTipRepositoryModel)


FullBlockClosure(BlockClosure)>>cull:
	Receiver: [ 
			dialog validate.
			self repositoryModel updateLocation: dialog location.
			true ]
	Arguments and temporary variables: 
		anArg: 	a SpDialogWindowPresenter
	Receiver's instance variables: 
		outerContext: 	IceTipRepairLocateRepository>>basicExecute
		compiledBlock: 	a CompiledBlock: [ 
			dialog validate.
			self repositoryMo[..]
		numArgs: 	0
		receiver: 	an IceTipRepairLocateRepository


SpDialogWindowPresenter>>triggerOkAction
	Receiver: a SpDialogWindowPresenter
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicDialogWindowAdapter a SpDialogWind[..]
		announcer: 	an Announcer
		owner: 	nil
		adapter: 	a SpMorphicDialogWindowAdapter
		needRebuild: 	true
		eventHandler: 	nil
		application: 	a StPharoApplication
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ nil ]
		windowIcon: 	an ObservableValueHolder[ Form(16x16x32) ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ true ]
		titleHolder: 	an ObservableValueHolder[ 'Import from existing clone' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ nil ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		borderWidth: 	an ObservableValueHolder[ nil ]
		borderColor: 	an ObservableValueHolder[ nil ]
		dragEnabled: 	an ObservableValueHolder[ false ]
		dropEnabled: 	an ObservableValueHolder[ false ]
		color: 	an ObservableValueHolder[ nil ]
		help: 	an ObservableValueHolder[ nil ]
		enabled: 	an ObservableValueHolder[ true ]
		wantsDrop: 	an ObservableValueHolder[ [ :transfer | self dropEnabled ] ]
		acceptDrop: 	an ObservableValueHolder[ [ :transfer | ] ]
		deferredActions: 	nil
		presenter: 	an ObservableValueHolder[ an IceTipLocalRepositoryPanel ]
		initialPosition: 	an ObservableValueHolder[ nil ]
		initialExtent: 	an ObservableValueHolder[ (500@137) ]
		menu: 	an ObservableValueHolder[ nil ]
		centered: 	an ObservableValueHolder[ false ]
		isClosed: 	an ObservableValueHolder[ false ]
		toolbar: 	an ObservableValueHolder[ nil ]
		statusbar: 	an ObservableValueHolder[ nil ]
		window: 	an ObservableValueHolder[ a SpDialogWindowMorph(272541184) named: I[..]
		decorations: 	an ObservableValueHolder[ true ]
		resizable: 	an ObservableValueHolder[ true ]
		buttons: 	an OrderedCollection(a SpButtonPresenter a SpButtonPresenter)
		okAction: 	[ 
			dialog validate.
			self repositoryModel updateLocation: di[..]
		cancelAction: 	[ 
		cancelled := true.
		self close ]
		cancelled: 	true
		defaultButton: 	nil


[ :presenter | 
			presenter triggerOkAction.
			presenter close ] in IceTipLocalRepositoryPanel(SpAbstractPresenter)>>initializeDialogWindow:
	Receiver: an IceTipLocalRepositoryPanel
	Arguments and temporary variables: 
		aDialogWindowPresenter: 	a SpDialogWindowPresenter
		presenter: 	a SpDialogWindowPresenter
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicGridAdapter)
		announcer: 	an Announcer
		owner: 	a SpDialogWindowPresenter
		adapter: 	a SpMorphicGridAdapter
		needRebuild: 	true
		eventHandler: 	nil
		application: 	a StPharoApplication
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ nil ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Untitled window' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpGridLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		decorations: 	nil
		projectLocationLabel: 	a SpLabelPresenter
		projectLocation: 	an IceTipDirectoryPresenter
		remoteLabel: 	nil
		remoteInputText: 	nil
		repository: 	nil


FullBlockClosure(BlockClosure)>>cull:
	Receiver: [ :presenter | 
			presenter triggerOkAction.
			presenter close ]
	Arguments and temporary variables: 
		anArg: 	a SpDialogWindowPresenter
	Receiver's instance variables: 
		outerContext: 	IceTipLocalRepositoryPanel(SpAbstractPresenter)>>initializeDi[..]
		compiledBlock: 	a CompiledBlock: [ :presenter | 
			presenter triggerOkActio[..]
		numArgs: 	1
		receiver: 	an IceTipLocalRepositoryPanel


[ aBlock cull: self ] in SpDialogWindowPresenter>>addButton:do:
	Receiver: a SpDialogWindowPresenter
	Arguments and temporary variables: 
		aString: 	'Ok'
		aBlock: 	[ :presenter | 
			presenter triggerOkAction.
			presenter close ]
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicDialogWindowAdapter a SpDialogWind[..]
		announcer: 	an Announcer
		owner: 	nil
		adapter: 	a SpMorphicDialogWindowAdapter
		needRebuild: 	true
		eventHandler: 	nil
		application: 	a StPharoApplication
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ nil ]
		windowIcon: 	an ObservableValueHolder[ Form(16x16x32) ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ true ]
		titleHolder: 	an ObservableValueHolder[ 'Import from existing clone' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ nil ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		borderWidth: 	an ObservableValueHolder[ nil ]
		borderColor: 	an ObservableValueHolder[ nil ]
		dragEnabled: 	an ObservableValueHolder[ false ]
		dropEnabled: 	an ObservableValueHolder[ false ]
		color: 	an ObservableValueHolder[ nil ]
		help: 	an ObservableValueHolder[ nil ]
		enabled: 	an ObservableValueHolder[ true ]
		wantsDrop: 	an ObservableValueHolder[ [ :transfer | self dropEnabled ] ]
		acceptDrop: 	an ObservableValueHolder[ [ :transfer | ] ]
		deferredActions: 	nil
		presenter: 	an ObservableValueHolder[ an IceTipLocalRepositoryPanel ]
		initialPosition: 	an ObservableValueHolder[ nil ]
		initialExtent: 	an ObservableValueHolder[ (500@137) ]
		menu: 	an ObservableValueHolder[ nil ]
		centered: 	an ObservableValueHolder[ false ]
		isClosed: 	an ObservableValueHolder[ false ]
		toolbar: 	an ObservableValueHolder[ nil ]
		statusbar: 	an ObservableValueHolder[ nil ]
		window: 	an ObservableValueHolder[ a SpDialogWindowMorph(272541184) named: I[..]
		decorations: 	an ObservableValueHolder[ true ]
		resizable: 	an ObservableValueHolder[ true ]
		buttons: 	an OrderedCollection(a SpButtonPresenter a SpButtonPresenter)
		okAction: 	[ 
			dialog validate.
			self repositoryModel updateLocation: di[..]
		cancelAction: 	[ 
		cancelled := true.
		self close ]
		cancelled: 	true
		defaultButton: 	nil


SpButtonPresenter>>performAction
	Receiver: a SpButtonPresenter
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicButtonAdapter)
		announcer: 	an Announcer
		owner: 	a SpButtonBarPresenter
		adapter: 	a SpMorphicButtonAdapter
		needRebuild: 	true
		eventHandler: 	nil
		application: 	nil
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ nil ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Button' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpAbstractWidgetLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		borderWidth: 	an ObservableValueHolder[ nil ]
		borderColor: 	an ObservableValueHolder[ nil ]
		dragEnabled: 	an ObservableValueHolder[ false ]
		dropEnabled: 	an ObservableValueHolder[ false ]
		color: 	an ObservableValueHolder[ nil ]
		help: 	an ObservableValueHolder[ nil ]
		enabled: 	an ObservableValueHolder[ true ]
		wantsDrop: 	an ObservableValueHolder[ [ :transfer | self dropEnabled ] ]
		acceptDrop: 	an ObservableValueHolder[ [ :transfer | ] ]
		deferredActions: 	nil
		icon: 	an ObservableValueHolder[ nil ]
		label: 	an ObservableValueHolder[ 'Ok' ]
		action: 	an ObservableValueHolder[ [ aBlock cull: self ] ]
		actionPerformed: 	an ObservableValueHolder[ nil ]
		askBeforeChanging: 	an ObservableValueHolder[ false ]
		font: 	an ObservableValueHolder[ nil ]
		shortcut: 	an ObservableValueHolder[ nil ]
		state: 	an ObservableValueHolder[ false ]
		contextMenu: 	an ObservableValueHolder[ nil ]


SpMorphicButtonAdapter>>action
	Receiver: a SpMorphicButtonAdapter
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpPluggableButtonMorph(190880000))
		announcer: 	nil
		model: 	a SpButtonPresenter
		widget: 	a SpPluggableButtonMorph(190880000)
		selector: 	nil
		owner: 	a SpButtonPresenter
		unsubscribed: 	false
		subMenuWidget: 	nil
		styleName: 	nil


SpPluggableButtonMorph(PluggableButtonMorph)>>performAction:
	Receiver: a SpPluggableButtonMorph(190880000)
	Arguments and temporary variables: 
		event: 	[(1205@510) mouseUp 4810089 nil]
	Receiver's instance variables: 
		bounds: 	(1138.0@503.0) corner: (1238.0@533.0)
		owner: 	a PanelMorph(996435712)
		submorphs: 	an Array(an AlignmentMorph(603547904))
		fullBounds: 	nil
		color: 	(Color r: 0.9012707722385142 g: 0.9012707722385142 b: 0.901270772238[..]
		extension: 	a MorphExtension (702656000) [eventHandler = a MorphicEventHandl[..]
		borderWidth: 	1
		borderColor: 	#simple
		model: 	a SpMorphicButtonAdapter
		label: 	'Ok'
		icon: 	nil
		getIconSelector: 	nil
		getStateSelector: 	#state
		actionSelector: 	#action
		font: 	nil
		getLabelSelector: 	#label
		getMenuSelector: 	#menu:
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	#enabled
		getFontSelector: 	#font
		labelMorph: 	a LabelMorph(527080448)'Ok'
		iconMorph: 	nil
		iconPosition: 	#left
		lastState: 	false
		backgroundColor: 	nil


[:m |
		(m containsPoint: evt cursorPoint) ifTrue: [m enabled ifTrue: [ m performAction: evt ]]] in SpPluggableButtonMorph(PluggableButtonMorph)>>mouseUp:
	Receiver: a SpPluggableButtonMorph(190880000)
	Arguments and temporary variables: 
		evt: 	[(1205@510) mouseUp 4810089 nil]
		all: 	an Array(a SpPluggableButtonMorph(1071948288) a SpPluggableButtonMorph[..]
		m: 	a SpPluggableButtonMorph(190880000)
	Receiver's instance variables: 
		bounds: 	(1138.0@503.0) corner: (1238.0@533.0)
		owner: 	a PanelMorph(996435712)
		submorphs: 	an Array(an AlignmentMorph(603547904))
		fullBounds: 	nil
		color: 	(Color r: 0.9012707722385142 g: 0.9012707722385142 b: 0.901270772238[..]
		extension: 	a MorphExtension (702656000) [eventHandler = a MorphicEventHandl[..]
		borderWidth: 	1
		borderColor: 	#simple
		model: 	a SpMorphicButtonAdapter
		label: 	'Ok'
		icon: 	nil
		getIconSelector: 	nil
		getStateSelector: 	#state
		actionSelector: 	#action
		font: 	nil
		getLabelSelector: 	#label
		getMenuSelector: 	#menu:
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	#enabled
		getFontSelector: 	#font
		labelMorph: 	a LabelMorph(527080448)'Ok'
		iconMorph: 	nil
		iconPosition: 	#left
		lastState: 	false
		backgroundColor: 	nil


Array(SequenceableCollection)>>do:
	Receiver: an Array(a SpPluggableButtonMorph(1071948288) a SpPluggableButtonMorph(190880000))
	Arguments and temporary variables: 
		aBlock: 	[:m |
		(m containsPoint: evt cursorPoint) ifTrue: [m enabled ifTru[..]
		index: 	2
	Receiver's instance variables: 
an Array(a SpPluggableButtonMorph(1071948288) a SpPluggableButtonMorph(190880000))

SpPluggableButtonMorph(PluggableButtonMorph)>>mouseUp:
	Receiver: a SpPluggableButtonMorph(190880000)
	Arguments and temporary variables: 
		evt: 	[(1205@510) mouseUp 4810089 nil]
		all: 	an Array(a SpPluggableButtonMorph(1071948288) a SpPluggableButtonMorph[..]
	Receiver's instance variables: 
		bounds: 	(1138.0@503.0) corner: (1238.0@533.0)
		owner: 	a PanelMorph(996435712)
		submorphs: 	an Array(an AlignmentMorph(603547904))
		fullBounds: 	nil
		color: 	(Color r: 0.9012707722385142 g: 0.9012707722385142 b: 0.901270772238[..]
		extension: 	a MorphExtension (702656000) [eventHandler = a MorphicEventHandl[..]
		borderWidth: 	1
		borderColor: 	#simple
		model: 	a SpMorphicButtonAdapter
		label: 	'Ok'
		icon: 	nil
		getIconSelector: 	nil
		getStateSelector: 	#state
		actionSelector: 	#action
		font: 	nil
		getLabelSelector: 	#label
		getMenuSelector: 	#menu:
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	#enabled
		getFontSelector: 	#font
		labelMorph: 	a LabelMorph(527080448)'Ok'
		iconMorph: 	nil
		iconPosition: 	#left
		lastState: 	false
		backgroundColor: 	nil


SpPluggableButtonMorph(Morph)>>handleMouseUp:
	Receiver: a SpPluggableButtonMorph(190880000)
	Arguments and temporary variables: 
		anEvent: 	[(1205@510) mouseUp 4810089 nil]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(1138.0@503.0) corner: (1238.0@533.0)
		owner: 	a PanelMorph(996435712)
		submorphs: 	an Array(an AlignmentMorph(603547904))
		fullBounds: 	nil
		color: 	(Color r: 0.9012707722385142 g: 0.9012707722385142 b: 0.901270772238[..]
		extension: 	a MorphExtension (702656000) [eventHandler = a MorphicEventHandl[..]
		borderWidth: 	1
		borderColor: 	#simple
		model: 	a SpMorphicButtonAdapter
		label: 	'Ok'
		icon: 	nil
		getIconSelector: 	nil
		getStateSelector: 	#state
		actionSelector: 	#action
		font: 	nil
		getLabelSelector: 	#label
		getMenuSelector: 	#menu:
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	#enabled
		getFontSelector: 	#font
		labelMorph: 	a LabelMorph(527080448)'Ok'
		iconMorph: 	nil
		iconPosition: 	#left
		lastState: 	false
		backgroundColor: 	nil


MouseButtonEvent>>sentTo:
	Receiver: [(1205@510) mouseUp 4810089 nil]
	Arguments and temporary variables: 
		anObject: 	a SpPluggableButtonMorph(190880000)
	Receiver's instance variables: 
		timeStamp: 	4810089
		source: 	a HandMorph(337424384)
		windowIndex: 	nil
		type: 	#mouseUp
		buttons: 	0
		position: 	(1205@510)
		handler: 	nil
		wasHandled: 	true
		whichButton: 	4


SpPluggableButtonMorph(Morph)>>handleEvent:
	Receiver: a SpPluggableButtonMorph(190880000)
	Arguments and temporary variables: 
		anEvent: 	[(1205@510) mouseUp 4810089 nil]
	Receiver's instance variables: 
		bounds: 	(1138.0@503.0) corner: (1238.0@533.0)
		owner: 	a PanelMorph(996435712)
		submorphs: 	an Array(an AlignmentMorph(603547904))
		fullBounds: 	nil
		color: 	(Color r: 0.9012707722385142 g: 0.9012707722385142 b: 0.901270772238[..]
		extension: 	a MorphExtension (702656000) [eventHandler = a MorphicEventHandl[..]
		borderWidth: 	1
		borderColor: 	#simple
		model: 	a SpMorphicButtonAdapter
		label: 	'Ok'
		icon: 	nil
		getIconSelector: 	nil
		getStateSelector: 	#state
		actionSelector: 	#action
		font: 	nil
		getLabelSelector: 	#label
		getMenuSelector: 	#menu:
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	#enabled
		getFontSelector: 	#font
		labelMorph: 	a LabelMorph(527080448)'Ok'
		iconMorph: 	nil
		iconPosition: 	#left
		lastState: 	false
		backgroundColor: 	nil


SpPluggableButtonMorph(Morph)>>handleFocusEvent:
	Receiver: a SpPluggableButtonMorph(190880000)
	Arguments and temporary variables: 
		anEvent: 	[(1205@510) mouseUp 4810089 nil]
	Receiver's instance variables: 
		bounds: 	(1138.0@503.0) corner: (1238.0@533.0)
		owner: 	a PanelMorph(996435712)
		submorphs: 	an Array(an AlignmentMorph(603547904))
		fullBounds: 	nil
		color: 	(Color r: 0.9012707722385142 g: 0.9012707722385142 b: 0.901270772238[..]
		extension: 	a MorphExtension (702656000) [eventHandler = a MorphicEventHandl[..]
		borderWidth: 	1
		borderColor: 	#simple
		model: 	a SpMorphicButtonAdapter
		label: 	'Ok'
		icon: 	nil
		getIconSelector: 	nil
		getStateSelector: 	#state
		actionSelector: 	#action
		font: 	nil
		getLabelSelector: 	#label
		getMenuSelector: 	#menu:
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	#enabled
		getFontSelector: 	#font
		labelMorph: 	a LabelMorph(527080448)'Ok'
		iconMorph: 	nil
		iconPosition: 	#left
		lastState: 	false
		backgroundColor: 	nil


[
		result := focusHolder handleFocusEvent: transformedEvent.
	] in HandMorph>>sendFocusEvent:to:clear:
	Receiver: a HandMorph(337424384)
	Arguments and temporary variables: 
		anEvent: 	[(1205@510) mouseUp 4810089 nil]
		focusHolder: 	a SpPluggableButtonMorph(190880000)
		aBlock: 	[self mouseFocus: nil]
		w: 	a WorldMorph(341720576) [world]
		transformedEvent: 	[(1205@510) mouseUp 4810089 nil]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(1205@510.0) corner: (1221@526.0)
		owner: 	a WorldMorph(341720576) [world]
		submorphs: 	#()
		fullBounds: 	nil
		color: 	Color blue
		extension: 	a MorphExtension (370611968)
		mouseFocus: 	nil
		keyboardFocus: 	a SpPluggableButtonMorph(190880000)
		eventListeners: 	nil
		mouseListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(1205@510) mouseUp 4810089 nil]
		targetOffset: 	(66.0@7.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 0 0 0 0 0 nil nil)
		captureBlock: 	nil
		recentModifiers: 	0
		pendingEventQueue: 	WaitfreeQueue with 0 items
		supressNextKeyPress: 	false


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
		result := focusHolder handleFocusEvent: transformedEvent.
	]
	Arguments and temporary variables: 
		exception: 	Error
		handlerAction: 	[ :ex |
			ActiveWorld := priorWorld.
			ex pass ]
	Receiver's instance variables: 
		outerContext: 	HandMorph>>sendFocusEvent:to:clear:
		compiledBlock: 	a CompiledBlock: [
		result := focusHolder handleFocusEvent:[..]
		numArgs: 	0
		receiver: 	a HandMorph(337424384)


WorldMorph>>becomeActiveDuring:
	Receiver: a WorldMorph(341720576) [world]
	Arguments and temporary variables: 
		aBlock: 	[
		result := focusHolder handleFocusEvent: transformedEvent.
	]
		priorWorld: 	a WorldMorph(341720576) [world]
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1728@1080)
		owner: 	nil
		submorphs: 	an Array(a MenubarMorph(112886016) a TaskbarMorph(279458560) a S[..]
		fullBounds: 	nil
		color: 	(Color r: 0.9403714565004888 g: 0.9403714565004888 b: 0.940371456500[..]
		extension: 	a MorphExtension (1012946432) [other:  (dragEnabled -> true) (dr[..]
		borderWidth: 	0
		borderColor: 	(Color r: 0.8611925708699902 g: 1.0 b: 0.7223851417399805 alph[..]
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil


HandMorph>>sendFocusEvent:to:clear:
	Receiver: a HandMorph(337424384)
	Arguments and temporary variables: 
		result: 	nil
		anEvent: 	[(1205@510) mouseUp 4810089 nil]
		focusHolder: 	a SpPluggableButtonMorph(190880000)
		aBlock: 	[self mouseFocus: nil]
		w: 	a WorldMorph(341720576) [world]
		transformedEvent: 	[(1205@510) mouseUp 4810089 nil]
	Receiver's instance variables: 
		bounds: 	(1205@510.0) corner: (1221@526.0)
		owner: 	a WorldMorph(341720576) [world]
		submorphs: 	#()
		fullBounds: 	nil
		color: 	Color blue
		extension: 	a MorphExtension (370611968)
		mouseFocus: 	nil
		keyboardFocus: 	a SpPluggableButtonMorph(190880000)
		eventListeners: 	nil
		mouseListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(1205@510) mouseUp 4810089 nil]
		targetOffset: 	(66.0@7.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 0 0 0 0 0 nil nil)
		captureBlock: 	nil
		recentModifiers: 	0
		pendingEventQueue: 	WaitfreeQueue with 0 items
		supressNextKeyPress: 	false


HandMorph>>sendEvent:focus:clear:
	Receiver: a HandMorph(337424384)
	Arguments and temporary variables: 
		anEvent: 	[(1205@510) mouseUp 4810089 nil]
		focusHolder: 	a SpPluggableButtonMorph(190880000)
		aBlock: 	[self mouseFocus: nil]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(1205@510.0) corner: (1221@526.0)
		owner: 	a WorldMorph(341720576) [world]
		submorphs: 	#()
		fullBounds: 	nil
		color: 	Color blue
		extension: 	a MorphExtension (370611968)
		mouseFocus: 	nil
		keyboardFocus: 	a SpPluggableButtonMorph(190880000)
		eventListeners: 	nil
		mouseListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(1205@510) mouseUp 4810089 nil]
		targetOffset: 	(66.0@7.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 0 0 0 0 0 nil nil)
		captureBlock: 	nil
		recentModifiers: 	0
		pendingEventQueue: 	WaitfreeQueue with 0 items
		supressNextKeyPress: 	false


HandMorph>>sendMouseEvent:
	Receiver: a HandMorph(337424384)
	Arguments and temporary variables: 
		anEvent: 	[(1205@510) mouseUp 4810089 nil]
	Receiver's instance variables: 
		bounds: 	(1205@510.0) corner: (1221@526.0)
		owner: 	a WorldMorph(341720576) [world]
		submorphs: 	#()
		fullBounds: 	nil
		color: 	Color blue
		extension: 	a MorphExtension (370611968)
		mouseFocus: 	nil
		keyboardFocus: 	a SpPluggableButtonMorph(190880000)
		eventListeners: 	nil
		mouseListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(1205@510) mouseUp 4810089 nil]
		targetOffset: 	(66.0@7.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 0 0 0 0 0 nil nil)
		captureBlock: 	nil
		recentModifiers: 	0
		pendingEventQueue: 	WaitfreeQueue with 0 items
		supressNextKeyPress: 	false


HandMorph>>handleEvent:
	Receiver: a HandMorph(337424384)
	Arguments and temporary variables: 
		anEvent: 	[(1205@510) mouseUp 4810089 nil]
		evt: 	[(1205@510) mouseUp 4810089 nil]
	Receiver's instance variables: 
		bounds: 	(1205@510.0) corner: (1221@526.0)
		owner: 	a WorldMorph(341720576) [world]
		submorphs: 	#()
		fullBounds: 	nil
		color: 	Color blue
		extension: 	a MorphExtension (370611968)
		mouseFocus: 	nil
		keyboardFocus: 	a SpPluggableButtonMorph(190880000)
		eventListeners: 	nil
		mouseListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(1205@510) mouseUp 4810089 nil]
		targetOffset: 	(66.0@7.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 0 0 0 0 0 nil nil)
		captureBlock: 	nil
		recentModifiers: 	0
		pendingEventQueue: 	WaitfreeQueue with 0 items
		supressNextKeyPress: 	false


[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil ]) ifTrue: [
			morphicWorld activeHand handleEvent: anEvent
		]
	] in OSWindowMorphicEventHandler>>dispatchMorphicEvent:
	Receiver: an OSWindowMorphicEventHandler
	Arguments and temporary variables: 
		anEvent: 	[(1205@510) mouseUp 4810089 nil]
	Receiver's instance variables: 
		morphicWorld: 	a WorldMorph(341720576) [world]


WorldState>>runStepMethodsIn:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(341720576) [world]
		queue: 	WaitfreeQueue with 0 items
		nextInQueue: 	[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNo[..]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(337424384))
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap()
		lastStepTime: 	4743121
		lastStepMessage: 	nil
		alarms: 	a Heap()
		lastAlarmTime: 	4810075
		activeHand: 	a HandMorph(337424384)
		currentCursor: 	((CursorWithMask
	extent: (16@16)
	depth: 1
	fromArray: #(
	[..]
		worldRenderer: 	an OSWorldRenderer
		realWindowExtent: 	(1728@1080)
		deferredUIMessages: 	WaitfreeQueue with 0 items


WorldMorph>>runStepMethods
	Receiver: a WorldMorph(341720576) [world]
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1728@1080)
		owner: 	nil
		submorphs: 	an Array(a MenubarMorph(112886016) a TaskbarMorph(279458560) a S[..]
		fullBounds: 	nil
		color: 	(Color r: 0.9403714565004888 g: 0.9403714565004888 b: 0.940371456500[..]
		extension: 	a MorphExtension (1012946432) [other:  (dragEnabled -> true) (dr[..]
		borderWidth: 	0
		borderColor: 	(Color r: 0.8611925708699902 g: 1.0 b: 0.7223851417399805 alph[..]
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil


WorldState>>doOneCycleFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(341720576) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(337424384))
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap()
		lastStepTime: 	4743121
		lastStepMessage: 	nil
		alarms: 	a Heap()
		lastAlarmTime: 	4810075
		activeHand: 	a HandMorph(337424384)
		currentCursor: 	((CursorWithMask
	extent: (16@16)
	depth: 1
	fromArray: #(
	[..]
		worldRenderer: 	an OSWorldRenderer
		realWindowExtent: 	(1728@1080)
		deferredUIMessages: 	WaitfreeQueue with 0 items


WorldMorph>>doOneCycleNow
	Receiver: a WorldMorph(341720576) [world]
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1728@1080)
		owner: 	nil
		submorphs: 	an Array(a MenubarMorph(112886016) a TaskbarMorph(279458560) a S[..]
		fullBounds: 	nil
		color: 	(Color r: 0.9403714565004888 g: 0.9403714565004888 b: 0.940371456500[..]
		extension: 	a MorphExtension (1012946432) [other:  (dragEnabled -> true) (dr[..]
		borderWidth: 	0
		borderColor: 	(Color r: 0.8611925708699902 g: 1.0 b: 0.7223851417399805 alph[..]
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil


WorldMorph>>doOneCycle
	Receiver: a WorldMorph(341720576) [world]
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1728@1080)
		owner: 	nil
		submorphs: 	an Array(a MenubarMorph(112886016) a TaskbarMorph(279458560) a S[..]
		fullBounds: 	nil
		color: 	(Color r: 0.9403714565004888 g: 0.9403714565004888 b: 0.940371456500[..]
		extension: 	a MorphExtension (1012946432) [other:  (dragEnabled -> true) (dr[..]
		borderWidth: 	0
		borderColor: 	(Color r: 0.8611925708699902 g: 1.0 b: 0.7223851417399805 alph[..]
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil


[
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMutex critical: [
			                     self extraWorldList ].
		extraWorldsToDraw do: [ :world | world doOneCycle ].

		(self currentWorld isNotNil and: [
			 (extraWorldsToDraw includes: self currentWorld) not ]) ifTrue: [
			self currentWorld doOneCycle ] ] in WorldMorph class>>doOneCycle
	Receiver: WorldMorph
	Arguments and temporary variables: 
		extraWorldsToDraw: 	#()
	Receiver's instance variables: 
		superclass: 	PasteUpMorph
		methodDict: 	a MethodDictionary(#acceptDroppingMorph:event:->WorldMorph>>#ac[..]
		format: 	65547
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		commentSourcePointer: 	nil
		subclasses: 	{AthensWorldMorph. OSWindowWorldMorph}
		name: 	#WorldMorph
		classPool: 	a Dictionary(#AllowDropFiles->nil #CursorOwnerWorld->a WorldMorp[..]
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Morphic-Core-Worlds'
		announcer: 	nil
		displayScaleFactor: 	1


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMutex critical: [
			  [..]
	Arguments and temporary variables: 
		aBlock: 	[
		self doInterCycleWait
	]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	WorldMorph class>>doOneCycle
		compiledBlock: 	a CompiledBlock: [
		| extraWorldsToDraw |
		extraWorldsToDr[..]
		numArgs: 	0
		receiver: 	WorldMorph


WorldState class>>doDrawCycleWith:
	Receiver: WorldState
	Arguments and temporary variables: 
		aBlock: 	[
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMute[..]
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary(#activeHand->WorldState>>#activeHand #active[..]
		format: 	65548
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		commentSourcePointer: 	nil
		subclasses: 	{AthensWorldState}
		name: 	#WorldState
		classPool: 	a Dictionary(#CanSurrenderToOS->nil #DebugShowDamage->false #Des[..]
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Morphic-Core-Worlds'


WorldMorph class>>doOneCycle
	Receiver: WorldMorph
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		superclass: 	PasteUpMorph
		methodDict: 	a MethodDictionary(#acceptDroppingMorph:event:->WorldMorph>>#ac[..]
		format: 	65547
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		commentSourcePointer: 	nil
		subclasses: 	{AthensWorldMorph. OSWindowWorldMorph}
		name: 	#WorldMorph
		classPool: 	a Dictionary(#AllowDropFiles->nil #CursorOwnerWorld->a WorldMorp[..]
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Morphic-Core-Worlds'
		announcer: 	nil
		displayScaleFactor: 	1


MorphicRenderLoop>>doOneCycle
	Receiver: a MorphicRenderLoop
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
a MorphicRenderLoop

MorphicRenderLoop>>doOneCycleWhile:
	Receiver: a MorphicRenderLoop
	Arguments and temporary variables: 
		aBlock: 	[ true ]
	Receiver's instance variables: 
a MorphicRenderLoop

[ MorphicRenderLoop new doOneCycleWhile: [ true ] ] in MorphicUIManager>>spawnNewProcess
	Receiver: a MorphicUIManager
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		activeTranscript: 	Transcript


[self value.
			"IMPORTANT: Do not step over next line of code. See method comments for details"
			Processor terminateRealActive] in FullBlockClosure(BlockClosure)>>newProcess
	Receiver: [ MorphicRenderLoop new doOneCycleWhile: [ true ] ]
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		outerContext: 	MorphicUIManager>>spawnNewProcess
		compiledBlock: 	a CompiledBlock: [ MorphicRenderLoop new doOneCycleWhile: [ [..]
		numArgs: 	0
		receiver: 	a MorphicUIManager



--- The full stack ---
IceTipLocalRepositoryPanel(Object)>>assert:description:
IceTipLocalRepositoryPanel>>validate
[ 
			dialog validate.
			self repositoryModel updateLocation: dialog location.
			true ] in IceTipRepairLocateRepository>>basicExecute
FullBlockClosure(BlockClosure)>>cull:
SpDialogWindowPresenter>>triggerOkAction
[ :presenter | 
			presenter triggerOkAction.
			presenter close ] in IceTipLocalRepositoryPanel(SpAbstractPresenter)>>initializeDialogWindow:
FullBlockClosure(BlockClosure)>>cull:
[ aBlock cull: self ] in SpDialogWindowPresenter>>addButton:do:
SpButtonPresenter>>performAction
SpMorphicButtonAdapter>>action
SpPluggableButtonMorph(PluggableButtonMorph)>>performAction:
[:m |
		(m containsPoint: evt cursorPoint) ifTrue: [m enabled ifTrue: [ m performAction: evt ]]] in SpPluggableButtonMorph(PluggableButtonMorph)>>mouseUp:
Array(SequenceableCollection)>>do:
SpPluggableButtonMorph(PluggableButtonMorph)>>mouseUp:
SpPluggableButtonMorph(Morph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
SpPluggableButtonMorph(Morph)>>handleEvent:
SpPluggableButtonMorph(Morph)>>handleFocusEvent:
[
		result := focusHolder handleFocusEvent: transformedEvent.
	] in HandMorph>>sendFocusEvent:to:clear:
FullBlockClosure(BlockClosure)>>on:do:
WorldMorph>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil ]) ifTrue: [
			morphicWorld activeHand handleEvent: anEvent
		]
	] in OSWindowMorphicEventHandler>>dispatchMorphicEvent:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycleNow
WorldMorph>>doOneCycle
[
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMutex critical: [
			                     self extraWorldList ].
		extraWorldsToDraw do: [ :world | world doOneCycle ].

		(self currentWorld isNotNil and: [
			 (extraWorldsToDraw includes: self currentWorld) not ]) ifTrue: [
			self currentWorld doOneCycle ] ] in WorldMorph class>>doOneCycle
FullBlockClosure(BlockClosure)>>ensure:
WorldState class>>doDrawCycleWith:
WorldMorph class>>doOneCycle
MorphicRenderLoop>>doOneCycle
MorphicRenderLoop>>doOneCycleWhile:
[ MorphicRenderLoop new doOneCycleWhile: [ true ] ] in MorphicUIManager>>spawnNewProcess
[self value.
			"IMPORTANT: Do not step over next line of code. See method comments for details"
			Processor terminateRealActive] in FullBlockClosure(BlockClosure)>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
AssertionFailure: Project location does not seems to be a valid git repository.
13 November 2023 5:25:54.533929 pm

VM: Mac OS - arm64 - 1000 - CoInterpreter VMMaker-tonel.1 uuid: 902dd483-c0c4-0d00-86f2-0f880df24b96 Oct 23 2023
StackToRegisterMappingCogit VMMaker-tonel.1 uuid: 902dd483-c0c4-0d00-86f2-0f880df24b96 Oct 23 2023
v10.0.8 - Commit: b323c5fb - Date: 2023-10-20 16:02:07 -0400

Image: Pharo11.0.0 [Build information: Pharo-11.0.0+build.710.sha.ea28d8552cac85a7ce1e9c34ab1e7bd45f7b9910 (64 Bit)]

IceTipLocalRepositoryPanel(Object)>>assert:description:
	Receiver: an IceTipLocalRepositoryPanel
	Arguments and temporary variables: 
		aBlock: 	false
		aStringOrBlock: 	'Project location does not seems to be a valid git repository.'
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicGridAdapter)
		announcer: 	an Announcer
		owner: 	a SpDialogWindowPresenter
		adapter: 	a SpMorphicGridAdapter
		needRebuild: 	true
		eventHandler: 	nil
		application: 	a StPharoApplication
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ nil ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Untitled window' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpGridLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		decorations: 	nil
		projectLocationLabel: 	a SpLabelPresenter
		projectLocation: 	an IceTipDirectoryPresenter
		remoteLabel: 	nil
		remoteInputText: 	nil
		repository: 	nil


IceTipLocalRepositoryPanel>>validate
	Receiver: an IceTipLocalRepositoryPanel
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicGridAdapter)
		announcer: 	an Announcer
		owner: 	a SpDialogWindowPresenter
		adapter: 	a SpMorphicGridAdapter
		needRebuild: 	true
		eventHandler: 	nil
		application: 	a StPharoApplication
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ nil ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Untitled window' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpGridLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		decorations: 	nil
		projectLocationLabel: 	a SpLabelPresenter
		projectLocation: 	an IceTipDirectoryPresenter
		remoteLabel: 	nil
		remoteInputText: 	nil
		repository: 	nil


[ 
			dialog validate.
			self repositoryModel updateLocation: dialog location.
			true ] in IceTipRepairLocateRepository>>basicExecute
	Receiver: an IceTipRepairLocateRepository
	Arguments and temporary variables: 
		dialog: 	an IceTipLocalRepositoryPanel
	Receiver's instance variables: 
		context: 	an IceTipRepairRepositoryDialog
		repository: 	nil
		successBlock: 	nil
		repositoryModel: 	an IceTipCachedModel(an IceTipRepositoryModel)


FullBlockClosure(BlockClosure)>>cull:
	Receiver: [ 
			dialog validate.
			self repositoryModel updateLocation: dialog location.
			true ]
	Arguments and temporary variables: 
		anArg: 	a SpDialogWindowPresenter
	Receiver's instance variables: 
		outerContext: 	IceTipRepairLocateRepository>>basicExecute
		compiledBlock: 	a CompiledBlock: [ 
			dialog validate.
			self repositoryMo[..]
		numArgs: 	0
		receiver: 	an IceTipRepairLocateRepository


SpDialogWindowPresenter>>triggerOkAction
	Receiver: a SpDialogWindowPresenter
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicDialogWindowAdapter a SpDialogWind[..]
		announcer: 	an Announcer
		owner: 	nil
		adapter: 	a SpMorphicDialogWindowAdapter
		needRebuild: 	true
		eventHandler: 	nil
		application: 	a StPharoApplication
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ nil ]
		windowIcon: 	an ObservableValueHolder[ Form(16x16x32) ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ true ]
		titleHolder: 	an ObservableValueHolder[ 'Import from existing clone' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ nil ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		borderWidth: 	an ObservableValueHolder[ nil ]
		borderColor: 	an ObservableValueHolder[ nil ]
		dragEnabled: 	an ObservableValueHolder[ false ]
		dropEnabled: 	an ObservableValueHolder[ false ]
		color: 	an ObservableValueHolder[ nil ]
		help: 	an ObservableValueHolder[ nil ]
		enabled: 	an ObservableValueHolder[ true ]
		wantsDrop: 	an ObservableValueHolder[ [ :transfer | self dropEnabled ] ]
		acceptDrop: 	an ObservableValueHolder[ [ :transfer | ] ]
		deferredActions: 	nil
		presenter: 	an ObservableValueHolder[ an IceTipLocalRepositoryPanel ]
		initialPosition: 	an ObservableValueHolder[ nil ]
		initialExtent: 	an ObservableValueHolder[ (500@137) ]
		menu: 	an ObservableValueHolder[ nil ]
		centered: 	an ObservableValueHolder[ false ]
		isClosed: 	an ObservableValueHolder[ false ]
		toolbar: 	an ObservableValueHolder[ nil ]
		statusbar: 	an ObservableValueHolder[ nil ]
		window: 	an ObservableValueHolder[ a SpDialogWindowMorph(272541184) named: I[..]
		decorations: 	an ObservableValueHolder[ true ]
		resizable: 	an ObservableValueHolder[ true ]
		buttons: 	an OrderedCollection(a SpButtonPresenter a SpButtonPresenter)
		okAction: 	[ 
			dialog validate.
			self repositoryModel updateLocation: di[..]
		cancelAction: 	[ 
		cancelled := true.
		self close ]
		cancelled: 	true
		defaultButton: 	nil


[ :presenter | 
			presenter triggerOkAction.
			presenter close ] in IceTipLocalRepositoryPanel(SpAbstractPresenter)>>initializeDialogWindow:
	Receiver: an IceTipLocalRepositoryPanel
	Arguments and temporary variables: 
		aDialogWindowPresenter: 	a SpDialogWindowPresenter
		presenter: 	a SpDialogWindowPresenter
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicGridAdapter)
		announcer: 	an Announcer
		owner: 	a SpDialogWindowPresenter
		adapter: 	a SpMorphicGridAdapter
		needRebuild: 	true
		eventHandler: 	nil
		application: 	a StPharoApplication
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ nil ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Untitled window' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpGridLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		decorations: 	nil
		projectLocationLabel: 	a SpLabelPresenter
		projectLocation: 	an IceTipDirectoryPresenter
		remoteLabel: 	nil
		remoteInputText: 	nil
		repository: 	nil


FullBlockClosure(BlockClosure)>>cull:
	Receiver: [ :presenter | 
			presenter triggerOkAction.
			presenter close ]
	Arguments and temporary variables: 
		anArg: 	a SpDialogWindowPresenter
	Receiver's instance variables: 
		outerContext: 	IceTipLocalRepositoryPanel(SpAbstractPresenter)>>initializeDi[..]
		compiledBlock: 	a CompiledBlock: [ :presenter | 
			presenter triggerOkActio[..]
		numArgs: 	1
		receiver: 	an IceTipLocalRepositoryPanel


[ aBlock cull: self ] in SpDialogWindowPresenter>>addButton:do:
	Receiver: a SpDialogWindowPresenter
	Arguments and temporary variables: 
		aString: 	'Ok'
		aBlock: 	[ :presenter | 
			presenter triggerOkAction.
			presenter close ]
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicDialogWindowAdapter a SpDialogWind[..]
		announcer: 	an Announcer
		owner: 	nil
		adapter: 	a SpMorphicDialogWindowAdapter
		needRebuild: 	true
		eventHandler: 	nil
		application: 	a StPharoApplication
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ nil ]
		windowIcon: 	an ObservableValueHolder[ Form(16x16x32) ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ true ]
		titleHolder: 	an ObservableValueHolder[ 'Import from existing clone' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ nil ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		borderWidth: 	an ObservableValueHolder[ nil ]
		borderColor: 	an ObservableValueHolder[ nil ]
		dragEnabled: 	an ObservableValueHolder[ false ]
		dropEnabled: 	an ObservableValueHolder[ false ]
		color: 	an ObservableValueHolder[ nil ]
		help: 	an ObservableValueHolder[ nil ]
		enabled: 	an ObservableValueHolder[ true ]
		wantsDrop: 	an ObservableValueHolder[ [ :transfer | self dropEnabled ] ]
		acceptDrop: 	an ObservableValueHolder[ [ :transfer | ] ]
		deferredActions: 	nil
		presenter: 	an ObservableValueHolder[ an IceTipLocalRepositoryPanel ]
		initialPosition: 	an ObservableValueHolder[ nil ]
		initialExtent: 	an ObservableValueHolder[ (500@137) ]
		menu: 	an ObservableValueHolder[ nil ]
		centered: 	an ObservableValueHolder[ false ]
		isClosed: 	an ObservableValueHolder[ false ]
		toolbar: 	an ObservableValueHolder[ nil ]
		statusbar: 	an ObservableValueHolder[ nil ]
		window: 	an ObservableValueHolder[ a SpDialogWindowMorph(272541184) named: I[..]
		decorations: 	an ObservableValueHolder[ true ]
		resizable: 	an ObservableValueHolder[ true ]
		buttons: 	an OrderedCollection(a SpButtonPresenter a SpButtonPresenter)
		okAction: 	[ 
			dialog validate.
			self repositoryModel updateLocation: di[..]
		cancelAction: 	[ 
		cancelled := true.
		self close ]
		cancelled: 	true
		defaultButton: 	nil


SpButtonPresenter>>performAction
	Receiver: a SpButtonPresenter
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicButtonAdapter)
		announcer: 	an Announcer
		owner: 	a SpButtonBarPresenter
		adapter: 	a SpMorphicButtonAdapter
		needRebuild: 	true
		eventHandler: 	nil
		application: 	nil
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ nil ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Button' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpAbstractWidgetLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		borderWidth: 	an ObservableValueHolder[ nil ]
		borderColor: 	an ObservableValueHolder[ nil ]
		dragEnabled: 	an ObservableValueHolder[ false ]
		dropEnabled: 	an ObservableValueHolder[ false ]
		color: 	an ObservableValueHolder[ nil ]
		help: 	an ObservableValueHolder[ nil ]
		enabled: 	an ObservableValueHolder[ true ]
		wantsDrop: 	an ObservableValueHolder[ [ :transfer | self dropEnabled ] ]
		acceptDrop: 	an ObservableValueHolder[ [ :transfer | ] ]
		deferredActions: 	nil
		icon: 	an ObservableValueHolder[ nil ]
		label: 	an ObservableValueHolder[ 'Ok' ]
		action: 	an ObservableValueHolder[ [ aBlock cull: self ] ]
		actionPerformed: 	an ObservableValueHolder[ nil ]
		askBeforeChanging: 	an ObservableValueHolder[ false ]
		font: 	an ObservableValueHolder[ nil ]
		shortcut: 	an ObservableValueHolder[ nil ]
		state: 	an ObservableValueHolder[ false ]
		contextMenu: 	an ObservableValueHolder[ nil ]


SpMorphicButtonAdapter>>action
	Receiver: a SpMorphicButtonAdapter
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpPluggableButtonMorph(190880000))
		announcer: 	nil
		model: 	a SpButtonPresenter
		widget: 	a SpPluggableButtonMorph(190880000)
		selector: 	nil
		owner: 	a SpButtonPresenter
		unsubscribed: 	false
		subMenuWidget: 	nil
		styleName: 	nil


SpPluggableButtonMorph(PluggableButtonMorph)>>performAction:
	Receiver: a SpPluggableButtonMorph(190880000)
	Arguments and temporary variables: 
		event: 	[(1103@815) mouseUp 4872662 nil]
	Receiver's instance variables: 
		bounds: 	(1079.0@803.0) corner: (1179.0@833.0)
		owner: 	a PanelMorph(996435712)
		submorphs: 	an Array(an AlignmentMorph(603547904))
		fullBounds: 	nil
		color: 	(Color r: 0.9012707722385142 g: 0.9012707722385142 b: 0.901270772238[..]
		extension: 	a MorphExtension (702656000) [eventHandler = a MorphicEventHandl[..]
		borderWidth: 	1
		borderColor: 	#simple
		model: 	a SpMorphicButtonAdapter
		label: 	'Ok'
		icon: 	nil
		getIconSelector: 	nil
		getStateSelector: 	#state
		actionSelector: 	#action
		font: 	nil
		getLabelSelector: 	#label
		getMenuSelector: 	#menu:
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	#enabled
		getFontSelector: 	#font
		labelMorph: 	a LabelMorph(527080448)'Ok'
		iconMorph: 	nil
		iconPosition: 	#left
		lastState: 	false
		backgroundColor: 	nil


[:m |
		(m containsPoint: evt cursorPoint) ifTrue: [m enabled ifTrue: [ m performAction: evt ]]] in SpPluggableButtonMorph(PluggableButtonMorph)>>mouseUp:
	Receiver: a SpPluggableButtonMorph(190880000)
	Arguments and temporary variables: 
		evt: 	[(1103@815) mouseUp 4872662 nil]
		all: 	an Array(a SpPluggableButtonMorph(1071948288) a SpPluggableButtonMorph[..]
		m: 	a SpPluggableButtonMorph(190880000)
	Receiver's instance variables: 
		bounds: 	(1079.0@803.0) corner: (1179.0@833.0)
		owner: 	a PanelMorph(996435712)
		submorphs: 	an Array(an AlignmentMorph(603547904))
		fullBounds: 	nil
		color: 	(Color r: 0.9012707722385142 g: 0.9012707722385142 b: 0.901270772238[..]
		extension: 	a MorphExtension (702656000) [eventHandler = a MorphicEventHandl[..]
		borderWidth: 	1
		borderColor: 	#simple
		model: 	a SpMorphicButtonAdapter
		label: 	'Ok'
		icon: 	nil
		getIconSelector: 	nil
		getStateSelector: 	#state
		actionSelector: 	#action
		font: 	nil
		getLabelSelector: 	#label
		getMenuSelector: 	#menu:
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	#enabled
		getFontSelector: 	#font
		labelMorph: 	a LabelMorph(527080448)'Ok'
		iconMorph: 	nil
		iconPosition: 	#left
		lastState: 	false
		backgroundColor: 	nil


Array(SequenceableCollection)>>do:
	Receiver: an Array(a SpPluggableButtonMorph(1071948288) a SpPluggableButtonMorph(190880000))
	Arguments and temporary variables: 
		aBlock: 	[:m |
		(m containsPoint: evt cursorPoint) ifTrue: [m enabled ifTru[..]
		index: 	2
	Receiver's instance variables: 
an Array(a SpPluggableButtonMorph(1071948288) a SpPluggableButtonMorph(190880000))

SpPluggableButtonMorph(PluggableButtonMorph)>>mouseUp:
	Receiver: a SpPluggableButtonMorph(190880000)
	Arguments and temporary variables: 
		evt: 	[(1103@815) mouseUp 4872662 nil]
		all: 	an Array(a SpPluggableButtonMorph(1071948288) a SpPluggableButtonMorph[..]
	Receiver's instance variables: 
		bounds: 	(1079.0@803.0) corner: (1179.0@833.0)
		owner: 	a PanelMorph(996435712)
		submorphs: 	an Array(an AlignmentMorph(603547904))
		fullBounds: 	nil
		color: 	(Color r: 0.9012707722385142 g: 0.9012707722385142 b: 0.901270772238[..]
		extension: 	a MorphExtension (702656000) [eventHandler = a MorphicEventHandl[..]
		borderWidth: 	1
		borderColor: 	#simple
		model: 	a SpMorphicButtonAdapter
		label: 	'Ok'
		icon: 	nil
		getIconSelector: 	nil
		getStateSelector: 	#state
		actionSelector: 	#action
		font: 	nil
		getLabelSelector: 	#label
		getMenuSelector: 	#menu:
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	#enabled
		getFontSelector: 	#font
		labelMorph: 	a LabelMorph(527080448)'Ok'
		iconMorph: 	nil
		iconPosition: 	#left
		lastState: 	false
		backgroundColor: 	nil


SpPluggableButtonMorph(Morph)>>handleMouseUp:
	Receiver: a SpPluggableButtonMorph(190880000)
	Arguments and temporary variables: 
		anEvent: 	[(1103@815) mouseUp 4872662 nil]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(1079.0@803.0) corner: (1179.0@833.0)
		owner: 	a PanelMorph(996435712)
		submorphs: 	an Array(an AlignmentMorph(603547904))
		fullBounds: 	nil
		color: 	(Color r: 0.9012707722385142 g: 0.9012707722385142 b: 0.901270772238[..]
		extension: 	a MorphExtension (702656000) [eventHandler = a MorphicEventHandl[..]
		borderWidth: 	1
		borderColor: 	#simple
		model: 	a SpMorphicButtonAdapter
		label: 	'Ok'
		icon: 	nil
		getIconSelector: 	nil
		getStateSelector: 	#state
		actionSelector: 	#action
		font: 	nil
		getLabelSelector: 	#label
		getMenuSelector: 	#menu:
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	#enabled
		getFontSelector: 	#font
		labelMorph: 	a LabelMorph(527080448)'Ok'
		iconMorph: 	nil
		iconPosition: 	#left
		lastState: 	false
		backgroundColor: 	nil


MouseButtonEvent>>sentTo:
	Receiver: [(1103@815) mouseUp 4872662 nil]
	Arguments and temporary variables: 
		anObject: 	a SpPluggableButtonMorph(190880000)
	Receiver's instance variables: 
		timeStamp: 	4872662
		source: 	a HandMorph(337424384)
		windowIndex: 	nil
		type: 	#mouseUp
		buttons: 	0
		position: 	(1103@815)
		handler: 	nil
		wasHandled: 	true
		whichButton: 	4


SpPluggableButtonMorph(Morph)>>handleEvent:
	Receiver: a SpPluggableButtonMorph(190880000)
	Arguments and temporary variables: 
		anEvent: 	[(1103@815) mouseUp 4872662 nil]
	Receiver's instance variables: 
		bounds: 	(1079.0@803.0) corner: (1179.0@833.0)
		owner: 	a PanelMorph(996435712)
		submorphs: 	an Array(an AlignmentMorph(603547904))
		fullBounds: 	nil
		color: 	(Color r: 0.9012707722385142 g: 0.9012707722385142 b: 0.901270772238[..]
		extension: 	a MorphExtension (702656000) [eventHandler = a MorphicEventHandl[..]
		borderWidth: 	1
		borderColor: 	#simple
		model: 	a SpMorphicButtonAdapter
		label: 	'Ok'
		icon: 	nil
		getIconSelector: 	nil
		getStateSelector: 	#state
		actionSelector: 	#action
		font: 	nil
		getLabelSelector: 	#label
		getMenuSelector: 	#menu:
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	#enabled
		getFontSelector: 	#font
		labelMorph: 	a LabelMorph(527080448)'Ok'
		iconMorph: 	nil
		iconPosition: 	#left
		lastState: 	false
		backgroundColor: 	nil


SpPluggableButtonMorph(Morph)>>handleFocusEvent:
	Receiver: a SpPluggableButtonMorph(190880000)
	Arguments and temporary variables: 
		anEvent: 	[(1103@815) mouseUp 4872662 nil]
	Receiver's instance variables: 
		bounds: 	(1079.0@803.0) corner: (1179.0@833.0)
		owner: 	a PanelMorph(996435712)
		submorphs: 	an Array(an AlignmentMorph(603547904))
		fullBounds: 	nil
		color: 	(Color r: 0.9012707722385142 g: 0.9012707722385142 b: 0.901270772238[..]
		extension: 	a MorphExtension (702656000) [eventHandler = a MorphicEventHandl[..]
		borderWidth: 	1
		borderColor: 	#simple
		model: 	a SpMorphicButtonAdapter
		label: 	'Ok'
		icon: 	nil
		getIconSelector: 	nil
		getStateSelector: 	#state
		actionSelector: 	#action
		font: 	nil
		getLabelSelector: 	#label
		getMenuSelector: 	#menu:
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	#enabled
		getFontSelector: 	#font
		labelMorph: 	a LabelMorph(527080448)'Ok'
		iconMorph: 	nil
		iconPosition: 	#left
		lastState: 	false
		backgroundColor: 	nil


[
		result := focusHolder handleFocusEvent: transformedEvent.
	] in HandMorph>>sendFocusEvent:to:clear:
	Receiver: a HandMorph(337424384)
	Arguments and temporary variables: 
		anEvent: 	[(1103@815) mouseUp 4872662 nil]
		focusHolder: 	a SpPluggableButtonMorph(190880000)
		aBlock: 	[self mouseFocus: nil]
		w: 	a WorldMorph(341720576) [world]
		transformedEvent: 	[(1103@815) mouseUp 4872662 nil]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(1103@815.0) corner: (1119@831.0)
		owner: 	a WorldMorph(341720576) [world]
		submorphs: 	#()
		fullBounds: 	(1103@815.0) corner: (1119@831.0)
		color: 	Color blue
		extension: 	a MorphExtension (370611968)
		mouseFocus: 	nil
		keyboardFocus: 	a SpPluggableButtonMorph(190880000)
		eventListeners: 	nil
		mouseListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(1103@815) mouseUp 4872662 nil]
		targetOffset: 	(24.0@12.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 0 0 0 0 0 nil nil)
		captureBlock: 	nil
		recentModifiers: 	0
		pendingEventQueue: 	WaitfreeQueue with 0 items
		supressNextKeyPress: 	false


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
		result := focusHolder handleFocusEvent: transformedEvent.
	]
	Arguments and temporary variables: 
		exception: 	Error
		handlerAction: 	[ :ex |
			ActiveWorld := priorWorld.
			ex pass ]
	Receiver's instance variables: 
		outerContext: 	HandMorph>>sendFocusEvent:to:clear:
		compiledBlock: 	a CompiledBlock: [
		result := focusHolder handleFocusEvent:[..]
		numArgs: 	0
		receiver: 	a HandMorph(337424384)


WorldMorph>>becomeActiveDuring:
	Receiver: a WorldMorph(341720576) [world]
	Arguments and temporary variables: 
		aBlock: 	[
		result := focusHolder handleFocusEvent: transformedEvent.
	]
		priorWorld: 	a WorldMorph(341720576) [world]
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1728@1080)
		owner: 	nil
		submorphs: 	an Array(a MenubarMorph(112886016) a TaskbarMorph(279458560) a S[..]
		fullBounds: 	(0@0) corner: (1728@1080)
		color: 	(Color r: 0.9403714565004888 g: 0.9403714565004888 b: 0.940371456500[..]
		extension: 	a MorphExtension (1012946432) [other:  (dragEnabled -> true) (dr[..]
		borderWidth: 	0
		borderColor: 	(Color r: 0.8611925708699902 g: 1.0 b: 0.7223851417399805 alph[..]
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil


HandMorph>>sendFocusEvent:to:clear:
	Receiver: a HandMorph(337424384)
	Arguments and temporary variables: 
		result: 	nil
		anEvent: 	[(1103@815) mouseUp 4872662 nil]
		focusHolder: 	a SpPluggableButtonMorph(190880000)
		aBlock: 	[self mouseFocus: nil]
		w: 	a WorldMorph(341720576) [world]
		transformedEvent: 	[(1103@815) mouseUp 4872662 nil]
	Receiver's instance variables: 
		bounds: 	(1103@815.0) corner: (1119@831.0)
		owner: 	a WorldMorph(341720576) [world]
		submorphs: 	#()
		fullBounds: 	(1103@815.0) corner: (1119@831.0)
		color: 	Color blue
		extension: 	a MorphExtension (370611968)
		mouseFocus: 	nil
		keyboardFocus: 	a SpPluggableButtonMorph(190880000)
		eventListeners: 	nil
		mouseListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(1103@815) mouseUp 4872662 nil]
		targetOffset: 	(24.0@12.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 0 0 0 0 0 nil nil)
		captureBlock: 	nil
		recentModifiers: 	0
		pendingEventQueue: 	WaitfreeQueue with 0 items
		supressNextKeyPress: 	false


HandMorph>>sendEvent:focus:clear:
	Receiver: a HandMorph(337424384)
	Arguments and temporary variables: 
		anEvent: 	[(1103@815) mouseUp 4872662 nil]
		focusHolder: 	a SpPluggableButtonMorph(190880000)
		aBlock: 	[self mouseFocus: nil]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(1103@815.0) corner: (1119@831.0)
		owner: 	a WorldMorph(341720576) [world]
		submorphs: 	#()
		fullBounds: 	(1103@815.0) corner: (1119@831.0)
		color: 	Color blue
		extension: 	a MorphExtension (370611968)
		mouseFocus: 	nil
		keyboardFocus: 	a SpPluggableButtonMorph(190880000)
		eventListeners: 	nil
		mouseListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(1103@815) mouseUp 4872662 nil]
		targetOffset: 	(24.0@12.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 0 0 0 0 0 nil nil)
		captureBlock: 	nil
		recentModifiers: 	0
		pendingEventQueue: 	WaitfreeQueue with 0 items
		supressNextKeyPress: 	false


HandMorph>>sendMouseEvent:
	Receiver: a HandMorph(337424384)
	Arguments and temporary variables: 
		anEvent: 	[(1103@815) mouseUp 4872662 nil]
	Receiver's instance variables: 
		bounds: 	(1103@815.0) corner: (1119@831.0)
		owner: 	a WorldMorph(341720576) [world]
		submorphs: 	#()
		fullBounds: 	(1103@815.0) corner: (1119@831.0)
		color: 	Color blue
		extension: 	a MorphExtension (370611968)
		mouseFocus: 	nil
		keyboardFocus: 	a SpPluggableButtonMorph(190880000)
		eventListeners: 	nil
		mouseListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(1103@815) mouseUp 4872662 nil]
		targetOffset: 	(24.0@12.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 0 0 0 0 0 nil nil)
		captureBlock: 	nil
		recentModifiers: 	0
		pendingEventQueue: 	WaitfreeQueue with 0 items
		supressNextKeyPress: 	false


HandMorph>>handleEvent:
	Receiver: a HandMorph(337424384)
	Arguments and temporary variables: 
		anEvent: 	[(1103@815) mouseUp 4872662 nil]
		evt: 	[(1103@815) mouseUp 4872662 nil]
	Receiver's instance variables: 
		bounds: 	(1103@815.0) corner: (1119@831.0)
		owner: 	a WorldMorph(341720576) [world]
		submorphs: 	#()
		fullBounds: 	(1103@815.0) corner: (1119@831.0)
		color: 	Color blue
		extension: 	a MorphExtension (370611968)
		mouseFocus: 	nil
		keyboardFocus: 	a SpPluggableButtonMorph(190880000)
		eventListeners: 	nil
		mouseListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(1103@815) mouseUp 4872662 nil]
		targetOffset: 	(24.0@12.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 0 0 0 0 0 nil nil)
		captureBlock: 	nil
		recentModifiers: 	0
		pendingEventQueue: 	WaitfreeQueue with 0 items
		supressNextKeyPress: 	false


[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil ]) ifTrue: [
			morphicWorld activeHand handleEvent: anEvent
		]
	] in OSWindowMorphicEventHandler>>dispatchMorphicEvent:
	Receiver: an OSWindowMorphicEventHandler
	Arguments and temporary variables: 
		anEvent: 	[(1103@815) mouseUp 4872662 nil]
	Receiver's instance variables: 
		morphicWorld: 	a WorldMorph(341720576) [world]


WorldState>>runStepMethodsIn:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(341720576) [world]
		queue: 	WaitfreeQueue with 0 items
		nextInQueue: 	[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNo[..]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(337424384))
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap()
		lastStepTime: 	4743121
		lastStepMessage: 	nil
		alarms: 	a Heap()
		lastAlarmTime: 	4872640
		activeHand: 	a HandMorph(337424384)
		currentCursor: 	((CursorWithMask
	extent: (16@16)
	depth: 1
	fromArray: #(
	[..]
		worldRenderer: 	an OSWorldRenderer
		realWindowExtent: 	(1728@1080)
		deferredUIMessages: 	WaitfreeQueue with 0 items


WorldMorph>>runStepMethods
	Receiver: a WorldMorph(341720576) [world]
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1728@1080)
		owner: 	nil
		submorphs: 	an Array(a MenubarMorph(112886016) a TaskbarMorph(279458560) a S[..]
		fullBounds: 	(0@0) corner: (1728@1080)
		color: 	(Color r: 0.9403714565004888 g: 0.9403714565004888 b: 0.940371456500[..]
		extension: 	a MorphExtension (1012946432) [other:  (dragEnabled -> true) (dr[..]
		borderWidth: 	0
		borderColor: 	(Color r: 0.8611925708699902 g: 1.0 b: 0.7223851417399805 alph[..]
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil


WorldState>>doOneCycleFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(341720576) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(337424384))
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap()
		lastStepTime: 	4743121
		lastStepMessage: 	nil
		alarms: 	a Heap()
		lastAlarmTime: 	4872640
		activeHand: 	a HandMorph(337424384)
		currentCursor: 	((CursorWithMask
	extent: (16@16)
	depth: 1
	fromArray: #(
	[..]
		worldRenderer: 	an OSWorldRenderer
		realWindowExtent: 	(1728@1080)
		deferredUIMessages: 	WaitfreeQueue with 0 items


WorldMorph>>doOneCycleNow
	Receiver: a WorldMorph(341720576) [world]
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1728@1080)
		owner: 	nil
		submorphs: 	an Array(a MenubarMorph(112886016) a TaskbarMorph(279458560) a S[..]
		fullBounds: 	(0@0) corner: (1728@1080)
		color: 	(Color r: 0.9403714565004888 g: 0.9403714565004888 b: 0.940371456500[..]
		extension: 	a MorphExtension (1012946432) [other:  (dragEnabled -> true) (dr[..]
		borderWidth: 	0
		borderColor: 	(Color r: 0.8611925708699902 g: 1.0 b: 0.7223851417399805 alph[..]
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil


WorldMorph>>doOneCycle
	Receiver: a WorldMorph(341720576) [world]
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1728@1080)
		owner: 	nil
		submorphs: 	an Array(a MenubarMorph(112886016) a TaskbarMorph(279458560) a S[..]
		fullBounds: 	(0@0) corner: (1728@1080)
		color: 	(Color r: 0.9403714565004888 g: 0.9403714565004888 b: 0.940371456500[..]
		extension: 	a MorphExtension (1012946432) [other:  (dragEnabled -> true) (dr[..]
		borderWidth: 	0
		borderColor: 	(Color r: 0.8611925708699902 g: 1.0 b: 0.7223851417399805 alph[..]
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil


[
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMutex critical: [
			                     self extraWorldList ].
		extraWorldsToDraw do: [ :world | world doOneCycle ].

		(self currentWorld isNotNil and: [
			 (extraWorldsToDraw includes: self currentWorld) not ]) ifTrue: [
			self currentWorld doOneCycle ] ] in WorldMorph class>>doOneCycle
	Receiver: WorldMorph
	Arguments and temporary variables: 
		extraWorldsToDraw: 	#()
	Receiver's instance variables: 
		superclass: 	PasteUpMorph
		methodDict: 	a MethodDictionary(#acceptDroppingMorph:event:->WorldMorph>>#ac[..]
		format: 	65547
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		commentSourcePointer: 	nil
		subclasses: 	{AthensWorldMorph. OSWindowWorldMorph}
		name: 	#WorldMorph
		classPool: 	a Dictionary(#AllowDropFiles->nil #CursorOwnerWorld->a WorldMorp[..]
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Morphic-Core-Worlds'
		announcer: 	nil
		displayScaleFactor: 	1


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMutex critical: [
			  [..]
	Arguments and temporary variables: 
		aBlock: 	[
		self doInterCycleWait
	]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	WorldMorph class>>doOneCycle
		compiledBlock: 	a CompiledBlock: [
		| extraWorldsToDraw |
		extraWorldsToDr[..]
		numArgs: 	0
		receiver: 	WorldMorph


WorldState class>>doDrawCycleWith:
	Receiver: WorldState
	Arguments and temporary variables: 
		aBlock: 	[
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMute[..]
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary(#activeHand->WorldState>>#activeHand #active[..]
		format: 	65548
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		commentSourcePointer: 	nil
		subclasses: 	{AthensWorldState}
		name: 	#WorldState
		classPool: 	a Dictionary(#CanSurrenderToOS->nil #DebugShowDamage->false #Des[..]
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Morphic-Core-Worlds'


WorldMorph class>>doOneCycle
	Receiver: WorldMorph
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		superclass: 	PasteUpMorph
		methodDict: 	a MethodDictionary(#acceptDroppingMorph:event:->WorldMorph>>#ac[..]
		format: 	65547
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		commentSourcePointer: 	nil
		subclasses: 	{AthensWorldMorph. OSWindowWorldMorph}
		name: 	#WorldMorph
		classPool: 	a Dictionary(#AllowDropFiles->nil #CursorOwnerWorld->a WorldMorp[..]
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Morphic-Core-Worlds'
		announcer: 	nil
		displayScaleFactor: 	1


MorphicRenderLoop>>doOneCycle
	Receiver: a MorphicRenderLoop
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
a MorphicRenderLoop

MorphicRenderLoop>>doOneCycleWhile:
	Receiver: a MorphicRenderLoop
	Arguments and temporary variables: 
		aBlock: 	[ true ]
	Receiver's instance variables: 
a MorphicRenderLoop

[ MorphicRenderLoop new doOneCycleWhile: [ true ] ] in MorphicUIManager>>spawnNewProcess
	Receiver: a MorphicUIManager
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		activeTranscript: 	nil


[self value.
			"IMPORTANT: Do not step over next line of code. See method comments for details"
			Processor terminateRealActive] in FullBlockClosure(BlockClosure)>>newProcess
	Receiver: [ MorphicRenderLoop new doOneCycleWhile: [ true ] ]
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		outerContext: 	MorphicUIManager>>spawnNewProcess
		compiledBlock: 	a CompiledBlock: [ MorphicRenderLoop new doOneCycleWhile: [ [..]
		numArgs: 	0
		receiver: 	a MorphicUIManager



--- The full stack ---
IceTipLocalRepositoryPanel(Object)>>assert:description:
IceTipLocalRepositoryPanel>>validate
[ 
			dialog validate.
			self repositoryModel updateLocation: dialog location.
			true ] in IceTipRepairLocateRepository>>basicExecute
FullBlockClosure(BlockClosure)>>cull:
SpDialogWindowPresenter>>triggerOkAction
[ :presenter | 
			presenter triggerOkAction.
			presenter close ] in IceTipLocalRepositoryPanel(SpAbstractPresenter)>>initializeDialogWindow:
FullBlockClosure(BlockClosure)>>cull:
[ aBlock cull: self ] in SpDialogWindowPresenter>>addButton:do:
SpButtonPresenter>>performAction
SpMorphicButtonAdapter>>action
SpPluggableButtonMorph(PluggableButtonMorph)>>performAction:
[:m |
		(m containsPoint: evt cursorPoint) ifTrue: [m enabled ifTrue: [ m performAction: evt ]]] in SpPluggableButtonMorph(PluggableButtonMorph)>>mouseUp:
Array(SequenceableCollection)>>do:
SpPluggableButtonMorph(PluggableButtonMorph)>>mouseUp:
SpPluggableButtonMorph(Morph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
SpPluggableButtonMorph(Morph)>>handleEvent:
SpPluggableButtonMorph(Morph)>>handleFocusEvent:
[
		result := focusHolder handleFocusEvent: transformedEvent.
	] in HandMorph>>sendFocusEvent:to:clear:
FullBlockClosure(BlockClosure)>>on:do:
WorldMorph>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil ]) ifTrue: [
			morphicWorld activeHand handleEvent: anEvent
		]
	] in OSWindowMorphicEventHandler>>dispatchMorphicEvent:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycleNow
WorldMorph>>doOneCycle
[
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMutex critical: [
			                     self extraWorldList ].
		extraWorldsToDraw do: [ :world | world doOneCycle ].

		(self currentWorld isNotNil and: [
			 (extraWorldsToDraw includes: self currentWorld) not ]) ifTrue: [
			self currentWorld doOneCycle ] ] in WorldMorph class>>doOneCycle
FullBlockClosure(BlockClosure)>>ensure:
WorldState class>>doDrawCycleWith:
WorldMorph class>>doOneCycle
MorphicRenderLoop>>doOneCycle
MorphicRenderLoop>>doOneCycleWhile:
[ MorphicRenderLoop new doOneCycleWhile: [ true ] ] in MorphicUIManager>>spawnNewProcess
[self value.
			"IMPORTANT: Do not step over next line of code. See method comments for details"
			Processor terminateRealActive] in FullBlockClosure(BlockClosure)>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
AssertionFailure: Project location does not seems to be a valid git repository.
13 November 2023 5:25:54.556091 pm

VM: Mac OS - arm64 - 1000 - CoInterpreter VMMaker-tonel.1 uuid: 902dd483-c0c4-0d00-86f2-0f880df24b96 Oct 23 2023
StackToRegisterMappingCogit VMMaker-tonel.1 uuid: 902dd483-c0c4-0d00-86f2-0f880df24b96 Oct 23 2023
v10.0.8 - Commit: b323c5fb - Date: 2023-10-20 16:02:07 -0400

Image: Pharo11.0.0 [Build information: Pharo-11.0.0+build.710.sha.ea28d8552cac85a7ce1e9c34ab1e7bd45f7b9910 (64 Bit)]

IceTipLocalRepositoryPanel(Object)>>assert:description:
	Receiver: an IceTipLocalRepositoryPanel
	Arguments and temporary variables: 
		aBlock: 	false
		aStringOrBlock: 	'Project location does not seems to be a valid git repository.'
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicGridAdapter)
		announcer: 	an Announcer
		owner: 	a SpDialogWindowPresenter
		adapter: 	a SpMorphicGridAdapter
		needRebuild: 	true
		eventHandler: 	nil
		application: 	a StPharoApplication
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ nil ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Untitled window' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpGridLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		decorations: 	nil
		projectLocationLabel: 	a SpLabelPresenter
		projectLocation: 	an IceTipDirectoryPresenter
		remoteLabel: 	nil
		remoteInputText: 	nil
		repository: 	nil


IceTipLocalRepositoryPanel>>validate
	Receiver: an IceTipLocalRepositoryPanel
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicGridAdapter)
		announcer: 	an Announcer
		owner: 	a SpDialogWindowPresenter
		adapter: 	a SpMorphicGridAdapter
		needRebuild: 	true
		eventHandler: 	nil
		application: 	a StPharoApplication
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ nil ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Untitled window' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpGridLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		decorations: 	nil
		projectLocationLabel: 	a SpLabelPresenter
		projectLocation: 	an IceTipDirectoryPresenter
		remoteLabel: 	nil
		remoteInputText: 	nil
		repository: 	nil


[ 
			dialog validate.
			self repositoryModel updateLocation: dialog location.
			true ] in IceTipRepairLocateRepository>>basicExecute
	Receiver: an IceTipRepairLocateRepository
	Arguments and temporary variables: 
		dialog: 	an IceTipLocalRepositoryPanel
	Receiver's instance variables: 
		context: 	an IceTipRepairRepositoryDialog
		repository: 	nil
		successBlock: 	nil
		repositoryModel: 	an IceTipCachedModel(an IceTipRepositoryModel)


FullBlockClosure(BlockClosure)>>cull:
	Receiver: [ 
			dialog validate.
			self repositoryModel updateLocation: dialog location.
			true ]
	Arguments and temporary variables: 
		anArg: 	a SpDialogWindowPresenter
	Receiver's instance variables: 
		outerContext: 	IceTipRepairLocateRepository>>basicExecute
		compiledBlock: 	a CompiledBlock: [ 
			dialog validate.
			self repositoryMo[..]
		numArgs: 	0
		receiver: 	an IceTipRepairLocateRepository


SpDialogWindowPresenter>>triggerOkAction
	Receiver: a SpDialogWindowPresenter
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicDialogWindowAdapter a SpDialogWind[..]
		announcer: 	an Announcer
		owner: 	nil
		adapter: 	a SpMorphicDialogWindowAdapter
		needRebuild: 	true
		eventHandler: 	nil
		application: 	a StPharoApplication
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ nil ]
		windowIcon: 	an ObservableValueHolder[ Form(16x16x32) ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ true ]
		titleHolder: 	an ObservableValueHolder[ 'Import from existing clone' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ nil ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		borderWidth: 	an ObservableValueHolder[ nil ]
		borderColor: 	an ObservableValueHolder[ nil ]
		dragEnabled: 	an ObservableValueHolder[ false ]
		dropEnabled: 	an ObservableValueHolder[ false ]
		color: 	an ObservableValueHolder[ nil ]
		help: 	an ObservableValueHolder[ nil ]
		enabled: 	an ObservableValueHolder[ true ]
		wantsDrop: 	an ObservableValueHolder[ [ :transfer | self dropEnabled ] ]
		acceptDrop: 	an ObservableValueHolder[ [ :transfer | ] ]
		deferredActions: 	nil
		presenter: 	an ObservableValueHolder[ an IceTipLocalRepositoryPanel ]
		initialPosition: 	an ObservableValueHolder[ nil ]
		initialExtent: 	an ObservableValueHolder[ (500@137) ]
		menu: 	an ObservableValueHolder[ nil ]
		centered: 	an ObservableValueHolder[ false ]
		isClosed: 	an ObservableValueHolder[ false ]
		toolbar: 	an ObservableValueHolder[ nil ]
		statusbar: 	an ObservableValueHolder[ nil ]
		window: 	an ObservableValueHolder[ a SpDialogWindowMorph(272541184) named: I[..]
		decorations: 	an ObservableValueHolder[ true ]
		resizable: 	an ObservableValueHolder[ true ]
		buttons: 	an OrderedCollection(a SpButtonPresenter a SpButtonPresenter)
		okAction: 	[ 
			dialog validate.
			self repositoryModel updateLocation: di[..]
		cancelAction: 	[ 
		cancelled := true.
		self close ]
		cancelled: 	true
		defaultButton: 	nil


[ :presenter | 
			presenter triggerOkAction.
			presenter close ] in IceTipLocalRepositoryPanel(SpAbstractPresenter)>>initializeDialogWindow:
	Receiver: an IceTipLocalRepositoryPanel
	Arguments and temporary variables: 
		aDialogWindowPresenter: 	a SpDialogWindowPresenter
		presenter: 	a SpDialogWindowPresenter
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicGridAdapter)
		announcer: 	an Announcer
		owner: 	a SpDialogWindowPresenter
		adapter: 	a SpMorphicGridAdapter
		needRebuild: 	true
		eventHandler: 	nil
		application: 	a StPharoApplication
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ nil ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Untitled window' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpGridLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		decorations: 	nil
		projectLocationLabel: 	a SpLabelPresenter
		projectLocation: 	an IceTipDirectoryPresenter
		remoteLabel: 	nil
		remoteInputText: 	nil
		repository: 	nil


FullBlockClosure(BlockClosure)>>cull:
	Receiver: [ :presenter | 
			presenter triggerOkAction.
			presenter close ]
	Arguments and temporary variables: 
		anArg: 	a SpDialogWindowPresenter
	Receiver's instance variables: 
		outerContext: 	IceTipLocalRepositoryPanel(SpAbstractPresenter)>>initializeDi[..]
		compiledBlock: 	a CompiledBlock: [ :presenter | 
			presenter triggerOkActio[..]
		numArgs: 	1
		receiver: 	an IceTipLocalRepositoryPanel


[ aBlock cull: self ] in SpDialogWindowPresenter>>addButton:do:
	Receiver: a SpDialogWindowPresenter
	Arguments and temporary variables: 
		aString: 	'Ok'
		aBlock: 	[ :presenter | 
			presenter triggerOkAction.
			presenter close ]
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicDialogWindowAdapter a SpDialogWind[..]
		announcer: 	an Announcer
		owner: 	nil
		adapter: 	a SpMorphicDialogWindowAdapter
		needRebuild: 	true
		eventHandler: 	nil
		application: 	a StPharoApplication
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ nil ]
		windowIcon: 	an ObservableValueHolder[ Form(16x16x32) ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ true ]
		titleHolder: 	an ObservableValueHolder[ 'Import from existing clone' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ nil ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		borderWidth: 	an ObservableValueHolder[ nil ]
		borderColor: 	an ObservableValueHolder[ nil ]
		dragEnabled: 	an ObservableValueHolder[ false ]
		dropEnabled: 	an ObservableValueHolder[ false ]
		color: 	an ObservableValueHolder[ nil ]
		help: 	an ObservableValueHolder[ nil ]
		enabled: 	an ObservableValueHolder[ true ]
		wantsDrop: 	an ObservableValueHolder[ [ :transfer | self dropEnabled ] ]
		acceptDrop: 	an ObservableValueHolder[ [ :transfer | ] ]
		deferredActions: 	nil
		presenter: 	an ObservableValueHolder[ an IceTipLocalRepositoryPanel ]
		initialPosition: 	an ObservableValueHolder[ nil ]
		initialExtent: 	an ObservableValueHolder[ (500@137) ]
		menu: 	an ObservableValueHolder[ nil ]
		centered: 	an ObservableValueHolder[ false ]
		isClosed: 	an ObservableValueHolder[ false ]
		toolbar: 	an ObservableValueHolder[ nil ]
		statusbar: 	an ObservableValueHolder[ nil ]
		window: 	an ObservableValueHolder[ a SpDialogWindowMorph(272541184) named: I[..]
		decorations: 	an ObservableValueHolder[ true ]
		resizable: 	an ObservableValueHolder[ true ]
		buttons: 	an OrderedCollection(a SpButtonPresenter a SpButtonPresenter)
		okAction: 	[ 
			dialog validate.
			self repositoryModel updateLocation: di[..]
		cancelAction: 	[ 
		cancelled := true.
		self close ]
		cancelled: 	true
		defaultButton: 	nil


SpButtonPresenter>>performAction
	Receiver: a SpButtonPresenter
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicButtonAdapter)
		announcer: 	an Announcer
		owner: 	a SpButtonBarPresenter
		adapter: 	a SpMorphicButtonAdapter
		needRebuild: 	true
		eventHandler: 	nil
		application: 	nil
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ nil ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Button' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpAbstractWidgetLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		borderWidth: 	an ObservableValueHolder[ nil ]
		borderColor: 	an ObservableValueHolder[ nil ]
		dragEnabled: 	an ObservableValueHolder[ false ]
		dropEnabled: 	an ObservableValueHolder[ false ]
		color: 	an ObservableValueHolder[ nil ]
		help: 	an ObservableValueHolder[ nil ]
		enabled: 	an ObservableValueHolder[ true ]
		wantsDrop: 	an ObservableValueHolder[ [ :transfer | self dropEnabled ] ]
		acceptDrop: 	an ObservableValueHolder[ [ :transfer | ] ]
		deferredActions: 	nil
		icon: 	an ObservableValueHolder[ nil ]
		label: 	an ObservableValueHolder[ 'Ok' ]
		action: 	an ObservableValueHolder[ [ aBlock cull: self ] ]
		actionPerformed: 	an ObservableValueHolder[ nil ]
		askBeforeChanging: 	an ObservableValueHolder[ false ]
		font: 	an ObservableValueHolder[ nil ]
		shortcut: 	an ObservableValueHolder[ nil ]
		state: 	an ObservableValueHolder[ false ]
		contextMenu: 	an ObservableValueHolder[ nil ]


SpMorphicButtonAdapter>>action
	Receiver: a SpMorphicButtonAdapter
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpPluggableButtonMorph(190880000))
		announcer: 	nil
		model: 	a SpButtonPresenter
		widget: 	a SpPluggableButtonMorph(190880000)
		selector: 	nil
		owner: 	a SpButtonPresenter
		unsubscribed: 	false
		subMenuWidget: 	nil
		styleName: 	nil


SpPluggableButtonMorph(PluggableButtonMorph)>>performAction:
	Receiver: a SpPluggableButtonMorph(190880000)
	Arguments and temporary variables: 
		event: 	[(1103@815) mouseUp 4872662 nil]
	Receiver's instance variables: 
		bounds: 	(1079.0@803.0) corner: (1179.0@833.0)
		owner: 	a PanelMorph(996435712)
		submorphs: 	an Array(an AlignmentMorph(603547904))
		fullBounds: 	nil
		color: 	(Color r: 0.9012707722385142 g: 0.9012707722385142 b: 0.901270772238[..]
		extension: 	a MorphExtension (702656000) [eventHandler = a MorphicEventHandl[..]
		borderWidth: 	1
		borderColor: 	#simple
		model: 	a SpMorphicButtonAdapter
		label: 	'Ok'
		icon: 	nil
		getIconSelector: 	nil
		getStateSelector: 	#state
		actionSelector: 	#action
		font: 	nil
		getLabelSelector: 	#label
		getMenuSelector: 	#menu:
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	#enabled
		getFontSelector: 	#font
		labelMorph: 	a LabelMorph(527080448)'Ok'
		iconMorph: 	nil
		iconPosition: 	#left
		lastState: 	false
		backgroundColor: 	nil


[:m |
		(m containsPoint: evt cursorPoint) ifTrue: [m enabled ifTrue: [ m performAction: evt ]]] in SpPluggableButtonMorph(PluggableButtonMorph)>>mouseUp:
	Receiver: a SpPluggableButtonMorph(190880000)
	Arguments and temporary variables: 
		evt: 	[(1103@815) mouseUp 4872662 nil]
		all: 	an Array(a SpPluggableButtonMorph(1071948288) a SpPluggableButtonMorph[..]
		m: 	a SpPluggableButtonMorph(190880000)
	Receiver's instance variables: 
		bounds: 	(1079.0@803.0) corner: (1179.0@833.0)
		owner: 	a PanelMorph(996435712)
		submorphs: 	an Array(an AlignmentMorph(603547904))
		fullBounds: 	nil
		color: 	(Color r: 0.9012707722385142 g: 0.9012707722385142 b: 0.901270772238[..]
		extension: 	a MorphExtension (702656000) [eventHandler = a MorphicEventHandl[..]
		borderWidth: 	1
		borderColor: 	#simple
		model: 	a SpMorphicButtonAdapter
		label: 	'Ok'
		icon: 	nil
		getIconSelector: 	nil
		getStateSelector: 	#state
		actionSelector: 	#action
		font: 	nil
		getLabelSelector: 	#label
		getMenuSelector: 	#menu:
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	#enabled
		getFontSelector: 	#font
		labelMorph: 	a LabelMorph(527080448)'Ok'
		iconMorph: 	nil
		iconPosition: 	#left
		lastState: 	false
		backgroundColor: 	nil


Array(SequenceableCollection)>>do:
	Receiver: an Array(a SpPluggableButtonMorph(1071948288) a SpPluggableButtonMorph(190880000))
	Arguments and temporary variables: 
		aBlock: 	[:m |
		(m containsPoint: evt cursorPoint) ifTrue: [m enabled ifTru[..]
		index: 	2
	Receiver's instance variables: 
an Array(a SpPluggableButtonMorph(1071948288) a SpPluggableButtonMorph(190880000))

SpPluggableButtonMorph(PluggableButtonMorph)>>mouseUp:
	Receiver: a SpPluggableButtonMorph(190880000)
	Arguments and temporary variables: 
		evt: 	[(1103@815) mouseUp 4872662 nil]
		all: 	an Array(a SpPluggableButtonMorph(1071948288) a SpPluggableButtonMorph[..]
	Receiver's instance variables: 
		bounds: 	(1079.0@803.0) corner: (1179.0@833.0)
		owner: 	a PanelMorph(996435712)
		submorphs: 	an Array(an AlignmentMorph(603547904))
		fullBounds: 	nil
		color: 	(Color r: 0.9012707722385142 g: 0.9012707722385142 b: 0.901270772238[..]
		extension: 	a MorphExtension (702656000) [eventHandler = a MorphicEventHandl[..]
		borderWidth: 	1
		borderColor: 	#simple
		model: 	a SpMorphicButtonAdapter
		label: 	'Ok'
		icon: 	nil
		getIconSelector: 	nil
		getStateSelector: 	#state
		actionSelector: 	#action
		font: 	nil
		getLabelSelector: 	#label
		getMenuSelector: 	#menu:
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	#enabled
		getFontSelector: 	#font
		labelMorph: 	a LabelMorph(527080448)'Ok'
		iconMorph: 	nil
		iconPosition: 	#left
		lastState: 	false
		backgroundColor: 	nil


SpPluggableButtonMorph(Morph)>>handleMouseUp:
	Receiver: a SpPluggableButtonMorph(190880000)
	Arguments and temporary variables: 
		anEvent: 	[(1103@815) mouseUp 4872662 nil]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(1079.0@803.0) corner: (1179.0@833.0)
		owner: 	a PanelMorph(996435712)
		submorphs: 	an Array(an AlignmentMorph(603547904))
		fullBounds: 	nil
		color: 	(Color r: 0.9012707722385142 g: 0.9012707722385142 b: 0.901270772238[..]
		extension: 	a MorphExtension (702656000) [eventHandler = a MorphicEventHandl[..]
		borderWidth: 	1
		borderColor: 	#simple
		model: 	a SpMorphicButtonAdapter
		label: 	'Ok'
		icon: 	nil
		getIconSelector: 	nil
		getStateSelector: 	#state
		actionSelector: 	#action
		font: 	nil
		getLabelSelector: 	#label
		getMenuSelector: 	#menu:
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	#enabled
		getFontSelector: 	#font
		labelMorph: 	a LabelMorph(527080448)'Ok'
		iconMorph: 	nil
		iconPosition: 	#left
		lastState: 	false
		backgroundColor: 	nil


MouseButtonEvent>>sentTo:
	Receiver: [(1103@815) mouseUp 4872662 nil]
	Arguments and temporary variables: 
		anObject: 	a SpPluggableButtonMorph(190880000)
	Receiver's instance variables: 
		timeStamp: 	4872662
		source: 	a HandMorph(337424384)
		windowIndex: 	nil
		type: 	#mouseUp
		buttons: 	0
		position: 	(1103@815)
		handler: 	nil
		wasHandled: 	true
		whichButton: 	4


SpPluggableButtonMorph(Morph)>>handleEvent:
	Receiver: a SpPluggableButtonMorph(190880000)
	Arguments and temporary variables: 
		anEvent: 	[(1103@815) mouseUp 4872662 nil]
	Receiver's instance variables: 
		bounds: 	(1079.0@803.0) corner: (1179.0@833.0)
		owner: 	a PanelMorph(996435712)
		submorphs: 	an Array(an AlignmentMorph(603547904))
		fullBounds: 	nil
		color: 	(Color r: 0.9012707722385142 g: 0.9012707722385142 b: 0.901270772238[..]
		extension: 	a MorphExtension (702656000) [eventHandler = a MorphicEventHandl[..]
		borderWidth: 	1
		borderColor: 	#simple
		model: 	a SpMorphicButtonAdapter
		label: 	'Ok'
		icon: 	nil
		getIconSelector: 	nil
		getStateSelector: 	#state
		actionSelector: 	#action
		font: 	nil
		getLabelSelector: 	#label
		getMenuSelector: 	#menu:
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	#enabled
		getFontSelector: 	#font
		labelMorph: 	a LabelMorph(527080448)'Ok'
		iconMorph: 	nil
		iconPosition: 	#left
		lastState: 	false
		backgroundColor: 	nil


SpPluggableButtonMorph(Morph)>>handleFocusEvent:
	Receiver: a SpPluggableButtonMorph(190880000)
	Arguments and temporary variables: 
		anEvent: 	[(1103@815) mouseUp 4872662 nil]
	Receiver's instance variables: 
		bounds: 	(1079.0@803.0) corner: (1179.0@833.0)
		owner: 	a PanelMorph(996435712)
		submorphs: 	an Array(an AlignmentMorph(603547904))
		fullBounds: 	nil
		color: 	(Color r: 0.9012707722385142 g: 0.9012707722385142 b: 0.901270772238[..]
		extension: 	a MorphExtension (702656000) [eventHandler = a MorphicEventHandl[..]
		borderWidth: 	1
		borderColor: 	#simple
		model: 	a SpMorphicButtonAdapter
		label: 	'Ok'
		icon: 	nil
		getIconSelector: 	nil
		getStateSelector: 	#state
		actionSelector: 	#action
		font: 	nil
		getLabelSelector: 	#label
		getMenuSelector: 	#menu:
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	#enabled
		getFontSelector: 	#font
		labelMorph: 	a LabelMorph(527080448)'Ok'
		iconMorph: 	nil
		iconPosition: 	#left
		lastState: 	false
		backgroundColor: 	nil


[
		result := focusHolder handleFocusEvent: transformedEvent.
	] in HandMorph>>sendFocusEvent:to:clear:
	Receiver: a HandMorph(337424384)
	Arguments and temporary variables: 
		anEvent: 	[(1103@815) mouseUp 4872662 nil]
		focusHolder: 	a SpPluggableButtonMorph(190880000)
		aBlock: 	[self mouseFocus: nil]
		w: 	a WorldMorph(341720576) [world]
		transformedEvent: 	[(1103@815) mouseUp 4872662 nil]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(1103@815.0) corner: (1119@831.0)
		owner: 	a WorldMorph(341720576) [world]
		submorphs: 	#()
		fullBounds: 	(1103@815.0) corner: (1119@831.0)
		color: 	Color blue
		extension: 	a MorphExtension (370611968)
		mouseFocus: 	nil
		keyboardFocus: 	a SpPluggableButtonMorph(190880000)
		eventListeners: 	nil
		mouseListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(1103@815) mouseUp 4872662 nil]
		targetOffset: 	(24.0@12.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 0 0 0 0 0 nil nil)
		captureBlock: 	nil
		recentModifiers: 	0
		pendingEventQueue: 	WaitfreeQueue with 0 items
		supressNextKeyPress: 	false


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
		result := focusHolder handleFocusEvent: transformedEvent.
	]
	Arguments and temporary variables: 
		exception: 	Error
		handlerAction: 	[ :ex |
			ActiveWorld := priorWorld.
			ex pass ]
	Receiver's instance variables: 
		outerContext: 	HandMorph>>sendFocusEvent:to:clear:
		compiledBlock: 	a CompiledBlock: [
		result := focusHolder handleFocusEvent:[..]
		numArgs: 	0
		receiver: 	a HandMorph(337424384)


WorldMorph>>becomeActiveDuring:
	Receiver: a WorldMorph(341720576) [world]
	Arguments and temporary variables: 
		aBlock: 	[
		result := focusHolder handleFocusEvent: transformedEvent.
	]
		priorWorld: 	a WorldMorph(341720576) [world]
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1728@1080)
		owner: 	nil
		submorphs: 	an Array(a MenubarMorph(112886016) a TaskbarMorph(279458560) a S[..]
		fullBounds: 	(0@0) corner: (1728@1080)
		color: 	(Color r: 0.9403714565004888 g: 0.9403714565004888 b: 0.940371456500[..]
		extension: 	a MorphExtension (1012946432) [other:  (dragEnabled -> true) (dr[..]
		borderWidth: 	0
		borderColor: 	(Color r: 0.8611925708699902 g: 1.0 b: 0.7223851417399805 alph[..]
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil


HandMorph>>sendFocusEvent:to:clear:
	Receiver: a HandMorph(337424384)
	Arguments and temporary variables: 
		result: 	nil
		anEvent: 	[(1103@815) mouseUp 4872662 nil]
		focusHolder: 	a SpPluggableButtonMorph(190880000)
		aBlock: 	[self mouseFocus: nil]
		w: 	a WorldMorph(341720576) [world]
		transformedEvent: 	[(1103@815) mouseUp 4872662 nil]
	Receiver's instance variables: 
		bounds: 	(1103@815.0) corner: (1119@831.0)
		owner: 	a WorldMorph(341720576) [world]
		submorphs: 	#()
		fullBounds: 	(1103@815.0) corner: (1119@831.0)
		color: 	Color blue
		extension: 	a MorphExtension (370611968)
		mouseFocus: 	nil
		keyboardFocus: 	a SpPluggableButtonMorph(190880000)
		eventListeners: 	nil
		mouseListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(1103@815) mouseUp 4872662 nil]
		targetOffset: 	(24.0@12.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 0 0 0 0 0 nil nil)
		captureBlock: 	nil
		recentModifiers: 	0
		pendingEventQueue: 	WaitfreeQueue with 0 items
		supressNextKeyPress: 	false


HandMorph>>sendEvent:focus:clear:
	Receiver: a HandMorph(337424384)
	Arguments and temporary variables: 
		anEvent: 	[(1103@815) mouseUp 4872662 nil]
		focusHolder: 	a SpPluggableButtonMorph(190880000)
		aBlock: 	[self mouseFocus: nil]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(1103@815.0) corner: (1119@831.0)
		owner: 	a WorldMorph(341720576) [world]
		submorphs: 	#()
		fullBounds: 	(1103@815.0) corner: (1119@831.0)
		color: 	Color blue
		extension: 	a MorphExtension (370611968)
		mouseFocus: 	nil
		keyboardFocus: 	a SpPluggableButtonMorph(190880000)
		eventListeners: 	nil
		mouseListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(1103@815) mouseUp 4872662 nil]
		targetOffset: 	(24.0@12.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 0 0 0 0 0 nil nil)
		captureBlock: 	nil
		recentModifiers: 	0
		pendingEventQueue: 	WaitfreeQueue with 0 items
		supressNextKeyPress: 	false


HandMorph>>sendMouseEvent:
	Receiver: a HandMorph(337424384)
	Arguments and temporary variables: 
		anEvent: 	[(1103@815) mouseUp 4872662 nil]
	Receiver's instance variables: 
		bounds: 	(1103@815.0) corner: (1119@831.0)
		owner: 	a WorldMorph(341720576) [world]
		submorphs: 	#()
		fullBounds: 	(1103@815.0) corner: (1119@831.0)
		color: 	Color blue
		extension: 	a MorphExtension (370611968)
		mouseFocus: 	nil
		keyboardFocus: 	a SpPluggableButtonMorph(190880000)
		eventListeners: 	nil
		mouseListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(1103@815) mouseUp 4872662 nil]
		targetOffset: 	(24.0@12.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 0 0 0 0 0 nil nil)
		captureBlock: 	nil
		recentModifiers: 	0
		pendingEventQueue: 	WaitfreeQueue with 0 items
		supressNextKeyPress: 	false


HandMorph>>handleEvent:
	Receiver: a HandMorph(337424384)
	Arguments and temporary variables: 
		anEvent: 	[(1103@815) mouseUp 4872662 nil]
		evt: 	[(1103@815) mouseUp 4872662 nil]
	Receiver's instance variables: 
		bounds: 	(1103@815.0) corner: (1119@831.0)
		owner: 	a WorldMorph(341720576) [world]
		submorphs: 	#()
		fullBounds: 	(1103@815.0) corner: (1119@831.0)
		color: 	Color blue
		extension: 	a MorphExtension (370611968)
		mouseFocus: 	nil
		keyboardFocus: 	a SpPluggableButtonMorph(190880000)
		eventListeners: 	nil
		mouseListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(1103@815) mouseUp 4872662 nil]
		targetOffset: 	(24.0@12.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 0 0 0 0 0 nil nil)
		captureBlock: 	nil
		recentModifiers: 	0
		pendingEventQueue: 	WaitfreeQueue with 0 items
		supressNextKeyPress: 	false


[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil ]) ifTrue: [
			morphicWorld activeHand handleEvent: anEvent
		]
	] in OSWindowMorphicEventHandler>>dispatchMorphicEvent:
	Receiver: an OSWindowMorphicEventHandler
	Arguments and temporary variables: 
		anEvent: 	[(1103@815) mouseUp 4872662 nil]
	Receiver's instance variables: 
		morphicWorld: 	a WorldMorph(341720576) [world]


WorldState>>runStepMethodsIn:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(341720576) [world]
		queue: 	WaitfreeQueue with 0 items
		nextInQueue: 	[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNo[..]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(337424384))
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap()
		lastStepTime: 	4743121
		lastStepMessage: 	nil
		alarms: 	a Heap()
		lastAlarmTime: 	4872640
		activeHand: 	a HandMorph(337424384)
		currentCursor: 	((CursorWithMask
	extent: (16@16)
	depth: 1
	fromArray: #(
	[..]
		worldRenderer: 	an OSWorldRenderer
		realWindowExtent: 	(1728@1080)
		deferredUIMessages: 	WaitfreeQueue with 0 items


WorldMorph>>runStepMethods
	Receiver: a WorldMorph(341720576) [world]
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1728@1080)
		owner: 	nil
		submorphs: 	an Array(a MenubarMorph(112886016) a TaskbarMorph(279458560) a S[..]
		fullBounds: 	(0@0) corner: (1728@1080)
		color: 	(Color r: 0.9403714565004888 g: 0.9403714565004888 b: 0.940371456500[..]
		extension: 	a MorphExtension (1012946432) [other:  (dragEnabled -> true) (dr[..]
		borderWidth: 	0
		borderColor: 	(Color r: 0.8611925708699902 g: 1.0 b: 0.7223851417399805 alph[..]
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil


WorldState>>doOneCycleFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(341720576) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(337424384))
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap()
		lastStepTime: 	4743121
		lastStepMessage: 	nil
		alarms: 	a Heap()
		lastAlarmTime: 	4872640
		activeHand: 	a HandMorph(337424384)
		currentCursor: 	((CursorWithMask
	extent: (16@16)
	depth: 1
	fromArray: #(
	[..]
		worldRenderer: 	an OSWorldRenderer
		realWindowExtent: 	(1728@1080)
		deferredUIMessages: 	WaitfreeQueue with 0 items


WorldMorph>>doOneCycleNow
	Receiver: a WorldMorph(341720576) [world]
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1728@1080)
		owner: 	nil
		submorphs: 	an Array(a MenubarMorph(112886016) a TaskbarMorph(279458560) a S[..]
		fullBounds: 	(0@0) corner: (1728@1080)
		color: 	(Color r: 0.9403714565004888 g: 0.9403714565004888 b: 0.940371456500[..]
		extension: 	a MorphExtension (1012946432) [other:  (dragEnabled -> true) (dr[..]
		borderWidth: 	0
		borderColor: 	(Color r: 0.8611925708699902 g: 1.0 b: 0.7223851417399805 alph[..]
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil


WorldMorph>>doOneCycle
	Receiver: a WorldMorph(341720576) [world]
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1728@1080)
		owner: 	nil
		submorphs: 	an Array(a MenubarMorph(112886016) a TaskbarMorph(279458560) a S[..]
		fullBounds: 	(0@0) corner: (1728@1080)
		color: 	(Color r: 0.9403714565004888 g: 0.9403714565004888 b: 0.940371456500[..]
		extension: 	a MorphExtension (1012946432) [other:  (dragEnabled -> true) (dr[..]
		borderWidth: 	0
		borderColor: 	(Color r: 0.8611925708699902 g: 1.0 b: 0.7223851417399805 alph[..]
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil


[
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMutex critical: [
			                     self extraWorldList ].
		extraWorldsToDraw do: [ :world | world doOneCycle ].

		(self currentWorld isNotNil and: [
			 (extraWorldsToDraw includes: self currentWorld) not ]) ifTrue: [
			self currentWorld doOneCycle ] ] in WorldMorph class>>doOneCycle
	Receiver: WorldMorph
	Arguments and temporary variables: 
		extraWorldsToDraw: 	#()
	Receiver's instance variables: 
		superclass: 	PasteUpMorph
		methodDict: 	a MethodDictionary(#acceptDroppingMorph:event:->WorldMorph>>#ac[..]
		format: 	65547
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		commentSourcePointer: 	nil
		subclasses: 	{AthensWorldMorph. OSWindowWorldMorph}
		name: 	#WorldMorph
		classPool: 	a Dictionary(#AllowDropFiles->nil #CursorOwnerWorld->a WorldMorp[..]
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Morphic-Core-Worlds'
		announcer: 	nil
		displayScaleFactor: 	1


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMutex critical: [
			  [..]
	Arguments and temporary variables: 
		aBlock: 	[
		self doInterCycleWait
	]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	WorldMorph class>>doOneCycle
		compiledBlock: 	a CompiledBlock: [
		| extraWorldsToDraw |
		extraWorldsToDr[..]
		numArgs: 	0
		receiver: 	WorldMorph


WorldState class>>doDrawCycleWith:
	Receiver: WorldState
	Arguments and temporary variables: 
		aBlock: 	[
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMute[..]
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary(#activeHand->WorldState>>#activeHand #active[..]
		format: 	65548
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		commentSourcePointer: 	nil
		subclasses: 	{AthensWorldState}
		name: 	#WorldState
		classPool: 	a Dictionary(#CanSurrenderToOS->nil #DebugShowDamage->false #Des[..]
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Morphic-Core-Worlds'


WorldMorph class>>doOneCycle
	Receiver: WorldMorph
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		superclass: 	PasteUpMorph
		methodDict: 	a MethodDictionary(#acceptDroppingMorph:event:->WorldMorph>>#ac[..]
		format: 	65547
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		commentSourcePointer: 	nil
		subclasses: 	{AthensWorldMorph. OSWindowWorldMorph}
		name: 	#WorldMorph
		classPool: 	a Dictionary(#AllowDropFiles->nil #CursorOwnerWorld->a WorldMorp[..]
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Morphic-Core-Worlds'
		announcer: 	nil
		displayScaleFactor: 	1


MorphicRenderLoop>>doOneCycle
	Receiver: a MorphicRenderLoop
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
a MorphicRenderLoop

MorphicRenderLoop>>doOneCycleWhile:
	Receiver: a MorphicRenderLoop
	Arguments and temporary variables: 
		aBlock: 	[ true ]
	Receiver's instance variables: 
a MorphicRenderLoop

[ MorphicRenderLoop new doOneCycleWhile: [ true ] ] in MorphicUIManager>>spawnNewProcess
	Receiver: a MorphicUIManager
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		activeTranscript: 	nil


[self value.
			"IMPORTANT: Do not step over next line of code. See method comments for details"
			Processor terminateRealActive] in FullBlockClosure(BlockClosure)>>newProcess
	Receiver: [ MorphicRenderLoop new doOneCycleWhile: [ true ] ]
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		outerContext: 	MorphicUIManager>>spawnNewProcess
		compiledBlock: 	a CompiledBlock: [ MorphicRenderLoop new doOneCycleWhile: [ [..]
		numArgs: 	0
		receiver: 	a MorphicUIManager



--- The full stack ---
IceTipLocalRepositoryPanel(Object)>>assert:description:
IceTipLocalRepositoryPanel>>validate
[ 
			dialog validate.
			self repositoryModel updateLocation: dialog location.
			true ] in IceTipRepairLocateRepository>>basicExecute
FullBlockClosure(BlockClosure)>>cull:
SpDialogWindowPresenter>>triggerOkAction
[ :presenter | 
			presenter triggerOkAction.
			presenter close ] in IceTipLocalRepositoryPanel(SpAbstractPresenter)>>initializeDialogWindow:
FullBlockClosure(BlockClosure)>>cull:
[ aBlock cull: self ] in SpDialogWindowPresenter>>addButton:do:
SpButtonPresenter>>performAction
SpMorphicButtonAdapter>>action
SpPluggableButtonMorph(PluggableButtonMorph)>>performAction:
[:m |
		(m containsPoint: evt cursorPoint) ifTrue: [m enabled ifTrue: [ m performAction: evt ]]] in SpPluggableButtonMorph(PluggableButtonMorph)>>mouseUp:
Array(SequenceableCollection)>>do:
SpPluggableButtonMorph(PluggableButtonMorph)>>mouseUp:
SpPluggableButtonMorph(Morph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
SpPluggableButtonMorph(Morph)>>handleEvent:
SpPluggableButtonMorph(Morph)>>handleFocusEvent:
[
		result := focusHolder handleFocusEvent: transformedEvent.
	] in HandMorph>>sendFocusEvent:to:clear:
FullBlockClosure(BlockClosure)>>on:do:
WorldMorph>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil ]) ifTrue: [
			morphicWorld activeHand handleEvent: anEvent
		]
	] in OSWindowMorphicEventHandler>>dispatchMorphicEvent:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycleNow
WorldMorph>>doOneCycle
[
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMutex critical: [
			                     self extraWorldList ].
		extraWorldsToDraw do: [ :world | world doOneCycle ].

		(self currentWorld isNotNil and: [
			 (extraWorldsToDraw includes: self currentWorld) not ]) ifTrue: [
			self currentWorld doOneCycle ] ] in WorldMorph class>>doOneCycle
FullBlockClosure(BlockClosure)>>ensure:
WorldState class>>doDrawCycleWith:
WorldMorph class>>doOneCycle
MorphicRenderLoop>>doOneCycle
MorphicRenderLoop>>doOneCycleWhile:
[ MorphicRenderLoop new doOneCycleWhile: [ true ] ] in MorphicUIManager>>spawnNewProcess
[self value.
			"IMPORTANT: Do not step over next line of code. See method comments for details"
			Processor terminateRealActive] in FullBlockClosure(BlockClosure)>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
#asLowercase was sent to nil
13 November 2023 5:31:35.765112 pm

VM: Mac OS - arm64 - 1000 - CoInterpreter VMMaker-tonel.1 uuid: 902dd483-c0c4-0d00-86f2-0f880df24b96 Oct 23 2023
StackToRegisterMappingCogit VMMaker-tonel.1 uuid: 902dd483-c0c4-0d00-86f2-0f880df24b96 Oct 23 2023
v10.0.8 - Commit: b323c5fb - Date: 2023-10-20 16:02:07 -0400

Image: Pharo11.0.0 [Build information: Pharo-11.0.0+build.710.sha.ea28d8552cac85a7ce1e9c34ab1e7bd45f7b9910 (64 Bit)]

UndefinedObject(Object)>>doesNotUnderstand: #asLowercase
	Receiver: nil
	Arguments and temporary variables: 
		aMessage: 	asLowercase
		exception: 	#asLowercase was sent to nil
		resumeValue: 	nil
	Receiver's instance variables: 
nil

UndefinedObject>>doesNotUnderstand: #asLowercase
	Receiver: nil
	Arguments and temporary variables: 
		node: 	nil
		aMessage: 	asLowercase
		exception: 	nil
		resumeValue: 	nil
	Receiver's instance variables: 
nil

MCPackage>>hash
	Receiver: <<error during printing>>
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		name: 	nil


Dictionary>>scanFor:
	Receiver: a Dictionary(size 779)
	Arguments and temporary variables: 
<<error during printing>>
	Receiver's instance variables: 
		tally: 	779
		array: 	an Array(a MCPackage(System-CommandLine)->a MCWorkingCopy(#'System-C[..]


Dictionary(HashedCollection)>>findElementOrNil:
	Receiver: a Dictionary(size 779)
	Arguments and temporary variables: 
<<error during printing>>
	Receiver's instance variables: 
		tally: 	779
		array: 	an Array(a MCPackage(System-CommandLine)->a MCWorkingCopy(#'System-C[..]


Dictionary>>at:ifAbsent:
	Receiver: a Dictionary(size 779)
	Arguments and temporary variables: 
<<error during printing>>
	Receiver's instance variables: 
		tally: 	779
		array: 	an Array(a MCPackage(System-CommandLine)->a MCWorkingCopy(#'System-C[..]


MCWorkingCopy class(MCPackageManager class)>>forPackage:
	Receiver: MCWorkingCopy
	Arguments and temporary variables: 
<<error during printing>>
	Receiver's instance variables: 
		superclass: 	MCPackageManager
		methodDict: 	a MethodDictionary(#adopt:->MCWorkingCopy>>#adopt: #allAncestor[..]
		format: 	65544
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		commentSourcePointer: 	nil
		subclasses: 	nil
		name: 	#MCWorkingCopy
		classPool: 	nil
		sharedPools: 	nil
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Monticello-Versioning'
		registry: 	a Dictionary(size 779)


MCFileRepositoryInspector>>saveChanges
	Receiver: a MCFileRepositoryInspector
	Arguments and temporary variables: 
		currentRepository: 	a MCCacheRepository(/Users/ryanperez/Documents/GitHub/pp[..]
		workingCopy: 	nil
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SystemWindow(654089728) named: Repository: [..]
		announcer: 	an Announcer
		morph: 	a SystemWindow(654089728) named: Repository: /Users/ryanperez/Docume[..]
		label: 	nil
		modal: 	false
		modalValue: 	nil
		version: 	nil
		repository: 	a MCCacheRepository(/Users/ryanperez/Documents/GitHub/pp-rep253[..]
		versions: 	#(#('Roassal3-Pharo9' 'CompatibleUserName' 1686657480 'Roassal3-P[..]
		loaded: 	a Set('Calypso-NavigationModel-Tests-tonel.1' 'Metacello-Gitlab-Tes[..]
		loadedPackages: 	a Set()
		newer: 	a Set()
		packageList: 	#('BaselineOfNeoJSON' 'Neo-JSON-Core' 'Neo-JSON-Pharo-Core' 'N[..]
		selectedPackage: 	nil
		selectedVersion: 	nil
		order: 	5
		versionInfo: 	nil
		packagePattern: 	'js'
		versionPattern: 	''
		packageListUpdateProcess: 	a Process in Process>>endProcess
		versionProcess: 	nil
		selectedPackageAncestors: 	nil


MCFileRepositoryInspector(MCTool)>>performButtonAction:enabled:
	Receiver: a MCFileRepositoryInspector
	Arguments and temporary variables: 
		anActionSelector: 	#saveChanges
		anEnabledSelector: 	#buttonEnabled
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SystemWindow(654089728) named: Repository: [..]
		announcer: 	an Announcer
		morph: 	a SystemWindow(654089728) named: Repository: /Users/ryanperez/Docume[..]
		label: 	nil
		modal: 	false
		modalValue: 	nil
		version: 	nil
		repository: 	a MCCacheRepository(/Users/ryanperez/Documents/GitHub/pp-rep253[..]
		versions: 	#(#('Roassal3-Pharo9' 'CompatibleUserName' 1686657480 'Roassal3-P[..]
		loaded: 	a Set('Calypso-NavigationModel-Tests-tonel.1' 'Metacello-Gitlab-Tes[..]
		loadedPackages: 	a Set()
		newer: 	a Set()
		packageList: 	#('BaselineOfNeoJSON' 'Neo-JSON-Core' 'Neo-JSON-Pharo-Core' 'N[..]
		selectedPackage: 	nil
		selectedVersion: 	nil
		order: 	5
		versionInfo: 	nil
		packagePattern: 	'js'
		versionPattern: 	''
		packageListUpdateProcess: 	a Process in Process>>endProcess
		versionProcess: 	nil
		selectedPackageAncestors: 	nil


PluggableButtonMorph>>performAction:
	Receiver: a PluggableButtonMorph(790293760)
	Arguments and temporary variables: 
		event: 	[(633@345) mouseUp 5213881 nil]
	Receiver's instance variables: 
		bounds: 	(621.0@330.0) corner: (675.0@356.0)
		owner: 	a PanelMorph(830711296)
		submorphs: 	an Array(an AlignmentMorph(282743808))
		fullBounds: 	nil
		color: 	(Color r: 0.9012707722385142 g: 0.9012707722385142 b: 0.901270772238[..]
		extension: 	a MorphExtension (214990592) [balloonText]  [other:  (mouseEnter[..]
		borderWidth: 	1
		borderColor: 	#simple
		model: 	a MCFileRepositoryInspector
		label: 	'Save'
		icon: 	nil
		getIconSelector: 	nil
		getStateSelector: 	#buttonState
		actionSelector: 	#performButtonAction:enabled:
		font: 	nil
		getLabelSelector: 	nil
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#(#saveChanges #buttonEnabled)
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	#buttonEnabled
		getFontSelector: 	nil
		labelMorph: 	a LabelMorph(207524352)'Save'
		iconMorph: 	nil
		iconPosition: 	#left
		lastState: 	false


[:m |
		(m containsPoint: evt cursorPoint) ifTrue: [m enabled ifTrue: [ m performAction: evt ]]] in PluggableButtonMorph>>mouseUp:
	Receiver: a PluggableButtonMorph(790293760)
	Arguments and temporary variables: 
		evt: 	[(633@345) mouseUp 5213881 nil]
		all: 	an Array(a PluggableButtonMorph(973825024) a PluggableButtonMorph(7902[..]
		m: 	a PluggableButtonMorph(790293760)
	Receiver's instance variables: 
		bounds: 	(621.0@330.0) corner: (675.0@356.0)
		owner: 	a PanelMorph(830711296)
		submorphs: 	an Array(an AlignmentMorph(282743808))
		fullBounds: 	nil
		color: 	(Color r: 0.9012707722385142 g: 0.9012707722385142 b: 0.901270772238[..]
		extension: 	a MorphExtension (214990592) [balloonText]  [other:  (mouseEnter[..]
		borderWidth: 	1
		borderColor: 	#simple
		model: 	a MCFileRepositoryInspector
		label: 	'Save'
		icon: 	nil
		getIconSelector: 	nil
		getStateSelector: 	#buttonState
		actionSelector: 	#performButtonAction:enabled:
		font: 	nil
		getLabelSelector: 	nil
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#(#saveChanges #buttonEnabled)
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	#buttonEnabled
		getFontSelector: 	nil
		labelMorph: 	a LabelMorph(207524352)'Save'
		iconMorph: 	nil
		iconPosition: 	#left
		lastState: 	false


Array(SequenceableCollection)>>do:
	Receiver: an Array(a PluggableButtonMorph(973825024) a PluggableButtonMorph(790293760) a Pluggab[..]
	Arguments and temporary variables: 
		aBlock: 	[:m |
		(m containsPoint: evt cursorPoint) ifTrue: [m enabled ifTru[..]
		index: 	2
	Receiver's instance variables: 
an Array(a PluggableButtonMorph(973825024) a PluggableButtonMorph(790293760) a Pluggab[..]

PluggableButtonMorph>>mouseUp:
	Receiver: a PluggableButtonMorph(790293760)
	Arguments and temporary variables: 
		evt: 	[(633@345) mouseUp 5213881 nil]
		all: 	an Array(a PluggableButtonMorph(973825024) a PluggableButtonMorph(7902[..]
	Receiver's instance variables: 
		bounds: 	(621.0@330.0) corner: (675.0@356.0)
		owner: 	a PanelMorph(830711296)
		submorphs: 	an Array(an AlignmentMorph(282743808))
		fullBounds: 	nil
		color: 	(Color r: 0.9012707722385142 g: 0.9012707722385142 b: 0.901270772238[..]
		extension: 	a MorphExtension (214990592) [balloonText]  [other:  (mouseEnter[..]
		borderWidth: 	1
		borderColor: 	#simple
		model: 	a MCFileRepositoryInspector
		label: 	'Save'
		icon: 	nil
		getIconSelector: 	nil
		getStateSelector: 	#buttonState
		actionSelector: 	#performButtonAction:enabled:
		font: 	nil
		getLabelSelector: 	nil
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#(#saveChanges #buttonEnabled)
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	#buttonEnabled
		getFontSelector: 	nil
		labelMorph: 	a LabelMorph(207524352)'Save'
		iconMorph: 	nil
		iconPosition: 	#left
		lastState: 	false


PluggableButtonMorph(Morph)>>handleMouseUp:
	Receiver: a PluggableButtonMorph(790293760)
	Arguments and temporary variables: 
		anEvent: 	[(633@345) mouseUp 5213881 nil]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(621.0@330.0) corner: (675.0@356.0)
		owner: 	a PanelMorph(830711296)
		submorphs: 	an Array(an AlignmentMorph(282743808))
		fullBounds: 	nil
		color: 	(Color r: 0.9012707722385142 g: 0.9012707722385142 b: 0.901270772238[..]
		extension: 	a MorphExtension (214990592) [balloonText]  [other:  (mouseEnter[..]
		borderWidth: 	1
		borderColor: 	#simple
		model: 	a MCFileRepositoryInspector
		label: 	'Save'
		icon: 	nil
		getIconSelector: 	nil
		getStateSelector: 	#buttonState
		actionSelector: 	#performButtonAction:enabled:
		font: 	nil
		getLabelSelector: 	nil
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#(#saveChanges #buttonEnabled)
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	#buttonEnabled
		getFontSelector: 	nil
		labelMorph: 	a LabelMorph(207524352)'Save'
		iconMorph: 	nil
		iconPosition: 	#left
		lastState: 	false


MouseButtonEvent>>sentTo:
	Receiver: [(633@345) mouseUp 5213881 nil]
	Arguments and temporary variables: 
		anObject: 	a PluggableButtonMorph(790293760)
	Receiver's instance variables: 
		timeStamp: 	5213881
		source: 	a HandMorph(337424384)
		windowIndex: 	nil
		type: 	#mouseUp
		buttons: 	0
		position: 	(633@345)
		handler: 	nil
		wasHandled: 	true
		whichButton: 	4


PluggableButtonMorph(Morph)>>handleEvent:
	Receiver: a PluggableButtonMorph(790293760)
	Arguments and temporary variables: 
		anEvent: 	[(633@345) mouseUp 5213881 nil]
	Receiver's instance variables: 
		bounds: 	(621.0@330.0) corner: (675.0@356.0)
		owner: 	a PanelMorph(830711296)
		submorphs: 	an Array(an AlignmentMorph(282743808))
		fullBounds: 	nil
		color: 	(Color r: 0.9012707722385142 g: 0.9012707722385142 b: 0.901270772238[..]
		extension: 	a MorphExtension (214990592) [balloonText]  [other:  (mouseEnter[..]
		borderWidth: 	1
		borderColor: 	#simple
		model: 	a MCFileRepositoryInspector
		label: 	'Save'
		icon: 	nil
		getIconSelector: 	nil
		getStateSelector: 	#buttonState
		actionSelector: 	#performButtonAction:enabled:
		font: 	nil
		getLabelSelector: 	nil
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#(#saveChanges #buttonEnabled)
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	#buttonEnabled
		getFontSelector: 	nil
		labelMorph: 	a LabelMorph(207524352)'Save'
		iconMorph: 	nil
		iconPosition: 	#left
		lastState: 	false


PluggableButtonMorph(Morph)>>handleFocusEvent:
	Receiver: a PluggableButtonMorph(790293760)
	Arguments and temporary variables: 
		anEvent: 	[(633@345) mouseUp 5213881 nil]
	Receiver's instance variables: 
		bounds: 	(621.0@330.0) corner: (675.0@356.0)
		owner: 	a PanelMorph(830711296)
		submorphs: 	an Array(an AlignmentMorph(282743808))
		fullBounds: 	nil
		color: 	(Color r: 0.9012707722385142 g: 0.9012707722385142 b: 0.901270772238[..]
		extension: 	a MorphExtension (214990592) [balloonText]  [other:  (mouseEnter[..]
		borderWidth: 	1
		borderColor: 	#simple
		model: 	a MCFileRepositoryInspector
		label: 	'Save'
		icon: 	nil
		getIconSelector: 	nil
		getStateSelector: 	#buttonState
		actionSelector: 	#performButtonAction:enabled:
		font: 	nil
		getLabelSelector: 	nil
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#(#saveChanges #buttonEnabled)
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	#buttonEnabled
		getFontSelector: 	nil
		labelMorph: 	a LabelMorph(207524352)'Save'
		iconMorph: 	nil
		iconPosition: 	#left
		lastState: 	false


[
		result := focusHolder handleFocusEvent: transformedEvent.
	] in HandMorph>>sendFocusEvent:to:clear:
	Receiver: a HandMorph(337424384)
	Arguments and temporary variables: 
		anEvent: 	[(633@345) mouseUp 5213881 nil]
		focusHolder: 	a PluggableButtonMorph(790293760)
		aBlock: 	[self mouseFocus: nil]
		w: 	a WorldMorph(341720576) [world]
		transformedEvent: 	[(633@345) mouseUp 5213881 nil]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(633@345.0) corner: (649@361.0)
		owner: 	a WorldMorph(341720576) [world]
		submorphs: 	#()
		fullBounds: 	(633@345.0) corner: (649@361.0)
		color: 	Color blue
		extension: 	a MorphExtension (370611968)
		mouseFocus: 	nil
		keyboardFocus: 	a RubTextFieldArea(348608512)
		eventListeners: 	nil
		mouseListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(633@345) mouseUp 5213881 nil]
		targetOffset: 	(12.0@15.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 0 0 0 0 0 nil nil)
		captureBlock: 	nil
		recentModifiers: 	0
		pendingEventQueue: 	WaitfreeQueue with 0 items
		supressNextKeyPress: 	false


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
		result := focusHolder handleFocusEvent: transformedEvent.
	]
	Arguments and temporary variables: 
		exception: 	Error
		handlerAction: 	[ :ex |
			ActiveWorld := priorWorld.
			ex pass ]
	Receiver's instance variables: 
		outerContext: 	HandMorph>>sendFocusEvent:to:clear:
		compiledBlock: 	a CompiledBlock: [
		result := focusHolder handleFocusEvent:[..]
		numArgs: 	0
		receiver: 	a HandMorph(337424384)


WorldMorph>>becomeActiveDuring:
	Receiver: a WorldMorph(341720576) [world]
	Arguments and temporary variables: 
		aBlock: 	[
		result := focusHolder handleFocusEvent: transformedEvent.
	]
		priorWorld: 	a WorldMorph(341720576) [world]
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1728@1080)
		owner: 	nil
		submorphs: 	an Array(a MenubarMorph(112886016) a TaskbarMorph(279458560) a S[..]
		fullBounds: 	(0@0) corner: (1728@1080)
		color: 	(Color r: 0.9403714565004888 g: 0.9403714565004888 b: 0.940371456500[..]
		extension: 	a MorphExtension (1012946432) [other:  (dragEnabled -> true) (dr[..]
		borderWidth: 	0
		borderColor: 	(Color r: 0.8611925708699902 g: 1.0 b: 0.7223851417399805 alph[..]
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil


HandMorph>>sendFocusEvent:to:clear:
	Receiver: a HandMorph(337424384)
	Arguments and temporary variables: 
		result: 	nil
		anEvent: 	[(633@345) mouseUp 5213881 nil]
		focusHolder: 	a PluggableButtonMorph(790293760)
		aBlock: 	[self mouseFocus: nil]
		w: 	a WorldMorph(341720576) [world]
		transformedEvent: 	[(633@345) mouseUp 5213881 nil]
	Receiver's instance variables: 
		bounds: 	(633@345.0) corner: (649@361.0)
		owner: 	a WorldMorph(341720576) [world]
		submorphs: 	#()
		fullBounds: 	(633@345.0) corner: (649@361.0)
		color: 	Color blue
		extension: 	a MorphExtension (370611968)
		mouseFocus: 	nil
		keyboardFocus: 	a RubTextFieldArea(348608512)
		eventListeners: 	nil
		mouseListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(633@345) mouseUp 5213881 nil]
		targetOffset: 	(12.0@15.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 0 0 0 0 0 nil nil)
		captureBlock: 	nil
		recentModifiers: 	0
		pendingEventQueue: 	WaitfreeQueue with 0 items
		supressNextKeyPress: 	false


HandMorph>>sendEvent:focus:clear:
	Receiver: a HandMorph(337424384)
	Arguments and temporary variables: 
		anEvent: 	[(633@345) mouseUp 5213881 nil]
		focusHolder: 	a PluggableButtonMorph(790293760)
		aBlock: 	[self mouseFocus: nil]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(633@345.0) corner: (649@361.0)
		owner: 	a WorldMorph(341720576) [world]
		submorphs: 	#()
		fullBounds: 	(633@345.0) corner: (649@361.0)
		color: 	Color blue
		extension: 	a MorphExtension (370611968)
		mouseFocus: 	nil
		keyboardFocus: 	a RubTextFieldArea(348608512)
		eventListeners: 	nil
		mouseListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(633@345) mouseUp 5213881 nil]
		targetOffset: 	(12.0@15.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 0 0 0 0 0 nil nil)
		captureBlock: 	nil
		recentModifiers: 	0
		pendingEventQueue: 	WaitfreeQueue with 0 items
		supressNextKeyPress: 	false


HandMorph>>sendMouseEvent:
	Receiver: a HandMorph(337424384)
	Arguments and temporary variables: 
		anEvent: 	[(633@345) mouseUp 5213881 nil]
	Receiver's instance variables: 
		bounds: 	(633@345.0) corner: (649@361.0)
		owner: 	a WorldMorph(341720576) [world]
		submorphs: 	#()
		fullBounds: 	(633@345.0) corner: (649@361.0)
		color: 	Color blue
		extension: 	a MorphExtension (370611968)
		mouseFocus: 	nil
		keyboardFocus: 	a RubTextFieldArea(348608512)
		eventListeners: 	nil
		mouseListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(633@345) mouseUp 5213881 nil]
		targetOffset: 	(12.0@15.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 0 0 0 0 0 nil nil)
		captureBlock: 	nil
		recentModifiers: 	0
		pendingEventQueue: 	WaitfreeQueue with 0 items
		supressNextKeyPress: 	false


HandMorph>>handleEvent:
	Receiver: a HandMorph(337424384)
	Arguments and temporary variables: 
		anEvent: 	[(633@345) mouseUp 5213881 nil]
		evt: 	[(633@345) mouseUp 5213881 nil]
	Receiver's instance variables: 
		bounds: 	(633@345.0) corner: (649@361.0)
		owner: 	a WorldMorph(341720576) [world]
		submorphs: 	#()
		fullBounds: 	(633@345.0) corner: (649@361.0)
		color: 	Color blue
		extension: 	a MorphExtension (370611968)
		mouseFocus: 	nil
		keyboardFocus: 	a RubTextFieldArea(348608512)
		eventListeners: 	nil
		mouseListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(633@345) mouseUp 5213881 nil]
		targetOffset: 	(12.0@15.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 0 0 0 0 0 nil nil)
		captureBlock: 	nil
		recentModifiers: 	0
		pendingEventQueue: 	WaitfreeQueue with 0 items
		supressNextKeyPress: 	false


[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil ]) ifTrue: [
			morphicWorld activeHand handleEvent: anEvent
		]
	] in OSWindowMorphicEventHandler>>dispatchMorphicEvent:
	Receiver: an OSWindowMorphicEventHandler
	Arguments and temporary variables: 
		anEvent: 	[(633@345) mouseUp 5213881 nil]
	Receiver's instance variables: 
		morphicWorld: 	a WorldMorph(341720576) [world]


WorldState>>runStepMethodsIn:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(341720576) [world]
		queue: 	WaitfreeQueue with 0 items
		nextInQueue: 	[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNo[..]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(337424384))
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap()
		lastStepTime: 	5163254
		lastStepMessage: 	nil
		alarms: 	a Heap(MorphicAlarm(#hideShow -> a RubCursor(729751808)))
		lastAlarmTime: 	5213869
		activeHand: 	a HandMorph(337424384)
		currentCursor: 	((CursorWithMask
	extent: (16@16)
	depth: 1
	fromArray: #(
	[..]
		worldRenderer: 	an OSWorldRenderer
		realWindowExtent: 	(1728@1080)
		deferredUIMessages: 	WaitfreeQueue with 0 items


WorldMorph>>runStepMethods
	Receiver: a WorldMorph(341720576) [world]
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1728@1080)
		owner: 	nil
		submorphs: 	an Array(a MenubarMorph(112886016) a TaskbarMorph(279458560) a S[..]
		fullBounds: 	(0@0) corner: (1728@1080)
		color: 	(Color r: 0.9403714565004888 g: 0.9403714565004888 b: 0.940371456500[..]
		extension: 	a MorphExtension (1012946432) [other:  (dragEnabled -> true) (dr[..]
		borderWidth: 	0
		borderColor: 	(Color r: 0.8611925708699902 g: 1.0 b: 0.7223851417399805 alph[..]
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil


WorldState>>doOneCycleFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(341720576) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(337424384))
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap()
		lastStepTime: 	5163254
		lastStepMessage: 	nil
		alarms: 	a Heap(MorphicAlarm(#hideShow -> a RubCursor(729751808)))
		lastAlarmTime: 	5213869
		activeHand: 	a HandMorph(337424384)
		currentCursor: 	((CursorWithMask
	extent: (16@16)
	depth: 1
	fromArray: #(
	[..]
		worldRenderer: 	an OSWorldRenderer
		realWindowExtent: 	(1728@1080)
		deferredUIMessages: 	WaitfreeQueue with 0 items


WorldMorph>>doOneCycleNow
	Receiver: a WorldMorph(341720576) [world]
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1728@1080)
		owner: 	nil
		submorphs: 	an Array(a MenubarMorph(112886016) a TaskbarMorph(279458560) a S[..]
		fullBounds: 	(0@0) corner: (1728@1080)
		color: 	(Color r: 0.9403714565004888 g: 0.9403714565004888 b: 0.940371456500[..]
		extension: 	a MorphExtension (1012946432) [other:  (dragEnabled -> true) (dr[..]
		borderWidth: 	0
		borderColor: 	(Color r: 0.8611925708699902 g: 1.0 b: 0.7223851417399805 alph[..]
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil


WorldMorph>>doOneCycle
	Receiver: a WorldMorph(341720576) [world]
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1728@1080)
		owner: 	nil
		submorphs: 	an Array(a MenubarMorph(112886016) a TaskbarMorph(279458560) a S[..]
		fullBounds: 	(0@0) corner: (1728@1080)
		color: 	(Color r: 0.9403714565004888 g: 0.9403714565004888 b: 0.940371456500[..]
		extension: 	a MorphExtension (1012946432) [other:  (dragEnabled -> true) (dr[..]
		borderWidth: 	0
		borderColor: 	(Color r: 0.8611925708699902 g: 1.0 b: 0.7223851417399805 alph[..]
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil


[
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMutex critical: [
			                     self extraWorldList ].
		extraWorldsToDraw do: [ :world | world doOneCycle ].

		(self currentWorld isNotNil and: [
			 (extraWorldsToDraw includes: self currentWorld) not ]) ifTrue: [
			self currentWorld doOneCycle ] ] in WorldMorph class>>doOneCycle
	Receiver: WorldMorph
	Arguments and temporary variables: 
		extraWorldsToDraw: 	#()
	Receiver's instance variables: 
		superclass: 	PasteUpMorph
		methodDict: 	a MethodDictionary(#acceptDroppingMorph:event:->WorldMorph>>#ac[..]
		format: 	65547
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		commentSourcePointer: 	nil
		subclasses: 	{AthensWorldMorph. OSWindowWorldMorph}
		name: 	#WorldMorph
		classPool: 	a Dictionary(#AllowDropFiles->nil #CursorOwnerWorld->a WorldMorp[..]
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Morphic-Core-Worlds'
		announcer: 	nil
		displayScaleFactor: 	1


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMutex critical: [
			  [..]
	Arguments and temporary variables: 
		aBlock: 	[
		self doInterCycleWait
	]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	WorldMorph class>>doOneCycle
		compiledBlock: 	a CompiledBlock: [
		| extraWorldsToDraw |
		extraWorldsToDr[..]
		numArgs: 	0
		receiver: 	WorldMorph


WorldState class>>doDrawCycleWith:
	Receiver: WorldState
	Arguments and temporary variables: 
		aBlock: 	[
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMute[..]
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary(#activeHand->WorldState>>#activeHand #active[..]
		format: 	65548
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		commentSourcePointer: 	nil
		subclasses: 	{AthensWorldState}
		name: 	#WorldState
		classPool: 	a Dictionary(#CanSurrenderToOS->nil #DebugShowDamage->false #Des[..]
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Morphic-Core-Worlds'


WorldMorph class>>doOneCycle
	Receiver: WorldMorph
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		superclass: 	PasteUpMorph
		methodDict: 	a MethodDictionary(#acceptDroppingMorph:event:->WorldMorph>>#ac[..]
		format: 	65547
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		commentSourcePointer: 	nil
		subclasses: 	{AthensWorldMorph. OSWindowWorldMorph}
		name: 	#WorldMorph
		classPool: 	a Dictionary(#AllowDropFiles->nil #CursorOwnerWorld->a WorldMorp[..]
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Morphic-Core-Worlds'
		announcer: 	nil
		displayScaleFactor: 	1


MorphicRenderLoop>>doOneCycle
	Receiver: a MorphicRenderLoop
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
a MorphicRenderLoop

MorphicRenderLoop>>doOneCycleWhile:
	Receiver: a MorphicRenderLoop
	Arguments and temporary variables: 
		aBlock: 	[ true ]
	Receiver's instance variables: 
a MorphicRenderLoop

[ MorphicRenderLoop new doOneCycleWhile: [ true ] ] in MorphicUIManager>>spawnNewProcess
	Receiver: a MorphicUIManager
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		activeTranscript: 	nil


[self value.
			"IMPORTANT: Do not step over next line of code. See method comments for details"
			Processor terminateRealActive] in FullBlockClosure(BlockClosure)>>newProcess
	Receiver: [ MorphicRenderLoop new doOneCycleWhile: [ true ] ]
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		outerContext: 	MorphicUIManager>>spawnNewProcess
		compiledBlock: 	a CompiledBlock: [ MorphicRenderLoop new doOneCycleWhile: [ [..]
		numArgs: 	0
		receiver: 	a MorphicUIManager



--- The full stack ---
UndefinedObject(Object)>>doesNotUnderstand: #asLowercase
UndefinedObject>>doesNotUnderstand: #asLowercase
MCPackage>>hash
Dictionary>>scanFor:
Dictionary(HashedCollection)>>findElementOrNil:
Dictionary>>at:ifAbsent:
MCWorkingCopy class(MCPackageManager class)>>forPackage:
MCFileRepositoryInspector>>saveChanges
MCFileRepositoryInspector(MCTool)>>performButtonAction:enabled:
PluggableButtonMorph>>performAction:
[:m |
		(m containsPoint: evt cursorPoint) ifTrue: [m enabled ifTrue: [ m performAction: evt ]]] in PluggableButtonMorph>>mouseUp:
Array(SequenceableCollection)>>do:
PluggableButtonMorph>>mouseUp:
PluggableButtonMorph(Morph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
PluggableButtonMorph(Morph)>>handleEvent:
PluggableButtonMorph(Morph)>>handleFocusEvent:
[
		result := focusHolder handleFocusEvent: transformedEvent.
	] in HandMorph>>sendFocusEvent:to:clear:
FullBlockClosure(BlockClosure)>>on:do:
WorldMorph>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil ]) ifTrue: [
			morphicWorld activeHand handleEvent: anEvent
		]
	] in OSWindowMorphicEventHandler>>dispatchMorphicEvent:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycleNow
WorldMorph>>doOneCycle
[
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMutex critical: [
			                     self extraWorldList ].
		extraWorldsToDraw do: [ :world | world doOneCycle ].

		(self currentWorld isNotNil and: [
			 (extraWorldsToDraw includes: self currentWorld) not ]) ifTrue: [
			self currentWorld doOneCycle ] ] in WorldMorph class>>doOneCycle
FullBlockClosure(BlockClosure)>>ensure:
WorldState class>>doDrawCycleWith:
WorldMorph class>>doOneCycle
MorphicRenderLoop>>doOneCycle
MorphicRenderLoop>>doOneCycleWhile:
[ MorphicRenderLoop new doOneCycleWhile: [ true ] ] in MorphicUIManager>>spawnNewProcess
[self value.
			"IMPORTANT: Do not step over next line of code. See method comments for details"
			Processor terminateRealActive] in FullBlockClosure(BlockClosure)>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
#asLowercase was sent to nil
13 November 2023 5:31:35.80383 pm

VM: Mac OS - arm64 - 1000 - CoInterpreter VMMaker-tonel.1 uuid: 902dd483-c0c4-0d00-86f2-0f880df24b96 Oct 23 2023
StackToRegisterMappingCogit VMMaker-tonel.1 uuid: 902dd483-c0c4-0d00-86f2-0f880df24b96 Oct 23 2023
v10.0.8 - Commit: b323c5fb - Date: 2023-10-20 16:02:07 -0400

Image: Pharo11.0.0 [Build information: Pharo-11.0.0+build.710.sha.ea28d8552cac85a7ce1e9c34ab1e7bd45f7b9910 (64 Bit)]

UndefinedObject(Object)>>doesNotUnderstand: #asLowercase
	Receiver: nil
	Arguments and temporary variables: 
		aMessage: 	asLowercase
		exception: 	#asLowercase was sent to nil
		resumeValue: 	nil
	Receiver's instance variables: 
nil

UndefinedObject>>doesNotUnderstand: #asLowercase
	Receiver: nil
	Arguments and temporary variables: 
		node: 	nil
		aMessage: 	asLowercase
		exception: 	nil
		resumeValue: 	nil
	Receiver's instance variables: 
nil

MCPackage>>hash
	Receiver: <<error during printing>>
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		name: 	nil


Dictionary>>scanFor:
	Receiver: a Dictionary(size 779)
	Arguments and temporary variables: 
<<error during printing>>
	Receiver's instance variables: 
		tally: 	779
		array: 	an Array(a MCPackage(System-CommandLine)->a MCWorkingCopy(#'System-C[..]


Dictionary(HashedCollection)>>findElementOrNil:
	Receiver: a Dictionary(size 779)
	Arguments and temporary variables: 
<<error during printing>>
	Receiver's instance variables: 
		tally: 	779
		array: 	an Array(a MCPackage(System-CommandLine)->a MCWorkingCopy(#'System-C[..]


Dictionary>>at:ifAbsent:
	Receiver: a Dictionary(size 779)
	Arguments and temporary variables: 
<<error during printing>>
	Receiver's instance variables: 
		tally: 	779
		array: 	an Array(a MCPackage(System-CommandLine)->a MCWorkingCopy(#'System-C[..]


MCWorkingCopy class(MCPackageManager class)>>forPackage:
	Receiver: MCWorkingCopy
	Arguments and temporary variables: 
<<error during printing>>
	Receiver's instance variables: 
		superclass: 	MCPackageManager
		methodDict: 	a MethodDictionary(#adopt:->MCWorkingCopy>>#adopt: #allAncestor[..]
		format: 	65544
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		commentSourcePointer: 	nil
		subclasses: 	nil
		name: 	#MCWorkingCopy
		classPool: 	nil
		sharedPools: 	nil
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Monticello-Versioning'
		registry: 	a Dictionary(size 779)


MCFileRepositoryInspector>>saveChanges
	Receiver: a MCFileRepositoryInspector
	Arguments and temporary variables: 
		currentRepository: 	a MCCacheRepository(/Users/ryanperez/Documents/GitHub/pp[..]
		workingCopy: 	nil
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SystemWindow(654089728) named: Repository: [..]
		announcer: 	an Announcer
		morph: 	a SystemWindow(654089728) named: Repository: /Users/ryanperez/Docume[..]
		label: 	nil
		modal: 	false
		modalValue: 	nil
		version: 	nil
		repository: 	a MCCacheRepository(/Users/ryanperez/Documents/GitHub/pp-rep253[..]
		versions: 	#(#('Roassal3-Pharo9' 'CompatibleUserName' 1686657480 'Roassal3-P[..]
		loaded: 	a Set('Calypso-NavigationModel-Tests-tonel.1' 'Metacello-Gitlab-Tes[..]
		loadedPackages: 	a Set()
		newer: 	a Set()
		packageList: 	#('BaselineOfNeoJSON' 'Neo-JSON-Core' 'Neo-JSON-Pharo-Core' 'N[..]
		selectedPackage: 	nil
		selectedVersion: 	nil
		order: 	5
		versionInfo: 	nil
		packagePattern: 	'js'
		versionPattern: 	''
		packageListUpdateProcess: 	a Process in Process>>endProcess
		versionProcess: 	nil
		selectedPackageAncestors: 	nil


MCFileRepositoryInspector(MCTool)>>performButtonAction:enabled:
	Receiver: a MCFileRepositoryInspector
	Arguments and temporary variables: 
		anActionSelector: 	#saveChanges
		anEnabledSelector: 	#buttonEnabled
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SystemWindow(654089728) named: Repository: [..]
		announcer: 	an Announcer
		morph: 	a SystemWindow(654089728) named: Repository: /Users/ryanperez/Docume[..]
		label: 	nil
		modal: 	false
		modalValue: 	nil
		version: 	nil
		repository: 	a MCCacheRepository(/Users/ryanperez/Documents/GitHub/pp-rep253[..]
		versions: 	#(#('Roassal3-Pharo9' 'CompatibleUserName' 1686657480 'Roassal3-P[..]
		loaded: 	a Set('Calypso-NavigationModel-Tests-tonel.1' 'Metacello-Gitlab-Tes[..]
		loadedPackages: 	a Set()
		newer: 	a Set()
		packageList: 	#('BaselineOfNeoJSON' 'Neo-JSON-Core' 'Neo-JSON-Pharo-Core' 'N[..]
		selectedPackage: 	nil
		selectedVersion: 	nil
		order: 	5
		versionInfo: 	nil
		packagePattern: 	'js'
		versionPattern: 	''
		packageListUpdateProcess: 	a Process in Process>>endProcess
		versionProcess: 	nil
		selectedPackageAncestors: 	nil


PluggableButtonMorph>>performAction:
	Receiver: a PluggableButtonMorph(790293760)
	Arguments and temporary variables: 
		event: 	[(633@345) mouseUp 5213881 nil]
	Receiver's instance variables: 
		bounds: 	(621.0@330.0) corner: (675.0@356.0)
		owner: 	a PanelMorph(830711296)
		submorphs: 	an Array(an AlignmentMorph(282743808))
		fullBounds: 	nil
		color: 	(Color r: 0.9012707722385142 g: 0.9012707722385142 b: 0.901270772238[..]
		extension: 	a MorphExtension (214990592) [balloonText]  [other:  (mouseEnter[..]
		borderWidth: 	1
		borderColor: 	#simple
		model: 	a MCFileRepositoryInspector
		label: 	'Save'
		icon: 	nil
		getIconSelector: 	nil
		getStateSelector: 	#buttonState
		actionSelector: 	#performButtonAction:enabled:
		font: 	nil
		getLabelSelector: 	nil
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#(#saveChanges #buttonEnabled)
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	#buttonEnabled
		getFontSelector: 	nil
		labelMorph: 	a LabelMorph(207524352)'Save'
		iconMorph: 	nil
		iconPosition: 	#left
		lastState: 	false


[:m |
		(m containsPoint: evt cursorPoint) ifTrue: [m enabled ifTrue: [ m performAction: evt ]]] in PluggableButtonMorph>>mouseUp:
	Receiver: a PluggableButtonMorph(790293760)
	Arguments and temporary variables: 
		evt: 	[(633@345) mouseUp 5213881 nil]
		all: 	an Array(a PluggableButtonMorph(973825024) a PluggableButtonMorph(7902[..]
		m: 	a PluggableButtonMorph(790293760)
	Receiver's instance variables: 
		bounds: 	(621.0@330.0) corner: (675.0@356.0)
		owner: 	a PanelMorph(830711296)
		submorphs: 	an Array(an AlignmentMorph(282743808))
		fullBounds: 	nil
		color: 	(Color r: 0.9012707722385142 g: 0.9012707722385142 b: 0.901270772238[..]
		extension: 	a MorphExtension (214990592) [balloonText]  [other:  (mouseEnter[..]
		borderWidth: 	1
		borderColor: 	#simple
		model: 	a MCFileRepositoryInspector
		label: 	'Save'
		icon: 	nil
		getIconSelector: 	nil
		getStateSelector: 	#buttonState
		actionSelector: 	#performButtonAction:enabled:
		font: 	nil
		getLabelSelector: 	nil
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#(#saveChanges #buttonEnabled)
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	#buttonEnabled
		getFontSelector: 	nil
		labelMorph: 	a LabelMorph(207524352)'Save'
		iconMorph: 	nil
		iconPosition: 	#left
		lastState: 	false


Array(SequenceableCollection)>>do:
	Receiver: an Array(a PluggableButtonMorph(973825024) a PluggableButtonMorph(790293760) a Pluggab[..]
	Arguments and temporary variables: 
		aBlock: 	[:m |
		(m containsPoint: evt cursorPoint) ifTrue: [m enabled ifTru[..]
		index: 	2
	Receiver's instance variables: 
an Array(a PluggableButtonMorph(973825024) a PluggableButtonMorph(790293760) a Pluggab[..]

PluggableButtonMorph>>mouseUp:
	Receiver: a PluggableButtonMorph(790293760)
	Arguments and temporary variables: 
		evt: 	[(633@345) mouseUp 5213881 nil]
		all: 	an Array(a PluggableButtonMorph(973825024) a PluggableButtonMorph(7902[..]
	Receiver's instance variables: 
		bounds: 	(621.0@330.0) corner: (675.0@356.0)
		owner: 	a PanelMorph(830711296)
		submorphs: 	an Array(an AlignmentMorph(282743808))
		fullBounds: 	nil
		color: 	(Color r: 0.9012707722385142 g: 0.9012707722385142 b: 0.901270772238[..]
		extension: 	a MorphExtension (214990592) [balloonText]  [other:  (mouseEnter[..]
		borderWidth: 	1
		borderColor: 	#simple
		model: 	a MCFileRepositoryInspector
		label: 	'Save'
		icon: 	nil
		getIconSelector: 	nil
		getStateSelector: 	#buttonState
		actionSelector: 	#performButtonAction:enabled:
		font: 	nil
		getLabelSelector: 	nil
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#(#saveChanges #buttonEnabled)
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	#buttonEnabled
		getFontSelector: 	nil
		labelMorph: 	a LabelMorph(207524352)'Save'
		iconMorph: 	nil
		iconPosition: 	#left
		lastState: 	false


PluggableButtonMorph(Morph)>>handleMouseUp:
	Receiver: a PluggableButtonMorph(790293760)
	Arguments and temporary variables: 
		anEvent: 	[(633@345) mouseUp 5213881 nil]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(621.0@330.0) corner: (675.0@356.0)
		owner: 	a PanelMorph(830711296)
		submorphs: 	an Array(an AlignmentMorph(282743808))
		fullBounds: 	nil
		color: 	(Color r: 0.9012707722385142 g: 0.9012707722385142 b: 0.901270772238[..]
		extension: 	a MorphExtension (214990592) [balloonText]  [other:  (mouseEnter[..]
		borderWidth: 	1
		borderColor: 	#simple
		model: 	a MCFileRepositoryInspector
		label: 	'Save'
		icon: 	nil
		getIconSelector: 	nil
		getStateSelector: 	#buttonState
		actionSelector: 	#performButtonAction:enabled:
		font: 	nil
		getLabelSelector: 	nil
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#(#saveChanges #buttonEnabled)
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	#buttonEnabled
		getFontSelector: 	nil
		labelMorph: 	a LabelMorph(207524352)'Save'
		iconMorph: 	nil
		iconPosition: 	#left
		lastState: 	false


MouseButtonEvent>>sentTo:
	Receiver: [(633@345) mouseUp 5213881 nil]
	Arguments and temporary variables: 
		anObject: 	a PluggableButtonMorph(790293760)
	Receiver's instance variables: 
		timeStamp: 	5213881
		source: 	a HandMorph(337424384)
		windowIndex: 	nil
		type: 	#mouseUp
		buttons: 	0
		position: 	(633@345)
		handler: 	nil
		wasHandled: 	true
		whichButton: 	4


PluggableButtonMorph(Morph)>>handleEvent:
	Receiver: a PluggableButtonMorph(790293760)
	Arguments and temporary variables: 
		anEvent: 	[(633@345) mouseUp 5213881 nil]
	Receiver's instance variables: 
		bounds: 	(621.0@330.0) corner: (675.0@356.0)
		owner: 	a PanelMorph(830711296)
		submorphs: 	an Array(an AlignmentMorph(282743808))
		fullBounds: 	nil
		color: 	(Color r: 0.9012707722385142 g: 0.9012707722385142 b: 0.901270772238[..]
		extension: 	a MorphExtension (214990592) [balloonText]  [other:  (mouseEnter[..]
		borderWidth: 	1
		borderColor: 	#simple
		model: 	a MCFileRepositoryInspector
		label: 	'Save'
		icon: 	nil
		getIconSelector: 	nil
		getStateSelector: 	#buttonState
		actionSelector: 	#performButtonAction:enabled:
		font: 	nil
		getLabelSelector: 	nil
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#(#saveChanges #buttonEnabled)
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	#buttonEnabled
		getFontSelector: 	nil
		labelMorph: 	a LabelMorph(207524352)'Save'
		iconMorph: 	nil
		iconPosition: 	#left
		lastState: 	false


PluggableButtonMorph(Morph)>>handleFocusEvent:
	Receiver: a PluggableButtonMorph(790293760)
	Arguments and temporary variables: 
		anEvent: 	[(633@345) mouseUp 5213881 nil]
	Receiver's instance variables: 
		bounds: 	(621.0@330.0) corner: (675.0@356.0)
		owner: 	a PanelMorph(830711296)
		submorphs: 	an Array(an AlignmentMorph(282743808))
		fullBounds: 	nil
		color: 	(Color r: 0.9012707722385142 g: 0.9012707722385142 b: 0.901270772238[..]
		extension: 	a MorphExtension (214990592) [balloonText]  [other:  (mouseEnter[..]
		borderWidth: 	1
		borderColor: 	#simple
		model: 	a MCFileRepositoryInspector
		label: 	'Save'
		icon: 	nil
		getIconSelector: 	nil
		getStateSelector: 	#buttonState
		actionSelector: 	#performButtonAction:enabled:
		font: 	nil
		getLabelSelector: 	nil
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#(#saveChanges #buttonEnabled)
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	#buttonEnabled
		getFontSelector: 	nil
		labelMorph: 	a LabelMorph(207524352)'Save'
		iconMorph: 	nil
		iconPosition: 	#left
		lastState: 	false


[
		result := focusHolder handleFocusEvent: transformedEvent.
	] in HandMorph>>sendFocusEvent:to:clear:
	Receiver: a HandMorph(337424384)
	Arguments and temporary variables: 
		anEvent: 	[(633@345) mouseUp 5213881 nil]
		focusHolder: 	a PluggableButtonMorph(790293760)
		aBlock: 	[self mouseFocus: nil]
		w: 	a WorldMorph(341720576) [world]
		transformedEvent: 	[(633@345) mouseUp 5213881 nil]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(633@345.0) corner: (649@361.0)
		owner: 	a WorldMorph(341720576) [world]
		submorphs: 	#()
		fullBounds: 	(633@345.0) corner: (649@361.0)
		color: 	Color blue
		extension: 	a MorphExtension (370611968)
		mouseFocus: 	nil
		keyboardFocus: 	a RubTextFieldArea(348608512)
		eventListeners: 	nil
		mouseListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(633@345) mouseUp 5213881 nil]
		targetOffset: 	(12.0@15.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 0 0 0 0 0 nil nil)
		captureBlock: 	nil
		recentModifiers: 	0
		pendingEventQueue: 	WaitfreeQueue with 0 items
		supressNextKeyPress: 	false


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
		result := focusHolder handleFocusEvent: transformedEvent.
	]
	Arguments and temporary variables: 
		exception: 	Error
		handlerAction: 	[ :ex |
			ActiveWorld := priorWorld.
			ex pass ]
	Receiver's instance variables: 
		outerContext: 	HandMorph>>sendFocusEvent:to:clear:
		compiledBlock: 	a CompiledBlock: [
		result := focusHolder handleFocusEvent:[..]
		numArgs: 	0
		receiver: 	a HandMorph(337424384)


WorldMorph>>becomeActiveDuring:
	Receiver: a WorldMorph(341720576) [world]
	Arguments and temporary variables: 
		aBlock: 	[
		result := focusHolder handleFocusEvent: transformedEvent.
	]
		priorWorld: 	a WorldMorph(341720576) [world]
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1728@1080)
		owner: 	nil
		submorphs: 	an Array(a MenubarMorph(112886016) a TaskbarMorph(279458560) a S[..]
		fullBounds: 	(0@0) corner: (1728@1080)
		color: 	(Color r: 0.9403714565004888 g: 0.9403714565004888 b: 0.940371456500[..]
		extension: 	a MorphExtension (1012946432) [other:  (dragEnabled -> true) (dr[..]
		borderWidth: 	0
		borderColor: 	(Color r: 0.8611925708699902 g: 1.0 b: 0.7223851417399805 alph[..]
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil


HandMorph>>sendFocusEvent:to:clear:
	Receiver: a HandMorph(337424384)
	Arguments and temporary variables: 
		result: 	nil
		anEvent: 	[(633@345) mouseUp 5213881 nil]
		focusHolder: 	a PluggableButtonMorph(790293760)
		aBlock: 	[self mouseFocus: nil]
		w: 	a WorldMorph(341720576) [world]
		transformedEvent: 	[(633@345) mouseUp 5213881 nil]
	Receiver's instance variables: 
		bounds: 	(633@345.0) corner: (649@361.0)
		owner: 	a WorldMorph(341720576) [world]
		submorphs: 	#()
		fullBounds: 	(633@345.0) corner: (649@361.0)
		color: 	Color blue
		extension: 	a MorphExtension (370611968)
		mouseFocus: 	nil
		keyboardFocus: 	a RubTextFieldArea(348608512)
		eventListeners: 	nil
		mouseListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(633@345) mouseUp 5213881 nil]
		targetOffset: 	(12.0@15.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 0 0 0 0 0 nil nil)
		captureBlock: 	nil
		recentModifiers: 	0
		pendingEventQueue: 	WaitfreeQueue with 0 items
		supressNextKeyPress: 	false


HandMorph>>sendEvent:focus:clear:
	Receiver: a HandMorph(337424384)
	Arguments and temporary variables: 
		anEvent: 	[(633@345) mouseUp 5213881 nil]
		focusHolder: 	a PluggableButtonMorph(790293760)
		aBlock: 	[self mouseFocus: nil]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(633@345.0) corner: (649@361.0)
		owner: 	a WorldMorph(341720576) [world]
		submorphs: 	#()
		fullBounds: 	(633@345.0) corner: (649@361.0)
		color: 	Color blue
		extension: 	a MorphExtension (370611968)
		mouseFocus: 	nil
		keyboardFocus: 	a RubTextFieldArea(348608512)
		eventListeners: 	nil
		mouseListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(633@345) mouseUp 5213881 nil]
		targetOffset: 	(12.0@15.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 0 0 0 0 0 nil nil)
		captureBlock: 	nil
		recentModifiers: 	0
		pendingEventQueue: 	WaitfreeQueue with 0 items
		supressNextKeyPress: 	false


HandMorph>>sendMouseEvent:
	Receiver: a HandMorph(337424384)
	Arguments and temporary variables: 
		anEvent: 	[(633@345) mouseUp 5213881 nil]
	Receiver's instance variables: 
		bounds: 	(633@345.0) corner: (649@361.0)
		owner: 	a WorldMorph(341720576) [world]
		submorphs: 	#()
		fullBounds: 	(633@345.0) corner: (649@361.0)
		color: 	Color blue
		extension: 	a MorphExtension (370611968)
		mouseFocus: 	nil
		keyboardFocus: 	a RubTextFieldArea(348608512)
		eventListeners: 	nil
		mouseListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(633@345) mouseUp 5213881 nil]
		targetOffset: 	(12.0@15.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 0 0 0 0 0 nil nil)
		captureBlock: 	nil
		recentModifiers: 	0
		pendingEventQueue: 	WaitfreeQueue with 0 items
		supressNextKeyPress: 	false


HandMorph>>handleEvent:
	Receiver: a HandMorph(337424384)
	Arguments and temporary variables: 
		anEvent: 	[(633@345) mouseUp 5213881 nil]
		evt: 	[(633@345) mouseUp 5213881 nil]
	Receiver's instance variables: 
		bounds: 	(633@345.0) corner: (649@361.0)
		owner: 	a WorldMorph(341720576) [world]
		submorphs: 	#()
		fullBounds: 	(633@345.0) corner: (649@361.0)
		color: 	Color blue
		extension: 	a MorphExtension (370611968)
		mouseFocus: 	nil
		keyboardFocus: 	a RubTextFieldArea(348608512)
		eventListeners: 	nil
		mouseListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(633@345) mouseUp 5213881 nil]
		targetOffset: 	(12.0@15.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 0 0 0 0 0 nil nil)
		captureBlock: 	nil
		recentModifiers: 	0
		pendingEventQueue: 	WaitfreeQueue with 0 items
		supressNextKeyPress: 	false


[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil ]) ifTrue: [
			morphicWorld activeHand handleEvent: anEvent
		]
	] in OSWindowMorphicEventHandler>>dispatchMorphicEvent:
	Receiver: an OSWindowMorphicEventHandler
	Arguments and temporary variables: 
		anEvent: 	[(633@345) mouseUp 5213881 nil]
	Receiver's instance variables: 
		morphicWorld: 	a WorldMorph(341720576) [world]


WorldState>>runStepMethodsIn:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(341720576) [world]
		queue: 	WaitfreeQueue with 0 items
		nextInQueue: 	[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNo[..]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(337424384))
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap()
		lastStepTime: 	5163254
		lastStepMessage: 	nil
		alarms: 	a Heap(MorphicAlarm(#hideShow -> a RubCursor(729751808)))
		lastAlarmTime: 	5213869
		activeHand: 	a HandMorph(337424384)
		currentCursor: 	((CursorWithMask
	extent: (16@16)
	depth: 1
	fromArray: #(
	[..]
		worldRenderer: 	an OSWorldRenderer
		realWindowExtent: 	(1728@1080)
		deferredUIMessages: 	WaitfreeQueue with 0 items


WorldMorph>>runStepMethods
	Receiver: a WorldMorph(341720576) [world]
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1728@1080)
		owner: 	nil
		submorphs: 	an Array(a MenubarMorph(112886016) a TaskbarMorph(279458560) a S[..]
		fullBounds: 	(0@0) corner: (1728@1080)
		color: 	(Color r: 0.9403714565004888 g: 0.9403714565004888 b: 0.940371456500[..]
		extension: 	a MorphExtension (1012946432) [other:  (dragEnabled -> true) (dr[..]
		borderWidth: 	0
		borderColor: 	(Color r: 0.8611925708699902 g: 1.0 b: 0.7223851417399805 alph[..]
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil


WorldState>>doOneCycleFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(341720576) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(337424384))
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap()
		lastStepTime: 	5163254
		lastStepMessage: 	nil
		alarms: 	a Heap(MorphicAlarm(#hideShow -> a RubCursor(729751808)))
		lastAlarmTime: 	5213869
		activeHand: 	a HandMorph(337424384)
		currentCursor: 	((CursorWithMask
	extent: (16@16)
	depth: 1
	fromArray: #(
	[..]
		worldRenderer: 	an OSWorldRenderer
		realWindowExtent: 	(1728@1080)
		deferredUIMessages: 	WaitfreeQueue with 0 items


WorldMorph>>doOneCycleNow
	Receiver: a WorldMorph(341720576) [world]
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1728@1080)
		owner: 	nil
		submorphs: 	an Array(a MenubarMorph(112886016) a TaskbarMorph(279458560) a S[..]
		fullBounds: 	(0@0) corner: (1728@1080)
		color: 	(Color r: 0.9403714565004888 g: 0.9403714565004888 b: 0.940371456500[..]
		extension: 	a MorphExtension (1012946432) [other:  (dragEnabled -> true) (dr[..]
		borderWidth: 	0
		borderColor: 	(Color r: 0.8611925708699902 g: 1.0 b: 0.7223851417399805 alph[..]
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil


WorldMorph>>doOneCycle
	Receiver: a WorldMorph(341720576) [world]
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1728@1080)
		owner: 	nil
		submorphs: 	an Array(a MenubarMorph(112886016) a TaskbarMorph(279458560) a S[..]
		fullBounds: 	(0@0) corner: (1728@1080)
		color: 	(Color r: 0.9403714565004888 g: 0.9403714565004888 b: 0.940371456500[..]
		extension: 	a MorphExtension (1012946432) [other:  (dragEnabled -> true) (dr[..]
		borderWidth: 	0
		borderColor: 	(Color r: 0.8611925708699902 g: 1.0 b: 0.7223851417399805 alph[..]
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil


[
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMutex critical: [
			                     self extraWorldList ].
		extraWorldsToDraw do: [ :world | world doOneCycle ].

		(self currentWorld isNotNil and: [
			 (extraWorldsToDraw includes: self currentWorld) not ]) ifTrue: [
			self currentWorld doOneCycle ] ] in WorldMorph class>>doOneCycle
	Receiver: WorldMorph
	Arguments and temporary variables: 
		extraWorldsToDraw: 	#()
	Receiver's instance variables: 
		superclass: 	PasteUpMorph
		methodDict: 	a MethodDictionary(#acceptDroppingMorph:event:->WorldMorph>>#ac[..]
		format: 	65547
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		commentSourcePointer: 	nil
		subclasses: 	{AthensWorldMorph. OSWindowWorldMorph}
		name: 	#WorldMorph
		classPool: 	a Dictionary(#AllowDropFiles->nil #CursorOwnerWorld->a WorldMorp[..]
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Morphic-Core-Worlds'
		announcer: 	nil
		displayScaleFactor: 	1


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMutex critical: [
			  [..]
	Arguments and temporary variables: 
		aBlock: 	[
		self doInterCycleWait
	]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	WorldMorph class>>doOneCycle
		compiledBlock: 	a CompiledBlock: [
		| extraWorldsToDraw |
		extraWorldsToDr[..]
		numArgs: 	0
		receiver: 	WorldMorph


WorldState class>>doDrawCycleWith:
	Receiver: WorldState
	Arguments and temporary variables: 
		aBlock: 	[
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMute[..]
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary(#activeHand->WorldState>>#activeHand #active[..]
		format: 	65548
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		commentSourcePointer: 	nil
		subclasses: 	{AthensWorldState}
		name: 	#WorldState
		classPool: 	a Dictionary(#CanSurrenderToOS->nil #DebugShowDamage->false #Des[..]
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Morphic-Core-Worlds'


WorldMorph class>>doOneCycle
	Receiver: WorldMorph
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		superclass: 	PasteUpMorph
		methodDict: 	a MethodDictionary(#acceptDroppingMorph:event:->WorldMorph>>#ac[..]
		format: 	65547
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		commentSourcePointer: 	nil
		subclasses: 	{AthensWorldMorph. OSWindowWorldMorph}
		name: 	#WorldMorph
		classPool: 	a Dictionary(#AllowDropFiles->nil #CursorOwnerWorld->a WorldMorp[..]
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Morphic-Core-Worlds'
		announcer: 	nil
		displayScaleFactor: 	1


MorphicRenderLoop>>doOneCycle
	Receiver: a MorphicRenderLoop
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
a MorphicRenderLoop

MorphicRenderLoop>>doOneCycleWhile:
	Receiver: a MorphicRenderLoop
	Arguments and temporary variables: 
		aBlock: 	[ true ]
	Receiver's instance variables: 
a MorphicRenderLoop

[ MorphicRenderLoop new doOneCycleWhile: [ true ] ] in MorphicUIManager>>spawnNewProcess
	Receiver: a MorphicUIManager
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		activeTranscript: 	nil


[self value.
			"IMPORTANT: Do not step over next line of code. See method comments for details"
			Processor terminateRealActive] in FullBlockClosure(BlockClosure)>>newProcess
	Receiver: [ MorphicRenderLoop new doOneCycleWhile: [ true ] ]
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		outerContext: 	MorphicUIManager>>spawnNewProcess
		compiledBlock: 	a CompiledBlock: [ MorphicRenderLoop new doOneCycleWhile: [ [..]
		numArgs: 	0
		receiver: 	a MorphicUIManager



--- The full stack ---
UndefinedObject(Object)>>doesNotUnderstand: #asLowercase
UndefinedObject>>doesNotUnderstand: #asLowercase
MCPackage>>hash
Dictionary>>scanFor:
Dictionary(HashedCollection)>>findElementOrNil:
Dictionary>>at:ifAbsent:
MCWorkingCopy class(MCPackageManager class)>>forPackage:
MCFileRepositoryInspector>>saveChanges
MCFileRepositoryInspector(MCTool)>>performButtonAction:enabled:
PluggableButtonMorph>>performAction:
[:m |
		(m containsPoint: evt cursorPoint) ifTrue: [m enabled ifTrue: [ m performAction: evt ]]] in PluggableButtonMorph>>mouseUp:
Array(SequenceableCollection)>>do:
PluggableButtonMorph>>mouseUp:
PluggableButtonMorph(Morph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
PluggableButtonMorph(Morph)>>handleEvent:
PluggableButtonMorph(Morph)>>handleFocusEvent:
[
		result := focusHolder handleFocusEvent: transformedEvent.
	] in HandMorph>>sendFocusEvent:to:clear:
FullBlockClosure(BlockClosure)>>on:do:
WorldMorph>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil ]) ifTrue: [
			morphicWorld activeHand handleEvent: anEvent
		]
	] in OSWindowMorphicEventHandler>>dispatchMorphicEvent:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycleNow
WorldMorph>>doOneCycle
[
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMutex critical: [
			                     self extraWorldList ].
		extraWorldsToDraw do: [ :world | world doOneCycle ].

		(self currentWorld isNotNil and: [
			 (extraWorldsToDraw includes: self currentWorld) not ]) ifTrue: [
			self currentWorld doOneCycle ] ] in WorldMorph class>>doOneCycle
FullBlockClosure(BlockClosure)>>ensure:
WorldState class>>doDrawCycleWith:
WorldMorph class>>doOneCycle
MorphicRenderLoop>>doOneCycle
MorphicRenderLoop>>doOneCycleWhile:
[ MorphicRenderLoop new doOneCycleWhile: [ true ] ] in MorphicUIManager>>spawnNewProcess
[self value.
			"IMPORTANT: Do not step over next line of code. See method comments for details"
			Processor terminateRealActive] in FullBlockClosure(BlockClosure)>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
#new was sent to nil
13 November 2023 6:25:43.510632 pm

VM: Mac OS - arm64 - 1000 - CoInterpreter VMMaker-tonel.1 uuid: 902dd483-c0c4-0d00-86f2-0f880df24b96 Oct 23 2023
StackToRegisterMappingCogit VMMaker-tonel.1 uuid: 902dd483-c0c4-0d00-86f2-0f880df24b96 Oct 23 2023
v10.0.8 - Commit: b323c5fb - Date: 2023-10-20 16:02:07 -0400

Image: Pharo11.0.0 [Build information: Pharo-11.0.0+build.710.sha.ea28d8552cac85a7ce1e9c34ab1e7bd45f7b9910 (64 Bit)]

UndefinedObject(Object)>>doesNotUnderstand: #new
	Receiver: nil
	Arguments and temporary variables: 
		aMessage: 	new
		exception: 	#new was sent to nil
		resumeValue: 	nil
	Receiver's instance variables: 
nil

UndefinedObject>>doesNotUnderstand: #new
	Receiver: nil
	Arguments and temporary variables: 
		node: 	nil
		aMessage: 	new
		exception: 	nil
		resumeValue: 	nil
	Receiver's instance variables: 
nil

GraphVisualizer>>initialize
	Receiver: a GraphVisualizer
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		view: 	nil
		nodes: 	nil
		edges: 	nil
		nodesMap: 	nil
		RSView: 	nil


GraphVisualizer class(Behavior)>>new
	Receiver: GraphVisualizer
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary(#createEdges->GraphVisualizer>>#createEdges [..]
		format: 	65541
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		commentSourcePointer: 	nil
		subclasses: 	#()
		name: 	#GraphVisualizer
		classPool: 	nil
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#Visualizer


UndefinedObject>>DoIt
	Receiver: nil
	Arguments and temporary variables: 
		visualizer: 	nil
	Receiver's instance variables: 
nil

OCReceiverDoItSemanticScope(OCDoItSemanticScope)>>evaluateDoIt:
	Receiver: an OCReceiverDoItSemanticScope
	Arguments and temporary variables: 
		doItMethod: 	UndefinedObject>>#DoIt
	Receiver's instance variables: 
		outerScope: 	nil
		targetReceiver: 	nil


OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
		doItMethod: 	UndefinedObject>>#DoIt
	Receiver's instance variables: 
		ast: 	DoIt

	| visualizer |
	visualizer := GraphVisualizer new.
	^ visualize[..]
		source: 	a ReadStream
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil


[
		self announcer announce: (SpCodeWillBeEvaluatedAnnouncement newContent: aString).
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionModel doItReceiver.
		result := receiver class compiler
			source: aString;
			context: self interactionModel doItContext;
			receiver: self interactionModel doItReceiver;
			requestor: self interactionModel;
			environment: self environment;
			failBlock:  [ 
				self announcer announce: (SpCodeEvaluationFailedAnnouncement newContent: aString).
				^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		self announcer announce: (SpCodeEvaluationSucceedAnnouncement newContent: aString).
		result ] in SpCodePresenter>>evaluate:onCompileError:onError:
	Receiver: a SpCodePresenter
	Arguments and temporary variables: 
		aString: 	'| visualizer |
visualizer := GraphVisualizer new.
visualizer visu[..]
		compileErrorBlock: 	[ ^ self ]
		errorBlock: 	[ :e | e pass ]
		receiver: 	nil
		result: 	nil
		oldBindings: 	a Dictionary()
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicCodeAdapter)
		announcer: 	an Announcer
		owner: 	a StPlaygroundPagePresenter
		adapter: 	a SpMorphicCodeAdapter
		needRebuild: 	true
		eventHandler: 	a SpEventHandler
		application: 	nil
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ a KMCategory ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Code' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpAbstractWidgetLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		borderWidth: 	an ObservableValueHolder[ nil ]
		borderColor: 	an ObservableValueHolder[ nil ]
		dragEnabled: 	an ObservableValueHolder[ false ]
		dropEnabled: 	an ObservableValueHolder[ false ]
		color: 	an ObservableValueHolder[ nil ]
		help: 	an ObservableValueHolder[ nil ]
		enabled: 	an ObservableValueHolder[ true ]
		wantsDrop: 	an ObservableValueHolder[ [ :transfer | self dropEnabled ] ]
		acceptDrop: 	an ObservableValueHolder[ [ :transfer | ] ]
		deferredActions: 	nil
		hasUnacceptedEdits: 	an ObservableValueHolder[ false ]
		selection: 	an ObservableValueHolder[ (1 to: 160) ]
		wantsVisualFeedback: 	an ObservableValueHolder[ true ]
		askBeforeDiscardingEdits: 	an ObservableValueHolder[ true ]
		text: 	an ObservableValueHolder[ '| visualizer |
visualizer := GraphVisualiz[..]
		actionToPerform: 	an ObservableValueHolder[ [ :txt |  ] ]
		readSelection: 	an ObservableValueHolder[ [ selection ] ]
		placeholder: 	an ObservableValueHolder[ '' ]
		contextMenu: 	an ObservableValueHolder[ [ (self menuActionsFor: text) asMenu[..]
		scrollValue: 	an ObservableValueHolder[ (0@0) ]
		editionContextMenu: 	an ObservableValueHolder[ true ]
		editable: 	an ObservableValueHolder[ true ]
		wrapWord: 	an ObservableValueHolder[ true ]
		undoRedoHistory: 	true
		wrapScrollBars: 	true
		propagateNaturalHeight: 	false
		propagateNaturalWidth: 	false
		scrollBarStyles: 	#()
		syntaxHighlight: 	an ObservableValueHolder[ true ]
		smartCharacters: 	an ObservableValueHolder[ true ]
		lineNumbers: 	an ObservableValueHolder[ true ]
		interactionModel: 	an ObservableValueHolder[ a StPlaygroundInteractionModel ]
		overrideContextMenu: 	true
		submitBlock: 	nil
		resetBlock: 	nil
		environment: 	nil
		systemNavigation: 	nil
		syntaxHighlightTheme: 	an ObservableValueHolder[ nil ]


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
		self announcer announce: (SpCodeWillBeEvaluatedAnnouncement newContent: aString).
[..]
	Arguments and temporary variables: 
		exception: 	Error
		handlerAction: 	[ :e |
		self announcer announce: (SpCodeEvaluationFailedAnn[..]
	Receiver's instance variables: 
		outerContext: 	SpCodePresenter>>evaluate:onCompileError:onError:
		compiledBlock: 	a CompiledBlock: [
		self announcer announce: (SpCodeWillBeE[..]
		numArgs: 	0
		receiver: 	a SpCodePresenter


SpCodePresenter>>evaluate:onCompileError:onError:
	Receiver: a SpCodePresenter
	Arguments and temporary variables: 
		receiver: 	nil
		result: 	nil
		oldBindings: 	a Dictionary()
		aString: 	'| visualizer |
visualizer := GraphVisualizer new.
visualizer visu[..]
		compileErrorBlock: 	[ ^ self ]
		errorBlock: 	[ :e | e pass ]
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicCodeAdapter)
		announcer: 	an Announcer
		owner: 	a StPlaygroundPagePresenter
		adapter: 	a SpMorphicCodeAdapter
		needRebuild: 	true
		eventHandler: 	a SpEventHandler
		application: 	nil
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ a KMCategory ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Code' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpAbstractWidgetLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		borderWidth: 	an ObservableValueHolder[ nil ]
		borderColor: 	an ObservableValueHolder[ nil ]
		dragEnabled: 	an ObservableValueHolder[ false ]
		dropEnabled: 	an ObservableValueHolder[ false ]
		color: 	an ObservableValueHolder[ nil ]
		help: 	an ObservableValueHolder[ nil ]
		enabled: 	an ObservableValueHolder[ true ]
		wantsDrop: 	an ObservableValueHolder[ [ :transfer | self dropEnabled ] ]
		acceptDrop: 	an ObservableValueHolder[ [ :transfer | ] ]
		deferredActions: 	nil
		hasUnacceptedEdits: 	an ObservableValueHolder[ false ]
		selection: 	an ObservableValueHolder[ (1 to: 160) ]
		wantsVisualFeedback: 	an ObservableValueHolder[ true ]
		askBeforeDiscardingEdits: 	an ObservableValueHolder[ true ]
		text: 	an ObservableValueHolder[ '| visualizer |
visualizer := GraphVisualiz[..]
		actionToPerform: 	an ObservableValueHolder[ [ :txt |  ] ]
		readSelection: 	an ObservableValueHolder[ [ selection ] ]
		placeholder: 	an ObservableValueHolder[ '' ]
		contextMenu: 	an ObservableValueHolder[ [ (self menuActionsFor: text) asMenu[..]
		scrollValue: 	an ObservableValueHolder[ (0@0) ]
		editionContextMenu: 	an ObservableValueHolder[ true ]
		editable: 	an ObservableValueHolder[ true ]
		wrapWord: 	an ObservableValueHolder[ true ]
		undoRedoHistory: 	true
		wrapScrollBars: 	true
		propagateNaturalHeight: 	false
		propagateNaturalWidth: 	false
		scrollBarStyles: 	#()
		syntaxHighlight: 	an ObservableValueHolder[ true ]
		smartCharacters: 	an ObservableValueHolder[ true ]
		lineNumbers: 	an ObservableValueHolder[ true ]
		interactionModel: 	an ObservableValueHolder[ a StPlaygroundInteractionModel ]
		overrideContextMenu: 	true
		submitBlock: 	nil
		resetBlock: 	nil
		environment: 	nil
		systemNavigation: 	nil
		syntaxHighlightTheme: 	an ObservableValueHolder[ nil ]


StPlaygroundPagePresenter>>doEvaluateAndGo
	Receiver: a StPlaygroundPagePresenter
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicBoxAdapter)
		announcer: 	an Announcer
		owner: 	a SpMillerColumnPresenter
		adapter: 	a SpMorphicBoxAdapter
		needRebuild: 	true
		eventHandler: 	nil
		application: 	a StPharoApplication
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ nil ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Untitled window' ]
		additionalSubpresentersMap: 	a Dictionary()
		layout: 	an ObservableValueHolder[ a SpBoxLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		text: 	a SpCodePresenter
		toolbar: 	a SpToolbarPresenter
		statusbar: 	a SpPresenter
		lineLabel: 	a SpLabelPresenter
		toggleLineNumberButton: 	a SpToggleButtonPresenter
		page: 	a StPlaygroundPage
		activationBlock: 	[ :selection |
		self changeSelection: selection from: new[..]


StPlaygroundPagePresenter>>doEvaluateAllAndGo
	Receiver: a StPlaygroundPagePresenter
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicBoxAdapter)
		announcer: 	an Announcer
		owner: 	a SpMillerColumnPresenter
		adapter: 	a SpMorphicBoxAdapter
		needRebuild: 	true
		eventHandler: 	nil
		application: 	a StPharoApplication
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ nil ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Untitled window' ]
		additionalSubpresentersMap: 	a Dictionary()
		layout: 	an ObservableValueHolder[ a SpBoxLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		text: 	a SpCodePresenter
		toolbar: 	a SpToolbarPresenter
		statusbar: 	a SpPresenter
		lineLabel: 	a SpLabelPresenter
		toggleLineNumberButton: 	a SpToggleButtonPresenter
		page: 	a StPlaygroundPage
		activationBlock: 	[ :selection |
		self changeSelection: selection from: new[..]


StPlaygroundDoItCommand>>execute
	Receiver: a StPlaygroundDoItCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		context: 	a StPlaygroundPagePresenter
		basicName: 	'Do it'
		basicDescription: 	'Do it all and inspect.'


SpCommand(CmCommandDecorator)>>execute
	Receiver: a SpCommand(Do it)
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a StPlaygroundDoItCommand
		iconProvider: 	a StPharoApplication
		iconName: 	#glamorousGo
		shortcutKey: 	nil
		displayStrategy: 	a CmUIDisableWhenCantBeRun
		positionStrategy: 	a CmUILeftPositionStrategy
		buildPresenterBlock: 	[ :specCommand | 
			aButtonClass new
				label: specC[..]
		presenter: 	a SpToolbarButtonPresenter


[ specCommand execute ] in [ :specCommand | 
			aButtonClass new
				label: specCommand name;
				help: specCommand description;
				in: [ :button | 
					specCommand hasIcon
						ifTrue: [ button icon: specCommand icon ] ];
				action: [ specCommand execute ];
				yourself ] in SpCommand>>configureAsButtonOfClass:
	Receiver: a SpCommand(Do it)
	Arguments and temporary variables: 
		aButtonClass: 	nil
		specCommand: 	a SpCommand(Do it)
	Receiver's instance variables: 
		decoratedCommand: 	a StPlaygroundDoItCommand
		iconProvider: 	a StPharoApplication
		iconName: 	#glamorousGo
		shortcutKey: 	nil
		displayStrategy: 	a CmUIDisableWhenCantBeRun
		positionStrategy: 	a CmUILeftPositionStrategy
		buildPresenterBlock: 	[ :specCommand | 
			aButtonClass new
				label: specC[..]
		presenter: 	a SpToolbarButtonPresenter


FullBlockClosure(BlockClosure)>>cull:
	Receiver: [ specCommand execute ]
	Arguments and temporary variables: 
		anArg: 	a SpToolbarButtonPresenter
	Receiver's instance variables: 
		outerContext: 	[ :specCommand | 
			aButtonClass new
				label: specCommand [..]
		compiledBlock: 	a CompiledBlock: [ specCommand execute ]
		numArgs: 	0
		receiver: 	a SpCommand(Do it)


SpMorphicToolbarButtonAdapter>>execute
	Receiver: a SpMorphicToolbarButtonAdapter
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpToolbarButtonMorph(319944704))
		announcer: 	nil
		model: 	a SpToolbarButtonPresenter
		widget: 	a SpToolbarButtonMorph(319944704)
		selector: 	nil
		owner: 	a SpToolbarButtonPresenter
		unsubscribed: 	false


SpToolbarButtonMorph(PluggableButtonMorph)>>performAction:
	Receiver: a SpToolbarButtonMorph(319944704)
	Arguments and temporary variables: 
		event: 	[(24.0@26.0) mouseUp 8461620 nil]
	Receiver's instance variables: 
		bounds: 	(0.0@5.0) corner: (45.0@39.0)
		owner: 	a Morph(13467904)
		submorphs: 	an Array(an AlignmentMorph(869548288))
		fullBounds: 	nil
		color: 	(Color r: 0.9012707722385142 g: 0.9012707722385142 b: 0.901270772238[..]
		extension: 	a MorphExtension (545772544) [balloonText]  [other:  (presenter [..]
		borderWidth: 	0
		borderColor: 	#simple
		model: 	a SpMorphicToolbarButtonAdapter
		label: 	'Do it'
		icon: 	Form(13x13x32)
		getIconSelector: 	#icon
		getStateSelector: 	#state
		actionSelector: 	#execute
		font: 	a LogicalFont
 familyName: 'Source Sans Pro'
 emphasis: nil
 pointSiz[..]
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	nil
		getFontSelector: 	nil
		labelMorph: 	a LabelMorph(424853504)'Do it'
		iconMorph: 	an ImageMorph(356841984)
		iconPosition: 	#top
		lastState: 	false
		badgeFont: 	nil
		badgeSelector: 	#badge


[:m |
		(m containsPoint: evt cursorPoint) ifTrue: [m enabled ifTrue: [ m performAction: evt ]]] in SpToolbarButtonMorph(PluggableButtonMorph)>>mouseUp:
	Receiver: a SpToolbarButtonMorph(319944704)
	Arguments and temporary variables: 
		evt: 	[(24.0@26.0) mouseUp 8461620 nil]
		all: 	an Array(a SpToolbarButtonMorph(319944704) a SpToolbarButtonMorph(5749[..]
		m: 	a SpToolbarButtonMorph(319944704)
	Receiver's instance variables: 
		bounds: 	(0.0@5.0) corner: (45.0@39.0)
		owner: 	a Morph(13467904)
		submorphs: 	an Array(an AlignmentMorph(869548288))
		fullBounds: 	nil
		color: 	(Color r: 0.9012707722385142 g: 0.9012707722385142 b: 0.901270772238[..]
		extension: 	a MorphExtension (545772544) [balloonText]  [other:  (presenter [..]
		borderWidth: 	0
		borderColor: 	#simple
		model: 	a SpMorphicToolbarButtonAdapter
		label: 	'Do it'
		icon: 	Form(13x13x32)
		getIconSelector: 	#icon
		getStateSelector: 	#state
		actionSelector: 	#execute
		font: 	a LogicalFont
 familyName: 'Source Sans Pro'
 emphasis: nil
 pointSiz[..]
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	nil
		getFontSelector: 	nil
		labelMorph: 	a LabelMorph(424853504)'Do it'
		iconMorph: 	an ImageMorph(356841984)
		iconPosition: 	#top
		lastState: 	false
		badgeFont: 	nil
		badgeSelector: 	#badge


Array(SequenceableCollection)>>do:
	Receiver: an Array(a SpToolbarButtonMorph(319944704) a SpToolbarButtonMorph(574995456) a SpToolb[..]
	Arguments and temporary variables: 
		aBlock: 	[:m |
		(m containsPoint: evt cursorPoint) ifTrue: [m enabled ifTru[..]
		index: 	1
	Receiver's instance variables: 
an Array(a SpToolbarButtonMorph(319944704) a SpToolbarButtonMorph(574995456) a SpToolb[..]

SpToolbarButtonMorph(PluggableButtonMorph)>>mouseUp:
	Receiver: a SpToolbarButtonMorph(319944704)
	Arguments and temporary variables: 
		evt: 	[(24.0@26.0) mouseUp 8461620 nil]
		all: 	an Array(a SpToolbarButtonMorph(319944704) a SpToolbarButtonMorph(5749[..]
	Receiver's instance variables: 
		bounds: 	(0.0@5.0) corner: (45.0@39.0)
		owner: 	a Morph(13467904)
		submorphs: 	an Array(an AlignmentMorph(869548288))
		fullBounds: 	nil
		color: 	(Color r: 0.9012707722385142 g: 0.9012707722385142 b: 0.901270772238[..]
		extension: 	a MorphExtension (545772544) [balloonText]  [other:  (presenter [..]
		borderWidth: 	0
		borderColor: 	#simple
		model: 	a SpMorphicToolbarButtonAdapter
		label: 	'Do it'
		icon: 	Form(13x13x32)
		getIconSelector: 	#icon
		getStateSelector: 	#state
		actionSelector: 	#execute
		font: 	a LogicalFont
 familyName: 'Source Sans Pro'
 emphasis: nil
 pointSiz[..]
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	nil
		getFontSelector: 	nil
		labelMorph: 	a LabelMorph(424853504)'Do it'
		iconMorph: 	an ImageMorph(356841984)
		iconPosition: 	#top
		lastState: 	false
		badgeFont: 	nil
		badgeSelector: 	#badge


SpToolbarButtonMorph(Morph)>>handleMouseUp:
	Receiver: a SpToolbarButtonMorph(319944704)
	Arguments and temporary variables: 
		anEvent: 	[(24.0@26.0) mouseUp 8461620 nil]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(0.0@5.0) corner: (45.0@39.0)
		owner: 	a Morph(13467904)
		submorphs: 	an Array(an AlignmentMorph(869548288))
		fullBounds: 	nil
		color: 	(Color r: 0.9012707722385142 g: 0.9012707722385142 b: 0.901270772238[..]
		extension: 	a MorphExtension (545772544) [balloonText]  [other:  (presenter [..]
		borderWidth: 	0
		borderColor: 	#simple
		model: 	a SpMorphicToolbarButtonAdapter
		label: 	'Do it'
		icon: 	Form(13x13x32)
		getIconSelector: 	#icon
		getStateSelector: 	#state
		actionSelector: 	#execute
		font: 	a LogicalFont
 familyName: 'Source Sans Pro'
 emphasis: nil
 pointSiz[..]
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	nil
		getFontSelector: 	nil
		labelMorph: 	a LabelMorph(424853504)'Do it'
		iconMorph: 	an ImageMorph(356841984)
		iconPosition: 	#top
		lastState: 	false
		badgeFont: 	nil
		badgeSelector: 	#badge


MouseButtonEvent>>sentTo:
	Receiver: [(24.0@26.0) mouseUp 8461620 nil]
	Arguments and temporary variables: 
		anObject: 	a SpToolbarButtonMorph(319944704)
	Receiver's instance variables: 
		timeStamp: 	8461620
		source: 	a HandMorph(337424384)
		windowIndex: 	nil
		type: 	#mouseUp
		buttons: 	0
		position: 	(24.0@26.0)
		handler: 	nil
		wasHandled: 	true
		whichButton: 	4


SpToolbarButtonMorph(Morph)>>handleEvent:
	Receiver: a SpToolbarButtonMorph(319944704)
	Arguments and temporary variables: 
		anEvent: 	[(24.0@26.0) mouseUp 8461620 nil]
	Receiver's instance variables: 
		bounds: 	(0.0@5.0) corner: (45.0@39.0)
		owner: 	a Morph(13467904)
		submorphs: 	an Array(an AlignmentMorph(869548288))
		fullBounds: 	nil
		color: 	(Color r: 0.9012707722385142 g: 0.9012707722385142 b: 0.901270772238[..]
		extension: 	a MorphExtension (545772544) [balloonText]  [other:  (presenter [..]
		borderWidth: 	0
		borderColor: 	#simple
		model: 	a SpMorphicToolbarButtonAdapter
		label: 	'Do it'
		icon: 	Form(13x13x32)
		getIconSelector: 	#icon
		getStateSelector: 	#state
		actionSelector: 	#execute
		font: 	a LogicalFont
 familyName: 'Source Sans Pro'
 emphasis: nil
 pointSiz[..]
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	nil
		getFontSelector: 	nil
		labelMorph: 	a LabelMorph(424853504)'Do it'
		iconMorph: 	an ImageMorph(356841984)
		iconPosition: 	#top
		lastState: 	false
		badgeFont: 	nil
		badgeSelector: 	#badge


SpToolbarButtonMorph(Morph)>>handleFocusEvent:
	Receiver: a SpToolbarButtonMorph(319944704)
	Arguments and temporary variables: 
		anEvent: 	[(24.0@26.0) mouseUp 8461620 nil]
	Receiver's instance variables: 
		bounds: 	(0.0@5.0) corner: (45.0@39.0)
		owner: 	a Morph(13467904)
		submorphs: 	an Array(an AlignmentMorph(869548288))
		fullBounds: 	nil
		color: 	(Color r: 0.9012707722385142 g: 0.9012707722385142 b: 0.901270772238[..]
		extension: 	a MorphExtension (545772544) [balloonText]  [other:  (presenter [..]
		borderWidth: 	0
		borderColor: 	#simple
		model: 	a SpMorphicToolbarButtonAdapter
		label: 	'Do it'
		icon: 	Form(13x13x32)
		getIconSelector: 	#icon
		getStateSelector: 	#state
		actionSelector: 	#execute
		font: 	a LogicalFont
 familyName: 'Source Sans Pro'
 emphasis: nil
 pointSiz[..]
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	nil
		getFontSelector: 	nil
		labelMorph: 	a LabelMorph(424853504)'Do it'
		iconMorph: 	an ImageMorph(356841984)
		iconPosition: 	#top
		lastState: 	false
		badgeFont: 	nil
		badgeSelector: 	#badge


[
		result := focusHolder handleFocusEvent: transformedEvent.
	] in HandMorph>>sendFocusEvent:to:clear:
	Receiver: a HandMorph(337424384)
	Arguments and temporary variables: 
		anEvent: 	[(543@344) mouseUp 8461620 nil]
		focusHolder: 	a SpToolbarButtonMorph(319944704)
		aBlock: 	[self mouseFocus: nil]
		w: 	a WorldMorph(341720576) [world]
		transformedEvent: 	[(24.0@26.0) mouseUp 8461620 nil]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(543@344.0) corner: (559@360.0)
		owner: 	a WorldMorph(341720576) [world]
		submorphs: 	#()
		fullBounds: 	(543@344.0) corner: (559@360.0)
		color: 	Color blue
		extension: 	a MorphExtension (370611968)
		mouseFocus: 	nil
		keyboardFocus: 	a RubEditingArea(189250304)
		eventListeners: 	nil
		mouseListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(543@344) mouseUp 8461620 nil]
		targetOffset: 	(24.0@21.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	true
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 0 0 0 0 0 nil nil)
		captureBlock: 	nil
		recentModifiers: 	0
		pendingEventQueue: 	WaitfreeQueue with 0 items
		supressNextKeyPress: 	false


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
		result := focusHolder handleFocusEvent: transformedEvent.
	]
	Arguments and temporary variables: 
		exception: 	Error
		handlerAction: 	[ :ex |
			ActiveWorld := priorWorld.
			ex pass ]
	Receiver's instance variables: 
		outerContext: 	HandMorph>>sendFocusEvent:to:clear:
		compiledBlock: 	a CompiledBlock: [
		result := focusHolder handleFocusEvent:[..]
		numArgs: 	0
		receiver: 	a HandMorph(337424384)


WorldMorph>>becomeActiveDuring:
	Receiver: a WorldMorph(341720576) [world]
	Arguments and temporary variables: 
		aBlock: 	[
		result := focusHolder handleFocusEvent: transformedEvent.
	]
		priorWorld: 	a WorldMorph(341720576) [world]
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1728@1080)
		owner: 	nil
		submorphs: 	an Array(a MenubarMorph(112886016) a TaskbarMorph(279458560) a S[..]
		fullBounds: 	(0@0) corner: (1728@1080)
		color: 	(Color r: 0.9403714565004888 g: 0.9403714565004888 b: 0.940371456500[..]
		extension: 	a MorphExtension (1012946432) [other:  (dragEnabled -> true) (dr[..]
		borderWidth: 	0
		borderColor: 	(Color r: 0.8611925708699902 g: 1.0 b: 0.7223851417399805 alph[..]
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil


HandMorph>>sendFocusEvent:to:clear:
	Receiver: a HandMorph(337424384)
	Arguments and temporary variables: 
		result: 	nil
		anEvent: 	[(543@344) mouseUp 8461620 nil]
		focusHolder: 	a SpToolbarButtonMorph(319944704)
		aBlock: 	[self mouseFocus: nil]
		w: 	a WorldMorph(341720576) [world]
		transformedEvent: 	[(24.0@26.0) mouseUp 8461620 nil]
	Receiver's instance variables: 
		bounds: 	(543@344.0) corner: (559@360.0)
		owner: 	a WorldMorph(341720576) [world]
		submorphs: 	#()
		fullBounds: 	(543@344.0) corner: (559@360.0)
		color: 	Color blue
		extension: 	a MorphExtension (370611968)
		mouseFocus: 	nil
		keyboardFocus: 	a RubEditingArea(189250304)
		eventListeners: 	nil
		mouseListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(543@344) mouseUp 8461620 nil]
		targetOffset: 	(24.0@21.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	true
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 0 0 0 0 0 nil nil)
		captureBlock: 	nil
		recentModifiers: 	0
		pendingEventQueue: 	WaitfreeQueue with 0 items
		supressNextKeyPress: 	false


HandMorph>>sendEvent:focus:clear:
	Receiver: a HandMorph(337424384)
	Arguments and temporary variables: 
		anEvent: 	[(543@344) mouseUp 8461620 nil]
		focusHolder: 	a SpToolbarButtonMorph(319944704)
		aBlock: 	[self mouseFocus: nil]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(543@344.0) corner: (559@360.0)
		owner: 	a WorldMorph(341720576) [world]
		submorphs: 	#()
		fullBounds: 	(543@344.0) corner: (559@360.0)
		color: 	Color blue
		extension: 	a MorphExtension (370611968)
		mouseFocus: 	nil
		keyboardFocus: 	a RubEditingArea(189250304)
		eventListeners: 	nil
		mouseListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(543@344) mouseUp 8461620 nil]
		targetOffset: 	(24.0@21.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	true
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 0 0 0 0 0 nil nil)
		captureBlock: 	nil
		recentModifiers: 	0
		pendingEventQueue: 	WaitfreeQueue with 0 items
		supressNextKeyPress: 	false


HandMorph>>sendMouseEvent:
	Receiver: a HandMorph(337424384)
	Arguments and temporary variables: 
		anEvent: 	[(543@344) mouseUp 8461620 nil]
	Receiver's instance variables: 
		bounds: 	(543@344.0) corner: (559@360.0)
		owner: 	a WorldMorph(341720576) [world]
		submorphs: 	#()
		fullBounds: 	(543@344.0) corner: (559@360.0)
		color: 	Color blue
		extension: 	a MorphExtension (370611968)
		mouseFocus: 	nil
		keyboardFocus: 	a RubEditingArea(189250304)
		eventListeners: 	nil
		mouseListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(543@344) mouseUp 8461620 nil]
		targetOffset: 	(24.0@21.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	true
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 0 0 0 0 0 nil nil)
		captureBlock: 	nil
		recentModifiers: 	0
		pendingEventQueue: 	WaitfreeQueue with 0 items
		supressNextKeyPress: 	false


HandMorph>>handleEvent:
	Receiver: a HandMorph(337424384)
	Arguments and temporary variables: 
		anEvent: 	[(543@344) mouseUp 8461620 nil]
		evt: 	[(543@344) mouseUp 8461620 nil]
	Receiver's instance variables: 
		bounds: 	(543@344.0) corner: (559@360.0)
		owner: 	a WorldMorph(341720576) [world]
		submorphs: 	#()
		fullBounds: 	(543@344.0) corner: (559@360.0)
		color: 	Color blue
		extension: 	a MorphExtension (370611968)
		mouseFocus: 	nil
		keyboardFocus: 	a RubEditingArea(189250304)
		eventListeners: 	nil
		mouseListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(543@344) mouseUp 8461620 nil]
		targetOffset: 	(24.0@21.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	true
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 0 0 0 0 0 nil nil)
		captureBlock: 	nil
		recentModifiers: 	0
		pendingEventQueue: 	WaitfreeQueue with 0 items
		supressNextKeyPress: 	false


[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil ]) ifTrue: [
			morphicWorld activeHand handleEvent: anEvent
		]
	] in OSWindowMorphicEventHandler>>dispatchMorphicEvent:
	Receiver: an OSWindowMorphicEventHandler
	Arguments and temporary variables: 
		anEvent: 	[(543@344) mouseUp 8461620 nil]
	Receiver's instance variables: 
		morphicWorld: 	a WorldMorph(341720576) [world]


WorldState>>runStepMethodsIn:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(341720576) [world]
		queue: 	WaitfreeQueue with 0 items
		nextInQueue: 	[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNo[..]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(337424384))
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap()
		lastStepTime: 	8349811
		lastStepMessage: 	nil
		alarms: 	a Heap(MorphicAlarm(#hideShow -> a RubCursor(898368768)))
		lastAlarmTime: 	8461598
		activeHand: 	a HandMorph(337424384)
		currentCursor: 	((CursorWithMask
	extent: (16@16)
	depth: 1
	fromArray: #(
	[..]
		worldRenderer: 	an OSWorldRenderer
		realWindowExtent: 	(1728@1080)
		deferredUIMessages: 	WaitfreeQueue with 0 items


WorldMorph>>runStepMethods
	Receiver: a WorldMorph(341720576) [world]
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1728@1080)
		owner: 	nil
		submorphs: 	an Array(a MenubarMorph(112886016) a TaskbarMorph(279458560) a S[..]
		fullBounds: 	(0@0) corner: (1728@1080)
		color: 	(Color r: 0.9403714565004888 g: 0.9403714565004888 b: 0.940371456500[..]
		extension: 	a MorphExtension (1012946432) [other:  (dragEnabled -> true) (dr[..]
		borderWidth: 	0
		borderColor: 	(Color r: 0.8611925708699902 g: 1.0 b: 0.7223851417399805 alph[..]
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil


WorldState>>doOneCycleFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(341720576) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(337424384))
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap()
		lastStepTime: 	8349811
		lastStepMessage: 	nil
		alarms: 	a Heap(MorphicAlarm(#hideShow -> a RubCursor(898368768)))
		lastAlarmTime: 	8461598
		activeHand: 	a HandMorph(337424384)
		currentCursor: 	((CursorWithMask
	extent: (16@16)
	depth: 1
	fromArray: #(
	[..]
		worldRenderer: 	an OSWorldRenderer
		realWindowExtent: 	(1728@1080)
		deferredUIMessages: 	WaitfreeQueue with 0 items


WorldMorph>>doOneCycleNow
	Receiver: a WorldMorph(341720576) [world]
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1728@1080)
		owner: 	nil
		submorphs: 	an Array(a MenubarMorph(112886016) a TaskbarMorph(279458560) a S[..]
		fullBounds: 	(0@0) corner: (1728@1080)
		color: 	(Color r: 0.9403714565004888 g: 0.9403714565004888 b: 0.940371456500[..]
		extension: 	a MorphExtension (1012946432) [other:  (dragEnabled -> true) (dr[..]
		borderWidth: 	0
		borderColor: 	(Color r: 0.8611925708699902 g: 1.0 b: 0.7223851417399805 alph[..]
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil


WorldMorph>>doOneCycle
	Receiver: a WorldMorph(341720576) [world]
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1728@1080)
		owner: 	nil
		submorphs: 	an Array(a MenubarMorph(112886016) a TaskbarMorph(279458560) a S[..]
		fullBounds: 	(0@0) corner: (1728@1080)
		color: 	(Color r: 0.9403714565004888 g: 0.9403714565004888 b: 0.940371456500[..]
		extension: 	a MorphExtension (1012946432) [other:  (dragEnabled -> true) (dr[..]
		borderWidth: 	0
		borderColor: 	(Color r: 0.8611925708699902 g: 1.0 b: 0.7223851417399805 alph[..]
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil


[
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMutex critical: [
			                     self extraWorldList ].
		extraWorldsToDraw do: [ :world | world doOneCycle ].

		(self currentWorld isNotNil and: [
			 (extraWorldsToDraw includes: self currentWorld) not ]) ifTrue: [
			self currentWorld doOneCycle ] ] in WorldMorph class>>doOneCycle
	Receiver: WorldMorph
	Arguments and temporary variables: 
		extraWorldsToDraw: 	#()
	Receiver's instance variables: 
		superclass: 	PasteUpMorph
		methodDict: 	a MethodDictionary(#acceptDroppingMorph:event:->WorldMorph>>#ac[..]
		format: 	65547
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		commentSourcePointer: 	nil
		subclasses: 	{AthensWorldMorph. OSWindowWorldMorph}
		name: 	#WorldMorph
		classPool: 	a Dictionary(#AllowDropFiles->nil #CursorOwnerWorld->a WorldMorp[..]
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Morphic-Core-Worlds'
		announcer: 	nil
		displayScaleFactor: 	1



--- The full stack ---
UndefinedObject(Object)>>doesNotUnderstand: #new
UndefinedObject>>doesNotUnderstand: #new
GraphVisualizer>>initialize
GraphVisualizer class(Behavior)>>new
UndefinedObject>>DoIt
OCReceiverDoItSemanticScope(OCDoItSemanticScope)>>evaluateDoIt:
OpalCompiler>>evaluate
[
		self announcer announce: (SpCodeWillBeEvaluatedAnnouncement newContent: aString).
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionModel doItReceiver.
		result := receiver class compiler
			source: aString;
			context: self interactionModel doItContext;
			receiver: self interactionModel doItReceiver;
			requestor: self interactionModel;
			environment: self environment;
			failBlock:  [ 
				self announcer announce: (SpCodeEvaluationFailedAnnouncement newContent: aString).
				^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		self announcer announce: (SpCodeEvaluationSucceedAnnouncement newContent: aString).
		result ] in SpCodePresenter>>evaluate:onCompileError:onError:
FullBlockClosure(BlockClosure)>>on:do:
SpCodePresenter>>evaluate:onCompileError:onError:
StPlaygroundPagePresenter>>doEvaluateAndGo
StPlaygroundPagePresenter>>doEvaluateAllAndGo
StPlaygroundDoItCommand>>execute
SpCommand(CmCommandDecorator)>>execute
[ specCommand execute ] in [ :specCommand | 
			aButtonClass new
				label: specCommand name;
				help: specCommand description;
				in: [ :button | 
					specCommand hasIcon
						ifTrue: [ button icon: specCommand icon ] ];
				action: [ specCommand execute ];
				yourself ] in SpCommand>>configureAsButtonOfClass:
FullBlockClosure(BlockClosure)>>cull:
SpMorphicToolbarButtonAdapter>>execute
SpToolbarButtonMorph(PluggableButtonMorph)>>performAction:
[:m |
		(m containsPoint: evt cursorPoint) ifTrue: [m enabled ifTrue: [ m performAction: evt ]]] in SpToolbarButtonMorph(PluggableButtonMorph)>>mouseUp:
Array(SequenceableCollection)>>do:
SpToolbarButtonMorph(PluggableButtonMorph)>>mouseUp:
SpToolbarButtonMorph(Morph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
SpToolbarButtonMorph(Morph)>>handleEvent:
SpToolbarButtonMorph(Morph)>>handleFocusEvent:
[
		result := focusHolder handleFocusEvent: transformedEvent.
	] in HandMorph>>sendFocusEvent:to:clear:
FullBlockClosure(BlockClosure)>>on:do:
WorldMorph>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil ]) ifTrue: [
			morphicWorld activeHand handleEvent: anEvent
		]
	] in OSWindowMorphicEventHandler>>dispatchMorphicEvent:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycleNow
WorldMorph>>doOneCycle
[
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMutex critical: [
			                     self extraWorldList ].
		extraWorldsToDraw do: [ :world | world doOneCycle ].

		(self currentWorld isNotNil and: [
			 (extraWorldsToDraw includes: self currentWorld) not ]) ifTrue: [
			self currentWorld doOneCycle ] ] in WorldMorph class>>doOneCycle
 - - - - - - - - - - - - - - -
			- - - - - - - - - - - - - - - - - -
FullBlockClosure(BlockClosure)>>ensure:
WorldState class>>doDrawCycleWith:
WorldMorph class>>doOneCycle
MorphicRenderLoop>>doOneCycle
MorphicRenderLoop>>doOneCycleWhile:
ListDialogWindow(SystemWindow)>>openModal
ListDialogWindow>>chooseFromOwner:
ClyFullBrowserMethodContext(CmdToolContext)>>requestSingleMethodTag:suggesting:
ClyMethodTagsAndPackageEditorMorph>>requestTag
[
		self isExtensionActive
			ifTrue: [ self requestPackage]
			ifFalse: [ self requestTag ]
	] in ClyMethodTagsAndPackageEditorMorph>>openEditor
FullBlockClosure(BlockClosure)>>on:do:
ClyMethodTagsAndPackageEditorMorph>>requestChangeBy:
ClyMethodTagsAndPackageEditorMorph>>openEditor
MorphEventSubscription>>notify:from:
[ :s | result := result | ((s notify: anEvent from: sourceMorph) == true) ] in MorphicEventHandler>>notifyMorphsOfEvent:ofType:from:
Set>>do:
MorphicEventHandler>>notifyMorphsOfEvent:ofType:from:
MorphicEventHandler>>click:fromMorph:
LabelMorph(Morph)>>click:
MouseClickState>>click
MouseClickState>>handleEvent:from:
HandMorph>>handleEvent:
[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil ]) ifTrue: [
			morphicWorld activeHand handleEvent: anEvent
		]
	] in OSWindowMorphicEventHandler>>dispatchMorphicEvent:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycleNow
WorldMorph>>doOneCycle
[
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMutex critical: [
			                     self extraWorldList ].
		extraWorldsToDraw do: [ :world | world doOneCycle ].

		(self currentWorld isNotNil and: [
			 (extraWorldsToDraw includes: self currentWorld) not ]) ifTrue: [
			self currentWorld doOneCycle ] ] in WorldMorph class>>doOneCycle
FullBlockClosure(BlockClosure)>>ensure:
WorldState class>>doDrawCycleWith:
WorldMorph class>>doOneCycle
MorphicRenderLoop>>doOneCycle
MorphicRenderLoop>>doOneCycleWhile:
[ MorphicRenderLoop new doOneCycleWhile: [ true ] ] in MorphicUIManager>>spawnNewProcess
[self value.
			"IMPORTANT: Do not step over next line of code. See method comments for details"
			Processor terminateRealActive] in FullBlockClosure(BlockClosure)>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
#new was sent to nil
13 November 2023 6:25:43.539982 pm

VM: Mac OS - arm64 - 1000 - CoInterpreter VMMaker-tonel.1 uuid: 902dd483-c0c4-0d00-86f2-0f880df24b96 Oct 23 2023
StackToRegisterMappingCogit VMMaker-tonel.1 uuid: 902dd483-c0c4-0d00-86f2-0f880df24b96 Oct 23 2023
v10.0.8 - Commit: b323c5fb - Date: 2023-10-20 16:02:07 -0400

Image: Pharo11.0.0 [Build information: Pharo-11.0.0+build.710.sha.ea28d8552cac85a7ce1e9c34ab1e7bd45f7b9910 (64 Bit)]

UndefinedObject(Object)>>doesNotUnderstand: #new
	Receiver: nil
	Arguments and temporary variables: 
		aMessage: 	new
		exception: 	#new was sent to nil
		resumeValue: 	nil
	Receiver's instance variables: 
nil

UndefinedObject>>doesNotUnderstand: #new
	Receiver: nil
	Arguments and temporary variables: 
		node: 	nil
		aMessage: 	new
		exception: 	nil
		resumeValue: 	nil
	Receiver's instance variables: 
nil

GraphVisualizer>>initialize
	Receiver: a GraphVisualizer
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		view: 	nil
		nodes: 	nil
		edges: 	nil
		nodesMap: 	nil
		RSView: 	nil


GraphVisualizer class(Behavior)>>new
	Receiver: GraphVisualizer
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary(#createEdges->GraphVisualizer>>#createEdges [..]
		format: 	65541
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		commentSourcePointer: 	nil
		subclasses: 	#()
		name: 	#GraphVisualizer
		classPool: 	nil
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#Visualizer


UndefinedObject>>DoIt
	Receiver: nil
	Arguments and temporary variables: 
		visualizer: 	nil
	Receiver's instance variables: 
nil

OCReceiverDoItSemanticScope(OCDoItSemanticScope)>>evaluateDoIt:
	Receiver: an OCReceiverDoItSemanticScope
	Arguments and temporary variables: 
		doItMethod: 	UndefinedObject>>#DoIt
	Receiver's instance variables: 
		outerScope: 	nil
		targetReceiver: 	nil


OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
		doItMethod: 	UndefinedObject>>#DoIt
	Receiver's instance variables: 
		ast: 	DoIt

	| visualizer |
	visualizer := GraphVisualizer new.
	^ visualize[..]
		source: 	a ReadStream
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil


[
		self announcer announce: (SpCodeWillBeEvaluatedAnnouncement newContent: aString).
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionModel doItReceiver.
		result := receiver class compiler
			source: aString;
			context: self interactionModel doItContext;
			receiver: self interactionModel doItReceiver;
			requestor: self interactionModel;
			environment: self environment;
			failBlock:  [ 
				self announcer announce: (SpCodeEvaluationFailedAnnouncement newContent: aString).
				^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		self announcer announce: (SpCodeEvaluationSucceedAnnouncement newContent: aString).
		result ] in SpCodePresenter>>evaluate:onCompileError:onError:
	Receiver: a SpCodePresenter
	Arguments and temporary variables: 
		aString: 	'| visualizer |
visualizer := GraphVisualizer new.
visualizer visu[..]
		compileErrorBlock: 	[ ^ self ]
		errorBlock: 	[ :e | e pass ]
		receiver: 	nil
		result: 	nil
		oldBindings: 	a Dictionary()
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicCodeAdapter)
		announcer: 	an Announcer
		owner: 	a StPlaygroundPagePresenter
		adapter: 	a SpMorphicCodeAdapter
		needRebuild: 	true
		eventHandler: 	a SpEventHandler
		application: 	nil
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ a KMCategory ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Code' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpAbstractWidgetLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		borderWidth: 	an ObservableValueHolder[ nil ]
		borderColor: 	an ObservableValueHolder[ nil ]
		dragEnabled: 	an ObservableValueHolder[ false ]
		dropEnabled: 	an ObservableValueHolder[ false ]
		color: 	an ObservableValueHolder[ nil ]
		help: 	an ObservableValueHolder[ nil ]
		enabled: 	an ObservableValueHolder[ true ]
		wantsDrop: 	an ObservableValueHolder[ [ :transfer | self dropEnabled ] ]
		acceptDrop: 	an ObservableValueHolder[ [ :transfer | ] ]
		deferredActions: 	nil
		hasUnacceptedEdits: 	an ObservableValueHolder[ false ]
		selection: 	an ObservableValueHolder[ (1 to: 160) ]
		wantsVisualFeedback: 	an ObservableValueHolder[ true ]
		askBeforeDiscardingEdits: 	an ObservableValueHolder[ true ]
		text: 	an ObservableValueHolder[ '| visualizer |
visualizer := GraphVisualiz[..]
		actionToPerform: 	an ObservableValueHolder[ [ :txt |  ] ]
		readSelection: 	an ObservableValueHolder[ [ selection ] ]
		placeholder: 	an ObservableValueHolder[ '' ]
		contextMenu: 	an ObservableValueHolder[ [ (self menuActionsFor: text) asMenu[..]
		scrollValue: 	an ObservableValueHolder[ (0@0) ]
		editionContextMenu: 	an ObservableValueHolder[ true ]
		editable: 	an ObservableValueHolder[ true ]
		wrapWord: 	an ObservableValueHolder[ true ]
		undoRedoHistory: 	true
		wrapScrollBars: 	true
		propagateNaturalHeight: 	false
		propagateNaturalWidth: 	false
		scrollBarStyles: 	#()
		syntaxHighlight: 	an ObservableValueHolder[ true ]
		smartCharacters: 	an ObservableValueHolder[ true ]
		lineNumbers: 	an ObservableValueHolder[ true ]
		interactionModel: 	an ObservableValueHolder[ a StPlaygroundInteractionModel ]
		overrideContextMenu: 	true
		submitBlock: 	nil
		resetBlock: 	nil
		environment: 	nil
		systemNavigation: 	nil
		syntaxHighlightTheme: 	an ObservableValueHolder[ nil ]


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
		self announcer announce: (SpCodeWillBeEvaluatedAnnouncement newContent: aString).
[..]
	Arguments and temporary variables: 
		exception: 	Error
		handlerAction: 	[ :e |
		self announcer announce: (SpCodeEvaluationFailedAnn[..]
	Receiver's instance variables: 
		outerContext: 	SpCodePresenter>>evaluate:onCompileError:onError:
		compiledBlock: 	a CompiledBlock: [
		self announcer announce: (SpCodeWillBeE[..]
		numArgs: 	0
		receiver: 	a SpCodePresenter


SpCodePresenter>>evaluate:onCompileError:onError:
	Receiver: a SpCodePresenter
	Arguments and temporary variables: 
		receiver: 	nil
		result: 	nil
		oldBindings: 	a Dictionary()
		aString: 	'| visualizer |
visualizer := GraphVisualizer new.
visualizer visu[..]
		compileErrorBlock: 	[ ^ self ]
		errorBlock: 	[ :e | e pass ]
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicCodeAdapter)
		announcer: 	an Announcer
		owner: 	a StPlaygroundPagePresenter
		adapter: 	a SpMorphicCodeAdapter
		needRebuild: 	true
		eventHandler: 	a SpEventHandler
		application: 	nil
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ a KMCategory ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Code' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpAbstractWidgetLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		borderWidth: 	an ObservableValueHolder[ nil ]
		borderColor: 	an ObservableValueHolder[ nil ]
		dragEnabled: 	an ObservableValueHolder[ false ]
		dropEnabled: 	an ObservableValueHolder[ false ]
		color: 	an ObservableValueHolder[ nil ]
		help: 	an ObservableValueHolder[ nil ]
		enabled: 	an ObservableValueHolder[ true ]
		wantsDrop: 	an ObservableValueHolder[ [ :transfer | self dropEnabled ] ]
		acceptDrop: 	an ObservableValueHolder[ [ :transfer | ] ]
		deferredActions: 	nil
		hasUnacceptedEdits: 	an ObservableValueHolder[ false ]
		selection: 	an ObservableValueHolder[ (1 to: 160) ]
		wantsVisualFeedback: 	an ObservableValueHolder[ true ]
		askBeforeDiscardingEdits: 	an ObservableValueHolder[ true ]
		text: 	an ObservableValueHolder[ '| visualizer |
visualizer := GraphVisualiz[..]
		actionToPerform: 	an ObservableValueHolder[ [ :txt |  ] ]
		readSelection: 	an ObservableValueHolder[ [ selection ] ]
		placeholder: 	an ObservableValueHolder[ '' ]
		contextMenu: 	an ObservableValueHolder[ [ (self menuActionsFor: text) asMenu[..]
		scrollValue: 	an ObservableValueHolder[ (0@0) ]
		editionContextMenu: 	an ObservableValueHolder[ true ]
		editable: 	an ObservableValueHolder[ true ]
		wrapWord: 	an ObservableValueHolder[ true ]
		undoRedoHistory: 	true
		wrapScrollBars: 	true
		propagateNaturalHeight: 	false
		propagateNaturalWidth: 	false
		scrollBarStyles: 	#()
		syntaxHighlight: 	an ObservableValueHolder[ true ]
		smartCharacters: 	an ObservableValueHolder[ true ]
		lineNumbers: 	an ObservableValueHolder[ true ]
		interactionModel: 	an ObservableValueHolder[ a StPlaygroundInteractionModel ]
		overrideContextMenu: 	true
		submitBlock: 	nil
		resetBlock: 	nil
		environment: 	nil
		systemNavigation: 	nil
		syntaxHighlightTheme: 	an ObservableValueHolder[ nil ]


StPlaygroundPagePresenter>>doEvaluateAndGo
	Receiver: a StPlaygroundPagePresenter
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicBoxAdapter)
		announcer: 	an Announcer
		owner: 	a SpMillerColumnPresenter
		adapter: 	a SpMorphicBoxAdapter
		needRebuild: 	true
		eventHandler: 	nil
		application: 	a StPharoApplication
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ nil ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Untitled window' ]
		additionalSubpresentersMap: 	a Dictionary()
		layout: 	an ObservableValueHolder[ a SpBoxLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		text: 	a SpCodePresenter
		toolbar: 	a SpToolbarPresenter
		statusbar: 	a SpPresenter
		lineLabel: 	a SpLabelPresenter
		toggleLineNumberButton: 	a SpToggleButtonPresenter
		page: 	a StPlaygroundPage
		activationBlock: 	[ :selection |
		self changeSelection: selection from: new[..]


StPlaygroundPagePresenter>>doEvaluateAllAndGo
	Receiver: a StPlaygroundPagePresenter
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicBoxAdapter)
		announcer: 	an Announcer
		owner: 	a SpMillerColumnPresenter
		adapter: 	a SpMorphicBoxAdapter
		needRebuild: 	true
		eventHandler: 	nil
		application: 	a StPharoApplication
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ nil ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Untitled window' ]
		additionalSubpresentersMap: 	a Dictionary()
		layout: 	an ObservableValueHolder[ a SpBoxLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		text: 	a SpCodePresenter
		toolbar: 	a SpToolbarPresenter
		statusbar: 	a SpPresenter
		lineLabel: 	a SpLabelPresenter
		toggleLineNumberButton: 	a SpToggleButtonPresenter
		page: 	a StPlaygroundPage
		activationBlock: 	[ :selection |
		self changeSelection: selection from: new[..]


StPlaygroundDoItCommand>>execute
	Receiver: a StPlaygroundDoItCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		context: 	a StPlaygroundPagePresenter
		basicName: 	'Do it'
		basicDescription: 	'Do it all and inspect.'


SpCommand(CmCommandDecorator)>>execute
	Receiver: a SpCommand(Do it)
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a StPlaygroundDoItCommand
		iconProvider: 	a StPharoApplication
		iconName: 	#glamorousGo
		shortcutKey: 	nil
		displayStrategy: 	a CmUIDisableWhenCantBeRun
		positionStrategy: 	a CmUILeftPositionStrategy
		buildPresenterBlock: 	[ :specCommand | 
			aButtonClass new
				label: specC[..]
		presenter: 	a SpToolbarButtonPresenter


[ specCommand execute ] in [ :specCommand | 
			aButtonClass new
				label: specCommand name;
				help: specCommand description;
				in: [ :button | 
					specCommand hasIcon
						ifTrue: [ button icon: specCommand icon ] ];
				action: [ specCommand execute ];
				yourself ] in SpCommand>>configureAsButtonOfClass:
	Receiver: a SpCommand(Do it)
	Arguments and temporary variables: 
		aButtonClass: 	nil
		specCommand: 	a SpCommand(Do it)
	Receiver's instance variables: 
		decoratedCommand: 	a StPlaygroundDoItCommand
		iconProvider: 	a StPharoApplication
		iconName: 	#glamorousGo
		shortcutKey: 	nil
		displayStrategy: 	a CmUIDisableWhenCantBeRun
		positionStrategy: 	a CmUILeftPositionStrategy
		buildPresenterBlock: 	[ :specCommand | 
			aButtonClass new
				label: specC[..]
		presenter: 	a SpToolbarButtonPresenter


FullBlockClosure(BlockClosure)>>cull:
	Receiver: [ specCommand execute ]
	Arguments and temporary variables: 
		anArg: 	a SpToolbarButtonPresenter
	Receiver's instance variables: 
		outerContext: 	[ :specCommand | 
			aButtonClass new
				label: specCommand [..]
		compiledBlock: 	a CompiledBlock: [ specCommand execute ]
		numArgs: 	0
		receiver: 	a SpCommand(Do it)


SpMorphicToolbarButtonAdapter>>execute
	Receiver: a SpMorphicToolbarButtonAdapter
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpToolbarButtonMorph(319944704))
		announcer: 	nil
		model: 	a SpToolbarButtonPresenter
		widget: 	a SpToolbarButtonMorph(319944704)
		selector: 	nil
		owner: 	a SpToolbarButtonPresenter
		unsubscribed: 	false


SpToolbarButtonMorph(PluggableButtonMorph)>>performAction:
	Receiver: a SpToolbarButtonMorph(319944704)
	Arguments and temporary variables: 
		event: 	[(24.0@26.0) mouseUp 8461620 nil]
	Receiver's instance variables: 
		bounds: 	(0.0@5.0) corner: (45.0@39.0)
		owner: 	a Morph(13467904)
		submorphs: 	an Array(an AlignmentMorph(869548288))
		fullBounds: 	nil
		color: 	(Color r: 0.9012707722385142 g: 0.9012707722385142 b: 0.901270772238[..]
		extension: 	a MorphExtension (545772544) [balloonText]  [other:  (presenter [..]
		borderWidth: 	0
		borderColor: 	#simple
		model: 	a SpMorphicToolbarButtonAdapter
		label: 	'Do it'
		icon: 	Form(13x13x32)
		getIconSelector: 	#icon
		getStateSelector: 	#state
		actionSelector: 	#execute
		font: 	a LogicalFont
 familyName: 'Source Sans Pro'
 emphasis: nil
 pointSiz[..]
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	nil
		getFontSelector: 	nil
		labelMorph: 	a LabelMorph(424853504)'Do it'
		iconMorph: 	an ImageMorph(356841984)
		iconPosition: 	#top
		lastState: 	false
		badgeFont: 	nil
		badgeSelector: 	#badge


[:m |
		(m containsPoint: evt cursorPoint) ifTrue: [m enabled ifTrue: [ m performAction: evt ]]] in SpToolbarButtonMorph(PluggableButtonMorph)>>mouseUp:
	Receiver: a SpToolbarButtonMorph(319944704)
	Arguments and temporary variables: 
		evt: 	[(24.0@26.0) mouseUp 8461620 nil]
		all: 	an Array(a SpToolbarButtonMorph(319944704) a SpToolbarButtonMorph(5749[..]
		m: 	a SpToolbarButtonMorph(319944704)
	Receiver's instance variables: 
		bounds: 	(0.0@5.0) corner: (45.0@39.0)
		owner: 	a Morph(13467904)
		submorphs: 	an Array(an AlignmentMorph(869548288))
		fullBounds: 	nil
		color: 	(Color r: 0.9012707722385142 g: 0.9012707722385142 b: 0.901270772238[..]
		extension: 	a MorphExtension (545772544) [balloonText]  [other:  (presenter [..]
		borderWidth: 	0
		borderColor: 	#simple
		model: 	a SpMorphicToolbarButtonAdapter
		label: 	'Do it'
		icon: 	Form(13x13x32)
		getIconSelector: 	#icon
		getStateSelector: 	#state
		actionSelector: 	#execute
		font: 	a LogicalFont
 familyName: 'Source Sans Pro'
 emphasis: nil
 pointSiz[..]
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	nil
		getFontSelector: 	nil
		labelMorph: 	a LabelMorph(424853504)'Do it'
		iconMorph: 	an ImageMorph(356841984)
		iconPosition: 	#top
		lastState: 	false
		badgeFont: 	nil
		badgeSelector: 	#badge


Array(SequenceableCollection)>>do:
	Receiver: an Array(a SpToolbarButtonMorph(319944704) a SpToolbarButtonMorph(574995456) a SpToolb[..]
	Arguments and temporary variables: 
		aBlock: 	[:m |
		(m containsPoint: evt cursorPoint) ifTrue: [m enabled ifTru[..]
		index: 	1
	Receiver's instance variables: 
an Array(a SpToolbarButtonMorph(319944704) a SpToolbarButtonMorph(574995456) a SpToolb[..]

SpToolbarButtonMorph(PluggableButtonMorph)>>mouseUp:
	Receiver: a SpToolbarButtonMorph(319944704)
	Arguments and temporary variables: 
		evt: 	[(24.0@26.0) mouseUp 8461620 nil]
		all: 	an Array(a SpToolbarButtonMorph(319944704) a SpToolbarButtonMorph(5749[..]
	Receiver's instance variables: 
		bounds: 	(0.0@5.0) corner: (45.0@39.0)
		owner: 	a Morph(13467904)
		submorphs: 	an Array(an AlignmentMorph(869548288))
		fullBounds: 	nil
		color: 	(Color r: 0.9012707722385142 g: 0.9012707722385142 b: 0.901270772238[..]
		extension: 	a MorphExtension (545772544) [balloonText]  [other:  (presenter [..]
		borderWidth: 	0
		borderColor: 	#simple
		model: 	a SpMorphicToolbarButtonAdapter
		label: 	'Do it'
		icon: 	Form(13x13x32)
		getIconSelector: 	#icon
		getStateSelector: 	#state
		actionSelector: 	#execute
		font: 	a LogicalFont
 familyName: 'Source Sans Pro'
 emphasis: nil
 pointSiz[..]
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	nil
		getFontSelector: 	nil
		labelMorph: 	a LabelMorph(424853504)'Do it'
		iconMorph: 	an ImageMorph(356841984)
		iconPosition: 	#top
		lastState: 	false
		badgeFont: 	nil
		badgeSelector: 	#badge


SpToolbarButtonMorph(Morph)>>handleMouseUp:
	Receiver: a SpToolbarButtonMorph(319944704)
	Arguments and temporary variables: 
		anEvent: 	[(24.0@26.0) mouseUp 8461620 nil]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(0.0@5.0) corner: (45.0@39.0)
		owner: 	a Morph(13467904)
		submorphs: 	an Array(an AlignmentMorph(869548288))
		fullBounds: 	nil
		color: 	(Color r: 0.9012707722385142 g: 0.9012707722385142 b: 0.901270772238[..]
		extension: 	a MorphExtension (545772544) [balloonText]  [other:  (presenter [..]
		borderWidth: 	0
		borderColor: 	#simple
		model: 	a SpMorphicToolbarButtonAdapter
		label: 	'Do it'
		icon: 	Form(13x13x32)
		getIconSelector: 	#icon
		getStateSelector: 	#state
		actionSelector: 	#execute
		font: 	a LogicalFont
 familyName: 'Source Sans Pro'
 emphasis: nil
 pointSiz[..]
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	nil
		getFontSelector: 	nil
		labelMorph: 	a LabelMorph(424853504)'Do it'
		iconMorph: 	an ImageMorph(356841984)
		iconPosition: 	#top
		lastState: 	false
		badgeFont: 	nil
		badgeSelector: 	#badge


MouseButtonEvent>>sentTo:
	Receiver: [(24.0@26.0) mouseUp 8461620 nil]
	Arguments and temporary variables: 
		anObject: 	a SpToolbarButtonMorph(319944704)
	Receiver's instance variables: 
		timeStamp: 	8461620
		source: 	a HandMorph(337424384)
		windowIndex: 	nil
		type: 	#mouseUp
		buttons: 	0
		position: 	(24.0@26.0)
		handler: 	nil
		wasHandled: 	true
		whichButton: 	4


SpToolbarButtonMorph(Morph)>>handleEvent:
	Receiver: a SpToolbarButtonMorph(319944704)
	Arguments and temporary variables: 
		anEvent: 	[(24.0@26.0) mouseUp 8461620 nil]
	Receiver's instance variables: 
		bounds: 	(0.0@5.0) corner: (45.0@39.0)
		owner: 	a Morph(13467904)
		submorphs: 	an Array(an AlignmentMorph(869548288))
		fullBounds: 	nil
		color: 	(Color r: 0.9012707722385142 g: 0.9012707722385142 b: 0.901270772238[..]
		extension: 	a MorphExtension (545772544) [balloonText]  [other:  (presenter [..]
		borderWidth: 	0
		borderColor: 	#simple
		model: 	a SpMorphicToolbarButtonAdapter
		label: 	'Do it'
		icon: 	Form(13x13x32)
		getIconSelector: 	#icon
		getStateSelector: 	#state
		actionSelector: 	#execute
		font: 	a LogicalFont
 familyName: 'Source Sans Pro'
 emphasis: nil
 pointSiz[..]
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	nil
		getFontSelector: 	nil
		labelMorph: 	a LabelMorph(424853504)'Do it'
		iconMorph: 	an ImageMorph(356841984)
		iconPosition: 	#top
		lastState: 	false
		badgeFont: 	nil
		badgeSelector: 	#badge


SpToolbarButtonMorph(Morph)>>handleFocusEvent:
	Receiver: a SpToolbarButtonMorph(319944704)
	Arguments and temporary variables: 
		anEvent: 	[(24.0@26.0) mouseUp 8461620 nil]
	Receiver's instance variables: 
		bounds: 	(0.0@5.0) corner: (45.0@39.0)
		owner: 	a Morph(13467904)
		submorphs: 	an Array(an AlignmentMorph(869548288))
		fullBounds: 	nil
		color: 	(Color r: 0.9012707722385142 g: 0.9012707722385142 b: 0.901270772238[..]
		extension: 	a MorphExtension (545772544) [balloonText]  [other:  (presenter [..]
		borderWidth: 	0
		borderColor: 	#simple
		model: 	a SpMorphicToolbarButtonAdapter
		label: 	'Do it'
		icon: 	Form(13x13x32)
		getIconSelector: 	#icon
		getStateSelector: 	#state
		actionSelector: 	#execute
		font: 	a LogicalFont
 familyName: 'Source Sans Pro'
 emphasis: nil
 pointSiz[..]
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	nil
		getFontSelector: 	nil
		labelMorph: 	a LabelMorph(424853504)'Do it'
		iconMorph: 	an ImageMorph(356841984)
		iconPosition: 	#top
		lastState: 	false
		badgeFont: 	nil
		badgeSelector: 	#badge


[
		result := focusHolder handleFocusEvent: transformedEvent.
	] in HandMorph>>sendFocusEvent:to:clear:
	Receiver: a HandMorph(337424384)
	Arguments and temporary variables: 
		anEvent: 	[(543@344) mouseUp 8461620 nil]
		focusHolder: 	a SpToolbarButtonMorph(319944704)
		aBlock: 	[self mouseFocus: nil]
		w: 	a WorldMorph(341720576) [world]
		transformedEvent: 	[(24.0@26.0) mouseUp 8461620 nil]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(543@344.0) corner: (559@360.0)
		owner: 	a WorldMorph(341720576) [world]
		submorphs: 	#()
		fullBounds: 	(543@344.0) corner: (559@360.0)
		color: 	Color blue
		extension: 	a MorphExtension (370611968)
		mouseFocus: 	nil
		keyboardFocus: 	a RubEditingArea(189250304)
		eventListeners: 	nil
		mouseListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(543@344) mouseUp 8461620 nil]
		targetOffset: 	(24.0@21.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	true
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 0 0 0 0 0 nil nil)
		captureBlock: 	nil
		recentModifiers: 	0
		pendingEventQueue: 	WaitfreeQueue with 0 items
		supressNextKeyPress: 	false


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
		result := focusHolder handleFocusEvent: transformedEvent.
	]
	Arguments and temporary variables: 
		exception: 	Error
		handlerAction: 	[ :ex |
			ActiveWorld := priorWorld.
			ex pass ]
	Receiver's instance variables: 
		outerContext: 	HandMorph>>sendFocusEvent:to:clear:
		compiledBlock: 	a CompiledBlock: [
		result := focusHolder handleFocusEvent:[..]
		numArgs: 	0
		receiver: 	a HandMorph(337424384)


WorldMorph>>becomeActiveDuring:
	Receiver: a WorldMorph(341720576) [world]
	Arguments and temporary variables: 
		aBlock: 	[
		result := focusHolder handleFocusEvent: transformedEvent.
	]
		priorWorld: 	a WorldMorph(341720576) [world]
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1728@1080)
		owner: 	nil
		submorphs: 	an Array(a MenubarMorph(112886016) a TaskbarMorph(279458560) a S[..]
		fullBounds: 	(0@0) corner: (1728@1080)
		color: 	(Color r: 0.9403714565004888 g: 0.9403714565004888 b: 0.940371456500[..]
		extension: 	a MorphExtension (1012946432) [other:  (dragEnabled -> true) (dr[..]
		borderWidth: 	0
		borderColor: 	(Color r: 0.8611925708699902 g: 1.0 b: 0.7223851417399805 alph[..]
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil


HandMorph>>sendFocusEvent:to:clear:
	Receiver: a HandMorph(337424384)
	Arguments and temporary variables: 
		result: 	nil
		anEvent: 	[(543@344) mouseUp 8461620 nil]
		focusHolder: 	a SpToolbarButtonMorph(319944704)
		aBlock: 	[self mouseFocus: nil]
		w: 	a WorldMorph(341720576) [world]
		transformedEvent: 	[(24.0@26.0) mouseUp 8461620 nil]
	Receiver's instance variables: 
		bounds: 	(543@344.0) corner: (559@360.0)
		owner: 	a WorldMorph(341720576) [world]
		submorphs: 	#()
		fullBounds: 	(543@344.0) corner: (559@360.0)
		color: 	Color blue
		extension: 	a MorphExtension (370611968)
		mouseFocus: 	nil
		keyboardFocus: 	a RubEditingArea(189250304)
		eventListeners: 	nil
		mouseListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(543@344) mouseUp 8461620 nil]
		targetOffset: 	(24.0@21.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	true
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 0 0 0 0 0 nil nil)
		captureBlock: 	nil
		recentModifiers: 	0
		pendingEventQueue: 	WaitfreeQueue with 0 items
		supressNextKeyPress: 	false


HandMorph>>sendEvent:focus:clear:
	Receiver: a HandMorph(337424384)
	Arguments and temporary variables: 
		anEvent: 	[(543@344) mouseUp 8461620 nil]
		focusHolder: 	a SpToolbarButtonMorph(319944704)
		aBlock: 	[self mouseFocus: nil]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(543@344.0) corner: (559@360.0)
		owner: 	a WorldMorph(341720576) [world]
		submorphs: 	#()
		fullBounds: 	(543@344.0) corner: (559@360.0)
		color: 	Color blue
		extension: 	a MorphExtension (370611968)
		mouseFocus: 	nil
		keyboardFocus: 	a RubEditingArea(189250304)
		eventListeners: 	nil
		mouseListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(543@344) mouseUp 8461620 nil]
		targetOffset: 	(24.0@21.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	true
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 0 0 0 0 0 nil nil)
		captureBlock: 	nil
		recentModifiers: 	0
		pendingEventQueue: 	WaitfreeQueue with 0 items
		supressNextKeyPress: 	false


HandMorph>>sendMouseEvent:
	Receiver: a HandMorph(337424384)
	Arguments and temporary variables: 
		anEvent: 	[(543@344) mouseUp 8461620 nil]
	Receiver's instance variables: 
		bounds: 	(543@344.0) corner: (559@360.0)
		owner: 	a WorldMorph(341720576) [world]
		submorphs: 	#()
		fullBounds: 	(543@344.0) corner: (559@360.0)
		color: 	Color blue
		extension: 	a MorphExtension (370611968)
		mouseFocus: 	nil
		keyboardFocus: 	a RubEditingArea(189250304)
		eventListeners: 	nil
		mouseListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(543@344) mouseUp 8461620 nil]
		targetOffset: 	(24.0@21.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	true
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 0 0 0 0 0 nil nil)
		captureBlock: 	nil
		recentModifiers: 	0
		pendingEventQueue: 	WaitfreeQueue with 0 items
		supressNextKeyPress: 	false


HandMorph>>handleEvent:
	Receiver: a HandMorph(337424384)
	Arguments and temporary variables: 
		anEvent: 	[(543@344) mouseUp 8461620 nil]
		evt: 	[(543@344) mouseUp 8461620 nil]
	Receiver's instance variables: 
		bounds: 	(543@344.0) corner: (559@360.0)
		owner: 	a WorldMorph(341720576) [world]
		submorphs: 	#()
		fullBounds: 	(543@344.0) corner: (559@360.0)
		color: 	Color blue
		extension: 	a MorphExtension (370611968)
		mouseFocus: 	nil
		keyboardFocus: 	a RubEditingArea(189250304)
		eventListeners: 	nil
		mouseListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(543@344) mouseUp 8461620 nil]
		targetOffset: 	(24.0@21.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	true
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 0 0 0 0 0 nil nil)
		captureBlock: 	nil
		recentModifiers: 	0
		pendingEventQueue: 	WaitfreeQueue with 0 items
		supressNextKeyPress: 	false


[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil ]) ifTrue: [
			morphicWorld activeHand handleEvent: anEvent
		]
	] in OSWindowMorphicEventHandler>>dispatchMorphicEvent:
	Receiver: an OSWindowMorphicEventHandler
	Arguments and temporary variables: 
		anEvent: 	[(543@344) mouseUp 8461620 nil]
	Receiver's instance variables: 
		morphicWorld: 	a WorldMorph(341720576) [world]


WorldState>>runStepMethodsIn:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(341720576) [world]
		queue: 	WaitfreeQueue with 0 items
		nextInQueue: 	[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNo[..]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(337424384))
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap()
		lastStepTime: 	8349811
		lastStepMessage: 	nil
		alarms: 	a Heap(MorphicAlarm(#hideShow -> a RubCursor(898368768)))
		lastAlarmTime: 	8461598
		activeHand: 	a HandMorph(337424384)
		currentCursor: 	((CursorWithMask
	extent: (16@16)
	depth: 1
	fromArray: #(
	[..]
		worldRenderer: 	an OSWorldRenderer
		realWindowExtent: 	(1728@1080)
		deferredUIMessages: 	WaitfreeQueue with 0 items


WorldMorph>>runStepMethods
	Receiver: a WorldMorph(341720576) [world]
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1728@1080)
		owner: 	nil
		submorphs: 	an Array(a MenubarMorph(112886016) a TaskbarMorph(279458560) a S[..]
		fullBounds: 	(0@0) corner: (1728@1080)
		color: 	(Color r: 0.9403714565004888 g: 0.9403714565004888 b: 0.940371456500[..]
		extension: 	a MorphExtension (1012946432) [other:  (dragEnabled -> true) (dr[..]
		borderWidth: 	0
		borderColor: 	(Color r: 0.8611925708699902 g: 1.0 b: 0.7223851417399805 alph[..]
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil


WorldState>>doOneCycleFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(341720576) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(337424384))
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap()
		lastStepTime: 	8349811
		lastStepMessage: 	nil
		alarms: 	a Heap(MorphicAlarm(#hideShow -> a RubCursor(898368768)))
		lastAlarmTime: 	8461598
		activeHand: 	a HandMorph(337424384)
		currentCursor: 	((CursorWithMask
	extent: (16@16)
	depth: 1
	fromArray: #(
	[..]
		worldRenderer: 	an OSWorldRenderer
		realWindowExtent: 	(1728@1080)
		deferredUIMessages: 	WaitfreeQueue with 0 items


WorldMorph>>doOneCycleNow
	Receiver: a WorldMorph(341720576) [world]
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1728@1080)
		owner: 	nil
		submorphs: 	an Array(a MenubarMorph(112886016) a TaskbarMorph(279458560) a S[..]
		fullBounds: 	(0@0) corner: (1728@1080)
		color: 	(Color r: 0.9403714565004888 g: 0.9403714565004888 b: 0.940371456500[..]
		extension: 	a MorphExtension (1012946432) [other:  (dragEnabled -> true) (dr[..]
		borderWidth: 	0
		borderColor: 	(Color r: 0.8611925708699902 g: 1.0 b: 0.7223851417399805 alph[..]
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil


WorldMorph>>doOneCycle
	Receiver: a WorldMorph(341720576) [world]
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1728@1080)
		owner: 	nil
		submorphs: 	an Array(a MenubarMorph(112886016) a TaskbarMorph(279458560) a S[..]
		fullBounds: 	(0@0) corner: (1728@1080)
		color: 	(Color r: 0.9403714565004888 g: 0.9403714565004888 b: 0.940371456500[..]
		extension: 	a MorphExtension (1012946432) [other:  (dragEnabled -> true) (dr[..]
		borderWidth: 	0
		borderColor: 	(Color r: 0.8611925708699902 g: 1.0 b: 0.7223851417399805 alph[..]
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil


[
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMutex critical: [
			                     self extraWorldList ].
		extraWorldsToDraw do: [ :world | world doOneCycle ].

		(self currentWorld isNotNil and: [
			 (extraWorldsToDraw includes: self currentWorld) not ]) ifTrue: [
			self currentWorld doOneCycle ] ] in WorldMorph class>>doOneCycle
	Receiver: WorldMorph
	Arguments and temporary variables: 
		extraWorldsToDraw: 	#()
	Receiver's instance variables: 
		superclass: 	PasteUpMorph
		methodDict: 	a MethodDictionary(#acceptDroppingMorph:event:->WorldMorph>>#ac[..]
		format: 	65547
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		commentSourcePointer: 	nil
		subclasses: 	{AthensWorldMorph. OSWindowWorldMorph}
		name: 	#WorldMorph
		classPool: 	a Dictionary(#AllowDropFiles->nil #CursorOwnerWorld->a WorldMorp[..]
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Morphic-Core-Worlds'
		announcer: 	nil
		displayScaleFactor: 	1



--- The full stack ---
UndefinedObject(Object)>>doesNotUnderstand: #new
UndefinedObject>>doesNotUnderstand: #new
GraphVisualizer>>initialize
GraphVisualizer class(Behavior)>>new
UndefinedObject>>DoIt
OCReceiverDoItSemanticScope(OCDoItSemanticScope)>>evaluateDoIt:
OpalCompiler>>evaluate
[
		self announcer announce: (SpCodeWillBeEvaluatedAnnouncement newContent: aString).
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionModel doItReceiver.
		result := receiver class compiler
			source: aString;
			context: self interactionModel doItContext;
			receiver: self interactionModel doItReceiver;
			requestor: self interactionModel;
			environment: self environment;
			failBlock:  [ 
				self announcer announce: (SpCodeEvaluationFailedAnnouncement newContent: aString).
				^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		self announcer announce: (SpCodeEvaluationSucceedAnnouncement newContent: aString).
		result ] in SpCodePresenter>>evaluate:onCompileError:onError:
FullBlockClosure(BlockClosure)>>on:do:
SpCodePresenter>>evaluate:onCompileError:onError:
StPlaygroundPagePresenter>>doEvaluateAndGo
StPlaygroundPagePresenter>>doEvaluateAllAndGo
StPlaygroundDoItCommand>>execute
SpCommand(CmCommandDecorator)>>execute
[ specCommand execute ] in [ :specCommand | 
			aButtonClass new
				label: specCommand name;
				help: specCommand description;
				in: [ :button | 
					specCommand hasIcon
						ifTrue: [ button icon: specCommand icon ] ];
				action: [ specCommand execute ];
				yourself ] in SpCommand>>configureAsButtonOfClass:
FullBlockClosure(BlockClosure)>>cull:
SpMorphicToolbarButtonAdapter>>execute
SpToolbarButtonMorph(PluggableButtonMorph)>>performAction:
[:m |
		(m containsPoint: evt cursorPoint) ifTrue: [m enabled ifTrue: [ m performAction: evt ]]] in SpToolbarButtonMorph(PluggableButtonMorph)>>mouseUp:
Array(SequenceableCollection)>>do:
SpToolbarButtonMorph(PluggableButtonMorph)>>mouseUp:
SpToolbarButtonMorph(Morph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
SpToolbarButtonMorph(Morph)>>handleEvent:
SpToolbarButtonMorph(Morph)>>handleFocusEvent:
[
		result := focusHolder handleFocusEvent: transformedEvent.
	] in HandMorph>>sendFocusEvent:to:clear:
FullBlockClosure(BlockClosure)>>on:do:
WorldMorph>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil ]) ifTrue: [
			morphicWorld activeHand handleEvent: anEvent
		]
	] in OSWindowMorphicEventHandler>>dispatchMorphicEvent:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycleNow
WorldMorph>>doOneCycle
[
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMutex critical: [
			                     self extraWorldList ].
		extraWorldsToDraw do: [ :world | world doOneCycle ].

		(self currentWorld isNotNil and: [
			 (extraWorldsToDraw includes: self currentWorld) not ]) ifTrue: [
			self currentWorld doOneCycle ] ] in WorldMorph class>>doOneCycle
 - - - - - - - - - - - - - - -
			- - - - - - - - - - - - - - - - - -
FullBlockClosure(BlockClosure)>>ensure:
WorldState class>>doDrawCycleWith:
WorldMorph class>>doOneCycle
MorphicRenderLoop>>doOneCycle
MorphicRenderLoop>>doOneCycleWhile:
ListDialogWindow(SystemWindow)>>openModal
ListDialogWindow>>chooseFromOwner:
ClyFullBrowserMethodContext(CmdToolContext)>>requestSingleMethodTag:suggesting:
ClyMethodTagsAndPackageEditorMorph>>requestTag
[
		self isExtensionActive
			ifTrue: [ self requestPackage]
			ifFalse: [ self requestTag ]
	] in ClyMethodTagsAndPackageEditorMorph>>openEditor
FullBlockClosure(BlockClosure)>>on:do:
ClyMethodTagsAndPackageEditorMorph>>requestChangeBy:
ClyMethodTagsAndPackageEditorMorph>>openEditor
MorphEventSubscription>>notify:from:
[ :s | result := result | ((s notify: anEvent from: sourceMorph) == true) ] in MorphicEventHandler>>notifyMorphsOfEvent:ofType:from:
Set>>do:
MorphicEventHandler>>notifyMorphsOfEvent:ofType:from:
MorphicEventHandler>>click:fromMorph:
LabelMorph(Morph)>>click:
MouseClickState>>click
MouseClickState>>handleEvent:from:
HandMorph>>handleEvent:
[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil ]) ifTrue: [
			morphicWorld activeHand handleEvent: anEvent
		]
	] in OSWindowMorphicEventHandler>>dispatchMorphicEvent:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycleNow
WorldMorph>>doOneCycle
[
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMutex critical: [
			                     self extraWorldList ].
		extraWorldsToDraw do: [ :world | world doOneCycle ].

		(self currentWorld isNotNil and: [
			 (extraWorldsToDraw includes: self currentWorld) not ]) ifTrue: [
			self currentWorld doOneCycle ] ] in WorldMorph class>>doOneCycle
FullBlockClosure(BlockClosure)>>ensure:
WorldState class>>doDrawCycleWith:
WorldMorph class>>doOneCycle
MorphicRenderLoop>>doOneCycle
MorphicRenderLoop>>doOneCycleWhile:
[ MorphicRenderLoop new doOneCycleWhile: [ true ] ] in MorphicUIManager>>spawnNewProcess
[self value.
			"IMPORTANT: Do not step over next line of code. See method comments for details"
			Processor terminateRealActive] in FullBlockClosure(BlockClosure)>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
#RSView is missing, and does not understand #new
13 November 2023 6:38:13.927611 pm

VM: Mac OS - arm64 - 1000 - CoInterpreter VMMaker-tonel.1 uuid: 902dd483-c0c4-0d00-86f2-0f880df24b96 Oct 23 2023
StackToRegisterMappingCogit VMMaker-tonel.1 uuid: 902dd483-c0c4-0d00-86f2-0f880df24b96 Oct 23 2023
v10.0.8 - Commit: b323c5fb - Date: 2023-10-20 16:02:07 -0400

Image: Pharo11.0.0 [Build information: Pharo-11.0.0+build.710.sha.ea28d8552cac85a7ce1e9c34ab1e7bd45f7b9910 (64 Bit)]

UndefinedObject>>doesNotUnderstand: #new
	Receiver: nil
	Arguments and temporary variables: 
		node: 	RBVariableNode(RSView)
		aMessage: 	new
		exception: 	#RSView is missing, and does not understand #new
		resumeValue: 	nil
	Receiver's instance variables: 
nil

GraphVisualizer>>initialize
	Receiver: a GraphVisualizer
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		view: 	nil
		nodes: 	nil
		edges: 	nil
		nodesMap: 	nil


GraphVisualizer class(Behavior)>>new
	Receiver: GraphVisualizer
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary(#createEdges->GraphVisualizer>>#createEdges [..]
		format: 	65540
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		commentSourcePointer: 	nil
		subclasses: 	#()
		name: 	#GraphVisualizer
		classPool: 	nil
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#Visualizer


UndefinedObject>>DoIt
	Receiver: nil
	Arguments and temporary variables: 
		visualizer: 	nil
	Receiver's instance variables: 
nil

OCReceiverDoItSemanticScope(OCDoItSemanticScope)>>evaluateDoIt:
	Receiver: an OCReceiverDoItSemanticScope
	Arguments and temporary variables: 
		doItMethod: 	UndefinedObject>>#DoIt
	Receiver's instance variables: 
		outerScope: 	nil
		targetReceiver: 	nil


OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
		doItMethod: 	UndefinedObject>>#DoIt
	Receiver's instance variables: 
		ast: 	DoIt

	| visualizer |
	visualizer := GraphVisualizer new.
	^ visualize[..]
		source: 	a ReadStream
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil


[
		self announcer announce: (SpCodeWillBeEvaluatedAnnouncement newContent: aString).
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionModel doItReceiver.
		result := receiver class compiler
			source: aString;
			context: self interactionModel doItContext;
			receiver: self interactionModel doItReceiver;
			requestor: self interactionModel;
			environment: self environment;
			failBlock:  [ 
				self announcer announce: (SpCodeEvaluationFailedAnnouncement newContent: aString).
				^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		self announcer announce: (SpCodeEvaluationSucceedAnnouncement newContent: aString).
		result ] in SpCodePresenter>>evaluate:onCompileError:onError:
	Receiver: a SpCodePresenter
	Arguments and temporary variables: 
		aString: 	'| visualizer |
visualizer := GraphVisualizer new.
visualizer visu[..]
		compileErrorBlock: 	[ ^ self ]
		errorBlock: 	[ :e | e pass ]
		receiver: 	nil
		result: 	nil
		oldBindings: 	a Dictionary()
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicCodeAdapter)
		announcer: 	an Announcer
		owner: 	a StPlaygroundPagePresenter
		adapter: 	a SpMorphicCodeAdapter
		needRebuild: 	true
		eventHandler: 	a SpEventHandler
		application: 	nil
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ a KMCategory ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Code' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpAbstractWidgetLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		borderWidth: 	an ObservableValueHolder[ nil ]
		borderColor: 	an ObservableValueHolder[ nil ]
		dragEnabled: 	an ObservableValueHolder[ false ]
		dropEnabled: 	an ObservableValueHolder[ false ]
		color: 	an ObservableValueHolder[ nil ]
		help: 	an ObservableValueHolder[ nil ]
		enabled: 	an ObservableValueHolder[ true ]
		wantsDrop: 	an ObservableValueHolder[ [ :transfer | self dropEnabled ] ]
		acceptDrop: 	an ObservableValueHolder[ [ :transfer | ] ]
		deferredActions: 	nil
		hasUnacceptedEdits: 	an ObservableValueHolder[ false ]
		selection: 	an ObservableValueHolder[ (1 to: 159) ]
		wantsVisualFeedback: 	an ObservableValueHolder[ true ]
		askBeforeDiscardingEdits: 	an ObservableValueHolder[ true ]
		text: 	an ObservableValueHolder[ '| visualizer |
visualizer := GraphVisualiz[..]
		actionToPerform: 	an ObservableValueHolder[ [ :txt |  ] ]
		readSelection: 	an ObservableValueHolder[ [ selection ] ]
		placeholder: 	an ObservableValueHolder[ '' ]
		contextMenu: 	an ObservableValueHolder[ [ (self menuActionsFor: text) asMenu[..]
		scrollValue: 	an ObservableValueHolder[ (0@0) ]
		editionContextMenu: 	an ObservableValueHolder[ true ]
		editable: 	an ObservableValueHolder[ true ]
		wrapWord: 	an ObservableValueHolder[ true ]
		undoRedoHistory: 	true
		wrapScrollBars: 	true
		propagateNaturalHeight: 	false
		propagateNaturalWidth: 	false
		scrollBarStyles: 	#()
		syntaxHighlight: 	an ObservableValueHolder[ true ]
		smartCharacters: 	an ObservableValueHolder[ true ]
		lineNumbers: 	an ObservableValueHolder[ true ]
		interactionModel: 	an ObservableValueHolder[ a StPlaygroundInteractionModel ]
		overrideContextMenu: 	true
		submitBlock: 	nil
		resetBlock: 	nil
		environment: 	nil
		systemNavigation: 	nil
		syntaxHighlightTheme: 	an ObservableValueHolder[ nil ]


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
		self announcer announce: (SpCodeWillBeEvaluatedAnnouncement newContent: aString).
[..]
	Arguments and temporary variables: 
		exception: 	Error
		handlerAction: 	[ :e |
		self announcer announce: (SpCodeEvaluationFailedAnn[..]
	Receiver's instance variables: 
		outerContext: 	SpCodePresenter>>evaluate:onCompileError:onError:
		compiledBlock: 	a CompiledBlock: [
		self announcer announce: (SpCodeWillBeE[..]
		numArgs: 	0
		receiver: 	a SpCodePresenter


SpCodePresenter>>evaluate:onCompileError:onError:
	Receiver: a SpCodePresenter
	Arguments and temporary variables: 
		receiver: 	nil
		result: 	nil
		oldBindings: 	a Dictionary()
		aString: 	'| visualizer |
visualizer := GraphVisualizer new.
visualizer visu[..]
		compileErrorBlock: 	[ ^ self ]
		errorBlock: 	[ :e | e pass ]
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicCodeAdapter)
		announcer: 	an Announcer
		owner: 	a StPlaygroundPagePresenter
		adapter: 	a SpMorphicCodeAdapter
		needRebuild: 	true
		eventHandler: 	a SpEventHandler
		application: 	nil
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ a KMCategory ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Code' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpAbstractWidgetLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		borderWidth: 	an ObservableValueHolder[ nil ]
		borderColor: 	an ObservableValueHolder[ nil ]
		dragEnabled: 	an ObservableValueHolder[ false ]
		dropEnabled: 	an ObservableValueHolder[ false ]
		color: 	an ObservableValueHolder[ nil ]
		help: 	an ObservableValueHolder[ nil ]
		enabled: 	an ObservableValueHolder[ true ]
		wantsDrop: 	an ObservableValueHolder[ [ :transfer | self dropEnabled ] ]
		acceptDrop: 	an ObservableValueHolder[ [ :transfer | ] ]
		deferredActions: 	nil
		hasUnacceptedEdits: 	an ObservableValueHolder[ false ]
		selection: 	an ObservableValueHolder[ (1 to: 159) ]
		wantsVisualFeedback: 	an ObservableValueHolder[ true ]
		askBeforeDiscardingEdits: 	an ObservableValueHolder[ true ]
		text: 	an ObservableValueHolder[ '| visualizer |
visualizer := GraphVisualiz[..]
		actionToPerform: 	an ObservableValueHolder[ [ :txt |  ] ]
		readSelection: 	an ObservableValueHolder[ [ selection ] ]
		placeholder: 	an ObservableValueHolder[ '' ]
		contextMenu: 	an ObservableValueHolder[ [ (self menuActionsFor: text) asMenu[..]
		scrollValue: 	an ObservableValueHolder[ (0@0) ]
		editionContextMenu: 	an ObservableValueHolder[ true ]
		editable: 	an ObservableValueHolder[ true ]
		wrapWord: 	an ObservableValueHolder[ true ]
		undoRedoHistory: 	true
		wrapScrollBars: 	true
		propagateNaturalHeight: 	false
		propagateNaturalWidth: 	false
		scrollBarStyles: 	#()
		syntaxHighlight: 	an ObservableValueHolder[ true ]
		smartCharacters: 	an ObservableValueHolder[ true ]
		lineNumbers: 	an ObservableValueHolder[ true ]
		interactionModel: 	an ObservableValueHolder[ a StPlaygroundInteractionModel ]
		overrideContextMenu: 	true
		submitBlock: 	nil
		resetBlock: 	nil
		environment: 	nil
		systemNavigation: 	nil
		syntaxHighlightTheme: 	an ObservableValueHolder[ nil ]


StPlaygroundPagePresenter>>doEvaluateAndGo
	Receiver: a StPlaygroundPagePresenter
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicBoxAdapter)
		announcer: 	an Announcer
		owner: 	a SpMillerColumnPresenter
		adapter: 	a SpMorphicBoxAdapter
		needRebuild: 	true
		eventHandler: 	nil
		application: 	a StPharoApplication
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ nil ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Untitled window' ]
		additionalSubpresentersMap: 	a Dictionary()
		layout: 	an ObservableValueHolder[ a SpBoxLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		text: 	a SpCodePresenter
		toolbar: 	a SpToolbarPresenter
		statusbar: 	a SpPresenter
		lineLabel: 	a SpLabelPresenter
		toggleLineNumberButton: 	a SpToggleButtonPresenter
		page: 	a StPlaygroundPage
		activationBlock: 	[ :selection |
		self changeSelection: selection from: new[..]


StPlaygroundPagePresenter>>doEvaluateAllAndGo
	Receiver: a StPlaygroundPagePresenter
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicBoxAdapter)
		announcer: 	an Announcer
		owner: 	a SpMillerColumnPresenter
		adapter: 	a SpMorphicBoxAdapter
		needRebuild: 	true
		eventHandler: 	nil
		application: 	a StPharoApplication
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ nil ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Untitled window' ]
		additionalSubpresentersMap: 	a Dictionary()
		layout: 	an ObservableValueHolder[ a SpBoxLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		text: 	a SpCodePresenter
		toolbar: 	a SpToolbarPresenter
		statusbar: 	a SpPresenter
		lineLabel: 	a SpLabelPresenter
		toggleLineNumberButton: 	a SpToggleButtonPresenter
		page: 	a StPlaygroundPage
		activationBlock: 	[ :selection |
		self changeSelection: selection from: new[..]


StPlaygroundDoItCommand>>execute
	Receiver: a StPlaygroundDoItCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		context: 	a StPlaygroundPagePresenter
		basicName: 	'Do it'
		basicDescription: 	'Do it all and inspect.'


SpCommand(CmCommandDecorator)>>execute
	Receiver: a SpCommand(Do it)
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a StPlaygroundDoItCommand
		iconProvider: 	a StPharoApplication
		iconName: 	#glamorousGo
		shortcutKey: 	nil
		displayStrategy: 	a CmUIDisableWhenCantBeRun
		positionStrategy: 	a CmUILeftPositionStrategy
		buildPresenterBlock: 	[ :specCommand | 
			aButtonClass new
				label: specC[..]
		presenter: 	a SpToolbarButtonPresenter


[ specCommand execute ] in [ :specCommand | 
			aButtonClass new
				label: specCommand name;
				help: specCommand description;
				in: [ :button | 
					specCommand hasIcon
						ifTrue: [ button icon: specCommand icon ] ];
				action: [ specCommand execute ];
				yourself ] in SpCommand>>configureAsButtonOfClass:
	Receiver: a SpCommand(Do it)
	Arguments and temporary variables: 
		aButtonClass: 	nil
		specCommand: 	a SpCommand(Do it)
	Receiver's instance variables: 
		decoratedCommand: 	a StPlaygroundDoItCommand
		iconProvider: 	a StPharoApplication
		iconName: 	#glamorousGo
		shortcutKey: 	nil
		displayStrategy: 	a CmUIDisableWhenCantBeRun
		positionStrategy: 	a CmUILeftPositionStrategy
		buildPresenterBlock: 	[ :specCommand | 
			aButtonClass new
				label: specC[..]
		presenter: 	a SpToolbarButtonPresenter


FullBlockClosure(BlockClosure)>>cull:
	Receiver: [ specCommand execute ]
	Arguments and temporary variables: 
		anArg: 	a SpToolbarButtonPresenter
	Receiver's instance variables: 
		outerContext: 	[ :specCommand | 
			aButtonClass new
				label: specCommand [..]
		compiledBlock: 	a CompiledBlock: [ specCommand execute ]
		numArgs: 	0
		receiver: 	a SpCommand(Do it)


SpMorphicToolbarButtonAdapter>>execute
	Receiver: a SpMorphicToolbarButtonAdapter
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpToolbarButtonMorph(319944704))
		announcer: 	nil
		model: 	a SpToolbarButtonPresenter
		widget: 	a SpToolbarButtonMorph(319944704)
		selector: 	nil
		owner: 	a SpToolbarButtonPresenter
		unsubscribed: 	false


SpToolbarButtonMorph(PluggableButtonMorph)>>performAction:
	Receiver: a SpToolbarButtonMorph(319944704)
	Arguments and temporary variables: 
		event: 	[(24.0@16.0) mouseUp 9212044 nil]
	Receiver's instance variables: 
		bounds: 	(0.0@5.0) corner: (45.0@39.0)
		owner: 	a Morph(13467904)
		submorphs: 	an Array(an AlignmentMorph(869548288))
		fullBounds: 	nil
		color: 	(Color r: 0.9012707722385142 g: 0.9012707722385142 b: 0.901270772238[..]
		extension: 	a MorphExtension (545772544) [balloonText]  [other:  (presenter [..]
		borderWidth: 	0
		borderColor: 	#simple
		model: 	a SpMorphicToolbarButtonAdapter
		label: 	'Do it'
		icon: 	Form(13x13x32)
		getIconSelector: 	#icon
		getStateSelector: 	#state
		actionSelector: 	#execute
		font: 	a LogicalFont
 familyName: 'Source Sans Pro'
 emphasis: nil
 pointSiz[..]
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	nil
		getFontSelector: 	nil
		labelMorph: 	a LabelMorph(424853504)'Do it'
		iconMorph: 	an ImageMorph(356841984)
		iconPosition: 	#top
		lastState: 	false
		badgeFont: 	nil
		badgeSelector: 	#badge


[:m |
		(m containsPoint: evt cursorPoint) ifTrue: [m enabled ifTrue: [ m performAction: evt ]]] in SpToolbarButtonMorph(PluggableButtonMorph)>>mouseUp:
	Receiver: a SpToolbarButtonMorph(319944704)
	Arguments and temporary variables: 
		evt: 	[(24.0@16.0) mouseUp 9212044 nil]
		all: 	an Array(a SpToolbarButtonMorph(319944704) a SpToolbarButtonMorph(5749[..]
		m: 	a SpToolbarButtonMorph(319944704)
	Receiver's instance variables: 
		bounds: 	(0.0@5.0) corner: (45.0@39.0)
		owner: 	a Morph(13467904)
		submorphs: 	an Array(an AlignmentMorph(869548288))
		fullBounds: 	nil
		color: 	(Color r: 0.9012707722385142 g: 0.9012707722385142 b: 0.901270772238[..]
		extension: 	a MorphExtension (545772544) [balloonText]  [other:  (presenter [..]
		borderWidth: 	0
		borderColor: 	#simple
		model: 	a SpMorphicToolbarButtonAdapter
		label: 	'Do it'
		icon: 	Form(13x13x32)
		getIconSelector: 	#icon
		getStateSelector: 	#state
		actionSelector: 	#execute
		font: 	a LogicalFont
 familyName: 'Source Sans Pro'
 emphasis: nil
 pointSiz[..]
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	nil
		getFontSelector: 	nil
		labelMorph: 	a LabelMorph(424853504)'Do it'
		iconMorph: 	an ImageMorph(356841984)
		iconPosition: 	#top
		lastState: 	false
		badgeFont: 	nil
		badgeSelector: 	#badge


Array(SequenceableCollection)>>do:
	Receiver: an Array(a SpToolbarButtonMorph(319944704) a SpToolbarButtonMorph(574995456) a SpToolb[..]
	Arguments and temporary variables: 
		aBlock: 	[:m |
		(m containsPoint: evt cursorPoint) ifTrue: [m enabled ifTru[..]
		index: 	1
	Receiver's instance variables: 
an Array(a SpToolbarButtonMorph(319944704) a SpToolbarButtonMorph(574995456) a SpToolb[..]

SpToolbarButtonMorph(PluggableButtonMorph)>>mouseUp:
	Receiver: a SpToolbarButtonMorph(319944704)
	Arguments and temporary variables: 
		evt: 	[(24.0@16.0) mouseUp 9212044 nil]
		all: 	an Array(a SpToolbarButtonMorph(319944704) a SpToolbarButtonMorph(5749[..]
	Receiver's instance variables: 
		bounds: 	(0.0@5.0) corner: (45.0@39.0)
		owner: 	a Morph(13467904)
		submorphs: 	an Array(an AlignmentMorph(869548288))
		fullBounds: 	nil
		color: 	(Color r: 0.9012707722385142 g: 0.9012707722385142 b: 0.901270772238[..]
		extension: 	a MorphExtension (545772544) [balloonText]  [other:  (presenter [..]
		borderWidth: 	0
		borderColor: 	#simple
		model: 	a SpMorphicToolbarButtonAdapter
		label: 	'Do it'
		icon: 	Form(13x13x32)
		getIconSelector: 	#icon
		getStateSelector: 	#state
		actionSelector: 	#execute
		font: 	a LogicalFont
 familyName: 'Source Sans Pro'
 emphasis: nil
 pointSiz[..]
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	nil
		getFontSelector: 	nil
		labelMorph: 	a LabelMorph(424853504)'Do it'
		iconMorph: 	an ImageMorph(356841984)
		iconPosition: 	#top
		lastState: 	false
		badgeFont: 	nil
		badgeSelector: 	#badge


SpToolbarButtonMorph(Morph)>>handleMouseUp:
	Receiver: a SpToolbarButtonMorph(319944704)
	Arguments and temporary variables: 
		anEvent: 	[(24.0@16.0) mouseUp 9212044 nil]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(0.0@5.0) corner: (45.0@39.0)
		owner: 	a Morph(13467904)
		submorphs: 	an Array(an AlignmentMorph(869548288))
		fullBounds: 	nil
		color: 	(Color r: 0.9012707722385142 g: 0.9012707722385142 b: 0.901270772238[..]
		extension: 	a MorphExtension (545772544) [balloonText]  [other:  (presenter [..]
		borderWidth: 	0
		borderColor: 	#simple
		model: 	a SpMorphicToolbarButtonAdapter
		label: 	'Do it'
		icon: 	Form(13x13x32)
		getIconSelector: 	#icon
		getStateSelector: 	#state
		actionSelector: 	#execute
		font: 	a LogicalFont
 familyName: 'Source Sans Pro'
 emphasis: nil
 pointSiz[..]
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	nil
		getFontSelector: 	nil
		labelMorph: 	a LabelMorph(424853504)'Do it'
		iconMorph: 	an ImageMorph(356841984)
		iconPosition: 	#top
		lastState: 	false
		badgeFont: 	nil
		badgeSelector: 	#badge


MouseButtonEvent>>sentTo:
	Receiver: [(24.0@16.0) mouseUp 9212044 nil]
	Arguments and temporary variables: 
		anObject: 	a SpToolbarButtonMorph(319944704)
	Receiver's instance variables: 
		timeStamp: 	9212044
		source: 	a HandMorph(337424384)
		windowIndex: 	nil
		type: 	#mouseUp
		buttons: 	0
		position: 	(24.0@16.0)
		handler: 	nil
		wasHandled: 	true
		whichButton: 	4


SpToolbarButtonMorph(Morph)>>handleEvent:
	Receiver: a SpToolbarButtonMorph(319944704)
	Arguments and temporary variables: 
		anEvent: 	[(24.0@16.0) mouseUp 9212044 nil]
	Receiver's instance variables: 
		bounds: 	(0.0@5.0) corner: (45.0@39.0)
		owner: 	a Morph(13467904)
		submorphs: 	an Array(an AlignmentMorph(869548288))
		fullBounds: 	nil
		color: 	(Color r: 0.9012707722385142 g: 0.9012707722385142 b: 0.901270772238[..]
		extension: 	a MorphExtension (545772544) [balloonText]  [other:  (presenter [..]
		borderWidth: 	0
		borderColor: 	#simple
		model: 	a SpMorphicToolbarButtonAdapter
		label: 	'Do it'
		icon: 	Form(13x13x32)
		getIconSelector: 	#icon
		getStateSelector: 	#state
		actionSelector: 	#execute
		font: 	a LogicalFont
 familyName: 'Source Sans Pro'
 emphasis: nil
 pointSiz[..]
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	nil
		getFontSelector: 	nil
		labelMorph: 	a LabelMorph(424853504)'Do it'
		iconMorph: 	an ImageMorph(356841984)
		iconPosition: 	#top
		lastState: 	false
		badgeFont: 	nil
		badgeSelector: 	#badge


SpToolbarButtonMorph(Morph)>>handleFocusEvent:
	Receiver: a SpToolbarButtonMorph(319944704)
	Arguments and temporary variables: 
		anEvent: 	[(24.0@16.0) mouseUp 9212044 nil]
	Receiver's instance variables: 
		bounds: 	(0.0@5.0) corner: (45.0@39.0)
		owner: 	a Morph(13467904)
		submorphs: 	an Array(an AlignmentMorph(869548288))
		fullBounds: 	nil
		color: 	(Color r: 0.9012707722385142 g: 0.9012707722385142 b: 0.901270772238[..]
		extension: 	a MorphExtension (545772544) [balloonText]  [other:  (presenter [..]
		borderWidth: 	0
		borderColor: 	#simple
		model: 	a SpMorphicToolbarButtonAdapter
		label: 	'Do it'
		icon: 	Form(13x13x32)
		getIconSelector: 	#icon
		getStateSelector: 	#state
		actionSelector: 	#execute
		font: 	a LogicalFont
 familyName: 'Source Sans Pro'
 emphasis: nil
 pointSiz[..]
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	nil
		getFontSelector: 	nil
		labelMorph: 	a LabelMorph(424853504)'Do it'
		iconMorph: 	an ImageMorph(356841984)
		iconPosition: 	#top
		lastState: 	false
		badgeFont: 	nil
		badgeSelector: 	#badge


[
		result := focusHolder handleFocusEvent: transformedEvent.
	] in HandMorph>>sendFocusEvent:to:clear:
	Receiver: a HandMorph(337424384)
	Arguments and temporary variables: 
		anEvent: 	[(543@334) mouseUp 9212044 nil]
		focusHolder: 	a SpToolbarButtonMorph(319944704)
		aBlock: 	[self mouseFocus: nil]
		w: 	a WorldMorph(341720576) [world]
		transformedEvent: 	[(24.0@16.0) mouseUp 9212044 nil]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(543@334.0) corner: (559@350.0)
		owner: 	a WorldMorph(341720576) [world]
		submorphs: 	#()
		fullBounds: 	(543@334.0) corner: (559@350.0)
		color: 	Color blue
		extension: 	a MorphExtension (370611968)
		mouseFocus: 	nil
		keyboardFocus: 	a RubEditingArea(189250304)
		eventListeners: 	nil
		mouseListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(543@334) mouseUp 9212044 nil]
		targetOffset: 	(24.0@11.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	true
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 0 0 0 0 0 nil nil)
		captureBlock: 	nil
		recentModifiers: 	0
		pendingEventQueue: 	WaitfreeQueue with 0 items
		supressNextKeyPress: 	false


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
		result := focusHolder handleFocusEvent: transformedEvent.
	]
	Arguments and temporary variables: 
		exception: 	Error
		handlerAction: 	[ :ex |
			ActiveWorld := priorWorld.
			ex pass ]
	Receiver's instance variables: 
		outerContext: 	HandMorph>>sendFocusEvent:to:clear:
		compiledBlock: 	a CompiledBlock: [
		result := focusHolder handleFocusEvent:[..]
		numArgs: 	0
		receiver: 	a HandMorph(337424384)


WorldMorph>>becomeActiveDuring:
	Receiver: a WorldMorph(341720576) [world]
	Arguments and temporary variables: 
		aBlock: 	[
		result := focusHolder handleFocusEvent: transformedEvent.
	]
		priorWorld: 	a WorldMorph(341720576) [world]
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1728@1080)
		owner: 	nil
		submorphs: 	an Array(a MenubarMorph(112886016) a TaskbarMorph(279458560) a S[..]
		fullBounds: 	(0@0) corner: (1728@1080)
		color: 	(Color r: 0.9403714565004888 g: 0.9403714565004888 b: 0.940371456500[..]
		extension: 	a MorphExtension (1012946432) [other:  (dragEnabled -> true) (dr[..]
		borderWidth: 	0
		borderColor: 	(Color r: 0.8611925708699902 g: 1.0 b: 0.7223851417399805 alph[..]
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil


HandMorph>>sendFocusEvent:to:clear:
	Receiver: a HandMorph(337424384)
	Arguments and temporary variables: 
		result: 	nil
		anEvent: 	[(543@334) mouseUp 9212044 nil]
		focusHolder: 	a SpToolbarButtonMorph(319944704)
		aBlock: 	[self mouseFocus: nil]
		w: 	a WorldMorph(341720576) [world]
		transformedEvent: 	[(24.0@16.0) mouseUp 9212044 nil]
	Receiver's instance variables: 
		bounds: 	(543@334.0) corner: (559@350.0)
		owner: 	a WorldMorph(341720576) [world]
		submorphs: 	#()
		fullBounds: 	(543@334.0) corner: (559@350.0)
		color: 	Color blue
		extension: 	a MorphExtension (370611968)
		mouseFocus: 	nil
		keyboardFocus: 	a RubEditingArea(189250304)
		eventListeners: 	nil
		mouseListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(543@334) mouseUp 9212044 nil]
		targetOffset: 	(24.0@11.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	true
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 0 0 0 0 0 nil nil)
		captureBlock: 	nil
		recentModifiers: 	0
		pendingEventQueue: 	WaitfreeQueue with 0 items
		supressNextKeyPress: 	false


HandMorph>>sendEvent:focus:clear:
	Receiver: a HandMorph(337424384)
	Arguments and temporary variables: 
		anEvent: 	[(543@334) mouseUp 9212044 nil]
		focusHolder: 	a SpToolbarButtonMorph(319944704)
		aBlock: 	[self mouseFocus: nil]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(543@334.0) corner: (559@350.0)
		owner: 	a WorldMorph(341720576) [world]
		submorphs: 	#()
		fullBounds: 	(543@334.0) corner: (559@350.0)
		color: 	Color blue
		extension: 	a MorphExtension (370611968)
		mouseFocus: 	nil
		keyboardFocus: 	a RubEditingArea(189250304)
		eventListeners: 	nil
		mouseListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(543@334) mouseUp 9212044 nil]
		targetOffset: 	(24.0@11.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	true
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 0 0 0 0 0 nil nil)
		captureBlock: 	nil
		recentModifiers: 	0
		pendingEventQueue: 	WaitfreeQueue with 0 items
		supressNextKeyPress: 	false


HandMorph>>sendMouseEvent:
	Receiver: a HandMorph(337424384)
	Arguments and temporary variables: 
		anEvent: 	[(543@334) mouseUp 9212044 nil]
	Receiver's instance variables: 
		bounds: 	(543@334.0) corner: (559@350.0)
		owner: 	a WorldMorph(341720576) [world]
		submorphs: 	#()
		fullBounds: 	(543@334.0) corner: (559@350.0)
		color: 	Color blue
		extension: 	a MorphExtension (370611968)
		mouseFocus: 	nil
		keyboardFocus: 	a RubEditingArea(189250304)
		eventListeners: 	nil
		mouseListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(543@334) mouseUp 9212044 nil]
		targetOffset: 	(24.0@11.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	true
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 0 0 0 0 0 nil nil)
		captureBlock: 	nil
		recentModifiers: 	0
		pendingEventQueue: 	WaitfreeQueue with 0 items
		supressNextKeyPress: 	false


HandMorph>>handleEvent:
	Receiver: a HandMorph(337424384)
	Arguments and temporary variables: 
		anEvent: 	[(543@334) mouseUp 9212044 nil]
		evt: 	[(543@334) mouseUp 9212044 nil]
	Receiver's instance variables: 
		bounds: 	(543@334.0) corner: (559@350.0)
		owner: 	a WorldMorph(341720576) [world]
		submorphs: 	#()
		fullBounds: 	(543@334.0) corner: (559@350.0)
		color: 	Color blue
		extension: 	a MorphExtension (370611968)
		mouseFocus: 	nil
		keyboardFocus: 	a RubEditingArea(189250304)
		eventListeners: 	nil
		mouseListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(543@334) mouseUp 9212044 nil]
		targetOffset: 	(24.0@11.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	true
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 0 0 0 0 0 nil nil)
		captureBlock: 	nil
		recentModifiers: 	0
		pendingEventQueue: 	WaitfreeQueue with 0 items
		supressNextKeyPress: 	false


[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil ]) ifTrue: [
			morphicWorld activeHand handleEvent: anEvent
		]
	] in OSWindowMorphicEventHandler>>dispatchMorphicEvent:
	Receiver: an OSWindowMorphicEventHandler
	Arguments and temporary variables: 
		anEvent: 	[(543@334) mouseUp 9212044 nil]
	Receiver's instance variables: 
		morphicWorld: 	a WorldMorph(341720576) [world]


WorldState>>runStepMethodsIn:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(341720576) [world]
		queue: 	WaitfreeQueue with 0 items
		nextInQueue: 	[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNo[..]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(337424384))
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap()
		lastStepTime: 	9145130
		lastStepMessage: 	nil
		alarms: 	a Heap(MorphicAlarm(#hideShow -> a RubCursor(898368768)))
		lastAlarmTime: 	9212037
		activeHand: 	a HandMorph(337424384)
		currentCursor: 	((CursorWithMask
	extent: (16@16)
	depth: 1
	fromArray: #(
	[..]
		worldRenderer: 	an OSWorldRenderer
		realWindowExtent: 	(1728@1080)
		deferredUIMessages: 	WaitfreeQueue with 0 items


WorldMorph>>runStepMethods
	Receiver: a WorldMorph(341720576) [world]
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1728@1080)
		owner: 	nil
		submorphs: 	an Array(a MenubarMorph(112886016) a TaskbarMorph(279458560) a S[..]
		fullBounds: 	(0@0) corner: (1728@1080)
		color: 	(Color r: 0.9403714565004888 g: 0.9403714565004888 b: 0.940371456500[..]
		extension: 	a MorphExtension (1012946432) [other:  (dragEnabled -> true) (dr[..]
		borderWidth: 	0
		borderColor: 	(Color r: 0.8611925708699902 g: 1.0 b: 0.7223851417399805 alph[..]
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil


WorldState>>doOneCycleFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(341720576) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(337424384))
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap()
		lastStepTime: 	9145130
		lastStepMessage: 	nil
		alarms: 	a Heap(MorphicAlarm(#hideShow -> a RubCursor(898368768)))
		lastAlarmTime: 	9212037
		activeHand: 	a HandMorph(337424384)
		currentCursor: 	((CursorWithMask
	extent: (16@16)
	depth: 1
	fromArray: #(
	[..]
		worldRenderer: 	an OSWorldRenderer
		realWindowExtent: 	(1728@1080)
		deferredUIMessages: 	WaitfreeQueue with 0 items


WorldMorph>>doOneCycleNow
	Receiver: a WorldMorph(341720576) [world]
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1728@1080)
		owner: 	nil
		submorphs: 	an Array(a MenubarMorph(112886016) a TaskbarMorph(279458560) a S[..]
		fullBounds: 	(0@0) corner: (1728@1080)
		color: 	(Color r: 0.9403714565004888 g: 0.9403714565004888 b: 0.940371456500[..]
		extension: 	a MorphExtension (1012946432) [other:  (dragEnabled -> true) (dr[..]
		borderWidth: 	0
		borderColor: 	(Color r: 0.8611925708699902 g: 1.0 b: 0.7223851417399805 alph[..]
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil


WorldMorph>>doOneCycle
	Receiver: a WorldMorph(341720576) [world]
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1728@1080)
		owner: 	nil
		submorphs: 	an Array(a MenubarMorph(112886016) a TaskbarMorph(279458560) a S[..]
		fullBounds: 	(0@0) corner: (1728@1080)
		color: 	(Color r: 0.9403714565004888 g: 0.9403714565004888 b: 0.940371456500[..]
		extension: 	a MorphExtension (1012946432) [other:  (dragEnabled -> true) (dr[..]
		borderWidth: 	0
		borderColor: 	(Color r: 0.8611925708699902 g: 1.0 b: 0.7223851417399805 alph[..]
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil


[
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMutex critical: [
			                     self extraWorldList ].
		extraWorldsToDraw do: [ :world | world doOneCycle ].

		(self currentWorld isNotNil and: [
			 (extraWorldsToDraw includes: self currentWorld) not ]) ifTrue: [
			self currentWorld doOneCycle ] ] in WorldMorph class>>doOneCycle
	Receiver: WorldMorph
	Arguments and temporary variables: 
		extraWorldsToDraw: 	#()
	Receiver's instance variables: 
		superclass: 	PasteUpMorph
		methodDict: 	a MethodDictionary(#acceptDroppingMorph:event:->WorldMorph>>#ac[..]
		format: 	65547
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		commentSourcePointer: 	nil
		subclasses: 	{AthensWorldMorph. OSWindowWorldMorph}
		name: 	#WorldMorph
		classPool: 	a Dictionary(#AllowDropFiles->nil #CursorOwnerWorld->a WorldMorp[..]
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Morphic-Core-Worlds'
		announcer: 	nil
		displayScaleFactor: 	1


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMutex critical: [
			  [..]
	Arguments and temporary variables: 
		aBlock: 	[
		self doInterCycleWait
	]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	WorldMorph class>>doOneCycle
		compiledBlock: 	a CompiledBlock: [
		| extraWorldsToDraw |
		extraWorldsToDr[..]
		numArgs: 	0
		receiver: 	WorldMorph



--- The full stack ---
UndefinedObject>>doesNotUnderstand: #new
GraphVisualizer>>initialize
GraphVisualizer class(Behavior)>>new
UndefinedObject>>DoIt
OCReceiverDoItSemanticScope(OCDoItSemanticScope)>>evaluateDoIt:
OpalCompiler>>evaluate
[
		self announcer announce: (SpCodeWillBeEvaluatedAnnouncement newContent: aString).
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionModel doItReceiver.
		result := receiver class compiler
			source: aString;
			context: self interactionModel doItContext;
			receiver: self interactionModel doItReceiver;
			requestor: self interactionModel;
			environment: self environment;
			failBlock:  [ 
				self announcer announce: (SpCodeEvaluationFailedAnnouncement newContent: aString).
				^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		self announcer announce: (SpCodeEvaluationSucceedAnnouncement newContent: aString).
		result ] in SpCodePresenter>>evaluate:onCompileError:onError:
FullBlockClosure(BlockClosure)>>on:do:
SpCodePresenter>>evaluate:onCompileError:onError:
StPlaygroundPagePresenter>>doEvaluateAndGo
StPlaygroundPagePresenter>>doEvaluateAllAndGo
StPlaygroundDoItCommand>>execute
SpCommand(CmCommandDecorator)>>execute
[ specCommand execute ] in [ :specCommand | 
			aButtonClass new
				label: specCommand name;
				help: specCommand description;
				in: [ :button | 
					specCommand hasIcon
						ifTrue: [ button icon: specCommand icon ] ];
				action: [ specCommand execute ];
				yourself ] in SpCommand>>configureAsButtonOfClass:
FullBlockClosure(BlockClosure)>>cull:
SpMorphicToolbarButtonAdapter>>execute
SpToolbarButtonMorph(PluggableButtonMorph)>>performAction:
[:m |
		(m containsPoint: evt cursorPoint) ifTrue: [m enabled ifTrue: [ m performAction: evt ]]] in SpToolbarButtonMorph(PluggableButtonMorph)>>mouseUp:
Array(SequenceableCollection)>>do:
SpToolbarButtonMorph(PluggableButtonMorph)>>mouseUp:
SpToolbarButtonMorph(Morph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
SpToolbarButtonMorph(Morph)>>handleEvent:
SpToolbarButtonMorph(Morph)>>handleFocusEvent:
[
		result := focusHolder handleFocusEvent: transformedEvent.
	] in HandMorph>>sendFocusEvent:to:clear:
FullBlockClosure(BlockClosure)>>on:do:
WorldMorph>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil ]) ifTrue: [
			morphicWorld activeHand handleEvent: anEvent
		]
	] in OSWindowMorphicEventHandler>>dispatchMorphicEvent:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycleNow
WorldMorph>>doOneCycle
[
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMutex critical: [
			                     self extraWorldList ].
		extraWorldsToDraw do: [ :world | world doOneCycle ].

		(self currentWorld isNotNil and: [
			 (extraWorldsToDraw includes: self currentWorld) not ]) ifTrue: [
			self currentWorld doOneCycle ] ] in WorldMorph class>>doOneCycle
FullBlockClosure(BlockClosure)>>ensure:
 - - - - - - - - - - - - - - -
			- - - - - - - - - - - - - - - - - -
WorldState class>>doDrawCycleWith:
WorldMorph class>>doOneCycle
MorphicRenderLoop>>doOneCycle
MorphicRenderLoop>>doOneCycleWhile:
[ MorphicRenderLoop new doOneCycleWhile: [ true ] ] in MorphicUIManager>>spawnNewProcess
[self value.
			"IMPORTANT: Do not step over next line of code. See method comments for details"
			Processor terminateRealActive] in FullBlockClosure(BlockClosure)>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
#RSView is missing, and does not understand #new
13 November 2023 6:38:13.95061 pm

VM: Mac OS - arm64 - 1000 - CoInterpreter VMMaker-tonel.1 uuid: 902dd483-c0c4-0d00-86f2-0f880df24b96 Oct 23 2023
StackToRegisterMappingCogit VMMaker-tonel.1 uuid: 902dd483-c0c4-0d00-86f2-0f880df24b96 Oct 23 2023
v10.0.8 - Commit: b323c5fb - Date: 2023-10-20 16:02:07 -0400

Image: Pharo11.0.0 [Build information: Pharo-11.0.0+build.710.sha.ea28d8552cac85a7ce1e9c34ab1e7bd45f7b9910 (64 Bit)]

UndefinedObject>>doesNotUnderstand: #new
	Receiver: nil
	Arguments and temporary variables: 
		node: 	RBVariableNode(RSView)
		aMessage: 	new
		exception: 	#RSView is missing, and does not understand #new
		resumeValue: 	nil
	Receiver's instance variables: 
nil

GraphVisualizer>>initialize
	Receiver: a GraphVisualizer
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		view: 	nil
		nodes: 	nil
		edges: 	nil
		nodesMap: 	nil


GraphVisualizer class(Behavior)>>new
	Receiver: GraphVisualizer
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary(#createEdges->GraphVisualizer>>#createEdges [..]
		format: 	65540
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		commentSourcePointer: 	nil
		subclasses: 	#()
		name: 	#GraphVisualizer
		classPool: 	nil
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#Visualizer


UndefinedObject>>DoIt
	Receiver: nil
	Arguments and temporary variables: 
		visualizer: 	nil
	Receiver's instance variables: 
nil

OCReceiverDoItSemanticScope(OCDoItSemanticScope)>>evaluateDoIt:
	Receiver: an OCReceiverDoItSemanticScope
	Arguments and temporary variables: 
		doItMethod: 	UndefinedObject>>#DoIt
	Receiver's instance variables: 
		outerScope: 	nil
		targetReceiver: 	nil


OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
		doItMethod: 	UndefinedObject>>#DoIt
	Receiver's instance variables: 
		ast: 	DoIt

	| visualizer |
	visualizer := GraphVisualizer new.
	^ visualize[..]
		source: 	a ReadStream
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil


[
		self announcer announce: (SpCodeWillBeEvaluatedAnnouncement newContent: aString).
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionModel doItReceiver.
		result := receiver class compiler
			source: aString;
			context: self interactionModel doItContext;
			receiver: self interactionModel doItReceiver;
			requestor: self interactionModel;
			environment: self environment;
			failBlock:  [ 
				self announcer announce: (SpCodeEvaluationFailedAnnouncement newContent: aString).
				^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		self announcer announce: (SpCodeEvaluationSucceedAnnouncement newContent: aString).
		result ] in SpCodePresenter>>evaluate:onCompileError:onError:
	Receiver: a SpCodePresenter
	Arguments and temporary variables: 
		aString: 	'| visualizer |
visualizer := GraphVisualizer new.
visualizer visu[..]
		compileErrorBlock: 	[ ^ self ]
		errorBlock: 	[ :e | e pass ]
		receiver: 	nil
		result: 	nil
		oldBindings: 	a Dictionary()
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicCodeAdapter)
		announcer: 	an Announcer
		owner: 	a StPlaygroundPagePresenter
		adapter: 	a SpMorphicCodeAdapter
		needRebuild: 	true
		eventHandler: 	a SpEventHandler
		application: 	nil
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ a KMCategory ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Code' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpAbstractWidgetLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		borderWidth: 	an ObservableValueHolder[ nil ]
		borderColor: 	an ObservableValueHolder[ nil ]
		dragEnabled: 	an ObservableValueHolder[ false ]
		dropEnabled: 	an ObservableValueHolder[ false ]
		color: 	an ObservableValueHolder[ nil ]
		help: 	an ObservableValueHolder[ nil ]
		enabled: 	an ObservableValueHolder[ true ]
		wantsDrop: 	an ObservableValueHolder[ [ :transfer | self dropEnabled ] ]
		acceptDrop: 	an ObservableValueHolder[ [ :transfer | ] ]
		deferredActions: 	nil
		hasUnacceptedEdits: 	an ObservableValueHolder[ false ]
		selection: 	an ObservableValueHolder[ (1 to: 159) ]
		wantsVisualFeedback: 	an ObservableValueHolder[ true ]
		askBeforeDiscardingEdits: 	an ObservableValueHolder[ true ]
		text: 	an ObservableValueHolder[ '| visualizer |
visualizer := GraphVisualiz[..]
		actionToPerform: 	an ObservableValueHolder[ [ :txt |  ] ]
		readSelection: 	an ObservableValueHolder[ [ selection ] ]
		placeholder: 	an ObservableValueHolder[ '' ]
		contextMenu: 	an ObservableValueHolder[ [ (self menuActionsFor: text) asMenu[..]
		scrollValue: 	an ObservableValueHolder[ (0@0) ]
		editionContextMenu: 	an ObservableValueHolder[ true ]
		editable: 	an ObservableValueHolder[ true ]
		wrapWord: 	an ObservableValueHolder[ true ]
		undoRedoHistory: 	true
		wrapScrollBars: 	true
		propagateNaturalHeight: 	false
		propagateNaturalWidth: 	false
		scrollBarStyles: 	#()
		syntaxHighlight: 	an ObservableValueHolder[ true ]
		smartCharacters: 	an ObservableValueHolder[ true ]
		lineNumbers: 	an ObservableValueHolder[ true ]
		interactionModel: 	an ObservableValueHolder[ a StPlaygroundInteractionModel ]
		overrideContextMenu: 	true
		submitBlock: 	nil
		resetBlock: 	nil
		environment: 	nil
		systemNavigation: 	nil
		syntaxHighlightTheme: 	an ObservableValueHolder[ nil ]


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
		self announcer announce: (SpCodeWillBeEvaluatedAnnouncement newContent: aString).
[..]
	Arguments and temporary variables: 
		exception: 	Error
		handlerAction: 	[ :e |
		self announcer announce: (SpCodeEvaluationFailedAnn[..]
	Receiver's instance variables: 
		outerContext: 	SpCodePresenter>>evaluate:onCompileError:onError:
		compiledBlock: 	a CompiledBlock: [
		self announcer announce: (SpCodeWillBeE[..]
		numArgs: 	0
		receiver: 	a SpCodePresenter


SpCodePresenter>>evaluate:onCompileError:onError:
	Receiver: a SpCodePresenter
	Arguments and temporary variables: 
		receiver: 	nil
		result: 	nil
		oldBindings: 	a Dictionary()
		aString: 	'| visualizer |
visualizer := GraphVisualizer new.
visualizer visu[..]
		compileErrorBlock: 	[ ^ self ]
		errorBlock: 	[ :e | e pass ]
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicCodeAdapter)
		announcer: 	an Announcer
		owner: 	a StPlaygroundPagePresenter
		adapter: 	a SpMorphicCodeAdapter
		needRebuild: 	true
		eventHandler: 	a SpEventHandler
		application: 	nil
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ a KMCategory ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Code' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpAbstractWidgetLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		borderWidth: 	an ObservableValueHolder[ nil ]
		borderColor: 	an ObservableValueHolder[ nil ]
		dragEnabled: 	an ObservableValueHolder[ false ]
		dropEnabled: 	an ObservableValueHolder[ false ]
		color: 	an ObservableValueHolder[ nil ]
		help: 	an ObservableValueHolder[ nil ]
		enabled: 	an ObservableValueHolder[ true ]
		wantsDrop: 	an ObservableValueHolder[ [ :transfer | self dropEnabled ] ]
		acceptDrop: 	an ObservableValueHolder[ [ :transfer | ] ]
		deferredActions: 	nil
		hasUnacceptedEdits: 	an ObservableValueHolder[ false ]
		selection: 	an ObservableValueHolder[ (1 to: 159) ]
		wantsVisualFeedback: 	an ObservableValueHolder[ true ]
		askBeforeDiscardingEdits: 	an ObservableValueHolder[ true ]
		text: 	an ObservableValueHolder[ '| visualizer |
visualizer := GraphVisualiz[..]
		actionToPerform: 	an ObservableValueHolder[ [ :txt |  ] ]
		readSelection: 	an ObservableValueHolder[ [ selection ] ]
		placeholder: 	an ObservableValueHolder[ '' ]
		contextMenu: 	an ObservableValueHolder[ [ (self menuActionsFor: text) asMenu[..]
		scrollValue: 	an ObservableValueHolder[ (0@0) ]
		editionContextMenu: 	an ObservableValueHolder[ true ]
		editable: 	an ObservableValueHolder[ true ]
		wrapWord: 	an ObservableValueHolder[ true ]
		undoRedoHistory: 	true
		wrapScrollBars: 	true
		propagateNaturalHeight: 	false
		propagateNaturalWidth: 	false
		scrollBarStyles: 	#()
		syntaxHighlight: 	an ObservableValueHolder[ true ]
		smartCharacters: 	an ObservableValueHolder[ true ]
		lineNumbers: 	an ObservableValueHolder[ true ]
		interactionModel: 	an ObservableValueHolder[ a StPlaygroundInteractionModel ]
		overrideContextMenu: 	true
		submitBlock: 	nil
		resetBlock: 	nil
		environment: 	nil
		systemNavigation: 	nil
		syntaxHighlightTheme: 	an ObservableValueHolder[ nil ]


StPlaygroundPagePresenter>>doEvaluateAndGo
	Receiver: a StPlaygroundPagePresenter
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicBoxAdapter)
		announcer: 	an Announcer
		owner: 	a SpMillerColumnPresenter
		adapter: 	a SpMorphicBoxAdapter
		needRebuild: 	true
		eventHandler: 	nil
		application: 	a StPharoApplication
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ nil ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Untitled window' ]
		additionalSubpresentersMap: 	a Dictionary()
		layout: 	an ObservableValueHolder[ a SpBoxLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		text: 	a SpCodePresenter
		toolbar: 	a SpToolbarPresenter
		statusbar: 	a SpPresenter
		lineLabel: 	a SpLabelPresenter
		toggleLineNumberButton: 	a SpToggleButtonPresenter
		page: 	a StPlaygroundPage
		activationBlock: 	[ :selection |
		self changeSelection: selection from: new[..]


StPlaygroundPagePresenter>>doEvaluateAllAndGo
	Receiver: a StPlaygroundPagePresenter
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicBoxAdapter)
		announcer: 	an Announcer
		owner: 	a SpMillerColumnPresenter
		adapter: 	a SpMorphicBoxAdapter
		needRebuild: 	true
		eventHandler: 	nil
		application: 	a StPharoApplication
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ nil ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Untitled window' ]
		additionalSubpresentersMap: 	a Dictionary()
		layout: 	an ObservableValueHolder[ a SpBoxLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		text: 	a SpCodePresenter
		toolbar: 	a SpToolbarPresenter
		statusbar: 	a SpPresenter
		lineLabel: 	a SpLabelPresenter
		toggleLineNumberButton: 	a SpToggleButtonPresenter
		page: 	a StPlaygroundPage
		activationBlock: 	[ :selection |
		self changeSelection: selection from: new[..]


StPlaygroundDoItCommand>>execute
	Receiver: a StPlaygroundDoItCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		context: 	a StPlaygroundPagePresenter
		basicName: 	'Do it'
		basicDescription: 	'Do it all and inspect.'


SpCommand(CmCommandDecorator)>>execute
	Receiver: a SpCommand(Do it)
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a StPlaygroundDoItCommand
		iconProvider: 	a StPharoApplication
		iconName: 	#glamorousGo
		shortcutKey: 	nil
		displayStrategy: 	a CmUIDisableWhenCantBeRun
		positionStrategy: 	a CmUILeftPositionStrategy
		buildPresenterBlock: 	[ :specCommand | 
			aButtonClass new
				label: specC[..]
		presenter: 	a SpToolbarButtonPresenter


[ specCommand execute ] in [ :specCommand | 
			aButtonClass new
				label: specCommand name;
				help: specCommand description;
				in: [ :button | 
					specCommand hasIcon
						ifTrue: [ button icon: specCommand icon ] ];
				action: [ specCommand execute ];
				yourself ] in SpCommand>>configureAsButtonOfClass:
	Receiver: a SpCommand(Do it)
	Arguments and temporary variables: 
		aButtonClass: 	nil
		specCommand: 	a SpCommand(Do it)
	Receiver's instance variables: 
		decoratedCommand: 	a StPlaygroundDoItCommand
		iconProvider: 	a StPharoApplication
		iconName: 	#glamorousGo
		shortcutKey: 	nil
		displayStrategy: 	a CmUIDisableWhenCantBeRun
		positionStrategy: 	a CmUILeftPositionStrategy
		buildPresenterBlock: 	[ :specCommand | 
			aButtonClass new
				label: specC[..]
		presenter: 	a SpToolbarButtonPresenter


FullBlockClosure(BlockClosure)>>cull:
	Receiver: [ specCommand execute ]
	Arguments and temporary variables: 
		anArg: 	a SpToolbarButtonPresenter
	Receiver's instance variables: 
		outerContext: 	[ :specCommand | 
			aButtonClass new
				label: specCommand [..]
		compiledBlock: 	a CompiledBlock: [ specCommand execute ]
		numArgs: 	0
		receiver: 	a SpCommand(Do it)


SpMorphicToolbarButtonAdapter>>execute
	Receiver: a SpMorphicToolbarButtonAdapter
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpToolbarButtonMorph(319944704))
		announcer: 	nil
		model: 	a SpToolbarButtonPresenter
		widget: 	a SpToolbarButtonMorph(319944704)
		selector: 	nil
		owner: 	a SpToolbarButtonPresenter
		unsubscribed: 	false


SpToolbarButtonMorph(PluggableButtonMorph)>>performAction:
	Receiver: a SpToolbarButtonMorph(319944704)
	Arguments and temporary variables: 
		event: 	[(24.0@16.0) mouseUp 9212044 nil]
	Receiver's instance variables: 
		bounds: 	(0.0@5.0) corner: (45.0@39.0)
		owner: 	a Morph(13467904)
		submorphs: 	an Array(an AlignmentMorph(869548288))
		fullBounds: 	nil
		color: 	(Color r: 0.9012707722385142 g: 0.9012707722385142 b: 0.901270772238[..]
		extension: 	a MorphExtension (545772544) [balloonText]  [other:  (presenter [..]
		borderWidth: 	0
		borderColor: 	#simple
		model: 	a SpMorphicToolbarButtonAdapter
		label: 	'Do it'
		icon: 	Form(13x13x32)
		getIconSelector: 	#icon
		getStateSelector: 	#state
		actionSelector: 	#execute
		font: 	a LogicalFont
 familyName: 'Source Sans Pro'
 emphasis: nil
 pointSiz[..]
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	nil
		getFontSelector: 	nil
		labelMorph: 	a LabelMorph(424853504)'Do it'
		iconMorph: 	an ImageMorph(356841984)
		iconPosition: 	#top
		lastState: 	false
		badgeFont: 	nil
		badgeSelector: 	#badge


[:m |
		(m containsPoint: evt cursorPoint) ifTrue: [m enabled ifTrue: [ m performAction: evt ]]] in SpToolbarButtonMorph(PluggableButtonMorph)>>mouseUp:
	Receiver: a SpToolbarButtonMorph(319944704)
	Arguments and temporary variables: 
		evt: 	[(24.0@16.0) mouseUp 9212044 nil]
		all: 	an Array(a SpToolbarButtonMorph(319944704) a SpToolbarButtonMorph(5749[..]
		m: 	a SpToolbarButtonMorph(319944704)
	Receiver's instance variables: 
		bounds: 	(0.0@5.0) corner: (45.0@39.0)
		owner: 	a Morph(13467904)
		submorphs: 	an Array(an AlignmentMorph(869548288))
		fullBounds: 	nil
		color: 	(Color r: 0.9012707722385142 g: 0.9012707722385142 b: 0.901270772238[..]
		extension: 	a MorphExtension (545772544) [balloonText]  [other:  (presenter [..]
		borderWidth: 	0
		borderColor: 	#simple
		model: 	a SpMorphicToolbarButtonAdapter
		label: 	'Do it'
		icon: 	Form(13x13x32)
		getIconSelector: 	#icon
		getStateSelector: 	#state
		actionSelector: 	#execute
		font: 	a LogicalFont
 familyName: 'Source Sans Pro'
 emphasis: nil
 pointSiz[..]
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	nil
		getFontSelector: 	nil
		labelMorph: 	a LabelMorph(424853504)'Do it'
		iconMorph: 	an ImageMorph(356841984)
		iconPosition: 	#top
		lastState: 	false
		badgeFont: 	nil
		badgeSelector: 	#badge


Array(SequenceableCollection)>>do:
	Receiver: an Array(a SpToolbarButtonMorph(319944704) a SpToolbarButtonMorph(574995456) a SpToolb[..]
	Arguments and temporary variables: 
		aBlock: 	[:m |
		(m containsPoint: evt cursorPoint) ifTrue: [m enabled ifTru[..]
		index: 	1
	Receiver's instance variables: 
an Array(a SpToolbarButtonMorph(319944704) a SpToolbarButtonMorph(574995456) a SpToolb[..]

SpToolbarButtonMorph(PluggableButtonMorph)>>mouseUp:
	Receiver: a SpToolbarButtonMorph(319944704)
	Arguments and temporary variables: 
		evt: 	[(24.0@16.0) mouseUp 9212044 nil]
		all: 	an Array(a SpToolbarButtonMorph(319944704) a SpToolbarButtonMorph(5749[..]
	Receiver's instance variables: 
		bounds: 	(0.0@5.0) corner: (45.0@39.0)
		owner: 	a Morph(13467904)
		submorphs: 	an Array(an AlignmentMorph(869548288))
		fullBounds: 	nil
		color: 	(Color r: 0.9012707722385142 g: 0.9012707722385142 b: 0.901270772238[..]
		extension: 	a MorphExtension (545772544) [balloonText]  [other:  (presenter [..]
		borderWidth: 	0
		borderColor: 	#simple
		model: 	a SpMorphicToolbarButtonAdapter
		label: 	'Do it'
		icon: 	Form(13x13x32)
		getIconSelector: 	#icon
		getStateSelector: 	#state
		actionSelector: 	#execute
		font: 	a LogicalFont
 familyName: 'Source Sans Pro'
 emphasis: nil
 pointSiz[..]
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	nil
		getFontSelector: 	nil
		labelMorph: 	a LabelMorph(424853504)'Do it'
		iconMorph: 	an ImageMorph(356841984)
		iconPosition: 	#top
		lastState: 	false
		badgeFont: 	nil
		badgeSelector: 	#badge


SpToolbarButtonMorph(Morph)>>handleMouseUp:
	Receiver: a SpToolbarButtonMorph(319944704)
	Arguments and temporary variables: 
		anEvent: 	[(24.0@16.0) mouseUp 9212044 nil]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(0.0@5.0) corner: (45.0@39.0)
		owner: 	a Morph(13467904)
		submorphs: 	an Array(an AlignmentMorph(869548288))
		fullBounds: 	nil
		color: 	(Color r: 0.9012707722385142 g: 0.9012707722385142 b: 0.901270772238[..]
		extension: 	a MorphExtension (545772544) [balloonText]  [other:  (presenter [..]
		borderWidth: 	0
		borderColor: 	#simple
		model: 	a SpMorphicToolbarButtonAdapter
		label: 	'Do it'
		icon: 	Form(13x13x32)
		getIconSelector: 	#icon
		getStateSelector: 	#state
		actionSelector: 	#execute
		font: 	a LogicalFont
 familyName: 'Source Sans Pro'
 emphasis: nil
 pointSiz[..]
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	nil
		getFontSelector: 	nil
		labelMorph: 	a LabelMorph(424853504)'Do it'
		iconMorph: 	an ImageMorph(356841984)
		iconPosition: 	#top
		lastState: 	false
		badgeFont: 	nil
		badgeSelector: 	#badge


MouseButtonEvent>>sentTo:
	Receiver: [(24.0@16.0) mouseUp 9212044 nil]
	Arguments and temporary variables: 
		anObject: 	a SpToolbarButtonMorph(319944704)
	Receiver's instance variables: 
		timeStamp: 	9212044
		source: 	a HandMorph(337424384)
		windowIndex: 	nil
		type: 	#mouseUp
		buttons: 	0
		position: 	(24.0@16.0)
		handler: 	nil
		wasHandled: 	true
		whichButton: 	4


SpToolbarButtonMorph(Morph)>>handleEvent:
	Receiver: a SpToolbarButtonMorph(319944704)
	Arguments and temporary variables: 
		anEvent: 	[(24.0@16.0) mouseUp 9212044 nil]
	Receiver's instance variables: 
		bounds: 	(0.0@5.0) corner: (45.0@39.0)
		owner: 	a Morph(13467904)
		submorphs: 	an Array(an AlignmentMorph(869548288))
		fullBounds: 	nil
		color: 	(Color r: 0.9012707722385142 g: 0.9012707722385142 b: 0.901270772238[..]
		extension: 	a MorphExtension (545772544) [balloonText]  [other:  (presenter [..]
		borderWidth: 	0
		borderColor: 	#simple
		model: 	a SpMorphicToolbarButtonAdapter
		label: 	'Do it'
		icon: 	Form(13x13x32)
		getIconSelector: 	#icon
		getStateSelector: 	#state
		actionSelector: 	#execute
		font: 	a LogicalFont
 familyName: 'Source Sans Pro'
 emphasis: nil
 pointSiz[..]
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	nil
		getFontSelector: 	nil
		labelMorph: 	a LabelMorph(424853504)'Do it'
		iconMorph: 	an ImageMorph(356841984)
		iconPosition: 	#top
		lastState: 	false
		badgeFont: 	nil
		badgeSelector: 	#badge


SpToolbarButtonMorph(Morph)>>handleFocusEvent:
	Receiver: a SpToolbarButtonMorph(319944704)
	Arguments and temporary variables: 
		anEvent: 	[(24.0@16.0) mouseUp 9212044 nil]
	Receiver's instance variables: 
		bounds: 	(0.0@5.0) corner: (45.0@39.0)
		owner: 	a Morph(13467904)
		submorphs: 	an Array(an AlignmentMorph(869548288))
		fullBounds: 	nil
		color: 	(Color r: 0.9012707722385142 g: 0.9012707722385142 b: 0.901270772238[..]
		extension: 	a MorphExtension (545772544) [balloonText]  [other:  (presenter [..]
		borderWidth: 	0
		borderColor: 	#simple
		model: 	a SpMorphicToolbarButtonAdapter
		label: 	'Do it'
		icon: 	Form(13x13x32)
		getIconSelector: 	#icon
		getStateSelector: 	#state
		actionSelector: 	#execute
		font: 	a LogicalFont
 familyName: 'Source Sans Pro'
 emphasis: nil
 pointSiz[..]
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	nil
		getFontSelector: 	nil
		labelMorph: 	a LabelMorph(424853504)'Do it'
		iconMorph: 	an ImageMorph(356841984)
		iconPosition: 	#top
		lastState: 	false
		badgeFont: 	nil
		badgeSelector: 	#badge


[
		result := focusHolder handleFocusEvent: transformedEvent.
	] in HandMorph>>sendFocusEvent:to:clear:
	Receiver: a HandMorph(337424384)
	Arguments and temporary variables: 
		anEvent: 	[(543@334) mouseUp 9212044 nil]
		focusHolder: 	a SpToolbarButtonMorph(319944704)
		aBlock: 	[self mouseFocus: nil]
		w: 	a WorldMorph(341720576) [world]
		transformedEvent: 	[(24.0@16.0) mouseUp 9212044 nil]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(543@334.0) corner: (559@350.0)
		owner: 	a WorldMorph(341720576) [world]
		submorphs: 	#()
		fullBounds: 	(543@334.0) corner: (559@350.0)
		color: 	Color blue
		extension: 	a MorphExtension (370611968)
		mouseFocus: 	nil
		keyboardFocus: 	a RubEditingArea(189250304)
		eventListeners: 	nil
		mouseListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(543@334) mouseUp 9212044 nil]
		targetOffset: 	(24.0@11.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	true
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 0 0 0 0 0 nil nil)
		captureBlock: 	nil
		recentModifiers: 	0
		pendingEventQueue: 	WaitfreeQueue with 0 items
		supressNextKeyPress: 	false


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
		result := focusHolder handleFocusEvent: transformedEvent.
	]
	Arguments and temporary variables: 
		exception: 	Error
		handlerAction: 	[ :ex |
			ActiveWorld := priorWorld.
			ex pass ]
	Receiver's instance variables: 
		outerContext: 	HandMorph>>sendFocusEvent:to:clear:
		compiledBlock: 	a CompiledBlock: [
		result := focusHolder handleFocusEvent:[..]
		numArgs: 	0
		receiver: 	a HandMorph(337424384)


WorldMorph>>becomeActiveDuring:
	Receiver: a WorldMorph(341720576) [world]
	Arguments and temporary variables: 
		aBlock: 	[
		result := focusHolder handleFocusEvent: transformedEvent.
	]
		priorWorld: 	a WorldMorph(341720576) [world]
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1728@1080)
		owner: 	nil
		submorphs: 	an Array(a MenubarMorph(112886016) a TaskbarMorph(279458560) a S[..]
		fullBounds: 	(0@0) corner: (1728@1080)
		color: 	(Color r: 0.9403714565004888 g: 0.9403714565004888 b: 0.940371456500[..]
		extension: 	a MorphExtension (1012946432) [other:  (dragEnabled -> true) (dr[..]
		borderWidth: 	0
		borderColor: 	(Color r: 0.8611925708699902 g: 1.0 b: 0.7223851417399805 alph[..]
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil


HandMorph>>sendFocusEvent:to:clear:
	Receiver: a HandMorph(337424384)
	Arguments and temporary variables: 
		result: 	nil
		anEvent: 	[(543@334) mouseUp 9212044 nil]
		focusHolder: 	a SpToolbarButtonMorph(319944704)
		aBlock: 	[self mouseFocus: nil]
		w: 	a WorldMorph(341720576) [world]
		transformedEvent: 	[(24.0@16.0) mouseUp 9212044 nil]
	Receiver's instance variables: 
		bounds: 	(543@334.0) corner: (559@350.0)
		owner: 	a WorldMorph(341720576) [world]
		submorphs: 	#()
		fullBounds: 	(543@334.0) corner: (559@350.0)
		color: 	Color blue
		extension: 	a MorphExtension (370611968)
		mouseFocus: 	nil
		keyboardFocus: 	a RubEditingArea(189250304)
		eventListeners: 	nil
		mouseListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(543@334) mouseUp 9212044 nil]
		targetOffset: 	(24.0@11.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	true
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 0 0 0 0 0 nil nil)
		captureBlock: 	nil
		recentModifiers: 	0
		pendingEventQueue: 	WaitfreeQueue with 0 items
		supressNextKeyPress: 	false


HandMorph>>sendEvent:focus:clear:
	Receiver: a HandMorph(337424384)
	Arguments and temporary variables: 
		anEvent: 	[(543@334) mouseUp 9212044 nil]
		focusHolder: 	a SpToolbarButtonMorph(319944704)
		aBlock: 	[self mouseFocus: nil]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(543@334.0) corner: (559@350.0)
		owner: 	a WorldMorph(341720576) [world]
		submorphs: 	#()
		fullBounds: 	(543@334.0) corner: (559@350.0)
		color: 	Color blue
		extension: 	a MorphExtension (370611968)
		mouseFocus: 	nil
		keyboardFocus: 	a RubEditingArea(189250304)
		eventListeners: 	nil
		mouseListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(543@334) mouseUp 9212044 nil]
		targetOffset: 	(24.0@11.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	true
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 0 0 0 0 0 nil nil)
		captureBlock: 	nil
		recentModifiers: 	0
		pendingEventQueue: 	WaitfreeQueue with 0 items
		supressNextKeyPress: 	false


HandMorph>>sendMouseEvent:
	Receiver: a HandMorph(337424384)
	Arguments and temporary variables: 
		anEvent: 	[(543@334) mouseUp 9212044 nil]
	Receiver's instance variables: 
		bounds: 	(543@334.0) corner: (559@350.0)
		owner: 	a WorldMorph(341720576) [world]
		submorphs: 	#()
		fullBounds: 	(543@334.0) corner: (559@350.0)
		color: 	Color blue
		extension: 	a MorphExtension (370611968)
		mouseFocus: 	nil
		keyboardFocus: 	a RubEditingArea(189250304)
		eventListeners: 	nil
		mouseListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(543@334) mouseUp 9212044 nil]
		targetOffset: 	(24.0@11.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	true
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 0 0 0 0 0 nil nil)
		captureBlock: 	nil
		recentModifiers: 	0
		pendingEventQueue: 	WaitfreeQueue with 0 items
		supressNextKeyPress: 	false


HandMorph>>handleEvent:
	Receiver: a HandMorph(337424384)
	Arguments and temporary variables: 
		anEvent: 	[(543@334) mouseUp 9212044 nil]
		evt: 	[(543@334) mouseUp 9212044 nil]
	Receiver's instance variables: 
		bounds: 	(543@334.0) corner: (559@350.0)
		owner: 	a WorldMorph(341720576) [world]
		submorphs: 	#()
		fullBounds: 	(543@334.0) corner: (559@350.0)
		color: 	Color blue
		extension: 	a MorphExtension (370611968)
		mouseFocus: 	nil
		keyboardFocus: 	a RubEditingArea(189250304)
		eventListeners: 	nil
		mouseListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(543@334) mouseUp 9212044 nil]
		targetOffset: 	(24.0@11.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	true
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 0 0 0 0 0 nil nil)
		captureBlock: 	nil
		recentModifiers: 	0
		pendingEventQueue: 	WaitfreeQueue with 0 items
		supressNextKeyPress: 	false


[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil ]) ifTrue: [
			morphicWorld activeHand handleEvent: anEvent
		]
	] in OSWindowMorphicEventHandler>>dispatchMorphicEvent:
	Receiver: an OSWindowMorphicEventHandler
	Arguments and temporary variables: 
		anEvent: 	[(543@334) mouseUp 9212044 nil]
	Receiver's instance variables: 
		morphicWorld: 	a WorldMorph(341720576) [world]


WorldState>>runStepMethodsIn:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(341720576) [world]
		queue: 	WaitfreeQueue with 0 items
		nextInQueue: 	[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNo[..]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(337424384))
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap()
		lastStepTime: 	9145130
		lastStepMessage: 	nil
		alarms: 	a Heap(MorphicAlarm(#hideShow -> a RubCursor(898368768)))
		lastAlarmTime: 	9212037
		activeHand: 	a HandMorph(337424384)
		currentCursor: 	((CursorWithMask
	extent: (16@16)
	depth: 1
	fromArray: #(
	[..]
		worldRenderer: 	an OSWorldRenderer
		realWindowExtent: 	(1728@1080)
		deferredUIMessages: 	WaitfreeQueue with 0 items


WorldMorph>>runStepMethods
	Receiver: a WorldMorph(341720576) [world]
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1728@1080)
		owner: 	nil
		submorphs: 	an Array(a MenubarMorph(112886016) a TaskbarMorph(279458560) a S[..]
		fullBounds: 	(0@0) corner: (1728@1080)
		color: 	(Color r: 0.9403714565004888 g: 0.9403714565004888 b: 0.940371456500[..]
		extension: 	a MorphExtension (1012946432) [other:  (dragEnabled -> true) (dr[..]
		borderWidth: 	0
		borderColor: 	(Color r: 0.8611925708699902 g: 1.0 b: 0.7223851417399805 alph[..]
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil


WorldState>>doOneCycleFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(341720576) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(337424384))
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap()
		lastStepTime: 	9145130
		lastStepMessage: 	nil
		alarms: 	a Heap(MorphicAlarm(#hideShow -> a RubCursor(898368768)))
		lastAlarmTime: 	9212037
		activeHand: 	a HandMorph(337424384)
		currentCursor: 	((CursorWithMask
	extent: (16@16)
	depth: 1
	fromArray: #(
	[..]
		worldRenderer: 	an OSWorldRenderer
		realWindowExtent: 	(1728@1080)
		deferredUIMessages: 	WaitfreeQueue with 0 items


WorldMorph>>doOneCycleNow
	Receiver: a WorldMorph(341720576) [world]
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1728@1080)
		owner: 	nil
		submorphs: 	an Array(a MenubarMorph(112886016) a TaskbarMorph(279458560) a S[..]
		fullBounds: 	(0@0) corner: (1728@1080)
		color: 	(Color r: 0.9403714565004888 g: 0.9403714565004888 b: 0.940371456500[..]
		extension: 	a MorphExtension (1012946432) [other:  (dragEnabled -> true) (dr[..]
		borderWidth: 	0
		borderColor: 	(Color r: 0.8611925708699902 g: 1.0 b: 0.7223851417399805 alph[..]
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil


WorldMorph>>doOneCycle
	Receiver: a WorldMorph(341720576) [world]
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1728@1080)
		owner: 	nil
		submorphs: 	an Array(a MenubarMorph(112886016) a TaskbarMorph(279458560) a S[..]
		fullBounds: 	(0@0) corner: (1728@1080)
		color: 	(Color r: 0.9403714565004888 g: 0.9403714565004888 b: 0.940371456500[..]
		extension: 	a MorphExtension (1012946432) [other:  (dragEnabled -> true) (dr[..]
		borderWidth: 	0
		borderColor: 	(Color r: 0.8611925708699902 g: 1.0 b: 0.7223851417399805 alph[..]
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil


[
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMutex critical: [
			                     self extraWorldList ].
		extraWorldsToDraw do: [ :world | world doOneCycle ].

		(self currentWorld isNotNil and: [
			 (extraWorldsToDraw includes: self currentWorld) not ]) ifTrue: [
			self currentWorld doOneCycle ] ] in WorldMorph class>>doOneCycle
	Receiver: WorldMorph
	Arguments and temporary variables: 
		extraWorldsToDraw: 	#()
	Receiver's instance variables: 
		superclass: 	PasteUpMorph
		methodDict: 	a MethodDictionary(#acceptDroppingMorph:event:->WorldMorph>>#ac[..]
		format: 	65547
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		commentSourcePointer: 	nil
		subclasses: 	{AthensWorldMorph. OSWindowWorldMorph}
		name: 	#WorldMorph
		classPool: 	a Dictionary(#AllowDropFiles->nil #CursorOwnerWorld->a WorldMorp[..]
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Morphic-Core-Worlds'
		announcer: 	nil
		displayScaleFactor: 	1


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMutex critical: [
			  [..]
	Arguments and temporary variables: 
		aBlock: 	[
		self doInterCycleWait
	]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	WorldMorph class>>doOneCycle
		compiledBlock: 	a CompiledBlock: [
		| extraWorldsToDraw |
		extraWorldsToDr[..]
		numArgs: 	0
		receiver: 	WorldMorph



--- The full stack ---
UndefinedObject>>doesNotUnderstand: #new
GraphVisualizer>>initialize
GraphVisualizer class(Behavior)>>new
UndefinedObject>>DoIt
OCReceiverDoItSemanticScope(OCDoItSemanticScope)>>evaluateDoIt:
OpalCompiler>>evaluate
[
		self announcer announce: (SpCodeWillBeEvaluatedAnnouncement newContent: aString).
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionModel doItReceiver.
		result := receiver class compiler
			source: aString;
			context: self interactionModel doItContext;
			receiver: self interactionModel doItReceiver;
			requestor: self interactionModel;
			environment: self environment;
			failBlock:  [ 
				self announcer announce: (SpCodeEvaluationFailedAnnouncement newContent: aString).
				^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		self announcer announce: (SpCodeEvaluationSucceedAnnouncement newContent: aString).
		result ] in SpCodePresenter>>evaluate:onCompileError:onError:
FullBlockClosure(BlockClosure)>>on:do:
SpCodePresenter>>evaluate:onCompileError:onError:
StPlaygroundPagePresenter>>doEvaluateAndGo
StPlaygroundPagePresenter>>doEvaluateAllAndGo
StPlaygroundDoItCommand>>execute
SpCommand(CmCommandDecorator)>>execute
[ specCommand execute ] in [ :specCommand | 
			aButtonClass new
				label: specCommand name;
				help: specCommand description;
				in: [ :button | 
					specCommand hasIcon
						ifTrue: [ button icon: specCommand icon ] ];
				action: [ specCommand execute ];
				yourself ] in SpCommand>>configureAsButtonOfClass:
FullBlockClosure(BlockClosure)>>cull:
SpMorphicToolbarButtonAdapter>>execute
SpToolbarButtonMorph(PluggableButtonMorph)>>performAction:
[:m |
		(m containsPoint: evt cursorPoint) ifTrue: [m enabled ifTrue: [ m performAction: evt ]]] in SpToolbarButtonMorph(PluggableButtonMorph)>>mouseUp:
Array(SequenceableCollection)>>do:
SpToolbarButtonMorph(PluggableButtonMorph)>>mouseUp:
SpToolbarButtonMorph(Morph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
SpToolbarButtonMorph(Morph)>>handleEvent:
SpToolbarButtonMorph(Morph)>>handleFocusEvent:
[
		result := focusHolder handleFocusEvent: transformedEvent.
	] in HandMorph>>sendFocusEvent:to:clear:
FullBlockClosure(BlockClosure)>>on:do:
WorldMorph>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil ]) ifTrue: [
			morphicWorld activeHand handleEvent: anEvent
		]
	] in OSWindowMorphicEventHandler>>dispatchMorphicEvent:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycleNow
WorldMorph>>doOneCycle
[
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMutex critical: [
			                     self extraWorldList ].
		extraWorldsToDraw do: [ :world | world doOneCycle ].

		(self currentWorld isNotNil and: [
			 (extraWorldsToDraw includes: self currentWorld) not ]) ifTrue: [
			self currentWorld doOneCycle ] ] in WorldMorph class>>doOneCycle
FullBlockClosure(BlockClosure)>>ensure:
 - - - - - - - - - - - - - - -
			- - - - - - - - - - - - - - - - - -
WorldState class>>doDrawCycleWith:
WorldMorph class>>doOneCycle
MorphicRenderLoop>>doOneCycle
MorphicRenderLoop>>doOneCycleWhile:
[ MorphicRenderLoop new doOneCycleWhile: [ true ] ] in MorphicUIManager>>spawnNewProcess
[self value.
			"IMPORTANT: Do not step over next line of code. See method comments for details"
			Processor terminateRealActive] in FullBlockClosure(BlockClosure)>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
KeyNotFound: key #edges not found in Dictionary
13 November 2023 6:40:46.330386 pm

VM: Mac OS - arm64 - 1000 - CoInterpreter VMMaker-tonel.1 uuid: 902dd483-c0c4-0d00-86f2-0f880df24b96 Oct 23 2023
StackToRegisterMappingCogit VMMaker-tonel.1 uuid: 902dd483-c0c4-0d00-86f2-0f880df24b96 Oct 23 2023
v10.0.8 - Commit: b323c5fb - Date: 2023-10-20 16:02:07 -0400

Image: Pharo11.0.0 [Build information: Pharo-11.0.0+build.710.sha.ea28d8552cac85a7ce1e9c34ab1e7bd45f7b9910 (64 Bit)]

Dictionary>>errorKeyNotFound:
	Receiver: a Dictionary('nodes'->an Array(a Dictionary('id'->1 'label'->'Person' 'properties'->a [..]
	Arguments and temporary variables: 
		aKey: 	#edges
	Receiver's instance variables: 
		tally: 	2
		array: 	an Array('nodes'->an Array(a Dictionary('id'->1 'label'->'Person' 'p[..]


[self errorKeyNotFound: key] in Dictionary>>at:
	Receiver: a Dictionary('nodes'->an Array(a Dictionary('id'->1 'label'->'Person' 'properties'->a [..]
	Arguments and temporary variables: 
		key: 	#edges
	Receiver's instance variables: 
		tally: 	2
		array: 	an Array('nodes'->an Array(a Dictionary('id'->1 'label'->'Person' 'p[..]


Dictionary>>at:ifAbsent:
	Receiver: a Dictionary('nodes'->an Array(a Dictionary('id'->1 'label'->'Person' 'properties'->a [..]
	Arguments and temporary variables: 
		key: 	#edges
		aBlock: 	[self errorKeyNotFound: key]
	Receiver's instance variables: 
		tally: 	2
		array: 	an Array('nodes'->an Array(a Dictionary('id'->1 'label'->'Person' 'p[..]


Dictionary>>at:
	Receiver: a Dictionary('nodes'->an Array(a Dictionary('id'->1 'label'->'Person' 'properties'->a [..]
	Arguments and temporary variables: 
		key: 	#edges
	Receiver's instance variables: 
		tally: 	2
		array: 	an Array('nodes'->an Array(a Dictionary('id'->1 'label'->'Person' 'p[..]


GraphVisualizer>>loadDataFromFile:
	Receiver: a GraphVisualizer
	Arguments and temporary variables: 
		aFilePath: 	'/Users/ryanperez/Documents/GitHub/pp-rep2533/project/src/data/t[..]
		file: 	File @ /Users/ryanperez/Documents/GitHub/pp-rep2533/project/src/data/[..]
		contents: 	'{
    "nodes": [
      {"id": 1, "label": "Person", "properties"[..]
	Receiver's instance variables: 
		view: 	a RSCanvas
		nodes: 	an Array(a Dictionary('id'->1 'label'->'Person' 'properties'->a Dict[..]
		edges: 	nil
		nodesMap: 	a Dictionary()


GraphVisualizer>>visualizeGraphFromFile:
	Receiver: a GraphVisualizer
	Arguments and temporary variables: 
		aFilePath: 	'/Users/ryanperez/Documents/GitHub/pp-rep2533/project/src/data/t[..]
	Receiver's instance variables: 
		view: 	a RSCanvas
		nodes: 	an Array(a Dictionary('id'->1 'label'->'Person' 'properties'->a Dict[..]
		edges: 	nil
		nodesMap: 	a Dictionary()


UndefinedObject>>DoIt
	Receiver: nil
	Arguments and temporary variables: 
		visualizer: 	a GraphVisualizer
	Receiver's instance variables: 
nil

OCReceiverDoItSemanticScope(OCDoItSemanticScope)>>evaluateDoIt:
	Receiver: an OCReceiverDoItSemanticScope
	Arguments and temporary variables: 
		doItMethod: 	UndefinedObject>>#DoIt
	Receiver's instance variables: 
		outerScope: 	nil
		targetReceiver: 	nil


OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
		doItMethod: 	UndefinedObject>>#DoIt
	Receiver's instance variables: 
		ast: 	DoIt

	| visualizer |
	visualizer := GraphVisualizer new.
	^ visualize[..]
		source: 	a ReadStream
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil


[
		self announcer announce: (SpCodeWillBeEvaluatedAnnouncement newContent: aString).
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionModel doItReceiver.
		result := receiver class compiler
			source: aString;
			context: self interactionModel doItContext;
			receiver: self interactionModel doItReceiver;
			requestor: self interactionModel;
			environment: self environment;
			failBlock:  [ 
				self announcer announce: (SpCodeEvaluationFailedAnnouncement newContent: aString).
				^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		self announcer announce: (SpCodeEvaluationSucceedAnnouncement newContent: aString).
		result ] in SpCodePresenter>>evaluate:onCompileError:onError:
	Receiver: a SpCodePresenter
	Arguments and temporary variables: 
		aString: 	'| visualizer |
visualizer := GraphVisualizer new.
visualizer visu[..]
		compileErrorBlock: 	[ ^ self ]
		errorBlock: 	[ :e | e pass ]
		receiver: 	nil
		result: 	nil
		oldBindings: 	a Dictionary()
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicCodeAdapter)
		announcer: 	an Announcer
		owner: 	a StPlaygroundPagePresenter
		adapter: 	a SpMorphicCodeAdapter
		needRebuild: 	true
		eventHandler: 	a SpEventHandler
		application: 	nil
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ a KMCategory ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Code' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpAbstractWidgetLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		borderWidth: 	an ObservableValueHolder[ nil ]
		borderColor: 	an ObservableValueHolder[ nil ]
		dragEnabled: 	an ObservableValueHolder[ false ]
		dropEnabled: 	an ObservableValueHolder[ false ]
		color: 	an ObservableValueHolder[ nil ]
		help: 	an ObservableValueHolder[ nil ]
		enabled: 	an ObservableValueHolder[ true ]
		wantsDrop: 	an ObservableValueHolder[ [ :transfer | self dropEnabled ] ]
		acceptDrop: 	an ObservableValueHolder[ [ :transfer | ] ]
		deferredActions: 	nil
		hasUnacceptedEdits: 	an ObservableValueHolder[ false ]
		selection: 	an ObservableValueHolder[ (1 to: 159) ]
		wantsVisualFeedback: 	an ObservableValueHolder[ true ]
		askBeforeDiscardingEdits: 	an ObservableValueHolder[ true ]
		text: 	an ObservableValueHolder[ '| visualizer |
visualizer := GraphVisualiz[..]
		actionToPerform: 	an ObservableValueHolder[ [ :txt |  ] ]
		readSelection: 	an ObservableValueHolder[ [ selection ] ]
		placeholder: 	an ObservableValueHolder[ '' ]
		contextMenu: 	an ObservableValueHolder[ [ (self menuActionsFor: text) asMenu[..]
		scrollValue: 	an ObservableValueHolder[ (0@0) ]
		editionContextMenu: 	an ObservableValueHolder[ true ]
		editable: 	an ObservableValueHolder[ true ]
		wrapWord: 	an ObservableValueHolder[ true ]
		undoRedoHistory: 	true
		wrapScrollBars: 	true
		propagateNaturalHeight: 	false
		propagateNaturalWidth: 	false
		scrollBarStyles: 	#()
		syntaxHighlight: 	an ObservableValueHolder[ true ]
		smartCharacters: 	an ObservableValueHolder[ true ]
		lineNumbers: 	an ObservableValueHolder[ true ]
		interactionModel: 	an ObservableValueHolder[ a StPlaygroundInteractionModel ]
		overrideContextMenu: 	true
		submitBlock: 	nil
		resetBlock: 	nil
		environment: 	nil
		systemNavigation: 	nil
		syntaxHighlightTheme: 	an ObservableValueHolder[ nil ]


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
		self announcer announce: (SpCodeWillBeEvaluatedAnnouncement newContent: aString).
[..]
	Arguments and temporary variables: 
		exception: 	Error
		handlerAction: 	[ :e |
		self announcer announce: (SpCodeEvaluationFailedAnn[..]
	Receiver's instance variables: 
		outerContext: 	SpCodePresenter>>evaluate:onCompileError:onError:
		compiledBlock: 	a CompiledBlock: [
		self announcer announce: (SpCodeWillBeE[..]
		numArgs: 	0
		receiver: 	a SpCodePresenter


SpCodePresenter>>evaluate:onCompileError:onError:
	Receiver: a SpCodePresenter
	Arguments and temporary variables: 
		receiver: 	nil
		result: 	nil
		oldBindings: 	a Dictionary()
		aString: 	'| visualizer |
visualizer := GraphVisualizer new.
visualizer visu[..]
		compileErrorBlock: 	[ ^ self ]
		errorBlock: 	[ :e | e pass ]
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicCodeAdapter)
		announcer: 	an Announcer
		owner: 	a StPlaygroundPagePresenter
		adapter: 	a SpMorphicCodeAdapter
		needRebuild: 	true
		eventHandler: 	a SpEventHandler
		application: 	nil
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ a KMCategory ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Code' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpAbstractWidgetLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		borderWidth: 	an ObservableValueHolder[ nil ]
		borderColor: 	an ObservableValueHolder[ nil ]
		dragEnabled: 	an ObservableValueHolder[ false ]
		dropEnabled: 	an ObservableValueHolder[ false ]
		color: 	an ObservableValueHolder[ nil ]
		help: 	an ObservableValueHolder[ nil ]
		enabled: 	an ObservableValueHolder[ true ]
		wantsDrop: 	an ObservableValueHolder[ [ :transfer | self dropEnabled ] ]
		acceptDrop: 	an ObservableValueHolder[ [ :transfer | ] ]
		deferredActions: 	nil
		hasUnacceptedEdits: 	an ObservableValueHolder[ false ]
		selection: 	an ObservableValueHolder[ (1 to: 159) ]
		wantsVisualFeedback: 	an ObservableValueHolder[ true ]
		askBeforeDiscardingEdits: 	an ObservableValueHolder[ true ]
		text: 	an ObservableValueHolder[ '| visualizer |
visualizer := GraphVisualiz[..]
		actionToPerform: 	an ObservableValueHolder[ [ :txt |  ] ]
		readSelection: 	an ObservableValueHolder[ [ selection ] ]
		placeholder: 	an ObservableValueHolder[ '' ]
		contextMenu: 	an ObservableValueHolder[ [ (self menuActionsFor: text) asMenu[..]
		scrollValue: 	an ObservableValueHolder[ (0@0) ]
		editionContextMenu: 	an ObservableValueHolder[ true ]
		editable: 	an ObservableValueHolder[ true ]
		wrapWord: 	an ObservableValueHolder[ true ]
		undoRedoHistory: 	true
		wrapScrollBars: 	true
		propagateNaturalHeight: 	false
		propagateNaturalWidth: 	false
		scrollBarStyles: 	#()
		syntaxHighlight: 	an ObservableValueHolder[ true ]
		smartCharacters: 	an ObservableValueHolder[ true ]
		lineNumbers: 	an ObservableValueHolder[ true ]
		interactionModel: 	an ObservableValueHolder[ a StPlaygroundInteractionModel ]
		overrideContextMenu: 	true
		submitBlock: 	nil
		resetBlock: 	nil
		environment: 	nil
		systemNavigation: 	nil
		syntaxHighlightTheme: 	an ObservableValueHolder[ nil ]


StPlaygroundPagePresenter>>doEvaluateAndGo
	Receiver: a StPlaygroundPagePresenter
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicBoxAdapter)
		announcer: 	an Announcer
		owner: 	a SpMillerColumnPresenter
		adapter: 	a SpMorphicBoxAdapter
		needRebuild: 	true
		eventHandler: 	nil
		application: 	a StPharoApplication
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ nil ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Untitled window' ]
		additionalSubpresentersMap: 	a Dictionary()
		layout: 	an ObservableValueHolder[ a SpBoxLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		text: 	a SpCodePresenter
		toolbar: 	a SpToolbarPresenter
		statusbar: 	a SpPresenter
		lineLabel: 	a SpLabelPresenter
		toggleLineNumberButton: 	a SpToggleButtonPresenter
		page: 	a StPlaygroundPage
		activationBlock: 	[ :selection |
		self changeSelection: selection from: new[..]


StPlaygroundPagePresenter>>doEvaluateAllAndGo
	Receiver: a StPlaygroundPagePresenter
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicBoxAdapter)
		announcer: 	an Announcer
		owner: 	a SpMillerColumnPresenter
		adapter: 	a SpMorphicBoxAdapter
		needRebuild: 	true
		eventHandler: 	nil
		application: 	a StPharoApplication
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ nil ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Untitled window' ]
		additionalSubpresentersMap: 	a Dictionary()
		layout: 	an ObservableValueHolder[ a SpBoxLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		text: 	a SpCodePresenter
		toolbar: 	a SpToolbarPresenter
		statusbar: 	a SpPresenter
		lineLabel: 	a SpLabelPresenter
		toggleLineNumberButton: 	a SpToggleButtonPresenter
		page: 	a StPlaygroundPage
		activationBlock: 	[ :selection |
		self changeSelection: selection from: new[..]


StPlaygroundDoItCommand>>execute
	Receiver: a StPlaygroundDoItCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		context: 	a StPlaygroundPagePresenter
		basicName: 	'Do it'
		basicDescription: 	'Do it all and inspect.'


SpCommand(CmCommandDecorator)>>execute
	Receiver: a SpCommand(Do it)
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a StPlaygroundDoItCommand
		iconProvider: 	a StPharoApplication
		iconName: 	#glamorousGo
		shortcutKey: 	nil
		displayStrategy: 	a CmUIDisableWhenCantBeRun
		positionStrategy: 	a CmUILeftPositionStrategy
		buildPresenterBlock: 	[ :specCommand | 
			aButtonClass new
				label: specC[..]
		presenter: 	a SpToolbarButtonPresenter


[ specCommand execute ] in [ :specCommand | 
			aButtonClass new
				label: specCommand name;
				help: specCommand description;
				in: [ :button | 
					specCommand hasIcon
						ifTrue: [ button icon: specCommand icon ] ];
				action: [ specCommand execute ];
				yourself ] in SpCommand>>configureAsButtonOfClass:
	Receiver: a SpCommand(Do it)
	Arguments and temporary variables: 
		aButtonClass: 	nil
		specCommand: 	a SpCommand(Do it)
	Receiver's instance variables: 
		decoratedCommand: 	a StPlaygroundDoItCommand
		iconProvider: 	a StPharoApplication
		iconName: 	#glamorousGo
		shortcutKey: 	nil
		displayStrategy: 	a CmUIDisableWhenCantBeRun
		positionStrategy: 	a CmUILeftPositionStrategy
		buildPresenterBlock: 	[ :specCommand | 
			aButtonClass new
				label: specC[..]
		presenter: 	a SpToolbarButtonPresenter


FullBlockClosure(BlockClosure)>>cull:
	Receiver: [ specCommand execute ]
	Arguments and temporary variables: 
		anArg: 	a SpToolbarButtonPresenter
	Receiver's instance variables: 
		outerContext: 	[ :specCommand | 
			aButtonClass new
				label: specCommand [..]
		compiledBlock: 	a CompiledBlock: [ specCommand execute ]
		numArgs: 	0
		receiver: 	a SpCommand(Do it)


SpMorphicToolbarButtonAdapter>>execute
	Receiver: a SpMorphicToolbarButtonAdapter
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpToolbarButtonMorph(319944704))
		announcer: 	nil
		model: 	a SpToolbarButtonPresenter
		widget: 	a SpToolbarButtonMorph(319944704)
		selector: 	nil
		owner: 	a SpToolbarButtonPresenter
		unsubscribed: 	false


SpToolbarButtonMorph(PluggableButtonMorph)>>performAction:
	Receiver: a SpToolbarButtonMorph(319944704)
	Arguments and temporary variables: 
		event: 	[(21.0@19.0) mouseUp 9364455 nil]
	Receiver's instance variables: 
		bounds: 	(0.0@5.0) corner: (45.0@39.0)
		owner: 	a Morph(13467904)
		submorphs: 	an Array(an AlignmentMorph(869548288))
		fullBounds: 	nil
		color: 	(Color r: 0.9012707722385142 g: 0.9012707722385142 b: 0.901270772238[..]
		extension: 	a MorphExtension (545772544) [balloonText]  [other:  (presenter [..]
		borderWidth: 	0
		borderColor: 	#simple
		model: 	a SpMorphicToolbarButtonAdapter
		label: 	'Do it'
		icon: 	Form(13x13x32)
		getIconSelector: 	#icon
		getStateSelector: 	#state
		actionSelector: 	#execute
		font: 	a LogicalFont
 familyName: 'Source Sans Pro'
 emphasis: nil
 pointSiz[..]
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	nil
		getFontSelector: 	nil
		labelMorph: 	a LabelMorph(424853504)'Do it'
		iconMorph: 	an ImageMorph(356841984)
		iconPosition: 	#top
		lastState: 	false
		badgeFont: 	nil
		badgeSelector: 	#badge


[:m |
		(m containsPoint: evt cursorPoint) ifTrue: [m enabled ifTrue: [ m performAction: evt ]]] in SpToolbarButtonMorph(PluggableButtonMorph)>>mouseUp:
	Receiver: a SpToolbarButtonMorph(319944704)
	Arguments and temporary variables: 
		evt: 	[(21.0@19.0) mouseUp 9364455 nil]
		all: 	an Array(a SpToolbarButtonMorph(319944704) a SpToolbarButtonMorph(5749[..]
		m: 	a SpToolbarButtonMorph(319944704)
	Receiver's instance variables: 
		bounds: 	(0.0@5.0) corner: (45.0@39.0)
		owner: 	a Morph(13467904)
		submorphs: 	an Array(an AlignmentMorph(869548288))
		fullBounds: 	nil
		color: 	(Color r: 0.9012707722385142 g: 0.9012707722385142 b: 0.901270772238[..]
		extension: 	a MorphExtension (545772544) [balloonText]  [other:  (presenter [..]
		borderWidth: 	0
		borderColor: 	#simple
		model: 	a SpMorphicToolbarButtonAdapter
		label: 	'Do it'
		icon: 	Form(13x13x32)
		getIconSelector: 	#icon
		getStateSelector: 	#state
		actionSelector: 	#execute
		font: 	a LogicalFont
 familyName: 'Source Sans Pro'
 emphasis: nil
 pointSiz[..]
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	nil
		getFontSelector: 	nil
		labelMorph: 	a LabelMorph(424853504)'Do it'
		iconMorph: 	an ImageMorph(356841984)
		iconPosition: 	#top
		lastState: 	false
		badgeFont: 	nil
		badgeSelector: 	#badge


Array(SequenceableCollection)>>do:
	Receiver: an Array(a SpToolbarButtonMorph(319944704) a SpToolbarButtonMorph(574995456) a SpToolb[..]
	Arguments and temporary variables: 
		aBlock: 	[:m |
		(m containsPoint: evt cursorPoint) ifTrue: [m enabled ifTru[..]
		index: 	1
	Receiver's instance variables: 
an Array(a SpToolbarButtonMorph(319944704) a SpToolbarButtonMorph(574995456) a SpToolb[..]

SpToolbarButtonMorph(PluggableButtonMorph)>>mouseUp:
	Receiver: a SpToolbarButtonMorph(319944704)
	Arguments and temporary variables: 
		evt: 	[(21.0@19.0) mouseUp 9364455 nil]
		all: 	an Array(a SpToolbarButtonMorph(319944704) a SpToolbarButtonMorph(5749[..]
	Receiver's instance variables: 
		bounds: 	(0.0@5.0) corner: (45.0@39.0)
		owner: 	a Morph(13467904)
		submorphs: 	an Array(an AlignmentMorph(869548288))
		fullBounds: 	nil
		color: 	(Color r: 0.9012707722385142 g: 0.9012707722385142 b: 0.901270772238[..]
		extension: 	a MorphExtension (545772544) [balloonText]  [other:  (presenter [..]
		borderWidth: 	0
		borderColor: 	#simple
		model: 	a SpMorphicToolbarButtonAdapter
		label: 	'Do it'
		icon: 	Form(13x13x32)
		getIconSelector: 	#icon
		getStateSelector: 	#state
		actionSelector: 	#execute
		font: 	a LogicalFont
 familyName: 'Source Sans Pro'
 emphasis: nil
 pointSiz[..]
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	nil
		getFontSelector: 	nil
		labelMorph: 	a LabelMorph(424853504)'Do it'
		iconMorph: 	an ImageMorph(356841984)
		iconPosition: 	#top
		lastState: 	false
		badgeFont: 	nil
		badgeSelector: 	#badge


SpToolbarButtonMorph(Morph)>>handleMouseUp:
	Receiver: a SpToolbarButtonMorph(319944704)
	Arguments and temporary variables: 
		anEvent: 	[(21.0@19.0) mouseUp 9364455 nil]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(0.0@5.0) corner: (45.0@39.0)
		owner: 	a Morph(13467904)
		submorphs: 	an Array(an AlignmentMorph(869548288))
		fullBounds: 	nil
		color: 	(Color r: 0.9012707722385142 g: 0.9012707722385142 b: 0.901270772238[..]
		extension: 	a MorphExtension (545772544) [balloonText]  [other:  (presenter [..]
		borderWidth: 	0
		borderColor: 	#simple
		model: 	a SpMorphicToolbarButtonAdapter
		label: 	'Do it'
		icon: 	Form(13x13x32)
		getIconSelector: 	#icon
		getStateSelector: 	#state
		actionSelector: 	#execute
		font: 	a LogicalFont
 familyName: 'Source Sans Pro'
 emphasis: nil
 pointSiz[..]
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	nil
		getFontSelector: 	nil
		labelMorph: 	a LabelMorph(424853504)'Do it'
		iconMorph: 	an ImageMorph(356841984)
		iconPosition: 	#top
		lastState: 	false
		badgeFont: 	nil
		badgeSelector: 	#badge


MouseButtonEvent>>sentTo:
	Receiver: [(21.0@19.0) mouseUp 9364455 nil]
	Arguments and temporary variables: 
		anObject: 	a SpToolbarButtonMorph(319944704)
	Receiver's instance variables: 
		timeStamp: 	9364455
		source: 	a HandMorph(337424384)
		windowIndex: 	nil
		type: 	#mouseUp
		buttons: 	0
		position: 	(21.0@19.0)
		handler: 	nil
		wasHandled: 	true
		whichButton: 	4


SpToolbarButtonMorph(Morph)>>handleEvent:
	Receiver: a SpToolbarButtonMorph(319944704)
	Arguments and temporary variables: 
		anEvent: 	[(21.0@19.0) mouseUp 9364455 nil]
	Receiver's instance variables: 
		bounds: 	(0.0@5.0) corner: (45.0@39.0)
		owner: 	a Morph(13467904)
		submorphs: 	an Array(an AlignmentMorph(869548288))
		fullBounds: 	nil
		color: 	(Color r: 0.9012707722385142 g: 0.9012707722385142 b: 0.901270772238[..]
		extension: 	a MorphExtension (545772544) [balloonText]  [other:  (presenter [..]
		borderWidth: 	0
		borderColor: 	#simple
		model: 	a SpMorphicToolbarButtonAdapter
		label: 	'Do it'
		icon: 	Form(13x13x32)
		getIconSelector: 	#icon
		getStateSelector: 	#state
		actionSelector: 	#execute
		font: 	a LogicalFont
 familyName: 'Source Sans Pro'
 emphasis: nil
 pointSiz[..]
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	nil
		getFontSelector: 	nil
		labelMorph: 	a LabelMorph(424853504)'Do it'
		iconMorph: 	an ImageMorph(356841984)
		iconPosition: 	#top
		lastState: 	false
		badgeFont: 	nil
		badgeSelector: 	#badge


SpToolbarButtonMorph(Morph)>>handleFocusEvent:
	Receiver: a SpToolbarButtonMorph(319944704)
	Arguments and temporary variables: 
		anEvent: 	[(21.0@19.0) mouseUp 9364455 nil]
	Receiver's instance variables: 
		bounds: 	(0.0@5.0) corner: (45.0@39.0)
		owner: 	a Morph(13467904)
		submorphs: 	an Array(an AlignmentMorph(869548288))
		fullBounds: 	nil
		color: 	(Color r: 0.9012707722385142 g: 0.9012707722385142 b: 0.901270772238[..]
		extension: 	a MorphExtension (545772544) [balloonText]  [other:  (presenter [..]
		borderWidth: 	0
		borderColor: 	#simple
		model: 	a SpMorphicToolbarButtonAdapter
		label: 	'Do it'
		icon: 	Form(13x13x32)
		getIconSelector: 	#icon
		getStateSelector: 	#state
		actionSelector: 	#execute
		font: 	a LogicalFont
 familyName: 'Source Sans Pro'
 emphasis: nil
 pointSiz[..]
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	nil
		getFontSelector: 	nil
		labelMorph: 	a LabelMorph(424853504)'Do it'
		iconMorph: 	an ImageMorph(356841984)
		iconPosition: 	#top
		lastState: 	false
		badgeFont: 	nil
		badgeSelector: 	#badge


[
		result := focusHolder handleFocusEvent: transformedEvent.
	] in HandMorph>>sendFocusEvent:to:clear:
	Receiver: a HandMorph(337424384)
	Arguments and temporary variables: 
		anEvent: 	[(484@177) mouseUp 9364455 nil]
		focusHolder: 	a SpToolbarButtonMorph(319944704)
		aBlock: 	[self mouseFocus: nil]
		w: 	a WorldMorph(341720576) [world]
		transformedEvent: 	[(21.0@19.0) mouseUp 9364455 nil]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(484@177.0) corner: (500@193.0)
		owner: 	a WorldMorph(341720576) [world]
		submorphs: 	#()
		fullBounds: 	(484@177.0) corner: (500@193.0)
		color: 	Color blue
		extension: 	a MorphExtension (370611968)
		mouseFocus: 	nil
		keyboardFocus: 	a RubEditingArea(189250304)
		eventListeners: 	nil
		mouseListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(484@177) mouseUp 9364455 nil]
		targetOffset: 	(21.0@14.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 0 0 0 0 0 nil nil)
		captureBlock: 	nil
		recentModifiers: 	0
		pendingEventQueue: 	WaitfreeQueue with 0 items
		supressNextKeyPress: 	false


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
		result := focusHolder handleFocusEvent: transformedEvent.
	]
	Arguments and temporary variables: 
		exception: 	Error
		handlerAction: 	[ :ex |
			ActiveWorld := priorWorld.
			ex pass ]
	Receiver's instance variables: 
		outerContext: 	HandMorph>>sendFocusEvent:to:clear:
		compiledBlock: 	a CompiledBlock: [
		result := focusHolder handleFocusEvent:[..]
		numArgs: 	0
		receiver: 	a HandMorph(337424384)


WorldMorph>>becomeActiveDuring:
	Receiver: a WorldMorph(341720576) [world]
	Arguments and temporary variables: 
		aBlock: 	[
		result := focusHolder handleFocusEvent: transformedEvent.
	]
		priorWorld: 	a WorldMorph(341720576) [world]
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1728@1080)
		owner: 	nil
		submorphs: 	an Array(a MenubarMorph(112886016) a TaskbarMorph(279458560) a S[..]
		fullBounds: 	(0@0) corner: (1728@1080)
		color: 	(Color r: 0.9403714565004888 g: 0.9403714565004888 b: 0.940371456500[..]
		extension: 	a MorphExtension (1012946432) [other:  (dragEnabled -> true) (dr[..]
		borderWidth: 	0
		borderColor: 	(Color r: 0.8611925708699902 g: 1.0 b: 0.7223851417399805 alph[..]
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil


HandMorph>>sendFocusEvent:to:clear:
	Receiver: a HandMorph(337424384)
	Arguments and temporary variables: 
		result: 	nil
		anEvent: 	[(484@177) mouseUp 9364455 nil]
		focusHolder: 	a SpToolbarButtonMorph(319944704)
		aBlock: 	[self mouseFocus: nil]
		w: 	a WorldMorph(341720576) [world]
		transformedEvent: 	[(21.0@19.0) mouseUp 9364455 nil]
	Receiver's instance variables: 
		bounds: 	(484@177.0) corner: (500@193.0)
		owner: 	a WorldMorph(341720576) [world]
		submorphs: 	#()
		fullBounds: 	(484@177.0) corner: (500@193.0)
		color: 	Color blue
		extension: 	a MorphExtension (370611968)
		mouseFocus: 	nil
		keyboardFocus: 	a RubEditingArea(189250304)
		eventListeners: 	nil
		mouseListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(484@177) mouseUp 9364455 nil]
		targetOffset: 	(21.0@14.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 0 0 0 0 0 nil nil)
		captureBlock: 	nil
		recentModifiers: 	0
		pendingEventQueue: 	WaitfreeQueue with 0 items
		supressNextKeyPress: 	false


HandMorph>>sendEvent:focus:clear:
	Receiver: a HandMorph(337424384)
	Arguments and temporary variables: 
		anEvent: 	[(484@177) mouseUp 9364455 nil]
		focusHolder: 	a SpToolbarButtonMorph(319944704)
		aBlock: 	[self mouseFocus: nil]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(484@177.0) corner: (500@193.0)
		owner: 	a WorldMorph(341720576) [world]
		submorphs: 	#()
		fullBounds: 	(484@177.0) corner: (500@193.0)
		color: 	Color blue
		extension: 	a MorphExtension (370611968)
		mouseFocus: 	nil
		keyboardFocus: 	a RubEditingArea(189250304)
		eventListeners: 	nil
		mouseListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(484@177) mouseUp 9364455 nil]
		targetOffset: 	(21.0@14.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 0 0 0 0 0 nil nil)
		captureBlock: 	nil
		recentModifiers: 	0
		pendingEventQueue: 	WaitfreeQueue with 0 items
		supressNextKeyPress: 	false


HandMorph>>sendMouseEvent:
	Receiver: a HandMorph(337424384)
	Arguments and temporary variables: 
		anEvent: 	[(484@177) mouseUp 9364455 nil]
	Receiver's instance variables: 
		bounds: 	(484@177.0) corner: (500@193.0)
		owner: 	a WorldMorph(341720576) [world]
		submorphs: 	#()
		fullBounds: 	(484@177.0) corner: (500@193.0)
		color: 	Color blue
		extension: 	a MorphExtension (370611968)
		mouseFocus: 	nil
		keyboardFocus: 	a RubEditingArea(189250304)
		eventListeners: 	nil
		mouseListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(484@177) mouseUp 9364455 nil]
		targetOffset: 	(21.0@14.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 0 0 0 0 0 nil nil)
		captureBlock: 	nil
		recentModifiers: 	0
		pendingEventQueue: 	WaitfreeQueue with 0 items
		supressNextKeyPress: 	false


HandMorph>>handleEvent:
	Receiver: a HandMorph(337424384)
	Arguments and temporary variables: 
		anEvent: 	[(484@177) mouseUp 9364455 nil]
		evt: 	[(484@177) mouseUp 9364455 nil]
	Receiver's instance variables: 
		bounds: 	(484@177.0) corner: (500@193.0)
		owner: 	a WorldMorph(341720576) [world]
		submorphs: 	#()
		fullBounds: 	(484@177.0) corner: (500@193.0)
		color: 	Color blue
		extension: 	a MorphExtension (370611968)
		mouseFocus: 	nil
		keyboardFocus: 	a RubEditingArea(189250304)
		eventListeners: 	nil
		mouseListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(484@177) mouseUp 9364455 nil]
		targetOffset: 	(21.0@14.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 0 0 0 0 0 nil nil)
		captureBlock: 	nil
		recentModifiers: 	0
		pendingEventQueue: 	WaitfreeQueue with 0 items
		supressNextKeyPress: 	false


[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil ]) ifTrue: [
			morphicWorld activeHand handleEvent: anEvent
		]
	] in OSWindowMorphicEventHandler>>dispatchMorphicEvent:
	Receiver: an OSWindowMorphicEventHandler
	Arguments and temporary variables: 
		anEvent: 	[(484@177) mouseUp 9364455 nil]
	Receiver's instance variables: 
		morphicWorld: 	a WorldMorph(341720576) [world]


WorldState>>runStepMethodsIn:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(341720576) [world]
		queue: 	WaitfreeQueue with 0 items
		nextInQueue: 	[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNo[..]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(337424384))
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap()
		lastStepTime: 	9355009
		lastStepMessage: 	nil
		alarms: 	a Heap(MorphicAlarm(#hideShow -> a RubCursor(898368768)))
		lastAlarmTime: 	9364436
		activeHand: 	a HandMorph(337424384)
		currentCursor: 	((CursorWithMask
	extent: (16@16)
	depth: 1
	fromArray: #(
	[..]
		worldRenderer: 	an OSWorldRenderer
		realWindowExtent: 	(1728@1080)
		deferredUIMessages: 	WaitfreeQueue with 0 items


WorldMorph>>runStepMethods
	Receiver: a WorldMorph(341720576) [world]
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1728@1080)
		owner: 	nil
		submorphs: 	an Array(a MenubarMorph(112886016) a TaskbarMorph(279458560) a S[..]
		fullBounds: 	(0@0) corner: (1728@1080)
		color: 	(Color r: 0.9403714565004888 g: 0.9403714565004888 b: 0.940371456500[..]
		extension: 	a MorphExtension (1012946432) [other:  (dragEnabled -> true) (dr[..]
		borderWidth: 	0
		borderColor: 	(Color r: 0.8611925708699902 g: 1.0 b: 0.7223851417399805 alph[..]
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil


WorldState>>doOneCycleFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(341720576) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(337424384))
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap()
		lastStepTime: 	9355009
		lastStepMessage: 	nil
		alarms: 	a Heap(MorphicAlarm(#hideShow -> a RubCursor(898368768)))
		lastAlarmTime: 	9364436
		activeHand: 	a HandMorph(337424384)
		currentCursor: 	((CursorWithMask
	extent: (16@16)
	depth: 1
	fromArray: #(
	[..]
		worldRenderer: 	an OSWorldRenderer
		realWindowExtent: 	(1728@1080)
		deferredUIMessages: 	WaitfreeQueue with 0 items


WorldMorph>>doOneCycleNow
	Receiver: a WorldMorph(341720576) [world]
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1728@1080)
		owner: 	nil
		submorphs: 	an Array(a MenubarMorph(112886016) a TaskbarMorph(279458560) a S[..]
		fullBounds: 	(0@0) corner: (1728@1080)
		color: 	(Color r: 0.9403714565004888 g: 0.9403714565004888 b: 0.940371456500[..]
		extension: 	a MorphExtension (1012946432) [other:  (dragEnabled -> true) (dr[..]
		borderWidth: 	0
		borderColor: 	(Color r: 0.8611925708699902 g: 1.0 b: 0.7223851417399805 alph[..]
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil



--- The full stack ---
Dictionary>>errorKeyNotFound:
[self errorKeyNotFound: key] in Dictionary>>at:
Dictionary>>at:ifAbsent:
Dictionary>>at:
GraphVisualizer>>loadDataFromFile:
GraphVisualizer>>visualizeGraphFromFile:
UndefinedObject>>DoIt
OCReceiverDoItSemanticScope(OCDoItSemanticScope)>>evaluateDoIt:
OpalCompiler>>evaluate
[
		self announcer announce: (SpCodeWillBeEvaluatedAnnouncement newContent: aString).
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionModel doItReceiver.
		result := receiver class compiler
			source: aString;
			context: self interactionModel doItContext;
			receiver: self interactionModel doItReceiver;
			requestor: self interactionModel;
			environment: self environment;
			failBlock:  [ 
				self announcer announce: (SpCodeEvaluationFailedAnnouncement newContent: aString).
				^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		self announcer announce: (SpCodeEvaluationSucceedAnnouncement newContent: aString).
		result ] in SpCodePresenter>>evaluate:onCompileError:onError:
FullBlockClosure(BlockClosure)>>on:do:
SpCodePresenter>>evaluate:onCompileError:onError:
StPlaygroundPagePresenter>>doEvaluateAndGo
StPlaygroundPagePresenter>>doEvaluateAllAndGo
StPlaygroundDoItCommand>>execute
SpCommand(CmCommandDecorator)>>execute
[ specCommand execute ] in [ :specCommand | 
			aButtonClass new
				label: specCommand name;
				help: specCommand description;
				in: [ :button | 
					specCommand hasIcon
						ifTrue: [ button icon: specCommand icon ] ];
				action: [ specCommand execute ];
				yourself ] in SpCommand>>configureAsButtonOfClass:
FullBlockClosure(BlockClosure)>>cull:
SpMorphicToolbarButtonAdapter>>execute
SpToolbarButtonMorph(PluggableButtonMorph)>>performAction:
[:m |
		(m containsPoint: evt cursorPoint) ifTrue: [m enabled ifTrue: [ m performAction: evt ]]] in SpToolbarButtonMorph(PluggableButtonMorph)>>mouseUp:
Array(SequenceableCollection)>>do:
SpToolbarButtonMorph(PluggableButtonMorph)>>mouseUp:
SpToolbarButtonMorph(Morph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
SpToolbarButtonMorph(Morph)>>handleEvent:
SpToolbarButtonMorph(Morph)>>handleFocusEvent:
[
		result := focusHolder handleFocusEvent: transformedEvent.
	] in HandMorph>>sendFocusEvent:to:clear:
FullBlockClosure(BlockClosure)>>on:do:
WorldMorph>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil ]) ifTrue: [
			morphicWorld activeHand handleEvent: anEvent
		]
	] in OSWindowMorphicEventHandler>>dispatchMorphicEvent:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycleNow
 - - - - - - - - - - - - - - -
			- - - - - - - - - - - - - - - - - -
WorldMorph>>doOneCycle
[
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMutex critical: [
			                     self extraWorldList ].
		extraWorldsToDraw do: [ :world | world doOneCycle ].

		(self currentWorld isNotNil and: [
			 (extraWorldsToDraw includes: self currentWorld) not ]) ifTrue: [
			self currentWorld doOneCycle ] ] in WorldMorph class>>doOneCycle
FullBlockClosure(BlockClosure)>>ensure:
WorldState class>>doDrawCycleWith:
WorldMorph class>>doOneCycle
MorphicRenderLoop>>doOneCycle
MorphicRenderLoop>>doOneCycleWhile:
[ MorphicRenderLoop new doOneCycleWhile: [ true ] ] in MorphicUIManager>>spawnNewProcess
[self value.
			"IMPORTANT: Do not step over next line of code. See method comments for details"
			Processor terminateRealActive] in FullBlockClosure(BlockClosure)>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
KeyNotFound: key #edges not found in Dictionary
13 November 2023 6:40:46.350199 pm

VM: Mac OS - arm64 - 1000 - CoInterpreter VMMaker-tonel.1 uuid: 902dd483-c0c4-0d00-86f2-0f880df24b96 Oct 23 2023
StackToRegisterMappingCogit VMMaker-tonel.1 uuid: 902dd483-c0c4-0d00-86f2-0f880df24b96 Oct 23 2023
v10.0.8 - Commit: b323c5fb - Date: 2023-10-20 16:02:07 -0400

Image: Pharo11.0.0 [Build information: Pharo-11.0.0+build.710.sha.ea28d8552cac85a7ce1e9c34ab1e7bd45f7b9910 (64 Bit)]

Dictionary>>errorKeyNotFound:
	Receiver: a Dictionary('nodes'->an Array(a Dictionary('id'->1 'label'->'Person' 'properties'->a [..]
	Arguments and temporary variables: 
		aKey: 	#edges
	Receiver's instance variables: 
		tally: 	2
		array: 	an Array('nodes'->an Array(a Dictionary('id'->1 'label'->'Person' 'p[..]


[self errorKeyNotFound: key] in Dictionary>>at:
	Receiver: a Dictionary('nodes'->an Array(a Dictionary('id'->1 'label'->'Person' 'properties'->a [..]
	Arguments and temporary variables: 
		key: 	#edges
	Receiver's instance variables: 
		tally: 	2
		array: 	an Array('nodes'->an Array(a Dictionary('id'->1 'label'->'Person' 'p[..]


Dictionary>>at:ifAbsent:
	Receiver: a Dictionary('nodes'->an Array(a Dictionary('id'->1 'label'->'Person' 'properties'->a [..]
	Arguments and temporary variables: 
		key: 	#edges
		aBlock: 	[self errorKeyNotFound: key]
	Receiver's instance variables: 
		tally: 	2
		array: 	an Array('nodes'->an Array(a Dictionary('id'->1 'label'->'Person' 'p[..]


Dictionary>>at:
	Receiver: a Dictionary('nodes'->an Array(a Dictionary('id'->1 'label'->'Person' 'properties'->a [..]
	Arguments and temporary variables: 
		key: 	#edges
	Receiver's instance variables: 
		tally: 	2
		array: 	an Array('nodes'->an Array(a Dictionary('id'->1 'label'->'Person' 'p[..]


GraphVisualizer>>loadDataFromFile:
	Receiver: a GraphVisualizer
	Arguments and temporary variables: 
		aFilePath: 	'/Users/ryanperez/Documents/GitHub/pp-rep2533/project/src/data/t[..]
		file: 	File @ /Users/ryanperez/Documents/GitHub/pp-rep2533/project/src/data/[..]
		contents: 	'{
    "nodes": [
      {"id": 1, "label": "Person", "properties"[..]
	Receiver's instance variables: 
		view: 	a RSCanvas
		nodes: 	an Array(a Dictionary('id'->1 'label'->'Person' 'properties'->a Dict[..]
		edges: 	nil
		nodesMap: 	a Dictionary()


GraphVisualizer>>visualizeGraphFromFile:
	Receiver: a GraphVisualizer
	Arguments and temporary variables: 
		aFilePath: 	'/Users/ryanperez/Documents/GitHub/pp-rep2533/project/src/data/t[..]
	Receiver's instance variables: 
		view: 	a RSCanvas
		nodes: 	an Array(a Dictionary('id'->1 'label'->'Person' 'properties'->a Dict[..]
		edges: 	nil
		nodesMap: 	a Dictionary()


UndefinedObject>>DoIt
	Receiver: nil
	Arguments and temporary variables: 
		visualizer: 	a GraphVisualizer
	Receiver's instance variables: 
nil

OCReceiverDoItSemanticScope(OCDoItSemanticScope)>>evaluateDoIt:
	Receiver: an OCReceiverDoItSemanticScope
	Arguments and temporary variables: 
		doItMethod: 	UndefinedObject>>#DoIt
	Receiver's instance variables: 
		outerScope: 	nil
		targetReceiver: 	nil


OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
		doItMethod: 	UndefinedObject>>#DoIt
	Receiver's instance variables: 
		ast: 	DoIt

	| visualizer |
	visualizer := GraphVisualizer new.
	^ visualize[..]
		source: 	a ReadStream
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil


[
		self announcer announce: (SpCodeWillBeEvaluatedAnnouncement newContent: aString).
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionModel doItReceiver.
		result := receiver class compiler
			source: aString;
			context: self interactionModel doItContext;
			receiver: self interactionModel doItReceiver;
			requestor: self interactionModel;
			environment: self environment;
			failBlock:  [ 
				self announcer announce: (SpCodeEvaluationFailedAnnouncement newContent: aString).
				^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		self announcer announce: (SpCodeEvaluationSucceedAnnouncement newContent: aString).
		result ] in SpCodePresenter>>evaluate:onCompileError:onError:
	Receiver: a SpCodePresenter
	Arguments and temporary variables: 
		aString: 	'| visualizer |
visualizer := GraphVisualizer new.
visualizer visu[..]
		compileErrorBlock: 	[ ^ self ]
		errorBlock: 	[ :e | e pass ]
		receiver: 	nil
		result: 	nil
		oldBindings: 	a Dictionary()
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicCodeAdapter)
		announcer: 	an Announcer
		owner: 	a StPlaygroundPagePresenter
		adapter: 	a SpMorphicCodeAdapter
		needRebuild: 	true
		eventHandler: 	a SpEventHandler
		application: 	nil
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ a KMCategory ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Code' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpAbstractWidgetLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		borderWidth: 	an ObservableValueHolder[ nil ]
		borderColor: 	an ObservableValueHolder[ nil ]
		dragEnabled: 	an ObservableValueHolder[ false ]
		dropEnabled: 	an ObservableValueHolder[ false ]
		color: 	an ObservableValueHolder[ nil ]
		help: 	an ObservableValueHolder[ nil ]
		enabled: 	an ObservableValueHolder[ true ]
		wantsDrop: 	an ObservableValueHolder[ [ :transfer | self dropEnabled ] ]
		acceptDrop: 	an ObservableValueHolder[ [ :transfer | ] ]
		deferredActions: 	nil
		hasUnacceptedEdits: 	an ObservableValueHolder[ false ]
		selection: 	an ObservableValueHolder[ (1 to: 159) ]
		wantsVisualFeedback: 	an ObservableValueHolder[ true ]
		askBeforeDiscardingEdits: 	an ObservableValueHolder[ true ]
		text: 	an ObservableValueHolder[ '| visualizer |
visualizer := GraphVisualiz[..]
		actionToPerform: 	an ObservableValueHolder[ [ :txt |  ] ]
		readSelection: 	an ObservableValueHolder[ [ selection ] ]
		placeholder: 	an ObservableValueHolder[ '' ]
		contextMenu: 	an ObservableValueHolder[ [ (self menuActionsFor: text) asMenu[..]
		scrollValue: 	an ObservableValueHolder[ (0@0) ]
		editionContextMenu: 	an ObservableValueHolder[ true ]
		editable: 	an ObservableValueHolder[ true ]
		wrapWord: 	an ObservableValueHolder[ true ]
		undoRedoHistory: 	true
		wrapScrollBars: 	true
		propagateNaturalHeight: 	false
		propagateNaturalWidth: 	false
		scrollBarStyles: 	#()
		syntaxHighlight: 	an ObservableValueHolder[ true ]
		smartCharacters: 	an ObservableValueHolder[ true ]
		lineNumbers: 	an ObservableValueHolder[ true ]
		interactionModel: 	an ObservableValueHolder[ a StPlaygroundInteractionModel ]
		overrideContextMenu: 	true
		submitBlock: 	nil
		resetBlock: 	nil
		environment: 	nil
		systemNavigation: 	nil
		syntaxHighlightTheme: 	an ObservableValueHolder[ nil ]


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
		self announcer announce: (SpCodeWillBeEvaluatedAnnouncement newContent: aString).
[..]
	Arguments and temporary variables: 
		exception: 	Error
		handlerAction: 	[ :e |
		self announcer announce: (SpCodeEvaluationFailedAnn[..]
	Receiver's instance variables: 
		outerContext: 	SpCodePresenter>>evaluate:onCompileError:onError:
		compiledBlock: 	a CompiledBlock: [
		self announcer announce: (SpCodeWillBeE[..]
		numArgs: 	0
		receiver: 	a SpCodePresenter


SpCodePresenter>>evaluate:onCompileError:onError:
	Receiver: a SpCodePresenter
	Arguments and temporary variables: 
		receiver: 	nil
		result: 	nil
		oldBindings: 	a Dictionary()
		aString: 	'| visualizer |
visualizer := GraphVisualizer new.
visualizer visu[..]
		compileErrorBlock: 	[ ^ self ]
		errorBlock: 	[ :e | e pass ]
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicCodeAdapter)
		announcer: 	an Announcer
		owner: 	a StPlaygroundPagePresenter
		adapter: 	a SpMorphicCodeAdapter
		needRebuild: 	true
		eventHandler: 	a SpEventHandler
		application: 	nil
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ a KMCategory ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Code' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpAbstractWidgetLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		borderWidth: 	an ObservableValueHolder[ nil ]
		borderColor: 	an ObservableValueHolder[ nil ]
		dragEnabled: 	an ObservableValueHolder[ false ]
		dropEnabled: 	an ObservableValueHolder[ false ]
		color: 	an ObservableValueHolder[ nil ]
		help: 	an ObservableValueHolder[ nil ]
		enabled: 	an ObservableValueHolder[ true ]
		wantsDrop: 	an ObservableValueHolder[ [ :transfer | self dropEnabled ] ]
		acceptDrop: 	an ObservableValueHolder[ [ :transfer | ] ]
		deferredActions: 	nil
		hasUnacceptedEdits: 	an ObservableValueHolder[ false ]
		selection: 	an ObservableValueHolder[ (1 to: 159) ]
		wantsVisualFeedback: 	an ObservableValueHolder[ true ]
		askBeforeDiscardingEdits: 	an ObservableValueHolder[ true ]
		text: 	an ObservableValueHolder[ '| visualizer |
visualizer := GraphVisualiz[..]
		actionToPerform: 	an ObservableValueHolder[ [ :txt |  ] ]
		readSelection: 	an ObservableValueHolder[ [ selection ] ]
		placeholder: 	an ObservableValueHolder[ '' ]
		contextMenu: 	an ObservableValueHolder[ [ (self menuActionsFor: text) asMenu[..]
		scrollValue: 	an ObservableValueHolder[ (0@0) ]
		editionContextMenu: 	an ObservableValueHolder[ true ]
		editable: 	an ObservableValueHolder[ true ]
		wrapWord: 	an ObservableValueHolder[ true ]
		undoRedoHistory: 	true
		wrapScrollBars: 	true
		propagateNaturalHeight: 	false
		propagateNaturalWidth: 	false
		scrollBarStyles: 	#()
		syntaxHighlight: 	an ObservableValueHolder[ true ]
		smartCharacters: 	an ObservableValueHolder[ true ]
		lineNumbers: 	an ObservableValueHolder[ true ]
		interactionModel: 	an ObservableValueHolder[ a StPlaygroundInteractionModel ]
		overrideContextMenu: 	true
		submitBlock: 	nil
		resetBlock: 	nil
		environment: 	nil
		systemNavigation: 	nil
		syntaxHighlightTheme: 	an ObservableValueHolder[ nil ]


StPlaygroundPagePresenter>>doEvaluateAndGo
	Receiver: a StPlaygroundPagePresenter
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicBoxAdapter)
		announcer: 	an Announcer
		owner: 	a SpMillerColumnPresenter
		adapter: 	a SpMorphicBoxAdapter
		needRebuild: 	true
		eventHandler: 	nil
		application: 	a StPharoApplication
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ nil ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Untitled window' ]
		additionalSubpresentersMap: 	a Dictionary()
		layout: 	an ObservableValueHolder[ a SpBoxLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		text: 	a SpCodePresenter
		toolbar: 	a SpToolbarPresenter
		statusbar: 	a SpPresenter
		lineLabel: 	a SpLabelPresenter
		toggleLineNumberButton: 	a SpToggleButtonPresenter
		page: 	a StPlaygroundPage
		activationBlock: 	[ :selection |
		self changeSelection: selection from: new[..]


StPlaygroundPagePresenter>>doEvaluateAllAndGo
	Receiver: a StPlaygroundPagePresenter
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicBoxAdapter)
		announcer: 	an Announcer
		owner: 	a SpMillerColumnPresenter
		adapter: 	a SpMorphicBoxAdapter
		needRebuild: 	true
		eventHandler: 	nil
		application: 	a StPharoApplication
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ nil ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Untitled window' ]
		additionalSubpresentersMap: 	a Dictionary()
		layout: 	an ObservableValueHolder[ a SpBoxLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		text: 	a SpCodePresenter
		toolbar: 	a SpToolbarPresenter
		statusbar: 	a SpPresenter
		lineLabel: 	a SpLabelPresenter
		toggleLineNumberButton: 	a SpToggleButtonPresenter
		page: 	a StPlaygroundPage
		activationBlock: 	[ :selection |
		self changeSelection: selection from: new[..]


StPlaygroundDoItCommand>>execute
	Receiver: a StPlaygroundDoItCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		context: 	a StPlaygroundPagePresenter
		basicName: 	'Do it'
		basicDescription: 	'Do it all and inspect.'


SpCommand(CmCommandDecorator)>>execute
	Receiver: a SpCommand(Do it)
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a StPlaygroundDoItCommand
		iconProvider: 	a StPharoApplication
		iconName: 	#glamorousGo
		shortcutKey: 	nil
		displayStrategy: 	a CmUIDisableWhenCantBeRun
		positionStrategy: 	a CmUILeftPositionStrategy
		buildPresenterBlock: 	[ :specCommand | 
			aButtonClass new
				label: specC[..]
		presenter: 	a SpToolbarButtonPresenter


[ specCommand execute ] in [ :specCommand | 
			aButtonClass new
				label: specCommand name;
				help: specCommand description;
				in: [ :button | 
					specCommand hasIcon
						ifTrue: [ button icon: specCommand icon ] ];
				action: [ specCommand execute ];
				yourself ] in SpCommand>>configureAsButtonOfClass:
	Receiver: a SpCommand(Do it)
	Arguments and temporary variables: 
		aButtonClass: 	nil
		specCommand: 	a SpCommand(Do it)
	Receiver's instance variables: 
		decoratedCommand: 	a StPlaygroundDoItCommand
		iconProvider: 	a StPharoApplication
		iconName: 	#glamorousGo
		shortcutKey: 	nil
		displayStrategy: 	a CmUIDisableWhenCantBeRun
		positionStrategy: 	a CmUILeftPositionStrategy
		buildPresenterBlock: 	[ :specCommand | 
			aButtonClass new
				label: specC[..]
		presenter: 	a SpToolbarButtonPresenter


FullBlockClosure(BlockClosure)>>cull:
	Receiver: [ specCommand execute ]
	Arguments and temporary variables: 
		anArg: 	a SpToolbarButtonPresenter
	Receiver's instance variables: 
		outerContext: 	[ :specCommand | 
			aButtonClass new
				label: specCommand [..]
		compiledBlock: 	a CompiledBlock: [ specCommand execute ]
		numArgs: 	0
		receiver: 	a SpCommand(Do it)


SpMorphicToolbarButtonAdapter>>execute
	Receiver: a SpMorphicToolbarButtonAdapter
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpToolbarButtonMorph(319944704))
		announcer: 	nil
		model: 	a SpToolbarButtonPresenter
		widget: 	a SpToolbarButtonMorph(319944704)
		selector: 	nil
		owner: 	a SpToolbarButtonPresenter
		unsubscribed: 	false


SpToolbarButtonMorph(PluggableButtonMorph)>>performAction:
	Receiver: a SpToolbarButtonMorph(319944704)
	Arguments and temporary variables: 
		event: 	[(21.0@19.0) mouseUp 9364455 nil]
	Receiver's instance variables: 
		bounds: 	(0.0@5.0) corner: (45.0@39.0)
		owner: 	a Morph(13467904)
		submorphs: 	an Array(an AlignmentMorph(869548288))
		fullBounds: 	nil
		color: 	(Color r: 0.9012707722385142 g: 0.9012707722385142 b: 0.901270772238[..]
		extension: 	a MorphExtension (545772544) [balloonText]  [other:  (presenter [..]
		borderWidth: 	0
		borderColor: 	#simple
		model: 	a SpMorphicToolbarButtonAdapter
		label: 	'Do it'
		icon: 	Form(13x13x32)
		getIconSelector: 	#icon
		getStateSelector: 	#state
		actionSelector: 	#execute
		font: 	a LogicalFont
 familyName: 'Source Sans Pro'
 emphasis: nil
 pointSiz[..]
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	nil
		getFontSelector: 	nil
		labelMorph: 	a LabelMorph(424853504)'Do it'
		iconMorph: 	an ImageMorph(356841984)
		iconPosition: 	#top
		lastState: 	false
		badgeFont: 	nil
		badgeSelector: 	#badge


[:m |
		(m containsPoint: evt cursorPoint) ifTrue: [m enabled ifTrue: [ m performAction: evt ]]] in SpToolbarButtonMorph(PluggableButtonMorph)>>mouseUp:
	Receiver: a SpToolbarButtonMorph(319944704)
	Arguments and temporary variables: 
		evt: 	[(21.0@19.0) mouseUp 9364455 nil]
		all: 	an Array(a SpToolbarButtonMorph(319944704) a SpToolbarButtonMorph(5749[..]
		m: 	a SpToolbarButtonMorph(319944704)
	Receiver's instance variables: 
		bounds: 	(0.0@5.0) corner: (45.0@39.0)
		owner: 	a Morph(13467904)
		submorphs: 	an Array(an AlignmentMorph(869548288))
		fullBounds: 	nil
		color: 	(Color r: 0.9012707722385142 g: 0.9012707722385142 b: 0.901270772238[..]
		extension: 	a MorphExtension (545772544) [balloonText]  [other:  (presenter [..]
		borderWidth: 	0
		borderColor: 	#simple
		model: 	a SpMorphicToolbarButtonAdapter
		label: 	'Do it'
		icon: 	Form(13x13x32)
		getIconSelector: 	#icon
		getStateSelector: 	#state
		actionSelector: 	#execute
		font: 	a LogicalFont
 familyName: 'Source Sans Pro'
 emphasis: nil
 pointSiz[..]
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	nil
		getFontSelector: 	nil
		labelMorph: 	a LabelMorph(424853504)'Do it'
		iconMorph: 	an ImageMorph(356841984)
		iconPosition: 	#top
		lastState: 	false
		badgeFont: 	nil
		badgeSelector: 	#badge


Array(SequenceableCollection)>>do:
	Receiver: an Array(a SpToolbarButtonMorph(319944704) a SpToolbarButtonMorph(574995456) a SpToolb[..]
	Arguments and temporary variables: 
		aBlock: 	[:m |
		(m containsPoint: evt cursorPoint) ifTrue: [m enabled ifTru[..]
		index: 	1
	Receiver's instance variables: 
an Array(a SpToolbarButtonMorph(319944704) a SpToolbarButtonMorph(574995456) a SpToolb[..]

SpToolbarButtonMorph(PluggableButtonMorph)>>mouseUp:
	Receiver: a SpToolbarButtonMorph(319944704)
	Arguments and temporary variables: 
		evt: 	[(21.0@19.0) mouseUp 9364455 nil]
		all: 	an Array(a SpToolbarButtonMorph(319944704) a SpToolbarButtonMorph(5749[..]
	Receiver's instance variables: 
		bounds: 	(0.0@5.0) corner: (45.0@39.0)
		owner: 	a Morph(13467904)
		submorphs: 	an Array(an AlignmentMorph(869548288))
		fullBounds: 	nil
		color: 	(Color r: 0.9012707722385142 g: 0.9012707722385142 b: 0.901270772238[..]
		extension: 	a MorphExtension (545772544) [balloonText]  [other:  (presenter [..]
		borderWidth: 	0
		borderColor: 	#simple
		model: 	a SpMorphicToolbarButtonAdapter
		label: 	'Do it'
		icon: 	Form(13x13x32)
		getIconSelector: 	#icon
		getStateSelector: 	#state
		actionSelector: 	#execute
		font: 	a LogicalFont
 familyName: 'Source Sans Pro'
 emphasis: nil
 pointSiz[..]
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	nil
		getFontSelector: 	nil
		labelMorph: 	a LabelMorph(424853504)'Do it'
		iconMorph: 	an ImageMorph(356841984)
		iconPosition: 	#top
		lastState: 	false
		badgeFont: 	nil
		badgeSelector: 	#badge


SpToolbarButtonMorph(Morph)>>handleMouseUp:
	Receiver: a SpToolbarButtonMorph(319944704)
	Arguments and temporary variables: 
		anEvent: 	[(21.0@19.0) mouseUp 9364455 nil]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(0.0@5.0) corner: (45.0@39.0)
		owner: 	a Morph(13467904)
		submorphs: 	an Array(an AlignmentMorph(869548288))
		fullBounds: 	nil
		color: 	(Color r: 0.9012707722385142 g: 0.9012707722385142 b: 0.901270772238[..]
		extension: 	a MorphExtension (545772544) [balloonText]  [other:  (presenter [..]
		borderWidth: 	0
		borderColor: 	#simple
		model: 	a SpMorphicToolbarButtonAdapter
		label: 	'Do it'
		icon: 	Form(13x13x32)
		getIconSelector: 	#icon
		getStateSelector: 	#state
		actionSelector: 	#execute
		font: 	a LogicalFont
 familyName: 'Source Sans Pro'
 emphasis: nil
 pointSiz[..]
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	nil
		getFontSelector: 	nil
		labelMorph: 	a LabelMorph(424853504)'Do it'
		iconMorph: 	an ImageMorph(356841984)
		iconPosition: 	#top
		lastState: 	false
		badgeFont: 	nil
		badgeSelector: 	#badge


MouseButtonEvent>>sentTo:
	Receiver: [(21.0@19.0) mouseUp 9364455 nil]
	Arguments and temporary variables: 
		anObject: 	a SpToolbarButtonMorph(319944704)
	Receiver's instance variables: 
		timeStamp: 	9364455
		source: 	a HandMorph(337424384)
		windowIndex: 	nil
		type: 	#mouseUp
		buttons: 	0
		position: 	(21.0@19.0)
		handler: 	nil
		wasHandled: 	true
		whichButton: 	4


SpToolbarButtonMorph(Morph)>>handleEvent:
	Receiver: a SpToolbarButtonMorph(319944704)
	Arguments and temporary variables: 
		anEvent: 	[(21.0@19.0) mouseUp 9364455 nil]
	Receiver's instance variables: 
		bounds: 	(0.0@5.0) corner: (45.0@39.0)
		owner: 	a Morph(13467904)
		submorphs: 	an Array(an AlignmentMorph(869548288))
		fullBounds: 	nil
		color: 	(Color r: 0.9012707722385142 g: 0.9012707722385142 b: 0.901270772238[..]
		extension: 	a MorphExtension (545772544) [balloonText]  [other:  (presenter [..]
		borderWidth: 	0
		borderColor: 	#simple
		model: 	a SpMorphicToolbarButtonAdapter
		label: 	'Do it'
		icon: 	Form(13x13x32)
		getIconSelector: 	#icon
		getStateSelector: 	#state
		actionSelector: 	#execute
		font: 	a LogicalFont
 familyName: 'Source Sans Pro'
 emphasis: nil
 pointSiz[..]
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	nil
		getFontSelector: 	nil
		labelMorph: 	a LabelMorph(424853504)'Do it'
		iconMorph: 	an ImageMorph(356841984)
		iconPosition: 	#top
		lastState: 	false
		badgeFont: 	nil
		badgeSelector: 	#badge


SpToolbarButtonMorph(Morph)>>handleFocusEvent:
	Receiver: a SpToolbarButtonMorph(319944704)
	Arguments and temporary variables: 
		anEvent: 	[(21.0@19.0) mouseUp 9364455 nil]
	Receiver's instance variables: 
		bounds: 	(0.0@5.0) corner: (45.0@39.0)
		owner: 	a Morph(13467904)
		submorphs: 	an Array(an AlignmentMorph(869548288))
		fullBounds: 	nil
		color: 	(Color r: 0.9012707722385142 g: 0.9012707722385142 b: 0.901270772238[..]
		extension: 	a MorphExtension (545772544) [balloonText]  [other:  (presenter [..]
		borderWidth: 	0
		borderColor: 	#simple
		model: 	a SpMorphicToolbarButtonAdapter
		label: 	'Do it'
		icon: 	Form(13x13x32)
		getIconSelector: 	#icon
		getStateSelector: 	#state
		actionSelector: 	#execute
		font: 	a LogicalFont
 familyName: 'Source Sans Pro'
 emphasis: nil
 pointSiz[..]
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	nil
		getFontSelector: 	nil
		labelMorph: 	a LabelMorph(424853504)'Do it'
		iconMorph: 	an ImageMorph(356841984)
		iconPosition: 	#top
		lastState: 	false
		badgeFont: 	nil
		badgeSelector: 	#badge


[
		result := focusHolder handleFocusEvent: transformedEvent.
	] in HandMorph>>sendFocusEvent:to:clear:
	Receiver: a HandMorph(337424384)
	Arguments and temporary variables: 
		anEvent: 	[(484@177) mouseUp 9364455 nil]
		focusHolder: 	a SpToolbarButtonMorph(319944704)
		aBlock: 	[self mouseFocus: nil]
		w: 	a WorldMorph(341720576) [world]
		transformedEvent: 	[(21.0@19.0) mouseUp 9364455 nil]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(484@177.0) corner: (500@193.0)
		owner: 	a WorldMorph(341720576) [world]
		submorphs: 	#()
		fullBounds: 	(484@177.0) corner: (500@193.0)
		color: 	Color blue
		extension: 	a MorphExtension (370611968)
		mouseFocus: 	nil
		keyboardFocus: 	a RubEditingArea(189250304)
		eventListeners: 	nil
		mouseListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(484@177) mouseUp 9364455 nil]
		targetOffset: 	(21.0@14.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 0 0 0 0 0 nil nil)
		captureBlock: 	nil
		recentModifiers: 	0
		pendingEventQueue: 	WaitfreeQueue with 0 items
		supressNextKeyPress: 	false


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
		result := focusHolder handleFocusEvent: transformedEvent.
	]
	Arguments and temporary variables: 
		exception: 	Error
		handlerAction: 	[ :ex |
			ActiveWorld := priorWorld.
			ex pass ]
	Receiver's instance variables: 
		outerContext: 	HandMorph>>sendFocusEvent:to:clear:
		compiledBlock: 	a CompiledBlock: [
		result := focusHolder handleFocusEvent:[..]
		numArgs: 	0
		receiver: 	a HandMorph(337424384)


WorldMorph>>becomeActiveDuring:
	Receiver: a WorldMorph(341720576) [world]
	Arguments and temporary variables: 
		aBlock: 	[
		result := focusHolder handleFocusEvent: transformedEvent.
	]
		priorWorld: 	a WorldMorph(341720576) [world]
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1728@1080)
		owner: 	nil
		submorphs: 	an Array(a MenubarMorph(112886016) a TaskbarMorph(279458560) a S[..]
		fullBounds: 	(0@0) corner: (1728@1080)
		color: 	(Color r: 0.9403714565004888 g: 0.9403714565004888 b: 0.940371456500[..]
		extension: 	a MorphExtension (1012946432) [other:  (dragEnabled -> true) (dr[..]
		borderWidth: 	0
		borderColor: 	(Color r: 0.8611925708699902 g: 1.0 b: 0.7223851417399805 alph[..]
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil


HandMorph>>sendFocusEvent:to:clear:
	Receiver: a HandMorph(337424384)
	Arguments and temporary variables: 
		result: 	nil
		anEvent: 	[(484@177) mouseUp 9364455 nil]
		focusHolder: 	a SpToolbarButtonMorph(319944704)
		aBlock: 	[self mouseFocus: nil]
		w: 	a WorldMorph(341720576) [world]
		transformedEvent: 	[(21.0@19.0) mouseUp 9364455 nil]
	Receiver's instance variables: 
		bounds: 	(484@177.0) corner: (500@193.0)
		owner: 	a WorldMorph(341720576) [world]
		submorphs: 	#()
		fullBounds: 	(484@177.0) corner: (500@193.0)
		color: 	Color blue
		extension: 	a MorphExtension (370611968)
		mouseFocus: 	nil
		keyboardFocus: 	a RubEditingArea(189250304)
		eventListeners: 	nil
		mouseListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(484@177) mouseUp 9364455 nil]
		targetOffset: 	(21.0@14.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 0 0 0 0 0 nil nil)
		captureBlock: 	nil
		recentModifiers: 	0
		pendingEventQueue: 	WaitfreeQueue with 0 items
		supressNextKeyPress: 	false


HandMorph>>sendEvent:focus:clear:
	Receiver: a HandMorph(337424384)
	Arguments and temporary variables: 
		anEvent: 	[(484@177) mouseUp 9364455 nil]
		focusHolder: 	a SpToolbarButtonMorph(319944704)
		aBlock: 	[self mouseFocus: nil]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(484@177.0) corner: (500@193.0)
		owner: 	a WorldMorph(341720576) [world]
		submorphs: 	#()
		fullBounds: 	(484@177.0) corner: (500@193.0)
		color: 	Color blue
		extension: 	a MorphExtension (370611968)
		mouseFocus: 	nil
		keyboardFocus: 	a RubEditingArea(189250304)
		eventListeners: 	nil
		mouseListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(484@177) mouseUp 9364455 nil]
		targetOffset: 	(21.0@14.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 0 0 0 0 0 nil nil)
		captureBlock: 	nil
		recentModifiers: 	0
		pendingEventQueue: 	WaitfreeQueue with 0 items
		supressNextKeyPress: 	false


HandMorph>>sendMouseEvent:
	Receiver: a HandMorph(337424384)
	Arguments and temporary variables: 
		anEvent: 	[(484@177) mouseUp 9364455 nil]
	Receiver's instance variables: 
		bounds: 	(484@177.0) corner: (500@193.0)
		owner: 	a WorldMorph(341720576) [world]
		submorphs: 	#()
		fullBounds: 	(484@177.0) corner: (500@193.0)
		color: 	Color blue
		extension: 	a MorphExtension (370611968)
		mouseFocus: 	nil
		keyboardFocus: 	a RubEditingArea(189250304)
		eventListeners: 	nil
		mouseListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(484@177) mouseUp 9364455 nil]
		targetOffset: 	(21.0@14.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 0 0 0 0 0 nil nil)
		captureBlock: 	nil
		recentModifiers: 	0
		pendingEventQueue: 	WaitfreeQueue with 0 items
		supressNextKeyPress: 	false


HandMorph>>handleEvent:
	Receiver: a HandMorph(337424384)
	Arguments and temporary variables: 
		anEvent: 	[(484@177) mouseUp 9364455 nil]
		evt: 	[(484@177) mouseUp 9364455 nil]
	Receiver's instance variables: 
		bounds: 	(484@177.0) corner: (500@193.0)
		owner: 	a WorldMorph(341720576) [world]
		submorphs: 	#()
		fullBounds: 	(484@177.0) corner: (500@193.0)
		color: 	Color blue
		extension: 	a MorphExtension (370611968)
		mouseFocus: 	nil
		keyboardFocus: 	a RubEditingArea(189250304)
		eventListeners: 	nil
		mouseListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(484@177) mouseUp 9364455 nil]
		targetOffset: 	(21.0@14.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 0 0 0 0 0 nil nil)
		captureBlock: 	nil
		recentModifiers: 	0
		pendingEventQueue: 	WaitfreeQueue with 0 items
		supressNextKeyPress: 	false


[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil ]) ifTrue: [
			morphicWorld activeHand handleEvent: anEvent
		]
	] in OSWindowMorphicEventHandler>>dispatchMorphicEvent:
	Receiver: an OSWindowMorphicEventHandler
	Arguments and temporary variables: 
		anEvent: 	[(484@177) mouseUp 9364455 nil]
	Receiver's instance variables: 
		morphicWorld: 	a WorldMorph(341720576) [world]


WorldState>>runStepMethodsIn:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(341720576) [world]
		queue: 	WaitfreeQueue with 0 items
		nextInQueue: 	[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNo[..]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(337424384))
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap()
		lastStepTime: 	9355009
		lastStepMessage: 	nil
		alarms: 	a Heap(MorphicAlarm(#hideShow -> a RubCursor(898368768)))
		lastAlarmTime: 	9364436
		activeHand: 	a HandMorph(337424384)
		currentCursor: 	((CursorWithMask
	extent: (16@16)
	depth: 1
	fromArray: #(
	[..]
		worldRenderer: 	an OSWorldRenderer
		realWindowExtent: 	(1728@1080)
		deferredUIMessages: 	WaitfreeQueue with 0 items


WorldMorph>>runStepMethods
	Receiver: a WorldMorph(341720576) [world]
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1728@1080)
		owner: 	nil
		submorphs: 	an Array(a MenubarMorph(112886016) a TaskbarMorph(279458560) a S[..]
		fullBounds: 	(0@0) corner: (1728@1080)
		color: 	(Color r: 0.9403714565004888 g: 0.9403714565004888 b: 0.940371456500[..]
		extension: 	a MorphExtension (1012946432) [other:  (dragEnabled -> true) (dr[..]
		borderWidth: 	0
		borderColor: 	(Color r: 0.8611925708699902 g: 1.0 b: 0.7223851417399805 alph[..]
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil


WorldState>>doOneCycleFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(341720576) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(337424384))
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap()
		lastStepTime: 	9355009
		lastStepMessage: 	nil
		alarms: 	a Heap(MorphicAlarm(#hideShow -> a RubCursor(898368768)))
		lastAlarmTime: 	9364436
		activeHand: 	a HandMorph(337424384)
		currentCursor: 	((CursorWithMask
	extent: (16@16)
	depth: 1
	fromArray: #(
	[..]
		worldRenderer: 	an OSWorldRenderer
		realWindowExtent: 	(1728@1080)
		deferredUIMessages: 	WaitfreeQueue with 0 items


WorldMorph>>doOneCycleNow
	Receiver: a WorldMorph(341720576) [world]
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1728@1080)
		owner: 	nil
		submorphs: 	an Array(a MenubarMorph(112886016) a TaskbarMorph(279458560) a S[..]
		fullBounds: 	(0@0) corner: (1728@1080)
		color: 	(Color r: 0.9403714565004888 g: 0.9403714565004888 b: 0.940371456500[..]
		extension: 	a MorphExtension (1012946432) [other:  (dragEnabled -> true) (dr[..]
		borderWidth: 	0
		borderColor: 	(Color r: 0.8611925708699902 g: 1.0 b: 0.7223851417399805 alph[..]
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil



--- The full stack ---
Dictionary>>errorKeyNotFound:
[self errorKeyNotFound: key] in Dictionary>>at:
Dictionary>>at:ifAbsent:
Dictionary>>at:
GraphVisualizer>>loadDataFromFile:
GraphVisualizer>>visualizeGraphFromFile:
UndefinedObject>>DoIt
OCReceiverDoItSemanticScope(OCDoItSemanticScope)>>evaluateDoIt:
OpalCompiler>>evaluate
[
		self announcer announce: (SpCodeWillBeEvaluatedAnnouncement newContent: aString).
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionModel doItReceiver.
		result := receiver class compiler
			source: aString;
			context: self interactionModel doItContext;
			receiver: self interactionModel doItReceiver;
			requestor: self interactionModel;
			environment: self environment;
			failBlock:  [ 
				self announcer announce: (SpCodeEvaluationFailedAnnouncement newContent: aString).
				^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		self announcer announce: (SpCodeEvaluationSucceedAnnouncement newContent: aString).
		result ] in SpCodePresenter>>evaluate:onCompileError:onError:
FullBlockClosure(BlockClosure)>>on:do:
SpCodePresenter>>evaluate:onCompileError:onError:
StPlaygroundPagePresenter>>doEvaluateAndGo
StPlaygroundPagePresenter>>doEvaluateAllAndGo
StPlaygroundDoItCommand>>execute
SpCommand(CmCommandDecorator)>>execute
[ specCommand execute ] in [ :specCommand | 
			aButtonClass new
				label: specCommand name;
				help: specCommand description;
				in: [ :button | 
					specCommand hasIcon
						ifTrue: [ button icon: specCommand icon ] ];
				action: [ specCommand execute ];
				yourself ] in SpCommand>>configureAsButtonOfClass:
FullBlockClosure(BlockClosure)>>cull:
SpMorphicToolbarButtonAdapter>>execute
SpToolbarButtonMorph(PluggableButtonMorph)>>performAction:
[:m |
		(m containsPoint: evt cursorPoint) ifTrue: [m enabled ifTrue: [ m performAction: evt ]]] in SpToolbarButtonMorph(PluggableButtonMorph)>>mouseUp:
Array(SequenceableCollection)>>do:
SpToolbarButtonMorph(PluggableButtonMorph)>>mouseUp:
SpToolbarButtonMorph(Morph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
SpToolbarButtonMorph(Morph)>>handleEvent:
SpToolbarButtonMorph(Morph)>>handleFocusEvent:
[
		result := focusHolder handleFocusEvent: transformedEvent.
	] in HandMorph>>sendFocusEvent:to:clear:
FullBlockClosure(BlockClosure)>>on:do:
WorldMorph>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil ]) ifTrue: [
			morphicWorld activeHand handleEvent: anEvent
		]
	] in OSWindowMorphicEventHandler>>dispatchMorphicEvent:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycleNow
 - - - - - - - - - - - - - - -
			- - - - - - - - - - - - - - - - - -
WorldMorph>>doOneCycle
[
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMutex critical: [
			                     self extraWorldList ].
		extraWorldsToDraw do: [ :world | world doOneCycle ].

		(self currentWorld isNotNil and: [
			 (extraWorldsToDraw includes: self currentWorld) not ]) ifTrue: [
			self currentWorld doOneCycle ] ] in WorldMorph class>>doOneCycle
FullBlockClosure(BlockClosure)>>ensure:
WorldState class>>doDrawCycleWith:
WorldMorph class>>doOneCycle
MorphicRenderLoop>>doOneCycle
MorphicRenderLoop>>doOneCycleWhile:
[ MorphicRenderLoop new doOneCycleWhile: [ true ] ] in MorphicUIManager>>spawnNewProcess
[self value.
			"IMPORTANT: Do not step over next line of code. See method comments for details"
			Processor terminateRealActive] in FullBlockClosure(BlockClosure)>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
#add: was sent to nil
13 November 2023 7:07:40.799383 pm

VM: Mac OS - arm64 - 1000 - CoInterpreter VMMaker-tonel.1 uuid: 902dd483-c0c4-0d00-86f2-0f880df24b96 Oct 23 2023
StackToRegisterMappingCogit VMMaker-tonel.1 uuid: 902dd483-c0c4-0d00-86f2-0f880df24b96 Oct 23 2023
v10.0.8 - Commit: b323c5fb - Date: 2023-10-20 16:02:07 -0400

Image: Pharo11.0.0 [Build information: Pharo-11.0.0+build.710.sha.ea28d8552cac85a7ce1e9c34ab1e7bd45f7b9910 (64 Bit)]

UndefinedObject(Object)>>doesNotUnderstand: #add:
	Receiver: nil
	Arguments and temporary variables: 
		aMessage: 	add: a RSBox
		exception: 	#add: was sent to nil
		resumeValue: 	nil
	Receiver's instance variables: 
nil

UndefinedObject>>doesNotUnderstand: #add:
	Receiver: nil
	Arguments and temporary variables: 
		node: 	nil
		aMessage: 	add: a RSBox
		exception: 	nil
		resumeValue: 	nil
	Receiver's instance variables: 
nil

[ :nodeDict |
        | node |
        node := RSBox new size: 20; color: Color blue.
        node canvas add: node.
        nodesMap at: (nodeDict at: #id) put: node.
    ] in GraphVisualizer>>createNodes
	Receiver: a GraphVisualizer
	Arguments and temporary variables: 
		nodeDict: 	a Dictionary('id'->1 'label'->'Person' 'properties'->a Dictionary[..]
		node: 	a RSBox
	Receiver's instance variables: 
		view: 	a RSCanvas
		nodes: 	an Array(a Dictionary('id'->1 'label'->'Person' 'properties'->a Dict[..]
		edges: 	an Array(a Dictionary('source'->1 'target'->2 'type'->'FRIENDS_WITH' ))
		nodesMap: 	a Dictionary()
		canvas: 	nil


Array(SequenceableCollection)>>do:
	Receiver: an Array(a Dictionary('id'->1 'label'->'Person' 'properties'->a Dictionary('name'->'Al[..]
	Arguments and temporary variables: 
		aBlock: 	[ :nodeDict |
        | node |
        node := RSBox new size: 20; [..]
		index: 	1
	Receiver's instance variables: 
an Array(a Dictionary('id'->1 'label'->'Person' 'properties'->a Dictionary('name'->'Al[..]

GraphVisualizer>>createNodes
	Receiver: a GraphVisualizer
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		view: 	a RSCanvas
		nodes: 	an Array(a Dictionary('id'->1 'label'->'Person' 'properties'->a Dict[..]
		edges: 	an Array(a Dictionary('source'->1 'target'->2 'type'->'FRIENDS_WITH' ))
		nodesMap: 	a Dictionary()
		canvas: 	nil


GraphVisualizer>>visualizeGraphFromFile:
	Receiver: a GraphVisualizer
	Arguments and temporary variables: 
		aFilePath: 	'/Users/ryanperez/Documents/GitHub/pp-rep2533/project/src/data/t[..]
	Receiver's instance variables: 
		view: 	a RSCanvas
		nodes: 	an Array(a Dictionary('id'->1 'label'->'Person' 'properties'->a Dict[..]
		edges: 	an Array(a Dictionary('source'->1 'target'->2 'type'->'FRIENDS_WITH' ))
		nodesMap: 	a Dictionary()
		canvas: 	nil


UndefinedObject>>DoIt
	Receiver: nil
	Arguments and temporary variables: 
		visualizer: 	a GraphVisualizer
	Receiver's instance variables: 
nil

OCReceiverDoItSemanticScope(OCDoItSemanticScope)>>evaluateDoIt:
	Receiver: an OCReceiverDoItSemanticScope
	Arguments and temporary variables: 
		doItMethod: 	UndefinedObject>>#DoIt
	Receiver's instance variables: 
		outerScope: 	nil
		targetReceiver: 	nil


OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
		doItMethod: 	UndefinedObject>>#DoIt
	Receiver's instance variables: 
		ast: 	DoIt

	| visualizer |
	visualizer := GraphVisualizer new.
	^ visualize[..]
		source: 	a ReadStream
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil


[
		self announcer announce: (SpCodeWillBeEvaluatedAnnouncement newContent: aString).
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionModel doItReceiver.
		result := receiver class compiler
			source: aString;
			context: self interactionModel doItContext;
			receiver: self interactionModel doItReceiver;
			requestor: self interactionModel;
			environment: self environment;
			failBlock:  [ 
				self announcer announce: (SpCodeEvaluationFailedAnnouncement newContent: aString).
				^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		self announcer announce: (SpCodeEvaluationSucceedAnnouncement newContent: aString).
		result ] in SpCodePresenter>>evaluate:onCompileError:onError:
	Receiver: a SpCodePresenter
	Arguments and temporary variables: 
		aString: 	'| visualizer |
visualizer := GraphVisualizer new.
visualizer visu[..]
		compileErrorBlock: 	[ ^ self ]
		errorBlock: 	[ :e | e pass ]
		receiver: 	nil
		result: 	nil
		oldBindings: 	a Dictionary()
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicCodeAdapter)
		announcer: 	an Announcer
		owner: 	a StPlaygroundPagePresenter
		adapter: 	a SpMorphicCodeAdapter
		needRebuild: 	true
		eventHandler: 	a SpEventHandler
		application: 	nil
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ a KMCategory ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Code' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpAbstractWidgetLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		borderWidth: 	an ObservableValueHolder[ nil ]
		borderColor: 	an ObservableValueHolder[ nil ]
		dragEnabled: 	an ObservableValueHolder[ false ]
		dropEnabled: 	an ObservableValueHolder[ false ]
		color: 	an ObservableValueHolder[ nil ]
		help: 	an ObservableValueHolder[ nil ]
		enabled: 	an ObservableValueHolder[ true ]
		wantsDrop: 	an ObservableValueHolder[ [ :transfer | self dropEnabled ] ]
		acceptDrop: 	an ObservableValueHolder[ [ :transfer | ] ]
		deferredActions: 	nil
		hasUnacceptedEdits: 	an ObservableValueHolder[ false ]
		selection: 	an ObservableValueHolder[ (1 to: 159) ]
		wantsVisualFeedback: 	an ObservableValueHolder[ true ]
		askBeforeDiscardingEdits: 	an ObservableValueHolder[ true ]
		text: 	an ObservableValueHolder[ '| visualizer |
visualizer := GraphVisualiz[..]
		actionToPerform: 	an ObservableValueHolder[ [ :txt |  ] ]
		readSelection: 	an ObservableValueHolder[ [ selection ] ]
		placeholder: 	an ObservableValueHolder[ '' ]
		contextMenu: 	an ObservableValueHolder[ [ (self menuActionsFor: text) asMenu[..]
		scrollValue: 	an ObservableValueHolder[ (0@0) ]
		editionContextMenu: 	an ObservableValueHolder[ true ]
		editable: 	an ObservableValueHolder[ true ]
		wrapWord: 	an ObservableValueHolder[ true ]
		undoRedoHistory: 	true
		wrapScrollBars: 	true
		propagateNaturalHeight: 	false
		propagateNaturalWidth: 	false
		scrollBarStyles: 	#()
		syntaxHighlight: 	an ObservableValueHolder[ true ]
		smartCharacters: 	an ObservableValueHolder[ true ]
		lineNumbers: 	an ObservableValueHolder[ true ]
		interactionModel: 	an ObservableValueHolder[ a StPlaygroundInteractionModel ]
		overrideContextMenu: 	true
		submitBlock: 	nil
		resetBlock: 	nil
		environment: 	nil
		systemNavigation: 	nil
		syntaxHighlightTheme: 	an ObservableValueHolder[ nil ]


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
		self announcer announce: (SpCodeWillBeEvaluatedAnnouncement newContent: aString).
[..]
	Arguments and temporary variables: 
		exception: 	Error
		handlerAction: 	[ :e |
		self announcer announce: (SpCodeEvaluationFailedAnn[..]
	Receiver's instance variables: 
		outerContext: 	SpCodePresenter>>evaluate:onCompileError:onError:
		compiledBlock: 	a CompiledBlock: [
		self announcer announce: (SpCodeWillBeE[..]
		numArgs: 	0
		receiver: 	a SpCodePresenter


SpCodePresenter>>evaluate:onCompileError:onError:
	Receiver: a SpCodePresenter
	Arguments and temporary variables: 
		receiver: 	nil
		result: 	nil
		oldBindings: 	a Dictionary()
		aString: 	'| visualizer |
visualizer := GraphVisualizer new.
visualizer visu[..]
		compileErrorBlock: 	[ ^ self ]
		errorBlock: 	[ :e | e pass ]
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicCodeAdapter)
		announcer: 	an Announcer
		owner: 	a StPlaygroundPagePresenter
		adapter: 	a SpMorphicCodeAdapter
		needRebuild: 	true
		eventHandler: 	a SpEventHandler
		application: 	nil
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ a KMCategory ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Code' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpAbstractWidgetLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		borderWidth: 	an ObservableValueHolder[ nil ]
		borderColor: 	an ObservableValueHolder[ nil ]
		dragEnabled: 	an ObservableValueHolder[ false ]
		dropEnabled: 	an ObservableValueHolder[ false ]
		color: 	an ObservableValueHolder[ nil ]
		help: 	an ObservableValueHolder[ nil ]
		enabled: 	an ObservableValueHolder[ true ]
		wantsDrop: 	an ObservableValueHolder[ [ :transfer | self dropEnabled ] ]
		acceptDrop: 	an ObservableValueHolder[ [ :transfer | ] ]
		deferredActions: 	nil
		hasUnacceptedEdits: 	an ObservableValueHolder[ false ]
		selection: 	an ObservableValueHolder[ (1 to: 159) ]
		wantsVisualFeedback: 	an ObservableValueHolder[ true ]
		askBeforeDiscardingEdits: 	an ObservableValueHolder[ true ]
		text: 	an ObservableValueHolder[ '| visualizer |
visualizer := GraphVisualiz[..]
		actionToPerform: 	an ObservableValueHolder[ [ :txt |  ] ]
		readSelection: 	an ObservableValueHolder[ [ selection ] ]
		placeholder: 	an ObservableValueHolder[ '' ]
		contextMenu: 	an ObservableValueHolder[ [ (self menuActionsFor: text) asMenu[..]
		scrollValue: 	an ObservableValueHolder[ (0@0) ]
		editionContextMenu: 	an ObservableValueHolder[ true ]
		editable: 	an ObservableValueHolder[ true ]
		wrapWord: 	an ObservableValueHolder[ true ]
		undoRedoHistory: 	true
		wrapScrollBars: 	true
		propagateNaturalHeight: 	false
		propagateNaturalWidth: 	false
		scrollBarStyles: 	#()
		syntaxHighlight: 	an ObservableValueHolder[ true ]
		smartCharacters: 	an ObservableValueHolder[ true ]
		lineNumbers: 	an ObservableValueHolder[ true ]
		interactionModel: 	an ObservableValueHolder[ a StPlaygroundInteractionModel ]
		overrideContextMenu: 	true
		submitBlock: 	nil
		resetBlock: 	nil
		environment: 	nil
		systemNavigation: 	nil
		syntaxHighlightTheme: 	an ObservableValueHolder[ nil ]


StPlaygroundPagePresenter>>doEvaluateAndGo
	Receiver: a StPlaygroundPagePresenter
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicBoxAdapter)
		announcer: 	an Announcer
		owner: 	a SpMillerColumnPresenter
		adapter: 	a SpMorphicBoxAdapter
		needRebuild: 	true
		eventHandler: 	nil
		application: 	a StPharoApplication
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ nil ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Untitled window' ]
		additionalSubpresentersMap: 	a Dictionary()
		layout: 	an ObservableValueHolder[ a SpBoxLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		text: 	a SpCodePresenter
		toolbar: 	a SpToolbarPresenter
		statusbar: 	a SpPresenter
		lineLabel: 	a SpLabelPresenter
		toggleLineNumberButton: 	a SpToggleButtonPresenter
		page: 	a StPlaygroundPage
		activationBlock: 	[ :selection |
		self changeSelection: selection from: new[..]


StPlaygroundPagePresenter>>doEvaluateAllAndGo
	Receiver: a StPlaygroundPagePresenter
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicBoxAdapter)
		announcer: 	an Announcer
		owner: 	a SpMillerColumnPresenter
		adapter: 	a SpMorphicBoxAdapter
		needRebuild: 	true
		eventHandler: 	nil
		application: 	a StPharoApplication
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ nil ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Untitled window' ]
		additionalSubpresentersMap: 	a Dictionary()
		layout: 	an ObservableValueHolder[ a SpBoxLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		text: 	a SpCodePresenter
		toolbar: 	a SpToolbarPresenter
		statusbar: 	a SpPresenter
		lineLabel: 	a SpLabelPresenter
		toggleLineNumberButton: 	a SpToggleButtonPresenter
		page: 	a StPlaygroundPage
		activationBlock: 	[ :selection |
		self changeSelection: selection from: new[..]


StPlaygroundDoItCommand>>execute
	Receiver: a StPlaygroundDoItCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		context: 	a StPlaygroundPagePresenter
		basicName: 	'Do it'
		basicDescription: 	'Do it all and inspect.'


SpCommand(CmCommandDecorator)>>execute
	Receiver: a SpCommand(Do it)
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a StPlaygroundDoItCommand
		iconProvider: 	a StPharoApplication
		iconName: 	#glamorousGo
		shortcutKey: 	nil
		displayStrategy: 	a CmUIDisableWhenCantBeRun
		positionStrategy: 	a CmUILeftPositionStrategy
		buildPresenterBlock: 	[ :specCommand | 
			aButtonClass new
				label: specC[..]
		presenter: 	a SpToolbarButtonPresenter


[ specCommand execute ] in [ :specCommand | 
			aButtonClass new
				label: specCommand name;
				help: specCommand description;
				in: [ :button | 
					specCommand hasIcon
						ifTrue: [ button icon: specCommand icon ] ];
				action: [ specCommand execute ];
				yourself ] in SpCommand>>configureAsButtonOfClass:
	Receiver: a SpCommand(Do it)
	Arguments and temporary variables: 
		aButtonClass: 	nil
		specCommand: 	a SpCommand(Do it)
	Receiver's instance variables: 
		decoratedCommand: 	a StPlaygroundDoItCommand
		iconProvider: 	a StPharoApplication
		iconName: 	#glamorousGo
		shortcutKey: 	nil
		displayStrategy: 	a CmUIDisableWhenCantBeRun
		positionStrategy: 	a CmUILeftPositionStrategy
		buildPresenterBlock: 	[ :specCommand | 
			aButtonClass new
				label: specC[..]
		presenter: 	a SpToolbarButtonPresenter


FullBlockClosure(BlockClosure)>>cull:
	Receiver: [ specCommand execute ]
	Arguments and temporary variables: 
		anArg: 	a SpToolbarButtonPresenter
	Receiver's instance variables: 
		outerContext: 	[ :specCommand | 
			aButtonClass new
				label: specCommand [..]
		compiledBlock: 	a CompiledBlock: [ specCommand execute ]
		numArgs: 	0
		receiver: 	a SpCommand(Do it)


SpMorphicToolbarButtonAdapter>>execute
	Receiver: a SpMorphicToolbarButtonAdapter
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpToolbarButtonMorph(163457024))
		announcer: 	nil
		model: 	a SpToolbarButtonPresenter
		widget: 	a SpToolbarButtonMorph(163457024)
		selector: 	nil
		owner: 	a SpToolbarButtonPresenter
		unsubscribed: 	false


SpToolbarButtonMorph(PluggableButtonMorph)>>performAction:
	Receiver: a SpToolbarButtonMorph(163457024)
	Arguments and temporary variables: 
		event: 	[(27.0@20.0) mouseUp 10978920 nil]
	Receiver's instance variables: 
		bounds: 	(0.0@5.0) corner: (45.0@39.0)
		owner: 	a Morph(543889152)
		submorphs: 	an Array(an AlignmentMorph(1048008448))
		fullBounds: 	nil
		color: 	(Color r: 0.9012707722385142 g: 0.9012707722385142 b: 0.901270772238[..]
		extension: 	a MorphExtension (606190080) [balloonText]  [other:  (presenter [..]
		borderWidth: 	0
		borderColor: 	#simple
		model: 	a SpMorphicToolbarButtonAdapter
		label: 	'Do it'
		icon: 	Form(13x13x32)
		getIconSelector: 	#icon
		getStateSelector: 	#state
		actionSelector: 	#execute
		font: 	a LogicalFont
 familyName: 'Source Sans Pro'
 emphasis: nil
 pointSiz[..]
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	nil
		getFontSelector: 	nil
		labelMorph: 	a LabelMorph(576130816)'Do it'
		iconMorph: 	an ImageMorph(527603200)
		iconPosition: 	#top
		lastState: 	false
		badgeFont: 	nil
		badgeSelector: 	#badge


[:m |
		(m containsPoint: evt cursorPoint) ifTrue: [m enabled ifTrue: [ m performAction: evt ]]] in SpToolbarButtonMorph(PluggableButtonMorph)>>mouseUp:
	Receiver: a SpToolbarButtonMorph(163457024)
	Arguments and temporary variables: 
		evt: 	[(27.0@20.0) mouseUp 10978920 nil]
		all: 	an Array(a SpToolbarButtonMorph(163457024) a SpToolbarButtonMorph(6416[..]
		m: 	a SpToolbarButtonMorph(163457024)
	Receiver's instance variables: 
		bounds: 	(0.0@5.0) corner: (45.0@39.0)
		owner: 	a Morph(543889152)
		submorphs: 	an Array(an AlignmentMorph(1048008448))
		fullBounds: 	nil
		color: 	(Color r: 0.9012707722385142 g: 0.9012707722385142 b: 0.901270772238[..]
		extension: 	a MorphExtension (606190080) [balloonText]  [other:  (presenter [..]
		borderWidth: 	0
		borderColor: 	#simple
		model: 	a SpMorphicToolbarButtonAdapter
		label: 	'Do it'
		icon: 	Form(13x13x32)
		getIconSelector: 	#icon
		getStateSelector: 	#state
		actionSelector: 	#execute
		font: 	a LogicalFont
 familyName: 'Source Sans Pro'
 emphasis: nil
 pointSiz[..]
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	nil
		getFontSelector: 	nil
		labelMorph: 	a LabelMorph(576130816)'Do it'
		iconMorph: 	an ImageMorph(527603200)
		iconPosition: 	#top
		lastState: 	false
		badgeFont: 	nil
		badgeSelector: 	#badge


Array(SequenceableCollection)>>do:
	Receiver: an Array(a SpToolbarButtonMorph(163457024) a SpToolbarButtonMorph(641645312) a SpToolb[..]
	Arguments and temporary variables: 
		aBlock: 	[:m |
		(m containsPoint: evt cursorPoint) ifTrue: [m enabled ifTru[..]
		index: 	1
	Receiver's instance variables: 
an Array(a SpToolbarButtonMorph(163457024) a SpToolbarButtonMorph(641645312) a SpToolb[..]

SpToolbarButtonMorph(PluggableButtonMorph)>>mouseUp:
	Receiver: a SpToolbarButtonMorph(163457024)
	Arguments and temporary variables: 
		evt: 	[(27.0@20.0) mouseUp 10978920 nil]
		all: 	an Array(a SpToolbarButtonMorph(163457024) a SpToolbarButtonMorph(6416[..]
	Receiver's instance variables: 
		bounds: 	(0.0@5.0) corner: (45.0@39.0)
		owner: 	a Morph(543889152)
		submorphs: 	an Array(an AlignmentMorph(1048008448))
		fullBounds: 	nil
		color: 	(Color r: 0.9012707722385142 g: 0.9012707722385142 b: 0.901270772238[..]
		extension: 	a MorphExtension (606190080) [balloonText]  [other:  (presenter [..]
		borderWidth: 	0
		borderColor: 	#simple
		model: 	a SpMorphicToolbarButtonAdapter
		label: 	'Do it'
		icon: 	Form(13x13x32)
		getIconSelector: 	#icon
		getStateSelector: 	#state
		actionSelector: 	#execute
		font: 	a LogicalFont
 familyName: 'Source Sans Pro'
 emphasis: nil
 pointSiz[..]
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	nil
		getFontSelector: 	nil
		labelMorph: 	a LabelMorph(576130816)'Do it'
		iconMorph: 	an ImageMorph(527603200)
		iconPosition: 	#top
		lastState: 	false
		badgeFont: 	nil
		badgeSelector: 	#badge


SpToolbarButtonMorph(Morph)>>handleMouseUp:
	Receiver: a SpToolbarButtonMorph(163457024)
	Arguments and temporary variables: 
		anEvent: 	[(27.0@20.0) mouseUp 10978920 nil]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(0.0@5.0) corner: (45.0@39.0)
		owner: 	a Morph(543889152)
		submorphs: 	an Array(an AlignmentMorph(1048008448))
		fullBounds: 	nil
		color: 	(Color r: 0.9012707722385142 g: 0.9012707722385142 b: 0.901270772238[..]
		extension: 	a MorphExtension (606190080) [balloonText]  [other:  (presenter [..]
		borderWidth: 	0
		borderColor: 	#simple
		model: 	a SpMorphicToolbarButtonAdapter
		label: 	'Do it'
		icon: 	Form(13x13x32)
		getIconSelector: 	#icon
		getStateSelector: 	#state
		actionSelector: 	#execute
		font: 	a LogicalFont
 familyName: 'Source Sans Pro'
 emphasis: nil
 pointSiz[..]
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	nil
		getFontSelector: 	nil
		labelMorph: 	a LabelMorph(576130816)'Do it'
		iconMorph: 	an ImageMorph(527603200)
		iconPosition: 	#top
		lastState: 	false
		badgeFont: 	nil
		badgeSelector: 	#badge


MouseButtonEvent>>sentTo:
	Receiver: [(27.0@20.0) mouseUp 10978920 nil]
	Arguments and temporary variables: 
		anObject: 	a SpToolbarButtonMorph(163457024)
	Receiver's instance variables: 
		timeStamp: 	10978920
		source: 	a HandMorph(337424384)
		windowIndex: 	nil
		type: 	#mouseUp
		buttons: 	0
		position: 	(27.0@20.0)
		handler: 	nil
		wasHandled: 	true
		whichButton: 	4


SpToolbarButtonMorph(Morph)>>handleEvent:
	Receiver: a SpToolbarButtonMorph(163457024)
	Arguments and temporary variables: 
		anEvent: 	[(27.0@20.0) mouseUp 10978920 nil]
	Receiver's instance variables: 
		bounds: 	(0.0@5.0) corner: (45.0@39.0)
		owner: 	a Morph(543889152)
		submorphs: 	an Array(an AlignmentMorph(1048008448))
		fullBounds: 	nil
		color: 	(Color r: 0.9012707722385142 g: 0.9012707722385142 b: 0.901270772238[..]
		extension: 	a MorphExtension (606190080) [balloonText]  [other:  (presenter [..]
		borderWidth: 	0
		borderColor: 	#simple
		model: 	a SpMorphicToolbarButtonAdapter
		label: 	'Do it'
		icon: 	Form(13x13x32)
		getIconSelector: 	#icon
		getStateSelector: 	#state
		actionSelector: 	#execute
		font: 	a LogicalFont
 familyName: 'Source Sans Pro'
 emphasis: nil
 pointSiz[..]
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	nil
		getFontSelector: 	nil
		labelMorph: 	a LabelMorph(576130816)'Do it'
		iconMorph: 	an ImageMorph(527603200)
		iconPosition: 	#top
		lastState: 	false
		badgeFont: 	nil
		badgeSelector: 	#badge


SpToolbarButtonMorph(Morph)>>handleFocusEvent:
	Receiver: a SpToolbarButtonMorph(163457024)
	Arguments and temporary variables: 
		anEvent: 	[(27.0@20.0) mouseUp 10978920 nil]
	Receiver's instance variables: 
		bounds: 	(0.0@5.0) corner: (45.0@39.0)
		owner: 	a Morph(543889152)
		submorphs: 	an Array(an AlignmentMorph(1048008448))
		fullBounds: 	nil
		color: 	(Color r: 0.9012707722385142 g: 0.9012707722385142 b: 0.901270772238[..]
		extension: 	a MorphExtension (606190080) [balloonText]  [other:  (presenter [..]
		borderWidth: 	0
		borderColor: 	#simple
		model: 	a SpMorphicToolbarButtonAdapter
		label: 	'Do it'
		icon: 	Form(13x13x32)
		getIconSelector: 	#icon
		getStateSelector: 	#state
		actionSelector: 	#execute
		font: 	a LogicalFont
 familyName: 'Source Sans Pro'
 emphasis: nil
 pointSiz[..]
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	nil
		getFontSelector: 	nil
		labelMorph: 	a LabelMorph(576130816)'Do it'
		iconMorph: 	an ImageMorph(527603200)
		iconPosition: 	#top
		lastState: 	false
		badgeFont: 	nil
		badgeSelector: 	#badge


[
		result := focusHolder handleFocusEvent: transformedEvent.
	] in HandMorph>>sendFocusEvent:to:clear:
	Receiver: a HandMorph(337424384)
	Arguments and temporary variables: 
		anEvent: 	[(219@271) mouseUp 10978920 nil]
		focusHolder: 	a SpToolbarButtonMorph(163457024)
		aBlock: 	[self mouseFocus: nil]
		w: 	a WorldMorph(341720576) [world]
		transformedEvent: 	[(27.0@20.0) mouseUp 10978920 nil]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(219@271.0) corner: (235@287.0)
		owner: 	a WorldMorph(341720576) [world]
		submorphs: 	#()
		fullBounds: 	(219@271.0) corner: (235@287.0)
		color: 	Color blue
		extension: 	a MorphExtension (370611968)
		mouseFocus: 	nil
		keyboardFocus: 	a RubEditingArea(143191808)
		eventListeners: 	nil
		mouseListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(219@271) mouseUp 10978920 nil]
		targetOffset: 	(27.0@15.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 0 0 0 0 0 nil nil)
		captureBlock: 	nil
		recentModifiers: 	0
		pendingEventQueue: 	WaitfreeQueue with 0 items
		supressNextKeyPress: 	true


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
		result := focusHolder handleFocusEvent: transformedEvent.
	]
	Arguments and temporary variables: 
		exception: 	Error
		handlerAction: 	[ :ex |
			ActiveWorld := priorWorld.
			ex pass ]
	Receiver's instance variables: 
		outerContext: 	HandMorph>>sendFocusEvent:to:clear:
		compiledBlock: 	a CompiledBlock: [
		result := focusHolder handleFocusEvent:[..]
		numArgs: 	0
		receiver: 	a HandMorph(337424384)


WorldMorph>>becomeActiveDuring:
	Receiver: a WorldMorph(341720576) [world]
	Arguments and temporary variables: 
		aBlock: 	[
		result := focusHolder handleFocusEvent: transformedEvent.
	]
		priorWorld: 	a WorldMorph(341720576) [world]
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1728@1080)
		owner: 	nil
		submorphs: 	an Array(a MenubarMorph(112886016) a TaskbarMorph(279458560) a S[..]
		fullBounds: 	(0@0) corner: (1728@1080)
		color: 	(Color r: 0.9403714565004888 g: 0.9403714565004888 b: 0.940371456500[..]
		extension: 	a MorphExtension (1012946432) [other:  (dragEnabled -> true) (dr[..]
		borderWidth: 	0
		borderColor: 	(Color r: 0.8611925708699902 g: 1.0 b: 0.7223851417399805 alph[..]
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil


HandMorph>>sendFocusEvent:to:clear:
	Receiver: a HandMorph(337424384)
	Arguments and temporary variables: 
		result: 	nil
		anEvent: 	[(219@271) mouseUp 10978920 nil]
		focusHolder: 	a SpToolbarButtonMorph(163457024)
		aBlock: 	[self mouseFocus: nil]
		w: 	a WorldMorph(341720576) [world]
		transformedEvent: 	[(27.0@20.0) mouseUp 10978920 nil]
	Receiver's instance variables: 
		bounds: 	(219@271.0) corner: (235@287.0)
		owner: 	a WorldMorph(341720576) [world]
		submorphs: 	#()
		fullBounds: 	(219@271.0) corner: (235@287.0)
		color: 	Color blue
		extension: 	a MorphExtension (370611968)
		mouseFocus: 	nil
		keyboardFocus: 	a RubEditingArea(143191808)
		eventListeners: 	nil
		mouseListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(219@271) mouseUp 10978920 nil]
		targetOffset: 	(27.0@15.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 0 0 0 0 0 nil nil)
		captureBlock: 	nil
		recentModifiers: 	0
		pendingEventQueue: 	WaitfreeQueue with 0 items
		supressNextKeyPress: 	true


HandMorph>>sendEvent:focus:clear:
	Receiver: a HandMorph(337424384)
	Arguments and temporary variables: 
		anEvent: 	[(219@271) mouseUp 10978920 nil]
		focusHolder: 	a SpToolbarButtonMorph(163457024)
		aBlock: 	[self mouseFocus: nil]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(219@271.0) corner: (235@287.0)
		owner: 	a WorldMorph(341720576) [world]
		submorphs: 	#()
		fullBounds: 	(219@271.0) corner: (235@287.0)
		color: 	Color blue
		extension: 	a MorphExtension (370611968)
		mouseFocus: 	nil
		keyboardFocus: 	a RubEditingArea(143191808)
		eventListeners: 	nil
		mouseListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(219@271) mouseUp 10978920 nil]
		targetOffset: 	(27.0@15.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 0 0 0 0 0 nil nil)
		captureBlock: 	nil
		recentModifiers: 	0
		pendingEventQueue: 	WaitfreeQueue with 0 items
		supressNextKeyPress: 	true


HandMorph>>sendMouseEvent:
	Receiver: a HandMorph(337424384)
	Arguments and temporary variables: 
		anEvent: 	[(219@271) mouseUp 10978920 nil]
	Receiver's instance variables: 
		bounds: 	(219@271.0) corner: (235@287.0)
		owner: 	a WorldMorph(341720576) [world]
		submorphs: 	#()
		fullBounds: 	(219@271.0) corner: (235@287.0)
		color: 	Color blue
		extension: 	a MorphExtension (370611968)
		mouseFocus: 	nil
		keyboardFocus: 	a RubEditingArea(143191808)
		eventListeners: 	nil
		mouseListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(219@271) mouseUp 10978920 nil]
		targetOffset: 	(27.0@15.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 0 0 0 0 0 nil nil)
		captureBlock: 	nil
		recentModifiers: 	0
		pendingEventQueue: 	WaitfreeQueue with 0 items
		supressNextKeyPress: 	true


HandMorph>>handleEvent:
	Receiver: a HandMorph(337424384)
	Arguments and temporary variables: 
		anEvent: 	[(219@271) mouseUp 10978920 nil]
		evt: 	[(219@271) mouseUp 10978920 nil]
	Receiver's instance variables: 
		bounds: 	(219@271.0) corner: (235@287.0)
		owner: 	a WorldMorph(341720576) [world]
		submorphs: 	#()
		fullBounds: 	(219@271.0) corner: (235@287.0)
		color: 	Color blue
		extension: 	a MorphExtension (370611968)
		mouseFocus: 	nil
		keyboardFocus: 	a RubEditingArea(143191808)
		eventListeners: 	nil
		mouseListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(219@271) mouseUp 10978920 nil]
		targetOffset: 	(27.0@15.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 0 0 0 0 0 nil nil)
		captureBlock: 	nil
		recentModifiers: 	0
		pendingEventQueue: 	WaitfreeQueue with 0 items
		supressNextKeyPress: 	true


[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil ]) ifTrue: [
			morphicWorld activeHand handleEvent: anEvent
		]
	] in OSWindowMorphicEventHandler>>dispatchMorphicEvent:
	Receiver: an OSWindowMorphicEventHandler
	Arguments and temporary variables: 
		anEvent: 	[(219@271) mouseUp 10978920 nil]
	Receiver's instance variables: 
		morphicWorld: 	a WorldMorph(341720576) [world]


WorldState>>runStepMethodsIn:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(341720576) [world]
		queue: 	WaitfreeQueue with 0 items
		nextInQueue: 	[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNo[..]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(337424384))
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap()
		lastStepTime: 	10975278
		lastStepMessage: 	nil
		alarms: 	a Heap(MorphicAlarm(#hideShow -> a RubCursor(27124480)))
		lastAlarmTime: 	10978899
		activeHand: 	a HandMorph(337424384)
		currentCursor: 	((CursorWithMask
	extent: (16@16)
	depth: 1
	fromArray: #(
	[..]
		worldRenderer: 	an OSWorldRenderer
		realWindowExtent: 	(1728@1080)
		deferredUIMessages: 	WaitfreeQueue with 0 items


WorldMorph>>runStepMethods
	Receiver: a WorldMorph(341720576) [world]
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1728@1080)
		owner: 	nil
		submorphs: 	an Array(a MenubarMorph(112886016) a TaskbarMorph(279458560) a S[..]
		fullBounds: 	(0@0) corner: (1728@1080)
		color: 	(Color r: 0.9403714565004888 g: 0.9403714565004888 b: 0.940371456500[..]
		extension: 	a MorphExtension (1012946432) [other:  (dragEnabled -> true) (dr[..]
		borderWidth: 	0
		borderColor: 	(Color r: 0.8611925708699902 g: 1.0 b: 0.7223851417399805 alph[..]
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil


WorldState>>doOneCycleFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(341720576) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(337424384))
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap()
		lastStepTime: 	10975278
		lastStepMessage: 	nil
		alarms: 	a Heap(MorphicAlarm(#hideShow -> a RubCursor(27124480)))
		lastAlarmTime: 	10978899
		activeHand: 	a HandMorph(337424384)
		currentCursor: 	((CursorWithMask
	extent: (16@16)
	depth: 1
	fromArray: #(
	[..]
		worldRenderer: 	an OSWorldRenderer
		realWindowExtent: 	(1728@1080)
		deferredUIMessages: 	WaitfreeQueue with 0 items


WorldMorph>>doOneCycleNow
	Receiver: a WorldMorph(341720576) [world]
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1728@1080)
		owner: 	nil
		submorphs: 	an Array(a MenubarMorph(112886016) a TaskbarMorph(279458560) a S[..]
		fullBounds: 	(0@0) corner: (1728@1080)
		color: 	(Color r: 0.9403714565004888 g: 0.9403714565004888 b: 0.940371456500[..]
		extension: 	a MorphExtension (1012946432) [other:  (dragEnabled -> true) (dr[..]
		borderWidth: 	0
		borderColor: 	(Color r: 0.8611925708699902 g: 1.0 b: 0.7223851417399805 alph[..]
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil



--- The full stack ---
UndefinedObject(Object)>>doesNotUnderstand: #add:
UndefinedObject>>doesNotUnderstand: #add:
[ :nodeDict |
        | node |
        node := RSBox new size: 20; color: Color blue.
        node canvas add: node.
        nodesMap at: (nodeDict at: #id) put: node.
    ] in GraphVisualizer>>createNodes
Array(SequenceableCollection)>>do:
GraphVisualizer>>createNodes
GraphVisualizer>>visualizeGraphFromFile:
UndefinedObject>>DoIt
OCReceiverDoItSemanticScope(OCDoItSemanticScope)>>evaluateDoIt:
OpalCompiler>>evaluate
[
		self announcer announce: (SpCodeWillBeEvaluatedAnnouncement newContent: aString).
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionModel doItReceiver.
		result := receiver class compiler
			source: aString;
			context: self interactionModel doItContext;
			receiver: self interactionModel doItReceiver;
			requestor: self interactionModel;
			environment: self environment;
			failBlock:  [ 
				self announcer announce: (SpCodeEvaluationFailedAnnouncement newContent: aString).
				^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		self announcer announce: (SpCodeEvaluationSucceedAnnouncement newContent: aString).
		result ] in SpCodePresenter>>evaluate:onCompileError:onError:
FullBlockClosure(BlockClosure)>>on:do:
SpCodePresenter>>evaluate:onCompileError:onError:
StPlaygroundPagePresenter>>doEvaluateAndGo
StPlaygroundPagePresenter>>doEvaluateAllAndGo
StPlaygroundDoItCommand>>execute
SpCommand(CmCommandDecorator)>>execute
[ specCommand execute ] in [ :specCommand | 
			aButtonClass new
				label: specCommand name;
				help: specCommand description;
				in: [ :button | 
					specCommand hasIcon
						ifTrue: [ button icon: specCommand icon ] ];
				action: [ specCommand execute ];
				yourself ] in SpCommand>>configureAsButtonOfClass:
FullBlockClosure(BlockClosure)>>cull:
SpMorphicToolbarButtonAdapter>>execute
SpToolbarButtonMorph(PluggableButtonMorph)>>performAction:
[:m |
		(m containsPoint: evt cursorPoint) ifTrue: [m enabled ifTrue: [ m performAction: evt ]]] in SpToolbarButtonMorph(PluggableButtonMorph)>>mouseUp:
Array(SequenceableCollection)>>do:
SpToolbarButtonMorph(PluggableButtonMorph)>>mouseUp:
SpToolbarButtonMorph(Morph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
SpToolbarButtonMorph(Morph)>>handleEvent:
SpToolbarButtonMorph(Morph)>>handleFocusEvent:
[
		result := focusHolder handleFocusEvent: transformedEvent.
	] in HandMorph>>sendFocusEvent:to:clear:
FullBlockClosure(BlockClosure)>>on:do:
WorldMorph>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil ]) ifTrue: [
			morphicWorld activeHand handleEvent: anEvent
		]
	] in OSWindowMorphicEventHandler>>dispatchMorphicEvent:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycleNow
 - - - - - - - - - - - - - - -
			- - - - - - - - - - - - - - - - - -
WorldMorph>>doOneCycle
[
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMutex critical: [
			                     self extraWorldList ].
		extraWorldsToDraw do: [ :world | world doOneCycle ].

		(self currentWorld isNotNil and: [
			 (extraWorldsToDraw includes: self currentWorld) not ]) ifTrue: [
			self currentWorld doOneCycle ] ] in WorldMorph class>>doOneCycle
FullBlockClosure(BlockClosure)>>ensure:
WorldState class>>doDrawCycleWith:
WorldMorph class>>doOneCycle
MorphicRenderLoop>>doOneCycle
MorphicRenderLoop>>doOneCycleWhile:
[ MorphicRenderLoop new doOneCycleWhile: [ true ] ] in MorphicUIManager>>spawnNewProcess
[self value.
			"IMPORTANT: Do not step over next line of code. See method comments for details"
			Processor terminateRealActive] in FullBlockClosure(BlockClosure)>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
#add: was sent to nil
13 November 2023 7:07:40.823307 pm

VM: Mac OS - arm64 - 1000 - CoInterpreter VMMaker-tonel.1 uuid: 902dd483-c0c4-0d00-86f2-0f880df24b96 Oct 23 2023
StackToRegisterMappingCogit VMMaker-tonel.1 uuid: 902dd483-c0c4-0d00-86f2-0f880df24b96 Oct 23 2023
v10.0.8 - Commit: b323c5fb - Date: 2023-10-20 16:02:07 -0400

Image: Pharo11.0.0 [Build information: Pharo-11.0.0+build.710.sha.ea28d8552cac85a7ce1e9c34ab1e7bd45f7b9910 (64 Bit)]

UndefinedObject(Object)>>doesNotUnderstand: #add:
	Receiver: nil
	Arguments and temporary variables: 
		aMessage: 	add: a RSBox
		exception: 	#add: was sent to nil
		resumeValue: 	nil
	Receiver's instance variables: 
nil

UndefinedObject>>doesNotUnderstand: #add:
	Receiver: nil
	Arguments and temporary variables: 
		node: 	nil
		aMessage: 	add: a RSBox
		exception: 	nil
		resumeValue: 	nil
	Receiver's instance variables: 
nil

[ :nodeDict |
        | node |
        node := RSBox new size: 20; color: Color blue.
        node canvas add: node.
        nodesMap at: (nodeDict at: #id) put: node.
    ] in GraphVisualizer>>createNodes
	Receiver: a GraphVisualizer
	Arguments and temporary variables: 
		nodeDict: 	a Dictionary('id'->1 'label'->'Person' 'properties'->a Dictionary[..]
		node: 	a RSBox
	Receiver's instance variables: 
		view: 	a RSCanvas
		nodes: 	an Array(a Dictionary('id'->1 'label'->'Person' 'properties'->a Dict[..]
		edges: 	an Array(a Dictionary('source'->1 'target'->2 'type'->'FRIENDS_WITH' ))
		nodesMap: 	a Dictionary()
		canvas: 	nil


Array(SequenceableCollection)>>do:
	Receiver: an Array(a Dictionary('id'->1 'label'->'Person' 'properties'->a Dictionary('name'->'Al[..]
	Arguments and temporary variables: 
		aBlock: 	[ :nodeDict |
        | node |
        node := RSBox new size: 20; [..]
		index: 	1
	Receiver's instance variables: 
an Array(a Dictionary('id'->1 'label'->'Person' 'properties'->a Dictionary('name'->'Al[..]

GraphVisualizer>>createNodes
	Receiver: a GraphVisualizer
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		view: 	a RSCanvas
		nodes: 	an Array(a Dictionary('id'->1 'label'->'Person' 'properties'->a Dict[..]
		edges: 	an Array(a Dictionary('source'->1 'target'->2 'type'->'FRIENDS_WITH' ))
		nodesMap: 	a Dictionary()
		canvas: 	nil


GraphVisualizer>>visualizeGraphFromFile:
	Receiver: a GraphVisualizer
	Arguments and temporary variables: 
		aFilePath: 	'/Users/ryanperez/Documents/GitHub/pp-rep2533/project/src/data/t[..]
	Receiver's instance variables: 
		view: 	a RSCanvas
		nodes: 	an Array(a Dictionary('id'->1 'label'->'Person' 'properties'->a Dict[..]
		edges: 	an Array(a Dictionary('source'->1 'target'->2 'type'->'FRIENDS_WITH' ))
		nodesMap: 	a Dictionary()
		canvas: 	nil


UndefinedObject>>DoIt
	Receiver: nil
	Arguments and temporary variables: 
		visualizer: 	a GraphVisualizer
	Receiver's instance variables: 
nil

OCReceiverDoItSemanticScope(OCDoItSemanticScope)>>evaluateDoIt:
	Receiver: an OCReceiverDoItSemanticScope
	Arguments and temporary variables: 
		doItMethod: 	UndefinedObject>>#DoIt
	Receiver's instance variables: 
		outerScope: 	nil
		targetReceiver: 	nil


OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
		doItMethod: 	UndefinedObject>>#DoIt
	Receiver's instance variables: 
		ast: 	DoIt

	| visualizer |
	visualizer := GraphVisualizer new.
	^ visualize[..]
		source: 	a ReadStream
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil


[
		self announcer announce: (SpCodeWillBeEvaluatedAnnouncement newContent: aString).
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionModel doItReceiver.
		result := receiver class compiler
			source: aString;
			context: self interactionModel doItContext;
			receiver: self interactionModel doItReceiver;
			requestor: self interactionModel;
			environment: self environment;
			failBlock:  [ 
				self announcer announce: (SpCodeEvaluationFailedAnnouncement newContent: aString).
				^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		self announcer announce: (SpCodeEvaluationSucceedAnnouncement newContent: aString).
		result ] in SpCodePresenter>>evaluate:onCompileError:onError:
	Receiver: a SpCodePresenter
	Arguments and temporary variables: 
		aString: 	'| visualizer |
visualizer := GraphVisualizer new.
visualizer visu[..]
		compileErrorBlock: 	[ ^ self ]
		errorBlock: 	[ :e | e pass ]
		receiver: 	nil
		result: 	nil
		oldBindings: 	a Dictionary()
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicCodeAdapter)
		announcer: 	an Announcer
		owner: 	a StPlaygroundPagePresenter
		adapter: 	a SpMorphicCodeAdapter
		needRebuild: 	true
		eventHandler: 	a SpEventHandler
		application: 	nil
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ a KMCategory ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Code' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpAbstractWidgetLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		borderWidth: 	an ObservableValueHolder[ nil ]
		borderColor: 	an ObservableValueHolder[ nil ]
		dragEnabled: 	an ObservableValueHolder[ false ]
		dropEnabled: 	an ObservableValueHolder[ false ]
		color: 	an ObservableValueHolder[ nil ]
		help: 	an ObservableValueHolder[ nil ]
		enabled: 	an ObservableValueHolder[ true ]
		wantsDrop: 	an ObservableValueHolder[ [ :transfer | self dropEnabled ] ]
		acceptDrop: 	an ObservableValueHolder[ [ :transfer | ] ]
		deferredActions: 	nil
		hasUnacceptedEdits: 	an ObservableValueHolder[ false ]
		selection: 	an ObservableValueHolder[ (1 to: 159) ]
		wantsVisualFeedback: 	an ObservableValueHolder[ true ]
		askBeforeDiscardingEdits: 	an ObservableValueHolder[ true ]
		text: 	an ObservableValueHolder[ '| visualizer |
visualizer := GraphVisualiz[..]
		actionToPerform: 	an ObservableValueHolder[ [ :txt |  ] ]
		readSelection: 	an ObservableValueHolder[ [ selection ] ]
		placeholder: 	an ObservableValueHolder[ '' ]
		contextMenu: 	an ObservableValueHolder[ [ (self menuActionsFor: text) asMenu[..]
		scrollValue: 	an ObservableValueHolder[ (0@0) ]
		editionContextMenu: 	an ObservableValueHolder[ true ]
		editable: 	an ObservableValueHolder[ true ]
		wrapWord: 	an ObservableValueHolder[ true ]
		undoRedoHistory: 	true
		wrapScrollBars: 	true
		propagateNaturalHeight: 	false
		propagateNaturalWidth: 	false
		scrollBarStyles: 	#()
		syntaxHighlight: 	an ObservableValueHolder[ true ]
		smartCharacters: 	an ObservableValueHolder[ true ]
		lineNumbers: 	an ObservableValueHolder[ true ]
		interactionModel: 	an ObservableValueHolder[ a StPlaygroundInteractionModel ]
		overrideContextMenu: 	true
		submitBlock: 	nil
		resetBlock: 	nil
		environment: 	nil
		systemNavigation: 	nil
		syntaxHighlightTheme: 	an ObservableValueHolder[ nil ]


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
		self announcer announce: (SpCodeWillBeEvaluatedAnnouncement newContent: aString).
[..]
	Arguments and temporary variables: 
		exception: 	Error
		handlerAction: 	[ :e |
		self announcer announce: (SpCodeEvaluationFailedAnn[..]
	Receiver's instance variables: 
		outerContext: 	SpCodePresenter>>evaluate:onCompileError:onError:
		compiledBlock: 	a CompiledBlock: [
		self announcer announce: (SpCodeWillBeE[..]
		numArgs: 	0
		receiver: 	a SpCodePresenter


SpCodePresenter>>evaluate:onCompileError:onError:
	Receiver: a SpCodePresenter
	Arguments and temporary variables: 
		receiver: 	nil
		result: 	nil
		oldBindings: 	a Dictionary()
		aString: 	'| visualizer |
visualizer := GraphVisualizer new.
visualizer visu[..]
		compileErrorBlock: 	[ ^ self ]
		errorBlock: 	[ :e | e pass ]
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicCodeAdapter)
		announcer: 	an Announcer
		owner: 	a StPlaygroundPagePresenter
		adapter: 	a SpMorphicCodeAdapter
		needRebuild: 	true
		eventHandler: 	a SpEventHandler
		application: 	nil
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ a KMCategory ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Code' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpAbstractWidgetLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		borderWidth: 	an ObservableValueHolder[ nil ]
		borderColor: 	an ObservableValueHolder[ nil ]
		dragEnabled: 	an ObservableValueHolder[ false ]
		dropEnabled: 	an ObservableValueHolder[ false ]
		color: 	an ObservableValueHolder[ nil ]
		help: 	an ObservableValueHolder[ nil ]
		enabled: 	an ObservableValueHolder[ true ]
		wantsDrop: 	an ObservableValueHolder[ [ :transfer | self dropEnabled ] ]
		acceptDrop: 	an ObservableValueHolder[ [ :transfer | ] ]
		deferredActions: 	nil
		hasUnacceptedEdits: 	an ObservableValueHolder[ false ]
		selection: 	an ObservableValueHolder[ (1 to: 159) ]
		wantsVisualFeedback: 	an ObservableValueHolder[ true ]
		askBeforeDiscardingEdits: 	an ObservableValueHolder[ true ]
		text: 	an ObservableValueHolder[ '| visualizer |
visualizer := GraphVisualiz[..]
		actionToPerform: 	an ObservableValueHolder[ [ :txt |  ] ]
		readSelection: 	an ObservableValueHolder[ [ selection ] ]
		placeholder: 	an ObservableValueHolder[ '' ]
		contextMenu: 	an ObservableValueHolder[ [ (self menuActionsFor: text) asMenu[..]
		scrollValue: 	an ObservableValueHolder[ (0@0) ]
		editionContextMenu: 	an ObservableValueHolder[ true ]
		editable: 	an ObservableValueHolder[ true ]
		wrapWord: 	an ObservableValueHolder[ true ]
		undoRedoHistory: 	true
		wrapScrollBars: 	true
		propagateNaturalHeight: 	false
		propagateNaturalWidth: 	false
		scrollBarStyles: 	#()
		syntaxHighlight: 	an ObservableValueHolder[ true ]
		smartCharacters: 	an ObservableValueHolder[ true ]
		lineNumbers: 	an ObservableValueHolder[ true ]
		interactionModel: 	an ObservableValueHolder[ a StPlaygroundInteractionModel ]
		overrideContextMenu: 	true
		submitBlock: 	nil
		resetBlock: 	nil
		environment: 	nil
		systemNavigation: 	nil
		syntaxHighlightTheme: 	an ObservableValueHolder[ nil ]


StPlaygroundPagePresenter>>doEvaluateAndGo
	Receiver: a StPlaygroundPagePresenter
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicBoxAdapter)
		announcer: 	an Announcer
		owner: 	a SpMillerColumnPresenter
		adapter: 	a SpMorphicBoxAdapter
		needRebuild: 	true
		eventHandler: 	nil
		application: 	a StPharoApplication
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ nil ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Untitled window' ]
		additionalSubpresentersMap: 	a Dictionary()
		layout: 	an ObservableValueHolder[ a SpBoxLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		text: 	a SpCodePresenter
		toolbar: 	a SpToolbarPresenter
		statusbar: 	a SpPresenter
		lineLabel: 	a SpLabelPresenter
		toggleLineNumberButton: 	a SpToggleButtonPresenter
		page: 	a StPlaygroundPage
		activationBlock: 	[ :selection |
		self changeSelection: selection from: new[..]


StPlaygroundPagePresenter>>doEvaluateAllAndGo
	Receiver: a StPlaygroundPagePresenter
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicBoxAdapter)
		announcer: 	an Announcer
		owner: 	a SpMillerColumnPresenter
		adapter: 	a SpMorphicBoxAdapter
		needRebuild: 	true
		eventHandler: 	nil
		application: 	a StPharoApplication
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ nil ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Untitled window' ]
		additionalSubpresentersMap: 	a Dictionary()
		layout: 	an ObservableValueHolder[ a SpBoxLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		text: 	a SpCodePresenter
		toolbar: 	a SpToolbarPresenter
		statusbar: 	a SpPresenter
		lineLabel: 	a SpLabelPresenter
		toggleLineNumberButton: 	a SpToggleButtonPresenter
		page: 	a StPlaygroundPage
		activationBlock: 	[ :selection |
		self changeSelection: selection from: new[..]


StPlaygroundDoItCommand>>execute
	Receiver: a StPlaygroundDoItCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		context: 	a StPlaygroundPagePresenter
		basicName: 	'Do it'
		basicDescription: 	'Do it all and inspect.'


SpCommand(CmCommandDecorator)>>execute
	Receiver: a SpCommand(Do it)
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a StPlaygroundDoItCommand
		iconProvider: 	a StPharoApplication
		iconName: 	#glamorousGo
		shortcutKey: 	nil
		displayStrategy: 	a CmUIDisableWhenCantBeRun
		positionStrategy: 	a CmUILeftPositionStrategy
		buildPresenterBlock: 	[ :specCommand | 
			aButtonClass new
				label: specC[..]
		presenter: 	a SpToolbarButtonPresenter


[ specCommand execute ] in [ :specCommand | 
			aButtonClass new
				label: specCommand name;
				help: specCommand description;
				in: [ :button | 
					specCommand hasIcon
						ifTrue: [ button icon: specCommand icon ] ];
				action: [ specCommand execute ];
				yourself ] in SpCommand>>configureAsButtonOfClass:
	Receiver: a SpCommand(Do it)
	Arguments and temporary variables: 
		aButtonClass: 	nil
		specCommand: 	a SpCommand(Do it)
	Receiver's instance variables: 
		decoratedCommand: 	a StPlaygroundDoItCommand
		iconProvider: 	a StPharoApplication
		iconName: 	#glamorousGo
		shortcutKey: 	nil
		displayStrategy: 	a CmUIDisableWhenCantBeRun
		positionStrategy: 	a CmUILeftPositionStrategy
		buildPresenterBlock: 	[ :specCommand | 
			aButtonClass new
				label: specC[..]
		presenter: 	a SpToolbarButtonPresenter


FullBlockClosure(BlockClosure)>>cull:
	Receiver: [ specCommand execute ]
	Arguments and temporary variables: 
		anArg: 	a SpToolbarButtonPresenter
	Receiver's instance variables: 
		outerContext: 	[ :specCommand | 
			aButtonClass new
				label: specCommand [..]
		compiledBlock: 	a CompiledBlock: [ specCommand execute ]
		numArgs: 	0
		receiver: 	a SpCommand(Do it)


SpMorphicToolbarButtonAdapter>>execute
	Receiver: a SpMorphicToolbarButtonAdapter
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpToolbarButtonMorph(163457024))
		announcer: 	nil
		model: 	a SpToolbarButtonPresenter
		widget: 	a SpToolbarButtonMorph(163457024)
		selector: 	nil
		owner: 	a SpToolbarButtonPresenter
		unsubscribed: 	false


SpToolbarButtonMorph(PluggableButtonMorph)>>performAction:
	Receiver: a SpToolbarButtonMorph(163457024)
	Arguments and temporary variables: 
		event: 	[(27.0@20.0) mouseUp 10978920 nil]
	Receiver's instance variables: 
		bounds: 	(0.0@5.0) corner: (45.0@39.0)
		owner: 	a Morph(543889152)
		submorphs: 	an Array(an AlignmentMorph(1048008448))
		fullBounds: 	nil
		color: 	(Color r: 0.9012707722385142 g: 0.9012707722385142 b: 0.901270772238[..]
		extension: 	a MorphExtension (606190080) [balloonText]  [other:  (presenter [..]
		borderWidth: 	0
		borderColor: 	#simple
		model: 	a SpMorphicToolbarButtonAdapter
		label: 	'Do it'
		icon: 	Form(13x13x32)
		getIconSelector: 	#icon
		getStateSelector: 	#state
		actionSelector: 	#execute
		font: 	a LogicalFont
 familyName: 'Source Sans Pro'
 emphasis: nil
 pointSiz[..]
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	nil
		getFontSelector: 	nil
		labelMorph: 	a LabelMorph(576130816)'Do it'
		iconMorph: 	an ImageMorph(527603200)
		iconPosition: 	#top
		lastState: 	false
		badgeFont: 	nil
		badgeSelector: 	#badge


[:m |
		(m containsPoint: evt cursorPoint) ifTrue: [m enabled ifTrue: [ m performAction: evt ]]] in SpToolbarButtonMorph(PluggableButtonMorph)>>mouseUp:
	Receiver: a SpToolbarButtonMorph(163457024)
	Arguments and temporary variables: 
		evt: 	[(27.0@20.0) mouseUp 10978920 nil]
		all: 	an Array(a SpToolbarButtonMorph(163457024) a SpToolbarButtonMorph(6416[..]
		m: 	a SpToolbarButtonMorph(163457024)
	Receiver's instance variables: 
		bounds: 	(0.0@5.0) corner: (45.0@39.0)
		owner: 	a Morph(543889152)
		submorphs: 	an Array(an AlignmentMorph(1048008448))
		fullBounds: 	nil
		color: 	(Color r: 0.9012707722385142 g: 0.9012707722385142 b: 0.901270772238[..]
		extension: 	a MorphExtension (606190080) [balloonText]  [other:  (presenter [..]
		borderWidth: 	0
		borderColor: 	#simple
		model: 	a SpMorphicToolbarButtonAdapter
		label: 	'Do it'
		icon: 	Form(13x13x32)
		getIconSelector: 	#icon
		getStateSelector: 	#state
		actionSelector: 	#execute
		font: 	a LogicalFont
 familyName: 'Source Sans Pro'
 emphasis: nil
 pointSiz[..]
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	nil
		getFontSelector: 	nil
		labelMorph: 	a LabelMorph(576130816)'Do it'
		iconMorph: 	an ImageMorph(527603200)
		iconPosition: 	#top
		lastState: 	false
		badgeFont: 	nil
		badgeSelector: 	#badge


Array(SequenceableCollection)>>do:
	Receiver: an Array(a SpToolbarButtonMorph(163457024) a SpToolbarButtonMorph(641645312) a SpToolb[..]
	Arguments and temporary variables: 
		aBlock: 	[:m |
		(m containsPoint: evt cursorPoint) ifTrue: [m enabled ifTru[..]
		index: 	1
	Receiver's instance variables: 
an Array(a SpToolbarButtonMorph(163457024) a SpToolbarButtonMorph(641645312) a SpToolb[..]

SpToolbarButtonMorph(PluggableButtonMorph)>>mouseUp:
	Receiver: a SpToolbarButtonMorph(163457024)
	Arguments and temporary variables: 
		evt: 	[(27.0@20.0) mouseUp 10978920 nil]
		all: 	an Array(a SpToolbarButtonMorph(163457024) a SpToolbarButtonMorph(6416[..]
	Receiver's instance variables: 
		bounds: 	(0.0@5.0) corner: (45.0@39.0)
		owner: 	a Morph(543889152)
		submorphs: 	an Array(an AlignmentMorph(1048008448))
		fullBounds: 	nil
		color: 	(Color r: 0.9012707722385142 g: 0.9012707722385142 b: 0.901270772238[..]
		extension: 	a MorphExtension (606190080) [balloonText]  [other:  (presenter [..]
		borderWidth: 	0
		borderColor: 	#simple
		model: 	a SpMorphicToolbarButtonAdapter
		label: 	'Do it'
		icon: 	Form(13x13x32)
		getIconSelector: 	#icon
		getStateSelector: 	#state
		actionSelector: 	#execute
		font: 	a LogicalFont
 familyName: 'Source Sans Pro'
 emphasis: nil
 pointSiz[..]
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	nil
		getFontSelector: 	nil
		labelMorph: 	a LabelMorph(576130816)'Do it'
		iconMorph: 	an ImageMorph(527603200)
		iconPosition: 	#top
		lastState: 	false
		badgeFont: 	nil
		badgeSelector: 	#badge


SpToolbarButtonMorph(Morph)>>handleMouseUp:
	Receiver: a SpToolbarButtonMorph(163457024)
	Arguments and temporary variables: 
		anEvent: 	[(27.0@20.0) mouseUp 10978920 nil]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(0.0@5.0) corner: (45.0@39.0)
		owner: 	a Morph(543889152)
		submorphs: 	an Array(an AlignmentMorph(1048008448))
		fullBounds: 	nil
		color: 	(Color r: 0.9012707722385142 g: 0.9012707722385142 b: 0.901270772238[..]
		extension: 	a MorphExtension (606190080) [balloonText]  [other:  (presenter [..]
		borderWidth: 	0
		borderColor: 	#simple
		model: 	a SpMorphicToolbarButtonAdapter
		label: 	'Do it'
		icon: 	Form(13x13x32)
		getIconSelector: 	#icon
		getStateSelector: 	#state
		actionSelector: 	#execute
		font: 	a LogicalFont
 familyName: 'Source Sans Pro'
 emphasis: nil
 pointSiz[..]
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	nil
		getFontSelector: 	nil
		labelMorph: 	a LabelMorph(576130816)'Do it'
		iconMorph: 	an ImageMorph(527603200)
		iconPosition: 	#top
		lastState: 	false
		badgeFont: 	nil
		badgeSelector: 	#badge


MouseButtonEvent>>sentTo:
	Receiver: [(27.0@20.0) mouseUp 10978920 nil]
	Arguments and temporary variables: 
		anObject: 	a SpToolbarButtonMorph(163457024)
	Receiver's instance variables: 
		timeStamp: 	10978920
		source: 	a HandMorph(337424384)
		windowIndex: 	nil
		type: 	#mouseUp
		buttons: 	0
		position: 	(27.0@20.0)
		handler: 	nil
		wasHandled: 	true
		whichButton: 	4


SpToolbarButtonMorph(Morph)>>handleEvent:
	Receiver: a SpToolbarButtonMorph(163457024)
	Arguments and temporary variables: 
		anEvent: 	[(27.0@20.0) mouseUp 10978920 nil]
	Receiver's instance variables: 
		bounds: 	(0.0@5.0) corner: (45.0@39.0)
		owner: 	a Morph(543889152)
		submorphs: 	an Array(an AlignmentMorph(1048008448))
		fullBounds: 	nil
		color: 	(Color r: 0.9012707722385142 g: 0.9012707722385142 b: 0.901270772238[..]
		extension: 	a MorphExtension (606190080) [balloonText]  [other:  (presenter [..]
		borderWidth: 	0
		borderColor: 	#simple
		model: 	a SpMorphicToolbarButtonAdapter
		label: 	'Do it'
		icon: 	Form(13x13x32)
		getIconSelector: 	#icon
		getStateSelector: 	#state
		actionSelector: 	#execute
		font: 	a LogicalFont
 familyName: 'Source Sans Pro'
 emphasis: nil
 pointSiz[..]
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	nil
		getFontSelector: 	nil
		labelMorph: 	a LabelMorph(576130816)'Do it'
		iconMorph: 	an ImageMorph(527603200)
		iconPosition: 	#top
		lastState: 	false
		badgeFont: 	nil
		badgeSelector: 	#badge


SpToolbarButtonMorph(Morph)>>handleFocusEvent:
	Receiver: a SpToolbarButtonMorph(163457024)
	Arguments and temporary variables: 
		anEvent: 	[(27.0@20.0) mouseUp 10978920 nil]
	Receiver's instance variables: 
		bounds: 	(0.0@5.0) corner: (45.0@39.0)
		owner: 	a Morph(543889152)
		submorphs: 	an Array(an AlignmentMorph(1048008448))
		fullBounds: 	nil
		color: 	(Color r: 0.9012707722385142 g: 0.9012707722385142 b: 0.901270772238[..]
		extension: 	a MorphExtension (606190080) [balloonText]  [other:  (presenter [..]
		borderWidth: 	0
		borderColor: 	#simple
		model: 	a SpMorphicToolbarButtonAdapter
		label: 	'Do it'
		icon: 	Form(13x13x32)
		getIconSelector: 	#icon
		getStateSelector: 	#state
		actionSelector: 	#execute
		font: 	a LogicalFont
 familyName: 'Source Sans Pro'
 emphasis: nil
 pointSiz[..]
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	nil
		getFontSelector: 	nil
		labelMorph: 	a LabelMorph(576130816)'Do it'
		iconMorph: 	an ImageMorph(527603200)
		iconPosition: 	#top
		lastState: 	false
		badgeFont: 	nil
		badgeSelector: 	#badge


[
		result := focusHolder handleFocusEvent: transformedEvent.
	] in HandMorph>>sendFocusEvent:to:clear:
	Receiver: a HandMorph(337424384)
	Arguments and temporary variables: 
		anEvent: 	[(219@271) mouseUp 10978920 nil]
		focusHolder: 	a SpToolbarButtonMorph(163457024)
		aBlock: 	[self mouseFocus: nil]
		w: 	a WorldMorph(341720576) [world]
		transformedEvent: 	[(27.0@20.0) mouseUp 10978920 nil]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(219@271.0) corner: (235@287.0)
		owner: 	a WorldMorph(341720576) [world]
		submorphs: 	#()
		fullBounds: 	(219@271.0) corner: (235@287.0)
		color: 	Color blue
		extension: 	a MorphExtension (370611968)
		mouseFocus: 	nil
		keyboardFocus: 	a RubEditingArea(143191808)
		eventListeners: 	nil
		mouseListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(219@271) mouseUp 10978920 nil]
		targetOffset: 	(27.0@15.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 0 0 0 0 0 nil nil)
		captureBlock: 	nil
		recentModifiers: 	0
		pendingEventQueue: 	WaitfreeQueue with 0 items
		supressNextKeyPress: 	true


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
		result := focusHolder handleFocusEvent: transformedEvent.
	]
	Arguments and temporary variables: 
		exception: 	Error
		handlerAction: 	[ :ex |
			ActiveWorld := priorWorld.
			ex pass ]
	Receiver's instance variables: 
		outerContext: 	HandMorph>>sendFocusEvent:to:clear:
		compiledBlock: 	a CompiledBlock: [
		result := focusHolder handleFocusEvent:[..]
		numArgs: 	0
		receiver: 	a HandMorph(337424384)


WorldMorph>>becomeActiveDuring:
	Receiver: a WorldMorph(341720576) [world]
	Arguments and temporary variables: 
		aBlock: 	[
		result := focusHolder handleFocusEvent: transformedEvent.
	]
		priorWorld: 	a WorldMorph(341720576) [world]
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1728@1080)
		owner: 	nil
		submorphs: 	an Array(a MenubarMorph(112886016) a TaskbarMorph(279458560) a S[..]
		fullBounds: 	(0@0) corner: (1728@1080)
		color: 	(Color r: 0.9403714565004888 g: 0.9403714565004888 b: 0.940371456500[..]
		extension: 	a MorphExtension (1012946432) [other:  (dragEnabled -> true) (dr[..]
		borderWidth: 	0
		borderColor: 	(Color r: 0.8611925708699902 g: 1.0 b: 0.7223851417399805 alph[..]
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil


HandMorph>>sendFocusEvent:to:clear:
	Receiver: a HandMorph(337424384)
	Arguments and temporary variables: 
		result: 	nil
		anEvent: 	[(219@271) mouseUp 10978920 nil]
		focusHolder: 	a SpToolbarButtonMorph(163457024)
		aBlock: 	[self mouseFocus: nil]
		w: 	a WorldMorph(341720576) [world]
		transformedEvent: 	[(27.0@20.0) mouseUp 10978920 nil]
	Receiver's instance variables: 
		bounds: 	(219@271.0) corner: (235@287.0)
		owner: 	a WorldMorph(341720576) [world]
		submorphs: 	#()
		fullBounds: 	(219@271.0) corner: (235@287.0)
		color: 	Color blue
		extension: 	a MorphExtension (370611968)
		mouseFocus: 	nil
		keyboardFocus: 	a RubEditingArea(143191808)
		eventListeners: 	nil
		mouseListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(219@271) mouseUp 10978920 nil]
		targetOffset: 	(27.0@15.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 0 0 0 0 0 nil nil)
		captureBlock: 	nil
		recentModifiers: 	0
		pendingEventQueue: 	WaitfreeQueue with 0 items
		supressNextKeyPress: 	true


HandMorph>>sendEvent:focus:clear:
	Receiver: a HandMorph(337424384)
	Arguments and temporary variables: 
		anEvent: 	[(219@271) mouseUp 10978920 nil]
		focusHolder: 	a SpToolbarButtonMorph(163457024)
		aBlock: 	[self mouseFocus: nil]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(219@271.0) corner: (235@287.0)
		owner: 	a WorldMorph(341720576) [world]
		submorphs: 	#()
		fullBounds: 	(219@271.0) corner: (235@287.0)
		color: 	Color blue
		extension: 	a MorphExtension (370611968)
		mouseFocus: 	nil
		keyboardFocus: 	a RubEditingArea(143191808)
		eventListeners: 	nil
		mouseListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(219@271) mouseUp 10978920 nil]
		targetOffset: 	(27.0@15.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 0 0 0 0 0 nil nil)
		captureBlock: 	nil
		recentModifiers: 	0
		pendingEventQueue: 	WaitfreeQueue with 0 items
		supressNextKeyPress: 	true


HandMorph>>sendMouseEvent:
	Receiver: a HandMorph(337424384)
	Arguments and temporary variables: 
		anEvent: 	[(219@271) mouseUp 10978920 nil]
	Receiver's instance variables: 
		bounds: 	(219@271.0) corner: (235@287.0)
		owner: 	a WorldMorph(341720576) [world]
		submorphs: 	#()
		fullBounds: 	(219@271.0) corner: (235@287.0)
		color: 	Color blue
		extension: 	a MorphExtension (370611968)
		mouseFocus: 	nil
		keyboardFocus: 	a RubEditingArea(143191808)
		eventListeners: 	nil
		mouseListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(219@271) mouseUp 10978920 nil]
		targetOffset: 	(27.0@15.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 0 0 0 0 0 nil nil)
		captureBlock: 	nil
		recentModifiers: 	0
		pendingEventQueue: 	WaitfreeQueue with 0 items
		supressNextKeyPress: 	true


HandMorph>>handleEvent:
	Receiver: a HandMorph(337424384)
	Arguments and temporary variables: 
		anEvent: 	[(219@271) mouseUp 10978920 nil]
		evt: 	[(219@271) mouseUp 10978920 nil]
	Receiver's instance variables: 
		bounds: 	(219@271.0) corner: (235@287.0)
		owner: 	a WorldMorph(341720576) [world]
		submorphs: 	#()
		fullBounds: 	(219@271.0) corner: (235@287.0)
		color: 	Color blue
		extension: 	a MorphExtension (370611968)
		mouseFocus: 	nil
		keyboardFocus: 	a RubEditingArea(143191808)
		eventListeners: 	nil
		mouseListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(219@271) mouseUp 10978920 nil]
		targetOffset: 	(27.0@15.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 0 0 0 0 0 nil nil)
		captureBlock: 	nil
		recentModifiers: 	0
		pendingEventQueue: 	WaitfreeQueue with 0 items
		supressNextKeyPress: 	true


[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil ]) ifTrue: [
			morphicWorld activeHand handleEvent: anEvent
		]
	] in OSWindowMorphicEventHandler>>dispatchMorphicEvent:
	Receiver: an OSWindowMorphicEventHandler
	Arguments and temporary variables: 
		anEvent: 	[(219@271) mouseUp 10978920 nil]
	Receiver's instance variables: 
		morphicWorld: 	a WorldMorph(341720576) [world]


WorldState>>runStepMethodsIn:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(341720576) [world]
		queue: 	WaitfreeQueue with 0 items
		nextInQueue: 	[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNo[..]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(337424384))
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap()
		lastStepTime: 	10975278
		lastStepMessage: 	nil
		alarms: 	a Heap(MorphicAlarm(#hideShow -> a RubCursor(27124480)))
		lastAlarmTime: 	10978899
		activeHand: 	a HandMorph(337424384)
		currentCursor: 	((CursorWithMask
	extent: (16@16)
	depth: 1
	fromArray: #(
	[..]
		worldRenderer: 	an OSWorldRenderer
		realWindowExtent: 	(1728@1080)
		deferredUIMessages: 	WaitfreeQueue with 0 items


WorldMorph>>runStepMethods
	Receiver: a WorldMorph(341720576) [world]
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1728@1080)
		owner: 	nil
		submorphs: 	an Array(a MenubarMorph(112886016) a TaskbarMorph(279458560) a S[..]
		fullBounds: 	(0@0) corner: (1728@1080)
		color: 	(Color r: 0.9403714565004888 g: 0.9403714565004888 b: 0.940371456500[..]
		extension: 	a MorphExtension (1012946432) [other:  (dragEnabled -> true) (dr[..]
		borderWidth: 	0
		borderColor: 	(Color r: 0.8611925708699902 g: 1.0 b: 0.7223851417399805 alph[..]
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil


WorldState>>doOneCycleFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(341720576) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(337424384))
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap()
		lastStepTime: 	10975278
		lastStepMessage: 	nil
		alarms: 	a Heap(MorphicAlarm(#hideShow -> a RubCursor(27124480)))
		lastAlarmTime: 	10978899
		activeHand: 	a HandMorph(337424384)
		currentCursor: 	((CursorWithMask
	extent: (16@16)
	depth: 1
	fromArray: #(
	[..]
		worldRenderer: 	an OSWorldRenderer
		realWindowExtent: 	(1728@1080)
		deferredUIMessages: 	WaitfreeQueue with 0 items


WorldMorph>>doOneCycleNow
	Receiver: a WorldMorph(341720576) [world]
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1728@1080)
		owner: 	nil
		submorphs: 	an Array(a MenubarMorph(112886016) a TaskbarMorph(279458560) a S[..]
		fullBounds: 	(0@0) corner: (1728@1080)
		color: 	(Color r: 0.9403714565004888 g: 0.9403714565004888 b: 0.940371456500[..]
		extension: 	a MorphExtension (1012946432) [other:  (dragEnabled -> true) (dr[..]
		borderWidth: 	0
		borderColor: 	(Color r: 0.8611925708699902 g: 1.0 b: 0.7223851417399805 alph[..]
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil



--- The full stack ---
UndefinedObject(Object)>>doesNotUnderstand: #add:
UndefinedObject>>doesNotUnderstand: #add:
[ :nodeDict |
        | node |
        node := RSBox new size: 20; color: Color blue.
        node canvas add: node.
        nodesMap at: (nodeDict at: #id) put: node.
    ] in GraphVisualizer>>createNodes
Array(SequenceableCollection)>>do:
GraphVisualizer>>createNodes
GraphVisualizer>>visualizeGraphFromFile:
UndefinedObject>>DoIt
OCReceiverDoItSemanticScope(OCDoItSemanticScope)>>evaluateDoIt:
OpalCompiler>>evaluate
[
		self announcer announce: (SpCodeWillBeEvaluatedAnnouncement newContent: aString).
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionModel doItReceiver.
		result := receiver class compiler
			source: aString;
			context: self interactionModel doItContext;
			receiver: self interactionModel doItReceiver;
			requestor: self interactionModel;
			environment: self environment;
			failBlock:  [ 
				self announcer announce: (SpCodeEvaluationFailedAnnouncement newContent: aString).
				^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		self announcer announce: (SpCodeEvaluationSucceedAnnouncement newContent: aString).
		result ] in SpCodePresenter>>evaluate:onCompileError:onError:
FullBlockClosure(BlockClosure)>>on:do:
SpCodePresenter>>evaluate:onCompileError:onError:
StPlaygroundPagePresenter>>doEvaluateAndGo
StPlaygroundPagePresenter>>doEvaluateAllAndGo
StPlaygroundDoItCommand>>execute
SpCommand(CmCommandDecorator)>>execute
[ specCommand execute ] in [ :specCommand | 
			aButtonClass new
				label: specCommand name;
				help: specCommand description;
				in: [ :button | 
					specCommand hasIcon
						ifTrue: [ button icon: specCommand icon ] ];
				action: [ specCommand execute ];
				yourself ] in SpCommand>>configureAsButtonOfClass:
FullBlockClosure(BlockClosure)>>cull:
SpMorphicToolbarButtonAdapter>>execute
SpToolbarButtonMorph(PluggableButtonMorph)>>performAction:
[:m |
		(m containsPoint: evt cursorPoint) ifTrue: [m enabled ifTrue: [ m performAction: evt ]]] in SpToolbarButtonMorph(PluggableButtonMorph)>>mouseUp:
Array(SequenceableCollection)>>do:
SpToolbarButtonMorph(PluggableButtonMorph)>>mouseUp:
SpToolbarButtonMorph(Morph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
SpToolbarButtonMorph(Morph)>>handleEvent:
SpToolbarButtonMorph(Morph)>>handleFocusEvent:
[
		result := focusHolder handleFocusEvent: transformedEvent.
	] in HandMorph>>sendFocusEvent:to:clear:
FullBlockClosure(BlockClosure)>>on:do:
WorldMorph>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil ]) ifTrue: [
			morphicWorld activeHand handleEvent: anEvent
		]
	] in OSWindowMorphicEventHandler>>dispatchMorphicEvent:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycleNow
 - - - - - - - - - - - - - - -
			- - - - - - - - - - - - - - - - - -
WorldMorph>>doOneCycle
[
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMutex critical: [
			                     self extraWorldList ].
		extraWorldsToDraw do: [ :world | world doOneCycle ].

		(self currentWorld isNotNil and: [
			 (extraWorldsToDraw includes: self currentWorld) not ]) ifTrue: [
			self currentWorld doOneCycle ] ] in WorldMorph class>>doOneCycle
FullBlockClosure(BlockClosure)>>ensure:
WorldState class>>doDrawCycleWith:
WorldMorph class>>doOneCycle
MorphicRenderLoop>>doOneCycle
MorphicRenderLoop>>doOneCycleWhile:
[ MorphicRenderLoop new doOneCycleWhile: [ true ] ] in MorphicUIManager>>spawnNewProcess
[self value.
			"IMPORTANT: Do not step over next line of code. See method comments for details"
			Processor terminateRealActive] in FullBlockClosure(BlockClosure)>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
Instance of RSBox did not understand #center
13 November 2023 7:14:10.434558 pm

VM: Mac OS - arm64 - 1000 - CoInterpreter VMMaker-tonel.1 uuid: 902dd483-c0c4-0d00-86f2-0f880df24b96 Oct 23 2023
StackToRegisterMappingCogit VMMaker-tonel.1 uuid: 902dd483-c0c4-0d00-86f2-0f880df24b96 Oct 23 2023
v10.0.8 - Commit: b323c5fb - Date: 2023-10-20 16:02:07 -0400

Image: Pharo11.0.0 [Build information: Pharo-11.0.0+build.710.sha.ea28d8552cac85a7ce1e9c34ab1e7bd45f7b9910 (64 Bit)]

RSBox(Object)>>doesNotUnderstand: #center
	Receiver: a RSBox
	Arguments and temporary variables: 
		aMessage: 	center
		exception: 	Instance of RSBox did not understand #center
		resumeValue: 	nil
	Receiver's instance variables: 
		announcer: 	nil
		properties: 	nil
		paint: 	Color blue
		path: 	(-10.0@ -10.0) corner: (10.0@10.0)
		border: 	nil
		parent: 	a RSCanvas
		isFixed: 	false
		encompassingRectangle: 	nil
		model: 	nil
		baseRectangle: 	(-10.0@ -10.0) corner: (10.0@10.0)
		matrix: 	x: 0.0 y: 0.0 sx: 1.0 sy: 1.0 shx: 0.0 shy: 0.0
		connectedLines: 	nil
		shouldUpdateLines: 	true
		cornerRadius: 	nil


[ :edgeDict |
        | edge sourceNode targetNode |
        sourceNode := nodesMap at: (edgeDict at: #source) ifAbsent: [ nil ].
        targetNode := nodesMap at: (edgeDict at: #target) ifAbsent: [ nil ].
        sourceNode ifNotNil: [ targetNode ifNotNil: [
            edge := RSLine new from: sourceNode center to: targetNode center.
            edge canvas add: edge.
        ]].
    ] in GraphVisualizer>>createEdges
	Receiver: a GraphVisualizer
	Arguments and temporary variables: 
		edgeDict: 	a Dictionary('source'->1 'target'->2 'type'->'FRIENDS_WITH' )
		edge: 	nil
		sourceNode: 	a RSBox
		targetNode: 	a RSBox
	Receiver's instance variables: 
		view: 	nil
		nodes: 	an Array(a Dictionary('id'->1 'label'->'Person' 'properties'->a Dict[..]
		edges: 	an Array(a Dictionary('source'->1 'target'->2 'type'->'FRIENDS_WITH' ))
		nodesMap: 	a Dictionary(1->a RSBox 2->a RSBox )
		canvas: 	a RSCanvas


Array(SequenceableCollection)>>do:
	Receiver: an Array(a Dictionary('source'->1 'target'->2 'type'->'FRIENDS_WITH' ))
	Arguments and temporary variables: 
		aBlock: 	[ :edgeDict |
        | edge sourceNode targetNode |
        source[..]
		index: 	1
	Receiver's instance variables: 
an Array(a Dictionary('source'->1 'target'->2 'type'->'FRIENDS_WITH' ))

GraphVisualizer>>createEdges
	Receiver: a GraphVisualizer
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		view: 	nil
		nodes: 	an Array(a Dictionary('id'->1 'label'->'Person' 'properties'->a Dict[..]
		edges: 	an Array(a Dictionary('source'->1 'target'->2 'type'->'FRIENDS_WITH' ))
		nodesMap: 	a Dictionary(1->a RSBox 2->a RSBox )
		canvas: 	a RSCanvas


GraphVisualizer>>visualizeGraphFromFile:
	Receiver: a GraphVisualizer
	Arguments and temporary variables: 
		aFilePath: 	'/Users/ryanperez/Documents/GitHub/pp-rep2533/project/src/data/t[..]
	Receiver's instance variables: 
		view: 	nil
		nodes: 	an Array(a Dictionary('id'->1 'label'->'Person' 'properties'->a Dict[..]
		edges: 	an Array(a Dictionary('source'->1 'target'->2 'type'->'FRIENDS_WITH' ))
		nodesMap: 	a Dictionary(1->a RSBox 2->a RSBox )
		canvas: 	a RSCanvas


UndefinedObject>>DoIt
	Receiver: nil
	Arguments and temporary variables: 
		visualizer: 	a GraphVisualizer
	Receiver's instance variables: 
nil

OCReceiverDoItSemanticScope(OCDoItSemanticScope)>>evaluateDoIt:
	Receiver: an OCReceiverDoItSemanticScope
	Arguments and temporary variables: 
		doItMethod: 	UndefinedObject>>#DoIt
	Receiver's instance variables: 
		outerScope: 	nil
		targetReceiver: 	nil


OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
		doItMethod: 	UndefinedObject>>#DoIt
	Receiver's instance variables: 
		ast: 	DoIt

	| visualizer |
	visualizer := GraphVisualizer new.
	^ visualize[..]
		source: 	a ReadStream
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil


[
		self announcer announce: (SpCodeWillBeEvaluatedAnnouncement newContent: aString).
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionModel doItReceiver.
		result := receiver class compiler
			source: aString;
			context: self interactionModel doItContext;
			receiver: self interactionModel doItReceiver;
			requestor: self interactionModel;
			environment: self environment;
			failBlock:  [ 
				self announcer announce: (SpCodeEvaluationFailedAnnouncement newContent: aString).
				^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		self announcer announce: (SpCodeEvaluationSucceedAnnouncement newContent: aString).
		result ] in SpCodePresenter>>evaluate:onCompileError:onError:
	Receiver: a SpCodePresenter
	Arguments and temporary variables: 
		aString: 	'| visualizer |
visualizer := GraphVisualizer new.
visualizer visu[..]
		compileErrorBlock: 	[ ^ self ]
		errorBlock: 	[ :e | e pass ]
		receiver: 	nil
		result: 	nil
		oldBindings: 	a Dictionary()
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicCodeAdapter)
		announcer: 	an Announcer
		owner: 	a StPlaygroundPagePresenter
		adapter: 	a SpMorphicCodeAdapter
		needRebuild: 	true
		eventHandler: 	a SpEventHandler
		application: 	nil
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ a KMCategory ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Code' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpAbstractWidgetLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		borderWidth: 	an ObservableValueHolder[ nil ]
		borderColor: 	an ObservableValueHolder[ nil ]
		dragEnabled: 	an ObservableValueHolder[ false ]
		dropEnabled: 	an ObservableValueHolder[ false ]
		color: 	an ObservableValueHolder[ nil ]
		help: 	an ObservableValueHolder[ nil ]
		enabled: 	an ObservableValueHolder[ true ]
		wantsDrop: 	an ObservableValueHolder[ [ :transfer | self dropEnabled ] ]
		acceptDrop: 	an ObservableValueHolder[ [ :transfer | ] ]
		deferredActions: 	nil
		hasUnacceptedEdits: 	an ObservableValueHolder[ false ]
		selection: 	an ObservableValueHolder[ (1 to: 159) ]
		wantsVisualFeedback: 	an ObservableValueHolder[ true ]
		askBeforeDiscardingEdits: 	an ObservableValueHolder[ true ]
		text: 	an ObservableValueHolder[ '| visualizer |
visualizer := GraphVisualiz[..]
		actionToPerform: 	an ObservableValueHolder[ [ :txt |  ] ]
		readSelection: 	an ObservableValueHolder[ [ selection ] ]
		placeholder: 	an ObservableValueHolder[ '' ]
		contextMenu: 	an ObservableValueHolder[ [ (self menuActionsFor: text) asMenu[..]
		scrollValue: 	an ObservableValueHolder[ (0@0) ]
		editionContextMenu: 	an ObservableValueHolder[ true ]
		editable: 	an ObservableValueHolder[ true ]
		wrapWord: 	an ObservableValueHolder[ true ]
		undoRedoHistory: 	true
		wrapScrollBars: 	true
		propagateNaturalHeight: 	false
		propagateNaturalWidth: 	false
		scrollBarStyles: 	#()
		syntaxHighlight: 	an ObservableValueHolder[ true ]
		smartCharacters: 	an ObservableValueHolder[ true ]
		lineNumbers: 	an ObservableValueHolder[ true ]
		interactionModel: 	an ObservableValueHolder[ a StPlaygroundInteractionModel ]
		overrideContextMenu: 	true
		submitBlock: 	nil
		resetBlock: 	nil
		environment: 	nil
		systemNavigation: 	nil
		syntaxHighlightTheme: 	an ObservableValueHolder[ nil ]


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
		self announcer announce: (SpCodeWillBeEvaluatedAnnouncement newContent: aString).
[..]
	Arguments and temporary variables: 
		exception: 	Error
		handlerAction: 	[ :e |
		self announcer announce: (SpCodeEvaluationFailedAnn[..]
	Receiver's instance variables: 
		outerContext: 	SpCodePresenter>>evaluate:onCompileError:onError:
		compiledBlock: 	a CompiledBlock: [
		self announcer announce: (SpCodeWillBeE[..]
		numArgs: 	0
		receiver: 	a SpCodePresenter


SpCodePresenter>>evaluate:onCompileError:onError:
	Receiver: a SpCodePresenter
	Arguments and temporary variables: 
		receiver: 	nil
		result: 	nil
		oldBindings: 	a Dictionary()
		aString: 	'| visualizer |
visualizer := GraphVisualizer new.
visualizer visu[..]
		compileErrorBlock: 	[ ^ self ]
		errorBlock: 	[ :e | e pass ]
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicCodeAdapter)
		announcer: 	an Announcer
		owner: 	a StPlaygroundPagePresenter
		adapter: 	a SpMorphicCodeAdapter
		needRebuild: 	true
		eventHandler: 	a SpEventHandler
		application: 	nil
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ a KMCategory ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Code' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpAbstractWidgetLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		borderWidth: 	an ObservableValueHolder[ nil ]
		borderColor: 	an ObservableValueHolder[ nil ]
		dragEnabled: 	an ObservableValueHolder[ false ]
		dropEnabled: 	an ObservableValueHolder[ false ]
		color: 	an ObservableValueHolder[ nil ]
		help: 	an ObservableValueHolder[ nil ]
		enabled: 	an ObservableValueHolder[ true ]
		wantsDrop: 	an ObservableValueHolder[ [ :transfer | self dropEnabled ] ]
		acceptDrop: 	an ObservableValueHolder[ [ :transfer | ] ]
		deferredActions: 	nil
		hasUnacceptedEdits: 	an ObservableValueHolder[ false ]
		selection: 	an ObservableValueHolder[ (1 to: 159) ]
		wantsVisualFeedback: 	an ObservableValueHolder[ true ]
		askBeforeDiscardingEdits: 	an ObservableValueHolder[ true ]
		text: 	an ObservableValueHolder[ '| visualizer |
visualizer := GraphVisualiz[..]
		actionToPerform: 	an ObservableValueHolder[ [ :txt |  ] ]
		readSelection: 	an ObservableValueHolder[ [ selection ] ]
		placeholder: 	an ObservableValueHolder[ '' ]
		contextMenu: 	an ObservableValueHolder[ [ (self menuActionsFor: text) asMenu[..]
		scrollValue: 	an ObservableValueHolder[ (0@0) ]
		editionContextMenu: 	an ObservableValueHolder[ true ]
		editable: 	an ObservableValueHolder[ true ]
		wrapWord: 	an ObservableValueHolder[ true ]
		undoRedoHistory: 	true
		wrapScrollBars: 	true
		propagateNaturalHeight: 	false
		propagateNaturalWidth: 	false
		scrollBarStyles: 	#()
		syntaxHighlight: 	an ObservableValueHolder[ true ]
		smartCharacters: 	an ObservableValueHolder[ true ]
		lineNumbers: 	an ObservableValueHolder[ true ]
		interactionModel: 	an ObservableValueHolder[ a StPlaygroundInteractionModel ]
		overrideContextMenu: 	true
		submitBlock: 	nil
		resetBlock: 	nil
		environment: 	nil
		systemNavigation: 	nil
		syntaxHighlightTheme: 	an ObservableValueHolder[ nil ]


StPlaygroundPagePresenter>>doEvaluateAndGo
	Receiver: a StPlaygroundPagePresenter
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicBoxAdapter)
		announcer: 	an Announcer
		owner: 	a SpMillerColumnPresenter
		adapter: 	a SpMorphicBoxAdapter
		needRebuild: 	true
		eventHandler: 	nil
		application: 	a StPharoApplication
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ nil ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Untitled window' ]
		additionalSubpresentersMap: 	a Dictionary()
		layout: 	an ObservableValueHolder[ a SpBoxLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		text: 	a SpCodePresenter
		toolbar: 	a SpToolbarPresenter
		statusbar: 	a SpPresenter
		lineLabel: 	a SpLabelPresenter
		toggleLineNumberButton: 	a SpToggleButtonPresenter
		page: 	a StPlaygroundPage
		activationBlock: 	[ :selection |
		self changeSelection: selection from: new[..]


StPlaygroundPagePresenter>>doEvaluateAllAndGo
	Receiver: a StPlaygroundPagePresenter
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicBoxAdapter)
		announcer: 	an Announcer
		owner: 	a SpMillerColumnPresenter
		adapter: 	a SpMorphicBoxAdapter
		needRebuild: 	true
		eventHandler: 	nil
		application: 	a StPharoApplication
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ nil ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Untitled window' ]
		additionalSubpresentersMap: 	a Dictionary()
		layout: 	an ObservableValueHolder[ a SpBoxLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		text: 	a SpCodePresenter
		toolbar: 	a SpToolbarPresenter
		statusbar: 	a SpPresenter
		lineLabel: 	a SpLabelPresenter
		toggleLineNumberButton: 	a SpToggleButtonPresenter
		page: 	a StPlaygroundPage
		activationBlock: 	[ :selection |
		self changeSelection: selection from: new[..]


StPlaygroundDoItCommand>>execute
	Receiver: a StPlaygroundDoItCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		context: 	a StPlaygroundPagePresenter
		basicName: 	'Do it'
		basicDescription: 	'Do it all and inspect.'


SpCommand(CmCommandDecorator)>>execute
	Receiver: a SpCommand(Do it)
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a StPlaygroundDoItCommand
		iconProvider: 	a StPharoApplication
		iconName: 	#glamorousGo
		shortcutKey: 	nil
		displayStrategy: 	a CmUIDisableWhenCantBeRun
		positionStrategy: 	a CmUILeftPositionStrategy
		buildPresenterBlock: 	[ :specCommand | 
			aButtonClass new
				label: specC[..]
		presenter: 	a SpToolbarButtonPresenter


[ specCommand execute ] in [ :specCommand | 
			aButtonClass new
				label: specCommand name;
				help: specCommand description;
				in: [ :button | 
					specCommand hasIcon
						ifTrue: [ button icon: specCommand icon ] ];
				action: [ specCommand execute ];
				yourself ] in SpCommand>>configureAsButtonOfClass:
	Receiver: a SpCommand(Do it)
	Arguments and temporary variables: 
		aButtonClass: 	nil
		specCommand: 	a SpCommand(Do it)
	Receiver's instance variables: 
		decoratedCommand: 	a StPlaygroundDoItCommand
		iconProvider: 	a StPharoApplication
		iconName: 	#glamorousGo
		shortcutKey: 	nil
		displayStrategy: 	a CmUIDisableWhenCantBeRun
		positionStrategy: 	a CmUILeftPositionStrategy
		buildPresenterBlock: 	[ :specCommand | 
			aButtonClass new
				label: specC[..]
		presenter: 	a SpToolbarButtonPresenter


FullBlockClosure(BlockClosure)>>cull:
	Receiver: [ specCommand execute ]
	Arguments and temporary variables: 
		anArg: 	a SpToolbarButtonPresenter
	Receiver's instance variables: 
		outerContext: 	[ :specCommand | 
			aButtonClass new
				label: specCommand [..]
		compiledBlock: 	a CompiledBlock: [ specCommand execute ]
		numArgs: 	0
		receiver: 	a SpCommand(Do it)


SpMorphicToolbarButtonAdapter>>execute
	Receiver: a SpMorphicToolbarButtonAdapter
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpToolbarButtonMorph(163457024))
		announcer: 	nil
		model: 	a SpToolbarButtonPresenter
		widget: 	a SpToolbarButtonMorph(163457024)
		selector: 	nil
		owner: 	a SpToolbarButtonPresenter
		unsubscribed: 	false


SpToolbarButtonMorph(PluggableButtonMorph)>>performAction:
	Receiver: a SpToolbarButtonMorph(163457024)
	Arguments and temporary variables: 
		event: 	[(25.0@23.0) mouseUp 11368550 nil]
	Receiver's instance variables: 
		bounds: 	(0.0@5.0) corner: (45.0@39.0)
		owner: 	a Morph(543889152)
		submorphs: 	an Array(an AlignmentMorph(1048008448))
		fullBounds: 	nil
		color: 	(Color r: 0.9012707722385142 g: 0.9012707722385142 b: 0.901270772238[..]
		extension: 	a MorphExtension (606190080) [balloonText]  [other:  (presenter [..]
		borderWidth: 	0
		borderColor: 	#simple
		model: 	a SpMorphicToolbarButtonAdapter
		label: 	'Do it'
		icon: 	Form(13x13x32)
		getIconSelector: 	#icon
		getStateSelector: 	#state
		actionSelector: 	#execute
		font: 	a LogicalFont
 familyName: 'Source Sans Pro'
 emphasis: nil
 pointSiz[..]
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	nil
		getFontSelector: 	nil
		labelMorph: 	a LabelMorph(576130816)'Do it'
		iconMorph: 	an ImageMorph(527603200)
		iconPosition: 	#top
		lastState: 	false
		badgeFont: 	nil
		badgeSelector: 	#badge


[:m |
		(m containsPoint: evt cursorPoint) ifTrue: [m enabled ifTrue: [ m performAction: evt ]]] in SpToolbarButtonMorph(PluggableButtonMorph)>>mouseUp:
	Receiver: a SpToolbarButtonMorph(163457024)
	Arguments and temporary variables: 
		evt: 	[(25.0@23.0) mouseUp 11368550 nil]
		all: 	an Array(a SpToolbarButtonMorph(163457024) a SpToolbarButtonMorph(6416[..]
		m: 	a SpToolbarButtonMorph(163457024)
	Receiver's instance variables: 
		bounds: 	(0.0@5.0) corner: (45.0@39.0)
		owner: 	a Morph(543889152)
		submorphs: 	an Array(an AlignmentMorph(1048008448))
		fullBounds: 	nil
		color: 	(Color r: 0.9012707722385142 g: 0.9012707722385142 b: 0.901270772238[..]
		extension: 	a MorphExtension (606190080) [balloonText]  [other:  (presenter [..]
		borderWidth: 	0
		borderColor: 	#simple
		model: 	a SpMorphicToolbarButtonAdapter
		label: 	'Do it'
		icon: 	Form(13x13x32)
		getIconSelector: 	#icon
		getStateSelector: 	#state
		actionSelector: 	#execute
		font: 	a LogicalFont
 familyName: 'Source Sans Pro'
 emphasis: nil
 pointSiz[..]
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	nil
		getFontSelector: 	nil
		labelMorph: 	a LabelMorph(576130816)'Do it'
		iconMorph: 	an ImageMorph(527603200)
		iconPosition: 	#top
		lastState: 	false
		badgeFont: 	nil
		badgeSelector: 	#badge


Array(SequenceableCollection)>>do:
	Receiver: an Array(a SpToolbarButtonMorph(163457024) a SpToolbarButtonMorph(641645312) a SpToolb[..]
	Arguments and temporary variables: 
		aBlock: 	[:m |
		(m containsPoint: evt cursorPoint) ifTrue: [m enabled ifTru[..]
		index: 	1
	Receiver's instance variables: 
an Array(a SpToolbarButtonMorph(163457024) a SpToolbarButtonMorph(641645312) a SpToolb[..]

SpToolbarButtonMorph(PluggableButtonMorph)>>mouseUp:
	Receiver: a SpToolbarButtonMorph(163457024)
	Arguments and temporary variables: 
		evt: 	[(25.0@23.0) mouseUp 11368550 nil]
		all: 	an Array(a SpToolbarButtonMorph(163457024) a SpToolbarButtonMorph(6416[..]
	Receiver's instance variables: 
		bounds: 	(0.0@5.0) corner: (45.0@39.0)
		owner: 	a Morph(543889152)
		submorphs: 	an Array(an AlignmentMorph(1048008448))
		fullBounds: 	nil
		color: 	(Color r: 0.9012707722385142 g: 0.9012707722385142 b: 0.901270772238[..]
		extension: 	a MorphExtension (606190080) [balloonText]  [other:  (presenter [..]
		borderWidth: 	0
		borderColor: 	#simple
		model: 	a SpMorphicToolbarButtonAdapter
		label: 	'Do it'
		icon: 	Form(13x13x32)
		getIconSelector: 	#icon
		getStateSelector: 	#state
		actionSelector: 	#execute
		font: 	a LogicalFont
 familyName: 'Source Sans Pro'
 emphasis: nil
 pointSiz[..]
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	nil
		getFontSelector: 	nil
		labelMorph: 	a LabelMorph(576130816)'Do it'
		iconMorph: 	an ImageMorph(527603200)
		iconPosition: 	#top
		lastState: 	false
		badgeFont: 	nil
		badgeSelector: 	#badge


SpToolbarButtonMorph(Morph)>>handleMouseUp:
	Receiver: a SpToolbarButtonMorph(163457024)
	Arguments and temporary variables: 
		anEvent: 	[(25.0@23.0) mouseUp 11368550 nil]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(0.0@5.0) corner: (45.0@39.0)
		owner: 	a Morph(543889152)
		submorphs: 	an Array(an AlignmentMorph(1048008448))
		fullBounds: 	nil
		color: 	(Color r: 0.9012707722385142 g: 0.9012707722385142 b: 0.901270772238[..]
		extension: 	a MorphExtension (606190080) [balloonText]  [other:  (presenter [..]
		borderWidth: 	0
		borderColor: 	#simple
		model: 	a SpMorphicToolbarButtonAdapter
		label: 	'Do it'
		icon: 	Form(13x13x32)
		getIconSelector: 	#icon
		getStateSelector: 	#state
		actionSelector: 	#execute
		font: 	a LogicalFont
 familyName: 'Source Sans Pro'
 emphasis: nil
 pointSiz[..]
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	nil
		getFontSelector: 	nil
		labelMorph: 	a LabelMorph(576130816)'Do it'
		iconMorph: 	an ImageMorph(527603200)
		iconPosition: 	#top
		lastState: 	false
		badgeFont: 	nil
		badgeSelector: 	#badge


MouseButtonEvent>>sentTo:
	Receiver: [(25.0@23.0) mouseUp 11368550 nil]
	Arguments and temporary variables: 
		anObject: 	a SpToolbarButtonMorph(163457024)
	Receiver's instance variables: 
		timeStamp: 	11368550
		source: 	a HandMorph(337424384)
		windowIndex: 	nil
		type: 	#mouseUp
		buttons: 	0
		position: 	(25.0@23.0)
		handler: 	nil
		wasHandled: 	true
		whichButton: 	4


SpToolbarButtonMorph(Morph)>>handleEvent:
	Receiver: a SpToolbarButtonMorph(163457024)
	Arguments and temporary variables: 
		anEvent: 	[(25.0@23.0) mouseUp 11368550 nil]
	Receiver's instance variables: 
		bounds: 	(0.0@5.0) corner: (45.0@39.0)
		owner: 	a Morph(543889152)
		submorphs: 	an Array(an AlignmentMorph(1048008448))
		fullBounds: 	nil
		color: 	(Color r: 0.9012707722385142 g: 0.9012707722385142 b: 0.901270772238[..]
		extension: 	a MorphExtension (606190080) [balloonText]  [other:  (presenter [..]
		borderWidth: 	0
		borderColor: 	#simple
		model: 	a SpMorphicToolbarButtonAdapter
		label: 	'Do it'
		icon: 	Form(13x13x32)
		getIconSelector: 	#icon
		getStateSelector: 	#state
		actionSelector: 	#execute
		font: 	a LogicalFont
 familyName: 'Source Sans Pro'
 emphasis: nil
 pointSiz[..]
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	nil
		getFontSelector: 	nil
		labelMorph: 	a LabelMorph(576130816)'Do it'
		iconMorph: 	an ImageMorph(527603200)
		iconPosition: 	#top
		lastState: 	false
		badgeFont: 	nil
		badgeSelector: 	#badge


SpToolbarButtonMorph(Morph)>>handleFocusEvent:
	Receiver: a SpToolbarButtonMorph(163457024)
	Arguments and temporary variables: 
		anEvent: 	[(25.0@23.0) mouseUp 11368550 nil]
	Receiver's instance variables: 
		bounds: 	(0.0@5.0) corner: (45.0@39.0)
		owner: 	a Morph(543889152)
		submorphs: 	an Array(an AlignmentMorph(1048008448))
		fullBounds: 	nil
		color: 	(Color r: 0.9012707722385142 g: 0.9012707722385142 b: 0.901270772238[..]
		extension: 	a MorphExtension (606190080) [balloonText]  [other:  (presenter [..]
		borderWidth: 	0
		borderColor: 	#simple
		model: 	a SpMorphicToolbarButtonAdapter
		label: 	'Do it'
		icon: 	Form(13x13x32)
		getIconSelector: 	#icon
		getStateSelector: 	#state
		actionSelector: 	#execute
		font: 	a LogicalFont
 familyName: 'Source Sans Pro'
 emphasis: nil
 pointSiz[..]
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	nil
		getFontSelector: 	nil
		labelMorph: 	a LabelMorph(576130816)'Do it'
		iconMorph: 	an ImageMorph(527603200)
		iconPosition: 	#top
		lastState: 	false
		badgeFont: 	nil
		badgeSelector: 	#badge


[
		result := focusHolder handleFocusEvent: transformedEvent.
	] in HandMorph>>sendFocusEvent:to:clear:
	Receiver: a HandMorph(337424384)
	Arguments and temporary variables: 
		anEvent: 	[(480@211) mouseUp 11368550 nil]
		focusHolder: 	a SpToolbarButtonMorph(163457024)
		aBlock: 	[self mouseFocus: nil]
		w: 	a WorldMorph(341720576) [world]
		transformedEvent: 	[(25.0@23.0) mouseUp 11368550 nil]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(480@211.0) corner: (496@227.0)
		owner: 	a WorldMorph(341720576) [world]
		submorphs: 	#()
		fullBounds: 	(480@211.0) corner: (496@227.0)
		color: 	Color blue
		extension: 	a MorphExtension (370611968)
		mouseFocus: 	nil
		keyboardFocus: 	a RubEditingArea(143191808)
		eventListeners: 	nil
		mouseListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(480@211) mouseUp 11368550 nil]
		targetOffset: 	(25.0@18.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 0 0 0 0 0 nil nil)
		captureBlock: 	nil
		recentModifiers: 	0
		pendingEventQueue: 	WaitfreeQueue with 0 items
		supressNextKeyPress: 	false


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
		result := focusHolder handleFocusEvent: transformedEvent.
	]
	Arguments and temporary variables: 
		exception: 	Error
		handlerAction: 	[ :ex |
			ActiveWorld := priorWorld.
			ex pass ]
	Receiver's instance variables: 
		outerContext: 	HandMorph>>sendFocusEvent:to:clear:
		compiledBlock: 	a CompiledBlock: [
		result := focusHolder handleFocusEvent:[..]
		numArgs: 	0
		receiver: 	a HandMorph(337424384)


WorldMorph>>becomeActiveDuring:
	Receiver: a WorldMorph(341720576) [world]
	Arguments and temporary variables: 
		aBlock: 	[
		result := focusHolder handleFocusEvent: transformedEvent.
	]
		priorWorld: 	a WorldMorph(341720576) [world]
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1728@1080)
		owner: 	nil
		submorphs: 	an Array(a MenubarMorph(112886016) a TaskbarMorph(279458560) a S[..]
		fullBounds: 	(0@0) corner: (1728@1080)
		color: 	(Color r: 0.9403714565004888 g: 0.9403714565004888 b: 0.940371456500[..]
		extension: 	a MorphExtension (1012946432) [other:  (dragEnabled -> true) (dr[..]
		borderWidth: 	0
		borderColor: 	(Color r: 0.8611925708699902 g: 1.0 b: 0.7223851417399805 alph[..]
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil


HandMorph>>sendFocusEvent:to:clear:
	Receiver: a HandMorph(337424384)
	Arguments and temporary variables: 
		result: 	nil
		anEvent: 	[(480@211) mouseUp 11368550 nil]
		focusHolder: 	a SpToolbarButtonMorph(163457024)
		aBlock: 	[self mouseFocus: nil]
		w: 	a WorldMorph(341720576) [world]
		transformedEvent: 	[(25.0@23.0) mouseUp 11368550 nil]
	Receiver's instance variables: 
		bounds: 	(480@211.0) corner: (496@227.0)
		owner: 	a WorldMorph(341720576) [world]
		submorphs: 	#()
		fullBounds: 	(480@211.0) corner: (496@227.0)
		color: 	Color blue
		extension: 	a MorphExtension (370611968)
		mouseFocus: 	nil
		keyboardFocus: 	a RubEditingArea(143191808)
		eventListeners: 	nil
		mouseListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(480@211) mouseUp 11368550 nil]
		targetOffset: 	(25.0@18.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 0 0 0 0 0 nil nil)
		captureBlock: 	nil
		recentModifiers: 	0
		pendingEventQueue: 	WaitfreeQueue with 0 items
		supressNextKeyPress: 	false


HandMorph>>sendEvent:focus:clear:
	Receiver: a HandMorph(337424384)
	Arguments and temporary variables: 
		anEvent: 	[(480@211) mouseUp 11368550 nil]
		focusHolder: 	a SpToolbarButtonMorph(163457024)
		aBlock: 	[self mouseFocus: nil]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(480@211.0) corner: (496@227.0)
		owner: 	a WorldMorph(341720576) [world]
		submorphs: 	#()
		fullBounds: 	(480@211.0) corner: (496@227.0)
		color: 	Color blue
		extension: 	a MorphExtension (370611968)
		mouseFocus: 	nil
		keyboardFocus: 	a RubEditingArea(143191808)
		eventListeners: 	nil
		mouseListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(480@211) mouseUp 11368550 nil]
		targetOffset: 	(25.0@18.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 0 0 0 0 0 nil nil)
		captureBlock: 	nil
		recentModifiers: 	0
		pendingEventQueue: 	WaitfreeQueue with 0 items
		supressNextKeyPress: 	false


HandMorph>>sendMouseEvent:
	Receiver: a HandMorph(337424384)
	Arguments and temporary variables: 
		anEvent: 	[(480@211) mouseUp 11368550 nil]
	Receiver's instance variables: 
		bounds: 	(480@211.0) corner: (496@227.0)
		owner: 	a WorldMorph(341720576) [world]
		submorphs: 	#()
		fullBounds: 	(480@211.0) corner: (496@227.0)
		color: 	Color blue
		extension: 	a MorphExtension (370611968)
		mouseFocus: 	nil
		keyboardFocus: 	a RubEditingArea(143191808)
		eventListeners: 	nil
		mouseListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(480@211) mouseUp 11368550 nil]
		targetOffset: 	(25.0@18.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 0 0 0 0 0 nil nil)
		captureBlock: 	nil
		recentModifiers: 	0
		pendingEventQueue: 	WaitfreeQueue with 0 items
		supressNextKeyPress: 	false


HandMorph>>handleEvent:
	Receiver: a HandMorph(337424384)
	Arguments and temporary variables: 
		anEvent: 	[(480@211) mouseUp 11368550 nil]
		evt: 	[(480@211) mouseUp 11368550 nil]
	Receiver's instance variables: 
		bounds: 	(480@211.0) corner: (496@227.0)
		owner: 	a WorldMorph(341720576) [world]
		submorphs: 	#()
		fullBounds: 	(480@211.0) corner: (496@227.0)
		color: 	Color blue
		extension: 	a MorphExtension (370611968)
		mouseFocus: 	nil
		keyboardFocus: 	a RubEditingArea(143191808)
		eventListeners: 	nil
		mouseListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(480@211) mouseUp 11368550 nil]
		targetOffset: 	(25.0@18.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 0 0 0 0 0 nil nil)
		captureBlock: 	nil
		recentModifiers: 	0
		pendingEventQueue: 	WaitfreeQueue with 0 items
		supressNextKeyPress: 	false


[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil ]) ifTrue: [
			morphicWorld activeHand handleEvent: anEvent
		]
	] in OSWindowMorphicEventHandler>>dispatchMorphicEvent:
	Receiver: an OSWindowMorphicEventHandler
	Arguments and temporary variables: 
		anEvent: 	[(480@211) mouseUp 11368550 nil]
	Receiver's instance variables: 
		morphicWorld: 	a WorldMorph(341720576) [world]


WorldState>>runStepMethodsIn:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(341720576) [world]
		queue: 	WaitfreeQueue with 0 items
		nextInQueue: 	[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNo[..]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(337424384))
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap()
		lastStepTime: 	11344935
		lastStepMessage: 	nil
		alarms: 	a Heap(MorphicAlarm(#hideShow -> a RubCursor(27124480)))
		lastAlarmTime: 	11368528
		activeHand: 	a HandMorph(337424384)
		currentCursor: 	((CursorWithMask
	extent: (16@16)
	depth: 1
	fromArray: #(
	[..]
		worldRenderer: 	an OSWorldRenderer
		realWindowExtent: 	(1728@1080)
		deferredUIMessages: 	WaitfreeQueue with 0 items


WorldMorph>>runStepMethods
	Receiver: a WorldMorph(341720576) [world]
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1728@1080)
		owner: 	nil
		submorphs: 	an Array(a MenubarMorph(112886016) a TaskbarMorph(279458560) a S[..]
		fullBounds: 	(0@0) corner: (1728@1080)
		color: 	(Color r: 0.9403714565004888 g: 0.9403714565004888 b: 0.940371456500[..]
		extension: 	a MorphExtension (1012946432) [other:  (dragEnabled -> true) (dr[..]
		borderWidth: 	0
		borderColor: 	(Color r: 0.8611925708699902 g: 1.0 b: 0.7223851417399805 alph[..]
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil


WorldState>>doOneCycleFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(341720576) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(337424384))
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap()
		lastStepTime: 	11344935
		lastStepMessage: 	nil
		alarms: 	a Heap(MorphicAlarm(#hideShow -> a RubCursor(27124480)))
		lastAlarmTime: 	11368528
		activeHand: 	a HandMorph(337424384)
		currentCursor: 	((CursorWithMask
	extent: (16@16)
	depth: 1
	fromArray: #(
	[..]
		worldRenderer: 	an OSWorldRenderer
		realWindowExtent: 	(1728@1080)
		deferredUIMessages: 	WaitfreeQueue with 0 items


WorldMorph>>doOneCycleNow
	Receiver: a WorldMorph(341720576) [world]
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1728@1080)
		owner: 	nil
		submorphs: 	an Array(a MenubarMorph(112886016) a TaskbarMorph(279458560) a S[..]
		fullBounds: 	(0@0) corner: (1728@1080)
		color: 	(Color r: 0.9403714565004888 g: 0.9403714565004888 b: 0.940371456500[..]
		extension: 	a MorphExtension (1012946432) [other:  (dragEnabled -> true) (dr[..]
		borderWidth: 	0
		borderColor: 	(Color r: 0.8611925708699902 g: 1.0 b: 0.7223851417399805 alph[..]
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil


WorldMorph>>doOneCycle
	Receiver: a WorldMorph(341720576) [world]
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1728@1080)
		owner: 	nil
		submorphs: 	an Array(a MenubarMorph(112886016) a TaskbarMorph(279458560) a S[..]
		fullBounds: 	(0@0) corner: (1728@1080)
		color: 	(Color r: 0.9403714565004888 g: 0.9403714565004888 b: 0.940371456500[..]
		extension: 	a MorphExtension (1012946432) [other:  (dragEnabled -> true) (dr[..]
		borderWidth: 	0
		borderColor: 	(Color r: 0.8611925708699902 g: 1.0 b: 0.7223851417399805 alph[..]
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil



--- The full stack ---
RSBox(Object)>>doesNotUnderstand: #center
[ :edgeDict |
        | edge sourceNode targetNode |
        sourceNode := nodesMap at: (edgeDict at: #source) ifAbsent: [ nil ].
        targetNode := nodesMap at: (edgeDict at: #target) ifAbsent: [ nil ].
        sourceNode ifNotNil: [ targetNode ifNotNil: [
            edge := RSLine new from: sourceNode center to: targetNode center.
            edge canvas add: edge.
        ]].
    ] in GraphVisualizer>>createEdges
Array(SequenceableCollection)>>do:
GraphVisualizer>>createEdges
GraphVisualizer>>visualizeGraphFromFile:
UndefinedObject>>DoIt
OCReceiverDoItSemanticScope(OCDoItSemanticScope)>>evaluateDoIt:
OpalCompiler>>evaluate
[
		self announcer announce: (SpCodeWillBeEvaluatedAnnouncement newContent: aString).
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionModel doItReceiver.
		result := receiver class compiler
			source: aString;
			context: self interactionModel doItContext;
			receiver: self interactionModel doItReceiver;
			requestor: self interactionModel;
			environment: self environment;
			failBlock:  [ 
				self announcer announce: (SpCodeEvaluationFailedAnnouncement newContent: aString).
				^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		self announcer announce: (SpCodeEvaluationSucceedAnnouncement newContent: aString).
		result ] in SpCodePresenter>>evaluate:onCompileError:onError:
FullBlockClosure(BlockClosure)>>on:do:
SpCodePresenter>>evaluate:onCompileError:onError:
StPlaygroundPagePresenter>>doEvaluateAndGo
StPlaygroundPagePresenter>>doEvaluateAllAndGo
StPlaygroundDoItCommand>>execute
SpCommand(CmCommandDecorator)>>execute
[ specCommand execute ] in [ :specCommand | 
			aButtonClass new
				label: specCommand name;
				help: specCommand description;
				in: [ :button | 
					specCommand hasIcon
						ifTrue: [ button icon: specCommand icon ] ];
				action: [ specCommand execute ];
				yourself ] in SpCommand>>configureAsButtonOfClass:
FullBlockClosure(BlockClosure)>>cull:
SpMorphicToolbarButtonAdapter>>execute
SpToolbarButtonMorph(PluggableButtonMorph)>>performAction:
[:m |
		(m containsPoint: evt cursorPoint) ifTrue: [m enabled ifTrue: [ m performAction: evt ]]] in SpToolbarButtonMorph(PluggableButtonMorph)>>mouseUp:
Array(SequenceableCollection)>>do:
SpToolbarButtonMorph(PluggableButtonMorph)>>mouseUp:
SpToolbarButtonMorph(Morph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
SpToolbarButtonMorph(Morph)>>handleEvent:
SpToolbarButtonMorph(Morph)>>handleFocusEvent:
[
		result := focusHolder handleFocusEvent: transformedEvent.
	] in HandMorph>>sendFocusEvent:to:clear:
FullBlockClosure(BlockClosure)>>on:do:
WorldMorph>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil ]) ifTrue: [
			morphicWorld activeHand handleEvent: anEvent
		]
	] in OSWindowMorphicEventHandler>>dispatchMorphicEvent:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycleNow
WorldMorph>>doOneCycle
 - - - - - - - - - - - - - - -
			- - - - - - - - - - - - - - - - - -
[
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMutex critical: [
			                     self extraWorldList ].
		extraWorldsToDraw do: [ :world | world doOneCycle ].

		(self currentWorld isNotNil and: [
			 (extraWorldsToDraw includes: self currentWorld) not ]) ifTrue: [
			self currentWorld doOneCycle ] ] in WorldMorph class>>doOneCycle
FullBlockClosure(BlockClosure)>>ensure:
WorldState class>>doDrawCycleWith:
WorldMorph class>>doOneCycle
MorphicRenderLoop>>doOneCycle
MorphicRenderLoop>>doOneCycleWhile:
[ MorphicRenderLoop new doOneCycleWhile: [ true ] ] in MorphicUIManager>>spawnNewProcess
[self value.
			"IMPORTANT: Do not step over next line of code. See method comments for details"
			Processor terminateRealActive] in FullBlockClosure(BlockClosure)>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
Instance of RSBox did not understand #center
13 November 2023 7:14:10.458292 pm

VM: Mac OS - arm64 - 1000 - CoInterpreter VMMaker-tonel.1 uuid: 902dd483-c0c4-0d00-86f2-0f880df24b96 Oct 23 2023
StackToRegisterMappingCogit VMMaker-tonel.1 uuid: 902dd483-c0c4-0d00-86f2-0f880df24b96 Oct 23 2023
v10.0.8 - Commit: b323c5fb - Date: 2023-10-20 16:02:07 -0400

Image: Pharo11.0.0 [Build information: Pharo-11.0.0+build.710.sha.ea28d8552cac85a7ce1e9c34ab1e7bd45f7b9910 (64 Bit)]

RSBox(Object)>>doesNotUnderstand: #center
	Receiver: a RSBox
	Arguments and temporary variables: 
		aMessage: 	center
		exception: 	Instance of RSBox did not understand #center
		resumeValue: 	nil
	Receiver's instance variables: 
		announcer: 	nil
		properties: 	nil
		paint: 	Color blue
		path: 	(-10.0@ -10.0) corner: (10.0@10.0)
		border: 	nil
		parent: 	a RSCanvas
		isFixed: 	false
		encompassingRectangle: 	nil
		model: 	nil
		baseRectangle: 	(-10.0@ -10.0) corner: (10.0@10.0)
		matrix: 	x: 0.0 y: 0.0 sx: 1.0 sy: 1.0 shx: 0.0 shy: 0.0
		connectedLines: 	nil
		shouldUpdateLines: 	true
		cornerRadius: 	nil


[ :edgeDict |
        | edge sourceNode targetNode |
        sourceNode := nodesMap at: (edgeDict at: #source) ifAbsent: [ nil ].
        targetNode := nodesMap at: (edgeDict at: #target) ifAbsent: [ nil ].
        sourceNode ifNotNil: [ targetNode ifNotNil: [
            edge := RSLine new from: sourceNode center to: targetNode center.
            edge canvas add: edge.
        ]].
    ] in GraphVisualizer>>createEdges
	Receiver: a GraphVisualizer
	Arguments and temporary variables: 
		edgeDict: 	a Dictionary('source'->1 'target'->2 'type'->'FRIENDS_WITH' )
		edge: 	nil
		sourceNode: 	a RSBox
		targetNode: 	a RSBox
	Receiver's instance variables: 
		view: 	nil
		nodes: 	an Array(a Dictionary('id'->1 'label'->'Person' 'properties'->a Dict[..]
		edges: 	an Array(a Dictionary('source'->1 'target'->2 'type'->'FRIENDS_WITH' ))
		nodesMap: 	a Dictionary(1->a RSBox 2->a RSBox )
		canvas: 	a RSCanvas


Array(SequenceableCollection)>>do:
	Receiver: an Array(a Dictionary('source'->1 'target'->2 'type'->'FRIENDS_WITH' ))
	Arguments and temporary variables: 
		aBlock: 	[ :edgeDict |
        | edge sourceNode targetNode |
        source[..]
		index: 	1
	Receiver's instance variables: 
an Array(a Dictionary('source'->1 'target'->2 'type'->'FRIENDS_WITH' ))

GraphVisualizer>>createEdges
	Receiver: a GraphVisualizer
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		view: 	nil
		nodes: 	an Array(a Dictionary('id'->1 'label'->'Person' 'properties'->a Dict[..]
		edges: 	an Array(a Dictionary('source'->1 'target'->2 'type'->'FRIENDS_WITH' ))
		nodesMap: 	a Dictionary(1->a RSBox 2->a RSBox )
		canvas: 	a RSCanvas


GraphVisualizer>>visualizeGraphFromFile:
	Receiver: a GraphVisualizer
	Arguments and temporary variables: 
		aFilePath: 	'/Users/ryanperez/Documents/GitHub/pp-rep2533/project/src/data/t[..]
	Receiver's instance variables: 
		view: 	nil
		nodes: 	an Array(a Dictionary('id'->1 'label'->'Person' 'properties'->a Dict[..]
		edges: 	an Array(a Dictionary('source'->1 'target'->2 'type'->'FRIENDS_WITH' ))
		nodesMap: 	a Dictionary(1->a RSBox 2->a RSBox )
		canvas: 	a RSCanvas


UndefinedObject>>DoIt
	Receiver: nil
	Arguments and temporary variables: 
		visualizer: 	a GraphVisualizer
	Receiver's instance variables: 
nil

OCReceiverDoItSemanticScope(OCDoItSemanticScope)>>evaluateDoIt:
	Receiver: an OCReceiverDoItSemanticScope
	Arguments and temporary variables: 
		doItMethod: 	UndefinedObject>>#DoIt
	Receiver's instance variables: 
		outerScope: 	nil
		targetReceiver: 	nil


OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
		doItMethod: 	UndefinedObject>>#DoIt
	Receiver's instance variables: 
		ast: 	DoIt

	| visualizer |
	visualizer := GraphVisualizer new.
	^ visualize[..]
		source: 	a ReadStream
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil


[
		self announcer announce: (SpCodeWillBeEvaluatedAnnouncement newContent: aString).
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionModel doItReceiver.
		result := receiver class compiler
			source: aString;
			context: self interactionModel doItContext;
			receiver: self interactionModel doItReceiver;
			requestor: self interactionModel;
			environment: self environment;
			failBlock:  [ 
				self announcer announce: (SpCodeEvaluationFailedAnnouncement newContent: aString).
				^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		self announcer announce: (SpCodeEvaluationSucceedAnnouncement newContent: aString).
		result ] in SpCodePresenter>>evaluate:onCompileError:onError:
	Receiver: a SpCodePresenter
	Arguments and temporary variables: 
		aString: 	'| visualizer |
visualizer := GraphVisualizer new.
visualizer visu[..]
		compileErrorBlock: 	[ ^ self ]
		errorBlock: 	[ :e | e pass ]
		receiver: 	nil
		result: 	nil
		oldBindings: 	a Dictionary()
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicCodeAdapter)
		announcer: 	an Announcer
		owner: 	a StPlaygroundPagePresenter
		adapter: 	a SpMorphicCodeAdapter
		needRebuild: 	true
		eventHandler: 	a SpEventHandler
		application: 	nil
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ a KMCategory ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Code' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpAbstractWidgetLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		borderWidth: 	an ObservableValueHolder[ nil ]
		borderColor: 	an ObservableValueHolder[ nil ]
		dragEnabled: 	an ObservableValueHolder[ false ]
		dropEnabled: 	an ObservableValueHolder[ false ]
		color: 	an ObservableValueHolder[ nil ]
		help: 	an ObservableValueHolder[ nil ]
		enabled: 	an ObservableValueHolder[ true ]
		wantsDrop: 	an ObservableValueHolder[ [ :transfer | self dropEnabled ] ]
		acceptDrop: 	an ObservableValueHolder[ [ :transfer | ] ]
		deferredActions: 	nil
		hasUnacceptedEdits: 	an ObservableValueHolder[ false ]
		selection: 	an ObservableValueHolder[ (1 to: 159) ]
		wantsVisualFeedback: 	an ObservableValueHolder[ true ]
		askBeforeDiscardingEdits: 	an ObservableValueHolder[ true ]
		text: 	an ObservableValueHolder[ '| visualizer |
visualizer := GraphVisualiz[..]
		actionToPerform: 	an ObservableValueHolder[ [ :txt |  ] ]
		readSelection: 	an ObservableValueHolder[ [ selection ] ]
		placeholder: 	an ObservableValueHolder[ '' ]
		contextMenu: 	an ObservableValueHolder[ [ (self menuActionsFor: text) asMenu[..]
		scrollValue: 	an ObservableValueHolder[ (0@0) ]
		editionContextMenu: 	an ObservableValueHolder[ true ]
		editable: 	an ObservableValueHolder[ true ]
		wrapWord: 	an ObservableValueHolder[ true ]
		undoRedoHistory: 	true
		wrapScrollBars: 	true
		propagateNaturalHeight: 	false
		propagateNaturalWidth: 	false
		scrollBarStyles: 	#()
		syntaxHighlight: 	an ObservableValueHolder[ true ]
		smartCharacters: 	an ObservableValueHolder[ true ]
		lineNumbers: 	an ObservableValueHolder[ true ]
		interactionModel: 	an ObservableValueHolder[ a StPlaygroundInteractionModel ]
		overrideContextMenu: 	true
		submitBlock: 	nil
		resetBlock: 	nil
		environment: 	nil
		systemNavigation: 	nil
		syntaxHighlightTheme: 	an ObservableValueHolder[ nil ]


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
		self announcer announce: (SpCodeWillBeEvaluatedAnnouncement newContent: aString).
[..]
	Arguments and temporary variables: 
		exception: 	Error
		handlerAction: 	[ :e |
		self announcer announce: (SpCodeEvaluationFailedAnn[..]
	Receiver's instance variables: 
		outerContext: 	SpCodePresenter>>evaluate:onCompileError:onError:
		compiledBlock: 	a CompiledBlock: [
		self announcer announce: (SpCodeWillBeE[..]
		numArgs: 	0
		receiver: 	a SpCodePresenter


SpCodePresenter>>evaluate:onCompileError:onError:
	Receiver: a SpCodePresenter
	Arguments and temporary variables: 
		receiver: 	nil
		result: 	nil
		oldBindings: 	a Dictionary()
		aString: 	'| visualizer |
visualizer := GraphVisualizer new.
visualizer visu[..]
		compileErrorBlock: 	[ ^ self ]
		errorBlock: 	[ :e | e pass ]
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicCodeAdapter)
		announcer: 	an Announcer
		owner: 	a StPlaygroundPagePresenter
		adapter: 	a SpMorphicCodeAdapter
		needRebuild: 	true
		eventHandler: 	a SpEventHandler
		application: 	nil
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ a KMCategory ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Code' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpAbstractWidgetLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		borderWidth: 	an ObservableValueHolder[ nil ]
		borderColor: 	an ObservableValueHolder[ nil ]
		dragEnabled: 	an ObservableValueHolder[ false ]
		dropEnabled: 	an ObservableValueHolder[ false ]
		color: 	an ObservableValueHolder[ nil ]
		help: 	an ObservableValueHolder[ nil ]
		enabled: 	an ObservableValueHolder[ true ]
		wantsDrop: 	an ObservableValueHolder[ [ :transfer | self dropEnabled ] ]
		acceptDrop: 	an ObservableValueHolder[ [ :transfer | ] ]
		deferredActions: 	nil
		hasUnacceptedEdits: 	an ObservableValueHolder[ false ]
		selection: 	an ObservableValueHolder[ (1 to: 159) ]
		wantsVisualFeedback: 	an ObservableValueHolder[ true ]
		askBeforeDiscardingEdits: 	an ObservableValueHolder[ true ]
		text: 	an ObservableValueHolder[ '| visualizer |
visualizer := GraphVisualiz[..]
		actionToPerform: 	an ObservableValueHolder[ [ :txt |  ] ]
		readSelection: 	an ObservableValueHolder[ [ selection ] ]
		placeholder: 	an ObservableValueHolder[ '' ]
		contextMenu: 	an ObservableValueHolder[ [ (self menuActionsFor: text) asMenu[..]
		scrollValue: 	an ObservableValueHolder[ (0@0) ]
		editionContextMenu: 	an ObservableValueHolder[ true ]
		editable: 	an ObservableValueHolder[ true ]
		wrapWord: 	an ObservableValueHolder[ true ]
		undoRedoHistory: 	true
		wrapScrollBars: 	true
		propagateNaturalHeight: 	false
		propagateNaturalWidth: 	false
		scrollBarStyles: 	#()
		syntaxHighlight: 	an ObservableValueHolder[ true ]
		smartCharacters: 	an ObservableValueHolder[ true ]
		lineNumbers: 	an ObservableValueHolder[ true ]
		interactionModel: 	an ObservableValueHolder[ a StPlaygroundInteractionModel ]
		overrideContextMenu: 	true
		submitBlock: 	nil
		resetBlock: 	nil
		environment: 	nil
		systemNavigation: 	nil
		syntaxHighlightTheme: 	an ObservableValueHolder[ nil ]


StPlaygroundPagePresenter>>doEvaluateAndGo
	Receiver: a StPlaygroundPagePresenter
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicBoxAdapter)
		announcer: 	an Announcer
		owner: 	a SpMillerColumnPresenter
		adapter: 	a SpMorphicBoxAdapter
		needRebuild: 	true
		eventHandler: 	nil
		application: 	a StPharoApplication
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ nil ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Untitled window' ]
		additionalSubpresentersMap: 	a Dictionary()
		layout: 	an ObservableValueHolder[ a SpBoxLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		text: 	a SpCodePresenter
		toolbar: 	a SpToolbarPresenter
		statusbar: 	a SpPresenter
		lineLabel: 	a SpLabelPresenter
		toggleLineNumberButton: 	a SpToggleButtonPresenter
		page: 	a StPlaygroundPage
		activationBlock: 	[ :selection |
		self changeSelection: selection from: new[..]


StPlaygroundPagePresenter>>doEvaluateAllAndGo
	Receiver: a StPlaygroundPagePresenter
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicBoxAdapter)
		announcer: 	an Announcer
		owner: 	a SpMillerColumnPresenter
		adapter: 	a SpMorphicBoxAdapter
		needRebuild: 	true
		eventHandler: 	nil
		application: 	a StPharoApplication
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ nil ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Untitled window' ]
		additionalSubpresentersMap: 	a Dictionary()
		layout: 	an ObservableValueHolder[ a SpBoxLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		text: 	a SpCodePresenter
		toolbar: 	a SpToolbarPresenter
		statusbar: 	a SpPresenter
		lineLabel: 	a SpLabelPresenter
		toggleLineNumberButton: 	a SpToggleButtonPresenter
		page: 	a StPlaygroundPage
		activationBlock: 	[ :selection |
		self changeSelection: selection from: new[..]


StPlaygroundDoItCommand>>execute
	Receiver: a StPlaygroundDoItCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		context: 	a StPlaygroundPagePresenter
		basicName: 	'Do it'
		basicDescription: 	'Do it all and inspect.'


SpCommand(CmCommandDecorator)>>execute
	Receiver: a SpCommand(Do it)
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a StPlaygroundDoItCommand
		iconProvider: 	a StPharoApplication
		iconName: 	#glamorousGo
		shortcutKey: 	nil
		displayStrategy: 	a CmUIDisableWhenCantBeRun
		positionStrategy: 	a CmUILeftPositionStrategy
		buildPresenterBlock: 	[ :specCommand | 
			aButtonClass new
				label: specC[..]
		presenter: 	a SpToolbarButtonPresenter


[ specCommand execute ] in [ :specCommand | 
			aButtonClass new
				label: specCommand name;
				help: specCommand description;
				in: [ :button | 
					specCommand hasIcon
						ifTrue: [ button icon: specCommand icon ] ];
				action: [ specCommand execute ];
				yourself ] in SpCommand>>configureAsButtonOfClass:
	Receiver: a SpCommand(Do it)
	Arguments and temporary variables: 
		aButtonClass: 	nil
		specCommand: 	a SpCommand(Do it)
	Receiver's instance variables: 
		decoratedCommand: 	a StPlaygroundDoItCommand
		iconProvider: 	a StPharoApplication
		iconName: 	#glamorousGo
		shortcutKey: 	nil
		displayStrategy: 	a CmUIDisableWhenCantBeRun
		positionStrategy: 	a CmUILeftPositionStrategy
		buildPresenterBlock: 	[ :specCommand | 
			aButtonClass new
				label: specC[..]
		presenter: 	a SpToolbarButtonPresenter


FullBlockClosure(BlockClosure)>>cull:
	Receiver: [ specCommand execute ]
	Arguments and temporary variables: 
		anArg: 	a SpToolbarButtonPresenter
	Receiver's instance variables: 
		outerContext: 	[ :specCommand | 
			aButtonClass new
				label: specCommand [..]
		compiledBlock: 	a CompiledBlock: [ specCommand execute ]
		numArgs: 	0
		receiver: 	a SpCommand(Do it)


SpMorphicToolbarButtonAdapter>>execute
	Receiver: a SpMorphicToolbarButtonAdapter
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpToolbarButtonMorph(163457024))
		announcer: 	nil
		model: 	a SpToolbarButtonPresenter
		widget: 	a SpToolbarButtonMorph(163457024)
		selector: 	nil
		owner: 	a SpToolbarButtonPresenter
		unsubscribed: 	false


SpToolbarButtonMorph(PluggableButtonMorph)>>performAction:
	Receiver: a SpToolbarButtonMorph(163457024)
	Arguments and temporary variables: 
		event: 	[(25.0@23.0) mouseUp 11368550 nil]
	Receiver's instance variables: 
		bounds: 	(0.0@5.0) corner: (45.0@39.0)
		owner: 	a Morph(543889152)
		submorphs: 	an Array(an AlignmentMorph(1048008448))
		fullBounds: 	nil
		color: 	(Color r: 0.9012707722385142 g: 0.9012707722385142 b: 0.901270772238[..]
		extension: 	a MorphExtension (606190080) [balloonText]  [other:  (presenter [..]
		borderWidth: 	0
		borderColor: 	#simple
		model: 	a SpMorphicToolbarButtonAdapter
		label: 	'Do it'
		icon: 	Form(13x13x32)
		getIconSelector: 	#icon
		getStateSelector: 	#state
		actionSelector: 	#execute
		font: 	a LogicalFont
 familyName: 'Source Sans Pro'
 emphasis: nil
 pointSiz[..]
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	nil
		getFontSelector: 	nil
		labelMorph: 	a LabelMorph(576130816)'Do it'
		iconMorph: 	an ImageMorph(527603200)
		iconPosition: 	#top
		lastState: 	false
		badgeFont: 	nil
		badgeSelector: 	#badge


[:m |
		(m containsPoint: evt cursorPoint) ifTrue: [m enabled ifTrue: [ m performAction: evt ]]] in SpToolbarButtonMorph(PluggableButtonMorph)>>mouseUp:
	Receiver: a SpToolbarButtonMorph(163457024)
	Arguments and temporary variables: 
		evt: 	[(25.0@23.0) mouseUp 11368550 nil]
		all: 	an Array(a SpToolbarButtonMorph(163457024) a SpToolbarButtonMorph(6416[..]
		m: 	a SpToolbarButtonMorph(163457024)
	Receiver's instance variables: 
		bounds: 	(0.0@5.0) corner: (45.0@39.0)
		owner: 	a Morph(543889152)
		submorphs: 	an Array(an AlignmentMorph(1048008448))
		fullBounds: 	nil
		color: 	(Color r: 0.9012707722385142 g: 0.9012707722385142 b: 0.901270772238[..]
		extension: 	a MorphExtension (606190080) [balloonText]  [other:  (presenter [..]
		borderWidth: 	0
		borderColor: 	#simple
		model: 	a SpMorphicToolbarButtonAdapter
		label: 	'Do it'
		icon: 	Form(13x13x32)
		getIconSelector: 	#icon
		getStateSelector: 	#state
		actionSelector: 	#execute
		font: 	a LogicalFont
 familyName: 'Source Sans Pro'
 emphasis: nil
 pointSiz[..]
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	nil
		getFontSelector: 	nil
		labelMorph: 	a LabelMorph(576130816)'Do it'
		iconMorph: 	an ImageMorph(527603200)
		iconPosition: 	#top
		lastState: 	false
		badgeFont: 	nil
		badgeSelector: 	#badge


Array(SequenceableCollection)>>do:
	Receiver: an Array(a SpToolbarButtonMorph(163457024) a SpToolbarButtonMorph(641645312) a SpToolb[..]
	Arguments and temporary variables: 
		aBlock: 	[:m |
		(m containsPoint: evt cursorPoint) ifTrue: [m enabled ifTru[..]
		index: 	1
	Receiver's instance variables: 
an Array(a SpToolbarButtonMorph(163457024) a SpToolbarButtonMorph(641645312) a SpToolb[..]

SpToolbarButtonMorph(PluggableButtonMorph)>>mouseUp:
	Receiver: a SpToolbarButtonMorph(163457024)
	Arguments and temporary variables: 
		evt: 	[(25.0@23.0) mouseUp 11368550 nil]
		all: 	an Array(a SpToolbarButtonMorph(163457024) a SpToolbarButtonMorph(6416[..]
	Receiver's instance variables: 
		bounds: 	(0.0@5.0) corner: (45.0@39.0)
		owner: 	a Morph(543889152)
		submorphs: 	an Array(an AlignmentMorph(1048008448))
		fullBounds: 	nil
		color: 	(Color r: 0.9012707722385142 g: 0.9012707722385142 b: 0.901270772238[..]
		extension: 	a MorphExtension (606190080) [balloonText]  [other:  (presenter [..]
		borderWidth: 	0
		borderColor: 	#simple
		model: 	a SpMorphicToolbarButtonAdapter
		label: 	'Do it'
		icon: 	Form(13x13x32)
		getIconSelector: 	#icon
		getStateSelector: 	#state
		actionSelector: 	#execute
		font: 	a LogicalFont
 familyName: 'Source Sans Pro'
 emphasis: nil
 pointSiz[..]
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	nil
		getFontSelector: 	nil
		labelMorph: 	a LabelMorph(576130816)'Do it'
		iconMorph: 	an ImageMorph(527603200)
		iconPosition: 	#top
		lastState: 	false
		badgeFont: 	nil
		badgeSelector: 	#badge


SpToolbarButtonMorph(Morph)>>handleMouseUp:
	Receiver: a SpToolbarButtonMorph(163457024)
	Arguments and temporary variables: 
		anEvent: 	[(25.0@23.0) mouseUp 11368550 nil]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(0.0@5.0) corner: (45.0@39.0)
		owner: 	a Morph(543889152)
		submorphs: 	an Array(an AlignmentMorph(1048008448))
		fullBounds: 	nil
		color: 	(Color r: 0.9012707722385142 g: 0.9012707722385142 b: 0.901270772238[..]
		extension: 	a MorphExtension (606190080) [balloonText]  [other:  (presenter [..]
		borderWidth: 	0
		borderColor: 	#simple
		model: 	a SpMorphicToolbarButtonAdapter
		label: 	'Do it'
		icon: 	Form(13x13x32)
		getIconSelector: 	#icon
		getStateSelector: 	#state
		actionSelector: 	#execute
		font: 	a LogicalFont
 familyName: 'Source Sans Pro'
 emphasis: nil
 pointSiz[..]
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	nil
		getFontSelector: 	nil
		labelMorph: 	a LabelMorph(576130816)'Do it'
		iconMorph: 	an ImageMorph(527603200)
		iconPosition: 	#top
		lastState: 	false
		badgeFont: 	nil
		badgeSelector: 	#badge


MouseButtonEvent>>sentTo:
	Receiver: [(25.0@23.0) mouseUp 11368550 nil]
	Arguments and temporary variables: 
		anObject: 	a SpToolbarButtonMorph(163457024)
	Receiver's instance variables: 
		timeStamp: 	11368550
		source: 	a HandMorph(337424384)
		windowIndex: 	nil
		type: 	#mouseUp
		buttons: 	0
		position: 	(25.0@23.0)
		handler: 	nil
		wasHandled: 	true
		whichButton: 	4


SpToolbarButtonMorph(Morph)>>handleEvent:
	Receiver: a SpToolbarButtonMorph(163457024)
	Arguments and temporary variables: 
		anEvent: 	[(25.0@23.0) mouseUp 11368550 nil]
	Receiver's instance variables: 
		bounds: 	(0.0@5.0) corner: (45.0@39.0)
		owner: 	a Morph(543889152)
		submorphs: 	an Array(an AlignmentMorph(1048008448))
		fullBounds: 	nil
		color: 	(Color r: 0.9012707722385142 g: 0.9012707722385142 b: 0.901270772238[..]
		extension: 	a MorphExtension (606190080) [balloonText]  [other:  (presenter [..]
		borderWidth: 	0
		borderColor: 	#simple
		model: 	a SpMorphicToolbarButtonAdapter
		label: 	'Do it'
		icon: 	Form(13x13x32)
		getIconSelector: 	#icon
		getStateSelector: 	#state
		actionSelector: 	#execute
		font: 	a LogicalFont
 familyName: 'Source Sans Pro'
 emphasis: nil
 pointSiz[..]
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	nil
		getFontSelector: 	nil
		labelMorph: 	a LabelMorph(576130816)'Do it'
		iconMorph: 	an ImageMorph(527603200)
		iconPosition: 	#top
		lastState: 	false
		badgeFont: 	nil
		badgeSelector: 	#badge


SpToolbarButtonMorph(Morph)>>handleFocusEvent:
	Receiver: a SpToolbarButtonMorph(163457024)
	Arguments and temporary variables: 
		anEvent: 	[(25.0@23.0) mouseUp 11368550 nil]
	Receiver's instance variables: 
		bounds: 	(0.0@5.0) corner: (45.0@39.0)
		owner: 	a Morph(543889152)
		submorphs: 	an Array(an AlignmentMorph(1048008448))
		fullBounds: 	nil
		color: 	(Color r: 0.9012707722385142 g: 0.9012707722385142 b: 0.901270772238[..]
		extension: 	a MorphExtension (606190080) [balloonText]  [other:  (presenter [..]
		borderWidth: 	0
		borderColor: 	#simple
		model: 	a SpMorphicToolbarButtonAdapter
		label: 	'Do it'
		icon: 	Form(13x13x32)
		getIconSelector: 	#icon
		getStateSelector: 	#state
		actionSelector: 	#execute
		font: 	a LogicalFont
 familyName: 'Source Sans Pro'
 emphasis: nil
 pointSiz[..]
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	nil
		getFontSelector: 	nil
		labelMorph: 	a LabelMorph(576130816)'Do it'
		iconMorph: 	an ImageMorph(527603200)
		iconPosition: 	#top
		lastState: 	false
		badgeFont: 	nil
		badgeSelector: 	#badge


[
		result := focusHolder handleFocusEvent: transformedEvent.
	] in HandMorph>>sendFocusEvent:to:clear:
	Receiver: a HandMorph(337424384)
	Arguments and temporary variables: 
		anEvent: 	[(480@211) mouseUp 11368550 nil]
		focusHolder: 	a SpToolbarButtonMorph(163457024)
		aBlock: 	[self mouseFocus: nil]
		w: 	a WorldMorph(341720576) [world]
		transformedEvent: 	[(25.0@23.0) mouseUp 11368550 nil]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(480@211.0) corner: (496@227.0)
		owner: 	a WorldMorph(341720576) [world]
		submorphs: 	#()
		fullBounds: 	(480@211.0) corner: (496@227.0)
		color: 	Color blue
		extension: 	a MorphExtension (370611968)
		mouseFocus: 	nil
		keyboardFocus: 	a RubEditingArea(143191808)
		eventListeners: 	nil
		mouseListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(480@211) mouseUp 11368550 nil]
		targetOffset: 	(25.0@18.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 0 0 0 0 0 nil nil)
		captureBlock: 	nil
		recentModifiers: 	0
		pendingEventQueue: 	WaitfreeQueue with 0 items
		supressNextKeyPress: 	false


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
		result := focusHolder handleFocusEvent: transformedEvent.
	]
	Arguments and temporary variables: 
		exception: 	Error
		handlerAction: 	[ :ex |
			ActiveWorld := priorWorld.
			ex pass ]
	Receiver's instance variables: 
		outerContext: 	HandMorph>>sendFocusEvent:to:clear:
		compiledBlock: 	a CompiledBlock: [
		result := focusHolder handleFocusEvent:[..]
		numArgs: 	0
		receiver: 	a HandMorph(337424384)


WorldMorph>>becomeActiveDuring:
	Receiver: a WorldMorph(341720576) [world]
	Arguments and temporary variables: 
		aBlock: 	[
		result := focusHolder handleFocusEvent: transformedEvent.
	]
		priorWorld: 	a WorldMorph(341720576) [world]
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1728@1080)
		owner: 	nil
		submorphs: 	an Array(a MenubarMorph(112886016) a TaskbarMorph(279458560) a S[..]
		fullBounds: 	(0@0) corner: (1728@1080)
		color: 	(Color r: 0.9403714565004888 g: 0.9403714565004888 b: 0.940371456500[..]
		extension: 	a MorphExtension (1012946432) [other:  (dragEnabled -> true) (dr[..]
		borderWidth: 	0
		borderColor: 	(Color r: 0.8611925708699902 g: 1.0 b: 0.7223851417399805 alph[..]
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil


HandMorph>>sendFocusEvent:to:clear:
	Receiver: a HandMorph(337424384)
	Arguments and temporary variables: 
		result: 	nil
		anEvent: 	[(480@211) mouseUp 11368550 nil]
		focusHolder: 	a SpToolbarButtonMorph(163457024)
		aBlock: 	[self mouseFocus: nil]
		w: 	a WorldMorph(341720576) [world]
		transformedEvent: 	[(25.0@23.0) mouseUp 11368550 nil]
	Receiver's instance variables: 
		bounds: 	(480@211.0) corner: (496@227.0)
		owner: 	a WorldMorph(341720576) [world]
		submorphs: 	#()
		fullBounds: 	(480@211.0) corner: (496@227.0)
		color: 	Color blue
		extension: 	a MorphExtension (370611968)
		mouseFocus: 	nil
		keyboardFocus: 	a RubEditingArea(143191808)
		eventListeners: 	nil
		mouseListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(480@211) mouseUp 11368550 nil]
		targetOffset: 	(25.0@18.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 0 0 0 0 0 nil nil)
		captureBlock: 	nil
		recentModifiers: 	0
		pendingEventQueue: 	WaitfreeQueue with 0 items
		supressNextKeyPress: 	false


HandMorph>>sendEvent:focus:clear:
	Receiver: a HandMorph(337424384)
	Arguments and temporary variables: 
		anEvent: 	[(480@211) mouseUp 11368550 nil]
		focusHolder: 	a SpToolbarButtonMorph(163457024)
		aBlock: 	[self mouseFocus: nil]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(480@211.0) corner: (496@227.0)
		owner: 	a WorldMorph(341720576) [world]
		submorphs: 	#()
		fullBounds: 	(480@211.0) corner: (496@227.0)
		color: 	Color blue
		extension: 	a MorphExtension (370611968)
		mouseFocus: 	nil
		keyboardFocus: 	a RubEditingArea(143191808)
		eventListeners: 	nil
		mouseListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(480@211) mouseUp 11368550 nil]
		targetOffset: 	(25.0@18.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 0 0 0 0 0 nil nil)
		captureBlock: 	nil
		recentModifiers: 	0
		pendingEventQueue: 	WaitfreeQueue with 0 items
		supressNextKeyPress: 	false


HandMorph>>sendMouseEvent:
	Receiver: a HandMorph(337424384)
	Arguments and temporary variables: 
		anEvent: 	[(480@211) mouseUp 11368550 nil]
	Receiver's instance variables: 
		bounds: 	(480@211.0) corner: (496@227.0)
		owner: 	a WorldMorph(341720576) [world]
		submorphs: 	#()
		fullBounds: 	(480@211.0) corner: (496@227.0)
		color: 	Color blue
		extension: 	a MorphExtension (370611968)
		mouseFocus: 	nil
		keyboardFocus: 	a RubEditingArea(143191808)
		eventListeners: 	nil
		mouseListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(480@211) mouseUp 11368550 nil]
		targetOffset: 	(25.0@18.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 0 0 0 0 0 nil nil)
		captureBlock: 	nil
		recentModifiers: 	0
		pendingEventQueue: 	WaitfreeQueue with 0 items
		supressNextKeyPress: 	false


HandMorph>>handleEvent:
	Receiver: a HandMorph(337424384)
	Arguments and temporary variables: 
		anEvent: 	[(480@211) mouseUp 11368550 nil]
		evt: 	[(480@211) mouseUp 11368550 nil]
	Receiver's instance variables: 
		bounds: 	(480@211.0) corner: (496@227.0)
		owner: 	a WorldMorph(341720576) [world]
		submorphs: 	#()
		fullBounds: 	(480@211.0) corner: (496@227.0)
		color: 	Color blue
		extension: 	a MorphExtension (370611968)
		mouseFocus: 	nil
		keyboardFocus: 	a RubEditingArea(143191808)
		eventListeners: 	nil
		mouseListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(480@211) mouseUp 11368550 nil]
		targetOffset: 	(25.0@18.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 0 0 0 0 0 nil nil)
		captureBlock: 	nil
		recentModifiers: 	0
		pendingEventQueue: 	WaitfreeQueue with 0 items
		supressNextKeyPress: 	false


[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil ]) ifTrue: [
			morphicWorld activeHand handleEvent: anEvent
		]
	] in OSWindowMorphicEventHandler>>dispatchMorphicEvent:
	Receiver: an OSWindowMorphicEventHandler
	Arguments and temporary variables: 
		anEvent: 	[(480@211) mouseUp 11368550 nil]
	Receiver's instance variables: 
		morphicWorld: 	a WorldMorph(341720576) [world]


WorldState>>runStepMethodsIn:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(341720576) [world]
		queue: 	WaitfreeQueue with 0 items
		nextInQueue: 	[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNo[..]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(337424384))
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap()
		lastStepTime: 	11344935
		lastStepMessage: 	nil
		alarms: 	a Heap(MorphicAlarm(#hideShow -> a RubCursor(27124480)))
		lastAlarmTime: 	11368528
		activeHand: 	a HandMorph(337424384)
		currentCursor: 	((CursorWithMask
	extent: (16@16)
	depth: 1
	fromArray: #(
	[..]
		worldRenderer: 	an OSWorldRenderer
		realWindowExtent: 	(1728@1080)
		deferredUIMessages: 	WaitfreeQueue with 0 items


WorldMorph>>runStepMethods
	Receiver: a WorldMorph(341720576) [world]
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1728@1080)
		owner: 	nil
		submorphs: 	an Array(a MenubarMorph(112886016) a TaskbarMorph(279458560) a S[..]
		fullBounds: 	(0@0) corner: (1728@1080)
		color: 	(Color r: 0.9403714565004888 g: 0.9403714565004888 b: 0.940371456500[..]
		extension: 	a MorphExtension (1012946432) [other:  (dragEnabled -> true) (dr[..]
		borderWidth: 	0
		borderColor: 	(Color r: 0.8611925708699902 g: 1.0 b: 0.7223851417399805 alph[..]
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil


WorldState>>doOneCycleFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(341720576) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(337424384))
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap()
		lastStepTime: 	11344935
		lastStepMessage: 	nil
		alarms: 	a Heap(MorphicAlarm(#hideShow -> a RubCursor(27124480)))
		lastAlarmTime: 	11368528
		activeHand: 	a HandMorph(337424384)
		currentCursor: 	((CursorWithMask
	extent: (16@16)
	depth: 1
	fromArray: #(
	[..]
		worldRenderer: 	an OSWorldRenderer
		realWindowExtent: 	(1728@1080)
		deferredUIMessages: 	WaitfreeQueue with 0 items


WorldMorph>>doOneCycleNow
	Receiver: a WorldMorph(341720576) [world]
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1728@1080)
		owner: 	nil
		submorphs: 	an Array(a MenubarMorph(112886016) a TaskbarMorph(279458560) a S[..]
		fullBounds: 	(0@0) corner: (1728@1080)
		color: 	(Color r: 0.9403714565004888 g: 0.9403714565004888 b: 0.940371456500[..]
		extension: 	a MorphExtension (1012946432) [other:  (dragEnabled -> true) (dr[..]
		borderWidth: 	0
		borderColor: 	(Color r: 0.8611925708699902 g: 1.0 b: 0.7223851417399805 alph[..]
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil


WorldMorph>>doOneCycle
	Receiver: a WorldMorph(341720576) [world]
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1728@1080)
		owner: 	nil
		submorphs: 	an Array(a MenubarMorph(112886016) a TaskbarMorph(279458560) a S[..]
		fullBounds: 	(0@0) corner: (1728@1080)
		color: 	(Color r: 0.9403714565004888 g: 0.9403714565004888 b: 0.940371456500[..]
		extension: 	a MorphExtension (1012946432) [other:  (dragEnabled -> true) (dr[..]
		borderWidth: 	0
		borderColor: 	(Color r: 0.8611925708699902 g: 1.0 b: 0.7223851417399805 alph[..]
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil



--- The full stack ---
RSBox(Object)>>doesNotUnderstand: #center
[ :edgeDict |
        | edge sourceNode targetNode |
        sourceNode := nodesMap at: (edgeDict at: #source) ifAbsent: [ nil ].
        targetNode := nodesMap at: (edgeDict at: #target) ifAbsent: [ nil ].
        sourceNode ifNotNil: [ targetNode ifNotNil: [
            edge := RSLine new from: sourceNode center to: targetNode center.
            edge canvas add: edge.
        ]].
    ] in GraphVisualizer>>createEdges
Array(SequenceableCollection)>>do:
GraphVisualizer>>createEdges
GraphVisualizer>>visualizeGraphFromFile:
UndefinedObject>>DoIt
OCReceiverDoItSemanticScope(OCDoItSemanticScope)>>evaluateDoIt:
OpalCompiler>>evaluate
[
		self announcer announce: (SpCodeWillBeEvaluatedAnnouncement newContent: aString).
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionModel doItReceiver.
		result := receiver class compiler
			source: aString;
			context: self interactionModel doItContext;
			receiver: self interactionModel doItReceiver;
			requestor: self interactionModel;
			environment: self environment;
			failBlock:  [ 
				self announcer announce: (SpCodeEvaluationFailedAnnouncement newContent: aString).
				^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		self announcer announce: (SpCodeEvaluationSucceedAnnouncement newContent: aString).
		result ] in SpCodePresenter>>evaluate:onCompileError:onError:
FullBlockClosure(BlockClosure)>>on:do:
SpCodePresenter>>evaluate:onCompileError:onError:
StPlaygroundPagePresenter>>doEvaluateAndGo
StPlaygroundPagePresenter>>doEvaluateAllAndGo
StPlaygroundDoItCommand>>execute
SpCommand(CmCommandDecorator)>>execute
[ specCommand execute ] in [ :specCommand | 
			aButtonClass new
				label: specCommand name;
				help: specCommand description;
				in: [ :button | 
					specCommand hasIcon
						ifTrue: [ button icon: specCommand icon ] ];
				action: [ specCommand execute ];
				yourself ] in SpCommand>>configureAsButtonOfClass:
FullBlockClosure(BlockClosure)>>cull:
SpMorphicToolbarButtonAdapter>>execute
SpToolbarButtonMorph(PluggableButtonMorph)>>performAction:
[:m |
		(m containsPoint: evt cursorPoint) ifTrue: [m enabled ifTrue: [ m performAction: evt ]]] in SpToolbarButtonMorph(PluggableButtonMorph)>>mouseUp:
Array(SequenceableCollection)>>do:
SpToolbarButtonMorph(PluggableButtonMorph)>>mouseUp:
SpToolbarButtonMorph(Morph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
SpToolbarButtonMorph(Morph)>>handleEvent:
SpToolbarButtonMorph(Morph)>>handleFocusEvent:
[
		result := focusHolder handleFocusEvent: transformedEvent.
	] in HandMorph>>sendFocusEvent:to:clear:
FullBlockClosure(BlockClosure)>>on:do:
WorldMorph>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil ]) ifTrue: [
			morphicWorld activeHand handleEvent: anEvent
		]
	] in OSWindowMorphicEventHandler>>dispatchMorphicEvent:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycleNow
WorldMorph>>doOneCycle
 - - - - - - - - - - - - - - -
			- - - - - - - - - - - - - - - - - -
[
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMutex critical: [
			                     self extraWorldList ].
		extraWorldsToDraw do: [ :world | world doOneCycle ].

		(self currentWorld isNotNil and: [
			 (extraWorldsToDraw includes: self currentWorld) not ]) ifTrue: [
			self currentWorld doOneCycle ] ] in WorldMorph class>>doOneCycle
FullBlockClosure(BlockClosure)>>ensure:
WorldState class>>doDrawCycleWith:
WorldMorph class>>doOneCycle
MorphicRenderLoop>>doOneCycle
MorphicRenderLoop>>doOneCycleWhile:
[ MorphicRenderLoop new doOneCycleWhile: [ true ] ] in MorphicUIManager>>spawnNewProcess
[self value.
			"IMPORTANT: Do not step over next line of code. See method comments for details"
			Processor terminateRealActive] in FullBlockClosure(BlockClosure)>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
Instance of RSLine did not understand #from:to:
13 November 2023 7:16:36.987889 pm

VM: Mac OS - arm64 - 1000 - CoInterpreter VMMaker-tonel.1 uuid: 902dd483-c0c4-0d00-86f2-0f880df24b96 Oct 23 2023
StackToRegisterMappingCogit VMMaker-tonel.1 uuid: 902dd483-c0c4-0d00-86f2-0f880df24b96 Oct 23 2023
v10.0.8 - Commit: b323c5fb - Date: 2023-10-20 16:02:07 -0400

Image: Pharo11.0.0 [Build information: Pharo-11.0.0+build.710.sha.ea28d8552cac85a7ce1e9c34ab1e7bd45f7b9910 (64 Bit)]

RSLine(Object)>>doesNotUnderstand: #from:to:
	Receiver: a RSLine
	Arguments and temporary variables: 
		aMessage: 	from: (0.0@0.0) to: (0.0@0.0)
		exception: 	Instance of RSLine did not understand #from:to:
		resumeValue: 	nil
	Receiver's instance variables: 
		announcer: 	nil
		properties: 	nil
		paint: 	nil
		path: 	nil
		border: 	1, Color gray
		parent: 	nil
		isFixed: 	false
		encompassingRectangle: 	nil
		model: 	nil
		attachPoint: 	a RSCenteredAttachPoint
		from: 	nil
		to: 	nil
		markers: 	nil
		startPoint: 	(0@0)
		endPoint: 	(100@100)


[ :edgeDict |
        | edge sourceNode targetNode sourcePosition targetPosition |
        sourceNode := nodesMap at: (edgeDict at: #source) ifAbsent: [ nil ].
        targetNode := nodesMap at: (edgeDict at: #target) ifAbsent: [ nil ].
        sourceNode ifNotNil: [ targetNode ifNotNil: [
            "Calculate center or get position differently"
            sourcePosition := sourceNode position.
            targetPosition := targetNode position.
            edge := RSLine new from: sourcePosition to: targetPosition.
            canvas add: edge.
        ]].
    ] in GraphVisualizer>>createEdges
	Receiver: a GraphVisualizer
	Arguments and temporary variables: 
		edgeDict: 	a Dictionary('source'->1 'target'->2 'type'->'FRIENDS_WITH' )
		edge: 	nil
		sourceNode: 	a RSBox
		targetNode: 	a RSBox
		sourcePosition: 	(0.0@0.0)
		targetPosition: 	(0.0@0.0)
	Receiver's instance variables: 
		view: 	nil
		nodes: 	an Array(a Dictionary('id'->1 'label'->'Person' 'properties'->a Dict[..]
		edges: 	an Array(a Dictionary('source'->1 'target'->2 'type'->'FRIENDS_WITH' ))
		nodesMap: 	a Dictionary(1->a RSBox 2->a RSBox )
		canvas: 	a RSCanvas


Array(SequenceableCollection)>>do:
	Receiver: an Array(a Dictionary('source'->1 'target'->2 'type'->'FRIENDS_WITH' ))
	Arguments and temporary variables: 
		aBlock: 	[ :edgeDict |
        | edge sourceNode targetNode sourcePosition t[..]
		index: 	1
	Receiver's instance variables: 
an Array(a Dictionary('source'->1 'target'->2 'type'->'FRIENDS_WITH' ))

GraphVisualizer>>createEdges
	Receiver: a GraphVisualizer
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		view: 	nil
		nodes: 	an Array(a Dictionary('id'->1 'label'->'Person' 'properties'->a Dict[..]
		edges: 	an Array(a Dictionary('source'->1 'target'->2 'type'->'FRIENDS_WITH' ))
		nodesMap: 	a Dictionary(1->a RSBox 2->a RSBox )
		canvas: 	a RSCanvas


GraphVisualizer>>visualizeGraphFromFile:
	Receiver: a GraphVisualizer
	Arguments and temporary variables: 
		aFilePath: 	'/Users/ryanperez/Documents/GitHub/pp-rep2533/project/src/data/t[..]
	Receiver's instance variables: 
		view: 	nil
		nodes: 	an Array(a Dictionary('id'->1 'label'->'Person' 'properties'->a Dict[..]
		edges: 	an Array(a Dictionary('source'->1 'target'->2 'type'->'FRIENDS_WITH' ))
		nodesMap: 	a Dictionary(1->a RSBox 2->a RSBox )
		canvas: 	a RSCanvas


UndefinedObject>>DoIt
	Receiver: nil
	Arguments and temporary variables: 
		visualizer: 	a GraphVisualizer
	Receiver's instance variables: 
nil

OCReceiverDoItSemanticScope(OCDoItSemanticScope)>>evaluateDoIt:
	Receiver: an OCReceiverDoItSemanticScope
	Arguments and temporary variables: 
		doItMethod: 	UndefinedObject>>#DoIt
	Receiver's instance variables: 
		outerScope: 	nil
		targetReceiver: 	nil


OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
		doItMethod: 	UndefinedObject>>#DoIt
	Receiver's instance variables: 
		ast: 	DoIt

	| visualizer |
	visualizer := GraphVisualizer new.
	^ visualize[..]
		source: 	a ReadStream
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil


[
		self announcer announce: (SpCodeWillBeEvaluatedAnnouncement newContent: aString).
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionModel doItReceiver.
		result := receiver class compiler
			source: aString;
			context: self interactionModel doItContext;
			receiver: self interactionModel doItReceiver;
			requestor: self interactionModel;
			environment: self environment;
			failBlock:  [ 
				self announcer announce: (SpCodeEvaluationFailedAnnouncement newContent: aString).
				^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		self announcer announce: (SpCodeEvaluationSucceedAnnouncement newContent: aString).
		result ] in SpCodePresenter>>evaluate:onCompileError:onError:
	Receiver: a SpCodePresenter
	Arguments and temporary variables: 
		aString: 	'| visualizer |
visualizer := GraphVisualizer new.
visualizer visu[..]
		compileErrorBlock: 	[ ^ self ]
		errorBlock: 	[ :e | e pass ]
		receiver: 	nil
		result: 	nil
		oldBindings: 	a Dictionary()
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicCodeAdapter)
		announcer: 	an Announcer
		owner: 	a StPlaygroundPagePresenter
		adapter: 	a SpMorphicCodeAdapter
		needRebuild: 	true
		eventHandler: 	a SpEventHandler
		application: 	nil
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ a KMCategory ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Code' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpAbstractWidgetLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		borderWidth: 	an ObservableValueHolder[ nil ]
		borderColor: 	an ObservableValueHolder[ nil ]
		dragEnabled: 	an ObservableValueHolder[ false ]
		dropEnabled: 	an ObservableValueHolder[ false ]
		color: 	an ObservableValueHolder[ nil ]
		help: 	an ObservableValueHolder[ nil ]
		enabled: 	an ObservableValueHolder[ true ]
		wantsDrop: 	an ObservableValueHolder[ [ :transfer | self dropEnabled ] ]
		acceptDrop: 	an ObservableValueHolder[ [ :transfer | ] ]
		deferredActions: 	nil
		hasUnacceptedEdits: 	an ObservableValueHolder[ false ]
		selection: 	an ObservableValueHolder[ (1 to: 159) ]
		wantsVisualFeedback: 	an ObservableValueHolder[ true ]
		askBeforeDiscardingEdits: 	an ObservableValueHolder[ true ]
		text: 	an ObservableValueHolder[ '| visualizer |
visualizer := GraphVisualiz[..]
		actionToPerform: 	an ObservableValueHolder[ [ :txt |  ] ]
		readSelection: 	an ObservableValueHolder[ [ selection ] ]
		placeholder: 	an ObservableValueHolder[ '' ]
		contextMenu: 	an ObservableValueHolder[ [ (self menuActionsFor: text) asMenu[..]
		scrollValue: 	an ObservableValueHolder[ (0@0) ]
		editionContextMenu: 	an ObservableValueHolder[ true ]
		editable: 	an ObservableValueHolder[ true ]
		wrapWord: 	an ObservableValueHolder[ true ]
		undoRedoHistory: 	true
		wrapScrollBars: 	true
		propagateNaturalHeight: 	false
		propagateNaturalWidth: 	false
		scrollBarStyles: 	#()
		syntaxHighlight: 	an ObservableValueHolder[ true ]
		smartCharacters: 	an ObservableValueHolder[ true ]
		lineNumbers: 	an ObservableValueHolder[ true ]
		interactionModel: 	an ObservableValueHolder[ a StPlaygroundInteractionModel ]
		overrideContextMenu: 	true
		submitBlock: 	nil
		resetBlock: 	nil
		environment: 	nil
		systemNavigation: 	nil
		syntaxHighlightTheme: 	an ObservableValueHolder[ nil ]


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
		self announcer announce: (SpCodeWillBeEvaluatedAnnouncement newContent: aString).
[..]
	Arguments and temporary variables: 
		exception: 	Error
		handlerAction: 	[ :e |
		self announcer announce: (SpCodeEvaluationFailedAnn[..]
	Receiver's instance variables: 
		outerContext: 	SpCodePresenter>>evaluate:onCompileError:onError:
		compiledBlock: 	a CompiledBlock: [
		self announcer announce: (SpCodeWillBeE[..]
		numArgs: 	0
		receiver: 	a SpCodePresenter


SpCodePresenter>>evaluate:onCompileError:onError:
	Receiver: a SpCodePresenter
	Arguments and temporary variables: 
		receiver: 	nil
		result: 	nil
		oldBindings: 	a Dictionary()
		aString: 	'| visualizer |
visualizer := GraphVisualizer new.
visualizer visu[..]
		compileErrorBlock: 	[ ^ self ]
		errorBlock: 	[ :e | e pass ]
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicCodeAdapter)
		announcer: 	an Announcer
		owner: 	a StPlaygroundPagePresenter
		adapter: 	a SpMorphicCodeAdapter
		needRebuild: 	true
		eventHandler: 	a SpEventHandler
		application: 	nil
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ a KMCategory ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Code' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpAbstractWidgetLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		borderWidth: 	an ObservableValueHolder[ nil ]
		borderColor: 	an ObservableValueHolder[ nil ]
		dragEnabled: 	an ObservableValueHolder[ false ]
		dropEnabled: 	an ObservableValueHolder[ false ]
		color: 	an ObservableValueHolder[ nil ]
		help: 	an ObservableValueHolder[ nil ]
		enabled: 	an ObservableValueHolder[ true ]
		wantsDrop: 	an ObservableValueHolder[ [ :transfer | self dropEnabled ] ]
		acceptDrop: 	an ObservableValueHolder[ [ :transfer | ] ]
		deferredActions: 	nil
		hasUnacceptedEdits: 	an ObservableValueHolder[ false ]
		selection: 	an ObservableValueHolder[ (1 to: 159) ]
		wantsVisualFeedback: 	an ObservableValueHolder[ true ]
		askBeforeDiscardingEdits: 	an ObservableValueHolder[ true ]
		text: 	an ObservableValueHolder[ '| visualizer |
visualizer := GraphVisualiz[..]
		actionToPerform: 	an ObservableValueHolder[ [ :txt |  ] ]
		readSelection: 	an ObservableValueHolder[ [ selection ] ]
		placeholder: 	an ObservableValueHolder[ '' ]
		contextMenu: 	an ObservableValueHolder[ [ (self menuActionsFor: text) asMenu[..]
		scrollValue: 	an ObservableValueHolder[ (0@0) ]
		editionContextMenu: 	an ObservableValueHolder[ true ]
		editable: 	an ObservableValueHolder[ true ]
		wrapWord: 	an ObservableValueHolder[ true ]
		undoRedoHistory: 	true
		wrapScrollBars: 	true
		propagateNaturalHeight: 	false
		propagateNaturalWidth: 	false
		scrollBarStyles: 	#()
		syntaxHighlight: 	an ObservableValueHolder[ true ]
		smartCharacters: 	an ObservableValueHolder[ true ]
		lineNumbers: 	an ObservableValueHolder[ true ]
		interactionModel: 	an ObservableValueHolder[ a StPlaygroundInteractionModel ]
		overrideContextMenu: 	true
		submitBlock: 	nil
		resetBlock: 	nil
		environment: 	nil
		systemNavigation: 	nil
		syntaxHighlightTheme: 	an ObservableValueHolder[ nil ]


StPlaygroundPagePresenter>>doEvaluateAndGo
	Receiver: a StPlaygroundPagePresenter
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicBoxAdapter)
		announcer: 	an Announcer
		owner: 	a SpMillerColumnPresenter
		adapter: 	a SpMorphicBoxAdapter
		needRebuild: 	true
		eventHandler: 	nil
		application: 	a StPharoApplication
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ nil ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Untitled window' ]
		additionalSubpresentersMap: 	a Dictionary()
		layout: 	an ObservableValueHolder[ a SpBoxLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		text: 	a SpCodePresenter
		toolbar: 	a SpToolbarPresenter
		statusbar: 	a SpPresenter
		lineLabel: 	a SpLabelPresenter
		toggleLineNumberButton: 	a SpToggleButtonPresenter
		page: 	a StPlaygroundPage
		activationBlock: 	[ :selection |
		self changeSelection: selection from: new[..]


StPlaygroundPagePresenter>>doEvaluateAllAndGo
	Receiver: a StPlaygroundPagePresenter
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicBoxAdapter)
		announcer: 	an Announcer
		owner: 	a SpMillerColumnPresenter
		adapter: 	a SpMorphicBoxAdapter
		needRebuild: 	true
		eventHandler: 	nil
		application: 	a StPharoApplication
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ nil ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Untitled window' ]
		additionalSubpresentersMap: 	a Dictionary()
		layout: 	an ObservableValueHolder[ a SpBoxLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		text: 	a SpCodePresenter
		toolbar: 	a SpToolbarPresenter
		statusbar: 	a SpPresenter
		lineLabel: 	a SpLabelPresenter
		toggleLineNumberButton: 	a SpToggleButtonPresenter
		page: 	a StPlaygroundPage
		activationBlock: 	[ :selection |
		self changeSelection: selection from: new[..]


StPlaygroundDoItCommand>>execute
	Receiver: a StPlaygroundDoItCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		context: 	a StPlaygroundPagePresenter
		basicName: 	'Do it'
		basicDescription: 	'Do it all and inspect.'


SpCommand(CmCommandDecorator)>>execute
	Receiver: a SpCommand(Do it)
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a StPlaygroundDoItCommand
		iconProvider: 	a StPharoApplication
		iconName: 	#glamorousGo
		shortcutKey: 	nil
		displayStrategy: 	a CmUIDisableWhenCantBeRun
		positionStrategy: 	a CmUILeftPositionStrategy
		buildPresenterBlock: 	[ :specCommand | 
			aButtonClass new
				label: specC[..]
		presenter: 	a SpToolbarButtonPresenter


[ specCommand execute ] in [ :specCommand | 
			aButtonClass new
				label: specCommand name;
				help: specCommand description;
				in: [ :button | 
					specCommand hasIcon
						ifTrue: [ button icon: specCommand icon ] ];
				action: [ specCommand execute ];
				yourself ] in SpCommand>>configureAsButtonOfClass:
	Receiver: a SpCommand(Do it)
	Arguments and temporary variables: 
		aButtonClass: 	nil
		specCommand: 	a SpCommand(Do it)
	Receiver's instance variables: 
		decoratedCommand: 	a StPlaygroundDoItCommand
		iconProvider: 	a StPharoApplication
		iconName: 	#glamorousGo
		shortcutKey: 	nil
		displayStrategy: 	a CmUIDisableWhenCantBeRun
		positionStrategy: 	a CmUILeftPositionStrategy
		buildPresenterBlock: 	[ :specCommand | 
			aButtonClass new
				label: specC[..]
		presenter: 	a SpToolbarButtonPresenter


FullBlockClosure(BlockClosure)>>cull:
	Receiver: [ specCommand execute ]
	Arguments and temporary variables: 
		anArg: 	a SpToolbarButtonPresenter
	Receiver's instance variables: 
		outerContext: 	[ :specCommand | 
			aButtonClass new
				label: specCommand [..]
		compiledBlock: 	a CompiledBlock: [ specCommand execute ]
		numArgs: 	0
		receiver: 	a SpCommand(Do it)


SpMorphicToolbarButtonAdapter>>execute
	Receiver: a SpMorphicToolbarButtonAdapter
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpToolbarButtonMorph(163457024))
		announcer: 	nil
		model: 	a SpToolbarButtonPresenter
		widget: 	a SpToolbarButtonMorph(163457024)
		selector: 	nil
		owner: 	a SpToolbarButtonPresenter
		unsubscribed: 	false


SpToolbarButtonMorph(PluggableButtonMorph)>>performAction:
	Receiver: a SpToolbarButtonMorph(163457024)
	Arguments and temporary variables: 
		event: 	[(24.0@12.0) mouseUp 11515094 nil]
	Receiver's instance variables: 
		bounds: 	(0.0@5.0) corner: (45.0@39.0)
		owner: 	a Morph(543889152)
		submorphs: 	an Array(an AlignmentMorph(1048008448))
		fullBounds: 	nil
		color: 	(Color r: 0.9012707722385142 g: 0.9012707722385142 b: 0.901270772238[..]
		extension: 	a MorphExtension (606190080) [balloonText]  [other:  (presenter [..]
		borderWidth: 	0
		borderColor: 	#simple
		model: 	a SpMorphicToolbarButtonAdapter
		label: 	'Do it'
		icon: 	Form(13x13x32)
		getIconSelector: 	#icon
		getStateSelector: 	#state
		actionSelector: 	#execute
		font: 	a LogicalFont
 familyName: 'Source Sans Pro'
 emphasis: nil
 pointSiz[..]
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	nil
		getFontSelector: 	nil
		labelMorph: 	a LabelMorph(576130816)'Do it'
		iconMorph: 	an ImageMorph(527603200)
		iconPosition: 	#top
		lastState: 	false
		badgeFont: 	nil
		badgeSelector: 	#badge


[:m |
		(m containsPoint: evt cursorPoint) ifTrue: [m enabled ifTrue: [ m performAction: evt ]]] in SpToolbarButtonMorph(PluggableButtonMorph)>>mouseUp:
	Receiver: a SpToolbarButtonMorph(163457024)
	Arguments and temporary variables: 
		evt: 	[(24.0@12.0) mouseUp 11515094 nil]
		all: 	an Array(a SpToolbarButtonMorph(163457024) a SpToolbarButtonMorph(6416[..]
		m: 	a SpToolbarButtonMorph(163457024)
	Receiver's instance variables: 
		bounds: 	(0.0@5.0) corner: (45.0@39.0)
		owner: 	a Morph(543889152)
		submorphs: 	an Array(an AlignmentMorph(1048008448))
		fullBounds: 	nil
		color: 	(Color r: 0.9012707722385142 g: 0.9012707722385142 b: 0.901270772238[..]
		extension: 	a MorphExtension (606190080) [balloonText]  [other:  (presenter [..]
		borderWidth: 	0
		borderColor: 	#simple
		model: 	a SpMorphicToolbarButtonAdapter
		label: 	'Do it'
		icon: 	Form(13x13x32)
		getIconSelector: 	#icon
		getStateSelector: 	#state
		actionSelector: 	#execute
		font: 	a LogicalFont
 familyName: 'Source Sans Pro'
 emphasis: nil
 pointSiz[..]
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	nil
		getFontSelector: 	nil
		labelMorph: 	a LabelMorph(576130816)'Do it'
		iconMorph: 	an ImageMorph(527603200)
		iconPosition: 	#top
		lastState: 	false
		badgeFont: 	nil
		badgeSelector: 	#badge


Array(SequenceableCollection)>>do:
	Receiver: an Array(a SpToolbarButtonMorph(163457024) a SpToolbarButtonMorph(641645312) a SpToolb[..]
	Arguments and temporary variables: 
		aBlock: 	[:m |
		(m containsPoint: evt cursorPoint) ifTrue: [m enabled ifTru[..]
		index: 	1
	Receiver's instance variables: 
an Array(a SpToolbarButtonMorph(163457024) a SpToolbarButtonMorph(641645312) a SpToolb[..]

SpToolbarButtonMorph(PluggableButtonMorph)>>mouseUp:
	Receiver: a SpToolbarButtonMorph(163457024)
	Arguments and temporary variables: 
		evt: 	[(24.0@12.0) mouseUp 11515094 nil]
		all: 	an Array(a SpToolbarButtonMorph(163457024) a SpToolbarButtonMorph(6416[..]
	Receiver's instance variables: 
		bounds: 	(0.0@5.0) corner: (45.0@39.0)
		owner: 	a Morph(543889152)
		submorphs: 	an Array(an AlignmentMorph(1048008448))
		fullBounds: 	nil
		color: 	(Color r: 0.9012707722385142 g: 0.9012707722385142 b: 0.901270772238[..]
		extension: 	a MorphExtension (606190080) [balloonText]  [other:  (presenter [..]
		borderWidth: 	0
		borderColor: 	#simple
		model: 	a SpMorphicToolbarButtonAdapter
		label: 	'Do it'
		icon: 	Form(13x13x32)
		getIconSelector: 	#icon
		getStateSelector: 	#state
		actionSelector: 	#execute
		font: 	a LogicalFont
 familyName: 'Source Sans Pro'
 emphasis: nil
 pointSiz[..]
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	nil
		getFontSelector: 	nil
		labelMorph: 	a LabelMorph(576130816)'Do it'
		iconMorph: 	an ImageMorph(527603200)
		iconPosition: 	#top
		lastState: 	false
		badgeFont: 	nil
		badgeSelector: 	#badge


SpToolbarButtonMorph(Morph)>>handleMouseUp:
	Receiver: a SpToolbarButtonMorph(163457024)
	Arguments and temporary variables: 
		anEvent: 	[(24.0@12.0) mouseUp 11515094 nil]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(0.0@5.0) corner: (45.0@39.0)
		owner: 	a Morph(543889152)
		submorphs: 	an Array(an AlignmentMorph(1048008448))
		fullBounds: 	nil
		color: 	(Color r: 0.9012707722385142 g: 0.9012707722385142 b: 0.901270772238[..]
		extension: 	a MorphExtension (606190080) [balloonText]  [other:  (presenter [..]
		borderWidth: 	0
		borderColor: 	#simple
		model: 	a SpMorphicToolbarButtonAdapter
		label: 	'Do it'
		icon: 	Form(13x13x32)
		getIconSelector: 	#icon
		getStateSelector: 	#state
		actionSelector: 	#execute
		font: 	a LogicalFont
 familyName: 'Source Sans Pro'
 emphasis: nil
 pointSiz[..]
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	nil
		getFontSelector: 	nil
		labelMorph: 	a LabelMorph(576130816)'Do it'
		iconMorph: 	an ImageMorph(527603200)
		iconPosition: 	#top
		lastState: 	false
		badgeFont: 	nil
		badgeSelector: 	#badge


MouseButtonEvent>>sentTo:
	Receiver: [(24.0@12.0) mouseUp 11515094 nil]
	Arguments and temporary variables: 
		anObject: 	a SpToolbarButtonMorph(163457024)
	Receiver's instance variables: 
		timeStamp: 	11515094
		source: 	a HandMorph(337424384)
		windowIndex: 	nil
		type: 	#mouseUp
		buttons: 	0
		position: 	(24.0@12.0)
		handler: 	nil
		wasHandled: 	true
		whichButton: 	4


SpToolbarButtonMorph(Morph)>>handleEvent:
	Receiver: a SpToolbarButtonMorph(163457024)
	Arguments and temporary variables: 
		anEvent: 	[(24.0@12.0) mouseUp 11515094 nil]
	Receiver's instance variables: 
		bounds: 	(0.0@5.0) corner: (45.0@39.0)
		owner: 	a Morph(543889152)
		submorphs: 	an Array(an AlignmentMorph(1048008448))
		fullBounds: 	nil
		color: 	(Color r: 0.9012707722385142 g: 0.9012707722385142 b: 0.901270772238[..]
		extension: 	a MorphExtension (606190080) [balloonText]  [other:  (presenter [..]
		borderWidth: 	0
		borderColor: 	#simple
		model: 	a SpMorphicToolbarButtonAdapter
		label: 	'Do it'
		icon: 	Form(13x13x32)
		getIconSelector: 	#icon
		getStateSelector: 	#state
		actionSelector: 	#execute
		font: 	a LogicalFont
 familyName: 'Source Sans Pro'
 emphasis: nil
 pointSiz[..]
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	nil
		getFontSelector: 	nil
		labelMorph: 	a LabelMorph(576130816)'Do it'
		iconMorph: 	an ImageMorph(527603200)
		iconPosition: 	#top
		lastState: 	false
		badgeFont: 	nil
		badgeSelector: 	#badge


SpToolbarButtonMorph(Morph)>>handleFocusEvent:
	Receiver: a SpToolbarButtonMorph(163457024)
	Arguments and temporary variables: 
		anEvent: 	[(24.0@12.0) mouseUp 11515094 nil]
	Receiver's instance variables: 
		bounds: 	(0.0@5.0) corner: (45.0@39.0)
		owner: 	a Morph(543889152)
		submorphs: 	an Array(an AlignmentMorph(1048008448))
		fullBounds: 	nil
		color: 	(Color r: 0.9012707722385142 g: 0.9012707722385142 b: 0.901270772238[..]
		extension: 	a MorphExtension (606190080) [balloonText]  [other:  (presenter [..]
		borderWidth: 	0
		borderColor: 	#simple
		model: 	a SpMorphicToolbarButtonAdapter
		label: 	'Do it'
		icon: 	Form(13x13x32)
		getIconSelector: 	#icon
		getStateSelector: 	#state
		actionSelector: 	#execute
		font: 	a LogicalFont
 familyName: 'Source Sans Pro'
 emphasis: nil
 pointSiz[..]
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	nil
		getFontSelector: 	nil
		labelMorph: 	a LabelMorph(576130816)'Do it'
		iconMorph: 	an ImageMorph(527603200)
		iconPosition: 	#top
		lastState: 	false
		badgeFont: 	nil
		badgeSelector: 	#badge


[
		result := focusHolder handleFocusEvent: transformedEvent.
	] in HandMorph>>sendFocusEvent:to:clear:
	Receiver: a HandMorph(337424384)
	Arguments and temporary variables: 
		anEvent: 	[(479@200) mouseUp 11515094 nil]
		focusHolder: 	a SpToolbarButtonMorph(163457024)
		aBlock: 	[self mouseFocus: nil]
		w: 	a WorldMorph(341720576) [world]
		transformedEvent: 	[(24.0@12.0) mouseUp 11515094 nil]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(479@200.0) corner: (495@216.0)
		owner: 	a WorldMorph(341720576) [world]
		submorphs: 	#()
		fullBounds: 	(479@200.0) corner: (495@216.0)
		color: 	Color blue
		extension: 	a MorphExtension (370611968)
		mouseFocus: 	nil
		keyboardFocus: 	a RubEditingArea(143191808)
		eventListeners: 	nil
		mouseListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(479@200) mouseUp 11515094 nil]
		targetOffset: 	(24.0@7.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 0 0 0 0 0 nil nil)
		captureBlock: 	nil
		recentModifiers: 	0
		pendingEventQueue: 	WaitfreeQueue with 0 items
		supressNextKeyPress: 	false


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
		result := focusHolder handleFocusEvent: transformedEvent.
	]
	Arguments and temporary variables: 
		exception: 	Error
		handlerAction: 	[ :ex |
			ActiveWorld := priorWorld.
			ex pass ]
	Receiver's instance variables: 
		outerContext: 	HandMorph>>sendFocusEvent:to:clear:
		compiledBlock: 	a CompiledBlock: [
		result := focusHolder handleFocusEvent:[..]
		numArgs: 	0
		receiver: 	a HandMorph(337424384)


WorldMorph>>becomeActiveDuring:
	Receiver: a WorldMorph(341720576) [world]
	Arguments and temporary variables: 
		aBlock: 	[
		result := focusHolder handleFocusEvent: transformedEvent.
	]
		priorWorld: 	a WorldMorph(341720576) [world]
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1728@1080)
		owner: 	nil
		submorphs: 	an Array(a MenubarMorph(112886016) a TaskbarMorph(279458560) a S[..]
		fullBounds: 	(0@0) corner: (1728@1080)
		color: 	(Color r: 0.9403714565004888 g: 0.9403714565004888 b: 0.940371456500[..]
		extension: 	a MorphExtension (1012946432) [other:  (dragEnabled -> true) (dr[..]
		borderWidth: 	0
		borderColor: 	(Color r: 0.8611925708699902 g: 1.0 b: 0.7223851417399805 alph[..]
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil


HandMorph>>sendFocusEvent:to:clear:
	Receiver: a HandMorph(337424384)
	Arguments and temporary variables: 
		result: 	nil
		anEvent: 	[(479@200) mouseUp 11515094 nil]
		focusHolder: 	a SpToolbarButtonMorph(163457024)
		aBlock: 	[self mouseFocus: nil]
		w: 	a WorldMorph(341720576) [world]
		transformedEvent: 	[(24.0@12.0) mouseUp 11515094 nil]
	Receiver's instance variables: 
		bounds: 	(479@200.0) corner: (495@216.0)
		owner: 	a WorldMorph(341720576) [world]
		submorphs: 	#()
		fullBounds: 	(479@200.0) corner: (495@216.0)
		color: 	Color blue
		extension: 	a MorphExtension (370611968)
		mouseFocus: 	nil
		keyboardFocus: 	a RubEditingArea(143191808)
		eventListeners: 	nil
		mouseListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(479@200) mouseUp 11515094 nil]
		targetOffset: 	(24.0@7.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 0 0 0 0 0 nil nil)
		captureBlock: 	nil
		recentModifiers: 	0
		pendingEventQueue: 	WaitfreeQueue with 0 items
		supressNextKeyPress: 	false


HandMorph>>sendEvent:focus:clear:
	Receiver: a HandMorph(337424384)
	Arguments and temporary variables: 
		anEvent: 	[(479@200) mouseUp 11515094 nil]
		focusHolder: 	a SpToolbarButtonMorph(163457024)
		aBlock: 	[self mouseFocus: nil]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(479@200.0) corner: (495@216.0)
		owner: 	a WorldMorph(341720576) [world]
		submorphs: 	#()
		fullBounds: 	(479@200.0) corner: (495@216.0)
		color: 	Color blue
		extension: 	a MorphExtension (370611968)
		mouseFocus: 	nil
		keyboardFocus: 	a RubEditingArea(143191808)
		eventListeners: 	nil
		mouseListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(479@200) mouseUp 11515094 nil]
		targetOffset: 	(24.0@7.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 0 0 0 0 0 nil nil)
		captureBlock: 	nil
		recentModifiers: 	0
		pendingEventQueue: 	WaitfreeQueue with 0 items
		supressNextKeyPress: 	false


HandMorph>>sendMouseEvent:
	Receiver: a HandMorph(337424384)
	Arguments and temporary variables: 
		anEvent: 	[(479@200) mouseUp 11515094 nil]
	Receiver's instance variables: 
		bounds: 	(479@200.0) corner: (495@216.0)
		owner: 	a WorldMorph(341720576) [world]
		submorphs: 	#()
		fullBounds: 	(479@200.0) corner: (495@216.0)
		color: 	Color blue
		extension: 	a MorphExtension (370611968)
		mouseFocus: 	nil
		keyboardFocus: 	a RubEditingArea(143191808)
		eventListeners: 	nil
		mouseListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(479@200) mouseUp 11515094 nil]
		targetOffset: 	(24.0@7.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 0 0 0 0 0 nil nil)
		captureBlock: 	nil
		recentModifiers: 	0
		pendingEventQueue: 	WaitfreeQueue with 0 items
		supressNextKeyPress: 	false


HandMorph>>handleEvent:
	Receiver: a HandMorph(337424384)
	Arguments and temporary variables: 
		anEvent: 	[(479@200) mouseUp 11515094 nil]
		evt: 	[(479@200) mouseUp 11515094 nil]
	Receiver's instance variables: 
		bounds: 	(479@200.0) corner: (495@216.0)
		owner: 	a WorldMorph(341720576) [world]
		submorphs: 	#()
		fullBounds: 	(479@200.0) corner: (495@216.0)
		color: 	Color blue
		extension: 	a MorphExtension (370611968)
		mouseFocus: 	nil
		keyboardFocus: 	a RubEditingArea(143191808)
		eventListeners: 	nil
		mouseListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(479@200) mouseUp 11515094 nil]
		targetOffset: 	(24.0@7.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 0 0 0 0 0 nil nil)
		captureBlock: 	nil
		recentModifiers: 	0
		pendingEventQueue: 	WaitfreeQueue with 0 items
		supressNextKeyPress: 	false


[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil ]) ifTrue: [
			morphicWorld activeHand handleEvent: anEvent
		]
	] in OSWindowMorphicEventHandler>>dispatchMorphicEvent:
	Receiver: an OSWindowMorphicEventHandler
	Arguments and temporary variables: 
		anEvent: 	[(479@200) mouseUp 11515094 nil]
	Receiver's instance variables: 
		morphicWorld: 	a WorldMorph(341720576) [world]


WorldState>>runStepMethodsIn:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(341720576) [world]
		queue: 	WaitfreeQueue with 0 items
		nextInQueue: 	[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNo[..]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(337424384))
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap()
		lastStepTime: 	11506463
		lastStepMessage: 	nil
		alarms: 	a Heap(MorphicAlarm(#hideShow -> a RubCursor(27124480)))
		lastAlarmTime: 	11515081
		activeHand: 	a HandMorph(337424384)
		currentCursor: 	((CursorWithMask
	extent: (16@16)
	depth: 1
	fromArray: #(
	[..]
		worldRenderer: 	an OSWorldRenderer
		realWindowExtent: 	(1728@1080)
		deferredUIMessages: 	WaitfreeQueue with 0 items


WorldMorph>>runStepMethods
	Receiver: a WorldMorph(341720576) [world]
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1728@1080)
		owner: 	nil
		submorphs: 	an Array(a MenubarMorph(112886016) a TaskbarMorph(279458560) a S[..]
		fullBounds: 	(0@0) corner: (1728@1080)
		color: 	(Color r: 0.9403714565004888 g: 0.9403714565004888 b: 0.940371456500[..]
		extension: 	a MorphExtension (1012946432) [other:  (dragEnabled -> true) (dr[..]
		borderWidth: 	0
		borderColor: 	(Color r: 0.8611925708699902 g: 1.0 b: 0.7223851417399805 alph[..]
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil


WorldState>>doOneCycleFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(341720576) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(337424384))
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap()
		lastStepTime: 	11506463
		lastStepMessage: 	nil
		alarms: 	a Heap(MorphicAlarm(#hideShow -> a RubCursor(27124480)))
		lastAlarmTime: 	11515081
		activeHand: 	a HandMorph(337424384)
		currentCursor: 	((CursorWithMask
	extent: (16@16)
	depth: 1
	fromArray: #(
	[..]
		worldRenderer: 	an OSWorldRenderer
		realWindowExtent: 	(1728@1080)
		deferredUIMessages: 	WaitfreeQueue with 0 items


WorldMorph>>doOneCycleNow
	Receiver: a WorldMorph(341720576) [world]
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1728@1080)
		owner: 	nil
		submorphs: 	an Array(a MenubarMorph(112886016) a TaskbarMorph(279458560) a S[..]
		fullBounds: 	(0@0) corner: (1728@1080)
		color: 	(Color r: 0.9403714565004888 g: 0.9403714565004888 b: 0.940371456500[..]
		extension: 	a MorphExtension (1012946432) [other:  (dragEnabled -> true) (dr[..]
		borderWidth: 	0
		borderColor: 	(Color r: 0.8611925708699902 g: 1.0 b: 0.7223851417399805 alph[..]
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil


WorldMorph>>doOneCycle
	Receiver: a WorldMorph(341720576) [world]
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1728@1080)
		owner: 	nil
		submorphs: 	an Array(a MenubarMorph(112886016) a TaskbarMorph(279458560) a S[..]
		fullBounds: 	(0@0) corner: (1728@1080)
		color: 	(Color r: 0.9403714565004888 g: 0.9403714565004888 b: 0.940371456500[..]
		extension: 	a MorphExtension (1012946432) [other:  (dragEnabled -> true) (dr[..]
		borderWidth: 	0
		borderColor: 	(Color r: 0.8611925708699902 g: 1.0 b: 0.7223851417399805 alph[..]
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil



--- The full stack ---
RSLine(Object)>>doesNotUnderstand: #from:to:
[ :edgeDict |
        | edge sourceNode targetNode sourcePosition targetPosition |
        sourceNode := nodesMap at: (edgeDict at: #source) ifAbsent: [ nil ].
        targetNode := nodesMap at: (edgeDict at: #target) ifAbsent: [ nil ].
        sourceNode ifNotNil: [ targetNode ifNotNil: [
            "Calculate center or get position differently"
            sourcePosition := sourceNode position.
            targetPosition := targetNode position.
            edge := RSLine new from: sourcePosition to: targetPosition.
            canvas add: edge.
        ]].
    ] in GraphVisualizer>>createEdges
Array(SequenceableCollection)>>do:
GraphVisualizer>>createEdges
GraphVisualizer>>visualizeGraphFromFile:
UndefinedObject>>DoIt
OCReceiverDoItSemanticScope(OCDoItSemanticScope)>>evaluateDoIt:
OpalCompiler>>evaluate
[
		self announcer announce: (SpCodeWillBeEvaluatedAnnouncement newContent: aString).
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionModel doItReceiver.
		result := receiver class compiler
			source: aString;
			context: self interactionModel doItContext;
			receiver: self interactionModel doItReceiver;
			requestor: self interactionModel;
			environment: self environment;
			failBlock:  [ 
				self announcer announce: (SpCodeEvaluationFailedAnnouncement newContent: aString).
				^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		self announcer announce: (SpCodeEvaluationSucceedAnnouncement newContent: aString).
		result ] in SpCodePresenter>>evaluate:onCompileError:onError:
FullBlockClosure(BlockClosure)>>on:do:
SpCodePresenter>>evaluate:onCompileError:onError:
StPlaygroundPagePresenter>>doEvaluateAndGo
StPlaygroundPagePresenter>>doEvaluateAllAndGo
StPlaygroundDoItCommand>>execute
SpCommand(CmCommandDecorator)>>execute
[ specCommand execute ] in [ :specCommand | 
			aButtonClass new
				label: specCommand name;
				help: specCommand description;
				in: [ :button | 
					specCommand hasIcon
						ifTrue: [ button icon: specCommand icon ] ];
				action: [ specCommand execute ];
				yourself ] in SpCommand>>configureAsButtonOfClass:
FullBlockClosure(BlockClosure)>>cull:
SpMorphicToolbarButtonAdapter>>execute
SpToolbarButtonMorph(PluggableButtonMorph)>>performAction:
[:m |
		(m containsPoint: evt cursorPoint) ifTrue: [m enabled ifTrue: [ m performAction: evt ]]] in SpToolbarButtonMorph(PluggableButtonMorph)>>mouseUp:
Array(SequenceableCollection)>>do:
SpToolbarButtonMorph(PluggableButtonMorph)>>mouseUp:
SpToolbarButtonMorph(Morph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
SpToolbarButtonMorph(Morph)>>handleEvent:
SpToolbarButtonMorph(Morph)>>handleFocusEvent:
[
		result := focusHolder handleFocusEvent: transformedEvent.
	] in HandMorph>>sendFocusEvent:to:clear:
FullBlockClosure(BlockClosure)>>on:do:
WorldMorph>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil ]) ifTrue: [
			morphicWorld activeHand handleEvent: anEvent
		]
	] in OSWindowMorphicEventHandler>>dispatchMorphicEvent:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycleNow
WorldMorph>>doOneCycle
 - - - - - - - - - - - - - - -
			- - - - - - - - - - - - - - - - - -
[
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMutex critical: [
			                     self extraWorldList ].
		extraWorldsToDraw do: [ :world | world doOneCycle ].

		(self currentWorld isNotNil and: [
			 (extraWorldsToDraw includes: self currentWorld) not ]) ifTrue: [
			self currentWorld doOneCycle ] ] in WorldMorph class>>doOneCycle
FullBlockClosure(BlockClosure)>>ensure:
WorldState class>>doDrawCycleWith:
WorldMorph class>>doOneCycle
MorphicRenderLoop>>doOneCycle
MorphicRenderLoop>>doOneCycleWhile:
[ MorphicRenderLoop new doOneCycleWhile: [ true ] ] in MorphicUIManager>>spawnNewProcess
[self value.
			"IMPORTANT: Do not step over next line of code. See method comments for details"
			Processor terminateRealActive] in FullBlockClosure(BlockClosure)>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
Instance of RSLine did not understand #from:to:
13 November 2023 7:16:37.012956 pm

VM: Mac OS - arm64 - 1000 - CoInterpreter VMMaker-tonel.1 uuid: 902dd483-c0c4-0d00-86f2-0f880df24b96 Oct 23 2023
StackToRegisterMappingCogit VMMaker-tonel.1 uuid: 902dd483-c0c4-0d00-86f2-0f880df24b96 Oct 23 2023
v10.0.8 - Commit: b323c5fb - Date: 2023-10-20 16:02:07 -0400

Image: Pharo11.0.0 [Build information: Pharo-11.0.0+build.710.sha.ea28d8552cac85a7ce1e9c34ab1e7bd45f7b9910 (64 Bit)]

RSLine(Object)>>doesNotUnderstand: #from:to:
	Receiver: a RSLine
	Arguments and temporary variables: 
		aMessage: 	from: (0.0@0.0) to: (0.0@0.0)
		exception: 	Instance of RSLine did not understand #from:to:
		resumeValue: 	nil
	Receiver's instance variables: 
		announcer: 	nil
		properties: 	nil
		paint: 	nil
		path: 	nil
		border: 	1, Color gray
		parent: 	nil
		isFixed: 	false
		encompassingRectangle: 	nil
		model: 	nil
		attachPoint: 	a RSCenteredAttachPoint
		from: 	nil
		to: 	nil
		markers: 	nil
		startPoint: 	(0@0)
		endPoint: 	(100@100)


[ :edgeDict |
        | edge sourceNode targetNode sourcePosition targetPosition |
        sourceNode := nodesMap at: (edgeDict at: #source) ifAbsent: [ nil ].
        targetNode := nodesMap at: (edgeDict at: #target) ifAbsent: [ nil ].
        sourceNode ifNotNil: [ targetNode ifNotNil: [
            "Calculate center or get position differently"
            sourcePosition := sourceNode position.
            targetPosition := targetNode position.
            edge := RSLine new from: sourcePosition to: targetPosition.
            canvas add: edge.
        ]].
    ] in GraphVisualizer>>createEdges
	Receiver: a GraphVisualizer
	Arguments and temporary variables: 
		edgeDict: 	a Dictionary('source'->1 'target'->2 'type'->'FRIENDS_WITH' )
		edge: 	nil
		sourceNode: 	a RSBox
		targetNode: 	a RSBox
		sourcePosition: 	(0.0@0.0)
		targetPosition: 	(0.0@0.0)
	Receiver's instance variables: 
		view: 	nil
		nodes: 	an Array(a Dictionary('id'->1 'label'->'Person' 'properties'->a Dict[..]
		edges: 	an Array(a Dictionary('source'->1 'target'->2 'type'->'FRIENDS_WITH' ))
		nodesMap: 	a Dictionary(1->a RSBox 2->a RSBox )
		canvas: 	a RSCanvas


Array(SequenceableCollection)>>do:
	Receiver: an Array(a Dictionary('source'->1 'target'->2 'type'->'FRIENDS_WITH' ))
	Arguments and temporary variables: 
		aBlock: 	[ :edgeDict |
        | edge sourceNode targetNode sourcePosition t[..]
		index: 	1
	Receiver's instance variables: 
an Array(a Dictionary('source'->1 'target'->2 'type'->'FRIENDS_WITH' ))

GraphVisualizer>>createEdges
	Receiver: a GraphVisualizer
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		view: 	nil
		nodes: 	an Array(a Dictionary('id'->1 'label'->'Person' 'properties'->a Dict[..]
		edges: 	an Array(a Dictionary('source'->1 'target'->2 'type'->'FRIENDS_WITH' ))
		nodesMap: 	a Dictionary(1->a RSBox 2->a RSBox )
		canvas: 	a RSCanvas


GraphVisualizer>>visualizeGraphFromFile:
	Receiver: a GraphVisualizer
	Arguments and temporary variables: 
		aFilePath: 	'/Users/ryanperez/Documents/GitHub/pp-rep2533/project/src/data/t[..]
	Receiver's instance variables: 
		view: 	nil
		nodes: 	an Array(a Dictionary('id'->1 'label'->'Person' 'properties'->a Dict[..]
		edges: 	an Array(a Dictionary('source'->1 'target'->2 'type'->'FRIENDS_WITH' ))
		nodesMap: 	a Dictionary(1->a RSBox 2->a RSBox )
		canvas: 	a RSCanvas


UndefinedObject>>DoIt
	Receiver: nil
	Arguments and temporary variables: 
		visualizer: 	a GraphVisualizer
	Receiver's instance variables: 
nil

OCReceiverDoItSemanticScope(OCDoItSemanticScope)>>evaluateDoIt:
	Receiver: an OCReceiverDoItSemanticScope
	Arguments and temporary variables: 
		doItMethod: 	UndefinedObject>>#DoIt
	Receiver's instance variables: 
		outerScope: 	nil
		targetReceiver: 	nil


OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
		doItMethod: 	UndefinedObject>>#DoIt
	Receiver's instance variables: 
		ast: 	DoIt

	| visualizer |
	visualizer := GraphVisualizer new.
	^ visualize[..]
		source: 	a ReadStream
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil


[
		self announcer announce: (SpCodeWillBeEvaluatedAnnouncement newContent: aString).
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionModel doItReceiver.
		result := receiver class compiler
			source: aString;
			context: self interactionModel doItContext;
			receiver: self interactionModel doItReceiver;
			requestor: self interactionModel;
			environment: self environment;
			failBlock:  [ 
				self announcer announce: (SpCodeEvaluationFailedAnnouncement newContent: aString).
				^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		self announcer announce: (SpCodeEvaluationSucceedAnnouncement newContent: aString).
		result ] in SpCodePresenter>>evaluate:onCompileError:onError:
	Receiver: a SpCodePresenter
	Arguments and temporary variables: 
		aString: 	'| visualizer |
visualizer := GraphVisualizer new.
visualizer visu[..]
		compileErrorBlock: 	[ ^ self ]
		errorBlock: 	[ :e | e pass ]
		receiver: 	nil
		result: 	nil
		oldBindings: 	a Dictionary()
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicCodeAdapter)
		announcer: 	an Announcer
		owner: 	a StPlaygroundPagePresenter
		adapter: 	a SpMorphicCodeAdapter
		needRebuild: 	true
		eventHandler: 	a SpEventHandler
		application: 	nil
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ a KMCategory ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Code' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpAbstractWidgetLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		borderWidth: 	an ObservableValueHolder[ nil ]
		borderColor: 	an ObservableValueHolder[ nil ]
		dragEnabled: 	an ObservableValueHolder[ false ]
		dropEnabled: 	an ObservableValueHolder[ false ]
		color: 	an ObservableValueHolder[ nil ]
		help: 	an ObservableValueHolder[ nil ]
		enabled: 	an ObservableValueHolder[ true ]
		wantsDrop: 	an ObservableValueHolder[ [ :transfer | self dropEnabled ] ]
		acceptDrop: 	an ObservableValueHolder[ [ :transfer | ] ]
		deferredActions: 	nil
		hasUnacceptedEdits: 	an ObservableValueHolder[ false ]
		selection: 	an ObservableValueHolder[ (1 to: 159) ]
		wantsVisualFeedback: 	an ObservableValueHolder[ true ]
		askBeforeDiscardingEdits: 	an ObservableValueHolder[ true ]
		text: 	an ObservableValueHolder[ '| visualizer |
visualizer := GraphVisualiz[..]
		actionToPerform: 	an ObservableValueHolder[ [ :txt |  ] ]
		readSelection: 	an ObservableValueHolder[ [ selection ] ]
		placeholder: 	an ObservableValueHolder[ '' ]
		contextMenu: 	an ObservableValueHolder[ [ (self menuActionsFor: text) asMenu[..]
		scrollValue: 	an ObservableValueHolder[ (0@0) ]
		editionContextMenu: 	an ObservableValueHolder[ true ]
		editable: 	an ObservableValueHolder[ true ]
		wrapWord: 	an ObservableValueHolder[ true ]
		undoRedoHistory: 	true
		wrapScrollBars: 	true
		propagateNaturalHeight: 	false
		propagateNaturalWidth: 	false
		scrollBarStyles: 	#()
		syntaxHighlight: 	an ObservableValueHolder[ true ]
		smartCharacters: 	an ObservableValueHolder[ true ]
		lineNumbers: 	an ObservableValueHolder[ true ]
		interactionModel: 	an ObservableValueHolder[ a StPlaygroundInteractionModel ]
		overrideContextMenu: 	true
		submitBlock: 	nil
		resetBlock: 	nil
		environment: 	nil
		systemNavigation: 	nil
		syntaxHighlightTheme: 	an ObservableValueHolder[ nil ]


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
		self announcer announce: (SpCodeWillBeEvaluatedAnnouncement newContent: aString).
[..]
	Arguments and temporary variables: 
		exception: 	Error
		handlerAction: 	[ :e |
		self announcer announce: (SpCodeEvaluationFailedAnn[..]
	Receiver's instance variables: 
		outerContext: 	SpCodePresenter>>evaluate:onCompileError:onError:
		compiledBlock: 	a CompiledBlock: [
		self announcer announce: (SpCodeWillBeE[..]
		numArgs: 	0
		receiver: 	a SpCodePresenter


SpCodePresenter>>evaluate:onCompileError:onError:
	Receiver: a SpCodePresenter
	Arguments and temporary variables: 
		receiver: 	nil
		result: 	nil
		oldBindings: 	a Dictionary()
		aString: 	'| visualizer |
visualizer := GraphVisualizer new.
visualizer visu[..]
		compileErrorBlock: 	[ ^ self ]
		errorBlock: 	[ :e | e pass ]
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicCodeAdapter)
		announcer: 	an Announcer
		owner: 	a StPlaygroundPagePresenter
		adapter: 	a SpMorphicCodeAdapter
		needRebuild: 	true
		eventHandler: 	a SpEventHandler
		application: 	nil
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ a KMCategory ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Code' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpAbstractWidgetLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		borderWidth: 	an ObservableValueHolder[ nil ]
		borderColor: 	an ObservableValueHolder[ nil ]
		dragEnabled: 	an ObservableValueHolder[ false ]
		dropEnabled: 	an ObservableValueHolder[ false ]
		color: 	an ObservableValueHolder[ nil ]
		help: 	an ObservableValueHolder[ nil ]
		enabled: 	an ObservableValueHolder[ true ]
		wantsDrop: 	an ObservableValueHolder[ [ :transfer | self dropEnabled ] ]
		acceptDrop: 	an ObservableValueHolder[ [ :transfer | ] ]
		deferredActions: 	nil
		hasUnacceptedEdits: 	an ObservableValueHolder[ false ]
		selection: 	an ObservableValueHolder[ (1 to: 159) ]
		wantsVisualFeedback: 	an ObservableValueHolder[ true ]
		askBeforeDiscardingEdits: 	an ObservableValueHolder[ true ]
		text: 	an ObservableValueHolder[ '| visualizer |
visualizer := GraphVisualiz[..]
		actionToPerform: 	an ObservableValueHolder[ [ :txt |  ] ]
		readSelection: 	an ObservableValueHolder[ [ selection ] ]
		placeholder: 	an ObservableValueHolder[ '' ]
		contextMenu: 	an ObservableValueHolder[ [ (self menuActionsFor: text) asMenu[..]
		scrollValue: 	an ObservableValueHolder[ (0@0) ]
		editionContextMenu: 	an ObservableValueHolder[ true ]
		editable: 	an ObservableValueHolder[ true ]
		wrapWord: 	an ObservableValueHolder[ true ]
		undoRedoHistory: 	true
		wrapScrollBars: 	true
		propagateNaturalHeight: 	false
		propagateNaturalWidth: 	false
		scrollBarStyles: 	#()
		syntaxHighlight: 	an ObservableValueHolder[ true ]
		smartCharacters: 	an ObservableValueHolder[ true ]
		lineNumbers: 	an ObservableValueHolder[ true ]
		interactionModel: 	an ObservableValueHolder[ a StPlaygroundInteractionModel ]
		overrideContextMenu: 	true
		submitBlock: 	nil
		resetBlock: 	nil
		environment: 	nil
		systemNavigation: 	nil
		syntaxHighlightTheme: 	an ObservableValueHolder[ nil ]


StPlaygroundPagePresenter>>doEvaluateAndGo
	Receiver: a StPlaygroundPagePresenter
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicBoxAdapter)
		announcer: 	an Announcer
		owner: 	a SpMillerColumnPresenter
		adapter: 	a SpMorphicBoxAdapter
		needRebuild: 	true
		eventHandler: 	nil
		application: 	a StPharoApplication
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ nil ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Untitled window' ]
		additionalSubpresentersMap: 	a Dictionary()
		layout: 	an ObservableValueHolder[ a SpBoxLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		text: 	a SpCodePresenter
		toolbar: 	a SpToolbarPresenter
		statusbar: 	a SpPresenter
		lineLabel: 	a SpLabelPresenter
		toggleLineNumberButton: 	a SpToggleButtonPresenter
		page: 	a StPlaygroundPage
		activationBlock: 	[ :selection |
		self changeSelection: selection from: new[..]


StPlaygroundPagePresenter>>doEvaluateAllAndGo
	Receiver: a StPlaygroundPagePresenter
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicBoxAdapter)
		announcer: 	an Announcer
		owner: 	a SpMillerColumnPresenter
		adapter: 	a SpMorphicBoxAdapter
		needRebuild: 	true
		eventHandler: 	nil
		application: 	a StPharoApplication
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ nil ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Untitled window' ]
		additionalSubpresentersMap: 	a Dictionary()
		layout: 	an ObservableValueHolder[ a SpBoxLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		text: 	a SpCodePresenter
		toolbar: 	a SpToolbarPresenter
		statusbar: 	a SpPresenter
		lineLabel: 	a SpLabelPresenter
		toggleLineNumberButton: 	a SpToggleButtonPresenter
		page: 	a StPlaygroundPage
		activationBlock: 	[ :selection |
		self changeSelection: selection from: new[..]


StPlaygroundDoItCommand>>execute
	Receiver: a StPlaygroundDoItCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		context: 	a StPlaygroundPagePresenter
		basicName: 	'Do it'
		basicDescription: 	'Do it all and inspect.'


SpCommand(CmCommandDecorator)>>execute
	Receiver: a SpCommand(Do it)
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a StPlaygroundDoItCommand
		iconProvider: 	a StPharoApplication
		iconName: 	#glamorousGo
		shortcutKey: 	nil
		displayStrategy: 	a CmUIDisableWhenCantBeRun
		positionStrategy: 	a CmUILeftPositionStrategy
		buildPresenterBlock: 	[ :specCommand | 
			aButtonClass new
				label: specC[..]
		presenter: 	a SpToolbarButtonPresenter


[ specCommand execute ] in [ :specCommand | 
			aButtonClass new
				label: specCommand name;
				help: specCommand description;
				in: [ :button | 
					specCommand hasIcon
						ifTrue: [ button icon: specCommand icon ] ];
				action: [ specCommand execute ];
				yourself ] in SpCommand>>configureAsButtonOfClass:
	Receiver: a SpCommand(Do it)
	Arguments and temporary variables: 
		aButtonClass: 	nil
		specCommand: 	a SpCommand(Do it)
	Receiver's instance variables: 
		decoratedCommand: 	a StPlaygroundDoItCommand
		iconProvider: 	a StPharoApplication
		iconName: 	#glamorousGo
		shortcutKey: 	nil
		displayStrategy: 	a CmUIDisableWhenCantBeRun
		positionStrategy: 	a CmUILeftPositionStrategy
		buildPresenterBlock: 	[ :specCommand | 
			aButtonClass new
				label: specC[..]
		presenter: 	a SpToolbarButtonPresenter


FullBlockClosure(BlockClosure)>>cull:
	Receiver: [ specCommand execute ]
	Arguments and temporary variables: 
		anArg: 	a SpToolbarButtonPresenter
	Receiver's instance variables: 
		outerContext: 	[ :specCommand | 
			aButtonClass new
				label: specCommand [..]
		compiledBlock: 	a CompiledBlock: [ specCommand execute ]
		numArgs: 	0
		receiver: 	a SpCommand(Do it)


SpMorphicToolbarButtonAdapter>>execute
	Receiver: a SpMorphicToolbarButtonAdapter
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpToolbarButtonMorph(163457024))
		announcer: 	nil
		model: 	a SpToolbarButtonPresenter
		widget: 	a SpToolbarButtonMorph(163457024)
		selector: 	nil
		owner: 	a SpToolbarButtonPresenter
		unsubscribed: 	false


SpToolbarButtonMorph(PluggableButtonMorph)>>performAction:
	Receiver: a SpToolbarButtonMorph(163457024)
	Arguments and temporary variables: 
		event: 	[(24.0@12.0) mouseUp 11515094 nil]
	Receiver's instance variables: 
		bounds: 	(0.0@5.0) corner: (45.0@39.0)
		owner: 	a Morph(543889152)
		submorphs: 	an Array(an AlignmentMorph(1048008448))
		fullBounds: 	nil
		color: 	(Color r: 0.9012707722385142 g: 0.9012707722385142 b: 0.901270772238[..]
		extension: 	a MorphExtension (606190080) [balloonText]  [other:  (presenter [..]
		borderWidth: 	0
		borderColor: 	#simple
		model: 	a SpMorphicToolbarButtonAdapter
		label: 	'Do it'
		icon: 	Form(13x13x32)
		getIconSelector: 	#icon
		getStateSelector: 	#state
		actionSelector: 	#execute
		font: 	a LogicalFont
 familyName: 'Source Sans Pro'
 emphasis: nil
 pointSiz[..]
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	nil
		getFontSelector: 	nil
		labelMorph: 	a LabelMorph(576130816)'Do it'
		iconMorph: 	an ImageMorph(527603200)
		iconPosition: 	#top
		lastState: 	false
		badgeFont: 	nil
		badgeSelector: 	#badge


[:m |
		(m containsPoint: evt cursorPoint) ifTrue: [m enabled ifTrue: [ m performAction: evt ]]] in SpToolbarButtonMorph(PluggableButtonMorph)>>mouseUp:
	Receiver: a SpToolbarButtonMorph(163457024)
	Arguments and temporary variables: 
		evt: 	[(24.0@12.0) mouseUp 11515094 nil]
		all: 	an Array(a SpToolbarButtonMorph(163457024) a SpToolbarButtonMorph(6416[..]
		m: 	a SpToolbarButtonMorph(163457024)
	Receiver's instance variables: 
		bounds: 	(0.0@5.0) corner: (45.0@39.0)
		owner: 	a Morph(543889152)
		submorphs: 	an Array(an AlignmentMorph(1048008448))
		fullBounds: 	nil
		color: 	(Color r: 0.9012707722385142 g: 0.9012707722385142 b: 0.901270772238[..]
		extension: 	a MorphExtension (606190080) [balloonText]  [other:  (presenter [..]
		borderWidth: 	0
		borderColor: 	#simple
		model: 	a SpMorphicToolbarButtonAdapter
		label: 	'Do it'
		icon: 	Form(13x13x32)
		getIconSelector: 	#icon
		getStateSelector: 	#state
		actionSelector: 	#execute
		font: 	a LogicalFont
 familyName: 'Source Sans Pro'
 emphasis: nil
 pointSiz[..]
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	nil
		getFontSelector: 	nil
		labelMorph: 	a LabelMorph(576130816)'Do it'
		iconMorph: 	an ImageMorph(527603200)
		iconPosition: 	#top
		lastState: 	false
		badgeFont: 	nil
		badgeSelector: 	#badge


Array(SequenceableCollection)>>do:
	Receiver: an Array(a SpToolbarButtonMorph(163457024) a SpToolbarButtonMorph(641645312) a SpToolb[..]
	Arguments and temporary variables: 
		aBlock: 	[:m |
		(m containsPoint: evt cursorPoint) ifTrue: [m enabled ifTru[..]
		index: 	1
	Receiver's instance variables: 
an Array(a SpToolbarButtonMorph(163457024) a SpToolbarButtonMorph(641645312) a SpToolb[..]

SpToolbarButtonMorph(PluggableButtonMorph)>>mouseUp:
	Receiver: a SpToolbarButtonMorph(163457024)
	Arguments and temporary variables: 
		evt: 	[(24.0@12.0) mouseUp 11515094 nil]
		all: 	an Array(a SpToolbarButtonMorph(163457024) a SpToolbarButtonMorph(6416[..]
	Receiver's instance variables: 
		bounds: 	(0.0@5.0) corner: (45.0@39.0)
		owner: 	a Morph(543889152)
		submorphs: 	an Array(an AlignmentMorph(1048008448))
		fullBounds: 	nil
		color: 	(Color r: 0.9012707722385142 g: 0.9012707722385142 b: 0.901270772238[..]
		extension: 	a MorphExtension (606190080) [balloonText]  [other:  (presenter [..]
		borderWidth: 	0
		borderColor: 	#simple
		model: 	a SpMorphicToolbarButtonAdapter
		label: 	'Do it'
		icon: 	Form(13x13x32)
		getIconSelector: 	#icon
		getStateSelector: 	#state
		actionSelector: 	#execute
		font: 	a LogicalFont
 familyName: 'Source Sans Pro'
 emphasis: nil
 pointSiz[..]
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	nil
		getFontSelector: 	nil
		labelMorph: 	a LabelMorph(576130816)'Do it'
		iconMorph: 	an ImageMorph(527603200)
		iconPosition: 	#top
		lastState: 	false
		badgeFont: 	nil
		badgeSelector: 	#badge


SpToolbarButtonMorph(Morph)>>handleMouseUp:
	Receiver: a SpToolbarButtonMorph(163457024)
	Arguments and temporary variables: 
		anEvent: 	[(24.0@12.0) mouseUp 11515094 nil]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(0.0@5.0) corner: (45.0@39.0)
		owner: 	a Morph(543889152)
		submorphs: 	an Array(an AlignmentMorph(1048008448))
		fullBounds: 	nil
		color: 	(Color r: 0.9012707722385142 g: 0.9012707722385142 b: 0.901270772238[..]
		extension: 	a MorphExtension (606190080) [balloonText]  [other:  (presenter [..]
		borderWidth: 	0
		borderColor: 	#simple
		model: 	a SpMorphicToolbarButtonAdapter
		label: 	'Do it'
		icon: 	Form(13x13x32)
		getIconSelector: 	#icon
		getStateSelector: 	#state
		actionSelector: 	#execute
		font: 	a LogicalFont
 familyName: 'Source Sans Pro'
 emphasis: nil
 pointSiz[..]
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	nil
		getFontSelector: 	nil
		labelMorph: 	a LabelMorph(576130816)'Do it'
		iconMorph: 	an ImageMorph(527603200)
		iconPosition: 	#top
		lastState: 	false
		badgeFont: 	nil
		badgeSelector: 	#badge


MouseButtonEvent>>sentTo:
	Receiver: [(24.0@12.0) mouseUp 11515094 nil]
	Arguments and temporary variables: 
		anObject: 	a SpToolbarButtonMorph(163457024)
	Receiver's instance variables: 
		timeStamp: 	11515094
		source: 	a HandMorph(337424384)
		windowIndex: 	nil
		type: 	#mouseUp
		buttons: 	0
		position: 	(24.0@12.0)
		handler: 	nil
		wasHandled: 	true
		whichButton: 	4


SpToolbarButtonMorph(Morph)>>handleEvent:
	Receiver: a SpToolbarButtonMorph(163457024)
	Arguments and temporary variables: 
		anEvent: 	[(24.0@12.0) mouseUp 11515094 nil]
	Receiver's instance variables: 
		bounds: 	(0.0@5.0) corner: (45.0@39.0)
		owner: 	a Morph(543889152)
		submorphs: 	an Array(an AlignmentMorph(1048008448))
		fullBounds: 	nil
		color: 	(Color r: 0.9012707722385142 g: 0.9012707722385142 b: 0.901270772238[..]
		extension: 	a MorphExtension (606190080) [balloonText]  [other:  (presenter [..]
		borderWidth: 	0
		borderColor: 	#simple
		model: 	a SpMorphicToolbarButtonAdapter
		label: 	'Do it'
		icon: 	Form(13x13x32)
		getIconSelector: 	#icon
		getStateSelector: 	#state
		actionSelector: 	#execute
		font: 	a LogicalFont
 familyName: 'Source Sans Pro'
 emphasis: nil
 pointSiz[..]
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	nil
		getFontSelector: 	nil
		labelMorph: 	a LabelMorph(576130816)'Do it'
		iconMorph: 	an ImageMorph(527603200)
		iconPosition: 	#top
		lastState: 	false
		badgeFont: 	nil
		badgeSelector: 	#badge


SpToolbarButtonMorph(Morph)>>handleFocusEvent:
	Receiver: a SpToolbarButtonMorph(163457024)
	Arguments and temporary variables: 
		anEvent: 	[(24.0@12.0) mouseUp 11515094 nil]
	Receiver's instance variables: 
		bounds: 	(0.0@5.0) corner: (45.0@39.0)
		owner: 	a Morph(543889152)
		submorphs: 	an Array(an AlignmentMorph(1048008448))
		fullBounds: 	nil
		color: 	(Color r: 0.9012707722385142 g: 0.9012707722385142 b: 0.901270772238[..]
		extension: 	a MorphExtension (606190080) [balloonText]  [other:  (presenter [..]
		borderWidth: 	0
		borderColor: 	#simple
		model: 	a SpMorphicToolbarButtonAdapter
		label: 	'Do it'
		icon: 	Form(13x13x32)
		getIconSelector: 	#icon
		getStateSelector: 	#state
		actionSelector: 	#execute
		font: 	a LogicalFont
 familyName: 'Source Sans Pro'
 emphasis: nil
 pointSiz[..]
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	nil
		getFontSelector: 	nil
		labelMorph: 	a LabelMorph(576130816)'Do it'
		iconMorph: 	an ImageMorph(527603200)
		iconPosition: 	#top
		lastState: 	false
		badgeFont: 	nil
		badgeSelector: 	#badge


[
		result := focusHolder handleFocusEvent: transformedEvent.
	] in HandMorph>>sendFocusEvent:to:clear:
	Receiver: a HandMorph(337424384)
	Arguments and temporary variables: 
		anEvent: 	[(479@200) mouseUp 11515094 nil]
		focusHolder: 	a SpToolbarButtonMorph(163457024)
		aBlock: 	[self mouseFocus: nil]
		w: 	a WorldMorph(341720576) [world]
		transformedEvent: 	[(24.0@12.0) mouseUp 11515094 nil]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(479@200.0) corner: (495@216.0)
		owner: 	a WorldMorph(341720576) [world]
		submorphs: 	#()
		fullBounds: 	(479@200.0) corner: (495@216.0)
		color: 	Color blue
		extension: 	a MorphExtension (370611968)
		mouseFocus: 	nil
		keyboardFocus: 	a RubEditingArea(143191808)
		eventListeners: 	nil
		mouseListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(479@200) mouseUp 11515094 nil]
		targetOffset: 	(24.0@7.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 0 0 0 0 0 nil nil)
		captureBlock: 	nil
		recentModifiers: 	0
		pendingEventQueue: 	WaitfreeQueue with 0 items
		supressNextKeyPress: 	false


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
		result := focusHolder handleFocusEvent: transformedEvent.
	]
	Arguments and temporary variables: 
		exception: 	Error
		handlerAction: 	[ :ex |
			ActiveWorld := priorWorld.
			ex pass ]
	Receiver's instance variables: 
		outerContext: 	HandMorph>>sendFocusEvent:to:clear:
		compiledBlock: 	a CompiledBlock: [
		result := focusHolder handleFocusEvent:[..]
		numArgs: 	0
		receiver: 	a HandMorph(337424384)


WorldMorph>>becomeActiveDuring:
	Receiver: a WorldMorph(341720576) [world]
	Arguments and temporary variables: 
		aBlock: 	[
		result := focusHolder handleFocusEvent: transformedEvent.
	]
		priorWorld: 	a WorldMorph(341720576) [world]
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1728@1080)
		owner: 	nil
		submorphs: 	an Array(a MenubarMorph(112886016) a TaskbarMorph(279458560) a S[..]
		fullBounds: 	(0@0) corner: (1728@1080)
		color: 	(Color r: 0.9403714565004888 g: 0.9403714565004888 b: 0.940371456500[..]
		extension: 	a MorphExtension (1012946432) [other:  (dragEnabled -> true) (dr[..]
		borderWidth: 	0
		borderColor: 	(Color r: 0.8611925708699902 g: 1.0 b: 0.7223851417399805 alph[..]
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil


HandMorph>>sendFocusEvent:to:clear:
	Receiver: a HandMorph(337424384)
	Arguments and temporary variables: 
		result: 	nil
		anEvent: 	[(479@200) mouseUp 11515094 nil]
		focusHolder: 	a SpToolbarButtonMorph(163457024)
		aBlock: 	[self mouseFocus: nil]
		w: 	a WorldMorph(341720576) [world]
		transformedEvent: 	[(24.0@12.0) mouseUp 11515094 nil]
	Receiver's instance variables: 
		bounds: 	(479@200.0) corner: (495@216.0)
		owner: 	a WorldMorph(341720576) [world]
		submorphs: 	#()
		fullBounds: 	(479@200.0) corner: (495@216.0)
		color: 	Color blue
		extension: 	a MorphExtension (370611968)
		mouseFocus: 	nil
		keyboardFocus: 	a RubEditingArea(143191808)
		eventListeners: 	nil
		mouseListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(479@200) mouseUp 11515094 nil]
		targetOffset: 	(24.0@7.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 0 0 0 0 0 nil nil)
		captureBlock: 	nil
		recentModifiers: 	0
		pendingEventQueue: 	WaitfreeQueue with 0 items
		supressNextKeyPress: 	false


HandMorph>>sendEvent:focus:clear:
	Receiver: a HandMorph(337424384)
	Arguments and temporary variables: 
		anEvent: 	[(479@200) mouseUp 11515094 nil]
		focusHolder: 	a SpToolbarButtonMorph(163457024)
		aBlock: 	[self mouseFocus: nil]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(479@200.0) corner: (495@216.0)
		owner: 	a WorldMorph(341720576) [world]
		submorphs: 	#()
		fullBounds: 	(479@200.0) corner: (495@216.0)
		color: 	Color blue
		extension: 	a MorphExtension (370611968)
		mouseFocus: 	nil
		keyboardFocus: 	a RubEditingArea(143191808)
		eventListeners: 	nil
		mouseListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(479@200) mouseUp 11515094 nil]
		targetOffset: 	(24.0@7.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 0 0 0 0 0 nil nil)
		captureBlock: 	nil
		recentModifiers: 	0
		pendingEventQueue: 	WaitfreeQueue with 0 items
		supressNextKeyPress: 	false


HandMorph>>sendMouseEvent:
	Receiver: a HandMorph(337424384)
	Arguments and temporary variables: 
		anEvent: 	[(479@200) mouseUp 11515094 nil]
	Receiver's instance variables: 
		bounds: 	(479@200.0) corner: (495@216.0)
		owner: 	a WorldMorph(341720576) [world]
		submorphs: 	#()
		fullBounds: 	(479@200.0) corner: (495@216.0)
		color: 	Color blue
		extension: 	a MorphExtension (370611968)
		mouseFocus: 	nil
		keyboardFocus: 	a RubEditingArea(143191808)
		eventListeners: 	nil
		mouseListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(479@200) mouseUp 11515094 nil]
		targetOffset: 	(24.0@7.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 0 0 0 0 0 nil nil)
		captureBlock: 	nil
		recentModifiers: 	0
		pendingEventQueue: 	WaitfreeQueue with 0 items
		supressNextKeyPress: 	false


HandMorph>>handleEvent:
	Receiver: a HandMorph(337424384)
	Arguments and temporary variables: 
		anEvent: 	[(479@200) mouseUp 11515094 nil]
		evt: 	[(479@200) mouseUp 11515094 nil]
	Receiver's instance variables: 
		bounds: 	(479@200.0) corner: (495@216.0)
		owner: 	a WorldMorph(341720576) [world]
		submorphs: 	#()
		fullBounds: 	(479@200.0) corner: (495@216.0)
		color: 	Color blue
		extension: 	a MorphExtension (370611968)
		mouseFocus: 	nil
		keyboardFocus: 	a RubEditingArea(143191808)
		eventListeners: 	nil
		mouseListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(479@200) mouseUp 11515094 nil]
		targetOffset: 	(24.0@7.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 0 0 0 0 0 nil nil)
		captureBlock: 	nil
		recentModifiers: 	0
		pendingEventQueue: 	WaitfreeQueue with 0 items
		supressNextKeyPress: 	false


[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil ]) ifTrue: [
			morphicWorld activeHand handleEvent: anEvent
		]
	] in OSWindowMorphicEventHandler>>dispatchMorphicEvent:
	Receiver: an OSWindowMorphicEventHandler
	Arguments and temporary variables: 
		anEvent: 	[(479@200) mouseUp 11515094 nil]
	Receiver's instance variables: 
		morphicWorld: 	a WorldMorph(341720576) [world]


WorldState>>runStepMethodsIn:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(341720576) [world]
		queue: 	WaitfreeQueue with 0 items
		nextInQueue: 	[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNo[..]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(337424384))
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap()
		lastStepTime: 	11506463
		lastStepMessage: 	nil
		alarms: 	a Heap(MorphicAlarm(#hideShow -> a RubCursor(27124480)))
		lastAlarmTime: 	11515081
		activeHand: 	a HandMorph(337424384)
		currentCursor: 	((CursorWithMask
	extent: (16@16)
	depth: 1
	fromArray: #(
	[..]
		worldRenderer: 	an OSWorldRenderer
		realWindowExtent: 	(1728@1080)
		deferredUIMessages: 	WaitfreeQueue with 0 items


WorldMorph>>runStepMethods
	Receiver: a WorldMorph(341720576) [world]
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1728@1080)
		owner: 	nil
		submorphs: 	an Array(a MenubarMorph(112886016) a TaskbarMorph(279458560) a S[..]
		fullBounds: 	(0@0) corner: (1728@1080)
		color: 	(Color r: 0.9403714565004888 g: 0.9403714565004888 b: 0.940371456500[..]
		extension: 	a MorphExtension (1012946432) [other:  (dragEnabled -> true) (dr[..]
		borderWidth: 	0
		borderColor: 	(Color r: 0.8611925708699902 g: 1.0 b: 0.7223851417399805 alph[..]
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil


WorldState>>doOneCycleFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(341720576) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(337424384))
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap()
		lastStepTime: 	11506463
		lastStepMessage: 	nil
		alarms: 	a Heap(MorphicAlarm(#hideShow -> a RubCursor(27124480)))
		lastAlarmTime: 	11515081
		activeHand: 	a HandMorph(337424384)
		currentCursor: 	((CursorWithMask
	extent: (16@16)
	depth: 1
	fromArray: #(
	[..]
		worldRenderer: 	an OSWorldRenderer
		realWindowExtent: 	(1728@1080)
		deferredUIMessages: 	WaitfreeQueue with 0 items


WorldMorph>>doOneCycleNow
	Receiver: a WorldMorph(341720576) [world]
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1728@1080)
		owner: 	nil
		submorphs: 	an Array(a MenubarMorph(112886016) a TaskbarMorph(279458560) a S[..]
		fullBounds: 	(0@0) corner: (1728@1080)
		color: 	(Color r: 0.9403714565004888 g: 0.9403714565004888 b: 0.940371456500[..]
		extension: 	a MorphExtension (1012946432) [other:  (dragEnabled -> true) (dr[..]
		borderWidth: 	0
		borderColor: 	(Color r: 0.8611925708699902 g: 1.0 b: 0.7223851417399805 alph[..]
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil


WorldMorph>>doOneCycle
	Receiver: a WorldMorph(341720576) [world]
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1728@1080)
		owner: 	nil
		submorphs: 	an Array(a MenubarMorph(112886016) a TaskbarMorph(279458560) a S[..]
		fullBounds: 	(0@0) corner: (1728@1080)
		color: 	(Color r: 0.9403714565004888 g: 0.9403714565004888 b: 0.940371456500[..]
		extension: 	a MorphExtension (1012946432) [other:  (dragEnabled -> true) (dr[..]
		borderWidth: 	0
		borderColor: 	(Color r: 0.8611925708699902 g: 1.0 b: 0.7223851417399805 alph[..]
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil



--- The full stack ---
RSLine(Object)>>doesNotUnderstand: #from:to:
[ :edgeDict |
        | edge sourceNode targetNode sourcePosition targetPosition |
        sourceNode := nodesMap at: (edgeDict at: #source) ifAbsent: [ nil ].
        targetNode := nodesMap at: (edgeDict at: #target) ifAbsent: [ nil ].
        sourceNode ifNotNil: [ targetNode ifNotNil: [
            "Calculate center or get position differently"
            sourcePosition := sourceNode position.
            targetPosition := targetNode position.
            edge := RSLine new from: sourcePosition to: targetPosition.
            canvas add: edge.
        ]].
    ] in GraphVisualizer>>createEdges
Array(SequenceableCollection)>>do:
GraphVisualizer>>createEdges
GraphVisualizer>>visualizeGraphFromFile:
UndefinedObject>>DoIt
OCReceiverDoItSemanticScope(OCDoItSemanticScope)>>evaluateDoIt:
OpalCompiler>>evaluate
[
		self announcer announce: (SpCodeWillBeEvaluatedAnnouncement newContent: aString).
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionModel doItReceiver.
		result := receiver class compiler
			source: aString;
			context: self interactionModel doItContext;
			receiver: self interactionModel doItReceiver;
			requestor: self interactionModel;
			environment: self environment;
			failBlock:  [ 
				self announcer announce: (SpCodeEvaluationFailedAnnouncement newContent: aString).
				^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		self announcer announce: (SpCodeEvaluationSucceedAnnouncement newContent: aString).
		result ] in SpCodePresenter>>evaluate:onCompileError:onError:
FullBlockClosure(BlockClosure)>>on:do:
SpCodePresenter>>evaluate:onCompileError:onError:
StPlaygroundPagePresenter>>doEvaluateAndGo
StPlaygroundPagePresenter>>doEvaluateAllAndGo
StPlaygroundDoItCommand>>execute
SpCommand(CmCommandDecorator)>>execute
[ specCommand execute ] in [ :specCommand | 
			aButtonClass new
				label: specCommand name;
				help: specCommand description;
				in: [ :button | 
					specCommand hasIcon
						ifTrue: [ button icon: specCommand icon ] ];
				action: [ specCommand execute ];
				yourself ] in SpCommand>>configureAsButtonOfClass:
FullBlockClosure(BlockClosure)>>cull:
SpMorphicToolbarButtonAdapter>>execute
SpToolbarButtonMorph(PluggableButtonMorph)>>performAction:
[:m |
		(m containsPoint: evt cursorPoint) ifTrue: [m enabled ifTrue: [ m performAction: evt ]]] in SpToolbarButtonMorph(PluggableButtonMorph)>>mouseUp:
Array(SequenceableCollection)>>do:
SpToolbarButtonMorph(PluggableButtonMorph)>>mouseUp:
SpToolbarButtonMorph(Morph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
SpToolbarButtonMorph(Morph)>>handleEvent:
SpToolbarButtonMorph(Morph)>>handleFocusEvent:
[
		result := focusHolder handleFocusEvent: transformedEvent.
	] in HandMorph>>sendFocusEvent:to:clear:
FullBlockClosure(BlockClosure)>>on:do:
WorldMorph>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil ]) ifTrue: [
			morphicWorld activeHand handleEvent: anEvent
		]
	] in OSWindowMorphicEventHandler>>dispatchMorphicEvent:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycleNow
WorldMorph>>doOneCycle
 - - - - - - - - - - - - - - -
			- - - - - - - - - - - - - - - - - -
[
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMutex critical: [
			                     self extraWorldList ].
		extraWorldsToDraw do: [ :world | world doOneCycle ].

		(self currentWorld isNotNil and: [
			 (extraWorldsToDraw includes: self currentWorld) not ]) ifTrue: [
			self currentWorld doOneCycle ] ] in WorldMorph class>>doOneCycle
FullBlockClosure(BlockClosure)>>ensure:
WorldState class>>doDrawCycleWith:
WorldMorph class>>doOneCycle
MorphicRenderLoop>>doOneCycle
MorphicRenderLoop>>doOneCycleWhile:
[ MorphicRenderLoop new doOneCycleWhile: [ true ] ] in MorphicUIManager>>spawnNewProcess
[self value.
			"IMPORTANT: Do not step over next line of code. See method comments for details"
			Processor terminateRealActive] in FullBlockClosure(BlockClosure)>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
Instance of RSBox did not understand #center
13 November 2023 7:22:17.472168 pm

VM: Mac OS - arm64 - 1000 - CoInterpreter VMMaker-tonel.1 uuid: 902dd483-c0c4-0d00-86f2-0f880df24b96 Oct 23 2023
StackToRegisterMappingCogit VMMaker-tonel.1 uuid: 902dd483-c0c4-0d00-86f2-0f880df24b96 Oct 23 2023
v10.0.8 - Commit: b323c5fb - Date: 2023-10-20 16:02:07 -0400

Image: Pharo11.0.0 [Build information: Pharo-11.0.0+build.710.sha.ea28d8552cac85a7ce1e9c34ab1e7bd45f7b9910 (64 Bit)]

RSBox(Object)>>doesNotUnderstand: #center
	Receiver: a RSBox
	Arguments and temporary variables: 
		aMessage: 	center
		exception: 	Instance of RSBox did not understand #center
		resumeValue: 	nil
	Receiver's instance variables: 
		announcer: 	nil
		properties: 	nil
		paint: 	Color blue
		path: 	(-10.0@ -10.0) corner: (10.0@10.0)
		border: 	nil
		parent: 	a RSCanvas
		isFixed: 	false
		encompassingRectangle: 	nil
		model: 	nil
		baseRectangle: 	(-10.0@ -10.0) corner: (10.0@10.0)
		matrix: 	x: 0.0 y: 0.0 sx: 1.0 sy: 1.0 shx: 0.0 shy: 0.0
		connectedLines: 	nil
		shouldUpdateLines: 	true
		cornerRadius: 	nil


[ :edgeDict |
        | edge sourceNode targetNode |
        sourceNode := nodesMap at: (edgeDict at: #source) ifAbsent: [ nil ].
        targetNode := nodesMap at: (edgeDict at: #target) ifAbsent: [ nil ].
        sourceNode ifNotNil: [ targetNode ifNotNil: [
            edge := RSLine new.
            edge start: sourceNode center; end: targetNode center.
            canvas add: edge.
        ]].
    ] in GraphVisualizer>>createEdges
	Receiver: a GraphVisualizer
	Arguments and temporary variables: 
		edgeDict: 	a Dictionary('source'->1 'target'->2 'type'->'FRIENDS_WITH' )
		edge: 	a RSLine
		sourceNode: 	a RSBox
		targetNode: 	a RSBox
	Receiver's instance variables: 
		view: 	nil
		nodes: 	an Array(a Dictionary('id'->1 'label'->'Person' 'properties'->a Dict[..]
		edges: 	an Array(a Dictionary('source'->1 'target'->2 'type'->'FRIENDS_WITH' ))
		nodesMap: 	a Dictionary(1->a RSBox 2->a RSBox )
		canvas: 	a RSCanvas


Array(SequenceableCollection)>>do:
	Receiver: an Array(a Dictionary('source'->1 'target'->2 'type'->'FRIENDS_WITH' ))
	Arguments and temporary variables: 
		aBlock: 	[ :edgeDict |
        | edge sourceNode targetNode |
        source[..]
		index: 	1
	Receiver's instance variables: 
an Array(a Dictionary('source'->1 'target'->2 'type'->'FRIENDS_WITH' ))

GraphVisualizer>>createEdges
	Receiver: a GraphVisualizer
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		view: 	nil
		nodes: 	an Array(a Dictionary('id'->1 'label'->'Person' 'properties'->a Dict[..]
		edges: 	an Array(a Dictionary('source'->1 'target'->2 'type'->'FRIENDS_WITH' ))
		nodesMap: 	a Dictionary(1->a RSBox 2->a RSBox )
		canvas: 	a RSCanvas


GraphVisualizer>>visualizeGraphFromFile:
	Receiver: a GraphVisualizer
	Arguments and temporary variables: 
		aFilePath: 	'/Users/ryanperez/Documents/GitHub/pp-rep2533/project/src/data/t[..]
	Receiver's instance variables: 
		view: 	nil
		nodes: 	an Array(a Dictionary('id'->1 'label'->'Person' 'properties'->a Dict[..]
		edges: 	an Array(a Dictionary('source'->1 'target'->2 'type'->'FRIENDS_WITH' ))
		nodesMap: 	a Dictionary(1->a RSBox 2->a RSBox )
		canvas: 	a RSCanvas


UndefinedObject>>DoIt
	Receiver: nil
	Arguments and temporary variables: 
		visualizer: 	a GraphVisualizer
	Receiver's instance variables: 
nil

OCReceiverDoItSemanticScope(OCDoItSemanticScope)>>evaluateDoIt:
	Receiver: an OCReceiverDoItSemanticScope
	Arguments and temporary variables: 
		doItMethod: 	UndefinedObject>>#DoIt
	Receiver's instance variables: 
		outerScope: 	nil
		targetReceiver: 	nil


OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
		doItMethod: 	UndefinedObject>>#DoIt
	Receiver's instance variables: 
		ast: 	DoIt

	| visualizer |
	visualizer := GraphVisualizer new.
	^ visualize[..]
		source: 	a ReadStream
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil


[
		self announcer announce: (SpCodeWillBeEvaluatedAnnouncement newContent: aString).
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionModel doItReceiver.
		result := receiver class compiler
			source: aString;
			context: self interactionModel doItContext;
			receiver: self interactionModel doItReceiver;
			requestor: self interactionModel;
			environment: self environment;
			failBlock:  [ 
				self announcer announce: (SpCodeEvaluationFailedAnnouncement newContent: aString).
				^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		self announcer announce: (SpCodeEvaluationSucceedAnnouncement newContent: aString).
		result ] in SpCodePresenter>>evaluate:onCompileError:onError:
	Receiver: a SpCodePresenter
	Arguments and temporary variables: 
		aString: 	'| visualizer |
visualizer := GraphVisualizer new.
visualizer visu[..]
		compileErrorBlock: 	[ ^ self ]
		errorBlock: 	[ :e | e pass ]
		receiver: 	nil
		result: 	nil
		oldBindings: 	a Dictionary()
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicCodeAdapter)
		announcer: 	an Announcer
		owner: 	a StPlaygroundPagePresenter
		adapter: 	a SpMorphicCodeAdapter
		needRebuild: 	true
		eventHandler: 	a SpEventHandler
		application: 	nil
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ a KMCategory ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Code' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpAbstractWidgetLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		borderWidth: 	an ObservableValueHolder[ nil ]
		borderColor: 	an ObservableValueHolder[ nil ]
		dragEnabled: 	an ObservableValueHolder[ false ]
		dropEnabled: 	an ObservableValueHolder[ false ]
		color: 	an ObservableValueHolder[ nil ]
		help: 	an ObservableValueHolder[ nil ]
		enabled: 	an ObservableValueHolder[ true ]
		wantsDrop: 	an ObservableValueHolder[ [ :transfer | self dropEnabled ] ]
		acceptDrop: 	an ObservableValueHolder[ [ :transfer | ] ]
		deferredActions: 	nil
		hasUnacceptedEdits: 	an ObservableValueHolder[ false ]
		selection: 	an ObservableValueHolder[ (1 to: 159) ]
		wantsVisualFeedback: 	an ObservableValueHolder[ true ]
		askBeforeDiscardingEdits: 	an ObservableValueHolder[ true ]
		text: 	an ObservableValueHolder[ '| visualizer |
visualizer := GraphVisualiz[..]
		actionToPerform: 	an ObservableValueHolder[ [ :txt |  ] ]
		readSelection: 	an ObservableValueHolder[ [ selection ] ]
		placeholder: 	an ObservableValueHolder[ '' ]
		contextMenu: 	an ObservableValueHolder[ [ (self menuActionsFor: text) asMenu[..]
		scrollValue: 	an ObservableValueHolder[ (0@0) ]
		editionContextMenu: 	an ObservableValueHolder[ true ]
		editable: 	an ObservableValueHolder[ true ]
		wrapWord: 	an ObservableValueHolder[ true ]
		undoRedoHistory: 	true
		wrapScrollBars: 	true
		propagateNaturalHeight: 	false
		propagateNaturalWidth: 	false
		scrollBarStyles: 	#()
		syntaxHighlight: 	an ObservableValueHolder[ true ]
		smartCharacters: 	an ObservableValueHolder[ true ]
		lineNumbers: 	an ObservableValueHolder[ true ]
		interactionModel: 	an ObservableValueHolder[ a StPlaygroundInteractionModel ]
		overrideContextMenu: 	true
		submitBlock: 	nil
		resetBlock: 	nil
		environment: 	nil
		systemNavigation: 	nil
		syntaxHighlightTheme: 	an ObservableValueHolder[ nil ]


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
		self announcer announce: (SpCodeWillBeEvaluatedAnnouncement newContent: aString).
[..]
	Arguments and temporary variables: 
		exception: 	Error
		handlerAction: 	[ :e |
		self announcer announce: (SpCodeEvaluationFailedAnn[..]
	Receiver's instance variables: 
		outerContext: 	SpCodePresenter>>evaluate:onCompileError:onError:
		compiledBlock: 	a CompiledBlock: [
		self announcer announce: (SpCodeWillBeE[..]
		numArgs: 	0
		receiver: 	a SpCodePresenter


SpCodePresenter>>evaluate:onCompileError:onError:
	Receiver: a SpCodePresenter
	Arguments and temporary variables: 
		receiver: 	nil
		result: 	nil
		oldBindings: 	a Dictionary()
		aString: 	'| visualizer |
visualizer := GraphVisualizer new.
visualizer visu[..]
		compileErrorBlock: 	[ ^ self ]
		errorBlock: 	[ :e | e pass ]
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicCodeAdapter)
		announcer: 	an Announcer
		owner: 	a StPlaygroundPagePresenter
		adapter: 	a SpMorphicCodeAdapter
		needRebuild: 	true
		eventHandler: 	a SpEventHandler
		application: 	nil
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ a KMCategory ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Code' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpAbstractWidgetLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		borderWidth: 	an ObservableValueHolder[ nil ]
		borderColor: 	an ObservableValueHolder[ nil ]
		dragEnabled: 	an ObservableValueHolder[ false ]
		dropEnabled: 	an ObservableValueHolder[ false ]
		color: 	an ObservableValueHolder[ nil ]
		help: 	an ObservableValueHolder[ nil ]
		enabled: 	an ObservableValueHolder[ true ]
		wantsDrop: 	an ObservableValueHolder[ [ :transfer | self dropEnabled ] ]
		acceptDrop: 	an ObservableValueHolder[ [ :transfer | ] ]
		deferredActions: 	nil
		hasUnacceptedEdits: 	an ObservableValueHolder[ false ]
		selection: 	an ObservableValueHolder[ (1 to: 159) ]
		wantsVisualFeedback: 	an ObservableValueHolder[ true ]
		askBeforeDiscardingEdits: 	an ObservableValueHolder[ true ]
		text: 	an ObservableValueHolder[ '| visualizer |
visualizer := GraphVisualiz[..]
		actionToPerform: 	an ObservableValueHolder[ [ :txt |  ] ]
		readSelection: 	an ObservableValueHolder[ [ selection ] ]
		placeholder: 	an ObservableValueHolder[ '' ]
		contextMenu: 	an ObservableValueHolder[ [ (self menuActionsFor: text) asMenu[..]
		scrollValue: 	an ObservableValueHolder[ (0@0) ]
		editionContextMenu: 	an ObservableValueHolder[ true ]
		editable: 	an ObservableValueHolder[ true ]
		wrapWord: 	an ObservableValueHolder[ true ]
		undoRedoHistory: 	true
		wrapScrollBars: 	true
		propagateNaturalHeight: 	false
		propagateNaturalWidth: 	false
		scrollBarStyles: 	#()
		syntaxHighlight: 	an ObservableValueHolder[ true ]
		smartCharacters: 	an ObservableValueHolder[ true ]
		lineNumbers: 	an ObservableValueHolder[ true ]
		interactionModel: 	an ObservableValueHolder[ a StPlaygroundInteractionModel ]
		overrideContextMenu: 	true
		submitBlock: 	nil
		resetBlock: 	nil
		environment: 	nil
		systemNavigation: 	nil
		syntaxHighlightTheme: 	an ObservableValueHolder[ nil ]


StPlaygroundPagePresenter>>doEvaluateAndGo
	Receiver: a StPlaygroundPagePresenter
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicBoxAdapter)
		announcer: 	an Announcer
		owner: 	a SpMillerColumnPresenter
		adapter: 	a SpMorphicBoxAdapter
		needRebuild: 	true
		eventHandler: 	nil
		application: 	a StPharoApplication
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ nil ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Untitled window' ]
		additionalSubpresentersMap: 	a Dictionary()
		layout: 	an ObservableValueHolder[ a SpBoxLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		text: 	a SpCodePresenter
		toolbar: 	a SpToolbarPresenter
		statusbar: 	a SpPresenter
		lineLabel: 	a SpLabelPresenter
		toggleLineNumberButton: 	a SpToggleButtonPresenter
		page: 	a StPlaygroundPage
		activationBlock: 	[ :selection |
		self changeSelection: selection from: new[..]


StPlaygroundPagePresenter>>doEvaluateAllAndGo
	Receiver: a StPlaygroundPagePresenter
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicBoxAdapter)
		announcer: 	an Announcer
		owner: 	a SpMillerColumnPresenter
		adapter: 	a SpMorphicBoxAdapter
		needRebuild: 	true
		eventHandler: 	nil
		application: 	a StPharoApplication
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ nil ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Untitled window' ]
		additionalSubpresentersMap: 	a Dictionary()
		layout: 	an ObservableValueHolder[ a SpBoxLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		text: 	a SpCodePresenter
		toolbar: 	a SpToolbarPresenter
		statusbar: 	a SpPresenter
		lineLabel: 	a SpLabelPresenter
		toggleLineNumberButton: 	a SpToggleButtonPresenter
		page: 	a StPlaygroundPage
		activationBlock: 	[ :selection |
		self changeSelection: selection from: new[..]


StPlaygroundDoItCommand>>execute
	Receiver: a StPlaygroundDoItCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		context: 	a StPlaygroundPagePresenter
		basicName: 	'Do it'
		basicDescription: 	'Do it all and inspect.'


SpCommand(CmCommandDecorator)>>execute
	Receiver: a SpCommand(Do it)
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a StPlaygroundDoItCommand
		iconProvider: 	a StPharoApplication
		iconName: 	#glamorousGo
		shortcutKey: 	nil
		displayStrategy: 	a CmUIDisableWhenCantBeRun
		positionStrategy: 	a CmUILeftPositionStrategy
		buildPresenterBlock: 	[ :specCommand | 
			aButtonClass new
				label: specC[..]
		presenter: 	a SpToolbarButtonPresenter


[ specCommand execute ] in [ :specCommand | 
			aButtonClass new
				label: specCommand name;
				help: specCommand description;
				in: [ :button | 
					specCommand hasIcon
						ifTrue: [ button icon: specCommand icon ] ];
				action: [ specCommand execute ];
				yourself ] in SpCommand>>configureAsButtonOfClass:
	Receiver: a SpCommand(Do it)
	Arguments and temporary variables: 
		aButtonClass: 	nil
		specCommand: 	a SpCommand(Do it)
	Receiver's instance variables: 
		decoratedCommand: 	a StPlaygroundDoItCommand
		iconProvider: 	a StPharoApplication
		iconName: 	#glamorousGo
		shortcutKey: 	nil
		displayStrategy: 	a CmUIDisableWhenCantBeRun
		positionStrategy: 	a CmUILeftPositionStrategy
		buildPresenterBlock: 	[ :specCommand | 
			aButtonClass new
				label: specC[..]
		presenter: 	a SpToolbarButtonPresenter


FullBlockClosure(BlockClosure)>>cull:
	Receiver: [ specCommand execute ]
	Arguments and temporary variables: 
		anArg: 	a SpToolbarButtonPresenter
	Receiver's instance variables: 
		outerContext: 	[ :specCommand | 
			aButtonClass new
				label: specCommand [..]
		compiledBlock: 	a CompiledBlock: [ specCommand execute ]
		numArgs: 	0
		receiver: 	a SpCommand(Do it)


SpMorphicToolbarButtonAdapter>>execute
	Receiver: a SpMorphicToolbarButtonAdapter
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpToolbarButtonMorph(163457024))
		announcer: 	nil
		model: 	a SpToolbarButtonPresenter
		widget: 	a SpToolbarButtonMorph(163457024)
		selector: 	nil
		owner: 	a SpToolbarButtonPresenter
		unsubscribed: 	false


SpToolbarButtonMorph(PluggableButtonMorph)>>performAction:
	Receiver: a SpToolbarButtonMorph(163457024)
	Arguments and temporary variables: 
		event: 	[(13.0@26.0) mouseUp 11855589 nil]
	Receiver's instance variables: 
		bounds: 	(0.0@5.0) corner: (45.0@39.0)
		owner: 	a Morph(543889152)
		submorphs: 	an Array(an AlignmentMorph(1048008448))
		fullBounds: 	nil
		color: 	(Color r: 0.9012707722385142 g: 0.9012707722385142 b: 0.901270772238[..]
		extension: 	a MorphExtension (606190080) [balloonText]  [other:  (presenter [..]
		borderWidth: 	0
		borderColor: 	#simple
		model: 	a SpMorphicToolbarButtonAdapter
		label: 	'Do it'
		icon: 	Form(13x13x32)
		getIconSelector: 	#icon
		getStateSelector: 	#state
		actionSelector: 	#execute
		font: 	a LogicalFont
 familyName: 'Source Sans Pro'
 emphasis: nil
 pointSiz[..]
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	nil
		getFontSelector: 	nil
		labelMorph: 	a LabelMorph(576130816)'Do it'
		iconMorph: 	an ImageMorph(527603200)
		iconPosition: 	#top
		lastState: 	false
		badgeFont: 	nil
		badgeSelector: 	#badge


[:m |
		(m containsPoint: evt cursorPoint) ifTrue: [m enabled ifTrue: [ m performAction: evt ]]] in SpToolbarButtonMorph(PluggableButtonMorph)>>mouseUp:
	Receiver: a SpToolbarButtonMorph(163457024)
	Arguments and temporary variables: 
		evt: 	[(13.0@26.0) mouseUp 11855589 nil]
		all: 	an Array(a SpToolbarButtonMorph(163457024) a SpToolbarButtonMorph(6416[..]
		m: 	a SpToolbarButtonMorph(163457024)
	Receiver's instance variables: 
		bounds: 	(0.0@5.0) corner: (45.0@39.0)
		owner: 	a Morph(543889152)
		submorphs: 	an Array(an AlignmentMorph(1048008448))
		fullBounds: 	nil
		color: 	(Color r: 0.9012707722385142 g: 0.9012707722385142 b: 0.901270772238[..]
		extension: 	a MorphExtension (606190080) [balloonText]  [other:  (presenter [..]
		borderWidth: 	0
		borderColor: 	#simple
		model: 	a SpMorphicToolbarButtonAdapter
		label: 	'Do it'
		icon: 	Form(13x13x32)
		getIconSelector: 	#icon
		getStateSelector: 	#state
		actionSelector: 	#execute
		font: 	a LogicalFont
 familyName: 'Source Sans Pro'
 emphasis: nil
 pointSiz[..]
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	nil
		getFontSelector: 	nil
		labelMorph: 	a LabelMorph(576130816)'Do it'
		iconMorph: 	an ImageMorph(527603200)
		iconPosition: 	#top
		lastState: 	false
		badgeFont: 	nil
		badgeSelector: 	#badge


Array(SequenceableCollection)>>do:
	Receiver: an Array(a SpToolbarButtonMorph(163457024) a SpToolbarButtonMorph(641645312) a SpToolb[..]
	Arguments and temporary variables: 
		aBlock: 	[:m |
		(m containsPoint: evt cursorPoint) ifTrue: [m enabled ifTru[..]
		index: 	1
	Receiver's instance variables: 
an Array(a SpToolbarButtonMorph(163457024) a SpToolbarButtonMorph(641645312) a SpToolb[..]

SpToolbarButtonMorph(PluggableButtonMorph)>>mouseUp:
	Receiver: a SpToolbarButtonMorph(163457024)
	Arguments and temporary variables: 
		evt: 	[(13.0@26.0) mouseUp 11855589 nil]
		all: 	an Array(a SpToolbarButtonMorph(163457024) a SpToolbarButtonMorph(6416[..]
	Receiver's instance variables: 
		bounds: 	(0.0@5.0) corner: (45.0@39.0)
		owner: 	a Morph(543889152)
		submorphs: 	an Array(an AlignmentMorph(1048008448))
		fullBounds: 	nil
		color: 	(Color r: 0.9012707722385142 g: 0.9012707722385142 b: 0.901270772238[..]
		extension: 	a MorphExtension (606190080) [balloonText]  [other:  (presenter [..]
		borderWidth: 	0
		borderColor: 	#simple
		model: 	a SpMorphicToolbarButtonAdapter
		label: 	'Do it'
		icon: 	Form(13x13x32)
		getIconSelector: 	#icon
		getStateSelector: 	#state
		actionSelector: 	#execute
		font: 	a LogicalFont
 familyName: 'Source Sans Pro'
 emphasis: nil
 pointSiz[..]
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	nil
		getFontSelector: 	nil
		labelMorph: 	a LabelMorph(576130816)'Do it'
		iconMorph: 	an ImageMorph(527603200)
		iconPosition: 	#top
		lastState: 	false
		badgeFont: 	nil
		badgeSelector: 	#badge


SpToolbarButtonMorph(Morph)>>handleMouseUp:
	Receiver: a SpToolbarButtonMorph(163457024)
	Arguments and temporary variables: 
		anEvent: 	[(13.0@26.0) mouseUp 11855589 nil]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(0.0@5.0) corner: (45.0@39.0)
		owner: 	a Morph(543889152)
		submorphs: 	an Array(an AlignmentMorph(1048008448))
		fullBounds: 	nil
		color: 	(Color r: 0.9012707722385142 g: 0.9012707722385142 b: 0.901270772238[..]
		extension: 	a MorphExtension (606190080) [balloonText]  [other:  (presenter [..]
		borderWidth: 	0
		borderColor: 	#simple
		model: 	a SpMorphicToolbarButtonAdapter
		label: 	'Do it'
		icon: 	Form(13x13x32)
		getIconSelector: 	#icon
		getStateSelector: 	#state
		actionSelector: 	#execute
		font: 	a LogicalFont
 familyName: 'Source Sans Pro'
 emphasis: nil
 pointSiz[..]
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	nil
		getFontSelector: 	nil
		labelMorph: 	a LabelMorph(576130816)'Do it'
		iconMorph: 	an ImageMorph(527603200)
		iconPosition: 	#top
		lastState: 	false
		badgeFont: 	nil
		badgeSelector: 	#badge


MouseButtonEvent>>sentTo:
	Receiver: [(13.0@26.0) mouseUp 11855589 nil]
	Arguments and temporary variables: 
		anObject: 	a SpToolbarButtonMorph(163457024)
	Receiver's instance variables: 
		timeStamp: 	11855589
		source: 	a HandMorph(337424384)
		windowIndex: 	nil
		type: 	#mouseUp
		buttons: 	0
		position: 	(13.0@26.0)
		handler: 	nil
		wasHandled: 	true
		whichButton: 	4


SpToolbarButtonMorph(Morph)>>handleEvent:
	Receiver: a SpToolbarButtonMorph(163457024)
	Arguments and temporary variables: 
		anEvent: 	[(13.0@26.0) mouseUp 11855589 nil]
	Receiver's instance variables: 
		bounds: 	(0.0@5.0) corner: (45.0@39.0)
		owner: 	a Morph(543889152)
		submorphs: 	an Array(an AlignmentMorph(1048008448))
		fullBounds: 	nil
		color: 	(Color r: 0.9012707722385142 g: 0.9012707722385142 b: 0.901270772238[..]
		extension: 	a MorphExtension (606190080) [balloonText]  [other:  (presenter [..]
		borderWidth: 	0
		borderColor: 	#simple
		model: 	a SpMorphicToolbarButtonAdapter
		label: 	'Do it'
		icon: 	Form(13x13x32)
		getIconSelector: 	#icon
		getStateSelector: 	#state
		actionSelector: 	#execute
		font: 	a LogicalFont
 familyName: 'Source Sans Pro'
 emphasis: nil
 pointSiz[..]
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	nil
		getFontSelector: 	nil
		labelMorph: 	a LabelMorph(576130816)'Do it'
		iconMorph: 	an ImageMorph(527603200)
		iconPosition: 	#top
		lastState: 	false
		badgeFont: 	nil
		badgeSelector: 	#badge


SpToolbarButtonMorph(Morph)>>handleFocusEvent:
	Receiver: a SpToolbarButtonMorph(163457024)
	Arguments and temporary variables: 
		anEvent: 	[(13.0@26.0) mouseUp 11855589 nil]
	Receiver's instance variables: 
		bounds: 	(0.0@5.0) corner: (45.0@39.0)
		owner: 	a Morph(543889152)
		submorphs: 	an Array(an AlignmentMorph(1048008448))
		fullBounds: 	nil
		color: 	(Color r: 0.9012707722385142 g: 0.9012707722385142 b: 0.901270772238[..]
		extension: 	a MorphExtension (606190080) [balloonText]  [other:  (presenter [..]
		borderWidth: 	0
		borderColor: 	#simple
		model: 	a SpMorphicToolbarButtonAdapter
		label: 	'Do it'
		icon: 	Form(13x13x32)
		getIconSelector: 	#icon
		getStateSelector: 	#state
		actionSelector: 	#execute
		font: 	a LogicalFont
 familyName: 'Source Sans Pro'
 emphasis: nil
 pointSiz[..]
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	nil
		getFontSelector: 	nil
		labelMorph: 	a LabelMorph(576130816)'Do it'
		iconMorph: 	an ImageMorph(527603200)
		iconPosition: 	#top
		lastState: 	false
		badgeFont: 	nil
		badgeSelector: 	#badge


[
		result := focusHolder handleFocusEvent: transformedEvent.
	] in HandMorph>>sendFocusEvent:to:clear:
	Receiver: a HandMorph(337424384)
	Arguments and temporary variables: 
		anEvent: 	[(468@214) mouseUp 11855589 nil]
		focusHolder: 	a SpToolbarButtonMorph(163457024)
		aBlock: 	[self mouseFocus: nil]
		w: 	a WorldMorph(341720576) [world]
		transformedEvent: 	[(13.0@26.0) mouseUp 11855589 nil]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(468@214.0) corner: (484@230.0)
		owner: 	a WorldMorph(341720576) [world]
		submorphs: 	#()
		fullBounds: 	(468@214.0) corner: (484@230.0)
		color: 	Color blue
		extension: 	a MorphExtension (370611968)
		mouseFocus: 	nil
		keyboardFocus: 	a RubEditingArea(143191808)
		eventListeners: 	nil
		mouseListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(468@214) mouseUp 11855589 nil]
		targetOffset: 	(13.0@21.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 0 0 0 0 0 nil nil)
		captureBlock: 	nil
		recentModifiers: 	0
		pendingEventQueue: 	WaitfreeQueue with 0 items
		supressNextKeyPress: 	false


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
		result := focusHolder handleFocusEvent: transformedEvent.
	]
	Arguments and temporary variables: 
		exception: 	Error
		handlerAction: 	[ :ex |
			ActiveWorld := priorWorld.
			ex pass ]
	Receiver's instance variables: 
		outerContext: 	HandMorph>>sendFocusEvent:to:clear:
		compiledBlock: 	a CompiledBlock: [
		result := focusHolder handleFocusEvent:[..]
		numArgs: 	0
		receiver: 	a HandMorph(337424384)


WorldMorph>>becomeActiveDuring:
	Receiver: a WorldMorph(341720576) [world]
	Arguments and temporary variables: 
		aBlock: 	[
		result := focusHolder handleFocusEvent: transformedEvent.
	]
		priorWorld: 	a WorldMorph(341720576) [world]
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1728@1080)
		owner: 	nil
		submorphs: 	an Array(a MenubarMorph(112886016) a TaskbarMorph(279458560) a S[..]
		fullBounds: 	(0@0) corner: (1728@1080)
		color: 	(Color r: 0.9403714565004888 g: 0.9403714565004888 b: 0.940371456500[..]
		extension: 	a MorphExtension (1012946432) [other:  (dragEnabled -> true) (dr[..]
		borderWidth: 	0
		borderColor: 	(Color r: 0.8611925708699902 g: 1.0 b: 0.7223851417399805 alph[..]
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil


HandMorph>>sendFocusEvent:to:clear:
	Receiver: a HandMorph(337424384)
	Arguments and temporary variables: 
		result: 	nil
		anEvent: 	[(468@214) mouseUp 11855589 nil]
		focusHolder: 	a SpToolbarButtonMorph(163457024)
		aBlock: 	[self mouseFocus: nil]
		w: 	a WorldMorph(341720576) [world]
		transformedEvent: 	[(13.0@26.0) mouseUp 11855589 nil]
	Receiver's instance variables: 
		bounds: 	(468@214.0) corner: (484@230.0)
		owner: 	a WorldMorph(341720576) [world]
		submorphs: 	#()
		fullBounds: 	(468@214.0) corner: (484@230.0)
		color: 	Color blue
		extension: 	a MorphExtension (370611968)
		mouseFocus: 	nil
		keyboardFocus: 	a RubEditingArea(143191808)
		eventListeners: 	nil
		mouseListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(468@214) mouseUp 11855589 nil]
		targetOffset: 	(13.0@21.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 0 0 0 0 0 nil nil)
		captureBlock: 	nil
		recentModifiers: 	0
		pendingEventQueue: 	WaitfreeQueue with 0 items
		supressNextKeyPress: 	false


HandMorph>>sendEvent:focus:clear:
	Receiver: a HandMorph(337424384)
	Arguments and temporary variables: 
		anEvent: 	[(468@214) mouseUp 11855589 nil]
		focusHolder: 	a SpToolbarButtonMorph(163457024)
		aBlock: 	[self mouseFocus: nil]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(468@214.0) corner: (484@230.0)
		owner: 	a WorldMorph(341720576) [world]
		submorphs: 	#()
		fullBounds: 	(468@214.0) corner: (484@230.0)
		color: 	Color blue
		extension: 	a MorphExtension (370611968)
		mouseFocus: 	nil
		keyboardFocus: 	a RubEditingArea(143191808)
		eventListeners: 	nil
		mouseListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(468@214) mouseUp 11855589 nil]
		targetOffset: 	(13.0@21.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 0 0 0 0 0 nil nil)
		captureBlock: 	nil
		recentModifiers: 	0
		pendingEventQueue: 	WaitfreeQueue with 0 items
		supressNextKeyPress: 	false


HandMorph>>sendMouseEvent:
	Receiver: a HandMorph(337424384)
	Arguments and temporary variables: 
		anEvent: 	[(468@214) mouseUp 11855589 nil]
	Receiver's instance variables: 
		bounds: 	(468@214.0) corner: (484@230.0)
		owner: 	a WorldMorph(341720576) [world]
		submorphs: 	#()
		fullBounds: 	(468@214.0) corner: (484@230.0)
		color: 	Color blue
		extension: 	a MorphExtension (370611968)
		mouseFocus: 	nil
		keyboardFocus: 	a RubEditingArea(143191808)
		eventListeners: 	nil
		mouseListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(468@214) mouseUp 11855589 nil]
		targetOffset: 	(13.0@21.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 0 0 0 0 0 nil nil)
		captureBlock: 	nil
		recentModifiers: 	0
		pendingEventQueue: 	WaitfreeQueue with 0 items
		supressNextKeyPress: 	false


HandMorph>>handleEvent:
	Receiver: a HandMorph(337424384)
	Arguments and temporary variables: 
		anEvent: 	[(468@214) mouseUp 11855589 nil]
		evt: 	[(468@214) mouseUp 11855589 nil]
	Receiver's instance variables: 
		bounds: 	(468@214.0) corner: (484@230.0)
		owner: 	a WorldMorph(341720576) [world]
		submorphs: 	#()
		fullBounds: 	(468@214.0) corner: (484@230.0)
		color: 	Color blue
		extension: 	a MorphExtension (370611968)
		mouseFocus: 	nil
		keyboardFocus: 	a RubEditingArea(143191808)
		eventListeners: 	nil
		mouseListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(468@214) mouseUp 11855589 nil]
		targetOffset: 	(13.0@21.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 0 0 0 0 0 nil nil)
		captureBlock: 	nil
		recentModifiers: 	0
		pendingEventQueue: 	WaitfreeQueue with 0 items
		supressNextKeyPress: 	false


[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil ]) ifTrue: [
			morphicWorld activeHand handleEvent: anEvent
		]
	] in OSWindowMorphicEventHandler>>dispatchMorphicEvent:
	Receiver: an OSWindowMorphicEventHandler
	Arguments and temporary variables: 
		anEvent: 	[(468@214) mouseUp 11855589 nil]
	Receiver's instance variables: 
		morphicWorld: 	a WorldMorph(341720576) [world]


WorldState>>runStepMethodsIn:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(341720576) [world]
		queue: 	WaitfreeQueue with 0 items
		nextInQueue: 	[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNo[..]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(337424384))
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap()
		lastStepTime: 	11852264
		lastStepMessage: 	nil
		alarms: 	a Heap(MorphicAlarm(#hideShow -> a RubCursor(27124480)))
		lastAlarmTime: 	11855582
		activeHand: 	a HandMorph(337424384)
		currentCursor: 	((CursorWithMask
	extent: (16@16)
	depth: 1
	fromArray: #(
	[..]
		worldRenderer: 	an OSWorldRenderer
		realWindowExtent: 	(1728@1080)
		deferredUIMessages: 	WaitfreeQueue with 0 items


WorldMorph>>runStepMethods
	Receiver: a WorldMorph(341720576) [world]
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1728@1080)
		owner: 	nil
		submorphs: 	an Array(a MenubarMorph(112886016) a TaskbarMorph(279458560) a S[..]
		fullBounds: 	(0@0) corner: (1728@1080)
		color: 	(Color r: 0.9403714565004888 g: 0.9403714565004888 b: 0.940371456500[..]
		extension: 	a MorphExtension (1012946432) [other:  (dragEnabled -> true) (dr[..]
		borderWidth: 	0
		borderColor: 	(Color r: 0.8611925708699902 g: 1.0 b: 0.7223851417399805 alph[..]
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil


WorldState>>doOneCycleFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(341720576) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(337424384))
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap()
		lastStepTime: 	11852264
		lastStepMessage: 	nil
		alarms: 	a Heap(MorphicAlarm(#hideShow -> a RubCursor(27124480)))
		lastAlarmTime: 	11855582
		activeHand: 	a HandMorph(337424384)
		currentCursor: 	((CursorWithMask
	extent: (16@16)
	depth: 1
	fromArray: #(
	[..]
		worldRenderer: 	an OSWorldRenderer
		realWindowExtent: 	(1728@1080)
		deferredUIMessages: 	WaitfreeQueue with 0 items


WorldMorph>>doOneCycleNow
	Receiver: a WorldMorph(341720576) [world]
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1728@1080)
		owner: 	nil
		submorphs: 	an Array(a MenubarMorph(112886016) a TaskbarMorph(279458560) a S[..]
		fullBounds: 	(0@0) corner: (1728@1080)
		color: 	(Color r: 0.9403714565004888 g: 0.9403714565004888 b: 0.940371456500[..]
		extension: 	a MorphExtension (1012946432) [other:  (dragEnabled -> true) (dr[..]
		borderWidth: 	0
		borderColor: 	(Color r: 0.8611925708699902 g: 1.0 b: 0.7223851417399805 alph[..]
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil


WorldMorph>>doOneCycle
	Receiver: a WorldMorph(341720576) [world]
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1728@1080)
		owner: 	nil
		submorphs: 	an Array(a MenubarMorph(112886016) a TaskbarMorph(279458560) a S[..]
		fullBounds: 	(0@0) corner: (1728@1080)
		color: 	(Color r: 0.9403714565004888 g: 0.9403714565004888 b: 0.940371456500[..]
		extension: 	a MorphExtension (1012946432) [other:  (dragEnabled -> true) (dr[..]
		borderWidth: 	0
		borderColor: 	(Color r: 0.8611925708699902 g: 1.0 b: 0.7223851417399805 alph[..]
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil



--- The full stack ---
RSBox(Object)>>doesNotUnderstand: #center
[ :edgeDict |
        | edge sourceNode targetNode |
        sourceNode := nodesMap at: (edgeDict at: #source) ifAbsent: [ nil ].
        targetNode := nodesMap at: (edgeDict at: #target) ifAbsent: [ nil ].
        sourceNode ifNotNil: [ targetNode ifNotNil: [
            edge := RSLine new.
            edge start: sourceNode center; end: targetNode center.
            canvas add: edge.
        ]].
    ] in GraphVisualizer>>createEdges
Array(SequenceableCollection)>>do:
GraphVisualizer>>createEdges
GraphVisualizer>>visualizeGraphFromFile:
UndefinedObject>>DoIt
OCReceiverDoItSemanticScope(OCDoItSemanticScope)>>evaluateDoIt:
OpalCompiler>>evaluate
[
		self announcer announce: (SpCodeWillBeEvaluatedAnnouncement newContent: aString).
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionModel doItReceiver.
		result := receiver class compiler
			source: aString;
			context: self interactionModel doItContext;
			receiver: self interactionModel doItReceiver;
			requestor: self interactionModel;
			environment: self environment;
			failBlock:  [ 
				self announcer announce: (SpCodeEvaluationFailedAnnouncement newContent: aString).
				^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		self announcer announce: (SpCodeEvaluationSucceedAnnouncement newContent: aString).
		result ] in SpCodePresenter>>evaluate:onCompileError:onError:
FullBlockClosure(BlockClosure)>>on:do:
SpCodePresenter>>evaluate:onCompileError:onError:
StPlaygroundPagePresenter>>doEvaluateAndGo
StPlaygroundPagePresenter>>doEvaluateAllAndGo
StPlaygroundDoItCommand>>execute
SpCommand(CmCommandDecorator)>>execute
[ specCommand execute ] in [ :specCommand | 
			aButtonClass new
				label: specCommand name;
				help: specCommand description;
				in: [ :button | 
					specCommand hasIcon
						ifTrue: [ button icon: specCommand icon ] ];
				action: [ specCommand execute ];
				yourself ] in SpCommand>>configureAsButtonOfClass:
FullBlockClosure(BlockClosure)>>cull:
SpMorphicToolbarButtonAdapter>>execute
SpToolbarButtonMorph(PluggableButtonMorph)>>performAction:
[:m |
		(m containsPoint: evt cursorPoint) ifTrue: [m enabled ifTrue: [ m performAction: evt ]]] in SpToolbarButtonMorph(PluggableButtonMorph)>>mouseUp:
Array(SequenceableCollection)>>do:
SpToolbarButtonMorph(PluggableButtonMorph)>>mouseUp:
SpToolbarButtonMorph(Morph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
SpToolbarButtonMorph(Morph)>>handleEvent:
SpToolbarButtonMorph(Morph)>>handleFocusEvent:
[
		result := focusHolder handleFocusEvent: transformedEvent.
	] in HandMorph>>sendFocusEvent:to:clear:
FullBlockClosure(BlockClosure)>>on:do:
WorldMorph>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil ]) ifTrue: [
			morphicWorld activeHand handleEvent: anEvent
		]
	] in OSWindowMorphicEventHandler>>dispatchMorphicEvent:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycleNow
WorldMorph>>doOneCycle
 - - - - - - - - - - - - - - -
			- - - - - - - - - - - - - - - - - -
[
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMutex critical: [
			                     self extraWorldList ].
		extraWorldsToDraw do: [ :world | world doOneCycle ].

		(self currentWorld isNotNil and: [
			 (extraWorldsToDraw includes: self currentWorld) not ]) ifTrue: [
			self currentWorld doOneCycle ] ] in WorldMorph class>>doOneCycle
FullBlockClosure(BlockClosure)>>ensure:
WorldState class>>doDrawCycleWith:
WorldMorph class>>doOneCycle
MorphicRenderLoop>>doOneCycle
MorphicRenderLoop>>doOneCycleWhile:
[ MorphicRenderLoop new doOneCycleWhile: [ true ] ] in MorphicUIManager>>spawnNewProcess
[self value.
			"IMPORTANT: Do not step over next line of code. See method comments for details"
			Processor terminateRealActive] in FullBlockClosure(BlockClosure)>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
Instance of RSBox did not understand #center
13 November 2023 7:22:17.494764 pm

VM: Mac OS - arm64 - 1000 - CoInterpreter VMMaker-tonel.1 uuid: 902dd483-c0c4-0d00-86f2-0f880df24b96 Oct 23 2023
StackToRegisterMappingCogit VMMaker-tonel.1 uuid: 902dd483-c0c4-0d00-86f2-0f880df24b96 Oct 23 2023
v10.0.8 - Commit: b323c5fb - Date: 2023-10-20 16:02:07 -0400

Image: Pharo11.0.0 [Build information: Pharo-11.0.0+build.710.sha.ea28d8552cac85a7ce1e9c34ab1e7bd45f7b9910 (64 Bit)]

RSBox(Object)>>doesNotUnderstand: #center
	Receiver: a RSBox
	Arguments and temporary variables: 
		aMessage: 	center
		exception: 	Instance of RSBox did not understand #center
		resumeValue: 	nil
	Receiver's instance variables: 
		announcer: 	nil
		properties: 	nil
		paint: 	Color blue
		path: 	(-10.0@ -10.0) corner: (10.0@10.0)
		border: 	nil
		parent: 	a RSCanvas
		isFixed: 	false
		encompassingRectangle: 	nil
		model: 	nil
		baseRectangle: 	(-10.0@ -10.0) corner: (10.0@10.0)
		matrix: 	x: 0.0 y: 0.0 sx: 1.0 sy: 1.0 shx: 0.0 shy: 0.0
		connectedLines: 	nil
		shouldUpdateLines: 	true
		cornerRadius: 	nil


[ :edgeDict |
        | edge sourceNode targetNode |
        sourceNode := nodesMap at: (edgeDict at: #source) ifAbsent: [ nil ].
        targetNode := nodesMap at: (edgeDict at: #target) ifAbsent: [ nil ].
        sourceNode ifNotNil: [ targetNode ifNotNil: [
            edge := RSLine new.
            edge start: sourceNode center; end: targetNode center.
            canvas add: edge.
        ]].
    ] in GraphVisualizer>>createEdges
	Receiver: a GraphVisualizer
	Arguments and temporary variables: 
		edgeDict: 	a Dictionary('source'->1 'target'->2 'type'->'FRIENDS_WITH' )
		edge: 	a RSLine
		sourceNode: 	a RSBox
		targetNode: 	a RSBox
	Receiver's instance variables: 
		view: 	nil
		nodes: 	an Array(a Dictionary('id'->1 'label'->'Person' 'properties'->a Dict[..]
		edges: 	an Array(a Dictionary('source'->1 'target'->2 'type'->'FRIENDS_WITH' ))
		nodesMap: 	a Dictionary(1->a RSBox 2->a RSBox )
		canvas: 	a RSCanvas


Array(SequenceableCollection)>>do:
	Receiver: an Array(a Dictionary('source'->1 'target'->2 'type'->'FRIENDS_WITH' ))
	Arguments and temporary variables: 
		aBlock: 	[ :edgeDict |
        | edge sourceNode targetNode |
        source[..]
		index: 	1
	Receiver's instance variables: 
an Array(a Dictionary('source'->1 'target'->2 'type'->'FRIENDS_WITH' ))

GraphVisualizer>>createEdges
	Receiver: a GraphVisualizer
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		view: 	nil
		nodes: 	an Array(a Dictionary('id'->1 'label'->'Person' 'properties'->a Dict[..]
		edges: 	an Array(a Dictionary('source'->1 'target'->2 'type'->'FRIENDS_WITH' ))
		nodesMap: 	a Dictionary(1->a RSBox 2->a RSBox )
		canvas: 	a RSCanvas


GraphVisualizer>>visualizeGraphFromFile:
	Receiver: a GraphVisualizer
	Arguments and temporary variables: 
		aFilePath: 	'/Users/ryanperez/Documents/GitHub/pp-rep2533/project/src/data/t[..]
	Receiver's instance variables: 
		view: 	nil
		nodes: 	an Array(a Dictionary('id'->1 'label'->'Person' 'properties'->a Dict[..]
		edges: 	an Array(a Dictionary('source'->1 'target'->2 'type'->'FRIENDS_WITH' ))
		nodesMap: 	a Dictionary(1->a RSBox 2->a RSBox )
		canvas: 	a RSCanvas


UndefinedObject>>DoIt
	Receiver: nil
	Arguments and temporary variables: 
		visualizer: 	a GraphVisualizer
	Receiver's instance variables: 
nil

OCReceiverDoItSemanticScope(OCDoItSemanticScope)>>evaluateDoIt:
	Receiver: an OCReceiverDoItSemanticScope
	Arguments and temporary variables: 
		doItMethod: 	UndefinedObject>>#DoIt
	Receiver's instance variables: 
		outerScope: 	nil
		targetReceiver: 	nil


OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
		doItMethod: 	UndefinedObject>>#DoIt
	Receiver's instance variables: 
		ast: 	DoIt

	| visualizer |
	visualizer := GraphVisualizer new.
	^ visualize[..]
		source: 	a ReadStream
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil


[
		self announcer announce: (SpCodeWillBeEvaluatedAnnouncement newContent: aString).
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionModel doItReceiver.
		result := receiver class compiler
			source: aString;
			context: self interactionModel doItContext;
			receiver: self interactionModel doItReceiver;
			requestor: self interactionModel;
			environment: self environment;
			failBlock:  [ 
				self announcer announce: (SpCodeEvaluationFailedAnnouncement newContent: aString).
				^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		self announcer announce: (SpCodeEvaluationSucceedAnnouncement newContent: aString).
		result ] in SpCodePresenter>>evaluate:onCompileError:onError:
	Receiver: a SpCodePresenter
	Arguments and temporary variables: 
		aString: 	'| visualizer |
visualizer := GraphVisualizer new.
visualizer visu[..]
		compileErrorBlock: 	[ ^ self ]
		errorBlock: 	[ :e | e pass ]
		receiver: 	nil
		result: 	nil
		oldBindings: 	a Dictionary()
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicCodeAdapter)
		announcer: 	an Announcer
		owner: 	a StPlaygroundPagePresenter
		adapter: 	a SpMorphicCodeAdapter
		needRebuild: 	true
		eventHandler: 	a SpEventHandler
		application: 	nil
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ a KMCategory ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Code' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpAbstractWidgetLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		borderWidth: 	an ObservableValueHolder[ nil ]
		borderColor: 	an ObservableValueHolder[ nil ]
		dragEnabled: 	an ObservableValueHolder[ false ]
		dropEnabled: 	an ObservableValueHolder[ false ]
		color: 	an ObservableValueHolder[ nil ]
		help: 	an ObservableValueHolder[ nil ]
		enabled: 	an ObservableValueHolder[ true ]
		wantsDrop: 	an ObservableValueHolder[ [ :transfer | self dropEnabled ] ]
		acceptDrop: 	an ObservableValueHolder[ [ :transfer | ] ]
		deferredActions: 	nil
		hasUnacceptedEdits: 	an ObservableValueHolder[ false ]
		selection: 	an ObservableValueHolder[ (1 to: 159) ]
		wantsVisualFeedback: 	an ObservableValueHolder[ true ]
		askBeforeDiscardingEdits: 	an ObservableValueHolder[ true ]
		text: 	an ObservableValueHolder[ '| visualizer |
visualizer := GraphVisualiz[..]
		actionToPerform: 	an ObservableValueHolder[ [ :txt |  ] ]
		readSelection: 	an ObservableValueHolder[ [ selection ] ]
		placeholder: 	an ObservableValueHolder[ '' ]
		contextMenu: 	an ObservableValueHolder[ [ (self menuActionsFor: text) asMenu[..]
		scrollValue: 	an ObservableValueHolder[ (0@0) ]
		editionContextMenu: 	an ObservableValueHolder[ true ]
		editable: 	an ObservableValueHolder[ true ]
		wrapWord: 	an ObservableValueHolder[ true ]
		undoRedoHistory: 	true
		wrapScrollBars: 	true
		propagateNaturalHeight: 	false
		propagateNaturalWidth: 	false
		scrollBarStyles: 	#()
		syntaxHighlight: 	an ObservableValueHolder[ true ]
		smartCharacters: 	an ObservableValueHolder[ true ]
		lineNumbers: 	an ObservableValueHolder[ true ]
		interactionModel: 	an ObservableValueHolder[ a StPlaygroundInteractionModel ]
		overrideContextMenu: 	true
		submitBlock: 	nil
		resetBlock: 	nil
		environment: 	nil
		systemNavigation: 	nil
		syntaxHighlightTheme: 	an ObservableValueHolder[ nil ]


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
		self announcer announce: (SpCodeWillBeEvaluatedAnnouncement newContent: aString).
[..]
	Arguments and temporary variables: 
		exception: 	Error
		handlerAction: 	[ :e |
		self announcer announce: (SpCodeEvaluationFailedAnn[..]
	Receiver's instance variables: 
		outerContext: 	SpCodePresenter>>evaluate:onCompileError:onError:
		compiledBlock: 	a CompiledBlock: [
		self announcer announce: (SpCodeWillBeE[..]
		numArgs: 	0
		receiver: 	a SpCodePresenter


SpCodePresenter>>evaluate:onCompileError:onError:
	Receiver: a SpCodePresenter
	Arguments and temporary variables: 
		receiver: 	nil
		result: 	nil
		oldBindings: 	a Dictionary()
		aString: 	'| visualizer |
visualizer := GraphVisualizer new.
visualizer visu[..]
		compileErrorBlock: 	[ ^ self ]
		errorBlock: 	[ :e | e pass ]
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicCodeAdapter)
		announcer: 	an Announcer
		owner: 	a StPlaygroundPagePresenter
		adapter: 	a SpMorphicCodeAdapter
		needRebuild: 	true
		eventHandler: 	a SpEventHandler
		application: 	nil
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ a KMCategory ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Code' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpAbstractWidgetLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		borderWidth: 	an ObservableValueHolder[ nil ]
		borderColor: 	an ObservableValueHolder[ nil ]
		dragEnabled: 	an ObservableValueHolder[ false ]
		dropEnabled: 	an ObservableValueHolder[ false ]
		color: 	an ObservableValueHolder[ nil ]
		help: 	an ObservableValueHolder[ nil ]
		enabled: 	an ObservableValueHolder[ true ]
		wantsDrop: 	an ObservableValueHolder[ [ :transfer | self dropEnabled ] ]
		acceptDrop: 	an ObservableValueHolder[ [ :transfer | ] ]
		deferredActions: 	nil
		hasUnacceptedEdits: 	an ObservableValueHolder[ false ]
		selection: 	an ObservableValueHolder[ (1 to: 159) ]
		wantsVisualFeedback: 	an ObservableValueHolder[ true ]
		askBeforeDiscardingEdits: 	an ObservableValueHolder[ true ]
		text: 	an ObservableValueHolder[ '| visualizer |
visualizer := GraphVisualiz[..]
		actionToPerform: 	an ObservableValueHolder[ [ :txt |  ] ]
		readSelection: 	an ObservableValueHolder[ [ selection ] ]
		placeholder: 	an ObservableValueHolder[ '' ]
		contextMenu: 	an ObservableValueHolder[ [ (self menuActionsFor: text) asMenu[..]
		scrollValue: 	an ObservableValueHolder[ (0@0) ]
		editionContextMenu: 	an ObservableValueHolder[ true ]
		editable: 	an ObservableValueHolder[ true ]
		wrapWord: 	an ObservableValueHolder[ true ]
		undoRedoHistory: 	true
		wrapScrollBars: 	true
		propagateNaturalHeight: 	false
		propagateNaturalWidth: 	false
		scrollBarStyles: 	#()
		syntaxHighlight: 	an ObservableValueHolder[ true ]
		smartCharacters: 	an ObservableValueHolder[ true ]
		lineNumbers: 	an ObservableValueHolder[ true ]
		interactionModel: 	an ObservableValueHolder[ a StPlaygroundInteractionModel ]
		overrideContextMenu: 	true
		submitBlock: 	nil
		resetBlock: 	nil
		environment: 	nil
		systemNavigation: 	nil
		syntaxHighlightTheme: 	an ObservableValueHolder[ nil ]


StPlaygroundPagePresenter>>doEvaluateAndGo
	Receiver: a StPlaygroundPagePresenter
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicBoxAdapter)
		announcer: 	an Announcer
		owner: 	a SpMillerColumnPresenter
		adapter: 	a SpMorphicBoxAdapter
		needRebuild: 	true
		eventHandler: 	nil
		application: 	a StPharoApplication
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ nil ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Untitled window' ]
		additionalSubpresentersMap: 	a Dictionary()
		layout: 	an ObservableValueHolder[ a SpBoxLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		text: 	a SpCodePresenter
		toolbar: 	a SpToolbarPresenter
		statusbar: 	a SpPresenter
		lineLabel: 	a SpLabelPresenter
		toggleLineNumberButton: 	a SpToggleButtonPresenter
		page: 	a StPlaygroundPage
		activationBlock: 	[ :selection |
		self changeSelection: selection from: new[..]


StPlaygroundPagePresenter>>doEvaluateAllAndGo
	Receiver: a StPlaygroundPagePresenter
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicBoxAdapter)
		announcer: 	an Announcer
		owner: 	a SpMillerColumnPresenter
		adapter: 	a SpMorphicBoxAdapter
		needRebuild: 	true
		eventHandler: 	nil
		application: 	a StPharoApplication
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ nil ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Untitled window' ]
		additionalSubpresentersMap: 	a Dictionary()
		layout: 	an ObservableValueHolder[ a SpBoxLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		text: 	a SpCodePresenter
		toolbar: 	a SpToolbarPresenter
		statusbar: 	a SpPresenter
		lineLabel: 	a SpLabelPresenter
		toggleLineNumberButton: 	a SpToggleButtonPresenter
		page: 	a StPlaygroundPage
		activationBlock: 	[ :selection |
		self changeSelection: selection from: new[..]


StPlaygroundDoItCommand>>execute
	Receiver: a StPlaygroundDoItCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		context: 	a StPlaygroundPagePresenter
		basicName: 	'Do it'
		basicDescription: 	'Do it all and inspect.'


SpCommand(CmCommandDecorator)>>execute
	Receiver: a SpCommand(Do it)
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a StPlaygroundDoItCommand
		iconProvider: 	a StPharoApplication
		iconName: 	#glamorousGo
		shortcutKey: 	nil
		displayStrategy: 	a CmUIDisableWhenCantBeRun
		positionStrategy: 	a CmUILeftPositionStrategy
		buildPresenterBlock: 	[ :specCommand | 
			aButtonClass new
				label: specC[..]
		presenter: 	a SpToolbarButtonPresenter


[ specCommand execute ] in [ :specCommand | 
			aButtonClass new
				label: specCommand name;
				help: specCommand description;
				in: [ :button | 
					specCommand hasIcon
						ifTrue: [ button icon: specCommand icon ] ];
				action: [ specCommand execute ];
				yourself ] in SpCommand>>configureAsButtonOfClass:
	Receiver: a SpCommand(Do it)
	Arguments and temporary variables: 
		aButtonClass: 	nil
		specCommand: 	a SpCommand(Do it)
	Receiver's instance variables: 
		decoratedCommand: 	a StPlaygroundDoItCommand
		iconProvider: 	a StPharoApplication
		iconName: 	#glamorousGo
		shortcutKey: 	nil
		displayStrategy: 	a CmUIDisableWhenCantBeRun
		positionStrategy: 	a CmUILeftPositionStrategy
		buildPresenterBlock: 	[ :specCommand | 
			aButtonClass new
				label: specC[..]
		presenter: 	a SpToolbarButtonPresenter


FullBlockClosure(BlockClosure)>>cull:
	Receiver: [ specCommand execute ]
	Arguments and temporary variables: 
		anArg: 	a SpToolbarButtonPresenter
	Receiver's instance variables: 
		outerContext: 	[ :specCommand | 
			aButtonClass new
				label: specCommand [..]
		compiledBlock: 	a CompiledBlock: [ specCommand execute ]
		numArgs: 	0
		receiver: 	a SpCommand(Do it)


SpMorphicToolbarButtonAdapter>>execute
	Receiver: a SpMorphicToolbarButtonAdapter
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpToolbarButtonMorph(163457024))
		announcer: 	nil
		model: 	a SpToolbarButtonPresenter
		widget: 	a SpToolbarButtonMorph(163457024)
		selector: 	nil
		owner: 	a SpToolbarButtonPresenter
		unsubscribed: 	false


SpToolbarButtonMorph(PluggableButtonMorph)>>performAction:
	Receiver: a SpToolbarButtonMorph(163457024)
	Arguments and temporary variables: 
		event: 	[(13.0@26.0) mouseUp 11855589 nil]
	Receiver's instance variables: 
		bounds: 	(0.0@5.0) corner: (45.0@39.0)
		owner: 	a Morph(543889152)
		submorphs: 	an Array(an AlignmentMorph(1048008448))
		fullBounds: 	nil
		color: 	(Color r: 0.9012707722385142 g: 0.9012707722385142 b: 0.901270772238[..]
		extension: 	a MorphExtension (606190080) [balloonText]  [other:  (presenter [..]
		borderWidth: 	0
		borderColor: 	#simple
		model: 	a SpMorphicToolbarButtonAdapter
		label: 	'Do it'
		icon: 	Form(13x13x32)
		getIconSelector: 	#icon
		getStateSelector: 	#state
		actionSelector: 	#execute
		font: 	a LogicalFont
 familyName: 'Source Sans Pro'
 emphasis: nil
 pointSiz[..]
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	nil
		getFontSelector: 	nil
		labelMorph: 	a LabelMorph(576130816)'Do it'
		iconMorph: 	an ImageMorph(527603200)
		iconPosition: 	#top
		lastState: 	false
		badgeFont: 	nil
		badgeSelector: 	#badge


[:m |
		(m containsPoint: evt cursorPoint) ifTrue: [m enabled ifTrue: [ m performAction: evt ]]] in SpToolbarButtonMorph(PluggableButtonMorph)>>mouseUp:
	Receiver: a SpToolbarButtonMorph(163457024)
	Arguments and temporary variables: 
		evt: 	[(13.0@26.0) mouseUp 11855589 nil]
		all: 	an Array(a SpToolbarButtonMorph(163457024) a SpToolbarButtonMorph(6416[..]
		m: 	a SpToolbarButtonMorph(163457024)
	Receiver's instance variables: 
		bounds: 	(0.0@5.0) corner: (45.0@39.0)
		owner: 	a Morph(543889152)
		submorphs: 	an Array(an AlignmentMorph(1048008448))
		fullBounds: 	nil
		color: 	(Color r: 0.9012707722385142 g: 0.9012707722385142 b: 0.901270772238[..]
		extension: 	a MorphExtension (606190080) [balloonText]  [other:  (presenter [..]
		borderWidth: 	0
		borderColor: 	#simple
		model: 	a SpMorphicToolbarButtonAdapter
		label: 	'Do it'
		icon: 	Form(13x13x32)
		getIconSelector: 	#icon
		getStateSelector: 	#state
		actionSelector: 	#execute
		font: 	a LogicalFont
 familyName: 'Source Sans Pro'
 emphasis: nil
 pointSiz[..]
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	nil
		getFontSelector: 	nil
		labelMorph: 	a LabelMorph(576130816)'Do it'
		iconMorph: 	an ImageMorph(527603200)
		iconPosition: 	#top
		lastState: 	false
		badgeFont: 	nil
		badgeSelector: 	#badge


Array(SequenceableCollection)>>do:
	Receiver: an Array(a SpToolbarButtonMorph(163457024) a SpToolbarButtonMorph(641645312) a SpToolb[..]
	Arguments and temporary variables: 
		aBlock: 	[:m |
		(m containsPoint: evt cursorPoint) ifTrue: [m enabled ifTru[..]
		index: 	1
	Receiver's instance variables: 
an Array(a SpToolbarButtonMorph(163457024) a SpToolbarButtonMorph(641645312) a SpToolb[..]

SpToolbarButtonMorph(PluggableButtonMorph)>>mouseUp:
	Receiver: a SpToolbarButtonMorph(163457024)
	Arguments and temporary variables: 
		evt: 	[(13.0@26.0) mouseUp 11855589 nil]
		all: 	an Array(a SpToolbarButtonMorph(163457024) a SpToolbarButtonMorph(6416[..]
	Receiver's instance variables: 
		bounds: 	(0.0@5.0) corner: (45.0@39.0)
		owner: 	a Morph(543889152)
		submorphs: 	an Array(an AlignmentMorph(1048008448))
		fullBounds: 	nil
		color: 	(Color r: 0.9012707722385142 g: 0.9012707722385142 b: 0.901270772238[..]
		extension: 	a MorphExtension (606190080) [balloonText]  [other:  (presenter [..]
		borderWidth: 	0
		borderColor: 	#simple
		model: 	a SpMorphicToolbarButtonAdapter
		label: 	'Do it'
		icon: 	Form(13x13x32)
		getIconSelector: 	#icon
		getStateSelector: 	#state
		actionSelector: 	#execute
		font: 	a LogicalFont
 familyName: 'Source Sans Pro'
 emphasis: nil
 pointSiz[..]
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	nil
		getFontSelector: 	nil
		labelMorph: 	a LabelMorph(576130816)'Do it'
		iconMorph: 	an ImageMorph(527603200)
		iconPosition: 	#top
		lastState: 	false
		badgeFont: 	nil
		badgeSelector: 	#badge


SpToolbarButtonMorph(Morph)>>handleMouseUp:
	Receiver: a SpToolbarButtonMorph(163457024)
	Arguments and temporary variables: 
		anEvent: 	[(13.0@26.0) mouseUp 11855589 nil]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(0.0@5.0) corner: (45.0@39.0)
		owner: 	a Morph(543889152)
		submorphs: 	an Array(an AlignmentMorph(1048008448))
		fullBounds: 	nil
		color: 	(Color r: 0.9012707722385142 g: 0.9012707722385142 b: 0.901270772238[..]
		extension: 	a MorphExtension (606190080) [balloonText]  [other:  (presenter [..]
		borderWidth: 	0
		borderColor: 	#simple
		model: 	a SpMorphicToolbarButtonAdapter
		label: 	'Do it'
		icon: 	Form(13x13x32)
		getIconSelector: 	#icon
		getStateSelector: 	#state
		actionSelector: 	#execute
		font: 	a LogicalFont
 familyName: 'Source Sans Pro'
 emphasis: nil
 pointSiz[..]
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	nil
		getFontSelector: 	nil
		labelMorph: 	a LabelMorph(576130816)'Do it'
		iconMorph: 	an ImageMorph(527603200)
		iconPosition: 	#top
		lastState: 	false
		badgeFont: 	nil
		badgeSelector: 	#badge


MouseButtonEvent>>sentTo:
	Receiver: [(13.0@26.0) mouseUp 11855589 nil]
	Arguments and temporary variables: 
		anObject: 	a SpToolbarButtonMorph(163457024)
	Receiver's instance variables: 
		timeStamp: 	11855589
		source: 	a HandMorph(337424384)
		windowIndex: 	nil
		type: 	#mouseUp
		buttons: 	0
		position: 	(13.0@26.0)
		handler: 	nil
		wasHandled: 	true
		whichButton: 	4


SpToolbarButtonMorph(Morph)>>handleEvent:
	Receiver: a SpToolbarButtonMorph(163457024)
	Arguments and temporary variables: 
		anEvent: 	[(13.0@26.0) mouseUp 11855589 nil]
	Receiver's instance variables: 
		bounds: 	(0.0@5.0) corner: (45.0@39.0)
		owner: 	a Morph(543889152)
		submorphs: 	an Array(an AlignmentMorph(1048008448))
		fullBounds: 	nil
		color: 	(Color r: 0.9012707722385142 g: 0.9012707722385142 b: 0.901270772238[..]
		extension: 	a MorphExtension (606190080) [balloonText]  [other:  (presenter [..]
		borderWidth: 	0
		borderColor: 	#simple
		model: 	a SpMorphicToolbarButtonAdapter
		label: 	'Do it'
		icon: 	Form(13x13x32)
		getIconSelector: 	#icon
		getStateSelector: 	#state
		actionSelector: 	#execute
		font: 	a LogicalFont
 familyName: 'Source Sans Pro'
 emphasis: nil
 pointSiz[..]
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	nil
		getFontSelector: 	nil
		labelMorph: 	a LabelMorph(576130816)'Do it'
		iconMorph: 	an ImageMorph(527603200)
		iconPosition: 	#top
		lastState: 	false
		badgeFont: 	nil
		badgeSelector: 	#badge


SpToolbarButtonMorph(Morph)>>handleFocusEvent:
	Receiver: a SpToolbarButtonMorph(163457024)
	Arguments and temporary variables: 
		anEvent: 	[(13.0@26.0) mouseUp 11855589 nil]
	Receiver's instance variables: 
		bounds: 	(0.0@5.0) corner: (45.0@39.0)
		owner: 	a Morph(543889152)
		submorphs: 	an Array(an AlignmentMorph(1048008448))
		fullBounds: 	nil
		color: 	(Color r: 0.9012707722385142 g: 0.9012707722385142 b: 0.901270772238[..]
		extension: 	a MorphExtension (606190080) [balloonText]  [other:  (presenter [..]
		borderWidth: 	0
		borderColor: 	#simple
		model: 	a SpMorphicToolbarButtonAdapter
		label: 	'Do it'
		icon: 	Form(13x13x32)
		getIconSelector: 	#icon
		getStateSelector: 	#state
		actionSelector: 	#execute
		font: 	a LogicalFont
 familyName: 'Source Sans Pro'
 emphasis: nil
 pointSiz[..]
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	nil
		getFontSelector: 	nil
		labelMorph: 	a LabelMorph(576130816)'Do it'
		iconMorph: 	an ImageMorph(527603200)
		iconPosition: 	#top
		lastState: 	false
		badgeFont: 	nil
		badgeSelector: 	#badge


[
		result := focusHolder handleFocusEvent: transformedEvent.
	] in HandMorph>>sendFocusEvent:to:clear:
	Receiver: a HandMorph(337424384)
	Arguments and temporary variables: 
		anEvent: 	[(468@214) mouseUp 11855589 nil]
		focusHolder: 	a SpToolbarButtonMorph(163457024)
		aBlock: 	[self mouseFocus: nil]
		w: 	a WorldMorph(341720576) [world]
		transformedEvent: 	[(13.0@26.0) mouseUp 11855589 nil]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(468@214.0) corner: (484@230.0)
		owner: 	a WorldMorph(341720576) [world]
		submorphs: 	#()
		fullBounds: 	(468@214.0) corner: (484@230.0)
		color: 	Color blue
		extension: 	a MorphExtension (370611968)
		mouseFocus: 	nil
		keyboardFocus: 	a RubEditingArea(143191808)
		eventListeners: 	nil
		mouseListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(468@214) mouseUp 11855589 nil]
		targetOffset: 	(13.0@21.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 0 0 0 0 0 nil nil)
		captureBlock: 	nil
		recentModifiers: 	0
		pendingEventQueue: 	WaitfreeQueue with 0 items
		supressNextKeyPress: 	false


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
		result := focusHolder handleFocusEvent: transformedEvent.
	]
	Arguments and temporary variables: 
		exception: 	Error
		handlerAction: 	[ :ex |
			ActiveWorld := priorWorld.
			ex pass ]
	Receiver's instance variables: 
		outerContext: 	HandMorph>>sendFocusEvent:to:clear:
		compiledBlock: 	a CompiledBlock: [
		result := focusHolder handleFocusEvent:[..]
		numArgs: 	0
		receiver: 	a HandMorph(337424384)


WorldMorph>>becomeActiveDuring:
	Receiver: a WorldMorph(341720576) [world]
	Arguments and temporary variables: 
		aBlock: 	[
		result := focusHolder handleFocusEvent: transformedEvent.
	]
		priorWorld: 	a WorldMorph(341720576) [world]
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1728@1080)
		owner: 	nil
		submorphs: 	an Array(a MenubarMorph(112886016) a TaskbarMorph(279458560) a S[..]
		fullBounds: 	(0@0) corner: (1728@1080)
		color: 	(Color r: 0.9403714565004888 g: 0.9403714565004888 b: 0.940371456500[..]
		extension: 	a MorphExtension (1012946432) [other:  (dragEnabled -> true) (dr[..]
		borderWidth: 	0
		borderColor: 	(Color r: 0.8611925708699902 g: 1.0 b: 0.7223851417399805 alph[..]
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil


HandMorph>>sendFocusEvent:to:clear:
	Receiver: a HandMorph(337424384)
	Arguments and temporary variables: 
		result: 	nil
		anEvent: 	[(468@214) mouseUp 11855589 nil]
		focusHolder: 	a SpToolbarButtonMorph(163457024)
		aBlock: 	[self mouseFocus: nil]
		w: 	a WorldMorph(341720576) [world]
		transformedEvent: 	[(13.0@26.0) mouseUp 11855589 nil]
	Receiver's instance variables: 
		bounds: 	(468@214.0) corner: (484@230.0)
		owner: 	a WorldMorph(341720576) [world]
		submorphs: 	#()
		fullBounds: 	(468@214.0) corner: (484@230.0)
		color: 	Color blue
		extension: 	a MorphExtension (370611968)
		mouseFocus: 	nil
		keyboardFocus: 	a RubEditingArea(143191808)
		eventListeners: 	nil
		mouseListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(468@214) mouseUp 11855589 nil]
		targetOffset: 	(13.0@21.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 0 0 0 0 0 nil nil)
		captureBlock: 	nil
		recentModifiers: 	0
		pendingEventQueue: 	WaitfreeQueue with 0 items
		supressNextKeyPress: 	false


HandMorph>>sendEvent:focus:clear:
	Receiver: a HandMorph(337424384)
	Arguments and temporary variables: 
		anEvent: 	[(468@214) mouseUp 11855589 nil]
		focusHolder: 	a SpToolbarButtonMorph(163457024)
		aBlock: 	[self mouseFocus: nil]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(468@214.0) corner: (484@230.0)
		owner: 	a WorldMorph(341720576) [world]
		submorphs: 	#()
		fullBounds: 	(468@214.0) corner: (484@230.0)
		color: 	Color blue
		extension: 	a MorphExtension (370611968)
		mouseFocus: 	nil
		keyboardFocus: 	a RubEditingArea(143191808)
		eventListeners: 	nil
		mouseListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(468@214) mouseUp 11855589 nil]
		targetOffset: 	(13.0@21.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 0 0 0 0 0 nil nil)
		captureBlock: 	nil
		recentModifiers: 	0
		pendingEventQueue: 	WaitfreeQueue with 0 items
		supressNextKeyPress: 	false


HandMorph>>sendMouseEvent:
	Receiver: a HandMorph(337424384)
	Arguments and temporary variables: 
		anEvent: 	[(468@214) mouseUp 11855589 nil]
	Receiver's instance variables: 
		bounds: 	(468@214.0) corner: (484@230.0)
		owner: 	a WorldMorph(341720576) [world]
		submorphs: 	#()
		fullBounds: 	(468@214.0) corner: (484@230.0)
		color: 	Color blue
		extension: 	a MorphExtension (370611968)
		mouseFocus: 	nil
		keyboardFocus: 	a RubEditingArea(143191808)
		eventListeners: 	nil
		mouseListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(468@214) mouseUp 11855589 nil]
		targetOffset: 	(13.0@21.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 0 0 0 0 0 nil nil)
		captureBlock: 	nil
		recentModifiers: 	0
		pendingEventQueue: 	WaitfreeQueue with 0 items
		supressNextKeyPress: 	false


HandMorph>>handleEvent:
	Receiver: a HandMorph(337424384)
	Arguments and temporary variables: 
		anEvent: 	[(468@214) mouseUp 11855589 nil]
		evt: 	[(468@214) mouseUp 11855589 nil]
	Receiver's instance variables: 
		bounds: 	(468@214.0) corner: (484@230.0)
		owner: 	a WorldMorph(341720576) [world]
		submorphs: 	#()
		fullBounds: 	(468@214.0) corner: (484@230.0)
		color: 	Color blue
		extension: 	a MorphExtension (370611968)
		mouseFocus: 	nil
		keyboardFocus: 	a RubEditingArea(143191808)
		eventListeners: 	nil
		mouseListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(468@214) mouseUp 11855589 nil]
		targetOffset: 	(13.0@21.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 0 0 0 0 0 nil nil)
		captureBlock: 	nil
		recentModifiers: 	0
		pendingEventQueue: 	WaitfreeQueue with 0 items
		supressNextKeyPress: 	false


[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil ]) ifTrue: [
			morphicWorld activeHand handleEvent: anEvent
		]
	] in OSWindowMorphicEventHandler>>dispatchMorphicEvent:
	Receiver: an OSWindowMorphicEventHandler
	Arguments and temporary variables: 
		anEvent: 	[(468@214) mouseUp 11855589 nil]
	Receiver's instance variables: 
		morphicWorld: 	a WorldMorph(341720576) [world]


WorldState>>runStepMethodsIn:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(341720576) [world]
		queue: 	WaitfreeQueue with 0 items
		nextInQueue: 	[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNo[..]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(337424384))
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap()
		lastStepTime: 	11852264
		lastStepMessage: 	nil
		alarms: 	a Heap(MorphicAlarm(#hideShow -> a RubCursor(27124480)))
		lastAlarmTime: 	11855582
		activeHand: 	a HandMorph(337424384)
		currentCursor: 	((CursorWithMask
	extent: (16@16)
	depth: 1
	fromArray: #(
	[..]
		worldRenderer: 	an OSWorldRenderer
		realWindowExtent: 	(1728@1080)
		deferredUIMessages: 	WaitfreeQueue with 0 items


WorldMorph>>runStepMethods
	Receiver: a WorldMorph(341720576) [world]
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1728@1080)
		owner: 	nil
		submorphs: 	an Array(a MenubarMorph(112886016) a TaskbarMorph(279458560) a S[..]
		fullBounds: 	(0@0) corner: (1728@1080)
		color: 	(Color r: 0.9403714565004888 g: 0.9403714565004888 b: 0.940371456500[..]
		extension: 	a MorphExtension (1012946432) [other:  (dragEnabled -> true) (dr[..]
		borderWidth: 	0
		borderColor: 	(Color r: 0.8611925708699902 g: 1.0 b: 0.7223851417399805 alph[..]
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil


WorldState>>doOneCycleFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(341720576) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(337424384))
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap()
		lastStepTime: 	11852264
		lastStepMessage: 	nil
		alarms: 	a Heap(MorphicAlarm(#hideShow -> a RubCursor(27124480)))
		lastAlarmTime: 	11855582
		activeHand: 	a HandMorph(337424384)
		currentCursor: 	((CursorWithMask
	extent: (16@16)
	depth: 1
	fromArray: #(
	[..]
		worldRenderer: 	an OSWorldRenderer
		realWindowExtent: 	(1728@1080)
		deferredUIMessages: 	WaitfreeQueue with 0 items


WorldMorph>>doOneCycleNow
	Receiver: a WorldMorph(341720576) [world]
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1728@1080)
		owner: 	nil
		submorphs: 	an Array(a MenubarMorph(112886016) a TaskbarMorph(279458560) a S[..]
		fullBounds: 	(0@0) corner: (1728@1080)
		color: 	(Color r: 0.9403714565004888 g: 0.9403714565004888 b: 0.940371456500[..]
		extension: 	a MorphExtension (1012946432) [other:  (dragEnabled -> true) (dr[..]
		borderWidth: 	0
		borderColor: 	(Color r: 0.8611925708699902 g: 1.0 b: 0.7223851417399805 alph[..]
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil


WorldMorph>>doOneCycle
	Receiver: a WorldMorph(341720576) [world]
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1728@1080)
		owner: 	nil
		submorphs: 	an Array(a MenubarMorph(112886016) a TaskbarMorph(279458560) a S[..]
		fullBounds: 	(0@0) corner: (1728@1080)
		color: 	(Color r: 0.9403714565004888 g: 0.9403714565004888 b: 0.940371456500[..]
		extension: 	a MorphExtension (1012946432) [other:  (dragEnabled -> true) (dr[..]
		borderWidth: 	0
		borderColor: 	(Color r: 0.8611925708699902 g: 1.0 b: 0.7223851417399805 alph[..]
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil



--- The full stack ---
RSBox(Object)>>doesNotUnderstand: #center
[ :edgeDict |
        | edge sourceNode targetNode |
        sourceNode := nodesMap at: (edgeDict at: #source) ifAbsent: [ nil ].
        targetNode := nodesMap at: (edgeDict at: #target) ifAbsent: [ nil ].
        sourceNode ifNotNil: [ targetNode ifNotNil: [
            edge := RSLine new.
            edge start: sourceNode center; end: targetNode center.
            canvas add: edge.
        ]].
    ] in GraphVisualizer>>createEdges
Array(SequenceableCollection)>>do:
GraphVisualizer>>createEdges
GraphVisualizer>>visualizeGraphFromFile:
UndefinedObject>>DoIt
OCReceiverDoItSemanticScope(OCDoItSemanticScope)>>evaluateDoIt:
OpalCompiler>>evaluate
[
		self announcer announce: (SpCodeWillBeEvaluatedAnnouncement newContent: aString).
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionModel doItReceiver.
		result := receiver class compiler
			source: aString;
			context: self interactionModel doItContext;
			receiver: self interactionModel doItReceiver;
			requestor: self interactionModel;
			environment: self environment;
			failBlock:  [ 
				self announcer announce: (SpCodeEvaluationFailedAnnouncement newContent: aString).
				^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		self announcer announce: (SpCodeEvaluationSucceedAnnouncement newContent: aString).
		result ] in SpCodePresenter>>evaluate:onCompileError:onError:
FullBlockClosure(BlockClosure)>>on:do:
SpCodePresenter>>evaluate:onCompileError:onError:
StPlaygroundPagePresenter>>doEvaluateAndGo
StPlaygroundPagePresenter>>doEvaluateAllAndGo
StPlaygroundDoItCommand>>execute
SpCommand(CmCommandDecorator)>>execute
[ specCommand execute ] in [ :specCommand | 
			aButtonClass new
				label: specCommand name;
				help: specCommand description;
				in: [ :button | 
					specCommand hasIcon
						ifTrue: [ button icon: specCommand icon ] ];
				action: [ specCommand execute ];
				yourself ] in SpCommand>>configureAsButtonOfClass:
FullBlockClosure(BlockClosure)>>cull:
SpMorphicToolbarButtonAdapter>>execute
SpToolbarButtonMorph(PluggableButtonMorph)>>performAction:
[:m |
		(m containsPoint: evt cursorPoint) ifTrue: [m enabled ifTrue: [ m performAction: evt ]]] in SpToolbarButtonMorph(PluggableButtonMorph)>>mouseUp:
Array(SequenceableCollection)>>do:
SpToolbarButtonMorph(PluggableButtonMorph)>>mouseUp:
SpToolbarButtonMorph(Morph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
SpToolbarButtonMorph(Morph)>>handleEvent:
SpToolbarButtonMorph(Morph)>>handleFocusEvent:
[
		result := focusHolder handleFocusEvent: transformedEvent.
	] in HandMorph>>sendFocusEvent:to:clear:
FullBlockClosure(BlockClosure)>>on:do:
WorldMorph>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil ]) ifTrue: [
			morphicWorld activeHand handleEvent: anEvent
		]
	] in OSWindowMorphicEventHandler>>dispatchMorphicEvent:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycleNow
WorldMorph>>doOneCycle
 - - - - - - - - - - - - - - -
			- - - - - - - - - - - - - - - - - -
[
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMutex critical: [
			                     self extraWorldList ].
		extraWorldsToDraw do: [ :world | world doOneCycle ].

		(self currentWorld isNotNil and: [
			 (extraWorldsToDraw includes: self currentWorld) not ]) ifTrue: [
			self currentWorld doOneCycle ] ] in WorldMorph class>>doOneCycle
FullBlockClosure(BlockClosure)>>ensure:
WorldState class>>doDrawCycleWith:
WorldMorph class>>doOneCycle
MorphicRenderLoop>>doOneCycle
MorphicRenderLoop>>doOneCycleWhile:
[ MorphicRenderLoop new doOneCycleWhile: [ true ] ] in MorphicUIManager>>spawnNewProcess
[self value.
			"IMPORTANT: Do not step over next line of code. See method comments for details"
			Processor terminateRealActive] in FullBlockClosure(BlockClosure)>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
Instance of RSLine did not understand #start:
13 November 2023 7:24:44.983656 pm

VM: Mac OS - arm64 - 1000 - CoInterpreter VMMaker-tonel.1 uuid: 902dd483-c0c4-0d00-86f2-0f880df24b96 Oct 23 2023
StackToRegisterMappingCogit VMMaker-tonel.1 uuid: 902dd483-c0c4-0d00-86f2-0f880df24b96 Oct 23 2023
v10.0.8 - Commit: b323c5fb - Date: 2023-10-20 16:02:07 -0400

Image: Pharo11.0.0 [Build information: Pharo-11.0.0+build.710.sha.ea28d8552cac85a7ce1e9c34ab1e7bd45f7b9910 (64 Bit)]

RSLine(Object)>>doesNotUnderstand: #start:
	Receiver: a RSLine
	Arguments and temporary variables: 
		aMessage: 	start: (0.0@0.0)
		exception: 	Instance of RSLine did not understand #start:
		resumeValue: 	nil
	Receiver's instance variables: 
		announcer: 	nil
		properties: 	nil
		paint: 	nil
		path: 	nil
		border: 	1, Color gray
		parent: 	nil
		isFixed: 	false
		encompassingRectangle: 	nil
		model: 	nil
		attachPoint: 	a RSCenteredAttachPoint
		from: 	nil
		to: 	nil
		markers: 	nil
		startPoint: 	(0@0)
		endPoint: 	(100@100)


[ :edgeDict |
        | edge sourceNode targetNode sourcePosition targetPosition |
        sourceNode := nodesMap at: (edgeDict at: #source) ifAbsent: [ nil ].
        targetNode := nodesMap at: (edgeDict at: #target) ifAbsent: [ nil ].
        sourceNode ifNotNil: [ targetNode ifNotNil: [
            sourcePosition := sourceNode position.
            targetPosition := targetNode position.
            edge := RSLine new.
            edge start: sourcePosition; end: targetPosition.
            canvas add: edge.
        ]].
    ] in GraphVisualizer>>createEdges
	Receiver: a GraphVisualizer
	Arguments and temporary variables: 
		edgeDict: 	a Dictionary('source'->1 'target'->2 'type'->'FRIENDS_WITH' )
		edge: 	a RSLine
		sourceNode: 	a RSBox
		targetNode: 	a RSBox
		sourcePosition: 	(0.0@0.0)
		targetPosition: 	(0.0@0.0)
	Receiver's instance variables: 
		view: 	nil
		nodes: 	an Array(a Dictionary('id'->1 'label'->'Person' 'properties'->a Dict[..]
		edges: 	an Array(a Dictionary('source'->1 'target'->2 'type'->'FRIENDS_WITH' ))
		nodesMap: 	a Dictionary(1->a RSBox 2->a RSBox )
		canvas: 	a RSCanvas


Array(SequenceableCollection)>>do:
	Receiver: an Array(a Dictionary('source'->1 'target'->2 'type'->'FRIENDS_WITH' ))
	Arguments and temporary variables: 
		aBlock: 	[ :edgeDict |
        | edge sourceNode targetNode sourcePosition t[..]
		index: 	1
	Receiver's instance variables: 
an Array(a Dictionary('source'->1 'target'->2 'type'->'FRIENDS_WITH' ))

GraphVisualizer>>createEdges
	Receiver: a GraphVisualizer
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		view: 	nil
		nodes: 	an Array(a Dictionary('id'->1 'label'->'Person' 'properties'->a Dict[..]
		edges: 	an Array(a Dictionary('source'->1 'target'->2 'type'->'FRIENDS_WITH' ))
		nodesMap: 	a Dictionary(1->a RSBox 2->a RSBox )
		canvas: 	a RSCanvas


GraphVisualizer>>visualizeGraphFromFile:
	Receiver: a GraphVisualizer
	Arguments and temporary variables: 
		aFilePath: 	'/Users/ryanperez/Documents/GitHub/pp-rep2533/project/src/data/t[..]
	Receiver's instance variables: 
		view: 	nil
		nodes: 	an Array(a Dictionary('id'->1 'label'->'Person' 'properties'->a Dict[..]
		edges: 	an Array(a Dictionary('source'->1 'target'->2 'type'->'FRIENDS_WITH' ))
		nodesMap: 	a Dictionary(1->a RSBox 2->a RSBox )
		canvas: 	a RSCanvas


UndefinedObject>>DoIt
	Receiver: nil
	Arguments and temporary variables: 
		visualizer: 	a GraphVisualizer
	Receiver's instance variables: 
nil

OCReceiverDoItSemanticScope(OCDoItSemanticScope)>>evaluateDoIt:
	Receiver: an OCReceiverDoItSemanticScope
	Arguments and temporary variables: 
		doItMethod: 	UndefinedObject>>#DoIt
	Receiver's instance variables: 
		outerScope: 	nil
		targetReceiver: 	nil


OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
		doItMethod: 	UndefinedObject>>#DoIt
	Receiver's instance variables: 
		ast: 	DoIt

	| visualizer |
	visualizer := GraphVisualizer new.
	^ visualize[..]
		source: 	a ReadStream
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil


[
		self announcer announce: (SpCodeWillBeEvaluatedAnnouncement newContent: aString).
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionModel doItReceiver.
		result := receiver class compiler
			source: aString;
			context: self interactionModel doItContext;
			receiver: self interactionModel doItReceiver;
			requestor: self interactionModel;
			environment: self environment;
			failBlock:  [ 
				self announcer announce: (SpCodeEvaluationFailedAnnouncement newContent: aString).
				^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		self announcer announce: (SpCodeEvaluationSucceedAnnouncement newContent: aString).
		result ] in SpCodePresenter>>evaluate:onCompileError:onError:
	Receiver: a SpCodePresenter
	Arguments and temporary variables: 
		aString: 	'| visualizer |
visualizer := GraphVisualizer new.
visualizer visu[..]
		compileErrorBlock: 	[ ^ self ]
		errorBlock: 	[ :e | e pass ]
		receiver: 	nil
		result: 	nil
		oldBindings: 	a Dictionary()
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicCodeAdapter)
		announcer: 	an Announcer
		owner: 	a StPlaygroundPagePresenter
		adapter: 	a SpMorphicCodeAdapter
		needRebuild: 	true
		eventHandler: 	a SpEventHandler
		application: 	nil
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ a KMCategory ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Code' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpAbstractWidgetLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		borderWidth: 	an ObservableValueHolder[ nil ]
		borderColor: 	an ObservableValueHolder[ nil ]
		dragEnabled: 	an ObservableValueHolder[ false ]
		dropEnabled: 	an ObservableValueHolder[ false ]
		color: 	an ObservableValueHolder[ nil ]
		help: 	an ObservableValueHolder[ nil ]
		enabled: 	an ObservableValueHolder[ true ]
		wantsDrop: 	an ObservableValueHolder[ [ :transfer | self dropEnabled ] ]
		acceptDrop: 	an ObservableValueHolder[ [ :transfer | ] ]
		deferredActions: 	nil
		hasUnacceptedEdits: 	an ObservableValueHolder[ false ]
		selection: 	an ObservableValueHolder[ (1 to: 159) ]
		wantsVisualFeedback: 	an ObservableValueHolder[ true ]
		askBeforeDiscardingEdits: 	an ObservableValueHolder[ true ]
		text: 	an ObservableValueHolder[ '| visualizer |
visualizer := GraphVisualiz[..]
		actionToPerform: 	an ObservableValueHolder[ [ :txt |  ] ]
		readSelection: 	an ObservableValueHolder[ [ selection ] ]
		placeholder: 	an ObservableValueHolder[ '' ]
		contextMenu: 	an ObservableValueHolder[ [ (self menuActionsFor: text) asMenu[..]
		scrollValue: 	an ObservableValueHolder[ (0@0) ]
		editionContextMenu: 	an ObservableValueHolder[ true ]
		editable: 	an ObservableValueHolder[ true ]
		wrapWord: 	an ObservableValueHolder[ true ]
		undoRedoHistory: 	true
		wrapScrollBars: 	true
		propagateNaturalHeight: 	false
		propagateNaturalWidth: 	false
		scrollBarStyles: 	#()
		syntaxHighlight: 	an ObservableValueHolder[ true ]
		smartCharacters: 	an ObservableValueHolder[ true ]
		lineNumbers: 	an ObservableValueHolder[ true ]
		interactionModel: 	an ObservableValueHolder[ a StPlaygroundInteractionModel ]
		overrideContextMenu: 	true
		submitBlock: 	nil
		resetBlock: 	nil
		environment: 	nil
		systemNavigation: 	nil
		syntaxHighlightTheme: 	an ObservableValueHolder[ nil ]


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
		self announcer announce: (SpCodeWillBeEvaluatedAnnouncement newContent: aString).
[..]
	Arguments and temporary variables: 
		exception: 	Error
		handlerAction: 	[ :e |
		self announcer announce: (SpCodeEvaluationFailedAnn[..]
	Receiver's instance variables: 
		outerContext: 	SpCodePresenter>>evaluate:onCompileError:onError:
		compiledBlock: 	a CompiledBlock: [
		self announcer announce: (SpCodeWillBeE[..]
		numArgs: 	0
		receiver: 	a SpCodePresenter


SpCodePresenter>>evaluate:onCompileError:onError:
	Receiver: a SpCodePresenter
	Arguments and temporary variables: 
		receiver: 	nil
		result: 	nil
		oldBindings: 	a Dictionary()
		aString: 	'| visualizer |
visualizer := GraphVisualizer new.
visualizer visu[..]
		compileErrorBlock: 	[ ^ self ]
		errorBlock: 	[ :e | e pass ]
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicCodeAdapter)
		announcer: 	an Announcer
		owner: 	a StPlaygroundPagePresenter
		adapter: 	a SpMorphicCodeAdapter
		needRebuild: 	true
		eventHandler: 	a SpEventHandler
		application: 	nil
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ a KMCategory ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Code' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpAbstractWidgetLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		borderWidth: 	an ObservableValueHolder[ nil ]
		borderColor: 	an ObservableValueHolder[ nil ]
		dragEnabled: 	an ObservableValueHolder[ false ]
		dropEnabled: 	an ObservableValueHolder[ false ]
		color: 	an ObservableValueHolder[ nil ]
		help: 	an ObservableValueHolder[ nil ]
		enabled: 	an ObservableValueHolder[ true ]
		wantsDrop: 	an ObservableValueHolder[ [ :transfer | self dropEnabled ] ]
		acceptDrop: 	an ObservableValueHolder[ [ :transfer | ] ]
		deferredActions: 	nil
		hasUnacceptedEdits: 	an ObservableValueHolder[ false ]
		selection: 	an ObservableValueHolder[ (1 to: 159) ]
		wantsVisualFeedback: 	an ObservableValueHolder[ true ]
		askBeforeDiscardingEdits: 	an ObservableValueHolder[ true ]
		text: 	an ObservableValueHolder[ '| visualizer |
visualizer := GraphVisualiz[..]
		actionToPerform: 	an ObservableValueHolder[ [ :txt |  ] ]
		readSelection: 	an ObservableValueHolder[ [ selection ] ]
		placeholder: 	an ObservableValueHolder[ '' ]
		contextMenu: 	an ObservableValueHolder[ [ (self menuActionsFor: text) asMenu[..]
		scrollValue: 	an ObservableValueHolder[ (0@0) ]
		editionContextMenu: 	an ObservableValueHolder[ true ]
		editable: 	an ObservableValueHolder[ true ]
		wrapWord: 	an ObservableValueHolder[ true ]
		undoRedoHistory: 	true
		wrapScrollBars: 	true
		propagateNaturalHeight: 	false
		propagateNaturalWidth: 	false
		scrollBarStyles: 	#()
		syntaxHighlight: 	an ObservableValueHolder[ true ]
		smartCharacters: 	an ObservableValueHolder[ true ]
		lineNumbers: 	an ObservableValueHolder[ true ]
		interactionModel: 	an ObservableValueHolder[ a StPlaygroundInteractionModel ]
		overrideContextMenu: 	true
		submitBlock: 	nil
		resetBlock: 	nil
		environment: 	nil
		systemNavigation: 	nil
		syntaxHighlightTheme: 	an ObservableValueHolder[ nil ]


StPlaygroundPagePresenter>>doEvaluateAndGo
	Receiver: a StPlaygroundPagePresenter
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicBoxAdapter)
		announcer: 	an Announcer
		owner: 	a SpMillerColumnPresenter
		adapter: 	a SpMorphicBoxAdapter
		needRebuild: 	true
		eventHandler: 	nil
		application: 	a StPharoApplication
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ nil ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Untitled window' ]
		additionalSubpresentersMap: 	a Dictionary()
		layout: 	an ObservableValueHolder[ a SpBoxLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		text: 	a SpCodePresenter
		toolbar: 	a SpToolbarPresenter
		statusbar: 	a SpPresenter
		lineLabel: 	a SpLabelPresenter
		toggleLineNumberButton: 	a SpToggleButtonPresenter
		page: 	a StPlaygroundPage
		activationBlock: 	[ :selection |
		self changeSelection: selection from: new[..]


StPlaygroundPagePresenter>>doEvaluateAllAndGo
	Receiver: a StPlaygroundPagePresenter
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicBoxAdapter)
		announcer: 	an Announcer
		owner: 	a SpMillerColumnPresenter
		adapter: 	a SpMorphicBoxAdapter
		needRebuild: 	true
		eventHandler: 	nil
		application: 	a StPharoApplication
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ nil ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Untitled window' ]
		additionalSubpresentersMap: 	a Dictionary()
		layout: 	an ObservableValueHolder[ a SpBoxLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		text: 	a SpCodePresenter
		toolbar: 	a SpToolbarPresenter
		statusbar: 	a SpPresenter
		lineLabel: 	a SpLabelPresenter
		toggleLineNumberButton: 	a SpToggleButtonPresenter
		page: 	a StPlaygroundPage
		activationBlock: 	[ :selection |
		self changeSelection: selection from: new[..]


StPlaygroundDoItCommand>>execute
	Receiver: a StPlaygroundDoItCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		context: 	a StPlaygroundPagePresenter
		basicName: 	'Do it'
		basicDescription: 	'Do it all and inspect.'


SpCommand(CmCommandDecorator)>>execute
	Receiver: a SpCommand(Do it)
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a StPlaygroundDoItCommand
		iconProvider: 	a StPharoApplication
		iconName: 	#glamorousGo
		shortcutKey: 	nil
		displayStrategy: 	a CmUIDisableWhenCantBeRun
		positionStrategy: 	a CmUILeftPositionStrategy
		buildPresenterBlock: 	[ :specCommand | 
			aButtonClass new
				label: specC[..]
		presenter: 	a SpToolbarButtonPresenter


[ specCommand execute ] in [ :specCommand | 
			aButtonClass new
				label: specCommand name;
				help: specCommand description;
				in: [ :button | 
					specCommand hasIcon
						ifTrue: [ button icon: specCommand icon ] ];
				action: [ specCommand execute ];
				yourself ] in SpCommand>>configureAsButtonOfClass:
	Receiver: a SpCommand(Do it)
	Arguments and temporary variables: 
		aButtonClass: 	nil
		specCommand: 	a SpCommand(Do it)
	Receiver's instance variables: 
		decoratedCommand: 	a StPlaygroundDoItCommand
		iconProvider: 	a StPharoApplication
		iconName: 	#glamorousGo
		shortcutKey: 	nil
		displayStrategy: 	a CmUIDisableWhenCantBeRun
		positionStrategy: 	a CmUILeftPositionStrategy
		buildPresenterBlock: 	[ :specCommand | 
			aButtonClass new
				label: specC[..]
		presenter: 	a SpToolbarButtonPresenter


FullBlockClosure(BlockClosure)>>cull:
	Receiver: [ specCommand execute ]
	Arguments and temporary variables: 
		anArg: 	a SpToolbarButtonPresenter
	Receiver's instance variables: 
		outerContext: 	[ :specCommand | 
			aButtonClass new
				label: specCommand [..]
		compiledBlock: 	a CompiledBlock: [ specCommand execute ]
		numArgs: 	0
		receiver: 	a SpCommand(Do it)


SpMorphicToolbarButtonAdapter>>execute
	Receiver: a SpMorphicToolbarButtonAdapter
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpToolbarButtonMorph(163457024))
		announcer: 	nil
		model: 	a SpToolbarButtonPresenter
		widget: 	a SpToolbarButtonMorph(163457024)
		selector: 	nil
		owner: 	a SpToolbarButtonPresenter
		unsubscribed: 	false


SpToolbarButtonMorph(PluggableButtonMorph)>>performAction:
	Receiver: a SpToolbarButtonMorph(163457024)
	Arguments and temporary variables: 
		event: 	[(20.0@20.0) mouseUp 12003100 nil]
	Receiver's instance variables: 
		bounds: 	(0.0@5.0) corner: (45.0@39.0)
		owner: 	a Morph(543889152)
		submorphs: 	an Array(an AlignmentMorph(1048008448))
		fullBounds: 	nil
		color: 	(Color r: 0.9012707722385142 g: 0.9012707722385142 b: 0.901270772238[..]
		extension: 	a MorphExtension (606190080) [balloonText]  [other:  (presenter [..]
		borderWidth: 	0
		borderColor: 	#simple
		model: 	a SpMorphicToolbarButtonAdapter
		label: 	'Do it'
		icon: 	Form(13x13x32)
		getIconSelector: 	#icon
		getStateSelector: 	#state
		actionSelector: 	#execute
		font: 	a LogicalFont
 familyName: 'Source Sans Pro'
 emphasis: nil
 pointSiz[..]
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	nil
		getFontSelector: 	nil
		labelMorph: 	a LabelMorph(576130816)'Do it'
		iconMorph: 	an ImageMorph(527603200)
		iconPosition: 	#top
		lastState: 	false
		badgeFont: 	nil
		badgeSelector: 	#badge


[:m |
		(m containsPoint: evt cursorPoint) ifTrue: [m enabled ifTrue: [ m performAction: evt ]]] in SpToolbarButtonMorph(PluggableButtonMorph)>>mouseUp:
	Receiver: a SpToolbarButtonMorph(163457024)
	Arguments and temporary variables: 
		evt: 	[(20.0@20.0) mouseUp 12003100 nil]
		all: 	an Array(a SpToolbarButtonMorph(163457024) a SpToolbarButtonMorph(6416[..]
		m: 	a SpToolbarButtonMorph(163457024)
	Receiver's instance variables: 
		bounds: 	(0.0@5.0) corner: (45.0@39.0)
		owner: 	a Morph(543889152)
		submorphs: 	an Array(an AlignmentMorph(1048008448))
		fullBounds: 	nil
		color: 	(Color r: 0.9012707722385142 g: 0.9012707722385142 b: 0.901270772238[..]
		extension: 	a MorphExtension (606190080) [balloonText]  [other:  (presenter [..]
		borderWidth: 	0
		borderColor: 	#simple
		model: 	a SpMorphicToolbarButtonAdapter
		label: 	'Do it'
		icon: 	Form(13x13x32)
		getIconSelector: 	#icon
		getStateSelector: 	#state
		actionSelector: 	#execute
		font: 	a LogicalFont
 familyName: 'Source Sans Pro'
 emphasis: nil
 pointSiz[..]
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	nil
		getFontSelector: 	nil
		labelMorph: 	a LabelMorph(576130816)'Do it'
		iconMorph: 	an ImageMorph(527603200)
		iconPosition: 	#top
		lastState: 	false
		badgeFont: 	nil
		badgeSelector: 	#badge


Array(SequenceableCollection)>>do:
	Receiver: an Array(a SpToolbarButtonMorph(163457024) a SpToolbarButtonMorph(641645312) a SpToolb[..]
	Arguments and temporary variables: 
		aBlock: 	[:m |
		(m containsPoint: evt cursorPoint) ifTrue: [m enabled ifTru[..]
		index: 	1
	Receiver's instance variables: 
an Array(a SpToolbarButtonMorph(163457024) a SpToolbarButtonMorph(641645312) a SpToolb[..]

SpToolbarButtonMorph(PluggableButtonMorph)>>mouseUp:
	Receiver: a SpToolbarButtonMorph(163457024)
	Arguments and temporary variables: 
		evt: 	[(20.0@20.0) mouseUp 12003100 nil]
		all: 	an Array(a SpToolbarButtonMorph(163457024) a SpToolbarButtonMorph(6416[..]
	Receiver's instance variables: 
		bounds: 	(0.0@5.0) corner: (45.0@39.0)
		owner: 	a Morph(543889152)
		submorphs: 	an Array(an AlignmentMorph(1048008448))
		fullBounds: 	nil
		color: 	(Color r: 0.9012707722385142 g: 0.9012707722385142 b: 0.901270772238[..]
		extension: 	a MorphExtension (606190080) [balloonText]  [other:  (presenter [..]
		borderWidth: 	0
		borderColor: 	#simple
		model: 	a SpMorphicToolbarButtonAdapter
		label: 	'Do it'
		icon: 	Form(13x13x32)
		getIconSelector: 	#icon
		getStateSelector: 	#state
		actionSelector: 	#execute
		font: 	a LogicalFont
 familyName: 'Source Sans Pro'
 emphasis: nil
 pointSiz[..]
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	nil
		getFontSelector: 	nil
		labelMorph: 	a LabelMorph(576130816)'Do it'
		iconMorph: 	an ImageMorph(527603200)
		iconPosition: 	#top
		lastState: 	false
		badgeFont: 	nil
		badgeSelector: 	#badge


SpToolbarButtonMorph(Morph)>>handleMouseUp:
	Receiver: a SpToolbarButtonMorph(163457024)
	Arguments and temporary variables: 
		anEvent: 	[(20.0@20.0) mouseUp 12003100 nil]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(0.0@5.0) corner: (45.0@39.0)
		owner: 	a Morph(543889152)
		submorphs: 	an Array(an AlignmentMorph(1048008448))
		fullBounds: 	nil
		color: 	(Color r: 0.9012707722385142 g: 0.9012707722385142 b: 0.901270772238[..]
		extension: 	a MorphExtension (606190080) [balloonText]  [other:  (presenter [..]
		borderWidth: 	0
		borderColor: 	#simple
		model: 	a SpMorphicToolbarButtonAdapter
		label: 	'Do it'
		icon: 	Form(13x13x32)
		getIconSelector: 	#icon
		getStateSelector: 	#state
		actionSelector: 	#execute
		font: 	a LogicalFont
 familyName: 'Source Sans Pro'
 emphasis: nil
 pointSiz[..]
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	nil
		getFontSelector: 	nil
		labelMorph: 	a LabelMorph(576130816)'Do it'
		iconMorph: 	an ImageMorph(527603200)
		iconPosition: 	#top
		lastState: 	false
		badgeFont: 	nil
		badgeSelector: 	#badge


MouseButtonEvent>>sentTo:
	Receiver: [(20.0@20.0) mouseUp 12003100 nil]
	Arguments and temporary variables: 
		anObject: 	a SpToolbarButtonMorph(163457024)
	Receiver's instance variables: 
		timeStamp: 	12003100
		source: 	a HandMorph(337424384)
		windowIndex: 	nil
		type: 	#mouseUp
		buttons: 	0
		position: 	(20.0@20.0)
		handler: 	nil
		wasHandled: 	true
		whichButton: 	4


SpToolbarButtonMorph(Morph)>>handleEvent:
	Receiver: a SpToolbarButtonMorph(163457024)
	Arguments and temporary variables: 
		anEvent: 	[(20.0@20.0) mouseUp 12003100 nil]
	Receiver's instance variables: 
		bounds: 	(0.0@5.0) corner: (45.0@39.0)
		owner: 	a Morph(543889152)
		submorphs: 	an Array(an AlignmentMorph(1048008448))
		fullBounds: 	nil
		color: 	(Color r: 0.9012707722385142 g: 0.9012707722385142 b: 0.901270772238[..]
		extension: 	a MorphExtension (606190080) [balloonText]  [other:  (presenter [..]
		borderWidth: 	0
		borderColor: 	#simple
		model: 	a SpMorphicToolbarButtonAdapter
		label: 	'Do it'
		icon: 	Form(13x13x32)
		getIconSelector: 	#icon
		getStateSelector: 	#state
		actionSelector: 	#execute
		font: 	a LogicalFont
 familyName: 'Source Sans Pro'
 emphasis: nil
 pointSiz[..]
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	nil
		getFontSelector: 	nil
		labelMorph: 	a LabelMorph(576130816)'Do it'
		iconMorph: 	an ImageMorph(527603200)
		iconPosition: 	#top
		lastState: 	false
		badgeFont: 	nil
		badgeSelector: 	#badge


SpToolbarButtonMorph(Morph)>>handleFocusEvent:
	Receiver: a SpToolbarButtonMorph(163457024)
	Arguments and temporary variables: 
		anEvent: 	[(20.0@20.0) mouseUp 12003100 nil]
	Receiver's instance variables: 
		bounds: 	(0.0@5.0) corner: (45.0@39.0)
		owner: 	a Morph(543889152)
		submorphs: 	an Array(an AlignmentMorph(1048008448))
		fullBounds: 	nil
		color: 	(Color r: 0.9012707722385142 g: 0.9012707722385142 b: 0.901270772238[..]
		extension: 	a MorphExtension (606190080) [balloonText]  [other:  (presenter [..]
		borderWidth: 	0
		borderColor: 	#simple
		model: 	a SpMorphicToolbarButtonAdapter
		label: 	'Do it'
		icon: 	Form(13x13x32)
		getIconSelector: 	#icon
		getStateSelector: 	#state
		actionSelector: 	#execute
		font: 	a LogicalFont
 familyName: 'Source Sans Pro'
 emphasis: nil
 pointSiz[..]
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	nil
		getFontSelector: 	nil
		labelMorph: 	a LabelMorph(576130816)'Do it'
		iconMorph: 	an ImageMorph(527603200)
		iconPosition: 	#top
		lastState: 	false
		badgeFont: 	nil
		badgeSelector: 	#badge


[
		result := focusHolder handleFocusEvent: transformedEvent.
	] in HandMorph>>sendFocusEvent:to:clear:
	Receiver: a HandMorph(337424384)
	Arguments and temporary variables: 
		anEvent: 	[(475@208) mouseUp 12003100 nil]
		focusHolder: 	a SpToolbarButtonMorph(163457024)
		aBlock: 	[self mouseFocus: nil]
		w: 	a WorldMorph(341720576) [world]
		transformedEvent: 	[(20.0@20.0) mouseUp 12003100 nil]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(475@208.0) corner: (491@224.0)
		owner: 	a WorldMorph(341720576) [world]
		submorphs: 	#()
		fullBounds: 	(475@208.0) corner: (491@224.0)
		color: 	Color blue
		extension: 	a MorphExtension (370611968)
		mouseFocus: 	nil
		keyboardFocus: 	a RubEditingArea(143191808)
		eventListeners: 	nil
		mouseListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(475@208) mouseUp 12003100 nil]
		targetOffset: 	(20.0@15.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 0 0 0 0 0 nil nil)
		captureBlock: 	nil
		recentModifiers: 	0
		pendingEventQueue: 	WaitfreeQueue with 0 items
		supressNextKeyPress: 	false


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
		result := focusHolder handleFocusEvent: transformedEvent.
	]
	Arguments and temporary variables: 
		exception: 	Error
		handlerAction: 	[ :ex |
			ActiveWorld := priorWorld.
			ex pass ]
	Receiver's instance variables: 
		outerContext: 	HandMorph>>sendFocusEvent:to:clear:
		compiledBlock: 	a CompiledBlock: [
		result := focusHolder handleFocusEvent:[..]
		numArgs: 	0
		receiver: 	a HandMorph(337424384)


WorldMorph>>becomeActiveDuring:
	Receiver: a WorldMorph(341720576) [world]
	Arguments and temporary variables: 
		aBlock: 	[
		result := focusHolder handleFocusEvent: transformedEvent.
	]
		priorWorld: 	a WorldMorph(341720576) [world]
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1728@1080)
		owner: 	nil
		submorphs: 	an Array(a MenubarMorph(112886016) a TaskbarMorph(279458560) a S[..]
		fullBounds: 	(0@0) corner: (1728@1080)
		color: 	(Color r: 0.9403714565004888 g: 0.9403714565004888 b: 0.940371456500[..]
		extension: 	a MorphExtension (1012946432) [other:  (dragEnabled -> true) (dr[..]
		borderWidth: 	0
		borderColor: 	(Color r: 0.8611925708699902 g: 1.0 b: 0.7223851417399805 alph[..]
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil


HandMorph>>sendFocusEvent:to:clear:
	Receiver: a HandMorph(337424384)
	Arguments and temporary variables: 
		result: 	nil
		anEvent: 	[(475@208) mouseUp 12003100 nil]
		focusHolder: 	a SpToolbarButtonMorph(163457024)
		aBlock: 	[self mouseFocus: nil]
		w: 	a WorldMorph(341720576) [world]
		transformedEvent: 	[(20.0@20.0) mouseUp 12003100 nil]
	Receiver's instance variables: 
		bounds: 	(475@208.0) corner: (491@224.0)
		owner: 	a WorldMorph(341720576) [world]
		submorphs: 	#()
		fullBounds: 	(475@208.0) corner: (491@224.0)
		color: 	Color blue
		extension: 	a MorphExtension (370611968)
		mouseFocus: 	nil
		keyboardFocus: 	a RubEditingArea(143191808)
		eventListeners: 	nil
		mouseListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(475@208) mouseUp 12003100 nil]
		targetOffset: 	(20.0@15.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 0 0 0 0 0 nil nil)
		captureBlock: 	nil
		recentModifiers: 	0
		pendingEventQueue: 	WaitfreeQueue with 0 items
		supressNextKeyPress: 	false


HandMorph>>sendEvent:focus:clear:
	Receiver: a HandMorph(337424384)
	Arguments and temporary variables: 
		anEvent: 	[(475@208) mouseUp 12003100 nil]
		focusHolder: 	a SpToolbarButtonMorph(163457024)
		aBlock: 	[self mouseFocus: nil]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(475@208.0) corner: (491@224.0)
		owner: 	a WorldMorph(341720576) [world]
		submorphs: 	#()
		fullBounds: 	(475@208.0) corner: (491@224.0)
		color: 	Color blue
		extension: 	a MorphExtension (370611968)
		mouseFocus: 	nil
		keyboardFocus: 	a RubEditingArea(143191808)
		eventListeners: 	nil
		mouseListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(475@208) mouseUp 12003100 nil]
		targetOffset: 	(20.0@15.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 0 0 0 0 0 nil nil)
		captureBlock: 	nil
		recentModifiers: 	0
		pendingEventQueue: 	WaitfreeQueue with 0 items
		supressNextKeyPress: 	false


HandMorph>>sendMouseEvent:
	Receiver: a HandMorph(337424384)
	Arguments and temporary variables: 
		anEvent: 	[(475@208) mouseUp 12003100 nil]
	Receiver's instance variables: 
		bounds: 	(475@208.0) corner: (491@224.0)
		owner: 	a WorldMorph(341720576) [world]
		submorphs: 	#()
		fullBounds: 	(475@208.0) corner: (491@224.0)
		color: 	Color blue
		extension: 	a MorphExtension (370611968)
		mouseFocus: 	nil
		keyboardFocus: 	a RubEditingArea(143191808)
		eventListeners: 	nil
		mouseListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(475@208) mouseUp 12003100 nil]
		targetOffset: 	(20.0@15.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 0 0 0 0 0 nil nil)
		captureBlock: 	nil
		recentModifiers: 	0
		pendingEventQueue: 	WaitfreeQueue with 0 items
		supressNextKeyPress: 	false


HandMorph>>handleEvent:
	Receiver: a HandMorph(337424384)
	Arguments and temporary variables: 
		anEvent: 	[(475@208) mouseUp 12003100 nil]
		evt: 	[(475@208) mouseUp 12003100 nil]
	Receiver's instance variables: 
		bounds: 	(475@208.0) corner: (491@224.0)
		owner: 	a WorldMorph(341720576) [world]
		submorphs: 	#()
		fullBounds: 	(475@208.0) corner: (491@224.0)
		color: 	Color blue
		extension: 	a MorphExtension (370611968)
		mouseFocus: 	nil
		keyboardFocus: 	a RubEditingArea(143191808)
		eventListeners: 	nil
		mouseListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(475@208) mouseUp 12003100 nil]
		targetOffset: 	(20.0@15.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 0 0 0 0 0 nil nil)
		captureBlock: 	nil
		recentModifiers: 	0
		pendingEventQueue: 	WaitfreeQueue with 0 items
		supressNextKeyPress: 	false


[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil ]) ifTrue: [
			morphicWorld activeHand handleEvent: anEvent
		]
	] in OSWindowMorphicEventHandler>>dispatchMorphicEvent:
	Receiver: an OSWindowMorphicEventHandler
	Arguments and temporary variables: 
		anEvent: 	[(475@208) mouseUp 12003100 nil]
	Receiver's instance variables: 
		morphicWorld: 	a WorldMorph(341720576) [world]


WorldState>>runStepMethodsIn:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(341720576) [world]
		queue: 	WaitfreeQueue with 0 items
		nextInQueue: 	[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNo[..]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(337424384))
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap()
		lastStepTime: 	11998217
		lastStepMessage: 	nil
		alarms: 	a Heap(MorphicAlarm(#hideShow -> a RubCursor(27124480)))
		lastAlarmTime: 	12003077
		activeHand: 	a HandMorph(337424384)
		currentCursor: 	((CursorWithMask
	extent: (16@16)
	depth: 1
	fromArray: #(
	[..]
		worldRenderer: 	an OSWorldRenderer
		realWindowExtent: 	(1728@1080)
		deferredUIMessages: 	WaitfreeQueue with 0 items


WorldMorph>>runStepMethods
	Receiver: a WorldMorph(341720576) [world]
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1728@1080)
		owner: 	nil
		submorphs: 	an Array(a MenubarMorph(112886016) a TaskbarMorph(279458560) a S[..]
		fullBounds: 	(0@0) corner: (1728@1080)
		color: 	(Color r: 0.9403714565004888 g: 0.9403714565004888 b: 0.940371456500[..]
		extension: 	a MorphExtension (1012946432) [other:  (dragEnabled -> true) (dr[..]
		borderWidth: 	0
		borderColor: 	(Color r: 0.8611925708699902 g: 1.0 b: 0.7223851417399805 alph[..]
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil


WorldState>>doOneCycleFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(341720576) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(337424384))
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap()
		lastStepTime: 	11998217
		lastStepMessage: 	nil
		alarms: 	a Heap(MorphicAlarm(#hideShow -> a RubCursor(27124480)))
		lastAlarmTime: 	12003077
		activeHand: 	a HandMorph(337424384)
		currentCursor: 	((CursorWithMask
	extent: (16@16)
	depth: 1
	fromArray: #(
	[..]
		worldRenderer: 	an OSWorldRenderer
		realWindowExtent: 	(1728@1080)
		deferredUIMessages: 	WaitfreeQueue with 0 items


WorldMorph>>doOneCycleNow
	Receiver: a WorldMorph(341720576) [world]
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1728@1080)
		owner: 	nil
		submorphs: 	an Array(a MenubarMorph(112886016) a TaskbarMorph(279458560) a S[..]
		fullBounds: 	(0@0) corner: (1728@1080)
		color: 	(Color r: 0.9403714565004888 g: 0.9403714565004888 b: 0.940371456500[..]
		extension: 	a MorphExtension (1012946432) [other:  (dragEnabled -> true) (dr[..]
		borderWidth: 	0
		borderColor: 	(Color r: 0.8611925708699902 g: 1.0 b: 0.7223851417399805 alph[..]
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil


WorldMorph>>doOneCycle
	Receiver: a WorldMorph(341720576) [world]
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1728@1080)
		owner: 	nil
		submorphs: 	an Array(a MenubarMorph(112886016) a TaskbarMorph(279458560) a S[..]
		fullBounds: 	(0@0) corner: (1728@1080)
		color: 	(Color r: 0.9403714565004888 g: 0.9403714565004888 b: 0.940371456500[..]
		extension: 	a MorphExtension (1012946432) [other:  (dragEnabled -> true) (dr[..]
		borderWidth: 	0
		borderColor: 	(Color r: 0.8611925708699902 g: 1.0 b: 0.7223851417399805 alph[..]
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil



--- The full stack ---
RSLine(Object)>>doesNotUnderstand: #start:
[ :edgeDict |
        | edge sourceNode targetNode sourcePosition targetPosition |
        sourceNode := nodesMap at: (edgeDict at: #source) ifAbsent: [ nil ].
        targetNode := nodesMap at: (edgeDict at: #target) ifAbsent: [ nil ].
        sourceNode ifNotNil: [ targetNode ifNotNil: [
            sourcePosition := sourceNode position.
            targetPosition := targetNode position.
            edge := RSLine new.
            edge start: sourcePosition; end: targetPosition.
            canvas add: edge.
        ]].
    ] in GraphVisualizer>>createEdges
Array(SequenceableCollection)>>do:
GraphVisualizer>>createEdges
GraphVisualizer>>visualizeGraphFromFile:
UndefinedObject>>DoIt
OCReceiverDoItSemanticScope(OCDoItSemanticScope)>>evaluateDoIt:
OpalCompiler>>evaluate
[
		self announcer announce: (SpCodeWillBeEvaluatedAnnouncement newContent: aString).
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionModel doItReceiver.
		result := receiver class compiler
			source: aString;
			context: self interactionModel doItContext;
			receiver: self interactionModel doItReceiver;
			requestor: self interactionModel;
			environment: self environment;
			failBlock:  [ 
				self announcer announce: (SpCodeEvaluationFailedAnnouncement newContent: aString).
				^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		self announcer announce: (SpCodeEvaluationSucceedAnnouncement newContent: aString).
		result ] in SpCodePresenter>>evaluate:onCompileError:onError:
FullBlockClosure(BlockClosure)>>on:do:
SpCodePresenter>>evaluate:onCompileError:onError:
StPlaygroundPagePresenter>>doEvaluateAndGo
StPlaygroundPagePresenter>>doEvaluateAllAndGo
StPlaygroundDoItCommand>>execute
SpCommand(CmCommandDecorator)>>execute
[ specCommand execute ] in [ :specCommand | 
			aButtonClass new
				label: specCommand name;
				help: specCommand description;
				in: [ :button | 
					specCommand hasIcon
						ifTrue: [ button icon: specCommand icon ] ];
				action: [ specCommand execute ];
				yourself ] in SpCommand>>configureAsButtonOfClass:
FullBlockClosure(BlockClosure)>>cull:
SpMorphicToolbarButtonAdapter>>execute
SpToolbarButtonMorph(PluggableButtonMorph)>>performAction:
[:m |
		(m containsPoint: evt cursorPoint) ifTrue: [m enabled ifTrue: [ m performAction: evt ]]] in SpToolbarButtonMorph(PluggableButtonMorph)>>mouseUp:
Array(SequenceableCollection)>>do:
SpToolbarButtonMorph(PluggableButtonMorph)>>mouseUp:
SpToolbarButtonMorph(Morph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
SpToolbarButtonMorph(Morph)>>handleEvent:
SpToolbarButtonMorph(Morph)>>handleFocusEvent:
[
		result := focusHolder handleFocusEvent: transformedEvent.
	] in HandMorph>>sendFocusEvent:to:clear:
FullBlockClosure(BlockClosure)>>on:do:
WorldMorph>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil ]) ifTrue: [
			morphicWorld activeHand handleEvent: anEvent
		]
	] in OSWindowMorphicEventHandler>>dispatchMorphicEvent:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycleNow
WorldMorph>>doOneCycle
 - - - - - - - - - - - - - - -
			- - - - - - - - - - - - - - - - - -
[
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMutex critical: [
			                     self extraWorldList ].
		extraWorldsToDraw do: [ :world | world doOneCycle ].

		(self currentWorld isNotNil and: [
			 (extraWorldsToDraw includes: self currentWorld) not ]) ifTrue: [
			self currentWorld doOneCycle ] ] in WorldMorph class>>doOneCycle
FullBlockClosure(BlockClosure)>>ensure:
WorldState class>>doDrawCycleWith:
WorldMorph class>>doOneCycle
MorphicRenderLoop>>doOneCycle
MorphicRenderLoop>>doOneCycleWhile:
[ MorphicRenderLoop new doOneCycleWhile: [ true ] ] in MorphicUIManager>>spawnNewProcess
[self value.
			"IMPORTANT: Do not step over next line of code. See method comments for details"
			Processor terminateRealActive] in FullBlockClosure(BlockClosure)>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
Instance of RSLine did not understand #start:
13 November 2023 7:24:45.008512 pm

VM: Mac OS - arm64 - 1000 - CoInterpreter VMMaker-tonel.1 uuid: 902dd483-c0c4-0d00-86f2-0f880df24b96 Oct 23 2023
StackToRegisterMappingCogit VMMaker-tonel.1 uuid: 902dd483-c0c4-0d00-86f2-0f880df24b96 Oct 23 2023
v10.0.8 - Commit: b323c5fb - Date: 2023-10-20 16:02:07 -0400

Image: Pharo11.0.0 [Build information: Pharo-11.0.0+build.710.sha.ea28d8552cac85a7ce1e9c34ab1e7bd45f7b9910 (64 Bit)]

RSLine(Object)>>doesNotUnderstand: #start:
	Receiver: a RSLine
	Arguments and temporary variables: 
		aMessage: 	start: (0.0@0.0)
		exception: 	Instance of RSLine did not understand #start:
		resumeValue: 	nil
	Receiver's instance variables: 
		announcer: 	nil
		properties: 	nil
		paint: 	nil
		path: 	nil
		border: 	1, Color gray
		parent: 	nil
		isFixed: 	false
		encompassingRectangle: 	nil
		model: 	nil
		attachPoint: 	a RSCenteredAttachPoint
		from: 	nil
		to: 	nil
		markers: 	nil
		startPoint: 	(0@0)
		endPoint: 	(100@100)


[ :edgeDict |
        | edge sourceNode targetNode sourcePosition targetPosition |
        sourceNode := nodesMap at: (edgeDict at: #source) ifAbsent: [ nil ].
        targetNode := nodesMap at: (edgeDict at: #target) ifAbsent: [ nil ].
        sourceNode ifNotNil: [ targetNode ifNotNil: [
            sourcePosition := sourceNode position.
            targetPosition := targetNode position.
            edge := RSLine new.
            edge start: sourcePosition; end: targetPosition.
            canvas add: edge.
        ]].
    ] in GraphVisualizer>>createEdges
	Receiver: a GraphVisualizer
	Arguments and temporary variables: 
		edgeDict: 	a Dictionary('source'->1 'target'->2 'type'->'FRIENDS_WITH' )
		edge: 	a RSLine
		sourceNode: 	a RSBox
		targetNode: 	a RSBox
		sourcePosition: 	(0.0@0.0)
		targetPosition: 	(0.0@0.0)
	Receiver's instance variables: 
		view: 	nil
		nodes: 	an Array(a Dictionary('id'->1 'label'->'Person' 'properties'->a Dict[..]
		edges: 	an Array(a Dictionary('source'->1 'target'->2 'type'->'FRIENDS_WITH' ))
		nodesMap: 	a Dictionary(1->a RSBox 2->a RSBox )
		canvas: 	a RSCanvas


Array(SequenceableCollection)>>do:
	Receiver: an Array(a Dictionary('source'->1 'target'->2 'type'->'FRIENDS_WITH' ))
	Arguments and temporary variables: 
		aBlock: 	[ :edgeDict |
        | edge sourceNode targetNode sourcePosition t[..]
		index: 	1
	Receiver's instance variables: 
an Array(a Dictionary('source'->1 'target'->2 'type'->'FRIENDS_WITH' ))

GraphVisualizer>>createEdges
	Receiver: a GraphVisualizer
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		view: 	nil
		nodes: 	an Array(a Dictionary('id'->1 'label'->'Person' 'properties'->a Dict[..]
		edges: 	an Array(a Dictionary('source'->1 'target'->2 'type'->'FRIENDS_WITH' ))
		nodesMap: 	a Dictionary(1->a RSBox 2->a RSBox )
		canvas: 	a RSCanvas


GraphVisualizer>>visualizeGraphFromFile:
	Receiver: a GraphVisualizer
	Arguments and temporary variables: 
		aFilePath: 	'/Users/ryanperez/Documents/GitHub/pp-rep2533/project/src/data/t[..]
	Receiver's instance variables: 
		view: 	nil
		nodes: 	an Array(a Dictionary('id'->1 'label'->'Person' 'properties'->a Dict[..]
		edges: 	an Array(a Dictionary('source'->1 'target'->2 'type'->'FRIENDS_WITH' ))
		nodesMap: 	a Dictionary(1->a RSBox 2->a RSBox )
		canvas: 	a RSCanvas


UndefinedObject>>DoIt
	Receiver: nil
	Arguments and temporary variables: 
		visualizer: 	a GraphVisualizer
	Receiver's instance variables: 
nil

OCReceiverDoItSemanticScope(OCDoItSemanticScope)>>evaluateDoIt:
	Receiver: an OCReceiverDoItSemanticScope
	Arguments and temporary variables: 
		doItMethod: 	UndefinedObject>>#DoIt
	Receiver's instance variables: 
		outerScope: 	nil
		targetReceiver: 	nil


OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
		doItMethod: 	UndefinedObject>>#DoIt
	Receiver's instance variables: 
		ast: 	DoIt

	| visualizer |
	visualizer := GraphVisualizer new.
	^ visualize[..]
		source: 	a ReadStream
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil


[
		self announcer announce: (SpCodeWillBeEvaluatedAnnouncement newContent: aString).
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionModel doItReceiver.
		result := receiver class compiler
			source: aString;
			context: self interactionModel doItContext;
			receiver: self interactionModel doItReceiver;
			requestor: self interactionModel;
			environment: self environment;
			failBlock:  [ 
				self announcer announce: (SpCodeEvaluationFailedAnnouncement newContent: aString).
				^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		self announcer announce: (SpCodeEvaluationSucceedAnnouncement newContent: aString).
		result ] in SpCodePresenter>>evaluate:onCompileError:onError:
	Receiver: a SpCodePresenter
	Arguments and temporary variables: 
		aString: 	'| visualizer |
visualizer := GraphVisualizer new.
visualizer visu[..]
		compileErrorBlock: 	[ ^ self ]
		errorBlock: 	[ :e | e pass ]
		receiver: 	nil
		result: 	nil
		oldBindings: 	a Dictionary()
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicCodeAdapter)
		announcer: 	an Announcer
		owner: 	a StPlaygroundPagePresenter
		adapter: 	a SpMorphicCodeAdapter
		needRebuild: 	true
		eventHandler: 	a SpEventHandler
		application: 	nil
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ a KMCategory ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Code' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpAbstractWidgetLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		borderWidth: 	an ObservableValueHolder[ nil ]
		borderColor: 	an ObservableValueHolder[ nil ]
		dragEnabled: 	an ObservableValueHolder[ false ]
		dropEnabled: 	an ObservableValueHolder[ false ]
		color: 	an ObservableValueHolder[ nil ]
		help: 	an ObservableValueHolder[ nil ]
		enabled: 	an ObservableValueHolder[ true ]
		wantsDrop: 	an ObservableValueHolder[ [ :transfer | self dropEnabled ] ]
		acceptDrop: 	an ObservableValueHolder[ [ :transfer | ] ]
		deferredActions: 	nil
		hasUnacceptedEdits: 	an ObservableValueHolder[ false ]
		selection: 	an ObservableValueHolder[ (1 to: 159) ]
		wantsVisualFeedback: 	an ObservableValueHolder[ true ]
		askBeforeDiscardingEdits: 	an ObservableValueHolder[ true ]
		text: 	an ObservableValueHolder[ '| visualizer |
visualizer := GraphVisualiz[..]
		actionToPerform: 	an ObservableValueHolder[ [ :txt |  ] ]
		readSelection: 	an ObservableValueHolder[ [ selection ] ]
		placeholder: 	an ObservableValueHolder[ '' ]
		contextMenu: 	an ObservableValueHolder[ [ (self menuActionsFor: text) asMenu[..]
		scrollValue: 	an ObservableValueHolder[ (0@0) ]
		editionContextMenu: 	an ObservableValueHolder[ true ]
		editable: 	an ObservableValueHolder[ true ]
		wrapWord: 	an ObservableValueHolder[ true ]
		undoRedoHistory: 	true
		wrapScrollBars: 	true
		propagateNaturalHeight: 	false
		propagateNaturalWidth: 	false
		scrollBarStyles: 	#()
		syntaxHighlight: 	an ObservableValueHolder[ true ]
		smartCharacters: 	an ObservableValueHolder[ true ]
		lineNumbers: 	an ObservableValueHolder[ true ]
		interactionModel: 	an ObservableValueHolder[ a StPlaygroundInteractionModel ]
		overrideContextMenu: 	true
		submitBlock: 	nil
		resetBlock: 	nil
		environment: 	nil
		systemNavigation: 	nil
		syntaxHighlightTheme: 	an ObservableValueHolder[ nil ]


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
		self announcer announce: (SpCodeWillBeEvaluatedAnnouncement newContent: aString).
[..]
	Arguments and temporary variables: 
		exception: 	Error
		handlerAction: 	[ :e |
		self announcer announce: (SpCodeEvaluationFailedAnn[..]
	Receiver's instance variables: 
		outerContext: 	SpCodePresenter>>evaluate:onCompileError:onError:
		compiledBlock: 	a CompiledBlock: [
		self announcer announce: (SpCodeWillBeE[..]
		numArgs: 	0
		receiver: 	a SpCodePresenter


SpCodePresenter>>evaluate:onCompileError:onError:
	Receiver: a SpCodePresenter
	Arguments and temporary variables: 
		receiver: 	nil
		result: 	nil
		oldBindings: 	a Dictionary()
		aString: 	'| visualizer |
visualizer := GraphVisualizer new.
visualizer visu[..]
		compileErrorBlock: 	[ ^ self ]
		errorBlock: 	[ :e | e pass ]
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicCodeAdapter)
		announcer: 	an Announcer
		owner: 	a StPlaygroundPagePresenter
		adapter: 	a SpMorphicCodeAdapter
		needRebuild: 	true
		eventHandler: 	a SpEventHandler
		application: 	nil
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ a KMCategory ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Code' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpAbstractWidgetLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		borderWidth: 	an ObservableValueHolder[ nil ]
		borderColor: 	an ObservableValueHolder[ nil ]
		dragEnabled: 	an ObservableValueHolder[ false ]
		dropEnabled: 	an ObservableValueHolder[ false ]
		color: 	an ObservableValueHolder[ nil ]
		help: 	an ObservableValueHolder[ nil ]
		enabled: 	an ObservableValueHolder[ true ]
		wantsDrop: 	an ObservableValueHolder[ [ :transfer | self dropEnabled ] ]
		acceptDrop: 	an ObservableValueHolder[ [ :transfer | ] ]
		deferredActions: 	nil
		hasUnacceptedEdits: 	an ObservableValueHolder[ false ]
		selection: 	an ObservableValueHolder[ (1 to: 159) ]
		wantsVisualFeedback: 	an ObservableValueHolder[ true ]
		askBeforeDiscardingEdits: 	an ObservableValueHolder[ true ]
		text: 	an ObservableValueHolder[ '| visualizer |
visualizer := GraphVisualiz[..]
		actionToPerform: 	an ObservableValueHolder[ [ :txt |  ] ]
		readSelection: 	an ObservableValueHolder[ [ selection ] ]
		placeholder: 	an ObservableValueHolder[ '' ]
		contextMenu: 	an ObservableValueHolder[ [ (self menuActionsFor: text) asMenu[..]
		scrollValue: 	an ObservableValueHolder[ (0@0) ]
		editionContextMenu: 	an ObservableValueHolder[ true ]
		editable: 	an ObservableValueHolder[ true ]
		wrapWord: 	an ObservableValueHolder[ true ]
		undoRedoHistory: 	true
		wrapScrollBars: 	true
		propagateNaturalHeight: 	false
		propagateNaturalWidth: 	false
		scrollBarStyles: 	#()
		syntaxHighlight: 	an ObservableValueHolder[ true ]
		smartCharacters: 	an ObservableValueHolder[ true ]
		lineNumbers: 	an ObservableValueHolder[ true ]
		interactionModel: 	an ObservableValueHolder[ a StPlaygroundInteractionModel ]
		overrideContextMenu: 	true
		submitBlock: 	nil
		resetBlock: 	nil
		environment: 	nil
		systemNavigation: 	nil
		syntaxHighlightTheme: 	an ObservableValueHolder[ nil ]


StPlaygroundPagePresenter>>doEvaluateAndGo
	Receiver: a StPlaygroundPagePresenter
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicBoxAdapter)
		announcer: 	an Announcer
		owner: 	a SpMillerColumnPresenter
		adapter: 	a SpMorphicBoxAdapter
		needRebuild: 	true
		eventHandler: 	nil
		application: 	a StPharoApplication
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ nil ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Untitled window' ]
		additionalSubpresentersMap: 	a Dictionary()
		layout: 	an ObservableValueHolder[ a SpBoxLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		text: 	a SpCodePresenter
		toolbar: 	a SpToolbarPresenter
		statusbar: 	a SpPresenter
		lineLabel: 	a SpLabelPresenter
		toggleLineNumberButton: 	a SpToggleButtonPresenter
		page: 	a StPlaygroundPage
		activationBlock: 	[ :selection |
		self changeSelection: selection from: new[..]


StPlaygroundPagePresenter>>doEvaluateAllAndGo
	Receiver: a StPlaygroundPagePresenter
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicBoxAdapter)
		announcer: 	an Announcer
		owner: 	a SpMillerColumnPresenter
		adapter: 	a SpMorphicBoxAdapter
		needRebuild: 	true
		eventHandler: 	nil
		application: 	a StPharoApplication
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ nil ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Untitled window' ]
		additionalSubpresentersMap: 	a Dictionary()
		layout: 	an ObservableValueHolder[ a SpBoxLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		text: 	a SpCodePresenter
		toolbar: 	a SpToolbarPresenter
		statusbar: 	a SpPresenter
		lineLabel: 	a SpLabelPresenter
		toggleLineNumberButton: 	a SpToggleButtonPresenter
		page: 	a StPlaygroundPage
		activationBlock: 	[ :selection |
		self changeSelection: selection from: new[..]


StPlaygroundDoItCommand>>execute
	Receiver: a StPlaygroundDoItCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		context: 	a StPlaygroundPagePresenter
		basicName: 	'Do it'
		basicDescription: 	'Do it all and inspect.'


SpCommand(CmCommandDecorator)>>execute
	Receiver: a SpCommand(Do it)
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a StPlaygroundDoItCommand
		iconProvider: 	a StPharoApplication
		iconName: 	#glamorousGo
		shortcutKey: 	nil
		displayStrategy: 	a CmUIDisableWhenCantBeRun
		positionStrategy: 	a CmUILeftPositionStrategy
		buildPresenterBlock: 	[ :specCommand | 
			aButtonClass new
				label: specC[..]
		presenter: 	a SpToolbarButtonPresenter


[ specCommand execute ] in [ :specCommand | 
			aButtonClass new
				label: specCommand name;
				help: specCommand description;
				in: [ :button | 
					specCommand hasIcon
						ifTrue: [ button icon: specCommand icon ] ];
				action: [ specCommand execute ];
				yourself ] in SpCommand>>configureAsButtonOfClass:
	Receiver: a SpCommand(Do it)
	Arguments and temporary variables: 
		aButtonClass: 	nil
		specCommand: 	a SpCommand(Do it)
	Receiver's instance variables: 
		decoratedCommand: 	a StPlaygroundDoItCommand
		iconProvider: 	a StPharoApplication
		iconName: 	#glamorousGo
		shortcutKey: 	nil
		displayStrategy: 	a CmUIDisableWhenCantBeRun
		positionStrategy: 	a CmUILeftPositionStrategy
		buildPresenterBlock: 	[ :specCommand | 
			aButtonClass new
				label: specC[..]
		presenter: 	a SpToolbarButtonPresenter


FullBlockClosure(BlockClosure)>>cull:
	Receiver: [ specCommand execute ]
	Arguments and temporary variables: 
		anArg: 	a SpToolbarButtonPresenter
	Receiver's instance variables: 
		outerContext: 	[ :specCommand | 
			aButtonClass new
				label: specCommand [..]
		compiledBlock: 	a CompiledBlock: [ specCommand execute ]
		numArgs: 	0
		receiver: 	a SpCommand(Do it)


SpMorphicToolbarButtonAdapter>>execute
	Receiver: a SpMorphicToolbarButtonAdapter
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpToolbarButtonMorph(163457024))
		announcer: 	nil
		model: 	a SpToolbarButtonPresenter
		widget: 	a SpToolbarButtonMorph(163457024)
		selector: 	nil
		owner: 	a SpToolbarButtonPresenter
		unsubscribed: 	false


SpToolbarButtonMorph(PluggableButtonMorph)>>performAction:
	Receiver: a SpToolbarButtonMorph(163457024)
	Arguments and temporary variables: 
		event: 	[(20.0@20.0) mouseUp 12003100 nil]
	Receiver's instance variables: 
		bounds: 	(0.0@5.0) corner: (45.0@39.0)
		owner: 	a Morph(543889152)
		submorphs: 	an Array(an AlignmentMorph(1048008448))
		fullBounds: 	nil
		color: 	(Color r: 0.9012707722385142 g: 0.9012707722385142 b: 0.901270772238[..]
		extension: 	a MorphExtension (606190080) [balloonText]  [other:  (presenter [..]
		borderWidth: 	0
		borderColor: 	#simple
		model: 	a SpMorphicToolbarButtonAdapter
		label: 	'Do it'
		icon: 	Form(13x13x32)
		getIconSelector: 	#icon
		getStateSelector: 	#state
		actionSelector: 	#execute
		font: 	a LogicalFont
 familyName: 'Source Sans Pro'
 emphasis: nil
 pointSiz[..]
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	nil
		getFontSelector: 	nil
		labelMorph: 	a LabelMorph(576130816)'Do it'
		iconMorph: 	an ImageMorph(527603200)
		iconPosition: 	#top
		lastState: 	false
		badgeFont: 	nil
		badgeSelector: 	#badge


[:m |
		(m containsPoint: evt cursorPoint) ifTrue: [m enabled ifTrue: [ m performAction: evt ]]] in SpToolbarButtonMorph(PluggableButtonMorph)>>mouseUp:
	Receiver: a SpToolbarButtonMorph(163457024)
	Arguments and temporary variables: 
		evt: 	[(20.0@20.0) mouseUp 12003100 nil]
		all: 	an Array(a SpToolbarButtonMorph(163457024) a SpToolbarButtonMorph(6416[..]
		m: 	a SpToolbarButtonMorph(163457024)
	Receiver's instance variables: 
		bounds: 	(0.0@5.0) corner: (45.0@39.0)
		owner: 	a Morph(543889152)
		submorphs: 	an Array(an AlignmentMorph(1048008448))
		fullBounds: 	nil
		color: 	(Color r: 0.9012707722385142 g: 0.9012707722385142 b: 0.901270772238[..]
		extension: 	a MorphExtension (606190080) [balloonText]  [other:  (presenter [..]
		borderWidth: 	0
		borderColor: 	#simple
		model: 	a SpMorphicToolbarButtonAdapter
		label: 	'Do it'
		icon: 	Form(13x13x32)
		getIconSelector: 	#icon
		getStateSelector: 	#state
		actionSelector: 	#execute
		font: 	a LogicalFont
 familyName: 'Source Sans Pro'
 emphasis: nil
 pointSiz[..]
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	nil
		getFontSelector: 	nil
		labelMorph: 	a LabelMorph(576130816)'Do it'
		iconMorph: 	an ImageMorph(527603200)
		iconPosition: 	#top
		lastState: 	false
		badgeFont: 	nil
		badgeSelector: 	#badge


Array(SequenceableCollection)>>do:
	Receiver: an Array(a SpToolbarButtonMorph(163457024) a SpToolbarButtonMorph(641645312) a SpToolb[..]
	Arguments and temporary variables: 
		aBlock: 	[:m |
		(m containsPoint: evt cursorPoint) ifTrue: [m enabled ifTru[..]
		index: 	1
	Receiver's instance variables: 
an Array(a SpToolbarButtonMorph(163457024) a SpToolbarButtonMorph(641645312) a SpToolb[..]

SpToolbarButtonMorph(PluggableButtonMorph)>>mouseUp:
	Receiver: a SpToolbarButtonMorph(163457024)
	Arguments and temporary variables: 
		evt: 	[(20.0@20.0) mouseUp 12003100 nil]
		all: 	an Array(a SpToolbarButtonMorph(163457024) a SpToolbarButtonMorph(6416[..]
	Receiver's instance variables: 
		bounds: 	(0.0@5.0) corner: (45.0@39.0)
		owner: 	a Morph(543889152)
		submorphs: 	an Array(an AlignmentMorph(1048008448))
		fullBounds: 	nil
		color: 	(Color r: 0.9012707722385142 g: 0.9012707722385142 b: 0.901270772238[..]
		extension: 	a MorphExtension (606190080) [balloonText]  [other:  (presenter [..]
		borderWidth: 	0
		borderColor: 	#simple
		model: 	a SpMorphicToolbarButtonAdapter
		label: 	'Do it'
		icon: 	Form(13x13x32)
		getIconSelector: 	#icon
		getStateSelector: 	#state
		actionSelector: 	#execute
		font: 	a LogicalFont
 familyName: 'Source Sans Pro'
 emphasis: nil
 pointSiz[..]
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	nil
		getFontSelector: 	nil
		labelMorph: 	a LabelMorph(576130816)'Do it'
		iconMorph: 	an ImageMorph(527603200)
		iconPosition: 	#top
		lastState: 	false
		badgeFont: 	nil
		badgeSelector: 	#badge


SpToolbarButtonMorph(Morph)>>handleMouseUp:
	Receiver: a SpToolbarButtonMorph(163457024)
	Arguments and temporary variables: 
		anEvent: 	[(20.0@20.0) mouseUp 12003100 nil]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(0.0@5.0) corner: (45.0@39.0)
		owner: 	a Morph(543889152)
		submorphs: 	an Array(an AlignmentMorph(1048008448))
		fullBounds: 	nil
		color: 	(Color r: 0.9012707722385142 g: 0.9012707722385142 b: 0.901270772238[..]
		extension: 	a MorphExtension (606190080) [balloonText]  [other:  (presenter [..]
		borderWidth: 	0
		borderColor: 	#simple
		model: 	a SpMorphicToolbarButtonAdapter
		label: 	'Do it'
		icon: 	Form(13x13x32)
		getIconSelector: 	#icon
		getStateSelector: 	#state
		actionSelector: 	#execute
		font: 	a LogicalFont
 familyName: 'Source Sans Pro'
 emphasis: nil
 pointSiz[..]
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	nil
		getFontSelector: 	nil
		labelMorph: 	a LabelMorph(576130816)'Do it'
		iconMorph: 	an ImageMorph(527603200)
		iconPosition: 	#top
		lastState: 	false
		badgeFont: 	nil
		badgeSelector: 	#badge


MouseButtonEvent>>sentTo:
	Receiver: [(20.0@20.0) mouseUp 12003100 nil]
	Arguments and temporary variables: 
		anObject: 	a SpToolbarButtonMorph(163457024)
	Receiver's instance variables: 
		timeStamp: 	12003100
		source: 	a HandMorph(337424384)
		windowIndex: 	nil
		type: 	#mouseUp
		buttons: 	0
		position: 	(20.0@20.0)
		handler: 	nil
		wasHandled: 	true
		whichButton: 	4


SpToolbarButtonMorph(Morph)>>handleEvent:
	Receiver: a SpToolbarButtonMorph(163457024)
	Arguments and temporary variables: 
		anEvent: 	[(20.0@20.0) mouseUp 12003100 nil]
	Receiver's instance variables: 
		bounds: 	(0.0@5.0) corner: (45.0@39.0)
		owner: 	a Morph(543889152)
		submorphs: 	an Array(an AlignmentMorph(1048008448))
		fullBounds: 	nil
		color: 	(Color r: 0.9012707722385142 g: 0.9012707722385142 b: 0.901270772238[..]
		extension: 	a MorphExtension (606190080) [balloonText]  [other:  (presenter [..]
		borderWidth: 	0
		borderColor: 	#simple
		model: 	a SpMorphicToolbarButtonAdapter
		label: 	'Do it'
		icon: 	Form(13x13x32)
		getIconSelector: 	#icon
		getStateSelector: 	#state
		actionSelector: 	#execute
		font: 	a LogicalFont
 familyName: 'Source Sans Pro'
 emphasis: nil
 pointSiz[..]
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	nil
		getFontSelector: 	nil
		labelMorph: 	a LabelMorph(576130816)'Do it'
		iconMorph: 	an ImageMorph(527603200)
		iconPosition: 	#top
		lastState: 	false
		badgeFont: 	nil
		badgeSelector: 	#badge


SpToolbarButtonMorph(Morph)>>handleFocusEvent:
	Receiver: a SpToolbarButtonMorph(163457024)
	Arguments and temporary variables: 
		anEvent: 	[(20.0@20.0) mouseUp 12003100 nil]
	Receiver's instance variables: 
		bounds: 	(0.0@5.0) corner: (45.0@39.0)
		owner: 	a Morph(543889152)
		submorphs: 	an Array(an AlignmentMorph(1048008448))
		fullBounds: 	nil
		color: 	(Color r: 0.9012707722385142 g: 0.9012707722385142 b: 0.901270772238[..]
		extension: 	a MorphExtension (606190080) [balloonText]  [other:  (presenter [..]
		borderWidth: 	0
		borderColor: 	#simple
		model: 	a SpMorphicToolbarButtonAdapter
		label: 	'Do it'
		icon: 	Form(13x13x32)
		getIconSelector: 	#icon
		getStateSelector: 	#state
		actionSelector: 	#execute
		font: 	a LogicalFont
 familyName: 'Source Sans Pro'
 emphasis: nil
 pointSiz[..]
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	nil
		getFontSelector: 	nil
		labelMorph: 	a LabelMorph(576130816)'Do it'
		iconMorph: 	an ImageMorph(527603200)
		iconPosition: 	#top
		lastState: 	false
		badgeFont: 	nil
		badgeSelector: 	#badge


[
		result := focusHolder handleFocusEvent: transformedEvent.
	] in HandMorph>>sendFocusEvent:to:clear:
	Receiver: a HandMorph(337424384)
	Arguments and temporary variables: 
		anEvent: 	[(475@208) mouseUp 12003100 nil]
		focusHolder: 	a SpToolbarButtonMorph(163457024)
		aBlock: 	[self mouseFocus: nil]
		w: 	a WorldMorph(341720576) [world]
		transformedEvent: 	[(20.0@20.0) mouseUp 12003100 nil]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(475@208.0) corner: (491@224.0)
		owner: 	a WorldMorph(341720576) [world]
		submorphs: 	#()
		fullBounds: 	(475@208.0) corner: (491@224.0)
		color: 	Color blue
		extension: 	a MorphExtension (370611968)
		mouseFocus: 	nil
		keyboardFocus: 	a RubEditingArea(143191808)
		eventListeners: 	nil
		mouseListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(475@208) mouseUp 12003100 nil]
		targetOffset: 	(20.0@15.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 0 0 0 0 0 nil nil)
		captureBlock: 	nil
		recentModifiers: 	0
		pendingEventQueue: 	WaitfreeQueue with 0 items
		supressNextKeyPress: 	false


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
		result := focusHolder handleFocusEvent: transformedEvent.
	]
	Arguments and temporary variables: 
		exception: 	Error
		handlerAction: 	[ :ex |
			ActiveWorld := priorWorld.
			ex pass ]
	Receiver's instance variables: 
		outerContext: 	HandMorph>>sendFocusEvent:to:clear:
		compiledBlock: 	a CompiledBlock: [
		result := focusHolder handleFocusEvent:[..]
		numArgs: 	0
		receiver: 	a HandMorph(337424384)


WorldMorph>>becomeActiveDuring:
	Receiver: a WorldMorph(341720576) [world]
	Arguments and temporary variables: 
		aBlock: 	[
		result := focusHolder handleFocusEvent: transformedEvent.
	]
		priorWorld: 	a WorldMorph(341720576) [world]
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1728@1080)
		owner: 	nil
		submorphs: 	an Array(a MenubarMorph(112886016) a TaskbarMorph(279458560) a S[..]
		fullBounds: 	(0@0) corner: (1728@1080)
		color: 	(Color r: 0.9403714565004888 g: 0.9403714565004888 b: 0.940371456500[..]
		extension: 	a MorphExtension (1012946432) [other:  (dragEnabled -> true) (dr[..]
		borderWidth: 	0
		borderColor: 	(Color r: 0.8611925708699902 g: 1.0 b: 0.7223851417399805 alph[..]
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil


HandMorph>>sendFocusEvent:to:clear:
	Receiver: a HandMorph(337424384)
	Arguments and temporary variables: 
		result: 	nil
		anEvent: 	[(475@208) mouseUp 12003100 nil]
		focusHolder: 	a SpToolbarButtonMorph(163457024)
		aBlock: 	[self mouseFocus: nil]
		w: 	a WorldMorph(341720576) [world]
		transformedEvent: 	[(20.0@20.0) mouseUp 12003100 nil]
	Receiver's instance variables: 
		bounds: 	(475@208.0) corner: (491@224.0)
		owner: 	a WorldMorph(341720576) [world]
		submorphs: 	#()
		fullBounds: 	(475@208.0) corner: (491@224.0)
		color: 	Color blue
		extension: 	a MorphExtension (370611968)
		mouseFocus: 	nil
		keyboardFocus: 	a RubEditingArea(143191808)
		eventListeners: 	nil
		mouseListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(475@208) mouseUp 12003100 nil]
		targetOffset: 	(20.0@15.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 0 0 0 0 0 nil nil)
		captureBlock: 	nil
		recentModifiers: 	0
		pendingEventQueue: 	WaitfreeQueue with 0 items
		supressNextKeyPress: 	false


HandMorph>>sendEvent:focus:clear:
	Receiver: a HandMorph(337424384)
	Arguments and temporary variables: 
		anEvent: 	[(475@208) mouseUp 12003100 nil]
		focusHolder: 	a SpToolbarButtonMorph(163457024)
		aBlock: 	[self mouseFocus: nil]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(475@208.0) corner: (491@224.0)
		owner: 	a WorldMorph(341720576) [world]
		submorphs: 	#()
		fullBounds: 	(475@208.0) corner: (491@224.0)
		color: 	Color blue
		extension: 	a MorphExtension (370611968)
		mouseFocus: 	nil
		keyboardFocus: 	a RubEditingArea(143191808)
		eventListeners: 	nil
		mouseListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(475@208) mouseUp 12003100 nil]
		targetOffset: 	(20.0@15.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 0 0 0 0 0 nil nil)
		captureBlock: 	nil
		recentModifiers: 	0
		pendingEventQueue: 	WaitfreeQueue with 0 items
		supressNextKeyPress: 	false


HandMorph>>sendMouseEvent:
	Receiver: a HandMorph(337424384)
	Arguments and temporary variables: 
		anEvent: 	[(475@208) mouseUp 12003100 nil]
	Receiver's instance variables: 
		bounds: 	(475@208.0) corner: (491@224.0)
		owner: 	a WorldMorph(341720576) [world]
		submorphs: 	#()
		fullBounds: 	(475@208.0) corner: (491@224.0)
		color: 	Color blue
		extension: 	a MorphExtension (370611968)
		mouseFocus: 	nil
		keyboardFocus: 	a RubEditingArea(143191808)
		eventListeners: 	nil
		mouseListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(475@208) mouseUp 12003100 nil]
		targetOffset: 	(20.0@15.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 0 0 0 0 0 nil nil)
		captureBlock: 	nil
		recentModifiers: 	0
		pendingEventQueue: 	WaitfreeQueue with 0 items
		supressNextKeyPress: 	false


HandMorph>>handleEvent:
	Receiver: a HandMorph(337424384)
	Arguments and temporary variables: 
		anEvent: 	[(475@208) mouseUp 12003100 nil]
		evt: 	[(475@208) mouseUp 12003100 nil]
	Receiver's instance variables: 
		bounds: 	(475@208.0) corner: (491@224.0)
		owner: 	a WorldMorph(341720576) [world]
		submorphs: 	#()
		fullBounds: 	(475@208.0) corner: (491@224.0)
		color: 	Color blue
		extension: 	a MorphExtension (370611968)
		mouseFocus: 	nil
		keyboardFocus: 	a RubEditingArea(143191808)
		eventListeners: 	nil
		mouseListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(475@208) mouseUp 12003100 nil]
		targetOffset: 	(20.0@15.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 0 0 0 0 0 nil nil)
		captureBlock: 	nil
		recentModifiers: 	0
		pendingEventQueue: 	WaitfreeQueue with 0 items
		supressNextKeyPress: 	false


[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil ]) ifTrue: [
			morphicWorld activeHand handleEvent: anEvent
		]
	] in OSWindowMorphicEventHandler>>dispatchMorphicEvent:
	Receiver: an OSWindowMorphicEventHandler
	Arguments and temporary variables: 
		anEvent: 	[(475@208) mouseUp 12003100 nil]
	Receiver's instance variables: 
		morphicWorld: 	a WorldMorph(341720576) [world]


WorldState>>runStepMethodsIn:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(341720576) [world]
		queue: 	WaitfreeQueue with 0 items
		nextInQueue: 	[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNo[..]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(337424384))
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap()
		lastStepTime: 	11998217
		lastStepMessage: 	nil
		alarms: 	a Heap(MorphicAlarm(#hideShow -> a RubCursor(27124480)))
		lastAlarmTime: 	12003077
		activeHand: 	a HandMorph(337424384)
		currentCursor: 	((CursorWithMask
	extent: (16@16)
	depth: 1
	fromArray: #(
	[..]
		worldRenderer: 	an OSWorldRenderer
		realWindowExtent: 	(1728@1080)
		deferredUIMessages: 	WaitfreeQueue with 0 items


WorldMorph>>runStepMethods
	Receiver: a WorldMorph(341720576) [world]
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1728@1080)
		owner: 	nil
		submorphs: 	an Array(a MenubarMorph(112886016) a TaskbarMorph(279458560) a S[..]
		fullBounds: 	(0@0) corner: (1728@1080)
		color: 	(Color r: 0.9403714565004888 g: 0.9403714565004888 b: 0.940371456500[..]
		extension: 	a MorphExtension (1012946432) [other:  (dragEnabled -> true) (dr[..]
		borderWidth: 	0
		borderColor: 	(Color r: 0.8611925708699902 g: 1.0 b: 0.7223851417399805 alph[..]
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil


WorldState>>doOneCycleFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(341720576) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(337424384))
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap()
		lastStepTime: 	11998217
		lastStepMessage: 	nil
		alarms: 	a Heap(MorphicAlarm(#hideShow -> a RubCursor(27124480)))
		lastAlarmTime: 	12003077
		activeHand: 	a HandMorph(337424384)
		currentCursor: 	((CursorWithMask
	extent: (16@16)
	depth: 1
	fromArray: #(
	[..]
		worldRenderer: 	an OSWorldRenderer
		realWindowExtent: 	(1728@1080)
		deferredUIMessages: 	WaitfreeQueue with 0 items


WorldMorph>>doOneCycleNow
	Receiver: a WorldMorph(341720576) [world]
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1728@1080)
		owner: 	nil
		submorphs: 	an Array(a MenubarMorph(112886016) a TaskbarMorph(279458560) a S[..]
		fullBounds: 	(0@0) corner: (1728@1080)
		color: 	(Color r: 0.9403714565004888 g: 0.9403714565004888 b: 0.940371456500[..]
		extension: 	a MorphExtension (1012946432) [other:  (dragEnabled -> true) (dr[..]
		borderWidth: 	0
		borderColor: 	(Color r: 0.8611925708699902 g: 1.0 b: 0.7223851417399805 alph[..]
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil


WorldMorph>>doOneCycle
	Receiver: a WorldMorph(341720576) [world]
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1728@1080)
		owner: 	nil
		submorphs: 	an Array(a MenubarMorph(112886016) a TaskbarMorph(279458560) a S[..]
		fullBounds: 	(0@0) corner: (1728@1080)
		color: 	(Color r: 0.9403714565004888 g: 0.9403714565004888 b: 0.940371456500[..]
		extension: 	a MorphExtension (1012946432) [other:  (dragEnabled -> true) (dr[..]
		borderWidth: 	0
		borderColor: 	(Color r: 0.8611925708699902 g: 1.0 b: 0.7223851417399805 alph[..]
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil



--- The full stack ---
RSLine(Object)>>doesNotUnderstand: #start:
[ :edgeDict |
        | edge sourceNode targetNode sourcePosition targetPosition |
        sourceNode := nodesMap at: (edgeDict at: #source) ifAbsent: [ nil ].
        targetNode := nodesMap at: (edgeDict at: #target) ifAbsent: [ nil ].
        sourceNode ifNotNil: [ targetNode ifNotNil: [
            sourcePosition := sourceNode position.
            targetPosition := targetNode position.
            edge := RSLine new.
            edge start: sourcePosition; end: targetPosition.
            canvas add: edge.
        ]].
    ] in GraphVisualizer>>createEdges
Array(SequenceableCollection)>>do:
GraphVisualizer>>createEdges
GraphVisualizer>>visualizeGraphFromFile:
UndefinedObject>>DoIt
OCReceiverDoItSemanticScope(OCDoItSemanticScope)>>evaluateDoIt:
OpalCompiler>>evaluate
[
		self announcer announce: (SpCodeWillBeEvaluatedAnnouncement newContent: aString).
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionModel doItReceiver.
		result := receiver class compiler
			source: aString;
			context: self interactionModel doItContext;
			receiver: self interactionModel doItReceiver;
			requestor: self interactionModel;
			environment: self environment;
			failBlock:  [ 
				self announcer announce: (SpCodeEvaluationFailedAnnouncement newContent: aString).
				^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		self announcer announce: (SpCodeEvaluationSucceedAnnouncement newContent: aString).
		result ] in SpCodePresenter>>evaluate:onCompileError:onError:
FullBlockClosure(BlockClosure)>>on:do:
SpCodePresenter>>evaluate:onCompileError:onError:
StPlaygroundPagePresenter>>doEvaluateAndGo
StPlaygroundPagePresenter>>doEvaluateAllAndGo
StPlaygroundDoItCommand>>execute
SpCommand(CmCommandDecorator)>>execute
[ specCommand execute ] in [ :specCommand | 
			aButtonClass new
				label: specCommand name;
				help: specCommand description;
				in: [ :button | 
					specCommand hasIcon
						ifTrue: [ button icon: specCommand icon ] ];
				action: [ specCommand execute ];
				yourself ] in SpCommand>>configureAsButtonOfClass:
FullBlockClosure(BlockClosure)>>cull:
SpMorphicToolbarButtonAdapter>>execute
SpToolbarButtonMorph(PluggableButtonMorph)>>performAction:
[:m |
		(m containsPoint: evt cursorPoint) ifTrue: [m enabled ifTrue: [ m performAction: evt ]]] in SpToolbarButtonMorph(PluggableButtonMorph)>>mouseUp:
Array(SequenceableCollection)>>do:
SpToolbarButtonMorph(PluggableButtonMorph)>>mouseUp:
SpToolbarButtonMorph(Morph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
SpToolbarButtonMorph(Morph)>>handleEvent:
SpToolbarButtonMorph(Morph)>>handleFocusEvent:
[
		result := focusHolder handleFocusEvent: transformedEvent.
	] in HandMorph>>sendFocusEvent:to:clear:
FullBlockClosure(BlockClosure)>>on:do:
WorldMorph>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil ]) ifTrue: [
			morphicWorld activeHand handleEvent: anEvent
		]
	] in OSWindowMorphicEventHandler>>dispatchMorphicEvent:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycleNow
WorldMorph>>doOneCycle
 - - - - - - - - - - - - - - -
			- - - - - - - - - - - - - - - - - -
[
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMutex critical: [
			                     self extraWorldList ].
		extraWorldsToDraw do: [ :world | world doOneCycle ].

		(self currentWorld isNotNil and: [
			 (extraWorldsToDraw includes: self currentWorld) not ]) ifTrue: [
			self currentWorld doOneCycle ] ] in WorldMorph class>>doOneCycle
FullBlockClosure(BlockClosure)>>ensure:
WorldState class>>doDrawCycleWith:
WorldMorph class>>doOneCycle
MorphicRenderLoop>>doOneCycle
MorphicRenderLoop>>doOneCycleWhile:
[ MorphicRenderLoop new doOneCycleWhile: [ true ] ] in MorphicUIManager>>spawnNewProcess
[self value.
			"IMPORTANT: Do not step over next line of code. See method comments for details"
			Processor terminateRealActive] in FullBlockClosure(BlockClosure)>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
Instance of RSLine did not understand #start:
13 November 2023 7:31:09.367416 pm

VM: Mac OS - arm64 - 1000 - CoInterpreter VMMaker-tonel.1 uuid: 902dd483-c0c4-0d00-86f2-0f880df24b96 Oct 23 2023
StackToRegisterMappingCogit VMMaker-tonel.1 uuid: 902dd483-c0c4-0d00-86f2-0f880df24b96 Oct 23 2023
v10.0.8 - Commit: b323c5fb - Date: 2023-10-20 16:02:07 -0400

Image: Pharo11.0.0 [Build information: Pharo-11.0.0+build.710.sha.ea28d8552cac85a7ce1e9c34ab1e7bd45f7b9910 (64 Bit)]

RSLine(Object)>>doesNotUnderstand: #start:
	Receiver: a RSLine
	Arguments and temporary variables: 
		aMessage: 	start: (0@0)
		exception: 	Instance of RSLine did not understand #start:
		resumeValue: 	nil
	Receiver's instance variables: 
		announcer: 	nil
		properties: 	nil
		paint: 	nil
		path: 	nil
		border: 	1, Color gray
		parent: 	nil
		isFixed: 	false
		encompassingRectangle: 	nil
		model: 	nil
		attachPoint: 	a RSCenteredAttachPoint
		from: 	nil
		to: 	nil
		markers: 	nil
		startPoint: 	(0@0)
		endPoint: 	(100@100)


UndefinedObject>>DoIt
	Receiver: nil
	Arguments and temporary variables: 
		box: 	a RSBox
		line: 	a RSLine
	Receiver's instance variables: 
nil

OCReceiverDoItSemanticScope(OCDoItSemanticScope)>>evaluateDoIt:
	Receiver: an OCReceiverDoItSemanticScope
	Arguments and temporary variables: 
		doItMethod: 	UndefinedObject>>#DoIt
	Receiver's instance variables: 
		outerScope: 	nil
		targetReceiver: 	nil


OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
		doItMethod: 	UndefinedObject>>#DoIt
	Receiver's instance variables: 
		ast: 	DoIt

	| box line |
	box := RSBox new.
	Transcript
		show: box positio[..]
		source: 	a ReadStream
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil


[
		self announcer announce: (SpCodeWillBeEvaluatedAnnouncement newContent: aString).
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionModel doItReceiver.
		result := receiver class compiler
			source: aString;
			context: self interactionModel doItContext;
			receiver: self interactionModel doItReceiver;
			requestor: self interactionModel;
			environment: self environment;
			failBlock:  [ 
				self announcer announce: (SpCodeEvaluationFailedAnnouncement newContent: aString).
				^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		self announcer announce: (SpCodeEvaluationSucceedAnnouncement newContent: aString).
		result ] in SpCodePresenter>>evaluate:onCompileError:onError:
	Receiver: a SpCodePresenter
	Arguments and temporary variables: 
		aString: 	'| box line |
box := RSBox new.
Transcript show: box position prin[..]
		compileErrorBlock: 	[ ^ self ]
		errorBlock: 	[ :e | e pass ]
		receiver: 	nil
		result: 	nil
		oldBindings: 	a Dictionary()
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicCodeAdapter)
		announcer: 	an Announcer
		owner: 	a StPlaygroundPagePresenter
		adapter: 	a SpMorphicCodeAdapter
		needRebuild: 	true
		eventHandler: 	a SpEventHandler
		application: 	nil
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ a KMCategory ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Code' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpAbstractWidgetLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		borderWidth: 	an ObservableValueHolder[ nil ]
		borderColor: 	an ObservableValueHolder[ nil ]
		dragEnabled: 	an ObservableValueHolder[ false ]
		dropEnabled: 	an ObservableValueHolder[ false ]
		color: 	an ObservableValueHolder[ nil ]
		help: 	an ObservableValueHolder[ nil ]
		enabled: 	an ObservableValueHolder[ true ]
		wantsDrop: 	an ObservableValueHolder[ [ :transfer | self dropEnabled ] ]
		acceptDrop: 	an ObservableValueHolder[ [ :transfer | ] ]
		deferredActions: 	nil
		hasUnacceptedEdits: 	an ObservableValueHolder[ false ]
		selection: 	an ObservableValueHolder[ (1 to: 173) ]
		wantsVisualFeedback: 	an ObservableValueHolder[ true ]
		askBeforeDiscardingEdits: 	an ObservableValueHolder[ true ]
		text: 	an ObservableValueHolder[ '| box line |
box := RSBox new.
Transcript [..]
		actionToPerform: 	an ObservableValueHolder[ [ :txt |  ] ]
		readSelection: 	an ObservableValueHolder[ [ selection ] ]
		placeholder: 	an ObservableValueHolder[ '' ]
		contextMenu: 	an ObservableValueHolder[ [ (self menuActionsFor: text) asMenu[..]
		scrollValue: 	an ObservableValueHolder[ (0@0) ]
		editionContextMenu: 	an ObservableValueHolder[ true ]
		editable: 	an ObservableValueHolder[ true ]
		wrapWord: 	an ObservableValueHolder[ true ]
		undoRedoHistory: 	true
		wrapScrollBars: 	true
		propagateNaturalHeight: 	false
		propagateNaturalWidth: 	false
		scrollBarStyles: 	#()
		syntaxHighlight: 	an ObservableValueHolder[ true ]
		smartCharacters: 	an ObservableValueHolder[ true ]
		lineNumbers: 	an ObservableValueHolder[ true ]
		interactionModel: 	an ObservableValueHolder[ a StPlaygroundInteractionModel ]
		overrideContextMenu: 	true
		submitBlock: 	nil
		resetBlock: 	nil
		environment: 	nil
		systemNavigation: 	nil
		syntaxHighlightTheme: 	an ObservableValueHolder[ nil ]


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
		self announcer announce: (SpCodeWillBeEvaluatedAnnouncement newContent: aString).
[..]
	Arguments and temporary variables: 
		exception: 	Error
		handlerAction: 	[ :e |
		self announcer announce: (SpCodeEvaluationFailedAnn[..]
	Receiver's instance variables: 
		outerContext: 	SpCodePresenter>>evaluate:onCompileError:onError:
		compiledBlock: 	a CompiledBlock: [
		self announcer announce: (SpCodeWillBeE[..]
		numArgs: 	0
		receiver: 	a SpCodePresenter


SpCodePresenter>>evaluate:onCompileError:onError:
	Receiver: a SpCodePresenter
	Arguments and temporary variables: 
		receiver: 	nil
		result: 	nil
		oldBindings: 	a Dictionary()
		aString: 	'| box line |
box := RSBox new.
Transcript show: box position prin[..]
		compileErrorBlock: 	[ ^ self ]
		errorBlock: 	[ :e | e pass ]
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicCodeAdapter)
		announcer: 	an Announcer
		owner: 	a StPlaygroundPagePresenter
		adapter: 	a SpMorphicCodeAdapter
		needRebuild: 	true
		eventHandler: 	a SpEventHandler
		application: 	nil
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ a KMCategory ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Code' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpAbstractWidgetLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		borderWidth: 	an ObservableValueHolder[ nil ]
		borderColor: 	an ObservableValueHolder[ nil ]
		dragEnabled: 	an ObservableValueHolder[ false ]
		dropEnabled: 	an ObservableValueHolder[ false ]
		color: 	an ObservableValueHolder[ nil ]
		help: 	an ObservableValueHolder[ nil ]
		enabled: 	an ObservableValueHolder[ true ]
		wantsDrop: 	an ObservableValueHolder[ [ :transfer | self dropEnabled ] ]
		acceptDrop: 	an ObservableValueHolder[ [ :transfer | ] ]
		deferredActions: 	nil
		hasUnacceptedEdits: 	an ObservableValueHolder[ false ]
		selection: 	an ObservableValueHolder[ (1 to: 173) ]
		wantsVisualFeedback: 	an ObservableValueHolder[ true ]
		askBeforeDiscardingEdits: 	an ObservableValueHolder[ true ]
		text: 	an ObservableValueHolder[ '| box line |
box := RSBox new.
Transcript [..]
		actionToPerform: 	an ObservableValueHolder[ [ :txt |  ] ]
		readSelection: 	an ObservableValueHolder[ [ selection ] ]
		placeholder: 	an ObservableValueHolder[ '' ]
		contextMenu: 	an ObservableValueHolder[ [ (self menuActionsFor: text) asMenu[..]
		scrollValue: 	an ObservableValueHolder[ (0@0) ]
		editionContextMenu: 	an ObservableValueHolder[ true ]
		editable: 	an ObservableValueHolder[ true ]
		wrapWord: 	an ObservableValueHolder[ true ]
		undoRedoHistory: 	true
		wrapScrollBars: 	true
		propagateNaturalHeight: 	false
		propagateNaturalWidth: 	false
		scrollBarStyles: 	#()
		syntaxHighlight: 	an ObservableValueHolder[ true ]
		smartCharacters: 	an ObservableValueHolder[ true ]
		lineNumbers: 	an ObservableValueHolder[ true ]
		interactionModel: 	an ObservableValueHolder[ a StPlaygroundInteractionModel ]
		overrideContextMenu: 	true
		submitBlock: 	nil
		resetBlock: 	nil
		environment: 	nil
		systemNavigation: 	nil
		syntaxHighlightTheme: 	an ObservableValueHolder[ nil ]


StPlaygroundPagePresenter>>doEvaluateAndGo
	Receiver: a StPlaygroundPagePresenter
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicBoxAdapter)
		announcer: 	an Announcer
		owner: 	a SpMillerColumnPresenter
		adapter: 	a SpMorphicBoxAdapter
		needRebuild: 	true
		eventHandler: 	nil
		application: 	a StPharoApplication
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ nil ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Untitled window' ]
		additionalSubpresentersMap: 	a Dictionary()
		layout: 	an ObservableValueHolder[ a SpBoxLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		text: 	a SpCodePresenter
		toolbar: 	a SpToolbarPresenter
		statusbar: 	a SpPresenter
		lineLabel: 	a SpLabelPresenter
		toggleLineNumberButton: 	a SpToggleButtonPresenter
		page: 	a StPlaygroundPage
		activationBlock: 	[ :selection |
		self changeSelection: selection from: new[..]


StPlaygroundPagePresenter>>doEvaluateAllAndGo
	Receiver: a StPlaygroundPagePresenter
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicBoxAdapter)
		announcer: 	an Announcer
		owner: 	a SpMillerColumnPresenter
		adapter: 	a SpMorphicBoxAdapter
		needRebuild: 	true
		eventHandler: 	nil
		application: 	a StPharoApplication
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ nil ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Untitled window' ]
		additionalSubpresentersMap: 	a Dictionary()
		layout: 	an ObservableValueHolder[ a SpBoxLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		text: 	a SpCodePresenter
		toolbar: 	a SpToolbarPresenter
		statusbar: 	a SpPresenter
		lineLabel: 	a SpLabelPresenter
		toggleLineNumberButton: 	a SpToggleButtonPresenter
		page: 	a StPlaygroundPage
		activationBlock: 	[ :selection |
		self changeSelection: selection from: new[..]


StPlaygroundDoItCommand>>execute
	Receiver: a StPlaygroundDoItCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		context: 	a StPlaygroundPagePresenter
		basicName: 	'Do it'
		basicDescription: 	'Do it all and inspect.'


SpCommand(CmCommandDecorator)>>execute
	Receiver: a SpCommand(Do it)
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a StPlaygroundDoItCommand
		iconProvider: 	a StPharoApplication
		iconName: 	#glamorousGo
		shortcutKey: 	nil
		displayStrategy: 	a CmUIDisableWhenCantBeRun
		positionStrategy: 	a CmUILeftPositionStrategy
		buildPresenterBlock: 	[ :specCommand | 
			aButtonClass new
				label: specC[..]
		presenter: 	a SpToolbarButtonPresenter


[ specCommand execute ] in [ :specCommand | 
			aButtonClass new
				label: specCommand name;
				help: specCommand description;
				in: [ :button | 
					specCommand hasIcon
						ifTrue: [ button icon: specCommand icon ] ];
				action: [ specCommand execute ];
				yourself ] in SpCommand>>configureAsButtonOfClass:
	Receiver: a SpCommand(Do it)
	Arguments and temporary variables: 
		aButtonClass: 	nil
		specCommand: 	a SpCommand(Do it)
	Receiver's instance variables: 
		decoratedCommand: 	a StPlaygroundDoItCommand
		iconProvider: 	a StPharoApplication
		iconName: 	#glamorousGo
		shortcutKey: 	nil
		displayStrategy: 	a CmUIDisableWhenCantBeRun
		positionStrategy: 	a CmUILeftPositionStrategy
		buildPresenterBlock: 	[ :specCommand | 
			aButtonClass new
				label: specC[..]
		presenter: 	a SpToolbarButtonPresenter


FullBlockClosure(BlockClosure)>>cull:
	Receiver: [ specCommand execute ]
	Arguments and temporary variables: 
		anArg: 	a SpToolbarButtonPresenter
	Receiver's instance variables: 
		outerContext: 	[ :specCommand | 
			aButtonClass new
				label: specCommand [..]
		compiledBlock: 	a CompiledBlock: [ specCommand execute ]
		numArgs: 	0
		receiver: 	a SpCommand(Do it)


SpMorphicToolbarButtonAdapter>>execute
	Receiver: a SpMorphicToolbarButtonAdapter
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpToolbarButtonMorph(493442816))
		announcer: 	nil
		model: 	a SpToolbarButtonPresenter
		widget: 	a SpToolbarButtonMorph(493442816)
		selector: 	nil
		owner: 	a SpToolbarButtonPresenter
		unsubscribed: 	false


SpToolbarButtonMorph(PluggableButtonMorph)>>performAction:
	Receiver: a SpToolbarButtonMorph(493442816)
	Arguments and temporary variables: 
		event: 	[(18.0@13.0) mouseUp 12387481 nil]
	Receiver's instance variables: 
		bounds: 	(0.0@5.0) corner: (45.0@39.0)
		owner: 	a Morph(787184128)
		submorphs: 	an Array(an AlignmentMorph(809072896))
		fullBounds: 	nil
		color: 	(Color r: 0.9012707722385142 g: 0.9012707722385142 b: 0.901270772238[..]
		extension: 	a MorphExtension (873985536) [balloonText]  [other:  (presenter [..]
		borderWidth: 	0
		borderColor: 	#simple
		model: 	a SpMorphicToolbarButtonAdapter
		label: 	'Do it'
		icon: 	Form(13x13x32)
		getIconSelector: 	#icon
		getStateSelector: 	#state
		actionSelector: 	#execute
		font: 	a LogicalFont
 familyName: 'Source Sans Pro'
 emphasis: nil
 pointSiz[..]
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	nil
		getFontSelector: 	nil
		labelMorph: 	a LabelMorph(288633600)'Do it'
		iconMorph: 	an ImageMorph(246778112)
		iconPosition: 	#top
		lastState: 	false
		badgeFont: 	nil
		badgeSelector: 	#badge


[:m |
		(m containsPoint: evt cursorPoint) ifTrue: [m enabled ifTrue: [ m performAction: evt ]]] in SpToolbarButtonMorph(PluggableButtonMorph)>>mouseUp:
	Receiver: a SpToolbarButtonMorph(493442816)
	Arguments and temporary variables: 
		evt: 	[(18.0@13.0) mouseUp 12387481 nil]
		all: 	an Array(a SpToolbarButtonMorph(493442816) a SpToolbarButtonMorph(9733[..]
		m: 	a SpToolbarButtonMorph(493442816)
	Receiver's instance variables: 
		bounds: 	(0.0@5.0) corner: (45.0@39.0)
		owner: 	a Morph(787184128)
		submorphs: 	an Array(an AlignmentMorph(809072896))
		fullBounds: 	nil
		color: 	(Color r: 0.9012707722385142 g: 0.9012707722385142 b: 0.901270772238[..]
		extension: 	a MorphExtension (873985536) [balloonText]  [other:  (presenter [..]
		borderWidth: 	0
		borderColor: 	#simple
		model: 	a SpMorphicToolbarButtonAdapter
		label: 	'Do it'
		icon: 	Form(13x13x32)
		getIconSelector: 	#icon
		getStateSelector: 	#state
		actionSelector: 	#execute
		font: 	a LogicalFont
 familyName: 'Source Sans Pro'
 emphasis: nil
 pointSiz[..]
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	nil
		getFontSelector: 	nil
		labelMorph: 	a LabelMorph(288633600)'Do it'
		iconMorph: 	an ImageMorph(246778112)
		iconPosition: 	#top
		lastState: 	false
		badgeFont: 	nil
		badgeSelector: 	#badge


Array(SequenceableCollection)>>do:
	Receiver: an Array(a SpToolbarButtonMorph(493442816) a SpToolbarButtonMorph(973364992) a SpToolb[..]
	Arguments and temporary variables: 
		aBlock: 	[:m |
		(m containsPoint: evt cursorPoint) ifTrue: [m enabled ifTru[..]
		index: 	1
	Receiver's instance variables: 
an Array(a SpToolbarButtonMorph(493442816) a SpToolbarButtonMorph(973364992) a SpToolb[..]

SpToolbarButtonMorph(PluggableButtonMorph)>>mouseUp:
	Receiver: a SpToolbarButtonMorph(493442816)
	Arguments and temporary variables: 
		evt: 	[(18.0@13.0) mouseUp 12387481 nil]
		all: 	an Array(a SpToolbarButtonMorph(493442816) a SpToolbarButtonMorph(9733[..]
	Receiver's instance variables: 
		bounds: 	(0.0@5.0) corner: (45.0@39.0)
		owner: 	a Morph(787184128)
		submorphs: 	an Array(an AlignmentMorph(809072896))
		fullBounds: 	nil
		color: 	(Color r: 0.9012707722385142 g: 0.9012707722385142 b: 0.901270772238[..]
		extension: 	a MorphExtension (873985536) [balloonText]  [other:  (presenter [..]
		borderWidth: 	0
		borderColor: 	#simple
		model: 	a SpMorphicToolbarButtonAdapter
		label: 	'Do it'
		icon: 	Form(13x13x32)
		getIconSelector: 	#icon
		getStateSelector: 	#state
		actionSelector: 	#execute
		font: 	a LogicalFont
 familyName: 'Source Sans Pro'
 emphasis: nil
 pointSiz[..]
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	nil
		getFontSelector: 	nil
		labelMorph: 	a LabelMorph(288633600)'Do it'
		iconMorph: 	an ImageMorph(246778112)
		iconPosition: 	#top
		lastState: 	false
		badgeFont: 	nil
		badgeSelector: 	#badge


SpToolbarButtonMorph(Morph)>>handleMouseUp:
	Receiver: a SpToolbarButtonMorph(493442816)
	Arguments and temporary variables: 
		anEvent: 	[(18.0@13.0) mouseUp 12387481 nil]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(0.0@5.0) corner: (45.0@39.0)
		owner: 	a Morph(787184128)
		submorphs: 	an Array(an AlignmentMorph(809072896))
		fullBounds: 	nil
		color: 	(Color r: 0.9012707722385142 g: 0.9012707722385142 b: 0.901270772238[..]
		extension: 	a MorphExtension (873985536) [balloonText]  [other:  (presenter [..]
		borderWidth: 	0
		borderColor: 	#simple
		model: 	a SpMorphicToolbarButtonAdapter
		label: 	'Do it'
		icon: 	Form(13x13x32)
		getIconSelector: 	#icon
		getStateSelector: 	#state
		actionSelector: 	#execute
		font: 	a LogicalFont
 familyName: 'Source Sans Pro'
 emphasis: nil
 pointSiz[..]
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	nil
		getFontSelector: 	nil
		labelMorph: 	a LabelMorph(288633600)'Do it'
		iconMorph: 	an ImageMorph(246778112)
		iconPosition: 	#top
		lastState: 	false
		badgeFont: 	nil
		badgeSelector: 	#badge


MouseButtonEvent>>sentTo:
	Receiver: [(18.0@13.0) mouseUp 12387481 nil]
	Arguments and temporary variables: 
		anObject: 	a SpToolbarButtonMorph(493442816)
	Receiver's instance variables: 
		timeStamp: 	12387481
		source: 	a HandMorph(337424384)
		windowIndex: 	nil
		type: 	#mouseUp
		buttons: 	0
		position: 	(18.0@13.0)
		handler: 	nil
		wasHandled: 	true
		whichButton: 	4


SpToolbarButtonMorph(Morph)>>handleEvent:
	Receiver: a SpToolbarButtonMorph(493442816)
	Arguments and temporary variables: 
		anEvent: 	[(18.0@13.0) mouseUp 12387481 nil]
	Receiver's instance variables: 
		bounds: 	(0.0@5.0) corner: (45.0@39.0)
		owner: 	a Morph(787184128)
		submorphs: 	an Array(an AlignmentMorph(809072896))
		fullBounds: 	nil
		color: 	(Color r: 0.9012707722385142 g: 0.9012707722385142 b: 0.901270772238[..]
		extension: 	a MorphExtension (873985536) [balloonText]  [other:  (presenter [..]
		borderWidth: 	0
		borderColor: 	#simple
		model: 	a SpMorphicToolbarButtonAdapter
		label: 	'Do it'
		icon: 	Form(13x13x32)
		getIconSelector: 	#icon
		getStateSelector: 	#state
		actionSelector: 	#execute
		font: 	a LogicalFont
 familyName: 'Source Sans Pro'
 emphasis: nil
 pointSiz[..]
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	nil
		getFontSelector: 	nil
		labelMorph: 	a LabelMorph(288633600)'Do it'
		iconMorph: 	an ImageMorph(246778112)
		iconPosition: 	#top
		lastState: 	false
		badgeFont: 	nil
		badgeSelector: 	#badge


SpToolbarButtonMorph(Morph)>>handleFocusEvent:
	Receiver: a SpToolbarButtonMorph(493442816)
	Arguments and temporary variables: 
		anEvent: 	[(18.0@13.0) mouseUp 12387481 nil]
	Receiver's instance variables: 
		bounds: 	(0.0@5.0) corner: (45.0@39.0)
		owner: 	a Morph(787184128)
		submorphs: 	an Array(an AlignmentMorph(809072896))
		fullBounds: 	nil
		color: 	(Color r: 0.9012707722385142 g: 0.9012707722385142 b: 0.901270772238[..]
		extension: 	a MorphExtension (873985536) [balloonText]  [other:  (presenter [..]
		borderWidth: 	0
		borderColor: 	#simple
		model: 	a SpMorphicToolbarButtonAdapter
		label: 	'Do it'
		icon: 	Form(13x13x32)
		getIconSelector: 	#icon
		getStateSelector: 	#state
		actionSelector: 	#execute
		font: 	a LogicalFont
 familyName: 'Source Sans Pro'
 emphasis: nil
 pointSiz[..]
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	nil
		getFontSelector: 	nil
		labelMorph: 	a LabelMorph(288633600)'Do it'
		iconMorph: 	an ImageMorph(246778112)
		iconPosition: 	#top
		lastState: 	false
		badgeFont: 	nil
		badgeSelector: 	#badge


[
		result := focusHolder handleFocusEvent: transformedEvent.
	] in HandMorph>>sendFocusEvent:to:clear:
	Receiver: a HandMorph(337424384)
	Arguments and temporary variables: 
		anEvent: 	[(537@331) mouseUp 12387481 nil]
		focusHolder: 	a SpToolbarButtonMorph(493442816)
		aBlock: 	[self mouseFocus: nil]
		w: 	a WorldMorph(341720576) [world]
		transformedEvent: 	[(18.0@13.0) mouseUp 12387481 nil]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(537@331.0) corner: (553@347.0)
		owner: 	a WorldMorph(341720576) [world]
		submorphs: 	#()
		fullBounds: 	(537@331.0) corner: (553@347.0)
		color: 	Color blue
		extension: 	a MorphExtension (370611968)
		mouseFocus: 	nil
		keyboardFocus: 	a RubEditingArea(890614272)
		eventListeners: 	nil
		mouseListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(537@331) mouseUp 12387481 nil]
		targetOffset: 	(18.0@8.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 0 0 0 0 0 nil nil)
		captureBlock: 	nil
		recentModifiers: 	0
		pendingEventQueue: 	WaitfreeQueue with 0 items
		supressNextKeyPress: 	false


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
		result := focusHolder handleFocusEvent: transformedEvent.
	]
	Arguments and temporary variables: 
		exception: 	Error
		handlerAction: 	[ :ex |
			ActiveWorld := priorWorld.
			ex pass ]
	Receiver's instance variables: 
		outerContext: 	HandMorph>>sendFocusEvent:to:clear:
		compiledBlock: 	a CompiledBlock: [
		result := focusHolder handleFocusEvent:[..]
		numArgs: 	0
		receiver: 	a HandMorph(337424384)


WorldMorph>>becomeActiveDuring:
	Receiver: a WorldMorph(341720576) [world]
	Arguments and temporary variables: 
		aBlock: 	[
		result := focusHolder handleFocusEvent: transformedEvent.
	]
		priorWorld: 	a WorldMorph(341720576) [world]
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1728@1080)
		owner: 	nil
		submorphs: 	an Array(a MenubarMorph(112886016) a TaskbarMorph(279458560) a S[..]
		fullBounds: 	(0@0) corner: (1728@1080)
		color: 	(Color r: 0.9403714565004888 g: 0.9403714565004888 b: 0.940371456500[..]
		extension: 	a MorphExtension (1012946432) [other:  (dragEnabled -> true) (dr[..]
		borderWidth: 	0
		borderColor: 	(Color r: 0.8611925708699902 g: 1.0 b: 0.7223851417399805 alph[..]
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil


HandMorph>>sendFocusEvent:to:clear:
	Receiver: a HandMorph(337424384)
	Arguments and temporary variables: 
		result: 	nil
		anEvent: 	[(537@331) mouseUp 12387481 nil]
		focusHolder: 	a SpToolbarButtonMorph(493442816)
		aBlock: 	[self mouseFocus: nil]
		w: 	a WorldMorph(341720576) [world]
		transformedEvent: 	[(18.0@13.0) mouseUp 12387481 nil]
	Receiver's instance variables: 
		bounds: 	(537@331.0) corner: (553@347.0)
		owner: 	a WorldMorph(341720576) [world]
		submorphs: 	#()
		fullBounds: 	(537@331.0) corner: (553@347.0)
		color: 	Color blue
		extension: 	a MorphExtension (370611968)
		mouseFocus: 	nil
		keyboardFocus: 	a RubEditingArea(890614272)
		eventListeners: 	nil
		mouseListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(537@331) mouseUp 12387481 nil]
		targetOffset: 	(18.0@8.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 0 0 0 0 0 nil nil)
		captureBlock: 	nil
		recentModifiers: 	0
		pendingEventQueue: 	WaitfreeQueue with 0 items
		supressNextKeyPress: 	false


HandMorph>>sendEvent:focus:clear:
	Receiver: a HandMorph(337424384)
	Arguments and temporary variables: 
		anEvent: 	[(537@331) mouseUp 12387481 nil]
		focusHolder: 	a SpToolbarButtonMorph(493442816)
		aBlock: 	[self mouseFocus: nil]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(537@331.0) corner: (553@347.0)
		owner: 	a WorldMorph(341720576) [world]
		submorphs: 	#()
		fullBounds: 	(537@331.0) corner: (553@347.0)
		color: 	Color blue
		extension: 	a MorphExtension (370611968)
		mouseFocus: 	nil
		keyboardFocus: 	a RubEditingArea(890614272)
		eventListeners: 	nil
		mouseListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(537@331) mouseUp 12387481 nil]
		targetOffset: 	(18.0@8.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 0 0 0 0 0 nil nil)
		captureBlock: 	nil
		recentModifiers: 	0
		pendingEventQueue: 	WaitfreeQueue with 0 items
		supressNextKeyPress: 	false


HandMorph>>sendMouseEvent:
	Receiver: a HandMorph(337424384)
	Arguments and temporary variables: 
		anEvent: 	[(537@331) mouseUp 12387481 nil]
	Receiver's instance variables: 
		bounds: 	(537@331.0) corner: (553@347.0)
		owner: 	a WorldMorph(341720576) [world]
		submorphs: 	#()
		fullBounds: 	(537@331.0) corner: (553@347.0)
		color: 	Color blue
		extension: 	a MorphExtension (370611968)
		mouseFocus: 	nil
		keyboardFocus: 	a RubEditingArea(890614272)
		eventListeners: 	nil
		mouseListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(537@331) mouseUp 12387481 nil]
		targetOffset: 	(18.0@8.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 0 0 0 0 0 nil nil)
		captureBlock: 	nil
		recentModifiers: 	0
		pendingEventQueue: 	WaitfreeQueue with 0 items
		supressNextKeyPress: 	false


HandMorph>>handleEvent:
	Receiver: a HandMorph(337424384)
	Arguments and temporary variables: 
		anEvent: 	[(537@331) mouseUp 12387481 nil]
		evt: 	[(537@331) mouseUp 12387481 nil]
	Receiver's instance variables: 
		bounds: 	(537@331.0) corner: (553@347.0)
		owner: 	a WorldMorph(341720576) [world]
		submorphs: 	#()
		fullBounds: 	(537@331.0) corner: (553@347.0)
		color: 	Color blue
		extension: 	a MorphExtension (370611968)
		mouseFocus: 	nil
		keyboardFocus: 	a RubEditingArea(890614272)
		eventListeners: 	nil
		mouseListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(537@331) mouseUp 12387481 nil]
		targetOffset: 	(18.0@8.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 0 0 0 0 0 nil nil)
		captureBlock: 	nil
		recentModifiers: 	0
		pendingEventQueue: 	WaitfreeQueue with 0 items
		supressNextKeyPress: 	false


[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil ]) ifTrue: [
			morphicWorld activeHand handleEvent: anEvent
		]
	] in OSWindowMorphicEventHandler>>dispatchMorphicEvent:
	Receiver: an OSWindowMorphicEventHandler
	Arguments and temporary variables: 
		anEvent: 	[(537@331) mouseUp 12387481 nil]
	Receiver's instance variables: 
		morphicWorld: 	a WorldMorph(341720576) [world]


WorldState>>runStepMethodsIn:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(341720576) [world]
		queue: 	WaitfreeQueue with 0 items
		nextInQueue: 	[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNo[..]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(337424384))
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap()
		lastStepTime: 	11998217
		lastStepMessage: 	nil
		alarms: 	a Heap(MorphicAlarm(#hideShow -> a RubCursor(593311744)))
		lastAlarmTime: 	12387460
		activeHand: 	a HandMorph(337424384)
		currentCursor: 	((CursorWithMask
	extent: (16@16)
	depth: 1
	fromArray: #(
	[..]
		worldRenderer: 	an OSWorldRenderer
		realWindowExtent: 	(1728@1080)
		deferredUIMessages: 	WaitfreeQueue with 0 items


WorldMorph>>runStepMethods
	Receiver: a WorldMorph(341720576) [world]
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1728@1080)
		owner: 	nil
		submorphs: 	an Array(a MenubarMorph(112886016) a TaskbarMorph(279458560) a S[..]
		fullBounds: 	(0@0) corner: (1728@1080)
		color: 	(Color r: 0.9403714565004888 g: 0.9403714565004888 b: 0.940371456500[..]
		extension: 	a MorphExtension (1012946432) [other:  (dragEnabled -> true) (dr[..]
		borderWidth: 	0
		borderColor: 	(Color r: 0.8611925708699902 g: 1.0 b: 0.7223851417399805 alph[..]
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil


WorldState>>doOneCycleFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(341720576) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(337424384))
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap()
		lastStepTime: 	11998217
		lastStepMessage: 	nil
		alarms: 	a Heap(MorphicAlarm(#hideShow -> a RubCursor(593311744)))
		lastAlarmTime: 	12387460
		activeHand: 	a HandMorph(337424384)
		currentCursor: 	((CursorWithMask
	extent: (16@16)
	depth: 1
	fromArray: #(
	[..]
		worldRenderer: 	an OSWorldRenderer
		realWindowExtent: 	(1728@1080)
		deferredUIMessages: 	WaitfreeQueue with 0 items


WorldMorph>>doOneCycleNow
	Receiver: a WorldMorph(341720576) [world]
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1728@1080)
		owner: 	nil
		submorphs: 	an Array(a MenubarMorph(112886016) a TaskbarMorph(279458560) a S[..]
		fullBounds: 	(0@0) corner: (1728@1080)
		color: 	(Color r: 0.9403714565004888 g: 0.9403714565004888 b: 0.940371456500[..]
		extension: 	a MorphExtension (1012946432) [other:  (dragEnabled -> true) (dr[..]
		borderWidth: 	0
		borderColor: 	(Color r: 0.8611925708699902 g: 1.0 b: 0.7223851417399805 alph[..]
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil


WorldMorph>>doOneCycle
	Receiver: a WorldMorph(341720576) [world]
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1728@1080)
		owner: 	nil
		submorphs: 	an Array(a MenubarMorph(112886016) a TaskbarMorph(279458560) a S[..]
		fullBounds: 	(0@0) corner: (1728@1080)
		color: 	(Color r: 0.9403714565004888 g: 0.9403714565004888 b: 0.940371456500[..]
		extension: 	a MorphExtension (1012946432) [other:  (dragEnabled -> true) (dr[..]
		borderWidth: 	0
		borderColor: 	(Color r: 0.8611925708699902 g: 1.0 b: 0.7223851417399805 alph[..]
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil


[
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMutex critical: [
			                     self extraWorldList ].
		extraWorldsToDraw do: [ :world | world doOneCycle ].

		(self currentWorld isNotNil and: [
			 (extraWorldsToDraw includes: self currentWorld) not ]) ifTrue: [
			self currentWorld doOneCycle ] ] in WorldMorph class>>doOneCycle
	Receiver: WorldMorph
	Arguments and temporary variables: 
		extraWorldsToDraw: 	#()
	Receiver's instance variables: 
		superclass: 	PasteUpMorph
		methodDict: 	a MethodDictionary(#acceptDroppingMorph:event:->WorldMorph>>#ac[..]
		format: 	65547
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		commentSourcePointer: 	nil
		subclasses: 	{AthensWorldMorph. OSWindowWorldMorph}
		name: 	#WorldMorph
		classPool: 	a Dictionary(#AllowDropFiles->nil #CursorOwnerWorld->a WorldMorp[..]
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Morphic-Core-Worlds'
		announcer: 	nil
		displayScaleFactor: 	1


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMutex critical: [
			  [..]
	Arguments and temporary variables: 
		aBlock: 	[
		self doInterCycleWait
	]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	WorldMorph class>>doOneCycle
		compiledBlock: 	a CompiledBlock: [
		| extraWorldsToDraw |
		extraWorldsToDr[..]
		numArgs: 	0
		receiver: 	WorldMorph


WorldState class>>doDrawCycleWith:
	Receiver: WorldState
	Arguments and temporary variables: 
		aBlock: 	[
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMute[..]
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary(#activeHand->WorldState>>#activeHand #active[..]
		format: 	65548
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		commentSourcePointer: 	nil
		subclasses: 	{AthensWorldState}
		name: 	#WorldState
		classPool: 	a Dictionary(#CanSurrenderToOS->nil #DebugShowDamage->false #Des[..]
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Morphic-Core-Worlds'


WorldMorph class>>doOneCycle
	Receiver: WorldMorph
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		superclass: 	PasteUpMorph
		methodDict: 	a MethodDictionary(#acceptDroppingMorph:event:->WorldMorph>>#ac[..]
		format: 	65547
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		commentSourcePointer: 	nil
		subclasses: 	{AthensWorldMorph. OSWindowWorldMorph}
		name: 	#WorldMorph
		classPool: 	a Dictionary(#AllowDropFiles->nil #CursorOwnerWorld->a WorldMorp[..]
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Morphic-Core-Worlds'
		announcer: 	nil
		displayScaleFactor: 	1



--- The full stack ---
RSLine(Object)>>doesNotUnderstand: #start:
UndefinedObject>>DoIt
OCReceiverDoItSemanticScope(OCDoItSemanticScope)>>evaluateDoIt:
OpalCompiler>>evaluate
[
		self announcer announce: (SpCodeWillBeEvaluatedAnnouncement newContent: aString).
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionModel doItReceiver.
		result := receiver class compiler
			source: aString;
			context: self interactionModel doItContext;
			receiver: self interactionModel doItReceiver;
			requestor: self interactionModel;
			environment: self environment;
			failBlock:  [ 
				self announcer announce: (SpCodeEvaluationFailedAnnouncement newContent: aString).
				^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		self announcer announce: (SpCodeEvaluationSucceedAnnouncement newContent: aString).
		result ] in SpCodePresenter>>evaluate:onCompileError:onError:
FullBlockClosure(BlockClosure)>>on:do:
SpCodePresenter>>evaluate:onCompileError:onError:
StPlaygroundPagePresenter>>doEvaluateAndGo
StPlaygroundPagePresenter>>doEvaluateAllAndGo
StPlaygroundDoItCommand>>execute
SpCommand(CmCommandDecorator)>>execute
[ specCommand execute ] in [ :specCommand | 
			aButtonClass new
				label: specCommand name;
				help: specCommand description;
				in: [ :button | 
					specCommand hasIcon
						ifTrue: [ button icon: specCommand icon ] ];
				action: [ specCommand execute ];
				yourself ] in SpCommand>>configureAsButtonOfClass:
FullBlockClosure(BlockClosure)>>cull:
SpMorphicToolbarButtonAdapter>>execute
SpToolbarButtonMorph(PluggableButtonMorph)>>performAction:
[:m |
		(m containsPoint: evt cursorPoint) ifTrue: [m enabled ifTrue: [ m performAction: evt ]]] in SpToolbarButtonMorph(PluggableButtonMorph)>>mouseUp:
Array(SequenceableCollection)>>do:
SpToolbarButtonMorph(PluggableButtonMorph)>>mouseUp:
SpToolbarButtonMorph(Morph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
SpToolbarButtonMorph(Morph)>>handleEvent:
SpToolbarButtonMorph(Morph)>>handleFocusEvent:
[
		result := focusHolder handleFocusEvent: transformedEvent.
	] in HandMorph>>sendFocusEvent:to:clear:
FullBlockClosure(BlockClosure)>>on:do:
WorldMorph>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil ]) ifTrue: [
			morphicWorld activeHand handleEvent: anEvent
		]
	] in OSWindowMorphicEventHandler>>dispatchMorphicEvent:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycleNow
WorldMorph>>doOneCycle
[
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMutex critical: [
			                     self extraWorldList ].
		extraWorldsToDraw do: [ :world | world doOneCycle ].

		(self currentWorld isNotNil and: [
			 (extraWorldsToDraw includes: self currentWorld) not ]) ifTrue: [
			self currentWorld doOneCycle ] ] in WorldMorph class>>doOneCycle
FullBlockClosure(BlockClosure)>>ensure:
WorldState class>>doDrawCycleWith:
WorldMorph class>>doOneCycle
 - - - - - - - - - - - - - - -
			- - - - - - - - - - - - - - - - - -
MorphicRenderLoop>>doOneCycle
MorphicRenderLoop>>doOneCycleWhile:
[ MorphicRenderLoop new doOneCycleWhile: [ true ] ] in MorphicUIManager>>spawnNewProcess
[self value.
			"IMPORTANT: Do not step over next line of code. See method comments for details"
			Processor terminateRealActive] in FullBlockClosure(BlockClosure)>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
Instance of RSLine did not understand #start:
13 November 2023 7:31:09.389564 pm

VM: Mac OS - arm64 - 1000 - CoInterpreter VMMaker-tonel.1 uuid: 902dd483-c0c4-0d00-86f2-0f880df24b96 Oct 23 2023
StackToRegisterMappingCogit VMMaker-tonel.1 uuid: 902dd483-c0c4-0d00-86f2-0f880df24b96 Oct 23 2023
v10.0.8 - Commit: b323c5fb - Date: 2023-10-20 16:02:07 -0400

Image: Pharo11.0.0 [Build information: Pharo-11.0.0+build.710.sha.ea28d8552cac85a7ce1e9c34ab1e7bd45f7b9910 (64 Bit)]

RSLine(Object)>>doesNotUnderstand: #start:
	Receiver: a RSLine
	Arguments and temporary variables: 
		aMessage: 	start: (0@0)
		exception: 	Instance of RSLine did not understand #start:
		resumeValue: 	nil
	Receiver's instance variables: 
		announcer: 	nil
		properties: 	nil
		paint: 	nil
		path: 	nil
		border: 	1, Color gray
		parent: 	nil
		isFixed: 	false
		encompassingRectangle: 	nil
		model: 	nil
		attachPoint: 	a RSCenteredAttachPoint
		from: 	nil
		to: 	nil
		markers: 	nil
		startPoint: 	(0@0)
		endPoint: 	(100@100)


UndefinedObject>>DoIt
	Receiver: nil
	Arguments and temporary variables: 
		box: 	a RSBox
		line: 	a RSLine
	Receiver's instance variables: 
nil

OCReceiverDoItSemanticScope(OCDoItSemanticScope)>>evaluateDoIt:
	Receiver: an OCReceiverDoItSemanticScope
	Arguments and temporary variables: 
		doItMethod: 	UndefinedObject>>#DoIt
	Receiver's instance variables: 
		outerScope: 	nil
		targetReceiver: 	nil


OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
		doItMethod: 	UndefinedObject>>#DoIt
	Receiver's instance variables: 
		ast: 	DoIt

	| box line |
	box := RSBox new.
	Transcript
		show: box positio[..]
		source: 	a ReadStream
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil


[
		self announcer announce: (SpCodeWillBeEvaluatedAnnouncement newContent: aString).
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionModel doItReceiver.
		result := receiver class compiler
			source: aString;
			context: self interactionModel doItContext;
			receiver: self interactionModel doItReceiver;
			requestor: self interactionModel;
			environment: self environment;
			failBlock:  [ 
				self announcer announce: (SpCodeEvaluationFailedAnnouncement newContent: aString).
				^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		self announcer announce: (SpCodeEvaluationSucceedAnnouncement newContent: aString).
		result ] in SpCodePresenter>>evaluate:onCompileError:onError:
	Receiver: a SpCodePresenter
	Arguments and temporary variables: 
		aString: 	'| box line |
box := RSBox new.
Transcript show: box position prin[..]
		compileErrorBlock: 	[ ^ self ]
		errorBlock: 	[ :e | e pass ]
		receiver: 	nil
		result: 	nil
		oldBindings: 	a Dictionary()
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicCodeAdapter)
		announcer: 	an Announcer
		owner: 	a StPlaygroundPagePresenter
		adapter: 	a SpMorphicCodeAdapter
		needRebuild: 	true
		eventHandler: 	a SpEventHandler
		application: 	nil
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ a KMCategory ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Code' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpAbstractWidgetLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		borderWidth: 	an ObservableValueHolder[ nil ]
		borderColor: 	an ObservableValueHolder[ nil ]
		dragEnabled: 	an ObservableValueHolder[ false ]
		dropEnabled: 	an ObservableValueHolder[ false ]
		color: 	an ObservableValueHolder[ nil ]
		help: 	an ObservableValueHolder[ nil ]
		enabled: 	an ObservableValueHolder[ true ]
		wantsDrop: 	an ObservableValueHolder[ [ :transfer | self dropEnabled ] ]
		acceptDrop: 	an ObservableValueHolder[ [ :transfer | ] ]
		deferredActions: 	nil
		hasUnacceptedEdits: 	an ObservableValueHolder[ false ]
		selection: 	an ObservableValueHolder[ (1 to: 173) ]
		wantsVisualFeedback: 	an ObservableValueHolder[ true ]
		askBeforeDiscardingEdits: 	an ObservableValueHolder[ true ]
		text: 	an ObservableValueHolder[ '| box line |
box := RSBox new.
Transcript [..]
		actionToPerform: 	an ObservableValueHolder[ [ :txt |  ] ]
		readSelection: 	an ObservableValueHolder[ [ selection ] ]
		placeholder: 	an ObservableValueHolder[ '' ]
		contextMenu: 	an ObservableValueHolder[ [ (self menuActionsFor: text) asMenu[..]
		scrollValue: 	an ObservableValueHolder[ (0@0) ]
		editionContextMenu: 	an ObservableValueHolder[ true ]
		editable: 	an ObservableValueHolder[ true ]
		wrapWord: 	an ObservableValueHolder[ true ]
		undoRedoHistory: 	true
		wrapScrollBars: 	true
		propagateNaturalHeight: 	false
		propagateNaturalWidth: 	false
		scrollBarStyles: 	#()
		syntaxHighlight: 	an ObservableValueHolder[ true ]
		smartCharacters: 	an ObservableValueHolder[ true ]
		lineNumbers: 	an ObservableValueHolder[ true ]
		interactionModel: 	an ObservableValueHolder[ a StPlaygroundInteractionModel ]
		overrideContextMenu: 	true
		submitBlock: 	nil
		resetBlock: 	nil
		environment: 	nil
		systemNavigation: 	nil
		syntaxHighlightTheme: 	an ObservableValueHolder[ nil ]


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
		self announcer announce: (SpCodeWillBeEvaluatedAnnouncement newContent: aString).
[..]
	Arguments and temporary variables: 
		exception: 	Error
		handlerAction: 	[ :e |
		self announcer announce: (SpCodeEvaluationFailedAnn[..]
	Receiver's instance variables: 
		outerContext: 	SpCodePresenter>>evaluate:onCompileError:onError:
		compiledBlock: 	a CompiledBlock: [
		self announcer announce: (SpCodeWillBeE[..]
		numArgs: 	0
		receiver: 	a SpCodePresenter


SpCodePresenter>>evaluate:onCompileError:onError:
	Receiver: a SpCodePresenter
	Arguments and temporary variables: 
		receiver: 	nil
		result: 	nil
		oldBindings: 	a Dictionary()
		aString: 	'| box line |
box := RSBox new.
Transcript show: box position prin[..]
		compileErrorBlock: 	[ ^ self ]
		errorBlock: 	[ :e | e pass ]
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicCodeAdapter)
		announcer: 	an Announcer
		owner: 	a StPlaygroundPagePresenter
		adapter: 	a SpMorphicCodeAdapter
		needRebuild: 	true
		eventHandler: 	a SpEventHandler
		application: 	nil
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ a KMCategory ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Code' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpAbstractWidgetLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		borderWidth: 	an ObservableValueHolder[ nil ]
		borderColor: 	an ObservableValueHolder[ nil ]
		dragEnabled: 	an ObservableValueHolder[ false ]
		dropEnabled: 	an ObservableValueHolder[ false ]
		color: 	an ObservableValueHolder[ nil ]
		help: 	an ObservableValueHolder[ nil ]
		enabled: 	an ObservableValueHolder[ true ]
		wantsDrop: 	an ObservableValueHolder[ [ :transfer | self dropEnabled ] ]
		acceptDrop: 	an ObservableValueHolder[ [ :transfer | ] ]
		deferredActions: 	nil
		hasUnacceptedEdits: 	an ObservableValueHolder[ false ]
		selection: 	an ObservableValueHolder[ (1 to: 173) ]
		wantsVisualFeedback: 	an ObservableValueHolder[ true ]
		askBeforeDiscardingEdits: 	an ObservableValueHolder[ true ]
		text: 	an ObservableValueHolder[ '| box line |
box := RSBox new.
Transcript [..]
		actionToPerform: 	an ObservableValueHolder[ [ :txt |  ] ]
		readSelection: 	an ObservableValueHolder[ [ selection ] ]
		placeholder: 	an ObservableValueHolder[ '' ]
		contextMenu: 	an ObservableValueHolder[ [ (self menuActionsFor: text) asMenu[..]
		scrollValue: 	an ObservableValueHolder[ (0@0) ]
		editionContextMenu: 	an ObservableValueHolder[ true ]
		editable: 	an ObservableValueHolder[ true ]
		wrapWord: 	an ObservableValueHolder[ true ]
		undoRedoHistory: 	true
		wrapScrollBars: 	true
		propagateNaturalHeight: 	false
		propagateNaturalWidth: 	false
		scrollBarStyles: 	#()
		syntaxHighlight: 	an ObservableValueHolder[ true ]
		smartCharacters: 	an ObservableValueHolder[ true ]
		lineNumbers: 	an ObservableValueHolder[ true ]
		interactionModel: 	an ObservableValueHolder[ a StPlaygroundInteractionModel ]
		overrideContextMenu: 	true
		submitBlock: 	nil
		resetBlock: 	nil
		environment: 	nil
		systemNavigation: 	nil
		syntaxHighlightTheme: 	an ObservableValueHolder[ nil ]


StPlaygroundPagePresenter>>doEvaluateAndGo
	Receiver: a StPlaygroundPagePresenter
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicBoxAdapter)
		announcer: 	an Announcer
		owner: 	a SpMillerColumnPresenter
		adapter: 	a SpMorphicBoxAdapter
		needRebuild: 	true
		eventHandler: 	nil
		application: 	a StPharoApplication
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ nil ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Untitled window' ]
		additionalSubpresentersMap: 	a Dictionary()
		layout: 	an ObservableValueHolder[ a SpBoxLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		text: 	a SpCodePresenter
		toolbar: 	a SpToolbarPresenter
		statusbar: 	a SpPresenter
		lineLabel: 	a SpLabelPresenter
		toggleLineNumberButton: 	a SpToggleButtonPresenter
		page: 	a StPlaygroundPage
		activationBlock: 	[ :selection |
		self changeSelection: selection from: new[..]


StPlaygroundPagePresenter>>doEvaluateAllAndGo
	Receiver: a StPlaygroundPagePresenter
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicBoxAdapter)
		announcer: 	an Announcer
		owner: 	a SpMillerColumnPresenter
		adapter: 	a SpMorphicBoxAdapter
		needRebuild: 	true
		eventHandler: 	nil
		application: 	a StPharoApplication
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ nil ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Untitled window' ]
		additionalSubpresentersMap: 	a Dictionary()
		layout: 	an ObservableValueHolder[ a SpBoxLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		text: 	a SpCodePresenter
		toolbar: 	a SpToolbarPresenter
		statusbar: 	a SpPresenter
		lineLabel: 	a SpLabelPresenter
		toggleLineNumberButton: 	a SpToggleButtonPresenter
		page: 	a StPlaygroundPage
		activationBlock: 	[ :selection |
		self changeSelection: selection from: new[..]


StPlaygroundDoItCommand>>execute
	Receiver: a StPlaygroundDoItCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		context: 	a StPlaygroundPagePresenter
		basicName: 	'Do it'
		basicDescription: 	'Do it all and inspect.'


SpCommand(CmCommandDecorator)>>execute
	Receiver: a SpCommand(Do it)
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a StPlaygroundDoItCommand
		iconProvider: 	a StPharoApplication
		iconName: 	#glamorousGo
		shortcutKey: 	nil
		displayStrategy: 	a CmUIDisableWhenCantBeRun
		positionStrategy: 	a CmUILeftPositionStrategy
		buildPresenterBlock: 	[ :specCommand | 
			aButtonClass new
				label: specC[..]
		presenter: 	a SpToolbarButtonPresenter


[ specCommand execute ] in [ :specCommand | 
			aButtonClass new
				label: specCommand name;
				help: specCommand description;
				in: [ :button | 
					specCommand hasIcon
						ifTrue: [ button icon: specCommand icon ] ];
				action: [ specCommand execute ];
				yourself ] in SpCommand>>configureAsButtonOfClass:
	Receiver: a SpCommand(Do it)
	Arguments and temporary variables: 
		aButtonClass: 	nil
		specCommand: 	a SpCommand(Do it)
	Receiver's instance variables: 
		decoratedCommand: 	a StPlaygroundDoItCommand
		iconProvider: 	a StPharoApplication
		iconName: 	#glamorousGo
		shortcutKey: 	nil
		displayStrategy: 	a CmUIDisableWhenCantBeRun
		positionStrategy: 	a CmUILeftPositionStrategy
		buildPresenterBlock: 	[ :specCommand | 
			aButtonClass new
				label: specC[..]
		presenter: 	a SpToolbarButtonPresenter


FullBlockClosure(BlockClosure)>>cull:
	Receiver: [ specCommand execute ]
	Arguments and temporary variables: 
		anArg: 	a SpToolbarButtonPresenter
	Receiver's instance variables: 
		outerContext: 	[ :specCommand | 
			aButtonClass new
				label: specCommand [..]
		compiledBlock: 	a CompiledBlock: [ specCommand execute ]
		numArgs: 	0
		receiver: 	a SpCommand(Do it)


SpMorphicToolbarButtonAdapter>>execute
	Receiver: a SpMorphicToolbarButtonAdapter
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpToolbarButtonMorph(493442816))
		announcer: 	nil
		model: 	a SpToolbarButtonPresenter
		widget: 	a SpToolbarButtonMorph(493442816)
		selector: 	nil
		owner: 	a SpToolbarButtonPresenter
		unsubscribed: 	false


SpToolbarButtonMorph(PluggableButtonMorph)>>performAction:
	Receiver: a SpToolbarButtonMorph(493442816)
	Arguments and temporary variables: 
		event: 	[(18.0@13.0) mouseUp 12387481 nil]
	Receiver's instance variables: 
		bounds: 	(0.0@5.0) corner: (45.0@39.0)
		owner: 	a Morph(787184128)
		submorphs: 	an Array(an AlignmentMorph(809072896))
		fullBounds: 	nil
		color: 	(Color r: 0.9012707722385142 g: 0.9012707722385142 b: 0.901270772238[..]
		extension: 	a MorphExtension (873985536) [balloonText]  [other:  (presenter [..]
		borderWidth: 	0
		borderColor: 	#simple
		model: 	a SpMorphicToolbarButtonAdapter
		label: 	'Do it'
		icon: 	Form(13x13x32)
		getIconSelector: 	#icon
		getStateSelector: 	#state
		actionSelector: 	#execute
		font: 	a LogicalFont
 familyName: 'Source Sans Pro'
 emphasis: nil
 pointSiz[..]
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	nil
		getFontSelector: 	nil
		labelMorph: 	a LabelMorph(288633600)'Do it'
		iconMorph: 	an ImageMorph(246778112)
		iconPosition: 	#top
		lastState: 	false
		badgeFont: 	nil
		badgeSelector: 	#badge


[:m |
		(m containsPoint: evt cursorPoint) ifTrue: [m enabled ifTrue: [ m performAction: evt ]]] in SpToolbarButtonMorph(PluggableButtonMorph)>>mouseUp:
	Receiver: a SpToolbarButtonMorph(493442816)
	Arguments and temporary variables: 
		evt: 	[(18.0@13.0) mouseUp 12387481 nil]
		all: 	an Array(a SpToolbarButtonMorph(493442816) a SpToolbarButtonMorph(9733[..]
		m: 	a SpToolbarButtonMorph(493442816)
	Receiver's instance variables: 
		bounds: 	(0.0@5.0) corner: (45.0@39.0)
		owner: 	a Morph(787184128)
		submorphs: 	an Array(an AlignmentMorph(809072896))
		fullBounds: 	nil
		color: 	(Color r: 0.9012707722385142 g: 0.9012707722385142 b: 0.901270772238[..]
		extension: 	a MorphExtension (873985536) [balloonText]  [other:  (presenter [..]
		borderWidth: 	0
		borderColor: 	#simple
		model: 	a SpMorphicToolbarButtonAdapter
		label: 	'Do it'
		icon: 	Form(13x13x32)
		getIconSelector: 	#icon
		getStateSelector: 	#state
		actionSelector: 	#execute
		font: 	a LogicalFont
 familyName: 'Source Sans Pro'
 emphasis: nil
 pointSiz[..]
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	nil
		getFontSelector: 	nil
		labelMorph: 	a LabelMorph(288633600)'Do it'
		iconMorph: 	an ImageMorph(246778112)
		iconPosition: 	#top
		lastState: 	false
		badgeFont: 	nil
		badgeSelector: 	#badge


Array(SequenceableCollection)>>do:
	Receiver: an Array(a SpToolbarButtonMorph(493442816) a SpToolbarButtonMorph(973364992) a SpToolb[..]
	Arguments and temporary variables: 
		aBlock: 	[:m |
		(m containsPoint: evt cursorPoint) ifTrue: [m enabled ifTru[..]
		index: 	1
	Receiver's instance variables: 
an Array(a SpToolbarButtonMorph(493442816) a SpToolbarButtonMorph(973364992) a SpToolb[..]

SpToolbarButtonMorph(PluggableButtonMorph)>>mouseUp:
	Receiver: a SpToolbarButtonMorph(493442816)
	Arguments and temporary variables: 
		evt: 	[(18.0@13.0) mouseUp 12387481 nil]
		all: 	an Array(a SpToolbarButtonMorph(493442816) a SpToolbarButtonMorph(9733[..]
	Receiver's instance variables: 
		bounds: 	(0.0@5.0) corner: (45.0@39.0)
		owner: 	a Morph(787184128)
		submorphs: 	an Array(an AlignmentMorph(809072896))
		fullBounds: 	nil
		color: 	(Color r: 0.9012707722385142 g: 0.9012707722385142 b: 0.901270772238[..]
		extension: 	a MorphExtension (873985536) [balloonText]  [other:  (presenter [..]
		borderWidth: 	0
		borderColor: 	#simple
		model: 	a SpMorphicToolbarButtonAdapter
		label: 	'Do it'
		icon: 	Form(13x13x32)
		getIconSelector: 	#icon
		getStateSelector: 	#state
		actionSelector: 	#execute
		font: 	a LogicalFont
 familyName: 'Source Sans Pro'
 emphasis: nil
 pointSiz[..]
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	nil
		getFontSelector: 	nil
		labelMorph: 	a LabelMorph(288633600)'Do it'
		iconMorph: 	an ImageMorph(246778112)
		iconPosition: 	#top
		lastState: 	false
		badgeFont: 	nil
		badgeSelector: 	#badge


SpToolbarButtonMorph(Morph)>>handleMouseUp:
	Receiver: a SpToolbarButtonMorph(493442816)
	Arguments and temporary variables: 
		anEvent: 	[(18.0@13.0) mouseUp 12387481 nil]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(0.0@5.0) corner: (45.0@39.0)
		owner: 	a Morph(787184128)
		submorphs: 	an Array(an AlignmentMorph(809072896))
		fullBounds: 	nil
		color: 	(Color r: 0.9012707722385142 g: 0.9012707722385142 b: 0.901270772238[..]
		extension: 	a MorphExtension (873985536) [balloonText]  [other:  (presenter [..]
		borderWidth: 	0
		borderColor: 	#simple
		model: 	a SpMorphicToolbarButtonAdapter
		label: 	'Do it'
		icon: 	Form(13x13x32)
		getIconSelector: 	#icon
		getStateSelector: 	#state
		actionSelector: 	#execute
		font: 	a LogicalFont
 familyName: 'Source Sans Pro'
 emphasis: nil
 pointSiz[..]
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	nil
		getFontSelector: 	nil
		labelMorph: 	a LabelMorph(288633600)'Do it'
		iconMorph: 	an ImageMorph(246778112)
		iconPosition: 	#top
		lastState: 	false
		badgeFont: 	nil
		badgeSelector: 	#badge


MouseButtonEvent>>sentTo:
	Receiver: [(18.0@13.0) mouseUp 12387481 nil]
	Arguments and temporary variables: 
		anObject: 	a SpToolbarButtonMorph(493442816)
	Receiver's instance variables: 
		timeStamp: 	12387481
		source: 	a HandMorph(337424384)
		windowIndex: 	nil
		type: 	#mouseUp
		buttons: 	0
		position: 	(18.0@13.0)
		handler: 	nil
		wasHandled: 	true
		whichButton: 	4


SpToolbarButtonMorph(Morph)>>handleEvent:
	Receiver: a SpToolbarButtonMorph(493442816)
	Arguments and temporary variables: 
		anEvent: 	[(18.0@13.0) mouseUp 12387481 nil]
	Receiver's instance variables: 
		bounds: 	(0.0@5.0) corner: (45.0@39.0)
		owner: 	a Morph(787184128)
		submorphs: 	an Array(an AlignmentMorph(809072896))
		fullBounds: 	nil
		color: 	(Color r: 0.9012707722385142 g: 0.9012707722385142 b: 0.901270772238[..]
		extension: 	a MorphExtension (873985536) [balloonText]  [other:  (presenter [..]
		borderWidth: 	0
		borderColor: 	#simple
		model: 	a SpMorphicToolbarButtonAdapter
		label: 	'Do it'
		icon: 	Form(13x13x32)
		getIconSelector: 	#icon
		getStateSelector: 	#state
		actionSelector: 	#execute
		font: 	a LogicalFont
 familyName: 'Source Sans Pro'
 emphasis: nil
 pointSiz[..]
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	nil
		getFontSelector: 	nil
		labelMorph: 	a LabelMorph(288633600)'Do it'
		iconMorph: 	an ImageMorph(246778112)
		iconPosition: 	#top
		lastState: 	false
		badgeFont: 	nil
		badgeSelector: 	#badge


SpToolbarButtonMorph(Morph)>>handleFocusEvent:
	Receiver: a SpToolbarButtonMorph(493442816)
	Arguments and temporary variables: 
		anEvent: 	[(18.0@13.0) mouseUp 12387481 nil]
	Receiver's instance variables: 
		bounds: 	(0.0@5.0) corner: (45.0@39.0)
		owner: 	a Morph(787184128)
		submorphs: 	an Array(an AlignmentMorph(809072896))
		fullBounds: 	nil
		color: 	(Color r: 0.9012707722385142 g: 0.9012707722385142 b: 0.901270772238[..]
		extension: 	a MorphExtension (873985536) [balloonText]  [other:  (presenter [..]
		borderWidth: 	0
		borderColor: 	#simple
		model: 	a SpMorphicToolbarButtonAdapter
		label: 	'Do it'
		icon: 	Form(13x13x32)
		getIconSelector: 	#icon
		getStateSelector: 	#state
		actionSelector: 	#execute
		font: 	a LogicalFont
 familyName: 'Source Sans Pro'
 emphasis: nil
 pointSiz[..]
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	nil
		getFontSelector: 	nil
		labelMorph: 	a LabelMorph(288633600)'Do it'
		iconMorph: 	an ImageMorph(246778112)
		iconPosition: 	#top
		lastState: 	false
		badgeFont: 	nil
		badgeSelector: 	#badge


[
		result := focusHolder handleFocusEvent: transformedEvent.
	] in HandMorph>>sendFocusEvent:to:clear:
	Receiver: a HandMorph(337424384)
	Arguments and temporary variables: 
		anEvent: 	[(537@331) mouseUp 12387481 nil]
		focusHolder: 	a SpToolbarButtonMorph(493442816)
		aBlock: 	[self mouseFocus: nil]
		w: 	a WorldMorph(341720576) [world]
		transformedEvent: 	[(18.0@13.0) mouseUp 12387481 nil]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(537@331.0) corner: (553@347.0)
		owner: 	a WorldMorph(341720576) [world]
		submorphs: 	#()
		fullBounds: 	(537@331.0) corner: (553@347.0)
		color: 	Color blue
		extension: 	a MorphExtension (370611968)
		mouseFocus: 	nil
		keyboardFocus: 	a RubEditingArea(890614272)
		eventListeners: 	nil
		mouseListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(537@331) mouseUp 12387481 nil]
		targetOffset: 	(18.0@8.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 0 0 0 0 0 nil nil)
		captureBlock: 	nil
		recentModifiers: 	0
		pendingEventQueue: 	WaitfreeQueue with 0 items
		supressNextKeyPress: 	false


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
		result := focusHolder handleFocusEvent: transformedEvent.
	]
	Arguments and temporary variables: 
		exception: 	Error
		handlerAction: 	[ :ex |
			ActiveWorld := priorWorld.
			ex pass ]
	Receiver's instance variables: 
		outerContext: 	HandMorph>>sendFocusEvent:to:clear:
		compiledBlock: 	a CompiledBlock: [
		result := focusHolder handleFocusEvent:[..]
		numArgs: 	0
		receiver: 	a HandMorph(337424384)


WorldMorph>>becomeActiveDuring:
	Receiver: a WorldMorph(341720576) [world]
	Arguments and temporary variables: 
		aBlock: 	[
		result := focusHolder handleFocusEvent: transformedEvent.
	]
		priorWorld: 	a WorldMorph(341720576) [world]
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1728@1080)
		owner: 	nil
		submorphs: 	an Array(a MenubarMorph(112886016) a TaskbarMorph(279458560) a S[..]
		fullBounds: 	(0@0) corner: (1728@1080)
		color: 	(Color r: 0.9403714565004888 g: 0.9403714565004888 b: 0.940371456500[..]
		extension: 	a MorphExtension (1012946432) [other:  (dragEnabled -> true) (dr[..]
		borderWidth: 	0
		borderColor: 	(Color r: 0.8611925708699902 g: 1.0 b: 0.7223851417399805 alph[..]
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil


HandMorph>>sendFocusEvent:to:clear:
	Receiver: a HandMorph(337424384)
	Arguments and temporary variables: 
		result: 	nil
		anEvent: 	[(537@331) mouseUp 12387481 nil]
		focusHolder: 	a SpToolbarButtonMorph(493442816)
		aBlock: 	[self mouseFocus: nil]
		w: 	a WorldMorph(341720576) [world]
		transformedEvent: 	[(18.0@13.0) mouseUp 12387481 nil]
	Receiver's instance variables: 
		bounds: 	(537@331.0) corner: (553@347.0)
		owner: 	a WorldMorph(341720576) [world]
		submorphs: 	#()
		fullBounds: 	(537@331.0) corner: (553@347.0)
		color: 	Color blue
		extension: 	a MorphExtension (370611968)
		mouseFocus: 	nil
		keyboardFocus: 	a RubEditingArea(890614272)
		eventListeners: 	nil
		mouseListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(537@331) mouseUp 12387481 nil]
		targetOffset: 	(18.0@8.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 0 0 0 0 0 nil nil)
		captureBlock: 	nil
		recentModifiers: 	0
		pendingEventQueue: 	WaitfreeQueue with 0 items
		supressNextKeyPress: 	false


HandMorph>>sendEvent:focus:clear:
	Receiver: a HandMorph(337424384)
	Arguments and temporary variables: 
		anEvent: 	[(537@331) mouseUp 12387481 nil]
		focusHolder: 	a SpToolbarButtonMorph(493442816)
		aBlock: 	[self mouseFocus: nil]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(537@331.0) corner: (553@347.0)
		owner: 	a WorldMorph(341720576) [world]
		submorphs: 	#()
		fullBounds: 	(537@331.0) corner: (553@347.0)
		color: 	Color blue
		extension: 	a MorphExtension (370611968)
		mouseFocus: 	nil
		keyboardFocus: 	a RubEditingArea(890614272)
		eventListeners: 	nil
		mouseListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(537@331) mouseUp 12387481 nil]
		targetOffset: 	(18.0@8.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 0 0 0 0 0 nil nil)
		captureBlock: 	nil
		recentModifiers: 	0
		pendingEventQueue: 	WaitfreeQueue with 0 items
		supressNextKeyPress: 	false


HandMorph>>sendMouseEvent:
	Receiver: a HandMorph(337424384)
	Arguments and temporary variables: 
		anEvent: 	[(537@331) mouseUp 12387481 nil]
	Receiver's instance variables: 
		bounds: 	(537@331.0) corner: (553@347.0)
		owner: 	a WorldMorph(341720576) [world]
		submorphs: 	#()
		fullBounds: 	(537@331.0) corner: (553@347.0)
		color: 	Color blue
		extension: 	a MorphExtension (370611968)
		mouseFocus: 	nil
		keyboardFocus: 	a RubEditingArea(890614272)
		eventListeners: 	nil
		mouseListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(537@331) mouseUp 12387481 nil]
		targetOffset: 	(18.0@8.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 0 0 0 0 0 nil nil)
		captureBlock: 	nil
		recentModifiers: 	0
		pendingEventQueue: 	WaitfreeQueue with 0 items
		supressNextKeyPress: 	false


HandMorph>>handleEvent:
	Receiver: a HandMorph(337424384)
	Arguments and temporary variables: 
		anEvent: 	[(537@331) mouseUp 12387481 nil]
		evt: 	[(537@331) mouseUp 12387481 nil]
	Receiver's instance variables: 
		bounds: 	(537@331.0) corner: (553@347.0)
		owner: 	a WorldMorph(341720576) [world]
		submorphs: 	#()
		fullBounds: 	(537@331.0) corner: (553@347.0)
		color: 	Color blue
		extension: 	a MorphExtension (370611968)
		mouseFocus: 	nil
		keyboardFocus: 	a RubEditingArea(890614272)
		eventListeners: 	nil
		mouseListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(537@331) mouseUp 12387481 nil]
		targetOffset: 	(18.0@8.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 0 0 0 0 0 nil nil)
		captureBlock: 	nil
		recentModifiers: 	0
		pendingEventQueue: 	WaitfreeQueue with 0 items
		supressNextKeyPress: 	false


[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil ]) ifTrue: [
			morphicWorld activeHand handleEvent: anEvent
		]
	] in OSWindowMorphicEventHandler>>dispatchMorphicEvent:
	Receiver: an OSWindowMorphicEventHandler
	Arguments and temporary variables: 
		anEvent: 	[(537@331) mouseUp 12387481 nil]
	Receiver's instance variables: 
		morphicWorld: 	a WorldMorph(341720576) [world]


WorldState>>runStepMethodsIn:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(341720576) [world]
		queue: 	WaitfreeQueue with 0 items
		nextInQueue: 	[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNo[..]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(337424384))
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap()
		lastStepTime: 	11998217
		lastStepMessage: 	nil
		alarms: 	a Heap(MorphicAlarm(#hideShow -> a RubCursor(593311744)))
		lastAlarmTime: 	12387460
		activeHand: 	a HandMorph(337424384)
		currentCursor: 	((CursorWithMask
	extent: (16@16)
	depth: 1
	fromArray: #(
	[..]
		worldRenderer: 	an OSWorldRenderer
		realWindowExtent: 	(1728@1080)
		deferredUIMessages: 	WaitfreeQueue with 0 items


WorldMorph>>runStepMethods
	Receiver: a WorldMorph(341720576) [world]
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1728@1080)
		owner: 	nil
		submorphs: 	an Array(a MenubarMorph(112886016) a TaskbarMorph(279458560) a S[..]
		fullBounds: 	(0@0) corner: (1728@1080)
		color: 	(Color r: 0.9403714565004888 g: 0.9403714565004888 b: 0.940371456500[..]
		extension: 	a MorphExtension (1012946432) [other:  (dragEnabled -> true) (dr[..]
		borderWidth: 	0
		borderColor: 	(Color r: 0.8611925708699902 g: 1.0 b: 0.7223851417399805 alph[..]
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil


WorldState>>doOneCycleFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(341720576) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(337424384))
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap()
		lastStepTime: 	11998217
		lastStepMessage: 	nil
		alarms: 	a Heap(MorphicAlarm(#hideShow -> a RubCursor(593311744)))
		lastAlarmTime: 	12387460
		activeHand: 	a HandMorph(337424384)
		currentCursor: 	((CursorWithMask
	extent: (16@16)
	depth: 1
	fromArray: #(
	[..]
		worldRenderer: 	an OSWorldRenderer
		realWindowExtent: 	(1728@1080)
		deferredUIMessages: 	WaitfreeQueue with 0 items


WorldMorph>>doOneCycleNow
	Receiver: a WorldMorph(341720576) [world]
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1728@1080)
		owner: 	nil
		submorphs: 	an Array(a MenubarMorph(112886016) a TaskbarMorph(279458560) a S[..]
		fullBounds: 	(0@0) corner: (1728@1080)
		color: 	(Color r: 0.9403714565004888 g: 0.9403714565004888 b: 0.940371456500[..]
		extension: 	a MorphExtension (1012946432) [other:  (dragEnabled -> true) (dr[..]
		borderWidth: 	0
		borderColor: 	(Color r: 0.8611925708699902 g: 1.0 b: 0.7223851417399805 alph[..]
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil


WorldMorph>>doOneCycle
	Receiver: a WorldMorph(341720576) [world]
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1728@1080)
		owner: 	nil
		submorphs: 	an Array(a MenubarMorph(112886016) a TaskbarMorph(279458560) a S[..]
		fullBounds: 	(0@0) corner: (1728@1080)
		color: 	(Color r: 0.9403714565004888 g: 0.9403714565004888 b: 0.940371456500[..]
		extension: 	a MorphExtension (1012946432) [other:  (dragEnabled -> true) (dr[..]
		borderWidth: 	0
		borderColor: 	(Color r: 0.8611925708699902 g: 1.0 b: 0.7223851417399805 alph[..]
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil


[
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMutex critical: [
			                     self extraWorldList ].
		extraWorldsToDraw do: [ :world | world doOneCycle ].

		(self currentWorld isNotNil and: [
			 (extraWorldsToDraw includes: self currentWorld) not ]) ifTrue: [
			self currentWorld doOneCycle ] ] in WorldMorph class>>doOneCycle
	Receiver: WorldMorph
	Arguments and temporary variables: 
		extraWorldsToDraw: 	#()
	Receiver's instance variables: 
		superclass: 	PasteUpMorph
		methodDict: 	a MethodDictionary(#acceptDroppingMorph:event:->WorldMorph>>#ac[..]
		format: 	65547
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		commentSourcePointer: 	nil
		subclasses: 	{AthensWorldMorph. OSWindowWorldMorph}
		name: 	#WorldMorph
		classPool: 	a Dictionary(#AllowDropFiles->nil #CursorOwnerWorld->a WorldMorp[..]
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Morphic-Core-Worlds'
		announcer: 	nil
		displayScaleFactor: 	1


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMutex critical: [
			  [..]
	Arguments and temporary variables: 
		aBlock: 	[
		self doInterCycleWait
	]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	WorldMorph class>>doOneCycle
		compiledBlock: 	a CompiledBlock: [
		| extraWorldsToDraw |
		extraWorldsToDr[..]
		numArgs: 	0
		receiver: 	WorldMorph


WorldState class>>doDrawCycleWith:
	Receiver: WorldState
	Arguments and temporary variables: 
		aBlock: 	[
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMute[..]
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary(#activeHand->WorldState>>#activeHand #active[..]
		format: 	65548
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		commentSourcePointer: 	nil
		subclasses: 	{AthensWorldState}
		name: 	#WorldState
		classPool: 	a Dictionary(#CanSurrenderToOS->nil #DebugShowDamage->false #Des[..]
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Morphic-Core-Worlds'


WorldMorph class>>doOneCycle
	Receiver: WorldMorph
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		superclass: 	PasteUpMorph
		methodDict: 	a MethodDictionary(#acceptDroppingMorph:event:->WorldMorph>>#ac[..]
		format: 	65547
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		commentSourcePointer: 	nil
		subclasses: 	{AthensWorldMorph. OSWindowWorldMorph}
		name: 	#WorldMorph
		classPool: 	a Dictionary(#AllowDropFiles->nil #CursorOwnerWorld->a WorldMorp[..]
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Morphic-Core-Worlds'
		announcer: 	nil
		displayScaleFactor: 	1



--- The full stack ---
RSLine(Object)>>doesNotUnderstand: #start:
UndefinedObject>>DoIt
OCReceiverDoItSemanticScope(OCDoItSemanticScope)>>evaluateDoIt:
OpalCompiler>>evaluate
[
		self announcer announce: (SpCodeWillBeEvaluatedAnnouncement newContent: aString).
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionModel doItReceiver.
		result := receiver class compiler
			source: aString;
			context: self interactionModel doItContext;
			receiver: self interactionModel doItReceiver;
			requestor: self interactionModel;
			environment: self environment;
			failBlock:  [ 
				self announcer announce: (SpCodeEvaluationFailedAnnouncement newContent: aString).
				^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		self announcer announce: (SpCodeEvaluationSucceedAnnouncement newContent: aString).
		result ] in SpCodePresenter>>evaluate:onCompileError:onError:
FullBlockClosure(BlockClosure)>>on:do:
SpCodePresenter>>evaluate:onCompileError:onError:
StPlaygroundPagePresenter>>doEvaluateAndGo
StPlaygroundPagePresenter>>doEvaluateAllAndGo
StPlaygroundDoItCommand>>execute
SpCommand(CmCommandDecorator)>>execute
[ specCommand execute ] in [ :specCommand | 
			aButtonClass new
				label: specCommand name;
				help: specCommand description;
				in: [ :button | 
					specCommand hasIcon
						ifTrue: [ button icon: specCommand icon ] ];
				action: [ specCommand execute ];
				yourself ] in SpCommand>>configureAsButtonOfClass:
FullBlockClosure(BlockClosure)>>cull:
SpMorphicToolbarButtonAdapter>>execute
SpToolbarButtonMorph(PluggableButtonMorph)>>performAction:
[:m |
		(m containsPoint: evt cursorPoint) ifTrue: [m enabled ifTrue: [ m performAction: evt ]]] in SpToolbarButtonMorph(PluggableButtonMorph)>>mouseUp:
Array(SequenceableCollection)>>do:
SpToolbarButtonMorph(PluggableButtonMorph)>>mouseUp:
SpToolbarButtonMorph(Morph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
SpToolbarButtonMorph(Morph)>>handleEvent:
SpToolbarButtonMorph(Morph)>>handleFocusEvent:
[
		result := focusHolder handleFocusEvent: transformedEvent.
	] in HandMorph>>sendFocusEvent:to:clear:
FullBlockClosure(BlockClosure)>>on:do:
WorldMorph>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil ]) ifTrue: [
			morphicWorld activeHand handleEvent: anEvent
		]
	] in OSWindowMorphicEventHandler>>dispatchMorphicEvent:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycleNow
WorldMorph>>doOneCycle
[
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMutex critical: [
			                     self extraWorldList ].
		extraWorldsToDraw do: [ :world | world doOneCycle ].

		(self currentWorld isNotNil and: [
			 (extraWorldsToDraw includes: self currentWorld) not ]) ifTrue: [
			self currentWorld doOneCycle ] ] in WorldMorph class>>doOneCycle
FullBlockClosure(BlockClosure)>>ensure:
WorldState class>>doDrawCycleWith:
WorldMorph class>>doOneCycle
 - - - - - - - - - - - - - - -
			- - - - - - - - - - - - - - - - - -
MorphicRenderLoop>>doOneCycle
MorphicRenderLoop>>doOneCycleWhile:
[ MorphicRenderLoop new doOneCycleWhile: [ true ] ] in MorphicUIManager>>spawnNewProcess
[self value.
			"IMPORTANT: Do not step over next line of code. See method comments for details"
			Processor terminateRealActive] in FullBlockClosure(BlockClosure)>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
Instance of ZnCharacterReadStream did not understand #isEmpty
13 November 2023 7:55:57.648634 pm

VM: Mac OS - arm64 - 1000 - CoInterpreter VMMaker-tonel.1 uuid: 902dd483-c0c4-0d00-86f2-0f880df24b96 Oct 23 2023
StackToRegisterMappingCogit VMMaker-tonel.1 uuid: 902dd483-c0c4-0d00-86f2-0f880df24b96 Oct 23 2023
v10.0.8 - Commit: b323c5fb - Date: 2023-10-20 16:02:07 -0400

Image: Pharo11.0.0 [Build information: Pharo-11.0.0+build.710.sha.ea28d8552cac85a7ce1e9c34ab1e7bd45f7b9910 (64 Bit)]

ZnCharacterReadStream(Object)>>doesNotUnderstand: #isEmpty
	Receiver: a ZnCharacterReadStream
	Arguments and temporary variables: 
		aMessage: 	isEmpty
		exception: 	Instance of ZnCharacterReadStream did not understand #isEmpty
		resumeValue: 	nil
	Receiver's instance variables: 
		stream: 	a ZnBufferedReadStream
		encoder: 	a ZnUTF8Encoder
		peeked: 	nil


Path class>>from:delimiter:
	Receiver: Path
	Arguments and temporary variables: 
		aString: 	a ZnCharacterReadStream
		aDelimiterCharacter: 	$/
		pathClass: 	nil
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary(#,->Path>>#, #/->Path>>#/ #'<='->Path>>#'<='[..]
		format: 	131072
		layout: 	a VariableLayout
		organization: 	a ClassOrganization
		commentSourcePointer: 	nil
		subclasses: 	{AbsolutePath. RelativePath. UNCNetworkPath}
		name: 	#Path
		classPool: 	nil
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'FileSystem-Path-Base'


MacStore(FileSystemStore)>>pathFromString:
	Receiver: a MacStore
	Arguments and temporary variables: 
		aString: 	a ZnCharacterReadStream
	Receiver's instance variables: 
		maxFileNameLength: 	255


FileSystem>>pathFromString:
	Receiver: a FileSystem
	Arguments and temporary variables: 
		aString: 	a ZnCharacterReadStream
	Receiver's instance variables: 
		store: 	a MacStore


FileReference(AbstractFileReference)>>/
	Receiver: File @ /Users/ryanperez/Documents/GitHub/pp-rep2533/project/src/visualizer/Smalltalk
	Arguments and temporary variables: 
		aString: 	a ZnCharacterReadStream
	Receiver's instance variables: 
		path: 	Path / 'Users' / 'ryanperez' / 'Documents' / 'GitHub' / 'pp-rep2533' [..]
		filesystem: 	a FileSystem


UndefinedObject>>DoIt
	Receiver: nil
	Arguments and temporary variables: 
		canvas: 	nil
		nodesMap: 	nil
		json: 	nil
		jsonFile: 	'/Users/ryanperez/Documents/GitHub/pp-rep2533/project/src/data/te[..]
		jsonStream: 	nil
		nodes: 	nil
		edges: 	nil
	Receiver's instance variables: 
nil

OCReceiverDoItSemanticScope(OCDoItSemanticScope)>>evaluateDoIt:
	Receiver: an OCReceiverDoItSemanticScope
	Arguments and temporary variables: 
		doItMethod: 	UndefinedObject>>#DoIt
	Receiver's instance variables: 
		outerScope: 	nil
		targetReceiver: 	nil


OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
		doItMethod: 	UndefinedObject>>#DoIt
	Receiver's instance variables: 
		ast: 	DoIt

	| canvas nodesMap json jsonFile jsonStream nodes edges |
	"Path[..]
		source: 	a ReadStream
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil


[
		self announcer announce: (SpCodeWillBeEvaluatedAnnouncement newContent: aString).
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionModel doItReceiver.
		result := receiver class compiler
			source: aString;
			context: self interactionModel doItContext;
			receiver: self interactionModel doItReceiver;
			requestor: self interactionModel;
			environment: self environment;
			failBlock:  [ 
				self announcer announce: (SpCodeEvaluationFailedAnnouncement newContent: aString).
				^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		self announcer announce: (SpCodeEvaluationSucceedAnnouncement newContent: aString).
		result ] in SpCodePresenter>>evaluate:onCompileError:onError:
	Receiver: a SpCodePresenter
	Arguments and temporary variables: 
		aString: 	'| canvas nodesMap json jsonFile jsonStream nodes edges |

"Path t[..]
		compileErrorBlock: 	[ ^ self ]
		errorBlock: 	[ :e | e pass ]
		receiver: 	nil
		result: 	nil
		oldBindings: 	a Dictionary()
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicCodeAdapter)
		announcer: 	an Announcer
		owner: 	a StPlaygroundPagePresenter
		adapter: 	a SpMorphicCodeAdapter
		needRebuild: 	true
		eventHandler: 	a SpEventHandler
		application: 	nil
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ a KMCategory ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Code' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpAbstractWidgetLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		borderWidth: 	an ObservableValueHolder[ nil ]
		borderColor: 	an ObservableValueHolder[ nil ]
		dragEnabled: 	an ObservableValueHolder[ false ]
		dropEnabled: 	an ObservableValueHolder[ false ]
		color: 	an ObservableValueHolder[ nil ]
		help: 	an ObservableValueHolder[ nil ]
		enabled: 	an ObservableValueHolder[ true ]
		wantsDrop: 	an ObservableValueHolder[ [ :transfer | self dropEnabled ] ]
		acceptDrop: 	an ObservableValueHolder[ [ :transfer | ] ]
		deferredActions: 	nil
		hasUnacceptedEdits: 	an ObservableValueHolder[ false ]
		selection: 	an ObservableValueHolder[ (1 to: 1439) ]
		wantsVisualFeedback: 	an ObservableValueHolder[ true ]
		askBeforeDiscardingEdits: 	an ObservableValueHolder[ true ]
		text: 	an ObservableValueHolder[ '| canvas nodesMap json jsonFile jsonStream[..]
		actionToPerform: 	an ObservableValueHolder[ [ :txt |  ] ]
		readSelection: 	an ObservableValueHolder[ [ selection ] ]
		placeholder: 	an ObservableValueHolder[ '' ]
		contextMenu: 	an ObservableValueHolder[ [ (self menuActionsFor: text) asMenu[..]
		scrollValue: 	an ObservableValueHolder[ (0@1.0) ]
		editionContextMenu: 	an ObservableValueHolder[ true ]
		editable: 	an ObservableValueHolder[ true ]
		wrapWord: 	an ObservableValueHolder[ true ]
		undoRedoHistory: 	true
		wrapScrollBars: 	true
		propagateNaturalHeight: 	false
		propagateNaturalWidth: 	false
		scrollBarStyles: 	#()
		syntaxHighlight: 	an ObservableValueHolder[ true ]
		smartCharacters: 	an ObservableValueHolder[ true ]
		lineNumbers: 	an ObservableValueHolder[ true ]
		interactionModel: 	an ObservableValueHolder[ a StPlaygroundInteractionModel ]
		overrideContextMenu: 	true
		submitBlock: 	nil
		resetBlock: 	nil
		environment: 	nil
		systemNavigation: 	nil
		syntaxHighlightTheme: 	an ObservableValueHolder[ nil ]


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
		self announcer announce: (SpCodeWillBeEvaluatedAnnouncement newContent: aString).
[..]
	Arguments and temporary variables: 
		exception: 	Error
		handlerAction: 	[ :e |
		self announcer announce: (SpCodeEvaluationFailedAnn[..]
	Receiver's instance variables: 
		outerContext: 	SpCodePresenter>>evaluate:onCompileError:onError:
		compiledBlock: 	a CompiledBlock: [
		self announcer announce: (SpCodeWillBeE[..]
		numArgs: 	0
		receiver: 	a SpCodePresenter


SpCodePresenter>>evaluate:onCompileError:onError:
	Receiver: a SpCodePresenter
	Arguments and temporary variables: 
		receiver: 	nil
		result: 	nil
		oldBindings: 	a Dictionary()
		aString: 	'| canvas nodesMap json jsonFile jsonStream nodes edges |

"Path t[..]
		compileErrorBlock: 	[ ^ self ]
		errorBlock: 	[ :e | e pass ]
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicCodeAdapter)
		announcer: 	an Announcer
		owner: 	a StPlaygroundPagePresenter
		adapter: 	a SpMorphicCodeAdapter
		needRebuild: 	true
		eventHandler: 	a SpEventHandler
		application: 	nil
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ a KMCategory ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Code' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpAbstractWidgetLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		borderWidth: 	an ObservableValueHolder[ nil ]
		borderColor: 	an ObservableValueHolder[ nil ]
		dragEnabled: 	an ObservableValueHolder[ false ]
		dropEnabled: 	an ObservableValueHolder[ false ]
		color: 	an ObservableValueHolder[ nil ]
		help: 	an ObservableValueHolder[ nil ]
		enabled: 	an ObservableValueHolder[ true ]
		wantsDrop: 	an ObservableValueHolder[ [ :transfer | self dropEnabled ] ]
		acceptDrop: 	an ObservableValueHolder[ [ :transfer | ] ]
		deferredActions: 	nil
		hasUnacceptedEdits: 	an ObservableValueHolder[ false ]
		selection: 	an ObservableValueHolder[ (1 to: 1439) ]
		wantsVisualFeedback: 	an ObservableValueHolder[ true ]
		askBeforeDiscardingEdits: 	an ObservableValueHolder[ true ]
		text: 	an ObservableValueHolder[ '| canvas nodesMap json jsonFile jsonStream[..]
		actionToPerform: 	an ObservableValueHolder[ [ :txt |  ] ]
		readSelection: 	an ObservableValueHolder[ [ selection ] ]
		placeholder: 	an ObservableValueHolder[ '' ]
		contextMenu: 	an ObservableValueHolder[ [ (self menuActionsFor: text) asMenu[..]
		scrollValue: 	an ObservableValueHolder[ (0@1.0) ]
		editionContextMenu: 	an ObservableValueHolder[ true ]
		editable: 	an ObservableValueHolder[ true ]
		wrapWord: 	an ObservableValueHolder[ true ]
		undoRedoHistory: 	true
		wrapScrollBars: 	true
		propagateNaturalHeight: 	false
		propagateNaturalWidth: 	false
		scrollBarStyles: 	#()
		syntaxHighlight: 	an ObservableValueHolder[ true ]
		smartCharacters: 	an ObservableValueHolder[ true ]
		lineNumbers: 	an ObservableValueHolder[ true ]
		interactionModel: 	an ObservableValueHolder[ a StPlaygroundInteractionModel ]
		overrideContextMenu: 	true
		submitBlock: 	nil
		resetBlock: 	nil
		environment: 	nil
		systemNavigation: 	nil
		syntaxHighlightTheme: 	an ObservableValueHolder[ nil ]


StPlaygroundPagePresenter>>doEvaluateAndGo
	Receiver: a StPlaygroundPagePresenter
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicBoxAdapter)
		announcer: 	an Announcer
		owner: 	a SpMillerColumnPresenter
		adapter: 	a SpMorphicBoxAdapter
		needRebuild: 	true
		eventHandler: 	nil
		application: 	a StPharoApplication
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ nil ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Untitled window' ]
		additionalSubpresentersMap: 	a Dictionary()
		layout: 	an ObservableValueHolder[ a SpBoxLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		text: 	a SpCodePresenter
		toolbar: 	a SpToolbarPresenter
		statusbar: 	a SpPresenter
		lineLabel: 	a SpLabelPresenter
		toggleLineNumberButton: 	a SpToggleButtonPresenter
		page: 	a StPlaygroundPage
		activationBlock: 	[ :selection |
		self changeSelection: selection from: new[..]


StPlaygroundPagePresenter>>doEvaluateAllAndGo
	Receiver: a StPlaygroundPagePresenter
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicBoxAdapter)
		announcer: 	an Announcer
		owner: 	a SpMillerColumnPresenter
		adapter: 	a SpMorphicBoxAdapter
		needRebuild: 	true
		eventHandler: 	nil
		application: 	a StPharoApplication
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ nil ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Untitled window' ]
		additionalSubpresentersMap: 	a Dictionary()
		layout: 	an ObservableValueHolder[ a SpBoxLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		text: 	a SpCodePresenter
		toolbar: 	a SpToolbarPresenter
		statusbar: 	a SpPresenter
		lineLabel: 	a SpLabelPresenter
		toggleLineNumberButton: 	a SpToggleButtonPresenter
		page: 	a StPlaygroundPage
		activationBlock: 	[ :selection |
		self changeSelection: selection from: new[..]


StPlaygroundDoItCommand>>execute
	Receiver: a StPlaygroundDoItCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		context: 	a StPlaygroundPagePresenter
		basicName: 	'Do it'
		basicDescription: 	'Do it all and inspect.'


SpCommand(CmCommandDecorator)>>execute
	Receiver: a SpCommand(Do it)
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a StPlaygroundDoItCommand
		iconProvider: 	a StPharoApplication
		iconName: 	#glamorousGo
		shortcutKey: 	nil
		displayStrategy: 	a CmUIDisableWhenCantBeRun
		positionStrategy: 	a CmUILeftPositionStrategy
		buildPresenterBlock: 	[ :specCommand | 
			aButtonClass new
				label: specC[..]
		presenter: 	a SpToolbarButtonPresenter


[ specCommand execute ] in [ :specCommand | 
			aButtonClass new
				label: specCommand name;
				help: specCommand description;
				in: [ :button | 
					specCommand hasIcon
						ifTrue: [ button icon: specCommand icon ] ];
				action: [ specCommand execute ];
				yourself ] in SpCommand>>configureAsButtonOfClass:
	Receiver: a SpCommand(Do it)
	Arguments and temporary variables: 
		aButtonClass: 	nil
		specCommand: 	a SpCommand(Do it)
	Receiver's instance variables: 
		decoratedCommand: 	a StPlaygroundDoItCommand
		iconProvider: 	a StPharoApplication
		iconName: 	#glamorousGo
		shortcutKey: 	nil
		displayStrategy: 	a CmUIDisableWhenCantBeRun
		positionStrategy: 	a CmUILeftPositionStrategy
		buildPresenterBlock: 	[ :specCommand | 
			aButtonClass new
				label: specC[..]
		presenter: 	a SpToolbarButtonPresenter


FullBlockClosure(BlockClosure)>>cull:
	Receiver: [ specCommand execute ]
	Arguments and temporary variables: 
		anArg: 	a SpToolbarButtonPresenter
	Receiver's instance variables: 
		outerContext: 	[ :specCommand | 
			aButtonClass new
				label: specCommand [..]
		compiledBlock: 	a CompiledBlock: [ specCommand execute ]
		numArgs: 	0
		receiver: 	a SpCommand(Do it)


SpMorphicToolbarButtonAdapter>>execute
	Receiver: a SpMorphicToolbarButtonAdapter
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpToolbarButtonMorph(737876992))
		announcer: 	nil
		model: 	a SpToolbarButtonPresenter
		widget: 	a SpToolbarButtonMorph(737876992)
		selector: 	nil
		owner: 	a SpToolbarButtonPresenter
		unsubscribed: 	false


SpToolbarButtonMorph(PluggableButtonMorph)>>performAction:
	Receiver: a SpToolbarButtonMorph(737876992)
	Arguments and temporary variables: 
		event: 	[(22.0@27.0) mouseUp 13865020 nil]
	Receiver's instance variables: 
		bounds: 	(0.0@5.0) corner: (45.0@39.0)
		owner: 	a Morph(683118080)
		submorphs: 	an Array(an AlignmentMorph(37545216))
		fullBounds: 	(0@5) corner: (45@39)
		color: 	Color transparent
		extension: 	a MorphExtension (22220288) [balloonText]  [other:  (presenter -[..]
		borderWidth: 	0
		borderColor: 	#simple
		model: 	a SpMorphicToolbarButtonAdapter
		label: 	'Do it'
		icon: 	Form(13x13x32)
		getIconSelector: 	#icon
		getStateSelector: 	#state
		actionSelector: 	#execute
		font: 	a LogicalFont
 familyName: 'Source Sans Pro'
 emphasis: nil
 pointSiz[..]
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	nil
		getFontSelector: 	nil
		labelMorph: 	a LabelMorph(55328000)'Do it'
		iconMorph: 	an ImageMorph(18942720)
		iconPosition: 	#top
		lastState: 	false
		badgeFont: 	nil
		badgeSelector: 	#badge


[:m |
		(m containsPoint: evt cursorPoint) ifTrue: [m enabled ifTrue: [ m performAction: evt ]]] in SpToolbarButtonMorph(PluggableButtonMorph)>>mouseUp:
	Receiver: a SpToolbarButtonMorph(737876992)
	Arguments and temporary variables: 
		evt: 	[(22.0@27.0) mouseUp 13865020 nil]
		all: 	an Array(a SpToolbarButtonMorph(737876992) a SpToolbarButtonMorph(9312[..]
		m: 	a SpToolbarButtonMorph(737876992)
	Receiver's instance variables: 
		bounds: 	(0.0@5.0) corner: (45.0@39.0)
		owner: 	a Morph(683118080)
		submorphs: 	an Array(an AlignmentMorph(37545216))
		fullBounds: 	(0@5) corner: (45@39)
		color: 	Color transparent
		extension: 	a MorphExtension (22220288) [balloonText]  [other:  (presenter -[..]
		borderWidth: 	0
		borderColor: 	#simple
		model: 	a SpMorphicToolbarButtonAdapter
		label: 	'Do it'
		icon: 	Form(13x13x32)
		getIconSelector: 	#icon
		getStateSelector: 	#state
		actionSelector: 	#execute
		font: 	a LogicalFont
 familyName: 'Source Sans Pro'
 emphasis: nil
 pointSiz[..]
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	nil
		getFontSelector: 	nil
		labelMorph: 	a LabelMorph(55328000)'Do it'
		iconMorph: 	an ImageMorph(18942720)
		iconPosition: 	#top
		lastState: 	false
		badgeFont: 	nil
		badgeSelector: 	#badge


Array(SequenceableCollection)>>do:
	Receiver: an Array(a SpToolbarButtonMorph(737876992) a SpToolbarButtonMorph(93121024) a SpToolba[..]
	Arguments and temporary variables: 
		aBlock: 	[:m |
		(m containsPoint: evt cursorPoint) ifTrue: [m enabled ifTru[..]
		index: 	1
	Receiver's instance variables: 
an Array(a SpToolbarButtonMorph(737876992) a SpToolbarButtonMorph(93121024) a SpToolba[..]

SpToolbarButtonMorph(PluggableButtonMorph)>>mouseUp:
	Receiver: a SpToolbarButtonMorph(737876992)
	Arguments and temporary variables: 
		evt: 	[(22.0@27.0) mouseUp 13865020 nil]
		all: 	an Array(a SpToolbarButtonMorph(737876992) a SpToolbarButtonMorph(9312[..]
	Receiver's instance variables: 
		bounds: 	(0.0@5.0) corner: (45.0@39.0)
		owner: 	a Morph(683118080)
		submorphs: 	an Array(an AlignmentMorph(37545216))
		fullBounds: 	(0@5) corner: (45@39)
		color: 	Color transparent
		extension: 	a MorphExtension (22220288) [balloonText]  [other:  (presenter -[..]
		borderWidth: 	0
		borderColor: 	#simple
		model: 	a SpMorphicToolbarButtonAdapter
		label: 	'Do it'
		icon: 	Form(13x13x32)
		getIconSelector: 	#icon
		getStateSelector: 	#state
		actionSelector: 	#execute
		font: 	a LogicalFont
 familyName: 'Source Sans Pro'
 emphasis: nil
 pointSiz[..]
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	nil
		getFontSelector: 	nil
		labelMorph: 	a LabelMorph(55328000)'Do it'
		iconMorph: 	an ImageMorph(18942720)
		iconPosition: 	#top
		lastState: 	false
		badgeFont: 	nil
		badgeSelector: 	#badge


SpToolbarButtonMorph(Morph)>>handleMouseUp:
	Receiver: a SpToolbarButtonMorph(737876992)
	Arguments and temporary variables: 
		anEvent: 	[(22.0@27.0) mouseUp 13865020 nil]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(0.0@5.0) corner: (45.0@39.0)
		owner: 	a Morph(683118080)
		submorphs: 	an Array(an AlignmentMorph(37545216))
		fullBounds: 	(0@5) corner: (45@39)
		color: 	Color transparent
		extension: 	a MorphExtension (22220288) [balloonText]  [other:  (presenter -[..]
		borderWidth: 	0
		borderColor: 	#simple
		model: 	a SpMorphicToolbarButtonAdapter
		label: 	'Do it'
		icon: 	Form(13x13x32)
		getIconSelector: 	#icon
		getStateSelector: 	#state
		actionSelector: 	#execute
		font: 	a LogicalFont
 familyName: 'Source Sans Pro'
 emphasis: nil
 pointSiz[..]
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	nil
		getFontSelector: 	nil
		labelMorph: 	a LabelMorph(55328000)'Do it'
		iconMorph: 	an ImageMorph(18942720)
		iconPosition: 	#top
		lastState: 	false
		badgeFont: 	nil
		badgeSelector: 	#badge


MouseButtonEvent>>sentTo:
	Receiver: [(22.0@27.0) mouseUp 13865020 nil]
	Arguments and temporary variables: 
		anObject: 	a SpToolbarButtonMorph(737876992)
	Receiver's instance variables: 
		timeStamp: 	13865020
		source: 	a HandMorph(337424384)
		windowIndex: 	nil
		type: 	#mouseUp
		buttons: 	0
		position: 	(22.0@27.0)
		handler: 	nil
		wasHandled: 	true
		whichButton: 	4


SpToolbarButtonMorph(Morph)>>handleEvent:
	Receiver: a SpToolbarButtonMorph(737876992)
	Arguments and temporary variables: 
		anEvent: 	[(22.0@27.0) mouseUp 13865020 nil]
	Receiver's instance variables: 
		bounds: 	(0.0@5.0) corner: (45.0@39.0)
		owner: 	a Morph(683118080)
		submorphs: 	an Array(an AlignmentMorph(37545216))
		fullBounds: 	(0@5) corner: (45@39)
		color: 	Color transparent
		extension: 	a MorphExtension (22220288) [balloonText]  [other:  (presenter -[..]
		borderWidth: 	0
		borderColor: 	#simple
		model: 	a SpMorphicToolbarButtonAdapter
		label: 	'Do it'
		icon: 	Form(13x13x32)
		getIconSelector: 	#icon
		getStateSelector: 	#state
		actionSelector: 	#execute
		font: 	a LogicalFont
 familyName: 'Source Sans Pro'
 emphasis: nil
 pointSiz[..]
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	nil
		getFontSelector: 	nil
		labelMorph: 	a LabelMorph(55328000)'Do it'
		iconMorph: 	an ImageMorph(18942720)
		iconPosition: 	#top
		lastState: 	false
		badgeFont: 	nil
		badgeSelector: 	#badge


SpToolbarButtonMorph(Morph)>>handleFocusEvent:
	Receiver: a SpToolbarButtonMorph(737876992)
	Arguments and temporary variables: 
		anEvent: 	[(22.0@27.0) mouseUp 13865020 nil]
	Receiver's instance variables: 
		bounds: 	(0.0@5.0) corner: (45.0@39.0)
		owner: 	a Morph(683118080)
		submorphs: 	an Array(an AlignmentMorph(37545216))
		fullBounds: 	(0@5) corner: (45@39)
		color: 	Color transparent
		extension: 	a MorphExtension (22220288) [balloonText]  [other:  (presenter -[..]
		borderWidth: 	0
		borderColor: 	#simple
		model: 	a SpMorphicToolbarButtonAdapter
		label: 	'Do it'
		icon: 	Form(13x13x32)
		getIconSelector: 	#icon
		getStateSelector: 	#state
		actionSelector: 	#execute
		font: 	a LogicalFont
 familyName: 'Source Sans Pro'
 emphasis: nil
 pointSiz[..]
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	nil
		getFontSelector: 	nil
		labelMorph: 	a LabelMorph(55328000)'Do it'
		iconMorph: 	an ImageMorph(18942720)
		iconPosition: 	#top
		lastState: 	false
		badgeFont: 	nil
		badgeSelector: 	#badge


[
		result := focusHolder handleFocusEvent: transformedEvent.
	] in HandMorph>>sendFocusEvent:to:clear:
	Receiver: a HandMorph(337424384)
	Arguments and temporary variables: 
		anEvent: 	[(360@298) mouseUp 13865020 nil]
		focusHolder: 	a SpToolbarButtonMorph(737876992)
		aBlock: 	[self mouseFocus: nil]
		w: 	a WorldMorph(341720576) [world]
		transformedEvent: 	[(22.0@27.0) mouseUp 13865020 nil]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(556@405.0) corner: (572@421.0)
		owner: 	a WorldMorph(341720576) [world]
		submorphs: 	#()
		fullBounds: 	nil
		color: 	Color blue
		extension: 	a MorphExtension (370611968)
		mouseFocus: 	nil
		keyboardFocus: 	a RubEditingArea(626691072)
		eventListeners: 	nil
		mouseListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(548@396) mouseOver 13875725 nil]
		targetOffset: 	(178.0@15.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	Form(16x16x8)
		temporaryCursorOffset: 	(-8@ -9)
		hardwareCursor: 	((CursorWithMask
	extent: (16@16)
	depth: 1
	fromArray: #(
[..]
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 0 0 0 0 0 nil nil)
		captureBlock: 	nil
		recentModifiers: 	0
		pendingEventQueue: 	WaitfreeQueue with 0 items
		supressNextKeyPress: 	false


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
		result := focusHolder handleFocusEvent: transformedEvent.
	]
	Arguments and temporary variables: 
		exception: 	Error
		handlerAction: 	[ :ex |
			ActiveWorld := priorWorld.
			ex pass ]
	Receiver's instance variables: 
		outerContext: 	HandMorph>>sendFocusEvent:to:clear:
		compiledBlock: 	a CompiledBlock: [
		result := focusHolder handleFocusEvent:[..]
		numArgs: 	0
		receiver: 	a HandMorph(337424384)


WorldMorph>>becomeActiveDuring:
	Receiver: a WorldMorph(341720576) [world]
	Arguments and temporary variables: 
		aBlock: 	[
		result := focusHolder handleFocusEvent: transformedEvent.
	]
		priorWorld: 	a WorldMorph(341720576) [world]
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1728@1080)
		owner: 	nil
		submorphs: 	an Array(a MenubarMorph(112886016) a TaskbarMorph(279458560) a S[..]
		fullBounds: 	nil
		color: 	(Color r: 0.9403714565004888 g: 0.9403714565004888 b: 0.940371456500[..]
		extension: 	a MorphExtension (1012946432) [other:  (dragEnabled -> true) (dr[..]
		borderWidth: 	0
		borderColor: 	(Color r: 0.8611925708699902 g: 1.0 b: 0.7223851417399805 alph[..]
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil


HandMorph>>sendFocusEvent:to:clear:
	Receiver: a HandMorph(337424384)
	Arguments and temporary variables: 
		result: 	nil
		anEvent: 	[(360@298) mouseUp 13865020 nil]
		focusHolder: 	a SpToolbarButtonMorph(737876992)
		aBlock: 	[self mouseFocus: nil]
		w: 	a WorldMorph(341720576) [world]
		transformedEvent: 	[(22.0@27.0) mouseUp 13865020 nil]
	Receiver's instance variables: 
		bounds: 	(556@405.0) corner: (572@421.0)
		owner: 	a WorldMorph(341720576) [world]
		submorphs: 	#()
		fullBounds: 	nil
		color: 	Color blue
		extension: 	a MorphExtension (370611968)
		mouseFocus: 	nil
		keyboardFocus: 	a RubEditingArea(626691072)
		eventListeners: 	nil
		mouseListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(548@396) mouseOver 13875725 nil]
		targetOffset: 	(178.0@15.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	Form(16x16x8)
		temporaryCursorOffset: 	(-8@ -9)
		hardwareCursor: 	((CursorWithMask
	extent: (16@16)
	depth: 1
	fromArray: #(
[..]
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 0 0 0 0 0 nil nil)
		captureBlock: 	nil
		recentModifiers: 	0
		pendingEventQueue: 	WaitfreeQueue with 0 items
		supressNextKeyPress: 	false


HandMorph>>sendEvent:focus:clear:
	Receiver: a HandMorph(337424384)
	Arguments and temporary variables: 
		anEvent: 	[(360@298) mouseUp 13865020 nil]
		focusHolder: 	a SpToolbarButtonMorph(737876992)
		aBlock: 	[self mouseFocus: nil]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(556@405.0) corner: (572@421.0)
		owner: 	a WorldMorph(341720576) [world]
		submorphs: 	#()
		fullBounds: 	nil
		color: 	Color blue
		extension: 	a MorphExtension (370611968)
		mouseFocus: 	nil
		keyboardFocus: 	a RubEditingArea(626691072)
		eventListeners: 	nil
		mouseListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(548@396) mouseOver 13875725 nil]
		targetOffset: 	(178.0@15.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	Form(16x16x8)
		temporaryCursorOffset: 	(-8@ -9)
		hardwareCursor: 	((CursorWithMask
	extent: (16@16)
	depth: 1
	fromArray: #(
[..]
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 0 0 0 0 0 nil nil)
		captureBlock: 	nil
		recentModifiers: 	0
		pendingEventQueue: 	WaitfreeQueue with 0 items
		supressNextKeyPress: 	false


HandMorph>>sendMouseEvent:
	Receiver: a HandMorph(337424384)
	Arguments and temporary variables: 
		anEvent: 	[(360@298) mouseUp 13865020 nil]
	Receiver's instance variables: 
		bounds: 	(556@405.0) corner: (572@421.0)
		owner: 	a WorldMorph(341720576) [world]
		submorphs: 	#()
		fullBounds: 	nil
		color: 	Color blue
		extension: 	a MorphExtension (370611968)
		mouseFocus: 	nil
		keyboardFocus: 	a RubEditingArea(626691072)
		eventListeners: 	nil
		mouseListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(548@396) mouseOver 13875725 nil]
		targetOffset: 	(178.0@15.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	Form(16x16x8)
		temporaryCursorOffset: 	(-8@ -9)
		hardwareCursor: 	((CursorWithMask
	extent: (16@16)
	depth: 1
	fromArray: #(
[..]
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 0 0 0 0 0 nil nil)
		captureBlock: 	nil
		recentModifiers: 	0
		pendingEventQueue: 	WaitfreeQueue with 0 items
		supressNextKeyPress: 	false


HandMorph>>handleEvent:
	Receiver: a HandMorph(337424384)
	Arguments and temporary variables: 
		anEvent: 	[(360@298) mouseUp 13865020 nil]
		evt: 	[(360@298) mouseUp 13865020 nil]
	Receiver's instance variables: 
		bounds: 	(556@405.0) corner: (572@421.0)
		owner: 	a WorldMorph(341720576) [world]
		submorphs: 	#()
		fullBounds: 	nil
		color: 	Color blue
		extension: 	a MorphExtension (370611968)
		mouseFocus: 	nil
		keyboardFocus: 	a RubEditingArea(626691072)
		eventListeners: 	nil
		mouseListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(548@396) mouseOver 13875725 nil]
		targetOffset: 	(178.0@15.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	Form(16x16x8)
		temporaryCursorOffset: 	(-8@ -9)
		hardwareCursor: 	((CursorWithMask
	extent: (16@16)
	depth: 1
	fromArray: #(
[..]
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 0 0 0 0 0 nil nil)
		captureBlock: 	nil
		recentModifiers: 	0
		pendingEventQueue: 	WaitfreeQueue with 0 items
		supressNextKeyPress: 	false


[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil ]) ifTrue: [
			morphicWorld activeHand handleEvent: anEvent
		]
	] in OSWindowMorphicEventHandler>>dispatchMorphicEvent:
	Receiver: an OSWindowMorphicEventHandler
	Arguments and temporary variables: 
		anEvent: 	[(360@298) mouseUp 13865020 nil]
	Receiver's instance variables: 
		morphicWorld: 	a WorldMorph(341720576) [world]


WorldState>>runStepMethodsIn:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(341720576) [world]
		queue: 	WaitfreeQueue with 0 items
		nextInQueue: 	[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNo[..]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(337424384))
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap()
		lastStepTime: 	13864869
		lastStepMessage: 	nil
		alarms: 	a Heap(MorphicAlarm(#hideShow -> a RubCursor(1026113536)))
		lastAlarmTime: 	13875752
		activeHand: 	a HandMorph(337424384)
		currentCursor: 	((CursorWithMask
	extent: (16@16)
	depth: 1
	fromArray: #(
	[..]
		worldRenderer: 	an OSWorldRenderer
		realWindowExtent: 	(1728@1080)
		deferredUIMessages: 	WaitfreeQueue with 0 items


WorldMorph>>runStepMethods
	Receiver: a WorldMorph(341720576) [world]
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1728@1080)
		owner: 	nil
		submorphs: 	an Array(a MenubarMorph(112886016) a TaskbarMorph(279458560) a S[..]
		fullBounds: 	nil
		color: 	(Color r: 0.9403714565004888 g: 0.9403714565004888 b: 0.940371456500[..]
		extension: 	a MorphExtension (1012946432) [other:  (dragEnabled -> true) (dr[..]
		borderWidth: 	0
		borderColor: 	(Color r: 0.8611925708699902 g: 1.0 b: 0.7223851417399805 alph[..]
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil


WorldState>>doOneCycleFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(341720576) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(337424384))
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap()
		lastStepTime: 	13864869
		lastStepMessage: 	nil
		alarms: 	a Heap(MorphicAlarm(#hideShow -> a RubCursor(1026113536)))
		lastAlarmTime: 	13875752
		activeHand: 	a HandMorph(337424384)
		currentCursor: 	((CursorWithMask
	extent: (16@16)
	depth: 1
	fromArray: #(
	[..]
		worldRenderer: 	an OSWorldRenderer
		realWindowExtent: 	(1728@1080)
		deferredUIMessages: 	WaitfreeQueue with 0 items


WorldMorph>>doOneCycleNow
	Receiver: a WorldMorph(341720576) [world]
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1728@1080)
		owner: 	nil
		submorphs: 	an Array(a MenubarMorph(112886016) a TaskbarMorph(279458560) a S[..]
		fullBounds: 	nil
		color: 	(Color r: 0.9403714565004888 g: 0.9403714565004888 b: 0.940371456500[..]
		extension: 	a MorphExtension (1012946432) [other:  (dragEnabled -> true) (dr[..]
		borderWidth: 	0
		borderColor: 	(Color r: 0.8611925708699902 g: 1.0 b: 0.7223851417399805 alph[..]
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil


WorldMorph>>doOneCycle
	Receiver: a WorldMorph(341720576) [world]
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1728@1080)
		owner: 	nil
		submorphs: 	an Array(a MenubarMorph(112886016) a TaskbarMorph(279458560) a S[..]
		fullBounds: 	nil
		color: 	(Color r: 0.9403714565004888 g: 0.9403714565004888 b: 0.940371456500[..]
		extension: 	a MorphExtension (1012946432) [other:  (dragEnabled -> true) (dr[..]
		borderWidth: 	0
		borderColor: 	(Color r: 0.8611925708699902 g: 1.0 b: 0.7223851417399805 alph[..]
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil



--- The full stack ---
ZnCharacterReadStream(Object)>>doesNotUnderstand: #isEmpty
Path class>>from:delimiter:
MacStore(FileSystemStore)>>pathFromString:
FileSystem>>pathFromString:
FileReference(AbstractFileReference)>>/
UndefinedObject>>DoIt
OCReceiverDoItSemanticScope(OCDoItSemanticScope)>>evaluateDoIt:
OpalCompiler>>evaluate
[
		self announcer announce: (SpCodeWillBeEvaluatedAnnouncement newContent: aString).
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionModel doItReceiver.
		result := receiver class compiler
			source: aString;
			context: self interactionModel doItContext;
			receiver: self interactionModel doItReceiver;
			requestor: self interactionModel;
			environment: self environment;
			failBlock:  [ 
				self announcer announce: (SpCodeEvaluationFailedAnnouncement newContent: aString).
				^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		self announcer announce: (SpCodeEvaluationSucceedAnnouncement newContent: aString).
		result ] in SpCodePresenter>>evaluate:onCompileError:onError:
FullBlockClosure(BlockClosure)>>on:do:
SpCodePresenter>>evaluate:onCompileError:onError:
StPlaygroundPagePresenter>>doEvaluateAndGo
StPlaygroundPagePresenter>>doEvaluateAllAndGo
StPlaygroundDoItCommand>>execute
SpCommand(CmCommandDecorator)>>execute
[ specCommand execute ] in [ :specCommand | 
			aButtonClass new
				label: specCommand name;
				help: specCommand description;
				in: [ :button | 
					specCommand hasIcon
						ifTrue: [ button icon: specCommand icon ] ];
				action: [ specCommand execute ];
				yourself ] in SpCommand>>configureAsButtonOfClass:
FullBlockClosure(BlockClosure)>>cull:
SpMorphicToolbarButtonAdapter>>execute
SpToolbarButtonMorph(PluggableButtonMorph)>>performAction:
[:m |
		(m containsPoint: evt cursorPoint) ifTrue: [m enabled ifTrue: [ m performAction: evt ]]] in SpToolbarButtonMorph(PluggableButtonMorph)>>mouseUp:
Array(SequenceableCollection)>>do:
SpToolbarButtonMorph(PluggableButtonMorph)>>mouseUp:
SpToolbarButtonMorph(Morph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
SpToolbarButtonMorph(Morph)>>handleEvent:
SpToolbarButtonMorph(Morph)>>handleFocusEvent:
[
		result := focusHolder handleFocusEvent: transformedEvent.
	] in HandMorph>>sendFocusEvent:to:clear:
FullBlockClosure(BlockClosure)>>on:do:
WorldMorph>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil ]) ifTrue: [
			morphicWorld activeHand handleEvent: anEvent
		]
	] in OSWindowMorphicEventHandler>>dispatchMorphicEvent:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycleNow
WorldMorph>>doOneCycle
 - - - - - - - - - - - - - - -
			- - - - - - - - - - - - - - - - - -
[
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMutex critical: [
			                     self extraWorldList ].
		extraWorldsToDraw do: [ :world | world doOneCycle ].

		(self currentWorld isNotNil and: [
			 (extraWorldsToDraw includes: self currentWorld) not ]) ifTrue: [
			self currentWorld doOneCycle ] ] in WorldMorph class>>doOneCycle
FullBlockClosure(BlockClosure)>>ensure:
WorldState class>>doDrawCycleWith:
WorldMorph class>>doOneCycle
MorphicRenderLoop>>doOneCycle
MorphicRenderLoop>>doOneCycleWhile:
[ MorphicRenderLoop new doOneCycleWhile: [ true ] ] in MorphicUIManager>>spawnNewProcess
[self value.
			"IMPORTANT: Do not step over next line of code. See method comments for details"
			Processor terminateRealActive] in FullBlockClosure(BlockClosure)>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
Instance of ZnCharacterReadStream did not understand #isEmpty
13 November 2023 7:55:57.671165 pm

VM: Mac OS - arm64 - 1000 - CoInterpreter VMMaker-tonel.1 uuid: 902dd483-c0c4-0d00-86f2-0f880df24b96 Oct 23 2023
StackToRegisterMappingCogit VMMaker-tonel.1 uuid: 902dd483-c0c4-0d00-86f2-0f880df24b96 Oct 23 2023
v10.0.8 - Commit: b323c5fb - Date: 2023-10-20 16:02:07 -0400

Image: Pharo11.0.0 [Build information: Pharo-11.0.0+build.710.sha.ea28d8552cac85a7ce1e9c34ab1e7bd45f7b9910 (64 Bit)]

ZnCharacterReadStream(Object)>>doesNotUnderstand: #isEmpty
	Receiver: a ZnCharacterReadStream
	Arguments and temporary variables: 
		aMessage: 	isEmpty
		exception: 	Instance of ZnCharacterReadStream did not understand #isEmpty
		resumeValue: 	nil
	Receiver's instance variables: 
		stream: 	a ZnBufferedReadStream
		encoder: 	a ZnUTF8Encoder
		peeked: 	nil


Path class>>from:delimiter:
	Receiver: Path
	Arguments and temporary variables: 
		aString: 	a ZnCharacterReadStream
		aDelimiterCharacter: 	$/
		pathClass: 	nil
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary(#,->Path>>#, #/->Path>>#/ #'<='->Path>>#'<='[..]
		format: 	131072
		layout: 	a VariableLayout
		organization: 	a ClassOrganization
		commentSourcePointer: 	nil
		subclasses: 	{AbsolutePath. RelativePath. UNCNetworkPath}
		name: 	#Path
		classPool: 	nil
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'FileSystem-Path-Base'


MacStore(FileSystemStore)>>pathFromString:
	Receiver: a MacStore
	Arguments and temporary variables: 
		aString: 	a ZnCharacterReadStream
	Receiver's instance variables: 
		maxFileNameLength: 	255


FileSystem>>pathFromString:
	Receiver: a FileSystem
	Arguments and temporary variables: 
		aString: 	a ZnCharacterReadStream
	Receiver's instance variables: 
		store: 	a MacStore


FileReference(AbstractFileReference)>>/
	Receiver: File @ /Users/ryanperez/Documents/GitHub/pp-rep2533/project/src/visualizer/Smalltalk
	Arguments and temporary variables: 
		aString: 	a ZnCharacterReadStream
	Receiver's instance variables: 
		path: 	Path / 'Users' / 'ryanperez' / 'Documents' / 'GitHub' / 'pp-rep2533' [..]
		filesystem: 	a FileSystem


UndefinedObject>>DoIt
	Receiver: nil
	Arguments and temporary variables: 
		canvas: 	nil
		nodesMap: 	nil
		json: 	nil
		jsonFile: 	'/Users/ryanperez/Documents/GitHub/pp-rep2533/project/src/data/te[..]
		jsonStream: 	nil
		nodes: 	nil
		edges: 	nil
	Receiver's instance variables: 
nil

OCReceiverDoItSemanticScope(OCDoItSemanticScope)>>evaluateDoIt:
	Receiver: an OCReceiverDoItSemanticScope
	Arguments and temporary variables: 
		doItMethod: 	UndefinedObject>>#DoIt
	Receiver's instance variables: 
		outerScope: 	nil
		targetReceiver: 	nil


OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
		doItMethod: 	UndefinedObject>>#DoIt
	Receiver's instance variables: 
		ast: 	DoIt

	| canvas nodesMap json jsonFile jsonStream nodes edges |
	"Path[..]
		source: 	a ReadStream
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil


[
		self announcer announce: (SpCodeWillBeEvaluatedAnnouncement newContent: aString).
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionModel doItReceiver.
		result := receiver class compiler
			source: aString;
			context: self interactionModel doItContext;
			receiver: self interactionModel doItReceiver;
			requestor: self interactionModel;
			environment: self environment;
			failBlock:  [ 
				self announcer announce: (SpCodeEvaluationFailedAnnouncement newContent: aString).
				^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		self announcer announce: (SpCodeEvaluationSucceedAnnouncement newContent: aString).
		result ] in SpCodePresenter>>evaluate:onCompileError:onError:
	Receiver: a SpCodePresenter
	Arguments and temporary variables: 
		aString: 	'| canvas nodesMap json jsonFile jsonStream nodes edges |

"Path t[..]
		compileErrorBlock: 	[ ^ self ]
		errorBlock: 	[ :e | e pass ]
		receiver: 	nil
		result: 	nil
		oldBindings: 	a Dictionary()
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicCodeAdapter)
		announcer: 	an Announcer
		owner: 	a StPlaygroundPagePresenter
		adapter: 	a SpMorphicCodeAdapter
		needRebuild: 	true
		eventHandler: 	a SpEventHandler
		application: 	nil
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ a KMCategory ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Code' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpAbstractWidgetLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		borderWidth: 	an ObservableValueHolder[ nil ]
		borderColor: 	an ObservableValueHolder[ nil ]
		dragEnabled: 	an ObservableValueHolder[ false ]
		dropEnabled: 	an ObservableValueHolder[ false ]
		color: 	an ObservableValueHolder[ nil ]
		help: 	an ObservableValueHolder[ nil ]
		enabled: 	an ObservableValueHolder[ true ]
		wantsDrop: 	an ObservableValueHolder[ [ :transfer | self dropEnabled ] ]
		acceptDrop: 	an ObservableValueHolder[ [ :transfer | ] ]
		deferredActions: 	nil
		hasUnacceptedEdits: 	an ObservableValueHolder[ false ]
		selection: 	an ObservableValueHolder[ (1 to: 1439) ]
		wantsVisualFeedback: 	an ObservableValueHolder[ true ]
		askBeforeDiscardingEdits: 	an ObservableValueHolder[ true ]
		text: 	an ObservableValueHolder[ '| canvas nodesMap json jsonFile jsonStream[..]
		actionToPerform: 	an ObservableValueHolder[ [ :txt |  ] ]
		readSelection: 	an ObservableValueHolder[ [ selection ] ]
		placeholder: 	an ObservableValueHolder[ '' ]
		contextMenu: 	an ObservableValueHolder[ [ (self menuActionsFor: text) asMenu[..]
		scrollValue: 	an ObservableValueHolder[ (0@1.0) ]
		editionContextMenu: 	an ObservableValueHolder[ true ]
		editable: 	an ObservableValueHolder[ true ]
		wrapWord: 	an ObservableValueHolder[ true ]
		undoRedoHistory: 	true
		wrapScrollBars: 	true
		propagateNaturalHeight: 	false
		propagateNaturalWidth: 	false
		scrollBarStyles: 	#()
		syntaxHighlight: 	an ObservableValueHolder[ true ]
		smartCharacters: 	an ObservableValueHolder[ true ]
		lineNumbers: 	an ObservableValueHolder[ true ]
		interactionModel: 	an ObservableValueHolder[ a StPlaygroundInteractionModel ]
		overrideContextMenu: 	true
		submitBlock: 	nil
		resetBlock: 	nil
		environment: 	nil
		systemNavigation: 	nil
		syntaxHighlightTheme: 	an ObservableValueHolder[ nil ]


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
		self announcer announce: (SpCodeWillBeEvaluatedAnnouncement newContent: aString).
[..]
	Arguments and temporary variables: 
		exception: 	Error
		handlerAction: 	[ :e |
		self announcer announce: (SpCodeEvaluationFailedAnn[..]
	Receiver's instance variables: 
		outerContext: 	SpCodePresenter>>evaluate:onCompileError:onError:
		compiledBlock: 	a CompiledBlock: [
		self announcer announce: (SpCodeWillBeE[..]
		numArgs: 	0
		receiver: 	a SpCodePresenter


SpCodePresenter>>evaluate:onCompileError:onError:
	Receiver: a SpCodePresenter
	Arguments and temporary variables: 
		receiver: 	nil
		result: 	nil
		oldBindings: 	a Dictionary()
		aString: 	'| canvas nodesMap json jsonFile jsonStream nodes edges |

"Path t[..]
		compileErrorBlock: 	[ ^ self ]
		errorBlock: 	[ :e | e pass ]
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicCodeAdapter)
		announcer: 	an Announcer
		owner: 	a StPlaygroundPagePresenter
		adapter: 	a SpMorphicCodeAdapter
		needRebuild: 	true
		eventHandler: 	a SpEventHandler
		application: 	nil
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ a KMCategory ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Code' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpAbstractWidgetLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		borderWidth: 	an ObservableValueHolder[ nil ]
		borderColor: 	an ObservableValueHolder[ nil ]
		dragEnabled: 	an ObservableValueHolder[ false ]
		dropEnabled: 	an ObservableValueHolder[ false ]
		color: 	an ObservableValueHolder[ nil ]
		help: 	an ObservableValueHolder[ nil ]
		enabled: 	an ObservableValueHolder[ true ]
		wantsDrop: 	an ObservableValueHolder[ [ :transfer | self dropEnabled ] ]
		acceptDrop: 	an ObservableValueHolder[ [ :transfer | ] ]
		deferredActions: 	nil
		hasUnacceptedEdits: 	an ObservableValueHolder[ false ]
		selection: 	an ObservableValueHolder[ (1 to: 1439) ]
		wantsVisualFeedback: 	an ObservableValueHolder[ true ]
		askBeforeDiscardingEdits: 	an ObservableValueHolder[ true ]
		text: 	an ObservableValueHolder[ '| canvas nodesMap json jsonFile jsonStream[..]
		actionToPerform: 	an ObservableValueHolder[ [ :txt |  ] ]
		readSelection: 	an ObservableValueHolder[ [ selection ] ]
		placeholder: 	an ObservableValueHolder[ '' ]
		contextMenu: 	an ObservableValueHolder[ [ (self menuActionsFor: text) asMenu[..]
		scrollValue: 	an ObservableValueHolder[ (0@1.0) ]
		editionContextMenu: 	an ObservableValueHolder[ true ]
		editable: 	an ObservableValueHolder[ true ]
		wrapWord: 	an ObservableValueHolder[ true ]
		undoRedoHistory: 	true
		wrapScrollBars: 	true
		propagateNaturalHeight: 	false
		propagateNaturalWidth: 	false
		scrollBarStyles: 	#()
		syntaxHighlight: 	an ObservableValueHolder[ true ]
		smartCharacters: 	an ObservableValueHolder[ true ]
		lineNumbers: 	an ObservableValueHolder[ true ]
		interactionModel: 	an ObservableValueHolder[ a StPlaygroundInteractionModel ]
		overrideContextMenu: 	true
		submitBlock: 	nil
		resetBlock: 	nil
		environment: 	nil
		systemNavigation: 	nil
		syntaxHighlightTheme: 	an ObservableValueHolder[ nil ]


StPlaygroundPagePresenter>>doEvaluateAndGo
	Receiver: a StPlaygroundPagePresenter
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicBoxAdapter)
		announcer: 	an Announcer
		owner: 	a SpMillerColumnPresenter
		adapter: 	a SpMorphicBoxAdapter
		needRebuild: 	true
		eventHandler: 	nil
		application: 	a StPharoApplication
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ nil ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Untitled window' ]
		additionalSubpresentersMap: 	a Dictionary()
		layout: 	an ObservableValueHolder[ a SpBoxLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		text: 	a SpCodePresenter
		toolbar: 	a SpToolbarPresenter
		statusbar: 	a SpPresenter
		lineLabel: 	a SpLabelPresenter
		toggleLineNumberButton: 	a SpToggleButtonPresenter
		page: 	a StPlaygroundPage
		activationBlock: 	[ :selection |
		self changeSelection: selection from: new[..]


StPlaygroundPagePresenter>>doEvaluateAllAndGo
	Receiver: a StPlaygroundPagePresenter
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicBoxAdapter)
		announcer: 	an Announcer
		owner: 	a SpMillerColumnPresenter
		adapter: 	a SpMorphicBoxAdapter
		needRebuild: 	true
		eventHandler: 	nil
		application: 	a StPharoApplication
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ nil ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Untitled window' ]
		additionalSubpresentersMap: 	a Dictionary()
		layout: 	an ObservableValueHolder[ a SpBoxLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		text: 	a SpCodePresenter
		toolbar: 	a SpToolbarPresenter
		statusbar: 	a SpPresenter
		lineLabel: 	a SpLabelPresenter
		toggleLineNumberButton: 	a SpToggleButtonPresenter
		page: 	a StPlaygroundPage
		activationBlock: 	[ :selection |
		self changeSelection: selection from: new[..]


StPlaygroundDoItCommand>>execute
	Receiver: a StPlaygroundDoItCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		context: 	a StPlaygroundPagePresenter
		basicName: 	'Do it'
		basicDescription: 	'Do it all and inspect.'


SpCommand(CmCommandDecorator)>>execute
	Receiver: a SpCommand(Do it)
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a StPlaygroundDoItCommand
		iconProvider: 	a StPharoApplication
		iconName: 	#glamorousGo
		shortcutKey: 	nil
		displayStrategy: 	a CmUIDisableWhenCantBeRun
		positionStrategy: 	a CmUILeftPositionStrategy
		buildPresenterBlock: 	[ :specCommand | 
			aButtonClass new
				label: specC[..]
		presenter: 	a SpToolbarButtonPresenter


[ specCommand execute ] in [ :specCommand | 
			aButtonClass new
				label: specCommand name;
				help: specCommand description;
				in: [ :button | 
					specCommand hasIcon
						ifTrue: [ button icon: specCommand icon ] ];
				action: [ specCommand execute ];
				yourself ] in SpCommand>>configureAsButtonOfClass:
	Receiver: a SpCommand(Do it)
	Arguments and temporary variables: 
		aButtonClass: 	nil
		specCommand: 	a SpCommand(Do it)
	Receiver's instance variables: 
		decoratedCommand: 	a StPlaygroundDoItCommand
		iconProvider: 	a StPharoApplication
		iconName: 	#glamorousGo
		shortcutKey: 	nil
		displayStrategy: 	a CmUIDisableWhenCantBeRun
		positionStrategy: 	a CmUILeftPositionStrategy
		buildPresenterBlock: 	[ :specCommand | 
			aButtonClass new
				label: specC[..]
		presenter: 	a SpToolbarButtonPresenter


FullBlockClosure(BlockClosure)>>cull:
	Receiver: [ specCommand execute ]
	Arguments and temporary variables: 
		anArg: 	a SpToolbarButtonPresenter
	Receiver's instance variables: 
		outerContext: 	[ :specCommand | 
			aButtonClass new
				label: specCommand [..]
		compiledBlock: 	a CompiledBlock: [ specCommand execute ]
		numArgs: 	0
		receiver: 	a SpCommand(Do it)


SpMorphicToolbarButtonAdapter>>execute
	Receiver: a SpMorphicToolbarButtonAdapter
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpToolbarButtonMorph(737876992))
		announcer: 	nil
		model: 	a SpToolbarButtonPresenter
		widget: 	a SpToolbarButtonMorph(737876992)
		selector: 	nil
		owner: 	a SpToolbarButtonPresenter
		unsubscribed: 	false


SpToolbarButtonMorph(PluggableButtonMorph)>>performAction:
	Receiver: a SpToolbarButtonMorph(737876992)
	Arguments and temporary variables: 
		event: 	[(22.0@27.0) mouseUp 13865020 nil]
	Receiver's instance variables: 
		bounds: 	(0.0@5.0) corner: (45.0@39.0)
		owner: 	a Morph(683118080)
		submorphs: 	an Array(an AlignmentMorph(37545216))
		fullBounds: 	(0@5) corner: (45@39)
		color: 	Color transparent
		extension: 	a MorphExtension (22220288) [balloonText]  [other:  (presenter -[..]
		borderWidth: 	0
		borderColor: 	#simple
		model: 	a SpMorphicToolbarButtonAdapter
		label: 	'Do it'
		icon: 	Form(13x13x32)
		getIconSelector: 	#icon
		getStateSelector: 	#state
		actionSelector: 	#execute
		font: 	a LogicalFont
 familyName: 'Source Sans Pro'
 emphasis: nil
 pointSiz[..]
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	nil
		getFontSelector: 	nil
		labelMorph: 	a LabelMorph(55328000)'Do it'
		iconMorph: 	an ImageMorph(18942720)
		iconPosition: 	#top
		lastState: 	false
		badgeFont: 	nil
		badgeSelector: 	#badge


[:m |
		(m containsPoint: evt cursorPoint) ifTrue: [m enabled ifTrue: [ m performAction: evt ]]] in SpToolbarButtonMorph(PluggableButtonMorph)>>mouseUp:
	Receiver: a SpToolbarButtonMorph(737876992)
	Arguments and temporary variables: 
		evt: 	[(22.0@27.0) mouseUp 13865020 nil]
		all: 	an Array(a SpToolbarButtonMorph(737876992) a SpToolbarButtonMorph(9312[..]
		m: 	a SpToolbarButtonMorph(737876992)
	Receiver's instance variables: 
		bounds: 	(0.0@5.0) corner: (45.0@39.0)
		owner: 	a Morph(683118080)
		submorphs: 	an Array(an AlignmentMorph(37545216))
		fullBounds: 	(0@5) corner: (45@39)
		color: 	Color transparent
		extension: 	a MorphExtension (22220288) [balloonText]  [other:  (presenter -[..]
		borderWidth: 	0
		borderColor: 	#simple
		model: 	a SpMorphicToolbarButtonAdapter
		label: 	'Do it'
		icon: 	Form(13x13x32)
		getIconSelector: 	#icon
		getStateSelector: 	#state
		actionSelector: 	#execute
		font: 	a LogicalFont
 familyName: 'Source Sans Pro'
 emphasis: nil
 pointSiz[..]
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	nil
		getFontSelector: 	nil
		labelMorph: 	a LabelMorph(55328000)'Do it'
		iconMorph: 	an ImageMorph(18942720)
		iconPosition: 	#top
		lastState: 	false
		badgeFont: 	nil
		badgeSelector: 	#badge


Array(SequenceableCollection)>>do:
	Receiver: an Array(a SpToolbarButtonMorph(737876992) a SpToolbarButtonMorph(93121024) a SpToolba[..]
	Arguments and temporary variables: 
		aBlock: 	[:m |
		(m containsPoint: evt cursorPoint) ifTrue: [m enabled ifTru[..]
		index: 	1
	Receiver's instance variables: 
an Array(a SpToolbarButtonMorph(737876992) a SpToolbarButtonMorph(93121024) a SpToolba[..]

SpToolbarButtonMorph(PluggableButtonMorph)>>mouseUp:
	Receiver: a SpToolbarButtonMorph(737876992)
	Arguments and temporary variables: 
		evt: 	[(22.0@27.0) mouseUp 13865020 nil]
		all: 	an Array(a SpToolbarButtonMorph(737876992) a SpToolbarButtonMorph(9312[..]
	Receiver's instance variables: 
		bounds: 	(0.0@5.0) corner: (45.0@39.0)
		owner: 	a Morph(683118080)
		submorphs: 	an Array(an AlignmentMorph(37545216))
		fullBounds: 	(0@5) corner: (45@39)
		color: 	Color transparent
		extension: 	a MorphExtension (22220288) [balloonText]  [other:  (presenter -[..]
		borderWidth: 	0
		borderColor: 	#simple
		model: 	a SpMorphicToolbarButtonAdapter
		label: 	'Do it'
		icon: 	Form(13x13x32)
		getIconSelector: 	#icon
		getStateSelector: 	#state
		actionSelector: 	#execute
		font: 	a LogicalFont
 familyName: 'Source Sans Pro'
 emphasis: nil
 pointSiz[..]
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	nil
		getFontSelector: 	nil
		labelMorph: 	a LabelMorph(55328000)'Do it'
		iconMorph: 	an ImageMorph(18942720)
		iconPosition: 	#top
		lastState: 	false
		badgeFont: 	nil
		badgeSelector: 	#badge


SpToolbarButtonMorph(Morph)>>handleMouseUp:
	Receiver: a SpToolbarButtonMorph(737876992)
	Arguments and temporary variables: 
		anEvent: 	[(22.0@27.0) mouseUp 13865020 nil]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(0.0@5.0) corner: (45.0@39.0)
		owner: 	a Morph(683118080)
		submorphs: 	an Array(an AlignmentMorph(37545216))
		fullBounds: 	(0@5) corner: (45@39)
		color: 	Color transparent
		extension: 	a MorphExtension (22220288) [balloonText]  [other:  (presenter -[..]
		borderWidth: 	0
		borderColor: 	#simple
		model: 	a SpMorphicToolbarButtonAdapter
		label: 	'Do it'
		icon: 	Form(13x13x32)
		getIconSelector: 	#icon
		getStateSelector: 	#state
		actionSelector: 	#execute
		font: 	a LogicalFont
 familyName: 'Source Sans Pro'
 emphasis: nil
 pointSiz[..]
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	nil
		getFontSelector: 	nil
		labelMorph: 	a LabelMorph(55328000)'Do it'
		iconMorph: 	an ImageMorph(18942720)
		iconPosition: 	#top
		lastState: 	false
		badgeFont: 	nil
		badgeSelector: 	#badge


MouseButtonEvent>>sentTo:
	Receiver: [(22.0@27.0) mouseUp 13865020 nil]
	Arguments and temporary variables: 
		anObject: 	a SpToolbarButtonMorph(737876992)
	Receiver's instance variables: 
		timeStamp: 	13865020
		source: 	a HandMorph(337424384)
		windowIndex: 	nil
		type: 	#mouseUp
		buttons: 	0
		position: 	(22.0@27.0)
		handler: 	nil
		wasHandled: 	true
		whichButton: 	4


SpToolbarButtonMorph(Morph)>>handleEvent:
	Receiver: a SpToolbarButtonMorph(737876992)
	Arguments and temporary variables: 
		anEvent: 	[(22.0@27.0) mouseUp 13865020 nil]
	Receiver's instance variables: 
		bounds: 	(0.0@5.0) corner: (45.0@39.0)
		owner: 	a Morph(683118080)
		submorphs: 	an Array(an AlignmentMorph(37545216))
		fullBounds: 	(0@5) corner: (45@39)
		color: 	Color transparent
		extension: 	a MorphExtension (22220288) [balloonText]  [other:  (presenter -[..]
		borderWidth: 	0
		borderColor: 	#simple
		model: 	a SpMorphicToolbarButtonAdapter
		label: 	'Do it'
		icon: 	Form(13x13x32)
		getIconSelector: 	#icon
		getStateSelector: 	#state
		actionSelector: 	#execute
		font: 	a LogicalFont
 familyName: 'Source Sans Pro'
 emphasis: nil
 pointSiz[..]
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	nil
		getFontSelector: 	nil
		labelMorph: 	a LabelMorph(55328000)'Do it'
		iconMorph: 	an ImageMorph(18942720)
		iconPosition: 	#top
		lastState: 	false
		badgeFont: 	nil
		badgeSelector: 	#badge


SpToolbarButtonMorph(Morph)>>handleFocusEvent:
	Receiver: a SpToolbarButtonMorph(737876992)
	Arguments and temporary variables: 
		anEvent: 	[(22.0@27.0) mouseUp 13865020 nil]
	Receiver's instance variables: 
		bounds: 	(0.0@5.0) corner: (45.0@39.0)
		owner: 	a Morph(683118080)
		submorphs: 	an Array(an AlignmentMorph(37545216))
		fullBounds: 	(0@5) corner: (45@39)
		color: 	Color transparent
		extension: 	a MorphExtension (22220288) [balloonText]  [other:  (presenter -[..]
		borderWidth: 	0
		borderColor: 	#simple
		model: 	a SpMorphicToolbarButtonAdapter
		label: 	'Do it'
		icon: 	Form(13x13x32)
		getIconSelector: 	#icon
		getStateSelector: 	#state
		actionSelector: 	#execute
		font: 	a LogicalFont
 familyName: 'Source Sans Pro'
 emphasis: nil
 pointSiz[..]
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	nil
		getFontSelector: 	nil
		labelMorph: 	a LabelMorph(55328000)'Do it'
		iconMorph: 	an ImageMorph(18942720)
		iconPosition: 	#top
		lastState: 	false
		badgeFont: 	nil
		badgeSelector: 	#badge


[
		result := focusHolder handleFocusEvent: transformedEvent.
	] in HandMorph>>sendFocusEvent:to:clear:
	Receiver: a HandMorph(337424384)
	Arguments and temporary variables: 
		anEvent: 	[(360@298) mouseUp 13865020 nil]
		focusHolder: 	a SpToolbarButtonMorph(737876992)
		aBlock: 	[self mouseFocus: nil]
		w: 	a WorldMorph(341720576) [world]
		transformedEvent: 	[(22.0@27.0) mouseUp 13865020 nil]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(556@405.0) corner: (572@421.0)
		owner: 	a WorldMorph(341720576) [world]
		submorphs: 	#()
		fullBounds: 	nil
		color: 	Color blue
		extension: 	a MorphExtension (370611968)
		mouseFocus: 	nil
		keyboardFocus: 	a RubEditingArea(626691072)
		eventListeners: 	nil
		mouseListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(548@396) mouseOver 13875725 nil]
		targetOffset: 	(178.0@15.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	Form(16x16x8)
		temporaryCursorOffset: 	(-8@ -9)
		hardwareCursor: 	((CursorWithMask
	extent: (16@16)
	depth: 1
	fromArray: #(
[..]
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 0 0 0 0 0 nil nil)
		captureBlock: 	nil
		recentModifiers: 	0
		pendingEventQueue: 	WaitfreeQueue with 0 items
		supressNextKeyPress: 	false


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
		result := focusHolder handleFocusEvent: transformedEvent.
	]
	Arguments and temporary variables: 
		exception: 	Error
		handlerAction: 	[ :ex |
			ActiveWorld := priorWorld.
			ex pass ]
	Receiver's instance variables: 
		outerContext: 	HandMorph>>sendFocusEvent:to:clear:
		compiledBlock: 	a CompiledBlock: [
		result := focusHolder handleFocusEvent:[..]
		numArgs: 	0
		receiver: 	a HandMorph(337424384)


WorldMorph>>becomeActiveDuring:
	Receiver: a WorldMorph(341720576) [world]
	Arguments and temporary variables: 
		aBlock: 	[
		result := focusHolder handleFocusEvent: transformedEvent.
	]
		priorWorld: 	a WorldMorph(341720576) [world]
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1728@1080)
		owner: 	nil
		submorphs: 	an Array(a MenubarMorph(112886016) a TaskbarMorph(279458560) a S[..]
		fullBounds: 	nil
		color: 	(Color r: 0.9403714565004888 g: 0.9403714565004888 b: 0.940371456500[..]
		extension: 	a MorphExtension (1012946432) [other:  (dragEnabled -> true) (dr[..]
		borderWidth: 	0
		borderColor: 	(Color r: 0.8611925708699902 g: 1.0 b: 0.7223851417399805 alph[..]
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil


HandMorph>>sendFocusEvent:to:clear:
	Receiver: a HandMorph(337424384)
	Arguments and temporary variables: 
		result: 	nil
		anEvent: 	[(360@298) mouseUp 13865020 nil]
		focusHolder: 	a SpToolbarButtonMorph(737876992)
		aBlock: 	[self mouseFocus: nil]
		w: 	a WorldMorph(341720576) [world]
		transformedEvent: 	[(22.0@27.0) mouseUp 13865020 nil]
	Receiver's instance variables: 
		bounds: 	(556@405.0) corner: (572@421.0)
		owner: 	a WorldMorph(341720576) [world]
		submorphs: 	#()
		fullBounds: 	nil
		color: 	Color blue
		extension: 	a MorphExtension (370611968)
		mouseFocus: 	nil
		keyboardFocus: 	a RubEditingArea(626691072)
		eventListeners: 	nil
		mouseListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(548@396) mouseOver 13875725 nil]
		targetOffset: 	(178.0@15.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	Form(16x16x8)
		temporaryCursorOffset: 	(-8@ -9)
		hardwareCursor: 	((CursorWithMask
	extent: (16@16)
	depth: 1
	fromArray: #(
[..]
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 0 0 0 0 0 nil nil)
		captureBlock: 	nil
		recentModifiers: 	0
		pendingEventQueue: 	WaitfreeQueue with 0 items
		supressNextKeyPress: 	false


HandMorph>>sendEvent:focus:clear:
	Receiver: a HandMorph(337424384)
	Arguments and temporary variables: 
		anEvent: 	[(360@298) mouseUp 13865020 nil]
		focusHolder: 	a SpToolbarButtonMorph(737876992)
		aBlock: 	[self mouseFocus: nil]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(556@405.0) corner: (572@421.0)
		owner: 	a WorldMorph(341720576) [world]
		submorphs: 	#()
		fullBounds: 	nil
		color: 	Color blue
		extension: 	a MorphExtension (370611968)
		mouseFocus: 	nil
		keyboardFocus: 	a RubEditingArea(626691072)
		eventListeners: 	nil
		mouseListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(548@396) mouseOver 13875725 nil]
		targetOffset: 	(178.0@15.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	Form(16x16x8)
		temporaryCursorOffset: 	(-8@ -9)
		hardwareCursor: 	((CursorWithMask
	extent: (16@16)
	depth: 1
	fromArray: #(
[..]
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 0 0 0 0 0 nil nil)
		captureBlock: 	nil
		recentModifiers: 	0
		pendingEventQueue: 	WaitfreeQueue with 0 items
		supressNextKeyPress: 	false


HandMorph>>sendMouseEvent:
	Receiver: a HandMorph(337424384)
	Arguments and temporary variables: 
		anEvent: 	[(360@298) mouseUp 13865020 nil]
	Receiver's instance variables: 
		bounds: 	(556@405.0) corner: (572@421.0)
		owner: 	a WorldMorph(341720576) [world]
		submorphs: 	#()
		fullBounds: 	nil
		color: 	Color blue
		extension: 	a MorphExtension (370611968)
		mouseFocus: 	nil
		keyboardFocus: 	a RubEditingArea(626691072)
		eventListeners: 	nil
		mouseListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(548@396) mouseOver 13875725 nil]
		targetOffset: 	(178.0@15.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	Form(16x16x8)
		temporaryCursorOffset: 	(-8@ -9)
		hardwareCursor: 	((CursorWithMask
	extent: (16@16)
	depth: 1
	fromArray: #(
[..]
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 0 0 0 0 0 nil nil)
		captureBlock: 	nil
		recentModifiers: 	0
		pendingEventQueue: 	WaitfreeQueue with 0 items
		supressNextKeyPress: 	false


HandMorph>>handleEvent:
	Receiver: a HandMorph(337424384)
	Arguments and temporary variables: 
		anEvent: 	[(360@298) mouseUp 13865020 nil]
		evt: 	[(360@298) mouseUp 13865020 nil]
	Receiver's instance variables: 
		bounds: 	(556@405.0) corner: (572@421.0)
		owner: 	a WorldMorph(341720576) [world]
		submorphs: 	#()
		fullBounds: 	nil
		color: 	Color blue
		extension: 	a MorphExtension (370611968)
		mouseFocus: 	nil
		keyboardFocus: 	a RubEditingArea(626691072)
		eventListeners: 	nil
		mouseListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(548@396) mouseOver 13875725 nil]
		targetOffset: 	(178.0@15.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	Form(16x16x8)
		temporaryCursorOffset: 	(-8@ -9)
		hardwareCursor: 	((CursorWithMask
	extent: (16@16)
	depth: 1
	fromArray: #(
[..]
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 0 0 0 0 0 nil nil)
		captureBlock: 	nil
		recentModifiers: 	0
		pendingEventQueue: 	WaitfreeQueue with 0 items
		supressNextKeyPress: 	false


[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil ]) ifTrue: [
			morphicWorld activeHand handleEvent: anEvent
		]
	] in OSWindowMorphicEventHandler>>dispatchMorphicEvent:
	Receiver: an OSWindowMorphicEventHandler
	Arguments and temporary variables: 
		anEvent: 	[(360@298) mouseUp 13865020 nil]
	Receiver's instance variables: 
		morphicWorld: 	a WorldMorph(341720576) [world]


WorldState>>runStepMethodsIn:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(341720576) [world]
		queue: 	WaitfreeQueue with 0 items
		nextInQueue: 	[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNo[..]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(337424384))
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap()
		lastStepTime: 	13864869
		lastStepMessage: 	nil
		alarms: 	a Heap(MorphicAlarm(#hideShow -> a RubCursor(1026113536)))
		lastAlarmTime: 	13875752
		activeHand: 	a HandMorph(337424384)
		currentCursor: 	((CursorWithMask
	extent: (16@16)
	depth: 1
	fromArray: #(
	[..]
		worldRenderer: 	an OSWorldRenderer
		realWindowExtent: 	(1728@1080)
		deferredUIMessages: 	WaitfreeQueue with 0 items


WorldMorph>>runStepMethods
	Receiver: a WorldMorph(341720576) [world]
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1728@1080)
		owner: 	nil
		submorphs: 	an Array(a MenubarMorph(112886016) a TaskbarMorph(279458560) a S[..]
		fullBounds: 	nil
		color: 	(Color r: 0.9403714565004888 g: 0.9403714565004888 b: 0.940371456500[..]
		extension: 	a MorphExtension (1012946432) [other:  (dragEnabled -> true) (dr[..]
		borderWidth: 	0
		borderColor: 	(Color r: 0.8611925708699902 g: 1.0 b: 0.7223851417399805 alph[..]
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil


WorldState>>doOneCycleFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(341720576) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(337424384))
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap()
		lastStepTime: 	13864869
		lastStepMessage: 	nil
		alarms: 	a Heap(MorphicAlarm(#hideShow -> a RubCursor(1026113536)))
		lastAlarmTime: 	13875752
		activeHand: 	a HandMorph(337424384)
		currentCursor: 	((CursorWithMask
	extent: (16@16)
	depth: 1
	fromArray: #(
	[..]
		worldRenderer: 	an OSWorldRenderer
		realWindowExtent: 	(1728@1080)
		deferredUIMessages: 	WaitfreeQueue with 0 items


WorldMorph>>doOneCycleNow
	Receiver: a WorldMorph(341720576) [world]
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1728@1080)
		owner: 	nil
		submorphs: 	an Array(a MenubarMorph(112886016) a TaskbarMorph(279458560) a S[..]
		fullBounds: 	nil
		color: 	(Color r: 0.9403714565004888 g: 0.9403714565004888 b: 0.940371456500[..]
		extension: 	a MorphExtension (1012946432) [other:  (dragEnabled -> true) (dr[..]
		borderWidth: 	0
		borderColor: 	(Color r: 0.8611925708699902 g: 1.0 b: 0.7223851417399805 alph[..]
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil


WorldMorph>>doOneCycle
	Receiver: a WorldMorph(341720576) [world]
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1728@1080)
		owner: 	nil
		submorphs: 	an Array(a MenubarMorph(112886016) a TaskbarMorph(279458560) a S[..]
		fullBounds: 	nil
		color: 	(Color r: 0.9403714565004888 g: 0.9403714565004888 b: 0.940371456500[..]
		extension: 	a MorphExtension (1012946432) [other:  (dragEnabled -> true) (dr[..]
		borderWidth: 	0
		borderColor: 	(Color r: 0.8611925708699902 g: 1.0 b: 0.7223851417399805 alph[..]
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil



--- The full stack ---
ZnCharacterReadStream(Object)>>doesNotUnderstand: #isEmpty
Path class>>from:delimiter:
MacStore(FileSystemStore)>>pathFromString:
FileSystem>>pathFromString:
FileReference(AbstractFileReference)>>/
UndefinedObject>>DoIt
OCReceiverDoItSemanticScope(OCDoItSemanticScope)>>evaluateDoIt:
OpalCompiler>>evaluate
[
		self announcer announce: (SpCodeWillBeEvaluatedAnnouncement newContent: aString).
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionModel doItReceiver.
		result := receiver class compiler
			source: aString;
			context: self interactionModel doItContext;
			receiver: self interactionModel doItReceiver;
			requestor: self interactionModel;
			environment: self environment;
			failBlock:  [ 
				self announcer announce: (SpCodeEvaluationFailedAnnouncement newContent: aString).
				^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		self announcer announce: (SpCodeEvaluationSucceedAnnouncement newContent: aString).
		result ] in SpCodePresenter>>evaluate:onCompileError:onError:
FullBlockClosure(BlockClosure)>>on:do:
SpCodePresenter>>evaluate:onCompileError:onError:
StPlaygroundPagePresenter>>doEvaluateAndGo
StPlaygroundPagePresenter>>doEvaluateAllAndGo
StPlaygroundDoItCommand>>execute
SpCommand(CmCommandDecorator)>>execute
[ specCommand execute ] in [ :specCommand | 
			aButtonClass new
				label: specCommand name;
				help: specCommand description;
				in: [ :button | 
					specCommand hasIcon
						ifTrue: [ button icon: specCommand icon ] ];
				action: [ specCommand execute ];
				yourself ] in SpCommand>>configureAsButtonOfClass:
FullBlockClosure(BlockClosure)>>cull:
SpMorphicToolbarButtonAdapter>>execute
SpToolbarButtonMorph(PluggableButtonMorph)>>performAction:
[:m |
		(m containsPoint: evt cursorPoint) ifTrue: [m enabled ifTrue: [ m performAction: evt ]]] in SpToolbarButtonMorph(PluggableButtonMorph)>>mouseUp:
Array(SequenceableCollection)>>do:
SpToolbarButtonMorph(PluggableButtonMorph)>>mouseUp:
SpToolbarButtonMorph(Morph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
SpToolbarButtonMorph(Morph)>>handleEvent:
SpToolbarButtonMorph(Morph)>>handleFocusEvent:
[
		result := focusHolder handleFocusEvent: transformedEvent.
	] in HandMorph>>sendFocusEvent:to:clear:
FullBlockClosure(BlockClosure)>>on:do:
WorldMorph>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil ]) ifTrue: [
			morphicWorld activeHand handleEvent: anEvent
		]
	] in OSWindowMorphicEventHandler>>dispatchMorphicEvent:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycleNow
WorldMorph>>doOneCycle
 - - - - - - - - - - - - - - -
			- - - - - - - - - - - - - - - - - -
[
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMutex critical: [
			                     self extraWorldList ].
		extraWorldsToDraw do: [ :world | world doOneCycle ].

		(self currentWorld isNotNil and: [
			 (extraWorldsToDraw includes: self currentWorld) not ]) ifTrue: [
			self currentWorld doOneCycle ] ] in WorldMorph class>>doOneCycle
FullBlockClosure(BlockClosure)>>ensure:
WorldState class>>doDrawCycleWith:
WorldMorph class>>doOneCycle
MorphicRenderLoop>>doOneCycle
MorphicRenderLoop>>doOneCycleWhile:
[ MorphicRenderLoop new doOneCycleWhile: [ true ] ] in MorphicUIManager>>spawnNewProcess
[self value.
			"IMPORTANT: Do not step over next line of code. See method comments for details"
			Processor terminateRealActive] in FullBlockClosure(BlockClosure)>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
Instance of RSLine did not understand #start:
13 November 2023 7:56:18.053093 pm

VM: Mac OS - arm64 - 1000 - CoInterpreter VMMaker-tonel.1 uuid: 902dd483-c0c4-0d00-86f2-0f880df24b96 Oct 23 2023
StackToRegisterMappingCogit VMMaker-tonel.1 uuid: 902dd483-c0c4-0d00-86f2-0f880df24b96 Oct 23 2023
v10.0.8 - Commit: b323c5fb - Date: 2023-10-20 16:02:07 -0400

Image: Pharo11.0.0 [Build information: Pharo-11.0.0+build.710.sha.ea28d8552cac85a7ce1e9c34ab1e7bd45f7b9910 (64 Bit)]

RSLine(Object)>>doesNotUnderstand: #start:
	Receiver: a RSLine
	Arguments and temporary variables: 
		aMessage: 	start: (0.0@0.0)
		exception: 	Instance of RSLine did not understand #start:
		resumeValue: 	nil
	Receiver's instance variables: 
		announcer: 	nil
		properties: 	nil
		paint: 	nil
		path: 	nil
		border: 	1, Color gray
		parent: 	nil
		isFixed: 	false
		encompassingRectangle: 	nil
		model: 	nil
		attachPoint: 	a RSCenteredAttachPoint
		from: 	nil
		to: 	nil
		markers: 	nil
		startPoint: 	(0@0)
		endPoint: 	(100@100)


[ :edgeDict |
        | edge sourceNode targetNode sourcePosition targetPosition |
        sourceNode := nodesMap at: (edgeDict at: #source) ifAbsent: [ nil ].
        targetNode := nodesMap at: (edgeDict at: #target) ifAbsent: [ nil ].
        sourceNode ifNotNil: [ targetNode ifNotNil: [
            sourcePosition := sourceNode position.
            targetPosition := targetNode position.
            edge := RSLine new.
            edge start: sourcePosition; end: targetPosition.
            canvas add: edge.
        ]].
    ] in GraphVisualizer>>createEdges
	Receiver: a GraphVisualizer
	Arguments and temporary variables: 
		edgeDict: 	a Dictionary('source'->1 'target'->2 'type'->'FRIENDS_WITH' )
		edge: 	a RSLine
		sourceNode: 	a RSBox
		targetNode: 	a RSBox
		sourcePosition: 	(0.0@0.0)
		targetPosition: 	(0.0@0.0)
	Receiver's instance variables: 
		view: 	nil
		nodes: 	an Array(a Dictionary('id'->1 'label'->'Person' 'properties'->a Dict[..]
		edges: 	an Array(a Dictionary('source'->1 'target'->2 'type'->'FRIENDS_WITH' ))
		nodesMap: 	a Dictionary(1->a RSBox 2->a RSBox )
		canvas: 	a RSCanvas


Array(SequenceableCollection)>>do:
	Receiver: an Array(a Dictionary('source'->1 'target'->2 'type'->'FRIENDS_WITH' ))
	Arguments and temporary variables: 
		aBlock: 	[ :edgeDict |
        | edge sourceNode targetNode sourcePosition t[..]
		index: 	1
	Receiver's instance variables: 
an Array(a Dictionary('source'->1 'target'->2 'type'->'FRIENDS_WITH' ))

GraphVisualizer>>createEdges
	Receiver: a GraphVisualizer
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		view: 	nil
		nodes: 	an Array(a Dictionary('id'->1 'label'->'Person' 'properties'->a Dict[..]
		edges: 	an Array(a Dictionary('source'->1 'target'->2 'type'->'FRIENDS_WITH' ))
		nodesMap: 	a Dictionary(1->a RSBox 2->a RSBox )
		canvas: 	a RSCanvas


GraphVisualizer>>visualizeGraphFromFile:
	Receiver: a GraphVisualizer
	Arguments and temporary variables: 
		aFilePath: 	'/Users/ryanperez/Documents/GitHub/pp-rep2533/project/src/data/t[..]
	Receiver's instance variables: 
		view: 	nil
		nodes: 	an Array(a Dictionary('id'->1 'label'->'Person' 'properties'->a Dict[..]
		edges: 	an Array(a Dictionary('source'->1 'target'->2 'type'->'FRIENDS_WITH' ))
		nodesMap: 	a Dictionary(1->a RSBox 2->a RSBox )
		canvas: 	a RSCanvas


UndefinedObject>>DoIt
	Receiver: nil
	Arguments and temporary variables: 
		visualizer: 	a GraphVisualizer
	Receiver's instance variables: 
nil

OCReceiverDoItSemanticScope(OCDoItSemanticScope)>>evaluateDoIt:
	Receiver: an OCReceiverDoItSemanticScope
	Arguments and temporary variables: 
		doItMethod: 	UndefinedObject>>#DoIt
	Receiver's instance variables: 
		outerScope: 	nil
		targetReceiver: 	nil


OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
		doItMethod: 	UndefinedObject>>#DoIt
	Receiver's instance variables: 
		ast: 	DoIt

	| visualizer |
	visualizer := GraphVisualizer new.
	^ visualize[..]
		source: 	a ReadStream
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil


[
		self announcer announce: (SpCodeWillBeEvaluatedAnnouncement newContent: aString).
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionModel doItReceiver.
		result := receiver class compiler
			source: aString;
			context: self interactionModel doItContext;
			receiver: self interactionModel doItReceiver;
			requestor: self interactionModel;
			environment: self environment;
			failBlock:  [ 
				self announcer announce: (SpCodeEvaluationFailedAnnouncement newContent: aString).
				^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		self announcer announce: (SpCodeEvaluationSucceedAnnouncement newContent: aString).
		result ] in SpCodePresenter>>evaluate:onCompileError:onError:
	Receiver: a SpCodePresenter
	Arguments and temporary variables: 
		aString: 	'| visualizer |
visualizer := GraphVisualizer new.
visualizer visu[..]
		compileErrorBlock: 	[ ^ self ]
		errorBlock: 	[ :e | e pass ]
		receiver: 	nil
		result: 	nil
		oldBindings: 	a Dictionary()
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicCodeAdapter)
		announcer: 	an Announcer
		owner: 	a StPlaygroundPagePresenter
		adapter: 	a SpMorphicCodeAdapter
		needRebuild: 	true
		eventHandler: 	a SpEventHandler
		application: 	nil
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ a KMCategory ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Code' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpAbstractWidgetLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		borderWidth: 	an ObservableValueHolder[ nil ]
		borderColor: 	an ObservableValueHolder[ nil ]
		dragEnabled: 	an ObservableValueHolder[ false ]
		dropEnabled: 	an ObservableValueHolder[ false ]
		color: 	an ObservableValueHolder[ nil ]
		help: 	an ObservableValueHolder[ nil ]
		enabled: 	an ObservableValueHolder[ true ]
		wantsDrop: 	an ObservableValueHolder[ [ :transfer | self dropEnabled ] ]
		acceptDrop: 	an ObservableValueHolder[ [ :transfer | ] ]
		deferredActions: 	nil
		hasUnacceptedEdits: 	an ObservableValueHolder[ false ]
		selection: 	an ObservableValueHolder[ (1 to: 159) ]
		wantsVisualFeedback: 	an ObservableValueHolder[ true ]
		askBeforeDiscardingEdits: 	an ObservableValueHolder[ true ]
		text: 	an ObservableValueHolder[ '| visualizer |
visualizer := GraphVisualiz[..]
		actionToPerform: 	an ObservableValueHolder[ [ :txt |  ] ]
		readSelection: 	an ObservableValueHolder[ [ selection ] ]
		placeholder: 	an ObservableValueHolder[ '' ]
		contextMenu: 	an ObservableValueHolder[ [ (self menuActionsFor: text) asMenu[..]
		scrollValue: 	an ObservableValueHolder[ (0@0) ]
		editionContextMenu: 	an ObservableValueHolder[ true ]
		editable: 	an ObservableValueHolder[ true ]
		wrapWord: 	an ObservableValueHolder[ true ]
		undoRedoHistory: 	true
		wrapScrollBars: 	true
		propagateNaturalHeight: 	false
		propagateNaturalWidth: 	false
		scrollBarStyles: 	#()
		syntaxHighlight: 	an ObservableValueHolder[ true ]
		smartCharacters: 	an ObservableValueHolder[ true ]
		lineNumbers: 	an ObservableValueHolder[ true ]
		interactionModel: 	an ObservableValueHolder[ a StPlaygroundInteractionModel ]
		overrideContextMenu: 	true
		submitBlock: 	nil
		resetBlock: 	nil
		environment: 	nil
		systemNavigation: 	nil
		syntaxHighlightTheme: 	an ObservableValueHolder[ nil ]


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
		self announcer announce: (SpCodeWillBeEvaluatedAnnouncement newContent: aString).
[..]
	Arguments and temporary variables: 
		exception: 	Error
		handlerAction: 	[ :e |
		self announcer announce: (SpCodeEvaluationFailedAnn[..]
	Receiver's instance variables: 
		outerContext: 	SpCodePresenter>>evaluate:onCompileError:onError:
		compiledBlock: 	a CompiledBlock: [
		self announcer announce: (SpCodeWillBeE[..]
		numArgs: 	0
		receiver: 	a SpCodePresenter


SpCodePresenter>>evaluate:onCompileError:onError:
	Receiver: a SpCodePresenter
	Arguments and temporary variables: 
		receiver: 	nil
		result: 	nil
		oldBindings: 	a Dictionary()
		aString: 	'| visualizer |
visualizer := GraphVisualizer new.
visualizer visu[..]
		compileErrorBlock: 	[ ^ self ]
		errorBlock: 	[ :e | e pass ]
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicCodeAdapter)
		announcer: 	an Announcer
		owner: 	a StPlaygroundPagePresenter
		adapter: 	a SpMorphicCodeAdapter
		needRebuild: 	true
		eventHandler: 	a SpEventHandler
		application: 	nil
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ a KMCategory ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Code' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpAbstractWidgetLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		borderWidth: 	an ObservableValueHolder[ nil ]
		borderColor: 	an ObservableValueHolder[ nil ]
		dragEnabled: 	an ObservableValueHolder[ false ]
		dropEnabled: 	an ObservableValueHolder[ false ]
		color: 	an ObservableValueHolder[ nil ]
		help: 	an ObservableValueHolder[ nil ]
		enabled: 	an ObservableValueHolder[ true ]
		wantsDrop: 	an ObservableValueHolder[ [ :transfer | self dropEnabled ] ]
		acceptDrop: 	an ObservableValueHolder[ [ :transfer | ] ]
		deferredActions: 	nil
		hasUnacceptedEdits: 	an ObservableValueHolder[ false ]
		selection: 	an ObservableValueHolder[ (1 to: 159) ]
		wantsVisualFeedback: 	an ObservableValueHolder[ true ]
		askBeforeDiscardingEdits: 	an ObservableValueHolder[ true ]
		text: 	an ObservableValueHolder[ '| visualizer |
visualizer := GraphVisualiz[..]
		actionToPerform: 	an ObservableValueHolder[ [ :txt |  ] ]
		readSelection: 	an ObservableValueHolder[ [ selection ] ]
		placeholder: 	an ObservableValueHolder[ '' ]
		contextMenu: 	an ObservableValueHolder[ [ (self menuActionsFor: text) asMenu[..]
		scrollValue: 	an ObservableValueHolder[ (0@0) ]
		editionContextMenu: 	an ObservableValueHolder[ true ]
		editable: 	an ObservableValueHolder[ true ]
		wrapWord: 	an ObservableValueHolder[ true ]
		undoRedoHistory: 	true
		wrapScrollBars: 	true
		propagateNaturalHeight: 	false
		propagateNaturalWidth: 	false
		scrollBarStyles: 	#()
		syntaxHighlight: 	an ObservableValueHolder[ true ]
		smartCharacters: 	an ObservableValueHolder[ true ]
		lineNumbers: 	an ObservableValueHolder[ true ]
		interactionModel: 	an ObservableValueHolder[ a StPlaygroundInteractionModel ]
		overrideContextMenu: 	true
		submitBlock: 	nil
		resetBlock: 	nil
		environment: 	nil
		systemNavigation: 	nil
		syntaxHighlightTheme: 	an ObservableValueHolder[ nil ]


StPlaygroundPagePresenter>>doEvaluateAndGo
	Receiver: a StPlaygroundPagePresenter
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicBoxAdapter)
		announcer: 	an Announcer
		owner: 	a SpMillerColumnPresenter
		adapter: 	a SpMorphicBoxAdapter
		needRebuild: 	true
		eventHandler: 	nil
		application: 	a StPharoApplication
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ nil ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Untitled window' ]
		additionalSubpresentersMap: 	a Dictionary()
		layout: 	an ObservableValueHolder[ a SpBoxLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		text: 	a SpCodePresenter
		toolbar: 	a SpToolbarPresenter
		statusbar: 	a SpPresenter
		lineLabel: 	a SpLabelPresenter
		toggleLineNumberButton: 	a SpToggleButtonPresenter
		page: 	a StPlaygroundPage
		activationBlock: 	[ :selection |
		self changeSelection: selection from: new[..]


StPlaygroundPagePresenter>>doEvaluateAllAndGo
	Receiver: a StPlaygroundPagePresenter
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicBoxAdapter)
		announcer: 	an Announcer
		owner: 	a SpMillerColumnPresenter
		adapter: 	a SpMorphicBoxAdapter
		needRebuild: 	true
		eventHandler: 	nil
		application: 	a StPharoApplication
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ nil ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Untitled window' ]
		additionalSubpresentersMap: 	a Dictionary()
		layout: 	an ObservableValueHolder[ a SpBoxLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		text: 	a SpCodePresenter
		toolbar: 	a SpToolbarPresenter
		statusbar: 	a SpPresenter
		lineLabel: 	a SpLabelPresenter
		toggleLineNumberButton: 	a SpToggleButtonPresenter
		page: 	a StPlaygroundPage
		activationBlock: 	[ :selection |
		self changeSelection: selection from: new[..]


StPlaygroundDoItCommand>>execute
	Receiver: a StPlaygroundDoItCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		context: 	a StPlaygroundPagePresenter
		basicName: 	'Do it'
		basicDescription: 	'Do it all and inspect.'


SpCommand(CmCommandDecorator)>>execute
	Receiver: a SpCommand(Do it)
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a StPlaygroundDoItCommand
		iconProvider: 	a StPharoApplication
		iconName: 	#glamorousGo
		shortcutKey: 	nil
		displayStrategy: 	a CmUIDisableWhenCantBeRun
		positionStrategy: 	a CmUILeftPositionStrategy
		buildPresenterBlock: 	[ :specCommand | 
			aButtonClass new
				label: specC[..]
		presenter: 	a SpToolbarButtonPresenter


[ specCommand execute ] in [ :specCommand | 
			aButtonClass new
				label: specCommand name;
				help: specCommand description;
				in: [ :button | 
					specCommand hasIcon
						ifTrue: [ button icon: specCommand icon ] ];
				action: [ specCommand execute ];
				yourself ] in SpCommand>>configureAsButtonOfClass:
	Receiver: a SpCommand(Do it)
	Arguments and temporary variables: 
		aButtonClass: 	nil
		specCommand: 	a SpCommand(Do it)
	Receiver's instance variables: 
		decoratedCommand: 	a StPlaygroundDoItCommand
		iconProvider: 	a StPharoApplication
		iconName: 	#glamorousGo
		shortcutKey: 	nil
		displayStrategy: 	a CmUIDisableWhenCantBeRun
		positionStrategy: 	a CmUILeftPositionStrategy
		buildPresenterBlock: 	[ :specCommand | 
			aButtonClass new
				label: specC[..]
		presenter: 	a SpToolbarButtonPresenter


FullBlockClosure(BlockClosure)>>cull:
	Receiver: [ specCommand execute ]
	Arguments and temporary variables: 
		anArg: 	a SpToolbarButtonPresenter
	Receiver's instance variables: 
		outerContext: 	[ :specCommand | 
			aButtonClass new
				label: specCommand [..]
		compiledBlock: 	a CompiledBlock: [ specCommand execute ]
		numArgs: 	0
		receiver: 	a SpCommand(Do it)


SpMorphicToolbarButtonAdapter>>execute
	Receiver: a SpMorphicToolbarButtonAdapter
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpToolbarButtonMorph(163457024))
		announcer: 	nil
		model: 	a SpToolbarButtonPresenter
		widget: 	a SpToolbarButtonMorph(163457024)
		selector: 	nil
		owner: 	a SpToolbarButtonPresenter
		unsubscribed: 	false


SpToolbarButtonMorph(PluggableButtonMorph)>>performAction:
	Receiver: a SpToolbarButtonMorph(163457024)
	Arguments and temporary variables: 
		event: 	[(28.0@16.0) mouseUp 13896165 nil]
	Receiver's instance variables: 
		bounds: 	(0.0@5.0) corner: (45.0@39.0)
		owner: 	a Morph(543889152)
		submorphs: 	an Array(an AlignmentMorph(1048008448))
		fullBounds: 	nil
		color: 	(Color r: 0.9012707722385142 g: 0.9012707722385142 b: 0.901270772238[..]
		extension: 	a MorphExtension (606190080) [balloonText]  [other:  (presenter [..]
		borderWidth: 	0
		borderColor: 	#simple
		model: 	a SpMorphicToolbarButtonAdapter
		label: 	'Do it'
		icon: 	Form(13x13x32)
		getIconSelector: 	#icon
		getStateSelector: 	#state
		actionSelector: 	#execute
		font: 	a LogicalFont
 familyName: 'Source Sans Pro'
 emphasis: nil
 pointSiz[..]
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	nil
		getFontSelector: 	nil
		labelMorph: 	a LabelMorph(576130816)'Do it'
		iconMorph: 	an ImageMorph(527603200)
		iconPosition: 	#top
		lastState: 	false
		badgeFont: 	nil
		badgeSelector: 	#badge


[:m |
		(m containsPoint: evt cursorPoint) ifTrue: [m enabled ifTrue: [ m performAction: evt ]]] in SpToolbarButtonMorph(PluggableButtonMorph)>>mouseUp:
	Receiver: a SpToolbarButtonMorph(163457024)
	Arguments and temporary variables: 
		evt: 	[(28.0@16.0) mouseUp 13896165 nil]
		all: 	an Array(a SpToolbarButtonMorph(163457024) a SpToolbarButtonMorph(6416[..]
		m: 	a SpToolbarButtonMorph(163457024)
	Receiver's instance variables: 
		bounds: 	(0.0@5.0) corner: (45.0@39.0)
		owner: 	a Morph(543889152)
		submorphs: 	an Array(an AlignmentMorph(1048008448))
		fullBounds: 	nil
		color: 	(Color r: 0.9012707722385142 g: 0.9012707722385142 b: 0.901270772238[..]
		extension: 	a MorphExtension (606190080) [balloonText]  [other:  (presenter [..]
		borderWidth: 	0
		borderColor: 	#simple
		model: 	a SpMorphicToolbarButtonAdapter
		label: 	'Do it'
		icon: 	Form(13x13x32)
		getIconSelector: 	#icon
		getStateSelector: 	#state
		actionSelector: 	#execute
		font: 	a LogicalFont
 familyName: 'Source Sans Pro'
 emphasis: nil
 pointSiz[..]
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	nil
		getFontSelector: 	nil
		labelMorph: 	a LabelMorph(576130816)'Do it'
		iconMorph: 	an ImageMorph(527603200)
		iconPosition: 	#top
		lastState: 	false
		badgeFont: 	nil
		badgeSelector: 	#badge


Array(SequenceableCollection)>>do:
	Receiver: an Array(a SpToolbarButtonMorph(163457024) a SpToolbarButtonMorph(641645312) a SpToolb[..]
	Arguments and temporary variables: 
		aBlock: 	[:m |
		(m containsPoint: evt cursorPoint) ifTrue: [m enabled ifTru[..]
		index: 	1
	Receiver's instance variables: 
an Array(a SpToolbarButtonMorph(163457024) a SpToolbarButtonMorph(641645312) a SpToolb[..]

SpToolbarButtonMorph(PluggableButtonMorph)>>mouseUp:
	Receiver: a SpToolbarButtonMorph(163457024)
	Arguments and temporary variables: 
		evt: 	[(28.0@16.0) mouseUp 13896165 nil]
		all: 	an Array(a SpToolbarButtonMorph(163457024) a SpToolbarButtonMorph(6416[..]
	Receiver's instance variables: 
		bounds: 	(0.0@5.0) corner: (45.0@39.0)
		owner: 	a Morph(543889152)
		submorphs: 	an Array(an AlignmentMorph(1048008448))
		fullBounds: 	nil
		color: 	(Color r: 0.9012707722385142 g: 0.9012707722385142 b: 0.901270772238[..]
		extension: 	a MorphExtension (606190080) [balloonText]  [other:  (presenter [..]
		borderWidth: 	0
		borderColor: 	#simple
		model: 	a SpMorphicToolbarButtonAdapter
		label: 	'Do it'
		icon: 	Form(13x13x32)
		getIconSelector: 	#icon
		getStateSelector: 	#state
		actionSelector: 	#execute
		font: 	a LogicalFont
 familyName: 'Source Sans Pro'
 emphasis: nil
 pointSiz[..]
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	nil
		getFontSelector: 	nil
		labelMorph: 	a LabelMorph(576130816)'Do it'
		iconMorph: 	an ImageMorph(527603200)
		iconPosition: 	#top
		lastState: 	false
		badgeFont: 	nil
		badgeSelector: 	#badge


SpToolbarButtonMorph(Morph)>>handleMouseUp:
	Receiver: a SpToolbarButtonMorph(163457024)
	Arguments and temporary variables: 
		anEvent: 	[(28.0@16.0) mouseUp 13896165 nil]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(0.0@5.0) corner: (45.0@39.0)
		owner: 	a Morph(543889152)
		submorphs: 	an Array(an AlignmentMorph(1048008448))
		fullBounds: 	nil
		color: 	(Color r: 0.9012707722385142 g: 0.9012707722385142 b: 0.901270772238[..]
		extension: 	a MorphExtension (606190080) [balloonText]  [other:  (presenter [..]
		borderWidth: 	0
		borderColor: 	#simple
		model: 	a SpMorphicToolbarButtonAdapter
		label: 	'Do it'
		icon: 	Form(13x13x32)
		getIconSelector: 	#icon
		getStateSelector: 	#state
		actionSelector: 	#execute
		font: 	a LogicalFont
 familyName: 'Source Sans Pro'
 emphasis: nil
 pointSiz[..]
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	nil
		getFontSelector: 	nil
		labelMorph: 	a LabelMorph(576130816)'Do it'
		iconMorph: 	an ImageMorph(527603200)
		iconPosition: 	#top
		lastState: 	false
		badgeFont: 	nil
		badgeSelector: 	#badge


MouseButtonEvent>>sentTo:
	Receiver: [(28.0@16.0) mouseUp 13896165 nil]
	Arguments and temporary variables: 
		anObject: 	a SpToolbarButtonMorph(163457024)
	Receiver's instance variables: 
		timeStamp: 	13896165
		source: 	a HandMorph(337424384)
		windowIndex: 	nil
		type: 	#mouseUp
		buttons: 	0
		position: 	(28.0@16.0)
		handler: 	nil
		wasHandled: 	true
		whichButton: 	4


SpToolbarButtonMorph(Morph)>>handleEvent:
	Receiver: a SpToolbarButtonMorph(163457024)
	Arguments and temporary variables: 
		anEvent: 	[(28.0@16.0) mouseUp 13896165 nil]
	Receiver's instance variables: 
		bounds: 	(0.0@5.0) corner: (45.0@39.0)
		owner: 	a Morph(543889152)
		submorphs: 	an Array(an AlignmentMorph(1048008448))
		fullBounds: 	nil
		color: 	(Color r: 0.9012707722385142 g: 0.9012707722385142 b: 0.901270772238[..]
		extension: 	a MorphExtension (606190080) [balloonText]  [other:  (presenter [..]
		borderWidth: 	0
		borderColor: 	#simple
		model: 	a SpMorphicToolbarButtonAdapter
		label: 	'Do it'
		icon: 	Form(13x13x32)
		getIconSelector: 	#icon
		getStateSelector: 	#state
		actionSelector: 	#execute
		font: 	a LogicalFont
 familyName: 'Source Sans Pro'
 emphasis: nil
 pointSiz[..]
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	nil
		getFontSelector: 	nil
		labelMorph: 	a LabelMorph(576130816)'Do it'
		iconMorph: 	an ImageMorph(527603200)
		iconPosition: 	#top
		lastState: 	false
		badgeFont: 	nil
		badgeSelector: 	#badge


SpToolbarButtonMorph(Morph)>>handleFocusEvent:
	Receiver: a SpToolbarButtonMorph(163457024)
	Arguments and temporary variables: 
		anEvent: 	[(28.0@16.0) mouseUp 13896165 nil]
	Receiver's instance variables: 
		bounds: 	(0.0@5.0) corner: (45.0@39.0)
		owner: 	a Morph(543889152)
		submorphs: 	an Array(an AlignmentMorph(1048008448))
		fullBounds: 	nil
		color: 	(Color r: 0.9012707722385142 g: 0.9012707722385142 b: 0.901270772238[..]
		extension: 	a MorphExtension (606190080) [balloonText]  [other:  (presenter [..]
		borderWidth: 	0
		borderColor: 	#simple
		model: 	a SpMorphicToolbarButtonAdapter
		label: 	'Do it'
		icon: 	Form(13x13x32)
		getIconSelector: 	#icon
		getStateSelector: 	#state
		actionSelector: 	#execute
		font: 	a LogicalFont
 familyName: 'Source Sans Pro'
 emphasis: nil
 pointSiz[..]
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	nil
		getFontSelector: 	nil
		labelMorph: 	a LabelMorph(576130816)'Do it'
		iconMorph: 	an ImageMorph(527603200)
		iconPosition: 	#top
		lastState: 	false
		badgeFont: 	nil
		badgeSelector: 	#badge


[
		result := focusHolder handleFocusEvent: transformedEvent.
	] in HandMorph>>sendFocusEvent:to:clear:
	Receiver: a HandMorph(337424384)
	Arguments and temporary variables: 
		anEvent: 	[(483@204) mouseUp 13896165 nil]
		focusHolder: 	a SpToolbarButtonMorph(163457024)
		aBlock: 	[self mouseFocus: nil]
		w: 	a WorldMorph(341720576) [world]
		transformedEvent: 	[(28.0@16.0) mouseUp 13896165 nil]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(483@204.0) corner: (499@220.0)
		owner: 	a WorldMorph(341720576) [world]
		submorphs: 	#()
		fullBounds: 	(483@204.0) corner: (499@220.0)
		color: 	Color blue
		extension: 	a MorphExtension (370611968)
		mouseFocus: 	nil
		keyboardFocus: 	a RubEditingArea(143191808)
		eventListeners: 	nil
		mouseListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(483@204) mouseUp 13896165 nil]
		targetOffset: 	(28.0@12.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 0 0 0 0 0 nil nil)
		captureBlock: 	nil
		recentModifiers: 	0
		pendingEventQueue: 	WaitfreeQueue with 0 items
		supressNextKeyPress: 	false


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
		result := focusHolder handleFocusEvent: transformedEvent.
	]
	Arguments and temporary variables: 
		exception: 	Error
		handlerAction: 	[ :ex |
			ActiveWorld := priorWorld.
			ex pass ]
	Receiver's instance variables: 
		outerContext: 	HandMorph>>sendFocusEvent:to:clear:
		compiledBlock: 	a CompiledBlock: [
		result := focusHolder handleFocusEvent:[..]
		numArgs: 	0
		receiver: 	a HandMorph(337424384)


WorldMorph>>becomeActiveDuring:
	Receiver: a WorldMorph(341720576) [world]
	Arguments and temporary variables: 
		aBlock: 	[
		result := focusHolder handleFocusEvent: transformedEvent.
	]
		priorWorld: 	a WorldMorph(341720576) [world]
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1728@1080)
		owner: 	nil
		submorphs: 	an Array(a MenubarMorph(112886016) a TaskbarMorph(279458560) a S[..]
		fullBounds: 	(0@0) corner: (1728@1080)
		color: 	(Color r: 0.9403714565004888 g: 0.9403714565004888 b: 0.940371456500[..]
		extension: 	a MorphExtension (1012946432) [other:  (dragEnabled -> true) (dr[..]
		borderWidth: 	0
		borderColor: 	(Color r: 0.8611925708699902 g: 1.0 b: 0.7223851417399805 alph[..]
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil


HandMorph>>sendFocusEvent:to:clear:
	Receiver: a HandMorph(337424384)
	Arguments and temporary variables: 
		result: 	nil
		anEvent: 	[(483@204) mouseUp 13896165 nil]
		focusHolder: 	a SpToolbarButtonMorph(163457024)
		aBlock: 	[self mouseFocus: nil]
		w: 	a WorldMorph(341720576) [world]
		transformedEvent: 	[(28.0@16.0) mouseUp 13896165 nil]
	Receiver's instance variables: 
		bounds: 	(483@204.0) corner: (499@220.0)
		owner: 	a WorldMorph(341720576) [world]
		submorphs: 	#()
		fullBounds: 	(483@204.0) corner: (499@220.0)
		color: 	Color blue
		extension: 	a MorphExtension (370611968)
		mouseFocus: 	nil
		keyboardFocus: 	a RubEditingArea(143191808)
		eventListeners: 	nil
		mouseListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(483@204) mouseUp 13896165 nil]
		targetOffset: 	(28.0@12.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 0 0 0 0 0 nil nil)
		captureBlock: 	nil
		recentModifiers: 	0
		pendingEventQueue: 	WaitfreeQueue with 0 items
		supressNextKeyPress: 	false


HandMorph>>sendEvent:focus:clear:
	Receiver: a HandMorph(337424384)
	Arguments and temporary variables: 
		anEvent: 	[(483@204) mouseUp 13896165 nil]
		focusHolder: 	a SpToolbarButtonMorph(163457024)
		aBlock: 	[self mouseFocus: nil]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(483@204.0) corner: (499@220.0)
		owner: 	a WorldMorph(341720576) [world]
		submorphs: 	#()
		fullBounds: 	(483@204.0) corner: (499@220.0)
		color: 	Color blue
		extension: 	a MorphExtension (370611968)
		mouseFocus: 	nil
		keyboardFocus: 	a RubEditingArea(143191808)
		eventListeners: 	nil
		mouseListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(483@204) mouseUp 13896165 nil]
		targetOffset: 	(28.0@12.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 0 0 0 0 0 nil nil)
		captureBlock: 	nil
		recentModifiers: 	0
		pendingEventQueue: 	WaitfreeQueue with 0 items
		supressNextKeyPress: 	false


HandMorph>>sendMouseEvent:
	Receiver: a HandMorph(337424384)
	Arguments and temporary variables: 
		anEvent: 	[(483@204) mouseUp 13896165 nil]
	Receiver's instance variables: 
		bounds: 	(483@204.0) corner: (499@220.0)
		owner: 	a WorldMorph(341720576) [world]
		submorphs: 	#()
		fullBounds: 	(483@204.0) corner: (499@220.0)
		color: 	Color blue
		extension: 	a MorphExtension (370611968)
		mouseFocus: 	nil
		keyboardFocus: 	a RubEditingArea(143191808)
		eventListeners: 	nil
		mouseListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(483@204) mouseUp 13896165 nil]
		targetOffset: 	(28.0@12.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 0 0 0 0 0 nil nil)
		captureBlock: 	nil
		recentModifiers: 	0
		pendingEventQueue: 	WaitfreeQueue with 0 items
		supressNextKeyPress: 	false


HandMorph>>handleEvent:
	Receiver: a HandMorph(337424384)
	Arguments and temporary variables: 
		anEvent: 	[(483@204) mouseUp 13896165 nil]
		evt: 	[(483@204) mouseUp 13896165 nil]
	Receiver's instance variables: 
		bounds: 	(483@204.0) corner: (499@220.0)
		owner: 	a WorldMorph(341720576) [world]
		submorphs: 	#()
		fullBounds: 	(483@204.0) corner: (499@220.0)
		color: 	Color blue
		extension: 	a MorphExtension (370611968)
		mouseFocus: 	nil
		keyboardFocus: 	a RubEditingArea(143191808)
		eventListeners: 	nil
		mouseListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(483@204) mouseUp 13896165 nil]
		targetOffset: 	(28.0@12.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 0 0 0 0 0 nil nil)
		captureBlock: 	nil
		recentModifiers: 	0
		pendingEventQueue: 	WaitfreeQueue with 0 items
		supressNextKeyPress: 	false


[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil ]) ifTrue: [
			morphicWorld activeHand handleEvent: anEvent
		]
	] in OSWindowMorphicEventHandler>>dispatchMorphicEvent:
	Receiver: an OSWindowMorphicEventHandler
	Arguments and temporary variables: 
		anEvent: 	[(483@204) mouseUp 13896165 nil]
	Receiver's instance variables: 
		morphicWorld: 	a WorldMorph(341720576) [world]


WorldState>>runStepMethodsIn:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(341720576) [world]
		queue: 	WaitfreeQueue with 0 items
		nextInQueue: 	[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNo[..]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(337424384))
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap()
		lastStepTime: 	13864869
		lastStepMessage: 	nil
		alarms: 	a Heap(MorphicAlarm(#hideShow -> a RubCursor(27124480)))
		lastAlarmTime: 	13896151
		activeHand: 	a HandMorph(337424384)
		currentCursor: 	((CursorWithMask
	extent: (16@16)
	depth: 1
	fromArray: #(
	[..]
		worldRenderer: 	an OSWorldRenderer
		realWindowExtent: 	(1728@1080)
		deferredUIMessages: 	WaitfreeQueue with 0 items


WorldMorph>>runStepMethods
	Receiver: a WorldMorph(341720576) [world]
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1728@1080)
		owner: 	nil
		submorphs: 	an Array(a MenubarMorph(112886016) a TaskbarMorph(279458560) a S[..]
		fullBounds: 	(0@0) corner: (1728@1080)
		color: 	(Color r: 0.9403714565004888 g: 0.9403714565004888 b: 0.940371456500[..]
		extension: 	a MorphExtension (1012946432) [other:  (dragEnabled -> true) (dr[..]
		borderWidth: 	0
		borderColor: 	(Color r: 0.8611925708699902 g: 1.0 b: 0.7223851417399805 alph[..]
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil


WorldState>>doOneCycleFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(341720576) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(337424384))
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap()
		lastStepTime: 	13864869
		lastStepMessage: 	nil
		alarms: 	a Heap(MorphicAlarm(#hideShow -> a RubCursor(27124480)))
		lastAlarmTime: 	13896151
		activeHand: 	a HandMorph(337424384)
		currentCursor: 	((CursorWithMask
	extent: (16@16)
	depth: 1
	fromArray: #(
	[..]
		worldRenderer: 	an OSWorldRenderer
		realWindowExtent: 	(1728@1080)
		deferredUIMessages: 	WaitfreeQueue with 0 items


WorldMorph>>doOneCycleNow
	Receiver: a WorldMorph(341720576) [world]
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1728@1080)
		owner: 	nil
		submorphs: 	an Array(a MenubarMorph(112886016) a TaskbarMorph(279458560) a S[..]
		fullBounds: 	(0@0) corner: (1728@1080)
		color: 	(Color r: 0.9403714565004888 g: 0.9403714565004888 b: 0.940371456500[..]
		extension: 	a MorphExtension (1012946432) [other:  (dragEnabled -> true) (dr[..]
		borderWidth: 	0
		borderColor: 	(Color r: 0.8611925708699902 g: 1.0 b: 0.7223851417399805 alph[..]
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil


WorldMorph>>doOneCycle
	Receiver: a WorldMorph(341720576) [world]
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1728@1080)
		owner: 	nil
		submorphs: 	an Array(a MenubarMorph(112886016) a TaskbarMorph(279458560) a S[..]
		fullBounds: 	(0@0) corner: (1728@1080)
		color: 	(Color r: 0.9403714565004888 g: 0.9403714565004888 b: 0.940371456500[..]
		extension: 	a MorphExtension (1012946432) [other:  (dragEnabled -> true) (dr[..]
		borderWidth: 	0
		borderColor: 	(Color r: 0.8611925708699902 g: 1.0 b: 0.7223851417399805 alph[..]
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil



--- The full stack ---
RSLine(Object)>>doesNotUnderstand: #start:
[ :edgeDict |
        | edge sourceNode targetNode sourcePosition targetPosition |
        sourceNode := nodesMap at: (edgeDict at: #source) ifAbsent: [ nil ].
        targetNode := nodesMap at: (edgeDict at: #target) ifAbsent: [ nil ].
        sourceNode ifNotNil: [ targetNode ifNotNil: [
            sourcePosition := sourceNode position.
            targetPosition := targetNode position.
            edge := RSLine new.
            edge start: sourcePosition; end: targetPosition.
            canvas add: edge.
        ]].
    ] in GraphVisualizer>>createEdges
Array(SequenceableCollection)>>do:
GraphVisualizer>>createEdges
GraphVisualizer>>visualizeGraphFromFile:
UndefinedObject>>DoIt
OCReceiverDoItSemanticScope(OCDoItSemanticScope)>>evaluateDoIt:
OpalCompiler>>evaluate
[
		self announcer announce: (SpCodeWillBeEvaluatedAnnouncement newContent: aString).
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionModel doItReceiver.
		result := receiver class compiler
			source: aString;
			context: self interactionModel doItContext;
			receiver: self interactionModel doItReceiver;
			requestor: self interactionModel;
			environment: self environment;
			failBlock:  [ 
				self announcer announce: (SpCodeEvaluationFailedAnnouncement newContent: aString).
				^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		self announcer announce: (SpCodeEvaluationSucceedAnnouncement newContent: aString).
		result ] in SpCodePresenter>>evaluate:onCompileError:onError:
FullBlockClosure(BlockClosure)>>on:do:
SpCodePresenter>>evaluate:onCompileError:onError:
StPlaygroundPagePresenter>>doEvaluateAndGo
StPlaygroundPagePresenter>>doEvaluateAllAndGo
StPlaygroundDoItCommand>>execute
SpCommand(CmCommandDecorator)>>execute
[ specCommand execute ] in [ :specCommand | 
			aButtonClass new
				label: specCommand name;
				help: specCommand description;
				in: [ :button | 
					specCommand hasIcon
						ifTrue: [ button icon: specCommand icon ] ];
				action: [ specCommand execute ];
				yourself ] in SpCommand>>configureAsButtonOfClass:
FullBlockClosure(BlockClosure)>>cull:
SpMorphicToolbarButtonAdapter>>execute
SpToolbarButtonMorph(PluggableButtonMorph)>>performAction:
[:m |
		(m containsPoint: evt cursorPoint) ifTrue: [m enabled ifTrue: [ m performAction: evt ]]] in SpToolbarButtonMorph(PluggableButtonMorph)>>mouseUp:
Array(SequenceableCollection)>>do:
SpToolbarButtonMorph(PluggableButtonMorph)>>mouseUp:
SpToolbarButtonMorph(Morph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
SpToolbarButtonMorph(Morph)>>handleEvent:
SpToolbarButtonMorph(Morph)>>handleFocusEvent:
[
		result := focusHolder handleFocusEvent: transformedEvent.
	] in HandMorph>>sendFocusEvent:to:clear:
FullBlockClosure(BlockClosure)>>on:do:
WorldMorph>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil ]) ifTrue: [
			morphicWorld activeHand handleEvent: anEvent
		]
	] in OSWindowMorphicEventHandler>>dispatchMorphicEvent:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycleNow
WorldMorph>>doOneCycle
 - - - - - - - - - - - - - - -
			- - - - - - - - - - - - - - - - - -
[
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMutex critical: [
			                     self extraWorldList ].
		extraWorldsToDraw do: [ :world | world doOneCycle ].

		(self currentWorld isNotNil and: [
			 (extraWorldsToDraw includes: self currentWorld) not ]) ifTrue: [
			self currentWorld doOneCycle ] ] in WorldMorph class>>doOneCycle
FullBlockClosure(BlockClosure)>>ensure:
WorldState class>>doDrawCycleWith:
WorldMorph class>>doOneCycle
MorphicRenderLoop>>doOneCycle
MorphicRenderLoop>>doOneCycleWhile:
[ MorphicRenderLoop new doOneCycleWhile: [ true ] ] in MorphicUIManager>>spawnNewProcess
[self value.
			"IMPORTANT: Do not step over next line of code. See method comments for details"
			Processor terminateRealActive] in FullBlockClosure(BlockClosure)>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
Instance of RSLine did not understand #start:
13 November 2023 7:56:18.077434 pm

VM: Mac OS - arm64 - 1000 - CoInterpreter VMMaker-tonel.1 uuid: 902dd483-c0c4-0d00-86f2-0f880df24b96 Oct 23 2023
StackToRegisterMappingCogit VMMaker-tonel.1 uuid: 902dd483-c0c4-0d00-86f2-0f880df24b96 Oct 23 2023
v10.0.8 - Commit: b323c5fb - Date: 2023-10-20 16:02:07 -0400

Image: Pharo11.0.0 [Build information: Pharo-11.0.0+build.710.sha.ea28d8552cac85a7ce1e9c34ab1e7bd45f7b9910 (64 Bit)]

RSLine(Object)>>doesNotUnderstand: #start:
	Receiver: a RSLine
	Arguments and temporary variables: 
		aMessage: 	start: (0.0@0.0)
		exception: 	Instance of RSLine did not understand #start:
		resumeValue: 	nil
	Receiver's instance variables: 
		announcer: 	nil
		properties: 	nil
		paint: 	nil
		path: 	nil
		border: 	1, Color gray
		parent: 	nil
		isFixed: 	false
		encompassingRectangle: 	nil
		model: 	nil
		attachPoint: 	a RSCenteredAttachPoint
		from: 	nil
		to: 	nil
		markers: 	nil
		startPoint: 	(0@0)
		endPoint: 	(100@100)


[ :edgeDict |
        | edge sourceNode targetNode sourcePosition targetPosition |
        sourceNode := nodesMap at: (edgeDict at: #source) ifAbsent: [ nil ].
        targetNode := nodesMap at: (edgeDict at: #target) ifAbsent: [ nil ].
        sourceNode ifNotNil: [ targetNode ifNotNil: [
            sourcePosition := sourceNode position.
            targetPosition := targetNode position.
            edge := RSLine new.
            edge start: sourcePosition; end: targetPosition.
            canvas add: edge.
        ]].
    ] in GraphVisualizer>>createEdges
	Receiver: a GraphVisualizer
	Arguments and temporary variables: 
		edgeDict: 	a Dictionary('source'->1 'target'->2 'type'->'FRIENDS_WITH' )
		edge: 	a RSLine
		sourceNode: 	a RSBox
		targetNode: 	a RSBox
		sourcePosition: 	(0.0@0.0)
		targetPosition: 	(0.0@0.0)
	Receiver's instance variables: 
		view: 	nil
		nodes: 	an Array(a Dictionary('id'->1 'label'->'Person' 'properties'->a Dict[..]
		edges: 	an Array(a Dictionary('source'->1 'target'->2 'type'->'FRIENDS_WITH' ))
		nodesMap: 	a Dictionary(1->a RSBox 2->a RSBox )
		canvas: 	a RSCanvas


Array(SequenceableCollection)>>do:
	Receiver: an Array(a Dictionary('source'->1 'target'->2 'type'->'FRIENDS_WITH' ))
	Arguments and temporary variables: 
		aBlock: 	[ :edgeDict |
        | edge sourceNode targetNode sourcePosition t[..]
		index: 	1
	Receiver's instance variables: 
an Array(a Dictionary('source'->1 'target'->2 'type'->'FRIENDS_WITH' ))

GraphVisualizer>>createEdges
	Receiver: a GraphVisualizer
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		view: 	nil
		nodes: 	an Array(a Dictionary('id'->1 'label'->'Person' 'properties'->a Dict[..]
		edges: 	an Array(a Dictionary('source'->1 'target'->2 'type'->'FRIENDS_WITH' ))
		nodesMap: 	a Dictionary(1->a RSBox 2->a RSBox )
		canvas: 	a RSCanvas


GraphVisualizer>>visualizeGraphFromFile:
	Receiver: a GraphVisualizer
	Arguments and temporary variables: 
		aFilePath: 	'/Users/ryanperez/Documents/GitHub/pp-rep2533/project/src/data/t[..]
	Receiver's instance variables: 
		view: 	nil
		nodes: 	an Array(a Dictionary('id'->1 'label'->'Person' 'properties'->a Dict[..]
		edges: 	an Array(a Dictionary('source'->1 'target'->2 'type'->'FRIENDS_WITH' ))
		nodesMap: 	a Dictionary(1->a RSBox 2->a RSBox )
		canvas: 	a RSCanvas


UndefinedObject>>DoIt
	Receiver: nil
	Arguments and temporary variables: 
		visualizer: 	a GraphVisualizer
	Receiver's instance variables: 
nil

OCReceiverDoItSemanticScope(OCDoItSemanticScope)>>evaluateDoIt:
	Receiver: an OCReceiverDoItSemanticScope
	Arguments and temporary variables: 
		doItMethod: 	UndefinedObject>>#DoIt
	Receiver's instance variables: 
		outerScope: 	nil
		targetReceiver: 	nil


OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
		doItMethod: 	UndefinedObject>>#DoIt
	Receiver's instance variables: 
		ast: 	DoIt

	| visualizer |
	visualizer := GraphVisualizer new.
	^ visualize[..]
		source: 	a ReadStream
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil


[
		self announcer announce: (SpCodeWillBeEvaluatedAnnouncement newContent: aString).
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionModel doItReceiver.
		result := receiver class compiler
			source: aString;
			context: self interactionModel doItContext;
			receiver: self interactionModel doItReceiver;
			requestor: self interactionModel;
			environment: self environment;
			failBlock:  [ 
				self announcer announce: (SpCodeEvaluationFailedAnnouncement newContent: aString).
				^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		self announcer announce: (SpCodeEvaluationSucceedAnnouncement newContent: aString).
		result ] in SpCodePresenter>>evaluate:onCompileError:onError:
	Receiver: a SpCodePresenter
	Arguments and temporary variables: 
		aString: 	'| visualizer |
visualizer := GraphVisualizer new.
visualizer visu[..]
		compileErrorBlock: 	[ ^ self ]
		errorBlock: 	[ :e | e pass ]
		receiver: 	nil
		result: 	nil
		oldBindings: 	a Dictionary()
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicCodeAdapter)
		announcer: 	an Announcer
		owner: 	a StPlaygroundPagePresenter
		adapter: 	a SpMorphicCodeAdapter
		needRebuild: 	true
		eventHandler: 	a SpEventHandler
		application: 	nil
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ a KMCategory ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Code' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpAbstractWidgetLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		borderWidth: 	an ObservableValueHolder[ nil ]
		borderColor: 	an ObservableValueHolder[ nil ]
		dragEnabled: 	an ObservableValueHolder[ false ]
		dropEnabled: 	an ObservableValueHolder[ false ]
		color: 	an ObservableValueHolder[ nil ]
		help: 	an ObservableValueHolder[ nil ]
		enabled: 	an ObservableValueHolder[ true ]
		wantsDrop: 	an ObservableValueHolder[ [ :transfer | self dropEnabled ] ]
		acceptDrop: 	an ObservableValueHolder[ [ :transfer | ] ]
		deferredActions: 	nil
		hasUnacceptedEdits: 	an ObservableValueHolder[ false ]
		selection: 	an ObservableValueHolder[ (1 to: 159) ]
		wantsVisualFeedback: 	an ObservableValueHolder[ true ]
		askBeforeDiscardingEdits: 	an ObservableValueHolder[ true ]
		text: 	an ObservableValueHolder[ '| visualizer |
visualizer := GraphVisualiz[..]
		actionToPerform: 	an ObservableValueHolder[ [ :txt |  ] ]
		readSelection: 	an ObservableValueHolder[ [ selection ] ]
		placeholder: 	an ObservableValueHolder[ '' ]
		contextMenu: 	an ObservableValueHolder[ [ (self menuActionsFor: text) asMenu[..]
		scrollValue: 	an ObservableValueHolder[ (0@0) ]
		editionContextMenu: 	an ObservableValueHolder[ true ]
		editable: 	an ObservableValueHolder[ true ]
		wrapWord: 	an ObservableValueHolder[ true ]
		undoRedoHistory: 	true
		wrapScrollBars: 	true
		propagateNaturalHeight: 	false
		propagateNaturalWidth: 	false
		scrollBarStyles: 	#()
		syntaxHighlight: 	an ObservableValueHolder[ true ]
		smartCharacters: 	an ObservableValueHolder[ true ]
		lineNumbers: 	an ObservableValueHolder[ true ]
		interactionModel: 	an ObservableValueHolder[ a StPlaygroundInteractionModel ]
		overrideContextMenu: 	true
		submitBlock: 	nil
		resetBlock: 	nil
		environment: 	nil
		systemNavigation: 	nil
		syntaxHighlightTheme: 	an ObservableValueHolder[ nil ]


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
		self announcer announce: (SpCodeWillBeEvaluatedAnnouncement newContent: aString).
[..]
	Arguments and temporary variables: 
		exception: 	Error
		handlerAction: 	[ :e |
		self announcer announce: (SpCodeEvaluationFailedAnn[..]
	Receiver's instance variables: 
		outerContext: 	SpCodePresenter>>evaluate:onCompileError:onError:
		compiledBlock: 	a CompiledBlock: [
		self announcer announce: (SpCodeWillBeE[..]
		numArgs: 	0
		receiver: 	a SpCodePresenter


SpCodePresenter>>evaluate:onCompileError:onError:
	Receiver: a SpCodePresenter
	Arguments and temporary variables: 
		receiver: 	nil
		result: 	nil
		oldBindings: 	a Dictionary()
		aString: 	'| visualizer |
visualizer := GraphVisualizer new.
visualizer visu[..]
		compileErrorBlock: 	[ ^ self ]
		errorBlock: 	[ :e | e pass ]
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicCodeAdapter)
		announcer: 	an Announcer
		owner: 	a StPlaygroundPagePresenter
		adapter: 	a SpMorphicCodeAdapter
		needRebuild: 	true
		eventHandler: 	a SpEventHandler
		application: 	nil
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ a KMCategory ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Code' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpAbstractWidgetLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		borderWidth: 	an ObservableValueHolder[ nil ]
		borderColor: 	an ObservableValueHolder[ nil ]
		dragEnabled: 	an ObservableValueHolder[ false ]
		dropEnabled: 	an ObservableValueHolder[ false ]
		color: 	an ObservableValueHolder[ nil ]
		help: 	an ObservableValueHolder[ nil ]
		enabled: 	an ObservableValueHolder[ true ]
		wantsDrop: 	an ObservableValueHolder[ [ :transfer | self dropEnabled ] ]
		acceptDrop: 	an ObservableValueHolder[ [ :transfer | ] ]
		deferredActions: 	nil
		hasUnacceptedEdits: 	an ObservableValueHolder[ false ]
		selection: 	an ObservableValueHolder[ (1 to: 159) ]
		wantsVisualFeedback: 	an ObservableValueHolder[ true ]
		askBeforeDiscardingEdits: 	an ObservableValueHolder[ true ]
		text: 	an ObservableValueHolder[ '| visualizer |
visualizer := GraphVisualiz[..]
		actionToPerform: 	an ObservableValueHolder[ [ :txt |  ] ]
		readSelection: 	an ObservableValueHolder[ [ selection ] ]
		placeholder: 	an ObservableValueHolder[ '' ]
		contextMenu: 	an ObservableValueHolder[ [ (self menuActionsFor: text) asMenu[..]
		scrollValue: 	an ObservableValueHolder[ (0@0) ]
		editionContextMenu: 	an ObservableValueHolder[ true ]
		editable: 	an ObservableValueHolder[ true ]
		wrapWord: 	an ObservableValueHolder[ true ]
		undoRedoHistory: 	true
		wrapScrollBars: 	true
		propagateNaturalHeight: 	false
		propagateNaturalWidth: 	false
		scrollBarStyles: 	#()
		syntaxHighlight: 	an ObservableValueHolder[ true ]
		smartCharacters: 	an ObservableValueHolder[ true ]
		lineNumbers: 	an ObservableValueHolder[ true ]
		interactionModel: 	an ObservableValueHolder[ a StPlaygroundInteractionModel ]
		overrideContextMenu: 	true
		submitBlock: 	nil
		resetBlock: 	nil
		environment: 	nil
		systemNavigation: 	nil
		syntaxHighlightTheme: 	an ObservableValueHolder[ nil ]


StPlaygroundPagePresenter>>doEvaluateAndGo
	Receiver: a StPlaygroundPagePresenter
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicBoxAdapter)
		announcer: 	an Announcer
		owner: 	a SpMillerColumnPresenter
		adapter: 	a SpMorphicBoxAdapter
		needRebuild: 	true
		eventHandler: 	nil
		application: 	a StPharoApplication
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ nil ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Untitled window' ]
		additionalSubpresentersMap: 	a Dictionary()
		layout: 	an ObservableValueHolder[ a SpBoxLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		text: 	a SpCodePresenter
		toolbar: 	a SpToolbarPresenter
		statusbar: 	a SpPresenter
		lineLabel: 	a SpLabelPresenter
		toggleLineNumberButton: 	a SpToggleButtonPresenter
		page: 	a StPlaygroundPage
		activationBlock: 	[ :selection |
		self changeSelection: selection from: new[..]


StPlaygroundPagePresenter>>doEvaluateAllAndGo
	Receiver: a StPlaygroundPagePresenter
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicBoxAdapter)
		announcer: 	an Announcer
		owner: 	a SpMillerColumnPresenter
		adapter: 	a SpMorphicBoxAdapter
		needRebuild: 	true
		eventHandler: 	nil
		application: 	a StPharoApplication
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ nil ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Untitled window' ]
		additionalSubpresentersMap: 	a Dictionary()
		layout: 	an ObservableValueHolder[ a SpBoxLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		text: 	a SpCodePresenter
		toolbar: 	a SpToolbarPresenter
		statusbar: 	a SpPresenter
		lineLabel: 	a SpLabelPresenter
		toggleLineNumberButton: 	a SpToggleButtonPresenter
		page: 	a StPlaygroundPage
		activationBlock: 	[ :selection |
		self changeSelection: selection from: new[..]


StPlaygroundDoItCommand>>execute
	Receiver: a StPlaygroundDoItCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		context: 	a StPlaygroundPagePresenter
		basicName: 	'Do it'
		basicDescription: 	'Do it all and inspect.'


SpCommand(CmCommandDecorator)>>execute
	Receiver: a SpCommand(Do it)
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a StPlaygroundDoItCommand
		iconProvider: 	a StPharoApplication
		iconName: 	#glamorousGo
		shortcutKey: 	nil
		displayStrategy: 	a CmUIDisableWhenCantBeRun
		positionStrategy: 	a CmUILeftPositionStrategy
		buildPresenterBlock: 	[ :specCommand | 
			aButtonClass new
				label: specC[..]
		presenter: 	a SpToolbarButtonPresenter


[ specCommand execute ] in [ :specCommand | 
			aButtonClass new
				label: specCommand name;
				help: specCommand description;
				in: [ :button | 
					specCommand hasIcon
						ifTrue: [ button icon: specCommand icon ] ];
				action: [ specCommand execute ];
				yourself ] in SpCommand>>configureAsButtonOfClass:
	Receiver: a SpCommand(Do it)
	Arguments and temporary variables: 
		aButtonClass: 	nil
		specCommand: 	a SpCommand(Do it)
	Receiver's instance variables: 
		decoratedCommand: 	a StPlaygroundDoItCommand
		iconProvider: 	a StPharoApplication
		iconName: 	#glamorousGo
		shortcutKey: 	nil
		displayStrategy: 	a CmUIDisableWhenCantBeRun
		positionStrategy: 	a CmUILeftPositionStrategy
		buildPresenterBlock: 	[ :specCommand | 
			aButtonClass new
				label: specC[..]
		presenter: 	a SpToolbarButtonPresenter


FullBlockClosure(BlockClosure)>>cull:
	Receiver: [ specCommand execute ]
	Arguments and temporary variables: 
		anArg: 	a SpToolbarButtonPresenter
	Receiver's instance variables: 
		outerContext: 	[ :specCommand | 
			aButtonClass new
				label: specCommand [..]
		compiledBlock: 	a CompiledBlock: [ specCommand execute ]
		numArgs: 	0
		receiver: 	a SpCommand(Do it)


SpMorphicToolbarButtonAdapter>>execute
	Receiver: a SpMorphicToolbarButtonAdapter
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpToolbarButtonMorph(163457024))
		announcer: 	nil
		model: 	a SpToolbarButtonPresenter
		widget: 	a SpToolbarButtonMorph(163457024)
		selector: 	nil
		owner: 	a SpToolbarButtonPresenter
		unsubscribed: 	false


SpToolbarButtonMorph(PluggableButtonMorph)>>performAction:
	Receiver: a SpToolbarButtonMorph(163457024)
	Arguments and temporary variables: 
		event: 	[(28.0@16.0) mouseUp 13896165 nil]
	Receiver's instance variables: 
		bounds: 	(0.0@5.0) corner: (45.0@39.0)
		owner: 	a Morph(543889152)
		submorphs: 	an Array(an AlignmentMorph(1048008448))
		fullBounds: 	nil
		color: 	(Color r: 0.9012707722385142 g: 0.9012707722385142 b: 0.901270772238[..]
		extension: 	a MorphExtension (606190080) [balloonText]  [other:  (presenter [..]
		borderWidth: 	0
		borderColor: 	#simple
		model: 	a SpMorphicToolbarButtonAdapter
		label: 	'Do it'
		icon: 	Form(13x13x32)
		getIconSelector: 	#icon
		getStateSelector: 	#state
		actionSelector: 	#execute
		font: 	a LogicalFont
 familyName: 'Source Sans Pro'
 emphasis: nil
 pointSiz[..]
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	nil
		getFontSelector: 	nil
		labelMorph: 	a LabelMorph(576130816)'Do it'
		iconMorph: 	an ImageMorph(527603200)
		iconPosition: 	#top
		lastState: 	false
		badgeFont: 	nil
		badgeSelector: 	#badge


[:m |
		(m containsPoint: evt cursorPoint) ifTrue: [m enabled ifTrue: [ m performAction: evt ]]] in SpToolbarButtonMorph(PluggableButtonMorph)>>mouseUp:
	Receiver: a SpToolbarButtonMorph(163457024)
	Arguments and temporary variables: 
		evt: 	[(28.0@16.0) mouseUp 13896165 nil]
		all: 	an Array(a SpToolbarButtonMorph(163457024) a SpToolbarButtonMorph(6416[..]
		m: 	a SpToolbarButtonMorph(163457024)
	Receiver's instance variables: 
		bounds: 	(0.0@5.0) corner: (45.0@39.0)
		owner: 	a Morph(543889152)
		submorphs: 	an Array(an AlignmentMorph(1048008448))
		fullBounds: 	nil
		color: 	(Color r: 0.9012707722385142 g: 0.9012707722385142 b: 0.901270772238[..]
		extension: 	a MorphExtension (606190080) [balloonText]  [other:  (presenter [..]
		borderWidth: 	0
		borderColor: 	#simple
		model: 	a SpMorphicToolbarButtonAdapter
		label: 	'Do it'
		icon: 	Form(13x13x32)
		getIconSelector: 	#icon
		getStateSelector: 	#state
		actionSelector: 	#execute
		font: 	a LogicalFont
 familyName: 'Source Sans Pro'
 emphasis: nil
 pointSiz[..]
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	nil
		getFontSelector: 	nil
		labelMorph: 	a LabelMorph(576130816)'Do it'
		iconMorph: 	an ImageMorph(527603200)
		iconPosition: 	#top
		lastState: 	false
		badgeFont: 	nil
		badgeSelector: 	#badge


Array(SequenceableCollection)>>do:
	Receiver: an Array(a SpToolbarButtonMorph(163457024) a SpToolbarButtonMorph(641645312) a SpToolb[..]
	Arguments and temporary variables: 
		aBlock: 	[:m |
		(m containsPoint: evt cursorPoint) ifTrue: [m enabled ifTru[..]
		index: 	1
	Receiver's instance variables: 
an Array(a SpToolbarButtonMorph(163457024) a SpToolbarButtonMorph(641645312) a SpToolb[..]

SpToolbarButtonMorph(PluggableButtonMorph)>>mouseUp:
	Receiver: a SpToolbarButtonMorph(163457024)
	Arguments and temporary variables: 
		evt: 	[(28.0@16.0) mouseUp 13896165 nil]
		all: 	an Array(a SpToolbarButtonMorph(163457024) a SpToolbarButtonMorph(6416[..]
	Receiver's instance variables: 
		bounds: 	(0.0@5.0) corner: (45.0@39.0)
		owner: 	a Morph(543889152)
		submorphs: 	an Array(an AlignmentMorph(1048008448))
		fullBounds: 	nil
		color: 	(Color r: 0.9012707722385142 g: 0.9012707722385142 b: 0.901270772238[..]
		extension: 	a MorphExtension (606190080) [balloonText]  [other:  (presenter [..]
		borderWidth: 	0
		borderColor: 	#simple
		model: 	a SpMorphicToolbarButtonAdapter
		label: 	'Do it'
		icon: 	Form(13x13x32)
		getIconSelector: 	#icon
		getStateSelector: 	#state
		actionSelector: 	#execute
		font: 	a LogicalFont
 familyName: 'Source Sans Pro'
 emphasis: nil
 pointSiz[..]
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	nil
		getFontSelector: 	nil
		labelMorph: 	a LabelMorph(576130816)'Do it'
		iconMorph: 	an ImageMorph(527603200)
		iconPosition: 	#top
		lastState: 	false
		badgeFont: 	nil
		badgeSelector: 	#badge


SpToolbarButtonMorph(Morph)>>handleMouseUp:
	Receiver: a SpToolbarButtonMorph(163457024)
	Arguments and temporary variables: 
		anEvent: 	[(28.0@16.0) mouseUp 13896165 nil]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(0.0@5.0) corner: (45.0@39.0)
		owner: 	a Morph(543889152)
		submorphs: 	an Array(an AlignmentMorph(1048008448))
		fullBounds: 	nil
		color: 	(Color r: 0.9012707722385142 g: 0.9012707722385142 b: 0.901270772238[..]
		extension: 	a MorphExtension (606190080) [balloonText]  [other:  (presenter [..]
		borderWidth: 	0
		borderColor: 	#simple
		model: 	a SpMorphicToolbarButtonAdapter
		label: 	'Do it'
		icon: 	Form(13x13x32)
		getIconSelector: 	#icon
		getStateSelector: 	#state
		actionSelector: 	#execute
		font: 	a LogicalFont
 familyName: 'Source Sans Pro'
 emphasis: nil
 pointSiz[..]
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	nil
		getFontSelector: 	nil
		labelMorph: 	a LabelMorph(576130816)'Do it'
		iconMorph: 	an ImageMorph(527603200)
		iconPosition: 	#top
		lastState: 	false
		badgeFont: 	nil
		badgeSelector: 	#badge


MouseButtonEvent>>sentTo:
	Receiver: [(28.0@16.0) mouseUp 13896165 nil]
	Arguments and temporary variables: 
		anObject: 	a SpToolbarButtonMorph(163457024)
	Receiver's instance variables: 
		timeStamp: 	13896165
		source: 	a HandMorph(337424384)
		windowIndex: 	nil
		type: 	#mouseUp
		buttons: 	0
		position: 	(28.0@16.0)
		handler: 	nil
		wasHandled: 	true
		whichButton: 	4


SpToolbarButtonMorph(Morph)>>handleEvent:
	Receiver: a SpToolbarButtonMorph(163457024)
	Arguments and temporary variables: 
		anEvent: 	[(28.0@16.0) mouseUp 13896165 nil]
	Receiver's instance variables: 
		bounds: 	(0.0@5.0) corner: (45.0@39.0)
		owner: 	a Morph(543889152)
		submorphs: 	an Array(an AlignmentMorph(1048008448))
		fullBounds: 	nil
		color: 	(Color r: 0.9012707722385142 g: 0.9012707722385142 b: 0.901270772238[..]
		extension: 	a MorphExtension (606190080) [balloonText]  [other:  (presenter [..]
		borderWidth: 	0
		borderColor: 	#simple
		model: 	a SpMorphicToolbarButtonAdapter
		label: 	'Do it'
		icon: 	Form(13x13x32)
		getIconSelector: 	#icon
		getStateSelector: 	#state
		actionSelector: 	#execute
		font: 	a LogicalFont
 familyName: 'Source Sans Pro'
 emphasis: nil
 pointSiz[..]
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	nil
		getFontSelector: 	nil
		labelMorph: 	a LabelMorph(576130816)'Do it'
		iconMorph: 	an ImageMorph(527603200)
		iconPosition: 	#top
		lastState: 	false
		badgeFont: 	nil
		badgeSelector: 	#badge


SpToolbarButtonMorph(Morph)>>handleFocusEvent:
	Receiver: a SpToolbarButtonMorph(163457024)
	Arguments and temporary variables: 
		anEvent: 	[(28.0@16.0) mouseUp 13896165 nil]
	Receiver's instance variables: 
		bounds: 	(0.0@5.0) corner: (45.0@39.0)
		owner: 	a Morph(543889152)
		submorphs: 	an Array(an AlignmentMorph(1048008448))
		fullBounds: 	nil
		color: 	(Color r: 0.9012707722385142 g: 0.9012707722385142 b: 0.901270772238[..]
		extension: 	a MorphExtension (606190080) [balloonText]  [other:  (presenter [..]
		borderWidth: 	0
		borderColor: 	#simple
		model: 	a SpMorphicToolbarButtonAdapter
		label: 	'Do it'
		icon: 	Form(13x13x32)
		getIconSelector: 	#icon
		getStateSelector: 	#state
		actionSelector: 	#execute
		font: 	a LogicalFont
 familyName: 'Source Sans Pro'
 emphasis: nil
 pointSiz[..]
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	nil
		getFontSelector: 	nil
		labelMorph: 	a LabelMorph(576130816)'Do it'
		iconMorph: 	an ImageMorph(527603200)
		iconPosition: 	#top
		lastState: 	false
		badgeFont: 	nil
		badgeSelector: 	#badge


[
		result := focusHolder handleFocusEvent: transformedEvent.
	] in HandMorph>>sendFocusEvent:to:clear:
	Receiver: a HandMorph(337424384)
	Arguments and temporary variables: 
		anEvent: 	[(483@204) mouseUp 13896165 nil]
		focusHolder: 	a SpToolbarButtonMorph(163457024)
		aBlock: 	[self mouseFocus: nil]
		w: 	a WorldMorph(341720576) [world]
		transformedEvent: 	[(28.0@16.0) mouseUp 13896165 nil]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(483@204.0) corner: (499@220.0)
		owner: 	a WorldMorph(341720576) [world]
		submorphs: 	#()
		fullBounds: 	(483@204.0) corner: (499@220.0)
		color: 	Color blue
		extension: 	a MorphExtension (370611968)
		mouseFocus: 	nil
		keyboardFocus: 	a RubEditingArea(143191808)
		eventListeners: 	nil
		mouseListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(483@204) mouseUp 13896165 nil]
		targetOffset: 	(28.0@12.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 0 0 0 0 0 nil nil)
		captureBlock: 	nil
		recentModifiers: 	0
		pendingEventQueue: 	WaitfreeQueue with 0 items
		supressNextKeyPress: 	false


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
		result := focusHolder handleFocusEvent: transformedEvent.
	]
	Arguments and temporary variables: 
		exception: 	Error
		handlerAction: 	[ :ex |
			ActiveWorld := priorWorld.
			ex pass ]
	Receiver's instance variables: 
		outerContext: 	HandMorph>>sendFocusEvent:to:clear:
		compiledBlock: 	a CompiledBlock: [
		result := focusHolder handleFocusEvent:[..]
		numArgs: 	0
		receiver: 	a HandMorph(337424384)


WorldMorph>>becomeActiveDuring:
	Receiver: a WorldMorph(341720576) [world]
	Arguments and temporary variables: 
		aBlock: 	[
		result := focusHolder handleFocusEvent: transformedEvent.
	]
		priorWorld: 	a WorldMorph(341720576) [world]
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1728@1080)
		owner: 	nil
		submorphs: 	an Array(a MenubarMorph(112886016) a TaskbarMorph(279458560) a S[..]
		fullBounds: 	(0@0) corner: (1728@1080)
		color: 	(Color r: 0.9403714565004888 g: 0.9403714565004888 b: 0.940371456500[..]
		extension: 	a MorphExtension (1012946432) [other:  (dragEnabled -> true) (dr[..]
		borderWidth: 	0
		borderColor: 	(Color r: 0.8611925708699902 g: 1.0 b: 0.7223851417399805 alph[..]
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil


HandMorph>>sendFocusEvent:to:clear:
	Receiver: a HandMorph(337424384)
	Arguments and temporary variables: 
		result: 	nil
		anEvent: 	[(483@204) mouseUp 13896165 nil]
		focusHolder: 	a SpToolbarButtonMorph(163457024)
		aBlock: 	[self mouseFocus: nil]
		w: 	a WorldMorph(341720576) [world]
		transformedEvent: 	[(28.0@16.0) mouseUp 13896165 nil]
	Receiver's instance variables: 
		bounds: 	(483@204.0) corner: (499@220.0)
		owner: 	a WorldMorph(341720576) [world]
		submorphs: 	#()
		fullBounds: 	(483@204.0) corner: (499@220.0)
		color: 	Color blue
		extension: 	a MorphExtension (370611968)
		mouseFocus: 	nil
		keyboardFocus: 	a RubEditingArea(143191808)
		eventListeners: 	nil
		mouseListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(483@204) mouseUp 13896165 nil]
		targetOffset: 	(28.0@12.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 0 0 0 0 0 nil nil)
		captureBlock: 	nil
		recentModifiers: 	0
		pendingEventQueue: 	WaitfreeQueue with 0 items
		supressNextKeyPress: 	false


HandMorph>>sendEvent:focus:clear:
	Receiver: a HandMorph(337424384)
	Arguments and temporary variables: 
		anEvent: 	[(483@204) mouseUp 13896165 nil]
		focusHolder: 	a SpToolbarButtonMorph(163457024)
		aBlock: 	[self mouseFocus: nil]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(483@204.0) corner: (499@220.0)
		owner: 	a WorldMorph(341720576) [world]
		submorphs: 	#()
		fullBounds: 	(483@204.0) corner: (499@220.0)
		color: 	Color blue
		extension: 	a MorphExtension (370611968)
		mouseFocus: 	nil
		keyboardFocus: 	a RubEditingArea(143191808)
		eventListeners: 	nil
		mouseListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(483@204) mouseUp 13896165 nil]
		targetOffset: 	(28.0@12.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 0 0 0 0 0 nil nil)
		captureBlock: 	nil
		recentModifiers: 	0
		pendingEventQueue: 	WaitfreeQueue with 0 items
		supressNextKeyPress: 	false


HandMorph>>sendMouseEvent:
	Receiver: a HandMorph(337424384)
	Arguments and temporary variables: 
		anEvent: 	[(483@204) mouseUp 13896165 nil]
	Receiver's instance variables: 
		bounds: 	(483@204.0) corner: (499@220.0)
		owner: 	a WorldMorph(341720576) [world]
		submorphs: 	#()
		fullBounds: 	(483@204.0) corner: (499@220.0)
		color: 	Color blue
		extension: 	a MorphExtension (370611968)
		mouseFocus: 	nil
		keyboardFocus: 	a RubEditingArea(143191808)
		eventListeners: 	nil
		mouseListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(483@204) mouseUp 13896165 nil]
		targetOffset: 	(28.0@12.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 0 0 0 0 0 nil nil)
		captureBlock: 	nil
		recentModifiers: 	0
		pendingEventQueue: 	WaitfreeQueue with 0 items
		supressNextKeyPress: 	false


HandMorph>>handleEvent:
	Receiver: a HandMorph(337424384)
	Arguments and temporary variables: 
		anEvent: 	[(483@204) mouseUp 13896165 nil]
		evt: 	[(483@204) mouseUp 13896165 nil]
	Receiver's instance variables: 
		bounds: 	(483@204.0) corner: (499@220.0)
		owner: 	a WorldMorph(341720576) [world]
		submorphs: 	#()
		fullBounds: 	(483@204.0) corner: (499@220.0)
		color: 	Color blue
		extension: 	a MorphExtension (370611968)
		mouseFocus: 	nil
		keyboardFocus: 	a RubEditingArea(143191808)
		eventListeners: 	nil
		mouseListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(483@204) mouseUp 13896165 nil]
		targetOffset: 	(28.0@12.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 0 0 0 0 0 nil nil)
		captureBlock: 	nil
		recentModifiers: 	0
		pendingEventQueue: 	WaitfreeQueue with 0 items
		supressNextKeyPress: 	false


[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil ]) ifTrue: [
			morphicWorld activeHand handleEvent: anEvent
		]
	] in OSWindowMorphicEventHandler>>dispatchMorphicEvent:
	Receiver: an OSWindowMorphicEventHandler
	Arguments and temporary variables: 
		anEvent: 	[(483@204) mouseUp 13896165 nil]
	Receiver's instance variables: 
		morphicWorld: 	a WorldMorph(341720576) [world]


WorldState>>runStepMethodsIn:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(341720576) [world]
		queue: 	WaitfreeQueue with 0 items
		nextInQueue: 	[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNo[..]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(337424384))
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap()
		lastStepTime: 	13864869
		lastStepMessage: 	nil
		alarms: 	a Heap(MorphicAlarm(#hideShow -> a RubCursor(27124480)))
		lastAlarmTime: 	13896151
		activeHand: 	a HandMorph(337424384)
		currentCursor: 	((CursorWithMask
	extent: (16@16)
	depth: 1
	fromArray: #(
	[..]
		worldRenderer: 	an OSWorldRenderer
		realWindowExtent: 	(1728@1080)
		deferredUIMessages: 	WaitfreeQueue with 0 items


WorldMorph>>runStepMethods
	Receiver: a WorldMorph(341720576) [world]
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1728@1080)
		owner: 	nil
		submorphs: 	an Array(a MenubarMorph(112886016) a TaskbarMorph(279458560) a S[..]
		fullBounds: 	(0@0) corner: (1728@1080)
		color: 	(Color r: 0.9403714565004888 g: 0.9403714565004888 b: 0.940371456500[..]
		extension: 	a MorphExtension (1012946432) [other:  (dragEnabled -> true) (dr[..]
		borderWidth: 	0
		borderColor: 	(Color r: 0.8611925708699902 g: 1.0 b: 0.7223851417399805 alph[..]
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil


WorldState>>doOneCycleFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(341720576) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(337424384))
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap()
		lastStepTime: 	13864869
		lastStepMessage: 	nil
		alarms: 	a Heap(MorphicAlarm(#hideShow -> a RubCursor(27124480)))
		lastAlarmTime: 	13896151
		activeHand: 	a HandMorph(337424384)
		currentCursor: 	((CursorWithMask
	extent: (16@16)
	depth: 1
	fromArray: #(
	[..]
		worldRenderer: 	an OSWorldRenderer
		realWindowExtent: 	(1728@1080)
		deferredUIMessages: 	WaitfreeQueue with 0 items


WorldMorph>>doOneCycleNow
	Receiver: a WorldMorph(341720576) [world]
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1728@1080)
		owner: 	nil
		submorphs: 	an Array(a MenubarMorph(112886016) a TaskbarMorph(279458560) a S[..]
		fullBounds: 	(0@0) corner: (1728@1080)
		color: 	(Color r: 0.9403714565004888 g: 0.9403714565004888 b: 0.940371456500[..]
		extension: 	a MorphExtension (1012946432) [other:  (dragEnabled -> true) (dr[..]
		borderWidth: 	0
		borderColor: 	(Color r: 0.8611925708699902 g: 1.0 b: 0.7223851417399805 alph[..]
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil


WorldMorph>>doOneCycle
	Receiver: a WorldMorph(341720576) [world]
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1728@1080)
		owner: 	nil
		submorphs: 	an Array(a MenubarMorph(112886016) a TaskbarMorph(279458560) a S[..]
		fullBounds: 	(0@0) corner: (1728@1080)
		color: 	(Color r: 0.9403714565004888 g: 0.9403714565004888 b: 0.940371456500[..]
		extension: 	a MorphExtension (1012946432) [other:  (dragEnabled -> true) (dr[..]
		borderWidth: 	0
		borderColor: 	(Color r: 0.8611925708699902 g: 1.0 b: 0.7223851417399805 alph[..]
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil



--- The full stack ---
RSLine(Object)>>doesNotUnderstand: #start:
[ :edgeDict |
        | edge sourceNode targetNode sourcePosition targetPosition |
        sourceNode := nodesMap at: (edgeDict at: #source) ifAbsent: [ nil ].
        targetNode := nodesMap at: (edgeDict at: #target) ifAbsent: [ nil ].
        sourceNode ifNotNil: [ targetNode ifNotNil: [
            sourcePosition := sourceNode position.
            targetPosition := targetNode position.
            edge := RSLine new.
            edge start: sourcePosition; end: targetPosition.
            canvas add: edge.
        ]].
    ] in GraphVisualizer>>createEdges
Array(SequenceableCollection)>>do:
GraphVisualizer>>createEdges
GraphVisualizer>>visualizeGraphFromFile:
UndefinedObject>>DoIt
OCReceiverDoItSemanticScope(OCDoItSemanticScope)>>evaluateDoIt:
OpalCompiler>>evaluate
[
		self announcer announce: (SpCodeWillBeEvaluatedAnnouncement newContent: aString).
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionModel doItReceiver.
		result := receiver class compiler
			source: aString;
			context: self interactionModel doItContext;
			receiver: self interactionModel doItReceiver;
			requestor: self interactionModel;
			environment: self environment;
			failBlock:  [ 
				self announcer announce: (SpCodeEvaluationFailedAnnouncement newContent: aString).
				^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		self announcer announce: (SpCodeEvaluationSucceedAnnouncement newContent: aString).
		result ] in SpCodePresenter>>evaluate:onCompileError:onError:
FullBlockClosure(BlockClosure)>>on:do:
SpCodePresenter>>evaluate:onCompileError:onError:
StPlaygroundPagePresenter>>doEvaluateAndGo
StPlaygroundPagePresenter>>doEvaluateAllAndGo
StPlaygroundDoItCommand>>execute
SpCommand(CmCommandDecorator)>>execute
[ specCommand execute ] in [ :specCommand | 
			aButtonClass new
				label: specCommand name;
				help: specCommand description;
				in: [ :button | 
					specCommand hasIcon
						ifTrue: [ button icon: specCommand icon ] ];
				action: [ specCommand execute ];
				yourself ] in SpCommand>>configureAsButtonOfClass:
FullBlockClosure(BlockClosure)>>cull:
SpMorphicToolbarButtonAdapter>>execute
SpToolbarButtonMorph(PluggableButtonMorph)>>performAction:
[:m |
		(m containsPoint: evt cursorPoint) ifTrue: [m enabled ifTrue: [ m performAction: evt ]]] in SpToolbarButtonMorph(PluggableButtonMorph)>>mouseUp:
Array(SequenceableCollection)>>do:
SpToolbarButtonMorph(PluggableButtonMorph)>>mouseUp:
SpToolbarButtonMorph(Morph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
SpToolbarButtonMorph(Morph)>>handleEvent:
SpToolbarButtonMorph(Morph)>>handleFocusEvent:
[
		result := focusHolder handleFocusEvent: transformedEvent.
	] in HandMorph>>sendFocusEvent:to:clear:
FullBlockClosure(BlockClosure)>>on:do:
WorldMorph>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil ]) ifTrue: [
			morphicWorld activeHand handleEvent: anEvent
		]
	] in OSWindowMorphicEventHandler>>dispatchMorphicEvent:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycleNow
WorldMorph>>doOneCycle
 - - - - - - - - - - - - - - -
			- - - - - - - - - - - - - - - - - -
[
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMutex critical: [
			                     self extraWorldList ].
		extraWorldsToDraw do: [ :world | world doOneCycle ].

		(self currentWorld isNotNil and: [
			 (extraWorldsToDraw includes: self currentWorld) not ]) ifTrue: [
			self currentWorld doOneCycle ] ] in WorldMorph class>>doOneCycle
FullBlockClosure(BlockClosure)>>ensure:
WorldState class>>doDrawCycleWith:
WorldMorph class>>doOneCycle
MorphicRenderLoop>>doOneCycle
MorphicRenderLoop>>doOneCycleWhile:
[ MorphicRenderLoop new doOneCycleWhile: [ true ] ] in MorphicUIManager>>spawnNewProcess
[self value.
			"IMPORTANT: Do not step over next line of code. See method comments for details"
			Processor terminateRealActive] in FullBlockClosure(BlockClosure)>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
#open was sent to nil
13 November 2023 7:56:47.46014 pm

VM: Mac OS - arm64 - 1000 - CoInterpreter VMMaker-tonel.1 uuid: 902dd483-c0c4-0d00-86f2-0f880df24b96 Oct 23 2023
StackToRegisterMappingCogit VMMaker-tonel.1 uuid: 902dd483-c0c4-0d00-86f2-0f880df24b96 Oct 23 2023
v10.0.8 - Commit: b323c5fb - Date: 2023-10-20 16:02:07 -0400

Image: Pharo11.0.0 [Build information: Pharo-11.0.0+build.710.sha.ea28d8552cac85a7ce1e9c34ab1e7bd45f7b9910 (64 Bit)]

UndefinedObject(Object)>>doesNotUnderstand: #open
	Receiver: nil
	Arguments and temporary variables: 
		aMessage: 	open
		exception: 	#open was sent to nil
		resumeValue: 	nil
	Receiver's instance variables: 
nil

UndefinedObject>>doesNotUnderstand: #open
	Receiver: nil
	Arguments and temporary variables: 
		node: 	nil
		aMessage: 	open
		exception: 	nil
		resumeValue: 	nil
	Receiver's instance variables: 
nil

GraphVisualizer>>visualizeGraphFromFile:
	Receiver: a GraphVisualizer
	Arguments and temporary variables: 
		aFilePath: 	'/Users/ryanperez/Documents/GitHub/pp-rep2533/project/src/data/t[..]
	Receiver's instance variables: 
		view: 	nil
		nodes: 	an Array(a Dictionary('id'->1 'label'->'Person' 'properties'->a Dict[..]
		edges: 	an Array(a Dictionary('source'->1 'target'->2 'type'->'FRIENDS_WITH' ))
		nodesMap: 	a Dictionary(1->a RSBox 2->a RSBox )
		canvas: 	a RSCanvas


UndefinedObject>>DoIt
	Receiver: nil
	Arguments and temporary variables: 
		visualizer: 	a GraphVisualizer
	Receiver's instance variables: 
nil

OCReceiverDoItSemanticScope(OCDoItSemanticScope)>>evaluateDoIt:
	Receiver: an OCReceiverDoItSemanticScope
	Arguments and temporary variables: 
		doItMethod: 	UndefinedObject>>#DoIt
	Receiver's instance variables: 
		outerScope: 	nil
		targetReceiver: 	nil


OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
		doItMethod: 	UndefinedObject>>#DoIt
	Receiver's instance variables: 
		ast: 	DoIt

	| visualizer |
	visualizer := GraphVisualizer new.
	^ visualize[..]
		source: 	a ReadStream
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil


[
		self announcer announce: (SpCodeWillBeEvaluatedAnnouncement newContent: aString).
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionModel doItReceiver.
		result := receiver class compiler
			source: aString;
			context: self interactionModel doItContext;
			receiver: self interactionModel doItReceiver;
			requestor: self interactionModel;
			environment: self environment;
			failBlock:  [ 
				self announcer announce: (SpCodeEvaluationFailedAnnouncement newContent: aString).
				^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		self announcer announce: (SpCodeEvaluationSucceedAnnouncement newContent: aString).
		result ] in SpCodePresenter>>evaluate:onCompileError:onError:
	Receiver: a SpCodePresenter
	Arguments and temporary variables: 
		aString: 	'| visualizer |
visualizer := GraphVisualizer new.
visualizer visu[..]
		compileErrorBlock: 	[ ^ self ]
		errorBlock: 	[ :e | e pass ]
		receiver: 	nil
		result: 	nil
		oldBindings: 	a Dictionary()
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicCodeAdapter)
		announcer: 	an Announcer
		owner: 	a StPlaygroundPagePresenter
		adapter: 	a SpMorphicCodeAdapter
		needRebuild: 	true
		eventHandler: 	a SpEventHandler
		application: 	nil
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ a KMCategory ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Code' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpAbstractWidgetLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		borderWidth: 	an ObservableValueHolder[ nil ]
		borderColor: 	an ObservableValueHolder[ nil ]
		dragEnabled: 	an ObservableValueHolder[ false ]
		dropEnabled: 	an ObservableValueHolder[ false ]
		color: 	an ObservableValueHolder[ nil ]
		help: 	an ObservableValueHolder[ nil ]
		enabled: 	an ObservableValueHolder[ true ]
		wantsDrop: 	an ObservableValueHolder[ [ :transfer | self dropEnabled ] ]
		acceptDrop: 	an ObservableValueHolder[ [ :transfer | ] ]
		deferredActions: 	nil
		hasUnacceptedEdits: 	an ObservableValueHolder[ false ]
		selection: 	an ObservableValueHolder[ (1 to: 159) ]
		wantsVisualFeedback: 	an ObservableValueHolder[ true ]
		askBeforeDiscardingEdits: 	an ObservableValueHolder[ true ]
		text: 	an ObservableValueHolder[ '| visualizer |
visualizer := GraphVisualiz[..]
		actionToPerform: 	an ObservableValueHolder[ [ :txt |  ] ]
		readSelection: 	an ObservableValueHolder[ [ selection ] ]
		placeholder: 	an ObservableValueHolder[ '' ]
		contextMenu: 	an ObservableValueHolder[ [ (self menuActionsFor: text) asMenu[..]
		scrollValue: 	an ObservableValueHolder[ (0@0) ]
		editionContextMenu: 	an ObservableValueHolder[ true ]
		editable: 	an ObservableValueHolder[ true ]
		wrapWord: 	an ObservableValueHolder[ true ]
		undoRedoHistory: 	true
		wrapScrollBars: 	true
		propagateNaturalHeight: 	false
		propagateNaturalWidth: 	false
		scrollBarStyles: 	#()
		syntaxHighlight: 	an ObservableValueHolder[ true ]
		smartCharacters: 	an ObservableValueHolder[ true ]
		lineNumbers: 	an ObservableValueHolder[ true ]
		interactionModel: 	an ObservableValueHolder[ a StPlaygroundInteractionModel ]
		overrideContextMenu: 	true
		submitBlock: 	nil
		resetBlock: 	nil
		environment: 	nil
		systemNavigation: 	nil
		syntaxHighlightTheme: 	an ObservableValueHolder[ nil ]


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
		self announcer announce: (SpCodeWillBeEvaluatedAnnouncement newContent: aString).
[..]
	Arguments and temporary variables: 
		exception: 	Error
		handlerAction: 	[ :e |
		self announcer announce: (SpCodeEvaluationFailedAnn[..]
	Receiver's instance variables: 
		outerContext: 	SpCodePresenter>>evaluate:onCompileError:onError:
		compiledBlock: 	a CompiledBlock: [
		self announcer announce: (SpCodeWillBeE[..]
		numArgs: 	0
		receiver: 	a SpCodePresenter


SpCodePresenter>>evaluate:onCompileError:onError:
	Receiver: a SpCodePresenter
	Arguments and temporary variables: 
		receiver: 	nil
		result: 	nil
		oldBindings: 	a Dictionary()
		aString: 	'| visualizer |
visualizer := GraphVisualizer new.
visualizer visu[..]
		compileErrorBlock: 	[ ^ self ]
		errorBlock: 	[ :e | e pass ]
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicCodeAdapter)
		announcer: 	an Announcer
		owner: 	a StPlaygroundPagePresenter
		adapter: 	a SpMorphicCodeAdapter
		needRebuild: 	true
		eventHandler: 	a SpEventHandler
		application: 	nil
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ a KMCategory ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Code' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpAbstractWidgetLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		borderWidth: 	an ObservableValueHolder[ nil ]
		borderColor: 	an ObservableValueHolder[ nil ]
		dragEnabled: 	an ObservableValueHolder[ false ]
		dropEnabled: 	an ObservableValueHolder[ false ]
		color: 	an ObservableValueHolder[ nil ]
		help: 	an ObservableValueHolder[ nil ]
		enabled: 	an ObservableValueHolder[ true ]
		wantsDrop: 	an ObservableValueHolder[ [ :transfer | self dropEnabled ] ]
		acceptDrop: 	an ObservableValueHolder[ [ :transfer | ] ]
		deferredActions: 	nil
		hasUnacceptedEdits: 	an ObservableValueHolder[ false ]
		selection: 	an ObservableValueHolder[ (1 to: 159) ]
		wantsVisualFeedback: 	an ObservableValueHolder[ true ]
		askBeforeDiscardingEdits: 	an ObservableValueHolder[ true ]
		text: 	an ObservableValueHolder[ '| visualizer |
visualizer := GraphVisualiz[..]
		actionToPerform: 	an ObservableValueHolder[ [ :txt |  ] ]
		readSelection: 	an ObservableValueHolder[ [ selection ] ]
		placeholder: 	an ObservableValueHolder[ '' ]
		contextMenu: 	an ObservableValueHolder[ [ (self menuActionsFor: text) asMenu[..]
		scrollValue: 	an ObservableValueHolder[ (0@0) ]
		editionContextMenu: 	an ObservableValueHolder[ true ]
		editable: 	an ObservableValueHolder[ true ]
		wrapWord: 	an ObservableValueHolder[ true ]
		undoRedoHistory: 	true
		wrapScrollBars: 	true
		propagateNaturalHeight: 	false
		propagateNaturalWidth: 	false
		scrollBarStyles: 	#()
		syntaxHighlight: 	an ObservableValueHolder[ true ]
		smartCharacters: 	an ObservableValueHolder[ true ]
		lineNumbers: 	an ObservableValueHolder[ true ]
		interactionModel: 	an ObservableValueHolder[ a StPlaygroundInteractionModel ]
		overrideContextMenu: 	true
		submitBlock: 	nil
		resetBlock: 	nil
		environment: 	nil
		systemNavigation: 	nil
		syntaxHighlightTheme: 	an ObservableValueHolder[ nil ]


StPlaygroundPagePresenter>>doEvaluateAndGo
	Receiver: a StPlaygroundPagePresenter
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicBoxAdapter)
		announcer: 	an Announcer
		owner: 	a SpMillerColumnPresenter
		adapter: 	a SpMorphicBoxAdapter
		needRebuild: 	true
		eventHandler: 	nil
		application: 	a StPharoApplication
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ nil ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Untitled window' ]
		additionalSubpresentersMap: 	a Dictionary()
		layout: 	an ObservableValueHolder[ a SpBoxLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		text: 	a SpCodePresenter
		toolbar: 	a SpToolbarPresenter
		statusbar: 	a SpPresenter
		lineLabel: 	a SpLabelPresenter
		toggleLineNumberButton: 	a SpToggleButtonPresenter
		page: 	a StPlaygroundPage
		activationBlock: 	[ :selection |
		self changeSelection: selection from: new[..]


StPlaygroundPagePresenter>>doEvaluateAllAndGo
	Receiver: a StPlaygroundPagePresenter
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicBoxAdapter)
		announcer: 	an Announcer
		owner: 	a SpMillerColumnPresenter
		adapter: 	a SpMorphicBoxAdapter
		needRebuild: 	true
		eventHandler: 	nil
		application: 	a StPharoApplication
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ nil ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Untitled window' ]
		additionalSubpresentersMap: 	a Dictionary()
		layout: 	an ObservableValueHolder[ a SpBoxLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		text: 	a SpCodePresenter
		toolbar: 	a SpToolbarPresenter
		statusbar: 	a SpPresenter
		lineLabel: 	a SpLabelPresenter
		toggleLineNumberButton: 	a SpToggleButtonPresenter
		page: 	a StPlaygroundPage
		activationBlock: 	[ :selection |
		self changeSelection: selection from: new[..]


StPlaygroundDoItCommand>>execute
	Receiver: a StPlaygroundDoItCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		context: 	a StPlaygroundPagePresenter
		basicName: 	'Do it'
		basicDescription: 	'Do it all and inspect.'


SpCommand(CmCommandDecorator)>>execute
	Receiver: a SpCommand(Do it)
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a StPlaygroundDoItCommand
		iconProvider: 	a StPharoApplication
		iconName: 	#glamorousGo
		shortcutKey: 	nil
		displayStrategy: 	a CmUIDisableWhenCantBeRun
		positionStrategy: 	a CmUILeftPositionStrategy
		buildPresenterBlock: 	[ :specCommand | 
			aButtonClass new
				label: specC[..]
		presenter: 	a SpToolbarButtonPresenter


[ specCommand execute ] in [ :specCommand | 
			aButtonClass new
				label: specCommand name;
				help: specCommand description;
				in: [ :button | 
					specCommand hasIcon
						ifTrue: [ button icon: specCommand icon ] ];
				action: [ specCommand execute ];
				yourself ] in SpCommand>>configureAsButtonOfClass:
	Receiver: a SpCommand(Do it)
	Arguments and temporary variables: 
		aButtonClass: 	nil
		specCommand: 	a SpCommand(Do it)
	Receiver's instance variables: 
		decoratedCommand: 	a StPlaygroundDoItCommand
		iconProvider: 	a StPharoApplication
		iconName: 	#glamorousGo
		shortcutKey: 	nil
		displayStrategy: 	a CmUIDisableWhenCantBeRun
		positionStrategy: 	a CmUILeftPositionStrategy
		buildPresenterBlock: 	[ :specCommand | 
			aButtonClass new
				label: specC[..]
		presenter: 	a SpToolbarButtonPresenter


FullBlockClosure(BlockClosure)>>cull:
	Receiver: [ specCommand execute ]
	Arguments and temporary variables: 
		anArg: 	a SpToolbarButtonPresenter
	Receiver's instance variables: 
		outerContext: 	[ :specCommand | 
			aButtonClass new
				label: specCommand [..]
		compiledBlock: 	a CompiledBlock: [ specCommand execute ]
		numArgs: 	0
		receiver: 	a SpCommand(Do it)


SpMorphicToolbarButtonAdapter>>execute
	Receiver: a SpMorphicToolbarButtonAdapter
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpToolbarButtonMorph(163457024))
		announcer: 	nil
		model: 	a SpToolbarButtonPresenter
		widget: 	a SpToolbarButtonMorph(163457024)
		selector: 	nil
		owner: 	a SpToolbarButtonPresenter
		unsubscribed: 	false


SpToolbarButtonMorph(PluggableButtonMorph)>>performAction:
	Receiver: a SpToolbarButtonMorph(163457024)
	Arguments and temporary variables: 
		event: 	[(27.0@24.0) mouseUp 13925570 nil]
	Receiver's instance variables: 
		bounds: 	(0.0@5.0) corner: (45.0@39.0)
		owner: 	a Morph(543889152)
		submorphs: 	an Array(an AlignmentMorph(1048008448))
		fullBounds: 	nil
		color: 	(Color r: 0.9012707722385142 g: 0.9012707722385142 b: 0.901270772238[..]
		extension: 	a MorphExtension (606190080) [balloonText]  [other:  (presenter [..]
		borderWidth: 	0
		borderColor: 	#simple
		model: 	a SpMorphicToolbarButtonAdapter
		label: 	'Do it'
		icon: 	Form(13x13x32)
		getIconSelector: 	#icon
		getStateSelector: 	#state
		actionSelector: 	#execute
		font: 	a LogicalFont
 familyName: 'Source Sans Pro'
 emphasis: nil
 pointSiz[..]
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	nil
		getFontSelector: 	nil
		labelMorph: 	a LabelMorph(576130816)'Do it'
		iconMorph: 	an ImageMorph(527603200)
		iconPosition: 	#top
		lastState: 	false
		badgeFont: 	nil
		badgeSelector: 	#badge


[:m |
		(m containsPoint: evt cursorPoint) ifTrue: [m enabled ifTrue: [ m performAction: evt ]]] in SpToolbarButtonMorph(PluggableButtonMorph)>>mouseUp:
	Receiver: a SpToolbarButtonMorph(163457024)
	Arguments and temporary variables: 
		evt: 	[(27.0@24.0) mouseUp 13925570 nil]
		all: 	an Array(a SpToolbarButtonMorph(163457024) a SpToolbarButtonMorph(6416[..]
		m: 	a SpToolbarButtonMorph(163457024)
	Receiver's instance variables: 
		bounds: 	(0.0@5.0) corner: (45.0@39.0)
		owner: 	a Morph(543889152)
		submorphs: 	an Array(an AlignmentMorph(1048008448))
		fullBounds: 	nil
		color: 	(Color r: 0.9012707722385142 g: 0.9012707722385142 b: 0.901270772238[..]
		extension: 	a MorphExtension (606190080) [balloonText]  [other:  (presenter [..]
		borderWidth: 	0
		borderColor: 	#simple
		model: 	a SpMorphicToolbarButtonAdapter
		label: 	'Do it'
		icon: 	Form(13x13x32)
		getIconSelector: 	#icon
		getStateSelector: 	#state
		actionSelector: 	#execute
		font: 	a LogicalFont
 familyName: 'Source Sans Pro'
 emphasis: nil
 pointSiz[..]
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	nil
		getFontSelector: 	nil
		labelMorph: 	a LabelMorph(576130816)'Do it'
		iconMorph: 	an ImageMorph(527603200)
		iconPosition: 	#top
		lastState: 	false
		badgeFont: 	nil
		badgeSelector: 	#badge


Array(SequenceableCollection)>>do:
	Receiver: an Array(a SpToolbarButtonMorph(163457024) a SpToolbarButtonMorph(641645312) a SpToolb[..]
	Arguments and temporary variables: 
		aBlock: 	[:m |
		(m containsPoint: evt cursorPoint) ifTrue: [m enabled ifTru[..]
		index: 	1
	Receiver's instance variables: 
an Array(a SpToolbarButtonMorph(163457024) a SpToolbarButtonMorph(641645312) a SpToolb[..]

SpToolbarButtonMorph(PluggableButtonMorph)>>mouseUp:
	Receiver: a SpToolbarButtonMorph(163457024)
	Arguments and temporary variables: 
		evt: 	[(27.0@24.0) mouseUp 13925570 nil]
		all: 	an Array(a SpToolbarButtonMorph(163457024) a SpToolbarButtonMorph(6416[..]
	Receiver's instance variables: 
		bounds: 	(0.0@5.0) corner: (45.0@39.0)
		owner: 	a Morph(543889152)
		submorphs: 	an Array(an AlignmentMorph(1048008448))
		fullBounds: 	nil
		color: 	(Color r: 0.9012707722385142 g: 0.9012707722385142 b: 0.901270772238[..]
		extension: 	a MorphExtension (606190080) [balloonText]  [other:  (presenter [..]
		borderWidth: 	0
		borderColor: 	#simple
		model: 	a SpMorphicToolbarButtonAdapter
		label: 	'Do it'
		icon: 	Form(13x13x32)
		getIconSelector: 	#icon
		getStateSelector: 	#state
		actionSelector: 	#execute
		font: 	a LogicalFont
 familyName: 'Source Sans Pro'
 emphasis: nil
 pointSiz[..]
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	nil
		getFontSelector: 	nil
		labelMorph: 	a LabelMorph(576130816)'Do it'
		iconMorph: 	an ImageMorph(527603200)
		iconPosition: 	#top
		lastState: 	false
		badgeFont: 	nil
		badgeSelector: 	#badge


SpToolbarButtonMorph(Morph)>>handleMouseUp:
	Receiver: a SpToolbarButtonMorph(163457024)
	Arguments and temporary variables: 
		anEvent: 	[(27.0@24.0) mouseUp 13925570 nil]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(0.0@5.0) corner: (45.0@39.0)
		owner: 	a Morph(543889152)
		submorphs: 	an Array(an AlignmentMorph(1048008448))
		fullBounds: 	nil
		color: 	(Color r: 0.9012707722385142 g: 0.9012707722385142 b: 0.901270772238[..]
		extension: 	a MorphExtension (606190080) [balloonText]  [other:  (presenter [..]
		borderWidth: 	0
		borderColor: 	#simple
		model: 	a SpMorphicToolbarButtonAdapter
		label: 	'Do it'
		icon: 	Form(13x13x32)
		getIconSelector: 	#icon
		getStateSelector: 	#state
		actionSelector: 	#execute
		font: 	a LogicalFont
 familyName: 'Source Sans Pro'
 emphasis: nil
 pointSiz[..]
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	nil
		getFontSelector: 	nil
		labelMorph: 	a LabelMorph(576130816)'Do it'
		iconMorph: 	an ImageMorph(527603200)
		iconPosition: 	#top
		lastState: 	false
		badgeFont: 	nil
		badgeSelector: 	#badge


MouseButtonEvent>>sentTo:
	Receiver: [(27.0@24.0) mouseUp 13925570 nil]
	Arguments and temporary variables: 
		anObject: 	a SpToolbarButtonMorph(163457024)
	Receiver's instance variables: 
		timeStamp: 	13925570
		source: 	a HandMorph(337424384)
		windowIndex: 	nil
		type: 	#mouseUp
		buttons: 	0
		position: 	(27.0@24.0)
		handler: 	nil
		wasHandled: 	true
		whichButton: 	4


SpToolbarButtonMorph(Morph)>>handleEvent:
	Receiver: a SpToolbarButtonMorph(163457024)
	Arguments and temporary variables: 
		anEvent: 	[(27.0@24.0) mouseUp 13925570 nil]
	Receiver's instance variables: 
		bounds: 	(0.0@5.0) corner: (45.0@39.0)
		owner: 	a Morph(543889152)
		submorphs: 	an Array(an AlignmentMorph(1048008448))
		fullBounds: 	nil
		color: 	(Color r: 0.9012707722385142 g: 0.9012707722385142 b: 0.901270772238[..]
		extension: 	a MorphExtension (606190080) [balloonText]  [other:  (presenter [..]
		borderWidth: 	0
		borderColor: 	#simple
		model: 	a SpMorphicToolbarButtonAdapter
		label: 	'Do it'
		icon: 	Form(13x13x32)
		getIconSelector: 	#icon
		getStateSelector: 	#state
		actionSelector: 	#execute
		font: 	a LogicalFont
 familyName: 'Source Sans Pro'
 emphasis: nil
 pointSiz[..]
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	nil
		getFontSelector: 	nil
		labelMorph: 	a LabelMorph(576130816)'Do it'
		iconMorph: 	an ImageMorph(527603200)
		iconPosition: 	#top
		lastState: 	false
		badgeFont: 	nil
		badgeSelector: 	#badge


SpToolbarButtonMorph(Morph)>>handleFocusEvent:
	Receiver: a SpToolbarButtonMorph(163457024)
	Arguments and temporary variables: 
		anEvent: 	[(27.0@24.0) mouseUp 13925570 nil]
	Receiver's instance variables: 
		bounds: 	(0.0@5.0) corner: (45.0@39.0)
		owner: 	a Morph(543889152)
		submorphs: 	an Array(an AlignmentMorph(1048008448))
		fullBounds: 	nil
		color: 	(Color r: 0.9012707722385142 g: 0.9012707722385142 b: 0.901270772238[..]
		extension: 	a MorphExtension (606190080) [balloonText]  [other:  (presenter [..]
		borderWidth: 	0
		borderColor: 	#simple
		model: 	a SpMorphicToolbarButtonAdapter
		label: 	'Do it'
		icon: 	Form(13x13x32)
		getIconSelector: 	#icon
		getStateSelector: 	#state
		actionSelector: 	#execute
		font: 	a LogicalFont
 familyName: 'Source Sans Pro'
 emphasis: nil
 pointSiz[..]
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	nil
		getFontSelector: 	nil
		labelMorph: 	a LabelMorph(576130816)'Do it'
		iconMorph: 	an ImageMorph(527603200)
		iconPosition: 	#top
		lastState: 	false
		badgeFont: 	nil
		badgeSelector: 	#badge


[
		result := focusHolder handleFocusEvent: transformedEvent.
	] in HandMorph>>sendFocusEvent:to:clear:
	Receiver: a HandMorph(337424384)
	Arguments and temporary variables: 
		anEvent: 	[(482@212) mouseUp 13925570 nil]
		focusHolder: 	a SpToolbarButtonMorph(163457024)
		aBlock: 	[self mouseFocus: nil]
		w: 	a WorldMorph(341720576) [world]
		transformedEvent: 	[(27.0@24.0) mouseUp 13925570 nil]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(482@212.0) corner: (498@228.0)
		owner: 	a WorldMorph(341720576) [world]
		submorphs: 	#()
		fullBounds: 	(482@212.0) corner: (498@228.0)
		color: 	Color blue
		extension: 	a MorphExtension (370611968)
		mouseFocus: 	nil
		keyboardFocus: 	a RubEditingArea(143191808)
		eventListeners: 	nil
		mouseListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(482@212) mouseUp 13925570 nil]
		targetOffset: 	(27.0@19.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 0 0 0 0 0 nil nil)
		captureBlock: 	nil
		recentModifiers: 	0
		pendingEventQueue: 	WaitfreeQueue with 0 items
		supressNextKeyPress: 	false


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
		result := focusHolder handleFocusEvent: transformedEvent.
	]
	Arguments and temporary variables: 
		exception: 	Error
		handlerAction: 	[ :ex |
			ActiveWorld := priorWorld.
			ex pass ]
	Receiver's instance variables: 
		outerContext: 	HandMorph>>sendFocusEvent:to:clear:
		compiledBlock: 	a CompiledBlock: [
		result := focusHolder handleFocusEvent:[..]
		numArgs: 	0
		receiver: 	a HandMorph(337424384)


WorldMorph>>becomeActiveDuring:
	Receiver: a WorldMorph(341720576) [world]
	Arguments and temporary variables: 
		aBlock: 	[
		result := focusHolder handleFocusEvent: transformedEvent.
	]
		priorWorld: 	a WorldMorph(341720576) [world]
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1728@1080)
		owner: 	nil
		submorphs: 	an Array(a MenubarMorph(112886016) a TaskbarMorph(279458560) a S[..]
		fullBounds: 	(0@0) corner: (1728@1080)
		color: 	(Color r: 0.9403714565004888 g: 0.9403714565004888 b: 0.940371456500[..]
		extension: 	a MorphExtension (1012946432) [other:  (dragEnabled -> true) (dr[..]
		borderWidth: 	0
		borderColor: 	(Color r: 0.8611925708699902 g: 1.0 b: 0.7223851417399805 alph[..]
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil


HandMorph>>sendFocusEvent:to:clear:
	Receiver: a HandMorph(337424384)
	Arguments and temporary variables: 
		result: 	nil
		anEvent: 	[(482@212) mouseUp 13925570 nil]
		focusHolder: 	a SpToolbarButtonMorph(163457024)
		aBlock: 	[self mouseFocus: nil]
		w: 	a WorldMorph(341720576) [world]
		transformedEvent: 	[(27.0@24.0) mouseUp 13925570 nil]
	Receiver's instance variables: 
		bounds: 	(482@212.0) corner: (498@228.0)
		owner: 	a WorldMorph(341720576) [world]
		submorphs: 	#()
		fullBounds: 	(482@212.0) corner: (498@228.0)
		color: 	Color blue
		extension: 	a MorphExtension (370611968)
		mouseFocus: 	nil
		keyboardFocus: 	a RubEditingArea(143191808)
		eventListeners: 	nil
		mouseListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(482@212) mouseUp 13925570 nil]
		targetOffset: 	(27.0@19.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 0 0 0 0 0 nil nil)
		captureBlock: 	nil
		recentModifiers: 	0
		pendingEventQueue: 	WaitfreeQueue with 0 items
		supressNextKeyPress: 	false


HandMorph>>sendEvent:focus:clear:
	Receiver: a HandMorph(337424384)
	Arguments and temporary variables: 
		anEvent: 	[(482@212) mouseUp 13925570 nil]
		focusHolder: 	a SpToolbarButtonMorph(163457024)
		aBlock: 	[self mouseFocus: nil]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(482@212.0) corner: (498@228.0)
		owner: 	a WorldMorph(341720576) [world]
		submorphs: 	#()
		fullBounds: 	(482@212.0) corner: (498@228.0)
		color: 	Color blue
		extension: 	a MorphExtension (370611968)
		mouseFocus: 	nil
		keyboardFocus: 	a RubEditingArea(143191808)
		eventListeners: 	nil
		mouseListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(482@212) mouseUp 13925570 nil]
		targetOffset: 	(27.0@19.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 0 0 0 0 0 nil nil)
		captureBlock: 	nil
		recentModifiers: 	0
		pendingEventQueue: 	WaitfreeQueue with 0 items
		supressNextKeyPress: 	false


HandMorph>>sendMouseEvent:
	Receiver: a HandMorph(337424384)
	Arguments and temporary variables: 
		anEvent: 	[(482@212) mouseUp 13925570 nil]
	Receiver's instance variables: 
		bounds: 	(482@212.0) corner: (498@228.0)
		owner: 	a WorldMorph(341720576) [world]
		submorphs: 	#()
		fullBounds: 	(482@212.0) corner: (498@228.0)
		color: 	Color blue
		extension: 	a MorphExtension (370611968)
		mouseFocus: 	nil
		keyboardFocus: 	a RubEditingArea(143191808)
		eventListeners: 	nil
		mouseListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(482@212) mouseUp 13925570 nil]
		targetOffset: 	(27.0@19.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 0 0 0 0 0 nil nil)
		captureBlock: 	nil
		recentModifiers: 	0
		pendingEventQueue: 	WaitfreeQueue with 0 items
		supressNextKeyPress: 	false


HandMorph>>handleEvent:
	Receiver: a HandMorph(337424384)
	Arguments and temporary variables: 
		anEvent: 	[(482@212) mouseUp 13925570 nil]
		evt: 	[(482@212) mouseUp 13925570 nil]
	Receiver's instance variables: 
		bounds: 	(482@212.0) corner: (498@228.0)
		owner: 	a WorldMorph(341720576) [world]
		submorphs: 	#()
		fullBounds: 	(482@212.0) corner: (498@228.0)
		color: 	Color blue
		extension: 	a MorphExtension (370611968)
		mouseFocus: 	nil
		keyboardFocus: 	a RubEditingArea(143191808)
		eventListeners: 	nil
		mouseListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(482@212) mouseUp 13925570 nil]
		targetOffset: 	(27.0@19.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 0 0 0 0 0 nil nil)
		captureBlock: 	nil
		recentModifiers: 	0
		pendingEventQueue: 	WaitfreeQueue with 0 items
		supressNextKeyPress: 	false


[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil ]) ifTrue: [
			morphicWorld activeHand handleEvent: anEvent
		]
	] in OSWindowMorphicEventHandler>>dispatchMorphicEvent:
	Receiver: an OSWindowMorphicEventHandler
	Arguments and temporary variables: 
		anEvent: 	[(482@212) mouseUp 13925570 nil]
	Receiver's instance variables: 
		morphicWorld: 	a WorldMorph(341720576) [world]


WorldState>>runStepMethodsIn:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(341720576) [world]
		queue: 	WaitfreeQueue with 0 items
		nextInQueue: 	[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNo[..]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(337424384))
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap()
		lastStepTime: 	13922097
		lastStepMessage: 	nil
		alarms: 	a Heap(MorphicAlarm(#hideShow -> a RubCursor(27124480)))
		lastAlarmTime: 	13925557
		activeHand: 	a HandMorph(337424384)
		currentCursor: 	((CursorWithMask
	extent: (16@16)
	depth: 1
	fromArray: #(
	[..]
		worldRenderer: 	an OSWorldRenderer
		realWindowExtent: 	(1728@1080)
		deferredUIMessages: 	WaitfreeQueue with 0 items


WorldMorph>>runStepMethods
	Receiver: a WorldMorph(341720576) [world]
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1728@1080)
		owner: 	nil
		submorphs: 	an Array(a MenubarMorph(112886016) a TaskbarMorph(279458560) a S[..]
		fullBounds: 	(0@0) corner: (1728@1080)
		color: 	(Color r: 0.9403714565004888 g: 0.9403714565004888 b: 0.940371456500[..]
		extension: 	a MorphExtension (1012946432) [other:  (dragEnabled -> true) (dr[..]
		borderWidth: 	0
		borderColor: 	(Color r: 0.8611925708699902 g: 1.0 b: 0.7223851417399805 alph[..]
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil


WorldState>>doOneCycleFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(341720576) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(337424384))
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap()
		lastStepTime: 	13922097
		lastStepMessage: 	nil
		alarms: 	a Heap(MorphicAlarm(#hideShow -> a RubCursor(27124480)))
		lastAlarmTime: 	13925557
		activeHand: 	a HandMorph(337424384)
		currentCursor: 	((CursorWithMask
	extent: (16@16)
	depth: 1
	fromArray: #(
	[..]
		worldRenderer: 	an OSWorldRenderer
		realWindowExtent: 	(1728@1080)
		deferredUIMessages: 	WaitfreeQueue with 0 items


WorldMorph>>doOneCycleNow
	Receiver: a WorldMorph(341720576) [world]
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1728@1080)
		owner: 	nil
		submorphs: 	an Array(a MenubarMorph(112886016) a TaskbarMorph(279458560) a S[..]
		fullBounds: 	(0@0) corner: (1728@1080)
		color: 	(Color r: 0.9403714565004888 g: 0.9403714565004888 b: 0.940371456500[..]
		extension: 	a MorphExtension (1012946432) [other:  (dragEnabled -> true) (dr[..]
		borderWidth: 	0
		borderColor: 	(Color r: 0.8611925708699902 g: 1.0 b: 0.7223851417399805 alph[..]
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil


WorldMorph>>doOneCycle
	Receiver: a WorldMorph(341720576) [world]
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1728@1080)
		owner: 	nil
		submorphs: 	an Array(a MenubarMorph(112886016) a TaskbarMorph(279458560) a S[..]
		fullBounds: 	(0@0) corner: (1728@1080)
		color: 	(Color r: 0.9403714565004888 g: 0.9403714565004888 b: 0.940371456500[..]
		extension: 	a MorphExtension (1012946432) [other:  (dragEnabled -> true) (dr[..]
		borderWidth: 	0
		borderColor: 	(Color r: 0.8611925708699902 g: 1.0 b: 0.7223851417399805 alph[..]
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil


[
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMutex critical: [
			                     self extraWorldList ].
		extraWorldsToDraw do: [ :world | world doOneCycle ].

		(self currentWorld isNotNil and: [
			 (extraWorldsToDraw includes: self currentWorld) not ]) ifTrue: [
			self currentWorld doOneCycle ] ] in WorldMorph class>>doOneCycle
	Receiver: WorldMorph
	Arguments and temporary variables: 
		extraWorldsToDraw: 	#()
	Receiver's instance variables: 
		superclass: 	PasteUpMorph
		methodDict: 	a MethodDictionary(#acceptDroppingMorph:event:->WorldMorph>>#ac[..]
		format: 	65547
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		commentSourcePointer: 	nil
		subclasses: 	{AthensWorldMorph. OSWindowWorldMorph}
		name: 	#WorldMorph
		classPool: 	a Dictionary(#AllowDropFiles->nil #CursorOwnerWorld->a WorldMorp[..]
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Morphic-Core-Worlds'
		announcer: 	nil
		displayScaleFactor: 	1


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMutex critical: [
			  [..]
	Arguments and temporary variables: 
		aBlock: 	[
		self doInterCycleWait
	]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	WorldMorph class>>doOneCycle
		compiledBlock: 	a CompiledBlock: [
		| extraWorldsToDraw |
		extraWorldsToDr[..]
		numArgs: 	0
		receiver: 	WorldMorph



--- The full stack ---
UndefinedObject(Object)>>doesNotUnderstand: #open
UndefinedObject>>doesNotUnderstand: #open
GraphVisualizer>>visualizeGraphFromFile:
UndefinedObject>>DoIt
OCReceiverDoItSemanticScope(OCDoItSemanticScope)>>evaluateDoIt:
OpalCompiler>>evaluate
[
		self announcer announce: (SpCodeWillBeEvaluatedAnnouncement newContent: aString).
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionModel doItReceiver.
		result := receiver class compiler
			source: aString;
			context: self interactionModel doItContext;
			receiver: self interactionModel doItReceiver;
			requestor: self interactionModel;
			environment: self environment;
			failBlock:  [ 
				self announcer announce: (SpCodeEvaluationFailedAnnouncement newContent: aString).
				^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		self announcer announce: (SpCodeEvaluationSucceedAnnouncement newContent: aString).
		result ] in SpCodePresenter>>evaluate:onCompileError:onError:
FullBlockClosure(BlockClosure)>>on:do:
SpCodePresenter>>evaluate:onCompileError:onError:
StPlaygroundPagePresenter>>doEvaluateAndGo
StPlaygroundPagePresenter>>doEvaluateAllAndGo
StPlaygroundDoItCommand>>execute
SpCommand(CmCommandDecorator)>>execute
[ specCommand execute ] in [ :specCommand | 
			aButtonClass new
				label: specCommand name;
				help: specCommand description;
				in: [ :button | 
					specCommand hasIcon
						ifTrue: [ button icon: specCommand icon ] ];
				action: [ specCommand execute ];
				yourself ] in SpCommand>>configureAsButtonOfClass:
FullBlockClosure(BlockClosure)>>cull:
SpMorphicToolbarButtonAdapter>>execute
SpToolbarButtonMorph(PluggableButtonMorph)>>performAction:
[:m |
		(m containsPoint: evt cursorPoint) ifTrue: [m enabled ifTrue: [ m performAction: evt ]]] in SpToolbarButtonMorph(PluggableButtonMorph)>>mouseUp:
Array(SequenceableCollection)>>do:
SpToolbarButtonMorph(PluggableButtonMorph)>>mouseUp:
SpToolbarButtonMorph(Morph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
SpToolbarButtonMorph(Morph)>>handleEvent:
SpToolbarButtonMorph(Morph)>>handleFocusEvent:
[
		result := focusHolder handleFocusEvent: transformedEvent.
	] in HandMorph>>sendFocusEvent:to:clear:
FullBlockClosure(BlockClosure)>>on:do:
WorldMorph>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil ]) ifTrue: [
			morphicWorld activeHand handleEvent: anEvent
		]
	] in OSWindowMorphicEventHandler>>dispatchMorphicEvent:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycleNow
WorldMorph>>doOneCycle
[
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMutex critical: [
			                     self extraWorldList ].
		extraWorldsToDraw do: [ :world | world doOneCycle ].

		(self currentWorld isNotNil and: [
			 (extraWorldsToDraw includes: self currentWorld) not ]) ifTrue: [
			self currentWorld doOneCycle ] ] in WorldMorph class>>doOneCycle
FullBlockClosure(BlockClosure)>>ensure:
 - - - - - - - - - - - - - - -
			- - - - - - - - - - - - - - - - - -
WorldState class>>doDrawCycleWith:
WorldMorph class>>doOneCycle
MorphicRenderLoop>>doOneCycle
MorphicRenderLoop>>doOneCycleWhile:
[ MorphicRenderLoop new doOneCycleWhile: [ true ] ] in MorphicUIManager>>spawnNewProcess
[self value.
			"IMPORTANT: Do not step over next line of code. See method comments for details"
			Processor terminateRealActive] in FullBlockClosure(BlockClosure)>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
#open was sent to nil
13 November 2023 7:56:47.484446 pm

VM: Mac OS - arm64 - 1000 - CoInterpreter VMMaker-tonel.1 uuid: 902dd483-c0c4-0d00-86f2-0f880df24b96 Oct 23 2023
StackToRegisterMappingCogit VMMaker-tonel.1 uuid: 902dd483-c0c4-0d00-86f2-0f880df24b96 Oct 23 2023
v10.0.8 - Commit: b323c5fb - Date: 2023-10-20 16:02:07 -0400

Image: Pharo11.0.0 [Build information: Pharo-11.0.0+build.710.sha.ea28d8552cac85a7ce1e9c34ab1e7bd45f7b9910 (64 Bit)]

UndefinedObject(Object)>>doesNotUnderstand: #open
	Receiver: nil
	Arguments and temporary variables: 
		aMessage: 	open
		exception: 	#open was sent to nil
		resumeValue: 	nil
	Receiver's instance variables: 
nil

UndefinedObject>>doesNotUnderstand: #open
	Receiver: nil
	Arguments and temporary variables: 
		node: 	nil
		aMessage: 	open
		exception: 	nil
		resumeValue: 	nil
	Receiver's instance variables: 
nil

GraphVisualizer>>visualizeGraphFromFile:
	Receiver: a GraphVisualizer
	Arguments and temporary variables: 
		aFilePath: 	'/Users/ryanperez/Documents/GitHub/pp-rep2533/project/src/data/t[..]
	Receiver's instance variables: 
		view: 	nil
		nodes: 	an Array(a Dictionary('id'->1 'label'->'Person' 'properties'->a Dict[..]
		edges: 	an Array(a Dictionary('source'->1 'target'->2 'type'->'FRIENDS_WITH' ))
		nodesMap: 	a Dictionary(1->a RSBox 2->a RSBox )
		canvas: 	a RSCanvas


UndefinedObject>>DoIt
	Receiver: nil
	Arguments and temporary variables: 
		visualizer: 	a GraphVisualizer
	Receiver's instance variables: 
nil

OCReceiverDoItSemanticScope(OCDoItSemanticScope)>>evaluateDoIt:
	Receiver: an OCReceiverDoItSemanticScope
	Arguments and temporary variables: 
		doItMethod: 	UndefinedObject>>#DoIt
	Receiver's instance variables: 
		outerScope: 	nil
		targetReceiver: 	nil


OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
		doItMethod: 	UndefinedObject>>#DoIt
	Receiver's instance variables: 
		ast: 	DoIt

	| visualizer |
	visualizer := GraphVisualizer new.
	^ visualize[..]
		source: 	a ReadStream
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil


[
		self announcer announce: (SpCodeWillBeEvaluatedAnnouncement newContent: aString).
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionModel doItReceiver.
		result := receiver class compiler
			source: aString;
			context: self interactionModel doItContext;
			receiver: self interactionModel doItReceiver;
			requestor: self interactionModel;
			environment: self environment;
			failBlock:  [ 
				self announcer announce: (SpCodeEvaluationFailedAnnouncement newContent: aString).
				^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		self announcer announce: (SpCodeEvaluationSucceedAnnouncement newContent: aString).
		result ] in SpCodePresenter>>evaluate:onCompileError:onError:
	Receiver: a SpCodePresenter
	Arguments and temporary variables: 
		aString: 	'| visualizer |
visualizer := GraphVisualizer new.
visualizer visu[..]
		compileErrorBlock: 	[ ^ self ]
		errorBlock: 	[ :e | e pass ]
		receiver: 	nil
		result: 	nil
		oldBindings: 	a Dictionary()
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicCodeAdapter)
		announcer: 	an Announcer
		owner: 	a StPlaygroundPagePresenter
		adapter: 	a SpMorphicCodeAdapter
		needRebuild: 	true
		eventHandler: 	a SpEventHandler
		application: 	nil
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ a KMCategory ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Code' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpAbstractWidgetLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		borderWidth: 	an ObservableValueHolder[ nil ]
		borderColor: 	an ObservableValueHolder[ nil ]
		dragEnabled: 	an ObservableValueHolder[ false ]
		dropEnabled: 	an ObservableValueHolder[ false ]
		color: 	an ObservableValueHolder[ nil ]
		help: 	an ObservableValueHolder[ nil ]
		enabled: 	an ObservableValueHolder[ true ]
		wantsDrop: 	an ObservableValueHolder[ [ :transfer | self dropEnabled ] ]
		acceptDrop: 	an ObservableValueHolder[ [ :transfer | ] ]
		deferredActions: 	nil
		hasUnacceptedEdits: 	an ObservableValueHolder[ false ]
		selection: 	an ObservableValueHolder[ (1 to: 159) ]
		wantsVisualFeedback: 	an ObservableValueHolder[ true ]
		askBeforeDiscardingEdits: 	an ObservableValueHolder[ true ]
		text: 	an ObservableValueHolder[ '| visualizer |
visualizer := GraphVisualiz[..]
		actionToPerform: 	an ObservableValueHolder[ [ :txt |  ] ]
		readSelection: 	an ObservableValueHolder[ [ selection ] ]
		placeholder: 	an ObservableValueHolder[ '' ]
		contextMenu: 	an ObservableValueHolder[ [ (self menuActionsFor: text) asMenu[..]
		scrollValue: 	an ObservableValueHolder[ (0@0) ]
		editionContextMenu: 	an ObservableValueHolder[ true ]
		editable: 	an ObservableValueHolder[ true ]
		wrapWord: 	an ObservableValueHolder[ true ]
		undoRedoHistory: 	true
		wrapScrollBars: 	true
		propagateNaturalHeight: 	false
		propagateNaturalWidth: 	false
		scrollBarStyles: 	#()
		syntaxHighlight: 	an ObservableValueHolder[ true ]
		smartCharacters: 	an ObservableValueHolder[ true ]
		lineNumbers: 	an ObservableValueHolder[ true ]
		interactionModel: 	an ObservableValueHolder[ a StPlaygroundInteractionModel ]
		overrideContextMenu: 	true
		submitBlock: 	nil
		resetBlock: 	nil
		environment: 	nil
		systemNavigation: 	nil
		syntaxHighlightTheme: 	an ObservableValueHolder[ nil ]


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
		self announcer announce: (SpCodeWillBeEvaluatedAnnouncement newContent: aString).
[..]
	Arguments and temporary variables: 
		exception: 	Error
		handlerAction: 	[ :e |
		self announcer announce: (SpCodeEvaluationFailedAnn[..]
	Receiver's instance variables: 
		outerContext: 	SpCodePresenter>>evaluate:onCompileError:onError:
		compiledBlock: 	a CompiledBlock: [
		self announcer announce: (SpCodeWillBeE[..]
		numArgs: 	0
		receiver: 	a SpCodePresenter


SpCodePresenter>>evaluate:onCompileError:onError:
	Receiver: a SpCodePresenter
	Arguments and temporary variables: 
		receiver: 	nil
		result: 	nil
		oldBindings: 	a Dictionary()
		aString: 	'| visualizer |
visualizer := GraphVisualizer new.
visualizer visu[..]
		compileErrorBlock: 	[ ^ self ]
		errorBlock: 	[ :e | e pass ]
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicCodeAdapter)
		announcer: 	an Announcer
		owner: 	a StPlaygroundPagePresenter
		adapter: 	a SpMorphicCodeAdapter
		needRebuild: 	true
		eventHandler: 	a SpEventHandler
		application: 	nil
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ a KMCategory ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Code' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpAbstractWidgetLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		borderWidth: 	an ObservableValueHolder[ nil ]
		borderColor: 	an ObservableValueHolder[ nil ]
		dragEnabled: 	an ObservableValueHolder[ false ]
		dropEnabled: 	an ObservableValueHolder[ false ]
		color: 	an ObservableValueHolder[ nil ]
		help: 	an ObservableValueHolder[ nil ]
		enabled: 	an ObservableValueHolder[ true ]
		wantsDrop: 	an ObservableValueHolder[ [ :transfer | self dropEnabled ] ]
		acceptDrop: 	an ObservableValueHolder[ [ :transfer | ] ]
		deferredActions: 	nil
		hasUnacceptedEdits: 	an ObservableValueHolder[ false ]
		selection: 	an ObservableValueHolder[ (1 to: 159) ]
		wantsVisualFeedback: 	an ObservableValueHolder[ true ]
		askBeforeDiscardingEdits: 	an ObservableValueHolder[ true ]
		text: 	an ObservableValueHolder[ '| visualizer |
visualizer := GraphVisualiz[..]
		actionToPerform: 	an ObservableValueHolder[ [ :txt |  ] ]
		readSelection: 	an ObservableValueHolder[ [ selection ] ]
		placeholder: 	an ObservableValueHolder[ '' ]
		contextMenu: 	an ObservableValueHolder[ [ (self menuActionsFor: text) asMenu[..]
		scrollValue: 	an ObservableValueHolder[ (0@0) ]
		editionContextMenu: 	an ObservableValueHolder[ true ]
		editable: 	an ObservableValueHolder[ true ]
		wrapWord: 	an ObservableValueHolder[ true ]
		undoRedoHistory: 	true
		wrapScrollBars: 	true
		propagateNaturalHeight: 	false
		propagateNaturalWidth: 	false
		scrollBarStyles: 	#()
		syntaxHighlight: 	an ObservableValueHolder[ true ]
		smartCharacters: 	an ObservableValueHolder[ true ]
		lineNumbers: 	an ObservableValueHolder[ true ]
		interactionModel: 	an ObservableValueHolder[ a StPlaygroundInteractionModel ]
		overrideContextMenu: 	true
		submitBlock: 	nil
		resetBlock: 	nil
		environment: 	nil
		systemNavigation: 	nil
		syntaxHighlightTheme: 	an ObservableValueHolder[ nil ]


StPlaygroundPagePresenter>>doEvaluateAndGo
	Receiver: a StPlaygroundPagePresenter
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicBoxAdapter)
		announcer: 	an Announcer
		owner: 	a SpMillerColumnPresenter
		adapter: 	a SpMorphicBoxAdapter
		needRebuild: 	true
		eventHandler: 	nil
		application: 	a StPharoApplication
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ nil ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Untitled window' ]
		additionalSubpresentersMap: 	a Dictionary()
		layout: 	an ObservableValueHolder[ a SpBoxLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		text: 	a SpCodePresenter
		toolbar: 	a SpToolbarPresenter
		statusbar: 	a SpPresenter
		lineLabel: 	a SpLabelPresenter
		toggleLineNumberButton: 	a SpToggleButtonPresenter
		page: 	a StPlaygroundPage
		activationBlock: 	[ :selection |
		self changeSelection: selection from: new[..]


StPlaygroundPagePresenter>>doEvaluateAllAndGo
	Receiver: a StPlaygroundPagePresenter
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicBoxAdapter)
		announcer: 	an Announcer
		owner: 	a SpMillerColumnPresenter
		adapter: 	a SpMorphicBoxAdapter
		needRebuild: 	true
		eventHandler: 	nil
		application: 	a StPharoApplication
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ nil ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Untitled window' ]
		additionalSubpresentersMap: 	a Dictionary()
		layout: 	an ObservableValueHolder[ a SpBoxLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		text: 	a SpCodePresenter
		toolbar: 	a SpToolbarPresenter
		statusbar: 	a SpPresenter
		lineLabel: 	a SpLabelPresenter
		toggleLineNumberButton: 	a SpToggleButtonPresenter
		page: 	a StPlaygroundPage
		activationBlock: 	[ :selection |
		self changeSelection: selection from: new[..]


StPlaygroundDoItCommand>>execute
	Receiver: a StPlaygroundDoItCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		context: 	a StPlaygroundPagePresenter
		basicName: 	'Do it'
		basicDescription: 	'Do it all and inspect.'


SpCommand(CmCommandDecorator)>>execute
	Receiver: a SpCommand(Do it)
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a StPlaygroundDoItCommand
		iconProvider: 	a StPharoApplication
		iconName: 	#glamorousGo
		shortcutKey: 	nil
		displayStrategy: 	a CmUIDisableWhenCantBeRun
		positionStrategy: 	a CmUILeftPositionStrategy
		buildPresenterBlock: 	[ :specCommand | 
			aButtonClass new
				label: specC[..]
		presenter: 	a SpToolbarButtonPresenter


[ specCommand execute ] in [ :specCommand | 
			aButtonClass new
				label: specCommand name;
				help: specCommand description;
				in: [ :button | 
					specCommand hasIcon
						ifTrue: [ button icon: specCommand icon ] ];
				action: [ specCommand execute ];
				yourself ] in SpCommand>>configureAsButtonOfClass:
	Receiver: a SpCommand(Do it)
	Arguments and temporary variables: 
		aButtonClass: 	nil
		specCommand: 	a SpCommand(Do it)
	Receiver's instance variables: 
		decoratedCommand: 	a StPlaygroundDoItCommand
		iconProvider: 	a StPharoApplication
		iconName: 	#glamorousGo
		shortcutKey: 	nil
		displayStrategy: 	a CmUIDisableWhenCantBeRun
		positionStrategy: 	a CmUILeftPositionStrategy
		buildPresenterBlock: 	[ :specCommand | 
			aButtonClass new
				label: specC[..]
		presenter: 	a SpToolbarButtonPresenter


FullBlockClosure(BlockClosure)>>cull:
	Receiver: [ specCommand execute ]
	Arguments and temporary variables: 
		anArg: 	a SpToolbarButtonPresenter
	Receiver's instance variables: 
		outerContext: 	[ :specCommand | 
			aButtonClass new
				label: specCommand [..]
		compiledBlock: 	a CompiledBlock: [ specCommand execute ]
		numArgs: 	0
		receiver: 	a SpCommand(Do it)


SpMorphicToolbarButtonAdapter>>execute
	Receiver: a SpMorphicToolbarButtonAdapter
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpToolbarButtonMorph(163457024))
		announcer: 	nil
		model: 	a SpToolbarButtonPresenter
		widget: 	a SpToolbarButtonMorph(163457024)
		selector: 	nil
		owner: 	a SpToolbarButtonPresenter
		unsubscribed: 	false


SpToolbarButtonMorph(PluggableButtonMorph)>>performAction:
	Receiver: a SpToolbarButtonMorph(163457024)
	Arguments and temporary variables: 
		event: 	[(27.0@24.0) mouseUp 13925570 nil]
	Receiver's instance variables: 
		bounds: 	(0.0@5.0) corner: (45.0@39.0)
		owner: 	a Morph(543889152)
		submorphs: 	an Array(an AlignmentMorph(1048008448))
		fullBounds: 	nil
		color: 	(Color r: 0.9012707722385142 g: 0.9012707722385142 b: 0.901270772238[..]
		extension: 	a MorphExtension (606190080) [balloonText]  [other:  (presenter [..]
		borderWidth: 	0
		borderColor: 	#simple
		model: 	a SpMorphicToolbarButtonAdapter
		label: 	'Do it'
		icon: 	Form(13x13x32)
		getIconSelector: 	#icon
		getStateSelector: 	#state
		actionSelector: 	#execute
		font: 	a LogicalFont
 familyName: 'Source Sans Pro'
 emphasis: nil
 pointSiz[..]
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	nil
		getFontSelector: 	nil
		labelMorph: 	a LabelMorph(576130816)'Do it'
		iconMorph: 	an ImageMorph(527603200)
		iconPosition: 	#top
		lastState: 	false
		badgeFont: 	nil
		badgeSelector: 	#badge


[:m |
		(m containsPoint: evt cursorPoint) ifTrue: [m enabled ifTrue: [ m performAction: evt ]]] in SpToolbarButtonMorph(PluggableButtonMorph)>>mouseUp:
	Receiver: a SpToolbarButtonMorph(163457024)
	Arguments and temporary variables: 
		evt: 	[(27.0@24.0) mouseUp 13925570 nil]
		all: 	an Array(a SpToolbarButtonMorph(163457024) a SpToolbarButtonMorph(6416[..]
		m: 	a SpToolbarButtonMorph(163457024)
	Receiver's instance variables: 
		bounds: 	(0.0@5.0) corner: (45.0@39.0)
		owner: 	a Morph(543889152)
		submorphs: 	an Array(an AlignmentMorph(1048008448))
		fullBounds: 	nil
		color: 	(Color r: 0.9012707722385142 g: 0.9012707722385142 b: 0.901270772238[..]
		extension: 	a MorphExtension (606190080) [balloonText]  [other:  (presenter [..]
		borderWidth: 	0
		borderColor: 	#simple
		model: 	a SpMorphicToolbarButtonAdapter
		label: 	'Do it'
		icon: 	Form(13x13x32)
		getIconSelector: 	#icon
		getStateSelector: 	#state
		actionSelector: 	#execute
		font: 	a LogicalFont
 familyName: 'Source Sans Pro'
 emphasis: nil
 pointSiz[..]
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	nil
		getFontSelector: 	nil
		labelMorph: 	a LabelMorph(576130816)'Do it'
		iconMorph: 	an ImageMorph(527603200)
		iconPosition: 	#top
		lastState: 	false
		badgeFont: 	nil
		badgeSelector: 	#badge


Array(SequenceableCollection)>>do:
	Receiver: an Array(a SpToolbarButtonMorph(163457024) a SpToolbarButtonMorph(641645312) a SpToolb[..]
	Arguments and temporary variables: 
		aBlock: 	[:m |
		(m containsPoint: evt cursorPoint) ifTrue: [m enabled ifTru[..]
		index: 	1
	Receiver's instance variables: 
an Array(a SpToolbarButtonMorph(163457024) a SpToolbarButtonMorph(641645312) a SpToolb[..]

SpToolbarButtonMorph(PluggableButtonMorph)>>mouseUp:
	Receiver: a SpToolbarButtonMorph(163457024)
	Arguments and temporary variables: 
		evt: 	[(27.0@24.0) mouseUp 13925570 nil]
		all: 	an Array(a SpToolbarButtonMorph(163457024) a SpToolbarButtonMorph(6416[..]
	Receiver's instance variables: 
		bounds: 	(0.0@5.0) corner: (45.0@39.0)
		owner: 	a Morph(543889152)
		submorphs: 	an Array(an AlignmentMorph(1048008448))
		fullBounds: 	nil
		color: 	(Color r: 0.9012707722385142 g: 0.9012707722385142 b: 0.901270772238[..]
		extension: 	a MorphExtension (606190080) [balloonText]  [other:  (presenter [..]
		borderWidth: 	0
		borderColor: 	#simple
		model: 	a SpMorphicToolbarButtonAdapter
		label: 	'Do it'
		icon: 	Form(13x13x32)
		getIconSelector: 	#icon
		getStateSelector: 	#state
		actionSelector: 	#execute
		font: 	a LogicalFont
 familyName: 'Source Sans Pro'
 emphasis: nil
 pointSiz[..]
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	nil
		getFontSelector: 	nil
		labelMorph: 	a LabelMorph(576130816)'Do it'
		iconMorph: 	an ImageMorph(527603200)
		iconPosition: 	#top
		lastState: 	false
		badgeFont: 	nil
		badgeSelector: 	#badge


SpToolbarButtonMorph(Morph)>>handleMouseUp:
	Receiver: a SpToolbarButtonMorph(163457024)
	Arguments and temporary variables: 
		anEvent: 	[(27.0@24.0) mouseUp 13925570 nil]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(0.0@5.0) corner: (45.0@39.0)
		owner: 	a Morph(543889152)
		submorphs: 	an Array(an AlignmentMorph(1048008448))
		fullBounds: 	nil
		color: 	(Color r: 0.9012707722385142 g: 0.9012707722385142 b: 0.901270772238[..]
		extension: 	a MorphExtension (606190080) [balloonText]  [other:  (presenter [..]
		borderWidth: 	0
		borderColor: 	#simple
		model: 	a SpMorphicToolbarButtonAdapter
		label: 	'Do it'
		icon: 	Form(13x13x32)
		getIconSelector: 	#icon
		getStateSelector: 	#state
		actionSelector: 	#execute
		font: 	a LogicalFont
 familyName: 'Source Sans Pro'
 emphasis: nil
 pointSiz[..]
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	nil
		getFontSelector: 	nil
		labelMorph: 	a LabelMorph(576130816)'Do it'
		iconMorph: 	an ImageMorph(527603200)
		iconPosition: 	#top
		lastState: 	false
		badgeFont: 	nil
		badgeSelector: 	#badge


MouseButtonEvent>>sentTo:
	Receiver: [(27.0@24.0) mouseUp 13925570 nil]
	Arguments and temporary variables: 
		anObject: 	a SpToolbarButtonMorph(163457024)
	Receiver's instance variables: 
		timeStamp: 	13925570
		source: 	a HandMorph(337424384)
		windowIndex: 	nil
		type: 	#mouseUp
		buttons: 	0
		position: 	(27.0@24.0)
		handler: 	nil
		wasHandled: 	true
		whichButton: 	4


SpToolbarButtonMorph(Morph)>>handleEvent:
	Receiver: a SpToolbarButtonMorph(163457024)
	Arguments and temporary variables: 
		anEvent: 	[(27.0@24.0) mouseUp 13925570 nil]
	Receiver's instance variables: 
		bounds: 	(0.0@5.0) corner: (45.0@39.0)
		owner: 	a Morph(543889152)
		submorphs: 	an Array(an AlignmentMorph(1048008448))
		fullBounds: 	nil
		color: 	(Color r: 0.9012707722385142 g: 0.9012707722385142 b: 0.901270772238[..]
		extension: 	a MorphExtension (606190080) [balloonText]  [other:  (presenter [..]
		borderWidth: 	0
		borderColor: 	#simple
		model: 	a SpMorphicToolbarButtonAdapter
		label: 	'Do it'
		icon: 	Form(13x13x32)
		getIconSelector: 	#icon
		getStateSelector: 	#state
		actionSelector: 	#execute
		font: 	a LogicalFont
 familyName: 'Source Sans Pro'
 emphasis: nil
 pointSiz[..]
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	nil
		getFontSelector: 	nil
		labelMorph: 	a LabelMorph(576130816)'Do it'
		iconMorph: 	an ImageMorph(527603200)
		iconPosition: 	#top
		lastState: 	false
		badgeFont: 	nil
		badgeSelector: 	#badge


SpToolbarButtonMorph(Morph)>>handleFocusEvent:
	Receiver: a SpToolbarButtonMorph(163457024)
	Arguments and temporary variables: 
		anEvent: 	[(27.0@24.0) mouseUp 13925570 nil]
	Receiver's instance variables: 
		bounds: 	(0.0@5.0) corner: (45.0@39.0)
		owner: 	a Morph(543889152)
		submorphs: 	an Array(an AlignmentMorph(1048008448))
		fullBounds: 	nil
		color: 	(Color r: 0.9012707722385142 g: 0.9012707722385142 b: 0.901270772238[..]
		extension: 	a MorphExtension (606190080) [balloonText]  [other:  (presenter [..]
		borderWidth: 	0
		borderColor: 	#simple
		model: 	a SpMorphicToolbarButtonAdapter
		label: 	'Do it'
		icon: 	Form(13x13x32)
		getIconSelector: 	#icon
		getStateSelector: 	#state
		actionSelector: 	#execute
		font: 	a LogicalFont
 familyName: 'Source Sans Pro'
 emphasis: nil
 pointSiz[..]
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	nil
		getFontSelector: 	nil
		labelMorph: 	a LabelMorph(576130816)'Do it'
		iconMorph: 	an ImageMorph(527603200)
		iconPosition: 	#top
		lastState: 	false
		badgeFont: 	nil
		badgeSelector: 	#badge


[
		result := focusHolder handleFocusEvent: transformedEvent.
	] in HandMorph>>sendFocusEvent:to:clear:
	Receiver: a HandMorph(337424384)
	Arguments and temporary variables: 
		anEvent: 	[(482@212) mouseUp 13925570 nil]
		focusHolder: 	a SpToolbarButtonMorph(163457024)
		aBlock: 	[self mouseFocus: nil]
		w: 	a WorldMorph(341720576) [world]
		transformedEvent: 	[(27.0@24.0) mouseUp 13925570 nil]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(482@212.0) corner: (498@228.0)
		owner: 	a WorldMorph(341720576) [world]
		submorphs: 	#()
		fullBounds: 	(482@212.0) corner: (498@228.0)
		color: 	Color blue
		extension: 	a MorphExtension (370611968)
		mouseFocus: 	nil
		keyboardFocus: 	a RubEditingArea(143191808)
		eventListeners: 	nil
		mouseListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(482@212) mouseUp 13925570 nil]
		targetOffset: 	(27.0@19.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 0 0 0 0 0 nil nil)
		captureBlock: 	nil
		recentModifiers: 	0
		pendingEventQueue: 	WaitfreeQueue with 0 items
		supressNextKeyPress: 	false


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
		result := focusHolder handleFocusEvent: transformedEvent.
	]
	Arguments and temporary variables: 
		exception: 	Error
		handlerAction: 	[ :ex |
			ActiveWorld := priorWorld.
			ex pass ]
	Receiver's instance variables: 
		outerContext: 	HandMorph>>sendFocusEvent:to:clear:
		compiledBlock: 	a CompiledBlock: [
		result := focusHolder handleFocusEvent:[..]
		numArgs: 	0
		receiver: 	a HandMorph(337424384)


WorldMorph>>becomeActiveDuring:
	Receiver: a WorldMorph(341720576) [world]
	Arguments and temporary variables: 
		aBlock: 	[
		result := focusHolder handleFocusEvent: transformedEvent.
	]
		priorWorld: 	a WorldMorph(341720576) [world]
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1728@1080)
		owner: 	nil
		submorphs: 	an Array(a MenubarMorph(112886016) a TaskbarMorph(279458560) a S[..]
		fullBounds: 	(0@0) corner: (1728@1080)
		color: 	(Color r: 0.9403714565004888 g: 0.9403714565004888 b: 0.940371456500[..]
		extension: 	a MorphExtension (1012946432) [other:  (dragEnabled -> true) (dr[..]
		borderWidth: 	0
		borderColor: 	(Color r: 0.8611925708699902 g: 1.0 b: 0.7223851417399805 alph[..]
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil


HandMorph>>sendFocusEvent:to:clear:
	Receiver: a HandMorph(337424384)
	Arguments and temporary variables: 
		result: 	nil
		anEvent: 	[(482@212) mouseUp 13925570 nil]
		focusHolder: 	a SpToolbarButtonMorph(163457024)
		aBlock: 	[self mouseFocus: nil]
		w: 	a WorldMorph(341720576) [world]
		transformedEvent: 	[(27.0@24.0) mouseUp 13925570 nil]
	Receiver's instance variables: 
		bounds: 	(482@212.0) corner: (498@228.0)
		owner: 	a WorldMorph(341720576) [world]
		submorphs: 	#()
		fullBounds: 	(482@212.0) corner: (498@228.0)
		color: 	Color blue
		extension: 	a MorphExtension (370611968)
		mouseFocus: 	nil
		keyboardFocus: 	a RubEditingArea(143191808)
		eventListeners: 	nil
		mouseListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(482@212) mouseUp 13925570 nil]
		targetOffset: 	(27.0@19.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 0 0 0 0 0 nil nil)
		captureBlock: 	nil
		recentModifiers: 	0
		pendingEventQueue: 	WaitfreeQueue with 0 items
		supressNextKeyPress: 	false


HandMorph>>sendEvent:focus:clear:
	Receiver: a HandMorph(337424384)
	Arguments and temporary variables: 
		anEvent: 	[(482@212) mouseUp 13925570 nil]
		focusHolder: 	a SpToolbarButtonMorph(163457024)
		aBlock: 	[self mouseFocus: nil]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(482@212.0) corner: (498@228.0)
		owner: 	a WorldMorph(341720576) [world]
		submorphs: 	#()
		fullBounds: 	(482@212.0) corner: (498@228.0)
		color: 	Color blue
		extension: 	a MorphExtension (370611968)
		mouseFocus: 	nil
		keyboardFocus: 	a RubEditingArea(143191808)
		eventListeners: 	nil
		mouseListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(482@212) mouseUp 13925570 nil]
		targetOffset: 	(27.0@19.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 0 0 0 0 0 nil nil)
		captureBlock: 	nil
		recentModifiers: 	0
		pendingEventQueue: 	WaitfreeQueue with 0 items
		supressNextKeyPress: 	false


HandMorph>>sendMouseEvent:
	Receiver: a HandMorph(337424384)
	Arguments and temporary variables: 
		anEvent: 	[(482@212) mouseUp 13925570 nil]
	Receiver's instance variables: 
		bounds: 	(482@212.0) corner: (498@228.0)
		owner: 	a WorldMorph(341720576) [world]
		submorphs: 	#()
		fullBounds: 	(482@212.0) corner: (498@228.0)
		color: 	Color blue
		extension: 	a MorphExtension (370611968)
		mouseFocus: 	nil
		keyboardFocus: 	a RubEditingArea(143191808)
		eventListeners: 	nil
		mouseListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(482@212) mouseUp 13925570 nil]
		targetOffset: 	(27.0@19.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 0 0 0 0 0 nil nil)
		captureBlock: 	nil
		recentModifiers: 	0
		pendingEventQueue: 	WaitfreeQueue with 0 items
		supressNextKeyPress: 	false


HandMorph>>handleEvent:
	Receiver: a HandMorph(337424384)
	Arguments and temporary variables: 
		anEvent: 	[(482@212) mouseUp 13925570 nil]
		evt: 	[(482@212) mouseUp 13925570 nil]
	Receiver's instance variables: 
		bounds: 	(482@212.0) corner: (498@228.0)
		owner: 	a WorldMorph(341720576) [world]
		submorphs: 	#()
		fullBounds: 	(482@212.0) corner: (498@228.0)
		color: 	Color blue
		extension: 	a MorphExtension (370611968)
		mouseFocus: 	nil
		keyboardFocus: 	a RubEditingArea(143191808)
		eventListeners: 	nil
		mouseListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(482@212) mouseUp 13925570 nil]
		targetOffset: 	(27.0@19.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 0 0 0 0 0 nil nil)
		captureBlock: 	nil
		recentModifiers: 	0
		pendingEventQueue: 	WaitfreeQueue with 0 items
		supressNextKeyPress: 	false


[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil ]) ifTrue: [
			morphicWorld activeHand handleEvent: anEvent
		]
	] in OSWindowMorphicEventHandler>>dispatchMorphicEvent:
	Receiver: an OSWindowMorphicEventHandler
	Arguments and temporary variables: 
		anEvent: 	[(482@212) mouseUp 13925570 nil]
	Receiver's instance variables: 
		morphicWorld: 	a WorldMorph(341720576) [world]


WorldState>>runStepMethodsIn:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(341720576) [world]
		queue: 	WaitfreeQueue with 0 items
		nextInQueue: 	[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNo[..]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(337424384))
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap()
		lastStepTime: 	13922097
		lastStepMessage: 	nil
		alarms: 	a Heap(MorphicAlarm(#hideShow -> a RubCursor(27124480)))
		lastAlarmTime: 	13925557
		activeHand: 	a HandMorph(337424384)
		currentCursor: 	((CursorWithMask
	extent: (16@16)
	depth: 1
	fromArray: #(
	[..]
		worldRenderer: 	an OSWorldRenderer
		realWindowExtent: 	(1728@1080)
		deferredUIMessages: 	WaitfreeQueue with 0 items


WorldMorph>>runStepMethods
	Receiver: a WorldMorph(341720576) [world]
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1728@1080)
		owner: 	nil
		submorphs: 	an Array(a MenubarMorph(112886016) a TaskbarMorph(279458560) a S[..]
		fullBounds: 	(0@0) corner: (1728@1080)
		color: 	(Color r: 0.9403714565004888 g: 0.9403714565004888 b: 0.940371456500[..]
		extension: 	a MorphExtension (1012946432) [other:  (dragEnabled -> true) (dr[..]
		borderWidth: 	0
		borderColor: 	(Color r: 0.8611925708699902 g: 1.0 b: 0.7223851417399805 alph[..]
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil


WorldState>>doOneCycleFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(341720576) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(337424384))
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap()
		lastStepTime: 	13922097
		lastStepMessage: 	nil
		alarms: 	a Heap(MorphicAlarm(#hideShow -> a RubCursor(27124480)))
		lastAlarmTime: 	13925557
		activeHand: 	a HandMorph(337424384)
		currentCursor: 	((CursorWithMask
	extent: (16@16)
	depth: 1
	fromArray: #(
	[..]
		worldRenderer: 	an OSWorldRenderer
		realWindowExtent: 	(1728@1080)
		deferredUIMessages: 	WaitfreeQueue with 0 items


WorldMorph>>doOneCycleNow
	Receiver: a WorldMorph(341720576) [world]
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1728@1080)
		owner: 	nil
		submorphs: 	an Array(a MenubarMorph(112886016) a TaskbarMorph(279458560) a S[..]
		fullBounds: 	(0@0) corner: (1728@1080)
		color: 	(Color r: 0.9403714565004888 g: 0.9403714565004888 b: 0.940371456500[..]
		extension: 	a MorphExtension (1012946432) [other:  (dragEnabled -> true) (dr[..]
		borderWidth: 	0
		borderColor: 	(Color r: 0.8611925708699902 g: 1.0 b: 0.7223851417399805 alph[..]
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil


WorldMorph>>doOneCycle
	Receiver: a WorldMorph(341720576) [world]
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1728@1080)
		owner: 	nil
		submorphs: 	an Array(a MenubarMorph(112886016) a TaskbarMorph(279458560) a S[..]
		fullBounds: 	(0@0) corner: (1728@1080)
		color: 	(Color r: 0.9403714565004888 g: 0.9403714565004888 b: 0.940371456500[..]
		extension: 	a MorphExtension (1012946432) [other:  (dragEnabled -> true) (dr[..]
		borderWidth: 	0
		borderColor: 	(Color r: 0.8611925708699902 g: 1.0 b: 0.7223851417399805 alph[..]
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil


[
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMutex critical: [
			                     self extraWorldList ].
		extraWorldsToDraw do: [ :world | world doOneCycle ].

		(self currentWorld isNotNil and: [
			 (extraWorldsToDraw includes: self currentWorld) not ]) ifTrue: [
			self currentWorld doOneCycle ] ] in WorldMorph class>>doOneCycle
	Receiver: WorldMorph
	Arguments and temporary variables: 
		extraWorldsToDraw: 	#()
	Receiver's instance variables: 
		superclass: 	PasteUpMorph
		methodDict: 	a MethodDictionary(#acceptDroppingMorph:event:->WorldMorph>>#ac[..]
		format: 	65547
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		commentSourcePointer: 	nil
		subclasses: 	{AthensWorldMorph. OSWindowWorldMorph}
		name: 	#WorldMorph
		classPool: 	a Dictionary(#AllowDropFiles->nil #CursorOwnerWorld->a WorldMorp[..]
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Morphic-Core-Worlds'
		announcer: 	nil
		displayScaleFactor: 	1


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMutex critical: [
			  [..]
	Arguments and temporary variables: 
		aBlock: 	[
		self doInterCycleWait
	]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	WorldMorph class>>doOneCycle
		compiledBlock: 	a CompiledBlock: [
		| extraWorldsToDraw |
		extraWorldsToDr[..]
		numArgs: 	0
		receiver: 	WorldMorph



--- The full stack ---
UndefinedObject(Object)>>doesNotUnderstand: #open
UndefinedObject>>doesNotUnderstand: #open
GraphVisualizer>>visualizeGraphFromFile:
UndefinedObject>>DoIt
OCReceiverDoItSemanticScope(OCDoItSemanticScope)>>evaluateDoIt:
OpalCompiler>>evaluate
[
		self announcer announce: (SpCodeWillBeEvaluatedAnnouncement newContent: aString).
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionModel doItReceiver.
		result := receiver class compiler
			source: aString;
			context: self interactionModel doItContext;
			receiver: self interactionModel doItReceiver;
			requestor: self interactionModel;
			environment: self environment;
			failBlock:  [ 
				self announcer announce: (SpCodeEvaluationFailedAnnouncement newContent: aString).
				^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		self announcer announce: (SpCodeEvaluationSucceedAnnouncement newContent: aString).
		result ] in SpCodePresenter>>evaluate:onCompileError:onError:
FullBlockClosure(BlockClosure)>>on:do:
SpCodePresenter>>evaluate:onCompileError:onError:
StPlaygroundPagePresenter>>doEvaluateAndGo
StPlaygroundPagePresenter>>doEvaluateAllAndGo
StPlaygroundDoItCommand>>execute
SpCommand(CmCommandDecorator)>>execute
[ specCommand execute ] in [ :specCommand | 
			aButtonClass new
				label: specCommand name;
				help: specCommand description;
				in: [ :button | 
					specCommand hasIcon
						ifTrue: [ button icon: specCommand icon ] ];
				action: [ specCommand execute ];
				yourself ] in SpCommand>>configureAsButtonOfClass:
FullBlockClosure(BlockClosure)>>cull:
SpMorphicToolbarButtonAdapter>>execute
SpToolbarButtonMorph(PluggableButtonMorph)>>performAction:
[:m |
		(m containsPoint: evt cursorPoint) ifTrue: [m enabled ifTrue: [ m performAction: evt ]]] in SpToolbarButtonMorph(PluggableButtonMorph)>>mouseUp:
Array(SequenceableCollection)>>do:
SpToolbarButtonMorph(PluggableButtonMorph)>>mouseUp:
SpToolbarButtonMorph(Morph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
SpToolbarButtonMorph(Morph)>>handleEvent:
SpToolbarButtonMorph(Morph)>>handleFocusEvent:
[
		result := focusHolder handleFocusEvent: transformedEvent.
	] in HandMorph>>sendFocusEvent:to:clear:
FullBlockClosure(BlockClosure)>>on:do:
WorldMorph>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil ]) ifTrue: [
			morphicWorld activeHand handleEvent: anEvent
		]
	] in OSWindowMorphicEventHandler>>dispatchMorphicEvent:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycleNow
WorldMorph>>doOneCycle
[
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMutex critical: [
			                     self extraWorldList ].
		extraWorldsToDraw do: [ :world | world doOneCycle ].

		(self currentWorld isNotNil and: [
			 (extraWorldsToDraw includes: self currentWorld) not ]) ifTrue: [
			self currentWorld doOneCycle ] ] in WorldMorph class>>doOneCycle
FullBlockClosure(BlockClosure)>>ensure:
 - - - - - - - - - - - - - - -
			- - - - - - - - - - - - - - - - - -
WorldState class>>doDrawCycleWith:
WorldMorph class>>doOneCycle
MorphicRenderLoop>>doOneCycle
MorphicRenderLoop>>doOneCycleWhile:
[ MorphicRenderLoop new doOneCycleWhile: [ true ] ] in MorphicUIManager>>spawnNewProcess
[self value.
			"IMPORTANT: Do not step over next line of code. See method comments for details"
			Processor terminateRealActive] in FullBlockClosure(BlockClosure)>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
AssertionFailure: You must enter a project name (it will be used also as part of the path).
13 November 2023 10:54:03.261762 pm

VM: Mac OS - arm64 - 1000 - CoInterpreter VMMaker-tonel.1 uuid: 902dd483-c0c4-0d00-86f2-0f880df24b96 Oct 23 2023
StackToRegisterMappingCogit VMMaker-tonel.1 uuid: 902dd483-c0c4-0d00-86f2-0f880df24b96 Oct 23 2023
v10.0.8 - Commit: b323c5fb - Date: 2023-10-20 16:02:07 -0400

Image: Pharo11.0.0 [Build information: Pharo-11.0.0+build.710.sha.ea28d8552cac85a7ce1e9c34ab1e7bd45f7b9910 (64 Bit)]

IceTipNewRepositoryPanel(Object)>>assert:description:
	Receiver: an IceTipNewRepositoryPanel
	Arguments and temporary variables: 
		aBlock: 	false
		aStringOrBlock: 	'You must enter a project name (it will be used also as par[..]
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicGridAdapter)
		announcer: 	an Announcer
		owner: 	an IceTipRegisterRepositoryDialog
		adapter: 	a SpMorphicGridAdapter
		needRebuild: 	true
		eventHandler: 	nil
		application: 	a StPharoApplication
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ nil ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Untitled window' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpGridLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		decorations: 	nil
		projectLocationLabel: 	a SpLabelPresenter
		projectLocation: 	an IceTipDirectoryPresenter
		remoteLabel: 	nil
		remoteInputText: 	nil
		repository: 	nil
		projectNameLabel: 	a SpLabelPresenter
		projectNameInputText: 	a SpTextInputFieldPresenter
		subdirectoryLabel: 	a SpLabelPresenter
		subdirectoryInputText: 	a SpTextInputFieldPresenter


IceTipNewRepositoryPanel>>validate
	Receiver: an IceTipNewRepositoryPanel
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicGridAdapter)
		announcer: 	an Announcer
		owner: 	an IceTipRegisterRepositoryDialog
		adapter: 	a SpMorphicGridAdapter
		needRebuild: 	true
		eventHandler: 	nil
		application: 	a StPharoApplication
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ nil ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Untitled window' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpGridLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		decorations: 	nil
		projectLocationLabel: 	a SpLabelPresenter
		projectLocation: 	an IceTipDirectoryPresenter
		remoteLabel: 	nil
		remoteInputText: 	nil
		repository: 	nil
		projectNameLabel: 	a SpLabelPresenter
		projectNameInputText: 	a SpTextInputFieldPresenter
		subdirectoryLabel: 	a SpLabelPresenter
		subdirectoryInputText: 	a SpTextInputFieldPresenter


IceTipRegisterRepositoryDialog>>doAccept
	Receiver: an IceTipRegisterRepositoryDialog
	Arguments and temporary variables: 
		newRepository: 	nil
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicPanedAdapter a SpMorphicBoxAdapter)
		announcer: 	an Announcer
		owner: 	a SpDialogWindowPresenter
		adapter: 	a SpMorphicPanedAdapter
		needRebuild: 	true
		eventHandler: 	nil
		application: 	a StPharoApplication
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ nil ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Untitled window' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpPanedLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		decorations: 	nil
		typeList: 	a SpListPresenter
		type: 	an IceTipNewRepositoryPanel
		contentLayout: 	a SpBoxLayout
		types: 	an OrderedCollection(an IceTipNewRepositoryPanel an IceTipLocalRepos[..]
		repository: 	nil
		acceptBlock: 	nil


[ 
	  self doAccept.
	  self closeWindow ] in IceTipRegisterRepositoryDialog(IceTipOptionDialog)>>accept
	Receiver: an IceTipRegisterRepositoryDialog
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicPanedAdapter a SpMorphicBoxAdapter)
		announcer: 	an Announcer
		owner: 	a SpDialogWindowPresenter
		adapter: 	a SpMorphicPanedAdapter
		needRebuild: 	true
		eventHandler: 	nil
		application: 	a StPharoApplication
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ nil ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Untitled window' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpPanedLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		decorations: 	nil
		typeList: 	a SpListPresenter
		type: 	an IceTipNewRepositoryPanel
		contentLayout: 	a SpBoxLayout
		types: 	an OrderedCollection(an IceTipNewRepositoryPanel an IceTipLocalRepos[..]
		repository: 	nil
		acceptBlock: 	nil


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [ 
	  self doAccept.
	  self closeWindow ]
	Arguments and temporary variables: 
		exception: 	an ExceptionSet
		handlerAction: 	[ :e | 
			  e acceptError: (IceTipInteractiveErrorVisitor n[..]
	Receiver's instance variables: 
		outerContext: 	IceTipRegisterRepositoryDialog(IceTipOptionDialog)>>accept
		compiledBlock: 	a CompiledBlock: [ 
	  self doAccept.
	  self closeWindow ]
		numArgs: 	0
		receiver: 	an IceTipRegisterRepositoryDialog


IceTipRegisterRepositoryDialog(IceTipOptionDialog)>>accept
	Receiver: an IceTipRegisterRepositoryDialog
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicPanedAdapter a SpMorphicBoxAdapter)
		announcer: 	an Announcer
		owner: 	a SpDialogWindowPresenter
		adapter: 	a SpMorphicPanedAdapter
		needRebuild: 	true
		eventHandler: 	nil
		application: 	a StPharoApplication
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ nil ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Untitled window' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpPanedLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		decorations: 	nil
		typeList: 	a SpListPresenter
		type: 	an IceTipNewRepositoryPanel
		contentLayout: 	a SpBoxLayout
		types: 	an OrderedCollection(an IceTipNewRepositoryPanel an IceTipLocalRepos[..]
		repository: 	nil
		acceptBlock: 	nil


[ :presenter | self accept ] in IceTipRegisterRepositoryDialog(IceTipOptionDialog)>>initializeDialogWindow:
	Receiver: an IceTipRegisterRepositoryDialog
	Arguments and temporary variables: 
		aWindowPresenter: 	a SpDialogWindowPresenter
		presenter: 	a SpDialogWindowPresenter
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicPanedAdapter a SpMorphicBoxAdapter)
		announcer: 	an Announcer
		owner: 	a SpDialogWindowPresenter
		adapter: 	a SpMorphicPanedAdapter
		needRebuild: 	true
		eventHandler: 	nil
		application: 	a StPharoApplication
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ nil ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Untitled window' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpPanedLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		decorations: 	nil
		typeList: 	a SpListPresenter
		type: 	an IceTipNewRepositoryPanel
		contentLayout: 	a SpBoxLayout
		types: 	an OrderedCollection(an IceTipNewRepositoryPanel an IceTipLocalRepos[..]
		repository: 	nil
		acceptBlock: 	nil


FullBlockClosure(BlockClosure)>>cull:
	Receiver: [ :presenter | self accept ]
	Arguments and temporary variables: 
		anArg: 	a SpDialogWindowPresenter
	Receiver's instance variables: 
		outerContext: 	IceTipRegisterRepositoryDialog(IceTipOptionDialog)>>initializ[..]
		compiledBlock: 	a CompiledBlock: [ :presenter | self accept ]
		numArgs: 	1
		receiver: 	an IceTipRegisterRepositoryDialog


[ aBlock cull: self ] in SpDialogWindowPresenter>>addButton:do:
	Receiver: a SpDialogWindowPresenter
	Arguments and temporary variables: 
		aString: 	'Ok'
		aBlock: 	[ :presenter | self accept ]
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicDialogWindowAdapter a SpDialogWind[..]
		announcer: 	an Announcer
		owner: 	nil
		adapter: 	a SpMorphicDialogWindowAdapter
		needRebuild: 	true
		eventHandler: 	nil
		application: 	a StPharoApplication
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ nil ]
		windowIcon: 	an ObservableValueHolder[ Form(16x16x32) ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ true ]
		titleHolder: 	an ObservableValueHolder[ 'New repository' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ nil ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		borderWidth: 	an ObservableValueHolder[ nil ]
		borderColor: 	an ObservableValueHolder[ nil ]
		dragEnabled: 	an ObservableValueHolder[ false ]
		dropEnabled: 	an ObservableValueHolder[ false ]
		color: 	an ObservableValueHolder[ nil ]
		help: 	an ObservableValueHolder[ nil ]
		enabled: 	an ObservableValueHolder[ true ]
		wantsDrop: 	an ObservableValueHolder[ [ :transfer | self dropEnabled ] ]
		acceptDrop: 	an ObservableValueHolder[ [ :transfer | ] ]
		deferredActions: 	nil
		presenter: 	an ObservableValueHolder[ an IceTipRegisterRepositoryDialog ]
		initialPosition: 	an ObservableValueHolder[ nil ]
		initialExtent: 	an ObservableValueHolder[ (700@300) ]
		menu: 	an ObservableValueHolder[ nil ]
		centered: 	an ObservableValueHolder[ false ]
		isClosed: 	an ObservableValueHolder[ false ]
		toolbar: 	an ObservableValueHolder[ nil ]
		statusbar: 	an ObservableValueHolder[ nil ]
		window: 	an ObservableValueHolder[ a SpDialogWindowMorph(395736832) named: N[..]
		decorations: 	an ObservableValueHolder[ true ]
		resizable: 	an ObservableValueHolder[ true ]
		buttons: 	an OrderedCollection(a SpButtonPresenter a SpButtonPresenter)
		okAction: 	[ 
		cancelled := false.
		self close ]
		cancelAction: 	[ 
		cancelled := true.
		self close ]
		cancelled: 	true
		defaultButton: 	nil


SpButtonPresenter>>performAction
	Receiver: a SpButtonPresenter
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicButtonAdapter)
		announcer: 	an Announcer
		owner: 	a SpButtonBarPresenter
		adapter: 	a SpMorphicButtonAdapter
		needRebuild: 	true
		eventHandler: 	nil
		application: 	nil
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ nil ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Button' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpAbstractWidgetLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		borderWidth: 	an ObservableValueHolder[ nil ]
		borderColor: 	an ObservableValueHolder[ nil ]
		dragEnabled: 	an ObservableValueHolder[ false ]
		dropEnabled: 	an ObservableValueHolder[ false ]
		color: 	an ObservableValueHolder[ nil ]
		help: 	an ObservableValueHolder[ nil ]
		enabled: 	an ObservableValueHolder[ true ]
		wantsDrop: 	an ObservableValueHolder[ [ :transfer | self dropEnabled ] ]
		acceptDrop: 	an ObservableValueHolder[ [ :transfer | ] ]
		deferredActions: 	nil
		icon: 	an ObservableValueHolder[ nil ]
		label: 	an ObservableValueHolder[ 'Ok' ]
		action: 	an ObservableValueHolder[ [ aBlock cull: self ] ]
		actionPerformed: 	an ObservableValueHolder[ nil ]
		askBeforeChanging: 	an ObservableValueHolder[ false ]
		font: 	an ObservableValueHolder[ nil ]
		shortcut: 	an ObservableValueHolder[ nil ]
		state: 	an ObservableValueHolder[ false ]
		contextMenu: 	an ObservableValueHolder[ nil ]


SpMorphicButtonAdapter>>action
	Receiver: a SpMorphicButtonAdapter
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpPluggableButtonMorph(752092160))
		announcer: 	nil
		model: 	a SpButtonPresenter
		widget: 	a SpPluggableButtonMorph(752092160)
		selector: 	nil
		owner: 	a SpButtonPresenter
		unsubscribed: 	false
		subMenuWidget: 	nil
		styleName: 	nil


SpPluggableButtonMorph(PluggableButtonMorph)>>performAction:
	Receiver: a SpPluggableButtonMorph(752092160)
	Arguments and temporary variables: 
		event: 	[(1127@582) mouseUp 24561380 nil]
	Receiver's instance variables: 
		bounds: 	(1072.0@571.0) corner: (1172.0@601.0)
		owner: 	a PanelMorph(847022080)
		submorphs: 	an Array(an AlignmentMorph(326063360))
		fullBounds: 	nil
		color: 	(Color r: 0.9012707722385142 g: 0.9012707722385142 b: 0.901270772238[..]
		extension: 	a MorphExtension (123141888) [eventHandler = a MorphicEventHandl[..]
		borderWidth: 	1
		borderColor: 	#simple
		model: 	a SpMorphicButtonAdapter
		label: 	'Ok'
		icon: 	nil
		getIconSelector: 	nil
		getStateSelector: 	#state
		actionSelector: 	#action
		font: 	nil
		getLabelSelector: 	#label
		getMenuSelector: 	#menu:
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	#enabled
		getFontSelector: 	#font
		labelMorph: 	a LabelMorph(842632448)'Ok'
		iconMorph: 	nil
		iconPosition: 	#left
		lastState: 	false
		backgroundColor: 	nil


[:m |
		(m containsPoint: evt cursorPoint) ifTrue: [m enabled ifTrue: [ m performAction: evt ]]] in SpPluggableButtonMorph(PluggableButtonMorph)>>mouseUp:
	Receiver: a SpPluggableButtonMorph(752092160)
	Arguments and temporary variables: 
		evt: 	[(1127@582) mouseUp 24561380 nil]
		all: 	an Array(a SpPluggableButtonMorph(36018432) a SpPluggableButtonMorph(7[..]
		m: 	a SpPluggableButtonMorph(752092160)
	Receiver's instance variables: 
		bounds: 	(1072.0@571.0) corner: (1172.0@601.0)
		owner: 	a PanelMorph(847022080)
		submorphs: 	an Array(an AlignmentMorph(326063360))
		fullBounds: 	nil
		color: 	(Color r: 0.9012707722385142 g: 0.9012707722385142 b: 0.901270772238[..]
		extension: 	a MorphExtension (123141888) [eventHandler = a MorphicEventHandl[..]
		borderWidth: 	1
		borderColor: 	#simple
		model: 	a SpMorphicButtonAdapter
		label: 	'Ok'
		icon: 	nil
		getIconSelector: 	nil
		getStateSelector: 	#state
		actionSelector: 	#action
		font: 	nil
		getLabelSelector: 	#label
		getMenuSelector: 	#menu:
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	#enabled
		getFontSelector: 	#font
		labelMorph: 	a LabelMorph(842632448)'Ok'
		iconMorph: 	nil
		iconPosition: 	#left
		lastState: 	false
		backgroundColor: 	nil


Array(SequenceableCollection)>>do:
	Receiver: an Array(a SpPluggableButtonMorph(36018432) a SpPluggableButtonMorph(752092160))
	Arguments and temporary variables: 
		aBlock: 	[:m |
		(m containsPoint: evt cursorPoint) ifTrue: [m enabled ifTru[..]
		index: 	2
	Receiver's instance variables: 
an Array(a SpPluggableButtonMorph(36018432) a SpPluggableButtonMorph(752092160))

SpPluggableButtonMorph(PluggableButtonMorph)>>mouseUp:
	Receiver: a SpPluggableButtonMorph(752092160)
	Arguments and temporary variables: 
		evt: 	[(1127@582) mouseUp 24561380 nil]
		all: 	an Array(a SpPluggableButtonMorph(36018432) a SpPluggableButtonMorph(7[..]
	Receiver's instance variables: 
		bounds: 	(1072.0@571.0) corner: (1172.0@601.0)
		owner: 	a PanelMorph(847022080)
		submorphs: 	an Array(an AlignmentMorph(326063360))
		fullBounds: 	nil
		color: 	(Color r: 0.9012707722385142 g: 0.9012707722385142 b: 0.901270772238[..]
		extension: 	a MorphExtension (123141888) [eventHandler = a MorphicEventHandl[..]
		borderWidth: 	1
		borderColor: 	#simple
		model: 	a SpMorphicButtonAdapter
		label: 	'Ok'
		icon: 	nil
		getIconSelector: 	nil
		getStateSelector: 	#state
		actionSelector: 	#action
		font: 	nil
		getLabelSelector: 	#label
		getMenuSelector: 	#menu:
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	#enabled
		getFontSelector: 	#font
		labelMorph: 	a LabelMorph(842632448)'Ok'
		iconMorph: 	nil
		iconPosition: 	#left
		lastState: 	false
		backgroundColor: 	nil


SpPluggableButtonMorph(Morph)>>handleMouseUp:
	Receiver: a SpPluggableButtonMorph(752092160)
	Arguments and temporary variables: 
		anEvent: 	[(1127@582) mouseUp 24561380 nil]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(1072.0@571.0) corner: (1172.0@601.0)
		owner: 	a PanelMorph(847022080)
		submorphs: 	an Array(an AlignmentMorph(326063360))
		fullBounds: 	nil
		color: 	(Color r: 0.9012707722385142 g: 0.9012707722385142 b: 0.901270772238[..]
		extension: 	a MorphExtension (123141888) [eventHandler = a MorphicEventHandl[..]
		borderWidth: 	1
		borderColor: 	#simple
		model: 	a SpMorphicButtonAdapter
		label: 	'Ok'
		icon: 	nil
		getIconSelector: 	nil
		getStateSelector: 	#state
		actionSelector: 	#action
		font: 	nil
		getLabelSelector: 	#label
		getMenuSelector: 	#menu:
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	#enabled
		getFontSelector: 	#font
		labelMorph: 	a LabelMorph(842632448)'Ok'
		iconMorph: 	nil
		iconPosition: 	#left
		lastState: 	false
		backgroundColor: 	nil


MouseButtonEvent>>sentTo:
	Receiver: [(1127@582) mouseUp 24561380 nil]
	Arguments and temporary variables: 
		anObject: 	a SpPluggableButtonMorph(752092160)
	Receiver's instance variables: 
		timeStamp: 	24561380
		source: 	a HandMorph(337424384)
		windowIndex: 	nil
		type: 	#mouseUp
		buttons: 	0
		position: 	(1127@582)
		handler: 	nil
		wasHandled: 	true
		whichButton: 	4


SpPluggableButtonMorph(Morph)>>handleEvent:
	Receiver: a SpPluggableButtonMorph(752092160)
	Arguments and temporary variables: 
		anEvent: 	[(1127@582) mouseUp 24561380 nil]
	Receiver's instance variables: 
		bounds: 	(1072.0@571.0) corner: (1172.0@601.0)
		owner: 	a PanelMorph(847022080)
		submorphs: 	an Array(an AlignmentMorph(326063360))
		fullBounds: 	nil
		color: 	(Color r: 0.9012707722385142 g: 0.9012707722385142 b: 0.901270772238[..]
		extension: 	a MorphExtension (123141888) [eventHandler = a MorphicEventHandl[..]
		borderWidth: 	1
		borderColor: 	#simple
		model: 	a SpMorphicButtonAdapter
		label: 	'Ok'
		icon: 	nil
		getIconSelector: 	nil
		getStateSelector: 	#state
		actionSelector: 	#action
		font: 	nil
		getLabelSelector: 	#label
		getMenuSelector: 	#menu:
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	#enabled
		getFontSelector: 	#font
		labelMorph: 	a LabelMorph(842632448)'Ok'
		iconMorph: 	nil
		iconPosition: 	#left
		lastState: 	false
		backgroundColor: 	nil


SpPluggableButtonMorph(Morph)>>handleFocusEvent:
	Receiver: a SpPluggableButtonMorph(752092160)
	Arguments and temporary variables: 
		anEvent: 	[(1127@582) mouseUp 24561380 nil]
	Receiver's instance variables: 
		bounds: 	(1072.0@571.0) corner: (1172.0@601.0)
		owner: 	a PanelMorph(847022080)
		submorphs: 	an Array(an AlignmentMorph(326063360))
		fullBounds: 	nil
		color: 	(Color r: 0.9012707722385142 g: 0.9012707722385142 b: 0.901270772238[..]
		extension: 	a MorphExtension (123141888) [eventHandler = a MorphicEventHandl[..]
		borderWidth: 	1
		borderColor: 	#simple
		model: 	a SpMorphicButtonAdapter
		label: 	'Ok'
		icon: 	nil
		getIconSelector: 	nil
		getStateSelector: 	#state
		actionSelector: 	#action
		font: 	nil
		getLabelSelector: 	#label
		getMenuSelector: 	#menu:
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	#enabled
		getFontSelector: 	#font
		labelMorph: 	a LabelMorph(842632448)'Ok'
		iconMorph: 	nil
		iconPosition: 	#left
		lastState: 	false
		backgroundColor: 	nil


[
		result := focusHolder handleFocusEvent: transformedEvent.
	] in HandMorph>>sendFocusEvent:to:clear:
	Receiver: a HandMorph(337424384)
	Arguments and temporary variables: 
		anEvent: 	[(1127@582) mouseUp 24561380 nil]
		focusHolder: 	a SpPluggableButtonMorph(752092160)
		aBlock: 	[self mouseFocus: nil]
		w: 	a WorldMorph(341720576) [world]
		transformedEvent: 	[(1127@582) mouseUp 24561380 nil]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(1127@582.0) corner: (1143@598.0)
		owner: 	a WorldMorph(341720576) [world]
		submorphs: 	#()
		fullBounds: 	nil
		color: 	Color blue
		extension: 	a MorphExtension (370611968)
		mouseFocus: 	nil
		keyboardFocus: 	a SpPluggableButtonMorph(752092160)
		eventListeners: 	nil
		mouseListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(1127@582) mouseUp 24561380 nil]
		targetOffset: 	(55.0@11.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 0 0 0 0 0 nil nil)
		captureBlock: 	nil
		recentModifiers: 	0
		pendingEventQueue: 	WaitfreeQueue with 0 items
		supressNextKeyPress: 	false


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
		result := focusHolder handleFocusEvent: transformedEvent.
	]
	Arguments and temporary variables: 
		exception: 	Error
		handlerAction: 	[ :ex |
			ActiveWorld := priorWorld.
			ex pass ]
	Receiver's instance variables: 
		outerContext: 	HandMorph>>sendFocusEvent:to:clear:
		compiledBlock: 	a CompiledBlock: [
		result := focusHolder handleFocusEvent:[..]
		numArgs: 	0
		receiver: 	a HandMorph(337424384)


WorldMorph>>becomeActiveDuring:
	Receiver: a WorldMorph(341720576) [world]
	Arguments and temporary variables: 
		aBlock: 	[
		result := focusHolder handleFocusEvent: transformedEvent.
	]
		priorWorld: 	a WorldMorph(341720576) [world]
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1728@1080)
		owner: 	nil
		submorphs: 	an Array(a MenubarMorph(112886016) a TaskbarMorph(279458560) a S[..]
		fullBounds: 	nil
		color: 	(Color r: 0.9403714565004888 g: 0.9403714565004888 b: 0.940371456500[..]
		extension: 	a MorphExtension (1012946432) [other:  (dragEnabled -> true) (dr[..]
		borderWidth: 	0
		borderColor: 	(Color r: 0.8611925708699902 g: 1.0 b: 0.7223851417399805 alph[..]
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil


HandMorph>>sendFocusEvent:to:clear:
	Receiver: a HandMorph(337424384)
	Arguments and temporary variables: 
		result: 	nil
		anEvent: 	[(1127@582) mouseUp 24561380 nil]
		focusHolder: 	a SpPluggableButtonMorph(752092160)
		aBlock: 	[self mouseFocus: nil]
		w: 	a WorldMorph(341720576) [world]
		transformedEvent: 	[(1127@582) mouseUp 24561380 nil]
	Receiver's instance variables: 
		bounds: 	(1127@582.0) corner: (1143@598.0)
		owner: 	a WorldMorph(341720576) [world]
		submorphs: 	#()
		fullBounds: 	nil
		color: 	Color blue
		extension: 	a MorphExtension (370611968)
		mouseFocus: 	nil
		keyboardFocus: 	a SpPluggableButtonMorph(752092160)
		eventListeners: 	nil
		mouseListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(1127@582) mouseUp 24561380 nil]
		targetOffset: 	(55.0@11.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 0 0 0 0 0 nil nil)
		captureBlock: 	nil
		recentModifiers: 	0
		pendingEventQueue: 	WaitfreeQueue with 0 items
		supressNextKeyPress: 	false


HandMorph>>sendEvent:focus:clear:
	Receiver: a HandMorph(337424384)
	Arguments and temporary variables: 
		anEvent: 	[(1127@582) mouseUp 24561380 nil]
		focusHolder: 	a SpPluggableButtonMorph(752092160)
		aBlock: 	[self mouseFocus: nil]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(1127@582.0) corner: (1143@598.0)
		owner: 	a WorldMorph(341720576) [world]
		submorphs: 	#()
		fullBounds: 	nil
		color: 	Color blue
		extension: 	a MorphExtension (370611968)
		mouseFocus: 	nil
		keyboardFocus: 	a SpPluggableButtonMorph(752092160)
		eventListeners: 	nil
		mouseListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(1127@582) mouseUp 24561380 nil]
		targetOffset: 	(55.0@11.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 0 0 0 0 0 nil nil)
		captureBlock: 	nil
		recentModifiers: 	0
		pendingEventQueue: 	WaitfreeQueue with 0 items
		supressNextKeyPress: 	false


HandMorph>>sendMouseEvent:
	Receiver: a HandMorph(337424384)
	Arguments and temporary variables: 
		anEvent: 	[(1127@582) mouseUp 24561380 nil]
	Receiver's instance variables: 
		bounds: 	(1127@582.0) corner: (1143@598.0)
		owner: 	a WorldMorph(341720576) [world]
		submorphs: 	#()
		fullBounds: 	nil
		color: 	Color blue
		extension: 	a MorphExtension (370611968)
		mouseFocus: 	nil
		keyboardFocus: 	a SpPluggableButtonMorph(752092160)
		eventListeners: 	nil
		mouseListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(1127@582) mouseUp 24561380 nil]
		targetOffset: 	(55.0@11.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 0 0 0 0 0 nil nil)
		captureBlock: 	nil
		recentModifiers: 	0
		pendingEventQueue: 	WaitfreeQueue with 0 items
		supressNextKeyPress: 	false


HandMorph>>handleEvent:
	Receiver: a HandMorph(337424384)
	Arguments and temporary variables: 
		anEvent: 	[(1127@582) mouseUp 24561380 nil]
		evt: 	[(1127@582) mouseUp 24561380 nil]
	Receiver's instance variables: 
		bounds: 	(1127@582.0) corner: (1143@598.0)
		owner: 	a WorldMorph(341720576) [world]
		submorphs: 	#()
		fullBounds: 	nil
		color: 	Color blue
		extension: 	a MorphExtension (370611968)
		mouseFocus: 	nil
		keyboardFocus: 	a SpPluggableButtonMorph(752092160)
		eventListeners: 	nil
		mouseListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(1127@582) mouseUp 24561380 nil]
		targetOffset: 	(55.0@11.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 0 0 0 0 0 nil nil)
		captureBlock: 	nil
		recentModifiers: 	0
		pendingEventQueue: 	WaitfreeQueue with 0 items
		supressNextKeyPress: 	false


[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil ]) ifTrue: [
			morphicWorld activeHand handleEvent: anEvent
		]
	] in OSWindowMorphicEventHandler>>dispatchMorphicEvent:
	Receiver: an OSWindowMorphicEventHandler
	Arguments and temporary variables: 
		anEvent: 	[(1127@582) mouseUp 24561380 nil]
	Receiver's instance variables: 
		morphicWorld: 	a WorldMorph(341720576) [world]


WorldState>>runStepMethodsIn:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(341720576) [world]
		queue: 	WaitfreeQueue with 0 items
		nextInQueue: 	[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNo[..]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(337424384))
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap()
		lastStepTime: 	24499018
		lastStepMessage: 	nil
		alarms: 	a Heap()
		lastAlarmTime: 	24561367
		activeHand: 	a HandMorph(337424384)
		currentCursor: 	((CursorWithMask
	extent: (16@16)
	depth: 1
	fromArray: #(
	[..]
		worldRenderer: 	an OSWorldRenderer
		realWindowExtent: 	(1728@1080)
		deferredUIMessages: 	WaitfreeQueue with 0 items


WorldMorph>>runStepMethods
	Receiver: a WorldMorph(341720576) [world]
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1728@1080)
		owner: 	nil
		submorphs: 	an Array(a MenubarMorph(112886016) a TaskbarMorph(279458560) a S[..]
		fullBounds: 	nil
		color: 	(Color r: 0.9403714565004888 g: 0.9403714565004888 b: 0.940371456500[..]
		extension: 	a MorphExtension (1012946432) [other:  (dragEnabled -> true) (dr[..]
		borderWidth: 	0
		borderColor: 	(Color r: 0.8611925708699902 g: 1.0 b: 0.7223851417399805 alph[..]
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil


WorldState>>doOneCycleFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(341720576) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(337424384))
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap()
		lastStepTime: 	24499018
		lastStepMessage: 	nil
		alarms: 	a Heap()
		lastAlarmTime: 	24561367
		activeHand: 	a HandMorph(337424384)
		currentCursor: 	((CursorWithMask
	extent: (16@16)
	depth: 1
	fromArray: #(
	[..]
		worldRenderer: 	an OSWorldRenderer
		realWindowExtent: 	(1728@1080)
		deferredUIMessages: 	WaitfreeQueue with 0 items


WorldMorph>>doOneCycleNow
	Receiver: a WorldMorph(341720576) [world]
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1728@1080)
		owner: 	nil
		submorphs: 	an Array(a MenubarMorph(112886016) a TaskbarMorph(279458560) a S[..]
		fullBounds: 	nil
		color: 	(Color r: 0.9403714565004888 g: 0.9403714565004888 b: 0.940371456500[..]
		extension: 	a MorphExtension (1012946432) [other:  (dragEnabled -> true) (dr[..]
		borderWidth: 	0
		borderColor: 	(Color r: 0.8611925708699902 g: 1.0 b: 0.7223851417399805 alph[..]
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil


WorldMorph>>doOneCycle
	Receiver: a WorldMorph(341720576) [world]
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1728@1080)
		owner: 	nil
		submorphs: 	an Array(a MenubarMorph(112886016) a TaskbarMorph(279458560) a S[..]
		fullBounds: 	nil
		color: 	(Color r: 0.9403714565004888 g: 0.9403714565004888 b: 0.940371456500[..]
		extension: 	a MorphExtension (1012946432) [other:  (dragEnabled -> true) (dr[..]
		borderWidth: 	0
		borderColor: 	(Color r: 0.8611925708699902 g: 1.0 b: 0.7223851417399805 alph[..]
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil


[
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMutex critical: [
			                     self extraWorldList ].
		extraWorldsToDraw do: [ :world | world doOneCycle ].

		(self currentWorld isNotNil and: [
			 (extraWorldsToDraw includes: self currentWorld) not ]) ifTrue: [
			self currentWorld doOneCycle ] ] in WorldMorph class>>doOneCycle
	Receiver: WorldMorph
	Arguments and temporary variables: 
		extraWorldsToDraw: 	#()
	Receiver's instance variables: 
		superclass: 	PasteUpMorph
		methodDict: 	a MethodDictionary(#acceptDroppingMorph:event:->WorldMorph>>#ac[..]
		format: 	65547
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		commentSourcePointer: 	nil
		subclasses: 	{AthensWorldMorph. OSWindowWorldMorph}
		name: 	#WorldMorph
		classPool: 	a Dictionary(#AllowDropFiles->nil #CursorOwnerWorld->a WorldMorp[..]
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Morphic-Core-Worlds'
		announcer: 	nil
		displayScaleFactor: 	1


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMutex critical: [
			  [..]
	Arguments and temporary variables: 
		aBlock: 	[
		self doInterCycleWait
	]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	WorldMorph class>>doOneCycle
		compiledBlock: 	a CompiledBlock: [
		| extraWorldsToDraw |
		extraWorldsToDr[..]
		numArgs: 	0
		receiver: 	WorldMorph


WorldState class>>doDrawCycleWith:
	Receiver: WorldState
	Arguments and temporary variables: 
		aBlock: 	[
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMute[..]
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary(#activeHand->WorldState>>#activeHand #active[..]
		format: 	65548
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		commentSourcePointer: 	nil
		subclasses: 	{AthensWorldState}
		name: 	#WorldState
		classPool: 	a Dictionary(#CanSurrenderToOS->nil #DebugShowDamage->false #Des[..]
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Morphic-Core-Worlds'


WorldMorph class>>doOneCycle
	Receiver: WorldMorph
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		superclass: 	PasteUpMorph
		methodDict: 	a MethodDictionary(#acceptDroppingMorph:event:->WorldMorph>>#ac[..]
		format: 	65547
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		commentSourcePointer: 	nil
		subclasses: 	{AthensWorldMorph. OSWindowWorldMorph}
		name: 	#WorldMorph
		classPool: 	a Dictionary(#AllowDropFiles->nil #CursorOwnerWorld->a WorldMorp[..]
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Morphic-Core-Worlds'
		announcer: 	nil
		displayScaleFactor: 	1


MorphicRenderLoop>>doOneCycle
	Receiver: a MorphicRenderLoop
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
a MorphicRenderLoop

MorphicRenderLoop>>doOneCycleWhile:
	Receiver: a MorphicRenderLoop
	Arguments and temporary variables: 
		aBlock: 	[ true ]
	Receiver's instance variables: 
a MorphicRenderLoop

[ MorphicRenderLoop new doOneCycleWhile: [ true ] ] in MorphicUIManager>>spawnNewProcess
	Receiver: a MorphicUIManager
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		activeTranscript: 	nil



--- The full stack ---
IceTipNewRepositoryPanel(Object)>>assert:description:
IceTipNewRepositoryPanel>>validate
IceTipRegisterRepositoryDialog>>doAccept
[ 
	  self doAccept.
	  self closeWindow ] in IceTipRegisterRepositoryDialog(IceTipOptionDialog)>>accept
FullBlockClosure(BlockClosure)>>on:do:
IceTipRegisterRepositoryDialog(IceTipOptionDialog)>>accept
[ :presenter | self accept ] in IceTipRegisterRepositoryDialog(IceTipOptionDialog)>>initializeDialogWindow:
FullBlockClosure(BlockClosure)>>cull:
[ aBlock cull: self ] in SpDialogWindowPresenter>>addButton:do:
SpButtonPresenter>>performAction
SpMorphicButtonAdapter>>action
SpPluggableButtonMorph(PluggableButtonMorph)>>performAction:
[:m |
		(m containsPoint: evt cursorPoint) ifTrue: [m enabled ifTrue: [ m performAction: evt ]]] in SpPluggableButtonMorph(PluggableButtonMorph)>>mouseUp:
Array(SequenceableCollection)>>do:
SpPluggableButtonMorph(PluggableButtonMorph)>>mouseUp:
SpPluggableButtonMorph(Morph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
SpPluggableButtonMorph(Morph)>>handleEvent:
SpPluggableButtonMorph(Morph)>>handleFocusEvent:
[
		result := focusHolder handleFocusEvent: transformedEvent.
	] in HandMorph>>sendFocusEvent:to:clear:
FullBlockClosure(BlockClosure)>>on:do:
WorldMorph>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil ]) ifTrue: [
			morphicWorld activeHand handleEvent: anEvent
		]
	] in OSWindowMorphicEventHandler>>dispatchMorphicEvent:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycleNow
WorldMorph>>doOneCycle
[
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMutex critical: [
			                     self extraWorldList ].
		extraWorldsToDraw do: [ :world | world doOneCycle ].

		(self currentWorld isNotNil and: [
			 (extraWorldsToDraw includes: self currentWorld) not ]) ifTrue: [
			self currentWorld doOneCycle ] ] in WorldMorph class>>doOneCycle
FullBlockClosure(BlockClosure)>>ensure:
WorldState class>>doDrawCycleWith:
WorldMorph class>>doOneCycle
MorphicRenderLoop>>doOneCycle
MorphicRenderLoop>>doOneCycleWhile:
[ MorphicRenderLoop new doOneCycleWhile: [ true ] ] in MorphicUIManager>>spawnNewProcess
 - - - - - - - - - - - - - - -
			- - - - - - - - - - - - - - - - - -
[self value.
			"IMPORTANT: Do not step over next line of code. See method comments for details"
			Processor terminateRealActive] in FullBlockClosure(BlockClosure)>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
AssertionFailure: You must enter a project name (it will be used also as part of the path).
13 November 2023 10:54:03.28773 pm

VM: Mac OS - arm64 - 1000 - CoInterpreter VMMaker-tonel.1 uuid: 902dd483-c0c4-0d00-86f2-0f880df24b96 Oct 23 2023
StackToRegisterMappingCogit VMMaker-tonel.1 uuid: 902dd483-c0c4-0d00-86f2-0f880df24b96 Oct 23 2023
v10.0.8 - Commit: b323c5fb - Date: 2023-10-20 16:02:07 -0400

Image: Pharo11.0.0 [Build information: Pharo-11.0.0+build.710.sha.ea28d8552cac85a7ce1e9c34ab1e7bd45f7b9910 (64 Bit)]

IceTipNewRepositoryPanel(Object)>>assert:description:
	Receiver: an IceTipNewRepositoryPanel
	Arguments and temporary variables: 
		aBlock: 	false
		aStringOrBlock: 	'You must enter a project name (it will be used also as par[..]
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicGridAdapter)
		announcer: 	an Announcer
		owner: 	an IceTipRegisterRepositoryDialog
		adapter: 	a SpMorphicGridAdapter
		needRebuild: 	true
		eventHandler: 	nil
		application: 	a StPharoApplication
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ nil ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Untitled window' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpGridLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		decorations: 	nil
		projectLocationLabel: 	a SpLabelPresenter
		projectLocation: 	an IceTipDirectoryPresenter
		remoteLabel: 	nil
		remoteInputText: 	nil
		repository: 	nil
		projectNameLabel: 	a SpLabelPresenter
		projectNameInputText: 	a SpTextInputFieldPresenter
		subdirectoryLabel: 	a SpLabelPresenter
		subdirectoryInputText: 	a SpTextInputFieldPresenter


IceTipNewRepositoryPanel>>validate
	Receiver: an IceTipNewRepositoryPanel
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicGridAdapter)
		announcer: 	an Announcer
		owner: 	an IceTipRegisterRepositoryDialog
		adapter: 	a SpMorphicGridAdapter
		needRebuild: 	true
		eventHandler: 	nil
		application: 	a StPharoApplication
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ nil ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Untitled window' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpGridLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		decorations: 	nil
		projectLocationLabel: 	a SpLabelPresenter
		projectLocation: 	an IceTipDirectoryPresenter
		remoteLabel: 	nil
		remoteInputText: 	nil
		repository: 	nil
		projectNameLabel: 	a SpLabelPresenter
		projectNameInputText: 	a SpTextInputFieldPresenter
		subdirectoryLabel: 	a SpLabelPresenter
		subdirectoryInputText: 	a SpTextInputFieldPresenter


IceTipRegisterRepositoryDialog>>doAccept
	Receiver: an IceTipRegisterRepositoryDialog
	Arguments and temporary variables: 
		newRepository: 	nil
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicPanedAdapter a SpMorphicBoxAdapter)
		announcer: 	an Announcer
		owner: 	a SpDialogWindowPresenter
		adapter: 	a SpMorphicPanedAdapter
		needRebuild: 	true
		eventHandler: 	nil
		application: 	a StPharoApplication
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ nil ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Untitled window' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpPanedLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		decorations: 	nil
		typeList: 	a SpListPresenter
		type: 	an IceTipNewRepositoryPanel
		contentLayout: 	a SpBoxLayout
		types: 	an OrderedCollection(an IceTipNewRepositoryPanel an IceTipLocalRepos[..]
		repository: 	nil
		acceptBlock: 	nil


[ 
	  self doAccept.
	  self closeWindow ] in IceTipRegisterRepositoryDialog(IceTipOptionDialog)>>accept
	Receiver: an IceTipRegisterRepositoryDialog
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicPanedAdapter a SpMorphicBoxAdapter)
		announcer: 	an Announcer
		owner: 	a SpDialogWindowPresenter
		adapter: 	a SpMorphicPanedAdapter
		needRebuild: 	true
		eventHandler: 	nil
		application: 	a StPharoApplication
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ nil ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Untitled window' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpPanedLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		decorations: 	nil
		typeList: 	a SpListPresenter
		type: 	an IceTipNewRepositoryPanel
		contentLayout: 	a SpBoxLayout
		types: 	an OrderedCollection(an IceTipNewRepositoryPanel an IceTipLocalRepos[..]
		repository: 	nil
		acceptBlock: 	nil


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [ 
	  self doAccept.
	  self closeWindow ]
	Arguments and temporary variables: 
		exception: 	an ExceptionSet
		handlerAction: 	[ :e | 
			  e acceptError: (IceTipInteractiveErrorVisitor n[..]
	Receiver's instance variables: 
		outerContext: 	IceTipRegisterRepositoryDialog(IceTipOptionDialog)>>accept
		compiledBlock: 	a CompiledBlock: [ 
	  self doAccept.
	  self closeWindow ]
		numArgs: 	0
		receiver: 	an IceTipRegisterRepositoryDialog


IceTipRegisterRepositoryDialog(IceTipOptionDialog)>>accept
	Receiver: an IceTipRegisterRepositoryDialog
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicPanedAdapter a SpMorphicBoxAdapter)
		announcer: 	an Announcer
		owner: 	a SpDialogWindowPresenter
		adapter: 	a SpMorphicPanedAdapter
		needRebuild: 	true
		eventHandler: 	nil
		application: 	a StPharoApplication
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ nil ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Untitled window' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpPanedLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		decorations: 	nil
		typeList: 	a SpListPresenter
		type: 	an IceTipNewRepositoryPanel
		contentLayout: 	a SpBoxLayout
		types: 	an OrderedCollection(an IceTipNewRepositoryPanel an IceTipLocalRepos[..]
		repository: 	nil
		acceptBlock: 	nil


[ :presenter | self accept ] in IceTipRegisterRepositoryDialog(IceTipOptionDialog)>>initializeDialogWindow:
	Receiver: an IceTipRegisterRepositoryDialog
	Arguments and temporary variables: 
		aWindowPresenter: 	a SpDialogWindowPresenter
		presenter: 	a SpDialogWindowPresenter
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicPanedAdapter a SpMorphicBoxAdapter)
		announcer: 	an Announcer
		owner: 	a SpDialogWindowPresenter
		adapter: 	a SpMorphicPanedAdapter
		needRebuild: 	true
		eventHandler: 	nil
		application: 	a StPharoApplication
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ nil ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Untitled window' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpPanedLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		decorations: 	nil
		typeList: 	a SpListPresenter
		type: 	an IceTipNewRepositoryPanel
		contentLayout: 	a SpBoxLayout
		types: 	an OrderedCollection(an IceTipNewRepositoryPanel an IceTipLocalRepos[..]
		repository: 	nil
		acceptBlock: 	nil


FullBlockClosure(BlockClosure)>>cull:
	Receiver: [ :presenter | self accept ]
	Arguments and temporary variables: 
		anArg: 	a SpDialogWindowPresenter
	Receiver's instance variables: 
		outerContext: 	IceTipRegisterRepositoryDialog(IceTipOptionDialog)>>initializ[..]
		compiledBlock: 	a CompiledBlock: [ :presenter | self accept ]
		numArgs: 	1
		receiver: 	an IceTipRegisterRepositoryDialog


[ aBlock cull: self ] in SpDialogWindowPresenter>>addButton:do:
	Receiver: a SpDialogWindowPresenter
	Arguments and temporary variables: 
		aString: 	'Ok'
		aBlock: 	[ :presenter | self accept ]
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicDialogWindowAdapter a SpDialogWind[..]
		announcer: 	an Announcer
		owner: 	nil
		adapter: 	a SpMorphicDialogWindowAdapter
		needRebuild: 	true
		eventHandler: 	nil
		application: 	a StPharoApplication
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ nil ]
		windowIcon: 	an ObservableValueHolder[ Form(16x16x32) ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ true ]
		titleHolder: 	an ObservableValueHolder[ 'New repository' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ nil ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		borderWidth: 	an ObservableValueHolder[ nil ]
		borderColor: 	an ObservableValueHolder[ nil ]
		dragEnabled: 	an ObservableValueHolder[ false ]
		dropEnabled: 	an ObservableValueHolder[ false ]
		color: 	an ObservableValueHolder[ nil ]
		help: 	an ObservableValueHolder[ nil ]
		enabled: 	an ObservableValueHolder[ true ]
		wantsDrop: 	an ObservableValueHolder[ [ :transfer | self dropEnabled ] ]
		acceptDrop: 	an ObservableValueHolder[ [ :transfer | ] ]
		deferredActions: 	nil
		presenter: 	an ObservableValueHolder[ an IceTipRegisterRepositoryDialog ]
		initialPosition: 	an ObservableValueHolder[ nil ]
		initialExtent: 	an ObservableValueHolder[ (700@300) ]
		menu: 	an ObservableValueHolder[ nil ]
		centered: 	an ObservableValueHolder[ false ]
		isClosed: 	an ObservableValueHolder[ false ]
		toolbar: 	an ObservableValueHolder[ nil ]
		statusbar: 	an ObservableValueHolder[ nil ]
		window: 	an ObservableValueHolder[ a SpDialogWindowMorph(395736832) named: N[..]
		decorations: 	an ObservableValueHolder[ true ]
		resizable: 	an ObservableValueHolder[ true ]
		buttons: 	an OrderedCollection(a SpButtonPresenter a SpButtonPresenter)
		okAction: 	[ 
		cancelled := false.
		self close ]
		cancelAction: 	[ 
		cancelled := true.
		self close ]
		cancelled: 	true
		defaultButton: 	nil


SpButtonPresenter>>performAction
	Receiver: a SpButtonPresenter
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicButtonAdapter)
		announcer: 	an Announcer
		owner: 	a SpButtonBarPresenter
		adapter: 	a SpMorphicButtonAdapter
		needRebuild: 	true
		eventHandler: 	nil
		application: 	nil
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ nil ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Button' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpAbstractWidgetLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		borderWidth: 	an ObservableValueHolder[ nil ]
		borderColor: 	an ObservableValueHolder[ nil ]
		dragEnabled: 	an ObservableValueHolder[ false ]
		dropEnabled: 	an ObservableValueHolder[ false ]
		color: 	an ObservableValueHolder[ nil ]
		help: 	an ObservableValueHolder[ nil ]
		enabled: 	an ObservableValueHolder[ true ]
		wantsDrop: 	an ObservableValueHolder[ [ :transfer | self dropEnabled ] ]
		acceptDrop: 	an ObservableValueHolder[ [ :transfer | ] ]
		deferredActions: 	nil
		icon: 	an ObservableValueHolder[ nil ]
		label: 	an ObservableValueHolder[ 'Ok' ]
		action: 	an ObservableValueHolder[ [ aBlock cull: self ] ]
		actionPerformed: 	an ObservableValueHolder[ nil ]
		askBeforeChanging: 	an ObservableValueHolder[ false ]
		font: 	an ObservableValueHolder[ nil ]
		shortcut: 	an ObservableValueHolder[ nil ]
		state: 	an ObservableValueHolder[ false ]
		contextMenu: 	an ObservableValueHolder[ nil ]


SpMorphicButtonAdapter>>action
	Receiver: a SpMorphicButtonAdapter
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpPluggableButtonMorph(752092160))
		announcer: 	nil
		model: 	a SpButtonPresenter
		widget: 	a SpPluggableButtonMorph(752092160)
		selector: 	nil
		owner: 	a SpButtonPresenter
		unsubscribed: 	false
		subMenuWidget: 	nil
		styleName: 	nil


SpPluggableButtonMorph(PluggableButtonMorph)>>performAction:
	Receiver: a SpPluggableButtonMorph(752092160)
	Arguments and temporary variables: 
		event: 	[(1127@582) mouseUp 24561380 nil]
	Receiver's instance variables: 
		bounds: 	(1072.0@571.0) corner: (1172.0@601.0)
		owner: 	a PanelMorph(847022080)
		submorphs: 	an Array(an AlignmentMorph(326063360))
		fullBounds: 	nil
		color: 	(Color r: 0.9012707722385142 g: 0.9012707722385142 b: 0.901270772238[..]
		extension: 	a MorphExtension (123141888) [eventHandler = a MorphicEventHandl[..]
		borderWidth: 	1
		borderColor: 	#simple
		model: 	a SpMorphicButtonAdapter
		label: 	'Ok'
		icon: 	nil
		getIconSelector: 	nil
		getStateSelector: 	#state
		actionSelector: 	#action
		font: 	nil
		getLabelSelector: 	#label
		getMenuSelector: 	#menu:
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	#enabled
		getFontSelector: 	#font
		labelMorph: 	a LabelMorph(842632448)'Ok'
		iconMorph: 	nil
		iconPosition: 	#left
		lastState: 	false
		backgroundColor: 	nil


[:m |
		(m containsPoint: evt cursorPoint) ifTrue: [m enabled ifTrue: [ m performAction: evt ]]] in SpPluggableButtonMorph(PluggableButtonMorph)>>mouseUp:
	Receiver: a SpPluggableButtonMorph(752092160)
	Arguments and temporary variables: 
		evt: 	[(1127@582) mouseUp 24561380 nil]
		all: 	an Array(a SpPluggableButtonMorph(36018432) a SpPluggableButtonMorph(7[..]
		m: 	a SpPluggableButtonMorph(752092160)
	Receiver's instance variables: 
		bounds: 	(1072.0@571.0) corner: (1172.0@601.0)
		owner: 	a PanelMorph(847022080)
		submorphs: 	an Array(an AlignmentMorph(326063360))
		fullBounds: 	nil
		color: 	(Color r: 0.9012707722385142 g: 0.9012707722385142 b: 0.901270772238[..]
		extension: 	a MorphExtension (123141888) [eventHandler = a MorphicEventHandl[..]
		borderWidth: 	1
		borderColor: 	#simple
		model: 	a SpMorphicButtonAdapter
		label: 	'Ok'
		icon: 	nil
		getIconSelector: 	nil
		getStateSelector: 	#state
		actionSelector: 	#action
		font: 	nil
		getLabelSelector: 	#label
		getMenuSelector: 	#menu:
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	#enabled
		getFontSelector: 	#font
		labelMorph: 	a LabelMorph(842632448)'Ok'
		iconMorph: 	nil
		iconPosition: 	#left
		lastState: 	false
		backgroundColor: 	nil


Array(SequenceableCollection)>>do:
	Receiver: an Array(a SpPluggableButtonMorph(36018432) a SpPluggableButtonMorph(752092160))
	Arguments and temporary variables: 
		aBlock: 	[:m |
		(m containsPoint: evt cursorPoint) ifTrue: [m enabled ifTru[..]
		index: 	2
	Receiver's instance variables: 
an Array(a SpPluggableButtonMorph(36018432) a SpPluggableButtonMorph(752092160))

SpPluggableButtonMorph(PluggableButtonMorph)>>mouseUp:
	Receiver: a SpPluggableButtonMorph(752092160)
	Arguments and temporary variables: 
		evt: 	[(1127@582) mouseUp 24561380 nil]
		all: 	an Array(a SpPluggableButtonMorph(36018432) a SpPluggableButtonMorph(7[..]
	Receiver's instance variables: 
		bounds: 	(1072.0@571.0) corner: (1172.0@601.0)
		owner: 	a PanelMorph(847022080)
		submorphs: 	an Array(an AlignmentMorph(326063360))
		fullBounds: 	nil
		color: 	(Color r: 0.9012707722385142 g: 0.9012707722385142 b: 0.901270772238[..]
		extension: 	a MorphExtension (123141888) [eventHandler = a MorphicEventHandl[..]
		borderWidth: 	1
		borderColor: 	#simple
		model: 	a SpMorphicButtonAdapter
		label: 	'Ok'
		icon: 	nil
		getIconSelector: 	nil
		getStateSelector: 	#state
		actionSelector: 	#action
		font: 	nil
		getLabelSelector: 	#label
		getMenuSelector: 	#menu:
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	#enabled
		getFontSelector: 	#font
		labelMorph: 	a LabelMorph(842632448)'Ok'
		iconMorph: 	nil
		iconPosition: 	#left
		lastState: 	false
		backgroundColor: 	nil


SpPluggableButtonMorph(Morph)>>handleMouseUp:
	Receiver: a SpPluggableButtonMorph(752092160)
	Arguments and temporary variables: 
		anEvent: 	[(1127@582) mouseUp 24561380 nil]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(1072.0@571.0) corner: (1172.0@601.0)
		owner: 	a PanelMorph(847022080)
		submorphs: 	an Array(an AlignmentMorph(326063360))
		fullBounds: 	nil
		color: 	(Color r: 0.9012707722385142 g: 0.9012707722385142 b: 0.901270772238[..]
		extension: 	a MorphExtension (123141888) [eventHandler = a MorphicEventHandl[..]
		borderWidth: 	1
		borderColor: 	#simple
		model: 	a SpMorphicButtonAdapter
		label: 	'Ok'
		icon: 	nil
		getIconSelector: 	nil
		getStateSelector: 	#state
		actionSelector: 	#action
		font: 	nil
		getLabelSelector: 	#label
		getMenuSelector: 	#menu:
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	#enabled
		getFontSelector: 	#font
		labelMorph: 	a LabelMorph(842632448)'Ok'
		iconMorph: 	nil
		iconPosition: 	#left
		lastState: 	false
		backgroundColor: 	nil


MouseButtonEvent>>sentTo:
	Receiver: [(1127@582) mouseUp 24561380 nil]
	Arguments and temporary variables: 
		anObject: 	a SpPluggableButtonMorph(752092160)
	Receiver's instance variables: 
		timeStamp: 	24561380
		source: 	a HandMorph(337424384)
		windowIndex: 	nil
		type: 	#mouseUp
		buttons: 	0
		position: 	(1127@582)
		handler: 	nil
		wasHandled: 	true
		whichButton: 	4


SpPluggableButtonMorph(Morph)>>handleEvent:
	Receiver: a SpPluggableButtonMorph(752092160)
	Arguments and temporary variables: 
		anEvent: 	[(1127@582) mouseUp 24561380 nil]
	Receiver's instance variables: 
		bounds: 	(1072.0@571.0) corner: (1172.0@601.0)
		owner: 	a PanelMorph(847022080)
		submorphs: 	an Array(an AlignmentMorph(326063360))
		fullBounds: 	nil
		color: 	(Color r: 0.9012707722385142 g: 0.9012707722385142 b: 0.901270772238[..]
		extension: 	a MorphExtension (123141888) [eventHandler = a MorphicEventHandl[..]
		borderWidth: 	1
		borderColor: 	#simple
		model: 	a SpMorphicButtonAdapter
		label: 	'Ok'
		icon: 	nil
		getIconSelector: 	nil
		getStateSelector: 	#state
		actionSelector: 	#action
		font: 	nil
		getLabelSelector: 	#label
		getMenuSelector: 	#menu:
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	#enabled
		getFontSelector: 	#font
		labelMorph: 	a LabelMorph(842632448)'Ok'
		iconMorph: 	nil
		iconPosition: 	#left
		lastState: 	false
		backgroundColor: 	nil


SpPluggableButtonMorph(Morph)>>handleFocusEvent:
	Receiver: a SpPluggableButtonMorph(752092160)
	Arguments and temporary variables: 
		anEvent: 	[(1127@582) mouseUp 24561380 nil]
	Receiver's instance variables: 
		bounds: 	(1072.0@571.0) corner: (1172.0@601.0)
		owner: 	a PanelMorph(847022080)
		submorphs: 	an Array(an AlignmentMorph(326063360))
		fullBounds: 	nil
		color: 	(Color r: 0.9012707722385142 g: 0.9012707722385142 b: 0.901270772238[..]
		extension: 	a MorphExtension (123141888) [eventHandler = a MorphicEventHandl[..]
		borderWidth: 	1
		borderColor: 	#simple
		model: 	a SpMorphicButtonAdapter
		label: 	'Ok'
		icon: 	nil
		getIconSelector: 	nil
		getStateSelector: 	#state
		actionSelector: 	#action
		font: 	nil
		getLabelSelector: 	#label
		getMenuSelector: 	#menu:
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	#enabled
		getFontSelector: 	#font
		labelMorph: 	a LabelMorph(842632448)'Ok'
		iconMorph: 	nil
		iconPosition: 	#left
		lastState: 	false
		backgroundColor: 	nil


[
		result := focusHolder handleFocusEvent: transformedEvent.
	] in HandMorph>>sendFocusEvent:to:clear:
	Receiver: a HandMorph(337424384)
	Arguments and temporary variables: 
		anEvent: 	[(1127@582) mouseUp 24561380 nil]
		focusHolder: 	a SpPluggableButtonMorph(752092160)
		aBlock: 	[self mouseFocus: nil]
		w: 	a WorldMorph(341720576) [world]
		transformedEvent: 	[(1127@582) mouseUp 24561380 nil]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(1127@582.0) corner: (1143@598.0)
		owner: 	a WorldMorph(341720576) [world]
		submorphs: 	#()
		fullBounds: 	nil
		color: 	Color blue
		extension: 	a MorphExtension (370611968)
		mouseFocus: 	nil
		keyboardFocus: 	a SpPluggableButtonMorph(752092160)
		eventListeners: 	nil
		mouseListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(1127@582) mouseUp 24561380 nil]
		targetOffset: 	(55.0@11.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 0 0 0 0 0 nil nil)
		captureBlock: 	nil
		recentModifiers: 	0
		pendingEventQueue: 	WaitfreeQueue with 0 items
		supressNextKeyPress: 	false


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
		result := focusHolder handleFocusEvent: transformedEvent.
	]
	Arguments and temporary variables: 
		exception: 	Error
		handlerAction: 	[ :ex |
			ActiveWorld := priorWorld.
			ex pass ]
	Receiver's instance variables: 
		outerContext: 	HandMorph>>sendFocusEvent:to:clear:
		compiledBlock: 	a CompiledBlock: [
		result := focusHolder handleFocusEvent:[..]
		numArgs: 	0
		receiver: 	a HandMorph(337424384)


WorldMorph>>becomeActiveDuring:
	Receiver: a WorldMorph(341720576) [world]
	Arguments and temporary variables: 
		aBlock: 	[
		result := focusHolder handleFocusEvent: transformedEvent.
	]
		priorWorld: 	a WorldMorph(341720576) [world]
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1728@1080)
		owner: 	nil
		submorphs: 	an Array(a MenubarMorph(112886016) a TaskbarMorph(279458560) a S[..]
		fullBounds: 	nil
		color: 	(Color r: 0.9403714565004888 g: 0.9403714565004888 b: 0.940371456500[..]
		extension: 	a MorphExtension (1012946432) [other:  (dragEnabled -> true) (dr[..]
		borderWidth: 	0
		borderColor: 	(Color r: 0.8611925708699902 g: 1.0 b: 0.7223851417399805 alph[..]
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil


HandMorph>>sendFocusEvent:to:clear:
	Receiver: a HandMorph(337424384)
	Arguments and temporary variables: 
		result: 	nil
		anEvent: 	[(1127@582) mouseUp 24561380 nil]
		focusHolder: 	a SpPluggableButtonMorph(752092160)
		aBlock: 	[self mouseFocus: nil]
		w: 	a WorldMorph(341720576) [world]
		transformedEvent: 	[(1127@582) mouseUp 24561380 nil]
	Receiver's instance variables: 
		bounds: 	(1127@582.0) corner: (1143@598.0)
		owner: 	a WorldMorph(341720576) [world]
		submorphs: 	#()
		fullBounds: 	nil
		color: 	Color blue
		extension: 	a MorphExtension (370611968)
		mouseFocus: 	nil
		keyboardFocus: 	a SpPluggableButtonMorph(752092160)
		eventListeners: 	nil
		mouseListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(1127@582) mouseUp 24561380 nil]
		targetOffset: 	(55.0@11.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 0 0 0 0 0 nil nil)
		captureBlock: 	nil
		recentModifiers: 	0
		pendingEventQueue: 	WaitfreeQueue with 0 items
		supressNextKeyPress: 	false


HandMorph>>sendEvent:focus:clear:
	Receiver: a HandMorph(337424384)
	Arguments and temporary variables: 
		anEvent: 	[(1127@582) mouseUp 24561380 nil]
		focusHolder: 	a SpPluggableButtonMorph(752092160)
		aBlock: 	[self mouseFocus: nil]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(1127@582.0) corner: (1143@598.0)
		owner: 	a WorldMorph(341720576) [world]
		submorphs: 	#()
		fullBounds: 	nil
		color: 	Color blue
		extension: 	a MorphExtension (370611968)
		mouseFocus: 	nil
		keyboardFocus: 	a SpPluggableButtonMorph(752092160)
		eventListeners: 	nil
		mouseListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(1127@582) mouseUp 24561380 nil]
		targetOffset: 	(55.0@11.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 0 0 0 0 0 nil nil)
		captureBlock: 	nil
		recentModifiers: 	0
		pendingEventQueue: 	WaitfreeQueue with 0 items
		supressNextKeyPress: 	false


HandMorph>>sendMouseEvent:
	Receiver: a HandMorph(337424384)
	Arguments and temporary variables: 
		anEvent: 	[(1127@582) mouseUp 24561380 nil]
	Receiver's instance variables: 
		bounds: 	(1127@582.0) corner: (1143@598.0)
		owner: 	a WorldMorph(341720576) [world]
		submorphs: 	#()
		fullBounds: 	nil
		color: 	Color blue
		extension: 	a MorphExtension (370611968)
		mouseFocus: 	nil
		keyboardFocus: 	a SpPluggableButtonMorph(752092160)
		eventListeners: 	nil
		mouseListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(1127@582) mouseUp 24561380 nil]
		targetOffset: 	(55.0@11.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 0 0 0 0 0 nil nil)
		captureBlock: 	nil
		recentModifiers: 	0
		pendingEventQueue: 	WaitfreeQueue with 0 items
		supressNextKeyPress: 	false


HandMorph>>handleEvent:
	Receiver: a HandMorph(337424384)
	Arguments and temporary variables: 
		anEvent: 	[(1127@582) mouseUp 24561380 nil]
		evt: 	[(1127@582) mouseUp 24561380 nil]
	Receiver's instance variables: 
		bounds: 	(1127@582.0) corner: (1143@598.0)
		owner: 	a WorldMorph(341720576) [world]
		submorphs: 	#()
		fullBounds: 	nil
		color: 	Color blue
		extension: 	a MorphExtension (370611968)
		mouseFocus: 	nil
		keyboardFocus: 	a SpPluggableButtonMorph(752092160)
		eventListeners: 	nil
		mouseListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(1127@582) mouseUp 24561380 nil]
		targetOffset: 	(55.0@11.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 0 0 0 0 0 nil nil)
		captureBlock: 	nil
		recentModifiers: 	0
		pendingEventQueue: 	WaitfreeQueue with 0 items
		supressNextKeyPress: 	false


[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil ]) ifTrue: [
			morphicWorld activeHand handleEvent: anEvent
		]
	] in OSWindowMorphicEventHandler>>dispatchMorphicEvent:
	Receiver: an OSWindowMorphicEventHandler
	Arguments and temporary variables: 
		anEvent: 	[(1127@582) mouseUp 24561380 nil]
	Receiver's instance variables: 
		morphicWorld: 	a WorldMorph(341720576) [world]


WorldState>>runStepMethodsIn:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(341720576) [world]
		queue: 	WaitfreeQueue with 0 items
		nextInQueue: 	[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNo[..]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(337424384))
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap()
		lastStepTime: 	24499018
		lastStepMessage: 	nil
		alarms: 	a Heap()
		lastAlarmTime: 	24561367
		activeHand: 	a HandMorph(337424384)
		currentCursor: 	((CursorWithMask
	extent: (16@16)
	depth: 1
	fromArray: #(
	[..]
		worldRenderer: 	an OSWorldRenderer
		realWindowExtent: 	(1728@1080)
		deferredUIMessages: 	WaitfreeQueue with 0 items


WorldMorph>>runStepMethods
	Receiver: a WorldMorph(341720576) [world]
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1728@1080)
		owner: 	nil
		submorphs: 	an Array(a MenubarMorph(112886016) a TaskbarMorph(279458560) a S[..]
		fullBounds: 	nil
		color: 	(Color r: 0.9403714565004888 g: 0.9403714565004888 b: 0.940371456500[..]
		extension: 	a MorphExtension (1012946432) [other:  (dragEnabled -> true) (dr[..]
		borderWidth: 	0
		borderColor: 	(Color r: 0.8611925708699902 g: 1.0 b: 0.7223851417399805 alph[..]
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil


WorldState>>doOneCycleFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(341720576) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(337424384))
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap()
		lastStepTime: 	24499018
		lastStepMessage: 	nil
		alarms: 	a Heap()
		lastAlarmTime: 	24561367
		activeHand: 	a HandMorph(337424384)
		currentCursor: 	((CursorWithMask
	extent: (16@16)
	depth: 1
	fromArray: #(
	[..]
		worldRenderer: 	an OSWorldRenderer
		realWindowExtent: 	(1728@1080)
		deferredUIMessages: 	WaitfreeQueue with 0 items


WorldMorph>>doOneCycleNow
	Receiver: a WorldMorph(341720576) [world]
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1728@1080)
		owner: 	nil
		submorphs: 	an Array(a MenubarMorph(112886016) a TaskbarMorph(279458560) a S[..]
		fullBounds: 	nil
		color: 	(Color r: 0.9403714565004888 g: 0.9403714565004888 b: 0.940371456500[..]
		extension: 	a MorphExtension (1012946432) [other:  (dragEnabled -> true) (dr[..]
		borderWidth: 	0
		borderColor: 	(Color r: 0.8611925708699902 g: 1.0 b: 0.7223851417399805 alph[..]
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil


WorldMorph>>doOneCycle
	Receiver: a WorldMorph(341720576) [world]
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1728@1080)
		owner: 	nil
		submorphs: 	an Array(a MenubarMorph(112886016) a TaskbarMorph(279458560) a S[..]
		fullBounds: 	nil
		color: 	(Color r: 0.9403714565004888 g: 0.9403714565004888 b: 0.940371456500[..]
		extension: 	a MorphExtension (1012946432) [other:  (dragEnabled -> true) (dr[..]
		borderWidth: 	0
		borderColor: 	(Color r: 0.8611925708699902 g: 1.0 b: 0.7223851417399805 alph[..]
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil


[
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMutex critical: [
			                     self extraWorldList ].
		extraWorldsToDraw do: [ :world | world doOneCycle ].

		(self currentWorld isNotNil and: [
			 (extraWorldsToDraw includes: self currentWorld) not ]) ifTrue: [
			self currentWorld doOneCycle ] ] in WorldMorph class>>doOneCycle
	Receiver: WorldMorph
	Arguments and temporary variables: 
		extraWorldsToDraw: 	#()
	Receiver's instance variables: 
		superclass: 	PasteUpMorph
		methodDict: 	a MethodDictionary(#acceptDroppingMorph:event:->WorldMorph>>#ac[..]
		format: 	65547
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		commentSourcePointer: 	nil
		subclasses: 	{AthensWorldMorph. OSWindowWorldMorph}
		name: 	#WorldMorph
		classPool: 	a Dictionary(#AllowDropFiles->nil #CursorOwnerWorld->a WorldMorp[..]
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Morphic-Core-Worlds'
		announcer: 	nil
		displayScaleFactor: 	1


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMutex critical: [
			  [..]
	Arguments and temporary variables: 
		aBlock: 	[
		self doInterCycleWait
	]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	WorldMorph class>>doOneCycle
		compiledBlock: 	a CompiledBlock: [
		| extraWorldsToDraw |
		extraWorldsToDr[..]
		numArgs: 	0
		receiver: 	WorldMorph


WorldState class>>doDrawCycleWith:
	Receiver: WorldState
	Arguments and temporary variables: 
		aBlock: 	[
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMute[..]
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary(#activeHand->WorldState>>#activeHand #active[..]
		format: 	65548
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		commentSourcePointer: 	nil
		subclasses: 	{AthensWorldState}
		name: 	#WorldState
		classPool: 	a Dictionary(#CanSurrenderToOS->nil #DebugShowDamage->false #Des[..]
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Morphic-Core-Worlds'


WorldMorph class>>doOneCycle
	Receiver: WorldMorph
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		superclass: 	PasteUpMorph
		methodDict: 	a MethodDictionary(#acceptDroppingMorph:event:->WorldMorph>>#ac[..]
		format: 	65547
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		commentSourcePointer: 	nil
		subclasses: 	{AthensWorldMorph. OSWindowWorldMorph}
		name: 	#WorldMorph
		classPool: 	a Dictionary(#AllowDropFiles->nil #CursorOwnerWorld->a WorldMorp[..]
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Morphic-Core-Worlds'
		announcer: 	nil
		displayScaleFactor: 	1


MorphicRenderLoop>>doOneCycle
	Receiver: a MorphicRenderLoop
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
a MorphicRenderLoop

MorphicRenderLoop>>doOneCycleWhile:
	Receiver: a MorphicRenderLoop
	Arguments and temporary variables: 
		aBlock: 	[ true ]
	Receiver's instance variables: 
a MorphicRenderLoop

[ MorphicRenderLoop new doOneCycleWhile: [ true ] ] in MorphicUIManager>>spawnNewProcess
	Receiver: a MorphicUIManager
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		activeTranscript: 	nil



--- The full stack ---
IceTipNewRepositoryPanel(Object)>>assert:description:
IceTipNewRepositoryPanel>>validate
IceTipRegisterRepositoryDialog>>doAccept
[ 
	  self doAccept.
	  self closeWindow ] in IceTipRegisterRepositoryDialog(IceTipOptionDialog)>>accept
FullBlockClosure(BlockClosure)>>on:do:
IceTipRegisterRepositoryDialog(IceTipOptionDialog)>>accept
[ :presenter | self accept ] in IceTipRegisterRepositoryDialog(IceTipOptionDialog)>>initializeDialogWindow:
FullBlockClosure(BlockClosure)>>cull:
[ aBlock cull: self ] in SpDialogWindowPresenter>>addButton:do:
SpButtonPresenter>>performAction
SpMorphicButtonAdapter>>action
SpPluggableButtonMorph(PluggableButtonMorph)>>performAction:
[:m |
		(m containsPoint: evt cursorPoint) ifTrue: [m enabled ifTrue: [ m performAction: evt ]]] in SpPluggableButtonMorph(PluggableButtonMorph)>>mouseUp:
Array(SequenceableCollection)>>do:
SpPluggableButtonMorph(PluggableButtonMorph)>>mouseUp:
SpPluggableButtonMorph(Morph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
SpPluggableButtonMorph(Morph)>>handleEvent:
SpPluggableButtonMorph(Morph)>>handleFocusEvent:
[
		result := focusHolder handleFocusEvent: transformedEvent.
	] in HandMorph>>sendFocusEvent:to:clear:
FullBlockClosure(BlockClosure)>>on:do:
WorldMorph>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil ]) ifTrue: [
			morphicWorld activeHand handleEvent: anEvent
		]
	] in OSWindowMorphicEventHandler>>dispatchMorphicEvent:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycleNow
WorldMorph>>doOneCycle
[
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMutex critical: [
			                     self extraWorldList ].
		extraWorldsToDraw do: [ :world | world doOneCycle ].

		(self currentWorld isNotNil and: [
			 (extraWorldsToDraw includes: self currentWorld) not ]) ifTrue: [
			self currentWorld doOneCycle ] ] in WorldMorph class>>doOneCycle
FullBlockClosure(BlockClosure)>>ensure:
WorldState class>>doDrawCycleWith:
WorldMorph class>>doOneCycle
MorphicRenderLoop>>doOneCycle
MorphicRenderLoop>>doOneCycleWhile:
[ MorphicRenderLoop new doOneCycleWhile: [ true ] ] in MorphicUIManager>>spawnNewProcess
 - - - - - - - - - - - - - - -
			- - - - - - - - - - - - - - - - - -
[self value.
			"IMPORTANT: Do not step over next line of code. See method comments for details"
			Processor terminateRealActive] in FullBlockClosure(BlockClosure)>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
AssertionFailure: Project location does not seems to be a valid git repository.
13 November 2023 10:55:16.689071 pm

VM: Mac OS - arm64 - 1000 - CoInterpreter VMMaker-tonel.1 uuid: 902dd483-c0c4-0d00-86f2-0f880df24b96 Oct 23 2023
StackToRegisterMappingCogit VMMaker-tonel.1 uuid: 902dd483-c0c4-0d00-86f2-0f880df24b96 Oct 23 2023
v10.0.8 - Commit: b323c5fb - Date: 2023-10-20 16:02:07 -0400

Image: Pharo11.0.0 [Build information: Pharo-11.0.0+build.710.sha.ea28d8552cac85a7ce1e9c34ab1e7bd45f7b9910 (64 Bit)]

IceTipLocalRepositoryPanel(Object)>>assert:description:
	Receiver: an IceTipLocalRepositoryPanel
	Arguments and temporary variables: 
		aBlock: 	false
		aStringOrBlock: 	'Project location does not seems to be a valid git repository.'
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicGridAdapter)
		announcer: 	an Announcer
		owner: 	an IceTipRegisterRepositoryDialog
		adapter: 	a SpMorphicGridAdapter
		needRebuild: 	true
		eventHandler: 	nil
		application: 	a StPharoApplication
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ nil ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Untitled window' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpGridLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		decorations: 	nil
		projectLocationLabel: 	a SpLabelPresenter
		projectLocation: 	an IceTipDirectoryPresenter
		remoteLabel: 	nil
		remoteInputText: 	nil
		repository: 	nil


IceTipLocalRepositoryPanel>>validate
	Receiver: an IceTipLocalRepositoryPanel
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicGridAdapter)
		announcer: 	an Announcer
		owner: 	an IceTipRegisterRepositoryDialog
		adapter: 	a SpMorphicGridAdapter
		needRebuild: 	true
		eventHandler: 	nil
		application: 	a StPharoApplication
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ nil ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Untitled window' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpGridLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		decorations: 	nil
		projectLocationLabel: 	a SpLabelPresenter
		projectLocation: 	an IceTipDirectoryPresenter
		remoteLabel: 	nil
		remoteInputText: 	nil
		repository: 	nil


IceTipRegisterRepositoryDialog>>doAccept
	Receiver: an IceTipRegisterRepositoryDialog
	Arguments and temporary variables: 
		newRepository: 	nil
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicPanedAdapter a SpMorphicBoxAdapter)
		announcer: 	an Announcer
		owner: 	a SpDialogWindowPresenter
		adapter: 	a SpMorphicPanedAdapter
		needRebuild: 	true
		eventHandler: 	nil
		application: 	a StPharoApplication
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ nil ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Untitled window' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpPanedLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		decorations: 	nil
		typeList: 	a SpListPresenter
		type: 	an IceTipLocalRepositoryPanel
		contentLayout: 	a SpBoxLayout
		types: 	an OrderedCollection(an IceTipNewRepositoryPanel an IceTipLocalRepos[..]
		repository: 	nil
		acceptBlock: 	nil


[ 
	  self doAccept.
	  self closeWindow ] in IceTipRegisterRepositoryDialog(IceTipOptionDialog)>>accept
	Receiver: an IceTipRegisterRepositoryDialog
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicPanedAdapter a SpMorphicBoxAdapter)
		announcer: 	an Announcer
		owner: 	a SpDialogWindowPresenter
		adapter: 	a SpMorphicPanedAdapter
		needRebuild: 	true
		eventHandler: 	nil
		application: 	a StPharoApplication
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ nil ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Untitled window' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpPanedLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		decorations: 	nil
		typeList: 	a SpListPresenter
		type: 	an IceTipLocalRepositoryPanel
		contentLayout: 	a SpBoxLayout
		types: 	an OrderedCollection(an IceTipNewRepositoryPanel an IceTipLocalRepos[..]
		repository: 	nil
		acceptBlock: 	nil


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [ 
	  self doAccept.
	  self closeWindow ]
	Arguments and temporary variables: 
		exception: 	an ExceptionSet
		handlerAction: 	[ :e | 
			  e acceptError: (IceTipInteractiveErrorVisitor n[..]
	Receiver's instance variables: 
		outerContext: 	IceTipRegisterRepositoryDialog(IceTipOptionDialog)>>accept
		compiledBlock: 	a CompiledBlock: [ 
	  self doAccept.
	  self closeWindow ]
		numArgs: 	0
		receiver: 	an IceTipRegisterRepositoryDialog


IceTipRegisterRepositoryDialog(IceTipOptionDialog)>>accept
	Receiver: an IceTipRegisterRepositoryDialog
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicPanedAdapter a SpMorphicBoxAdapter)
		announcer: 	an Announcer
		owner: 	a SpDialogWindowPresenter
		adapter: 	a SpMorphicPanedAdapter
		needRebuild: 	true
		eventHandler: 	nil
		application: 	a StPharoApplication
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ nil ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Untitled window' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpPanedLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		decorations: 	nil
		typeList: 	a SpListPresenter
		type: 	an IceTipLocalRepositoryPanel
		contentLayout: 	a SpBoxLayout
		types: 	an OrderedCollection(an IceTipNewRepositoryPanel an IceTipLocalRepos[..]
		repository: 	nil
		acceptBlock: 	nil


[ :presenter | self accept ] in IceTipRegisterRepositoryDialog(IceTipOptionDialog)>>initializeDialogWindow:
	Receiver: an IceTipRegisterRepositoryDialog
	Arguments and temporary variables: 
		aWindowPresenter: 	a SpDialogWindowPresenter
		presenter: 	a SpDialogWindowPresenter
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicPanedAdapter a SpMorphicBoxAdapter)
		announcer: 	an Announcer
		owner: 	a SpDialogWindowPresenter
		adapter: 	a SpMorphicPanedAdapter
		needRebuild: 	true
		eventHandler: 	nil
		application: 	a StPharoApplication
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ nil ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Untitled window' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpPanedLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		decorations: 	nil
		typeList: 	a SpListPresenter
		type: 	an IceTipLocalRepositoryPanel
		contentLayout: 	a SpBoxLayout
		types: 	an OrderedCollection(an IceTipNewRepositoryPanel an IceTipLocalRepos[..]
		repository: 	nil
		acceptBlock: 	nil


FullBlockClosure(BlockClosure)>>cull:
	Receiver: [ :presenter | self accept ]
	Arguments and temporary variables: 
		anArg: 	a SpDialogWindowPresenter
	Receiver's instance variables: 
		outerContext: 	IceTipRegisterRepositoryDialog(IceTipOptionDialog)>>initializ[..]
		compiledBlock: 	a CompiledBlock: [ :presenter | self accept ]
		numArgs: 	1
		receiver: 	an IceTipRegisterRepositoryDialog


[ aBlock cull: self ] in SpDialogWindowPresenter>>addButton:do:
	Receiver: a SpDialogWindowPresenter
	Arguments and temporary variables: 
		aString: 	'Ok'
		aBlock: 	[ :presenter | self accept ]
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicDialogWindowAdapter a SpDialogWind[..]
		announcer: 	an Announcer
		owner: 	nil
		adapter: 	a SpMorphicDialogWindowAdapter
		needRebuild: 	true
		eventHandler: 	nil
		application: 	a StPharoApplication
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ nil ]
		windowIcon: 	an ObservableValueHolder[ Form(16x16x32) ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ true ]
		titleHolder: 	an ObservableValueHolder[ 'Import from existing clone' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ nil ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		borderWidth: 	an ObservableValueHolder[ nil ]
		borderColor: 	an ObservableValueHolder[ nil ]
		dragEnabled: 	an ObservableValueHolder[ false ]
		dropEnabled: 	an ObservableValueHolder[ false ]
		color: 	an ObservableValueHolder[ nil ]
		help: 	an ObservableValueHolder[ nil ]
		enabled: 	an ObservableValueHolder[ true ]
		wantsDrop: 	an ObservableValueHolder[ [ :transfer | self dropEnabled ] ]
		acceptDrop: 	an ObservableValueHolder[ [ :transfer | ] ]
		deferredActions: 	nil
		presenter: 	an ObservableValueHolder[ an IceTipRegisterRepositoryDialog ]
		initialPosition: 	an ObservableValueHolder[ nil ]
		initialExtent: 	an ObservableValueHolder[ (700@300) ]
		menu: 	an ObservableValueHolder[ nil ]
		centered: 	an ObservableValueHolder[ false ]
		isClosed: 	an ObservableValueHolder[ false ]
		toolbar: 	an ObservableValueHolder[ nil ]
		statusbar: 	an ObservableValueHolder[ nil ]
		window: 	an ObservableValueHolder[ a SpDialogWindowMorph(8821248) named: Imp[..]
		decorations: 	an ObservableValueHolder[ true ]
		resizable: 	an ObservableValueHolder[ true ]
		buttons: 	an OrderedCollection(a SpButtonPresenter a SpButtonPresenter)
		okAction: 	[ 
		cancelled := false.
		self close ]
		cancelAction: 	[ 
		cancelled := true.
		self close ]
		cancelled: 	true
		defaultButton: 	nil


SpButtonPresenter>>performAction
	Receiver: a SpButtonPresenter
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicButtonAdapter)
		announcer: 	an Announcer
		owner: 	a SpButtonBarPresenter
		adapter: 	a SpMorphicButtonAdapter
		needRebuild: 	true
		eventHandler: 	nil
		application: 	nil
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ nil ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Button' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpAbstractWidgetLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		borderWidth: 	an ObservableValueHolder[ nil ]
		borderColor: 	an ObservableValueHolder[ nil ]
		dragEnabled: 	an ObservableValueHolder[ false ]
		dropEnabled: 	an ObservableValueHolder[ false ]
		color: 	an ObservableValueHolder[ nil ]
		help: 	an ObservableValueHolder[ nil ]
		enabled: 	an ObservableValueHolder[ true ]
		wantsDrop: 	an ObservableValueHolder[ [ :transfer | self dropEnabled ] ]
		acceptDrop: 	an ObservableValueHolder[ [ :transfer | ] ]
		deferredActions: 	nil
		icon: 	an ObservableValueHolder[ nil ]
		label: 	an ObservableValueHolder[ 'Ok' ]
		action: 	an ObservableValueHolder[ [ aBlock cull: self ] ]
		actionPerformed: 	an ObservableValueHolder[ nil ]
		askBeforeChanging: 	an ObservableValueHolder[ false ]
		font: 	an ObservableValueHolder[ nil ]
		shortcut: 	an ObservableValueHolder[ nil ]
		state: 	an ObservableValueHolder[ false ]
		contextMenu: 	an ObservableValueHolder[ nil ]


SpMorphicButtonAdapter>>action
	Receiver: a SpMorphicButtonAdapter
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpPluggableButtonMorph(570548736))
		announcer: 	nil
		model: 	a SpButtonPresenter
		widget: 	a SpPluggableButtonMorph(570548736)
		selector: 	nil
		owner: 	a SpButtonPresenter
		unsubscribed: 	false
		subMenuWidget: 	nil
		styleName: 	nil


SpPluggableButtonMorph(PluggableButtonMorph)>>performAction:
	Receiver: a SpPluggableButtonMorph(570548736)
	Arguments and temporary variables: 
		event: 	[(1125@582) mouseUp 24634808 nil]
	Receiver's instance variables: 
		bounds: 	(1072.0@571.0) corner: (1172.0@601.0)
		owner: 	a PanelMorph(698386432)
		submorphs: 	an Array(an AlignmentMorph(710766848))
		fullBounds: 	nil
		color: 	(Color r: 0.9012707722385142 g: 0.9012707722385142 b: 0.901270772238[..]
		extension: 	a MorphExtension (284495872) [eventHandler = a MorphicEventHandl[..]
		borderWidth: 	1
		borderColor: 	#simple
		model: 	a SpMorphicButtonAdapter
		label: 	'Ok'
		icon: 	nil
		getIconSelector: 	nil
		getStateSelector: 	#state
		actionSelector: 	#action
		font: 	nil
		getLabelSelector: 	#label
		getMenuSelector: 	#menu:
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	#enabled
		getFontSelector: 	#font
		labelMorph: 	a LabelMorph(480891136)'Ok'
		iconMorph: 	nil
		iconPosition: 	#left
		lastState: 	false
		backgroundColor: 	nil


[:m |
		(m containsPoint: evt cursorPoint) ifTrue: [m enabled ifTrue: [ m performAction: evt ]]] in SpPluggableButtonMorph(PluggableButtonMorph)>>mouseUp:
	Receiver: a SpPluggableButtonMorph(570548736)
	Arguments and temporary variables: 
		evt: 	[(1125@582) mouseUp 24634808 nil]
		all: 	an Array(a SpPluggableButtonMorph(150047232) a SpPluggableButtonMorph([..]
		m: 	a SpPluggableButtonMorph(570548736)
	Receiver's instance variables: 
		bounds: 	(1072.0@571.0) corner: (1172.0@601.0)
		owner: 	a PanelMorph(698386432)
		submorphs: 	an Array(an AlignmentMorph(710766848))
		fullBounds: 	nil
		color: 	(Color r: 0.9012707722385142 g: 0.9012707722385142 b: 0.901270772238[..]
		extension: 	a MorphExtension (284495872) [eventHandler = a MorphicEventHandl[..]
		borderWidth: 	1
		borderColor: 	#simple
		model: 	a SpMorphicButtonAdapter
		label: 	'Ok'
		icon: 	nil
		getIconSelector: 	nil
		getStateSelector: 	#state
		actionSelector: 	#action
		font: 	nil
		getLabelSelector: 	#label
		getMenuSelector: 	#menu:
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	#enabled
		getFontSelector: 	#font
		labelMorph: 	a LabelMorph(480891136)'Ok'
		iconMorph: 	nil
		iconPosition: 	#left
		lastState: 	false
		backgroundColor: 	nil


Array(SequenceableCollection)>>do:
	Receiver: an Array(a SpPluggableButtonMorph(150047232) a SpPluggableButtonMorph(570548736))
	Arguments and temporary variables: 
		aBlock: 	[:m |
		(m containsPoint: evt cursorPoint) ifTrue: [m enabled ifTru[..]
		index: 	2
	Receiver's instance variables: 
an Array(a SpPluggableButtonMorph(150047232) a SpPluggableButtonMorph(570548736))

SpPluggableButtonMorph(PluggableButtonMorph)>>mouseUp:
	Receiver: a SpPluggableButtonMorph(570548736)
	Arguments and temporary variables: 
		evt: 	[(1125@582) mouseUp 24634808 nil]
		all: 	an Array(a SpPluggableButtonMorph(150047232) a SpPluggableButtonMorph([..]
	Receiver's instance variables: 
		bounds: 	(1072.0@571.0) corner: (1172.0@601.0)
		owner: 	a PanelMorph(698386432)
		submorphs: 	an Array(an AlignmentMorph(710766848))
		fullBounds: 	nil
		color: 	(Color r: 0.9012707722385142 g: 0.9012707722385142 b: 0.901270772238[..]
		extension: 	a MorphExtension (284495872) [eventHandler = a MorphicEventHandl[..]
		borderWidth: 	1
		borderColor: 	#simple
		model: 	a SpMorphicButtonAdapter
		label: 	'Ok'
		icon: 	nil
		getIconSelector: 	nil
		getStateSelector: 	#state
		actionSelector: 	#action
		font: 	nil
		getLabelSelector: 	#label
		getMenuSelector: 	#menu:
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	#enabled
		getFontSelector: 	#font
		labelMorph: 	a LabelMorph(480891136)'Ok'
		iconMorph: 	nil
		iconPosition: 	#left
		lastState: 	false
		backgroundColor: 	nil


SpPluggableButtonMorph(Morph)>>handleMouseUp:
	Receiver: a SpPluggableButtonMorph(570548736)
	Arguments and temporary variables: 
		anEvent: 	[(1125@582) mouseUp 24634808 nil]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(1072.0@571.0) corner: (1172.0@601.0)
		owner: 	a PanelMorph(698386432)
		submorphs: 	an Array(an AlignmentMorph(710766848))
		fullBounds: 	nil
		color: 	(Color r: 0.9012707722385142 g: 0.9012707722385142 b: 0.901270772238[..]
		extension: 	a MorphExtension (284495872) [eventHandler = a MorphicEventHandl[..]
		borderWidth: 	1
		borderColor: 	#simple
		model: 	a SpMorphicButtonAdapter
		label: 	'Ok'
		icon: 	nil
		getIconSelector: 	nil
		getStateSelector: 	#state
		actionSelector: 	#action
		font: 	nil
		getLabelSelector: 	#label
		getMenuSelector: 	#menu:
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	#enabled
		getFontSelector: 	#font
		labelMorph: 	a LabelMorph(480891136)'Ok'
		iconMorph: 	nil
		iconPosition: 	#left
		lastState: 	false
		backgroundColor: 	nil


MouseButtonEvent>>sentTo:
	Receiver: [(1125@582) mouseUp 24634808 nil]
	Arguments and temporary variables: 
		anObject: 	a SpPluggableButtonMorph(570548736)
	Receiver's instance variables: 
		timeStamp: 	24634808
		source: 	a HandMorph(337424384)
		windowIndex: 	nil
		type: 	#mouseUp
		buttons: 	0
		position: 	(1125@582)
		handler: 	nil
		wasHandled: 	true
		whichButton: 	4


SpPluggableButtonMorph(Morph)>>handleEvent:
	Receiver: a SpPluggableButtonMorph(570548736)
	Arguments and temporary variables: 
		anEvent: 	[(1125@582) mouseUp 24634808 nil]
	Receiver's instance variables: 
		bounds: 	(1072.0@571.0) corner: (1172.0@601.0)
		owner: 	a PanelMorph(698386432)
		submorphs: 	an Array(an AlignmentMorph(710766848))
		fullBounds: 	nil
		color: 	(Color r: 0.9012707722385142 g: 0.9012707722385142 b: 0.901270772238[..]
		extension: 	a MorphExtension (284495872) [eventHandler = a MorphicEventHandl[..]
		borderWidth: 	1
		borderColor: 	#simple
		model: 	a SpMorphicButtonAdapter
		label: 	'Ok'
		icon: 	nil
		getIconSelector: 	nil
		getStateSelector: 	#state
		actionSelector: 	#action
		font: 	nil
		getLabelSelector: 	#label
		getMenuSelector: 	#menu:
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	#enabled
		getFontSelector: 	#font
		labelMorph: 	a LabelMorph(480891136)'Ok'
		iconMorph: 	nil
		iconPosition: 	#left
		lastState: 	false
		backgroundColor: 	nil


SpPluggableButtonMorph(Morph)>>handleFocusEvent:
	Receiver: a SpPluggableButtonMorph(570548736)
	Arguments and temporary variables: 
		anEvent: 	[(1125@582) mouseUp 24634808 nil]
	Receiver's instance variables: 
		bounds: 	(1072.0@571.0) corner: (1172.0@601.0)
		owner: 	a PanelMorph(698386432)
		submorphs: 	an Array(an AlignmentMorph(710766848))
		fullBounds: 	nil
		color: 	(Color r: 0.9012707722385142 g: 0.9012707722385142 b: 0.901270772238[..]
		extension: 	a MorphExtension (284495872) [eventHandler = a MorphicEventHandl[..]
		borderWidth: 	1
		borderColor: 	#simple
		model: 	a SpMorphicButtonAdapter
		label: 	'Ok'
		icon: 	nil
		getIconSelector: 	nil
		getStateSelector: 	#state
		actionSelector: 	#action
		font: 	nil
		getLabelSelector: 	#label
		getMenuSelector: 	#menu:
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	#enabled
		getFontSelector: 	#font
		labelMorph: 	a LabelMorph(480891136)'Ok'
		iconMorph: 	nil
		iconPosition: 	#left
		lastState: 	false
		backgroundColor: 	nil


[
		result := focusHolder handleFocusEvent: transformedEvent.
	] in HandMorph>>sendFocusEvent:to:clear:
	Receiver: a HandMorph(337424384)
	Arguments and temporary variables: 
		anEvent: 	[(1125@582) mouseUp 24634808 nil]
		focusHolder: 	a SpPluggableButtonMorph(570548736)
		aBlock: 	[self mouseFocus: nil]
		w: 	a WorldMorph(341720576) [world]
		transformedEvent: 	[(1125@582) mouseUp 24634808 nil]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(1125@582.0) corner: (1141@598.0)
		owner: 	a WorldMorph(341720576) [world]
		submorphs: 	#()
		fullBounds: 	(1125@582.0) corner: (1141@598.0)
		color: 	Color blue
		extension: 	a MorphExtension (370611968)
		mouseFocus: 	nil
		keyboardFocus: 	a SpPluggableButtonMorph(570548736)
		eventListeners: 	nil
		mouseListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(1125@582) mouseUp 24634808 nil]
		targetOffset: 	(53.0@11.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 0 0 0 0 0 nil nil)
		captureBlock: 	nil
		recentModifiers: 	0
		pendingEventQueue: 	WaitfreeQueue with 0 items
		supressNextKeyPress: 	false


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
		result := focusHolder handleFocusEvent: transformedEvent.
	]
	Arguments and temporary variables: 
		exception: 	Error
		handlerAction: 	[ :ex |
			ActiveWorld := priorWorld.
			ex pass ]
	Receiver's instance variables: 
		outerContext: 	HandMorph>>sendFocusEvent:to:clear:
		compiledBlock: 	a CompiledBlock: [
		result := focusHolder handleFocusEvent:[..]
		numArgs: 	0
		receiver: 	a HandMorph(337424384)


WorldMorph>>becomeActiveDuring:
	Receiver: a WorldMorph(341720576) [world]
	Arguments and temporary variables: 
		aBlock: 	[
		result := focusHolder handleFocusEvent: transformedEvent.
	]
		priorWorld: 	a WorldMorph(341720576) [world]
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1728@1080)
		owner: 	nil
		submorphs: 	an Array(a MenubarMorph(112886016) a TaskbarMorph(279458560) a S[..]
		fullBounds: 	(0@0) corner: (1728@1080)
		color: 	(Color r: 0.9403714565004888 g: 0.9403714565004888 b: 0.940371456500[..]
		extension: 	a MorphExtension (1012946432) [other:  (dragEnabled -> true) (dr[..]
		borderWidth: 	0
		borderColor: 	(Color r: 0.8611925708699902 g: 1.0 b: 0.7223851417399805 alph[..]
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil


HandMorph>>sendFocusEvent:to:clear:
	Receiver: a HandMorph(337424384)
	Arguments and temporary variables: 
		result: 	nil
		anEvent: 	[(1125@582) mouseUp 24634808 nil]
		focusHolder: 	a SpPluggableButtonMorph(570548736)
		aBlock: 	[self mouseFocus: nil]
		w: 	a WorldMorph(341720576) [world]
		transformedEvent: 	[(1125@582) mouseUp 24634808 nil]
	Receiver's instance variables: 
		bounds: 	(1125@582.0) corner: (1141@598.0)
		owner: 	a WorldMorph(341720576) [world]
		submorphs: 	#()
		fullBounds: 	(1125@582.0) corner: (1141@598.0)
		color: 	Color blue
		extension: 	a MorphExtension (370611968)
		mouseFocus: 	nil
		keyboardFocus: 	a SpPluggableButtonMorph(570548736)
		eventListeners: 	nil
		mouseListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(1125@582) mouseUp 24634808 nil]
		targetOffset: 	(53.0@11.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 0 0 0 0 0 nil nil)
		captureBlock: 	nil
		recentModifiers: 	0
		pendingEventQueue: 	WaitfreeQueue with 0 items
		supressNextKeyPress: 	false


HandMorph>>sendEvent:focus:clear:
	Receiver: a HandMorph(337424384)
	Arguments and temporary variables: 
		anEvent: 	[(1125@582) mouseUp 24634808 nil]
		focusHolder: 	a SpPluggableButtonMorph(570548736)
		aBlock: 	[self mouseFocus: nil]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(1125@582.0) corner: (1141@598.0)
		owner: 	a WorldMorph(341720576) [world]
		submorphs: 	#()
		fullBounds: 	(1125@582.0) corner: (1141@598.0)
		color: 	Color blue
		extension: 	a MorphExtension (370611968)
		mouseFocus: 	nil
		keyboardFocus: 	a SpPluggableButtonMorph(570548736)
		eventListeners: 	nil
		mouseListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(1125@582) mouseUp 24634808 nil]
		targetOffset: 	(53.0@11.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 0 0 0 0 0 nil nil)
		captureBlock: 	nil
		recentModifiers: 	0
		pendingEventQueue: 	WaitfreeQueue with 0 items
		supressNextKeyPress: 	false


HandMorph>>sendMouseEvent:
	Receiver: a HandMorph(337424384)
	Arguments and temporary variables: 
		anEvent: 	[(1125@582) mouseUp 24634808 nil]
	Receiver's instance variables: 
		bounds: 	(1125@582.0) corner: (1141@598.0)
		owner: 	a WorldMorph(341720576) [world]
		submorphs: 	#()
		fullBounds: 	(1125@582.0) corner: (1141@598.0)
		color: 	Color blue
		extension: 	a MorphExtension (370611968)
		mouseFocus: 	nil
		keyboardFocus: 	a SpPluggableButtonMorph(570548736)
		eventListeners: 	nil
		mouseListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(1125@582) mouseUp 24634808 nil]
		targetOffset: 	(53.0@11.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 0 0 0 0 0 nil nil)
		captureBlock: 	nil
		recentModifiers: 	0
		pendingEventQueue: 	WaitfreeQueue with 0 items
		supressNextKeyPress: 	false


HandMorph>>handleEvent:
	Receiver: a HandMorph(337424384)
	Arguments and temporary variables: 
		anEvent: 	[(1125@582) mouseUp 24634808 nil]
		evt: 	[(1125@582) mouseUp 24634808 nil]
	Receiver's instance variables: 
		bounds: 	(1125@582.0) corner: (1141@598.0)
		owner: 	a WorldMorph(341720576) [world]
		submorphs: 	#()
		fullBounds: 	(1125@582.0) corner: (1141@598.0)
		color: 	Color blue
		extension: 	a MorphExtension (370611968)
		mouseFocus: 	nil
		keyboardFocus: 	a SpPluggableButtonMorph(570548736)
		eventListeners: 	nil
		mouseListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(1125@582) mouseUp 24634808 nil]
		targetOffset: 	(53.0@11.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 0 0 0 0 0 nil nil)
		captureBlock: 	nil
		recentModifiers: 	0
		pendingEventQueue: 	WaitfreeQueue with 0 items
		supressNextKeyPress: 	false


[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil ]) ifTrue: [
			morphicWorld activeHand handleEvent: anEvent
		]
	] in OSWindowMorphicEventHandler>>dispatchMorphicEvent:
	Receiver: an OSWindowMorphicEventHandler
	Arguments and temporary variables: 
		anEvent: 	[(1125@582) mouseUp 24634808 nil]
	Receiver's instance variables: 
		morphicWorld: 	a WorldMorph(341720576) [world]


WorldState>>runStepMethodsIn:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(341720576) [world]
		queue: 	WaitfreeQueue with 0 items
		nextInQueue: 	[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNo[..]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(337424384))
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap()
		lastStepTime: 	24632782
		lastStepMessage: 	nil
		alarms: 	a Heap()
		lastAlarmTime: 	24634794
		activeHand: 	a HandMorph(337424384)
		currentCursor: 	((CursorWithMask
	extent: (16@16)
	depth: 1
	fromArray: #(
	[..]
		worldRenderer: 	an OSWorldRenderer
		realWindowExtent: 	(1728@1080)
		deferredUIMessages: 	WaitfreeQueue with 0 items


WorldMorph>>runStepMethods
	Receiver: a WorldMorph(341720576) [world]
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1728@1080)
		owner: 	nil
		submorphs: 	an Array(a MenubarMorph(112886016) a TaskbarMorph(279458560) a S[..]
		fullBounds: 	(0@0) corner: (1728@1080)
		color: 	(Color r: 0.9403714565004888 g: 0.9403714565004888 b: 0.940371456500[..]
		extension: 	a MorphExtension (1012946432) [other:  (dragEnabled -> true) (dr[..]
		borderWidth: 	0
		borderColor: 	(Color r: 0.8611925708699902 g: 1.0 b: 0.7223851417399805 alph[..]
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil


WorldState>>doOneCycleFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(341720576) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(337424384))
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap()
		lastStepTime: 	24632782
		lastStepMessage: 	nil
		alarms: 	a Heap()
		lastAlarmTime: 	24634794
		activeHand: 	a HandMorph(337424384)
		currentCursor: 	((CursorWithMask
	extent: (16@16)
	depth: 1
	fromArray: #(
	[..]
		worldRenderer: 	an OSWorldRenderer
		realWindowExtent: 	(1728@1080)
		deferredUIMessages: 	WaitfreeQueue with 0 items


WorldMorph>>doOneCycleNow
	Receiver: a WorldMorph(341720576) [world]
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1728@1080)
		owner: 	nil
		submorphs: 	an Array(a MenubarMorph(112886016) a TaskbarMorph(279458560) a S[..]
		fullBounds: 	(0@0) corner: (1728@1080)
		color: 	(Color r: 0.9403714565004888 g: 0.9403714565004888 b: 0.940371456500[..]
		extension: 	a MorphExtension (1012946432) [other:  (dragEnabled -> true) (dr[..]
		borderWidth: 	0
		borderColor: 	(Color r: 0.8611925708699902 g: 1.0 b: 0.7223851417399805 alph[..]
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil


WorldMorph>>doOneCycle
	Receiver: a WorldMorph(341720576) [world]
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1728@1080)
		owner: 	nil
		submorphs: 	an Array(a MenubarMorph(112886016) a TaskbarMorph(279458560) a S[..]
		fullBounds: 	(0@0) corner: (1728@1080)
		color: 	(Color r: 0.9403714565004888 g: 0.9403714565004888 b: 0.940371456500[..]
		extension: 	a MorphExtension (1012946432) [other:  (dragEnabled -> true) (dr[..]
		borderWidth: 	0
		borderColor: 	(Color r: 0.8611925708699902 g: 1.0 b: 0.7223851417399805 alph[..]
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil


[
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMutex critical: [
			                     self extraWorldList ].
		extraWorldsToDraw do: [ :world | world doOneCycle ].

		(self currentWorld isNotNil and: [
			 (extraWorldsToDraw includes: self currentWorld) not ]) ifTrue: [
			self currentWorld doOneCycle ] ] in WorldMorph class>>doOneCycle
	Receiver: WorldMorph
	Arguments and temporary variables: 
		extraWorldsToDraw: 	#()
	Receiver's instance variables: 
		superclass: 	PasteUpMorph
		methodDict: 	a MethodDictionary(#acceptDroppingMorph:event:->WorldMorph>>#ac[..]
		format: 	65547
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		commentSourcePointer: 	nil
		subclasses: 	{AthensWorldMorph. OSWindowWorldMorph}
		name: 	#WorldMorph
		classPool: 	a Dictionary(#AllowDropFiles->nil #CursorOwnerWorld->a WorldMorp[..]
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Morphic-Core-Worlds'
		announcer: 	nil
		displayScaleFactor: 	1


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMutex critical: [
			  [..]
	Arguments and temporary variables: 
		aBlock: 	[
		self doInterCycleWait
	]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	WorldMorph class>>doOneCycle
		compiledBlock: 	a CompiledBlock: [
		| extraWorldsToDraw |
		extraWorldsToDr[..]
		numArgs: 	0
		receiver: 	WorldMorph


WorldState class>>doDrawCycleWith:
	Receiver: WorldState
	Arguments and temporary variables: 
		aBlock: 	[
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMute[..]
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary(#activeHand->WorldState>>#activeHand #active[..]
		format: 	65548
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		commentSourcePointer: 	nil
		subclasses: 	{AthensWorldState}
		name: 	#WorldState
		classPool: 	a Dictionary(#CanSurrenderToOS->nil #DebugShowDamage->false #Des[..]
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Morphic-Core-Worlds'


WorldMorph class>>doOneCycle
	Receiver: WorldMorph
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		superclass: 	PasteUpMorph
		methodDict: 	a MethodDictionary(#acceptDroppingMorph:event:->WorldMorph>>#ac[..]
		format: 	65547
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		commentSourcePointer: 	nil
		subclasses: 	{AthensWorldMorph. OSWindowWorldMorph}
		name: 	#WorldMorph
		classPool: 	a Dictionary(#AllowDropFiles->nil #CursorOwnerWorld->a WorldMorp[..]
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Morphic-Core-Worlds'
		announcer: 	nil
		displayScaleFactor: 	1


MorphicRenderLoop>>doOneCycle
	Receiver: a MorphicRenderLoop
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
a MorphicRenderLoop

MorphicRenderLoop>>doOneCycleWhile:
	Receiver: a MorphicRenderLoop
	Arguments and temporary variables: 
		aBlock: 	[ true ]
	Receiver's instance variables: 
a MorphicRenderLoop

[ MorphicRenderLoop new doOneCycleWhile: [ true ] ] in MorphicUIManager>>spawnNewProcess
	Receiver: a MorphicUIManager
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		activeTranscript: 	nil



--- The full stack ---
IceTipLocalRepositoryPanel(Object)>>assert:description:
IceTipLocalRepositoryPanel>>validate
IceTipRegisterRepositoryDialog>>doAccept
[ 
	  self doAccept.
	  self closeWindow ] in IceTipRegisterRepositoryDialog(IceTipOptionDialog)>>accept
FullBlockClosure(BlockClosure)>>on:do:
IceTipRegisterRepositoryDialog(IceTipOptionDialog)>>accept
[ :presenter | self accept ] in IceTipRegisterRepositoryDialog(IceTipOptionDialog)>>initializeDialogWindow:
FullBlockClosure(BlockClosure)>>cull:
[ aBlock cull: self ] in SpDialogWindowPresenter>>addButton:do:
SpButtonPresenter>>performAction
SpMorphicButtonAdapter>>action
SpPluggableButtonMorph(PluggableButtonMorph)>>performAction:
[:m |
		(m containsPoint: evt cursorPoint) ifTrue: [m enabled ifTrue: [ m performAction: evt ]]] in SpPluggableButtonMorph(PluggableButtonMorph)>>mouseUp:
Array(SequenceableCollection)>>do:
SpPluggableButtonMorph(PluggableButtonMorph)>>mouseUp:
SpPluggableButtonMorph(Morph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
SpPluggableButtonMorph(Morph)>>handleEvent:
SpPluggableButtonMorph(Morph)>>handleFocusEvent:
[
		result := focusHolder handleFocusEvent: transformedEvent.
	] in HandMorph>>sendFocusEvent:to:clear:
FullBlockClosure(BlockClosure)>>on:do:
WorldMorph>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil ]) ifTrue: [
			morphicWorld activeHand handleEvent: anEvent
		]
	] in OSWindowMorphicEventHandler>>dispatchMorphicEvent:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycleNow
WorldMorph>>doOneCycle
[
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMutex critical: [
			                     self extraWorldList ].
		extraWorldsToDraw do: [ :world | world doOneCycle ].

		(self currentWorld isNotNil and: [
			 (extraWorldsToDraw includes: self currentWorld) not ]) ifTrue: [
			self currentWorld doOneCycle ] ] in WorldMorph class>>doOneCycle
FullBlockClosure(BlockClosure)>>ensure:
WorldState class>>doDrawCycleWith:
WorldMorph class>>doOneCycle
MorphicRenderLoop>>doOneCycle
MorphicRenderLoop>>doOneCycleWhile:
[ MorphicRenderLoop new doOneCycleWhile: [ true ] ] in MorphicUIManager>>spawnNewProcess
 - - - - - - - - - - - - - - -
			- - - - - - - - - - - - - - - - - -
[self value.
			"IMPORTANT: Do not step over next line of code. See method comments for details"
			Processor terminateRealActive] in FullBlockClosure(BlockClosure)>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
AssertionFailure: Project location does not seems to be a valid git repository.
13 November 2023 10:55:16.714825 pm

VM: Mac OS - arm64 - 1000 - CoInterpreter VMMaker-tonel.1 uuid: 902dd483-c0c4-0d00-86f2-0f880df24b96 Oct 23 2023
StackToRegisterMappingCogit VMMaker-tonel.1 uuid: 902dd483-c0c4-0d00-86f2-0f880df24b96 Oct 23 2023
v10.0.8 - Commit: b323c5fb - Date: 2023-10-20 16:02:07 -0400

Image: Pharo11.0.0 [Build information: Pharo-11.0.0+build.710.sha.ea28d8552cac85a7ce1e9c34ab1e7bd45f7b9910 (64 Bit)]

IceTipLocalRepositoryPanel(Object)>>assert:description:
	Receiver: an IceTipLocalRepositoryPanel
	Arguments and temporary variables: 
		aBlock: 	false
		aStringOrBlock: 	'Project location does not seems to be a valid git repository.'
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicGridAdapter)
		announcer: 	an Announcer
		owner: 	an IceTipRegisterRepositoryDialog
		adapter: 	a SpMorphicGridAdapter
		needRebuild: 	true
		eventHandler: 	nil
		application: 	a StPharoApplication
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ nil ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Untitled window' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpGridLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		decorations: 	nil
		projectLocationLabel: 	a SpLabelPresenter
		projectLocation: 	an IceTipDirectoryPresenter
		remoteLabel: 	nil
		remoteInputText: 	nil
		repository: 	nil


IceTipLocalRepositoryPanel>>validate
	Receiver: an IceTipLocalRepositoryPanel
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicGridAdapter)
		announcer: 	an Announcer
		owner: 	an IceTipRegisterRepositoryDialog
		adapter: 	a SpMorphicGridAdapter
		needRebuild: 	true
		eventHandler: 	nil
		application: 	a StPharoApplication
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ nil ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Untitled window' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpGridLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		decorations: 	nil
		projectLocationLabel: 	a SpLabelPresenter
		projectLocation: 	an IceTipDirectoryPresenter
		remoteLabel: 	nil
		remoteInputText: 	nil
		repository: 	nil


IceTipRegisterRepositoryDialog>>doAccept
	Receiver: an IceTipRegisterRepositoryDialog
	Arguments and temporary variables: 
		newRepository: 	nil
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicPanedAdapter a SpMorphicBoxAdapter)
		announcer: 	an Announcer
		owner: 	a SpDialogWindowPresenter
		adapter: 	a SpMorphicPanedAdapter
		needRebuild: 	true
		eventHandler: 	nil
		application: 	a StPharoApplication
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ nil ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Untitled window' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpPanedLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		decorations: 	nil
		typeList: 	a SpListPresenter
		type: 	an IceTipLocalRepositoryPanel
		contentLayout: 	a SpBoxLayout
		types: 	an OrderedCollection(an IceTipNewRepositoryPanel an IceTipLocalRepos[..]
		repository: 	nil
		acceptBlock: 	nil


[ 
	  self doAccept.
	  self closeWindow ] in IceTipRegisterRepositoryDialog(IceTipOptionDialog)>>accept
	Receiver: an IceTipRegisterRepositoryDialog
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicPanedAdapter a SpMorphicBoxAdapter)
		announcer: 	an Announcer
		owner: 	a SpDialogWindowPresenter
		adapter: 	a SpMorphicPanedAdapter
		needRebuild: 	true
		eventHandler: 	nil
		application: 	a StPharoApplication
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ nil ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Untitled window' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpPanedLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		decorations: 	nil
		typeList: 	a SpListPresenter
		type: 	an IceTipLocalRepositoryPanel
		contentLayout: 	a SpBoxLayout
		types: 	an OrderedCollection(an IceTipNewRepositoryPanel an IceTipLocalRepos[..]
		repository: 	nil
		acceptBlock: 	nil


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [ 
	  self doAccept.
	  self closeWindow ]
	Arguments and temporary variables: 
		exception: 	an ExceptionSet
		handlerAction: 	[ :e | 
			  e acceptError: (IceTipInteractiveErrorVisitor n[..]
	Receiver's instance variables: 
		outerContext: 	IceTipRegisterRepositoryDialog(IceTipOptionDialog)>>accept
		compiledBlock: 	a CompiledBlock: [ 
	  self doAccept.
	  self closeWindow ]
		numArgs: 	0
		receiver: 	an IceTipRegisterRepositoryDialog


IceTipRegisterRepositoryDialog(IceTipOptionDialog)>>accept
	Receiver: an IceTipRegisterRepositoryDialog
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicPanedAdapter a SpMorphicBoxAdapter)
		announcer: 	an Announcer
		owner: 	a SpDialogWindowPresenter
		adapter: 	a SpMorphicPanedAdapter
		needRebuild: 	true
		eventHandler: 	nil
		application: 	a StPharoApplication
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ nil ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Untitled window' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpPanedLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		decorations: 	nil
		typeList: 	a SpListPresenter
		type: 	an IceTipLocalRepositoryPanel
		contentLayout: 	a SpBoxLayout
		types: 	an OrderedCollection(an IceTipNewRepositoryPanel an IceTipLocalRepos[..]
		repository: 	nil
		acceptBlock: 	nil


[ :presenter | self accept ] in IceTipRegisterRepositoryDialog(IceTipOptionDialog)>>initializeDialogWindow:
	Receiver: an IceTipRegisterRepositoryDialog
	Arguments and temporary variables: 
		aWindowPresenter: 	a SpDialogWindowPresenter
		presenter: 	a SpDialogWindowPresenter
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicPanedAdapter a SpMorphicBoxAdapter)
		announcer: 	an Announcer
		owner: 	a SpDialogWindowPresenter
		adapter: 	a SpMorphicPanedAdapter
		needRebuild: 	true
		eventHandler: 	nil
		application: 	a StPharoApplication
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ nil ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Untitled window' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpPanedLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		decorations: 	nil
		typeList: 	a SpListPresenter
		type: 	an IceTipLocalRepositoryPanel
		contentLayout: 	a SpBoxLayout
		types: 	an OrderedCollection(an IceTipNewRepositoryPanel an IceTipLocalRepos[..]
		repository: 	nil
		acceptBlock: 	nil


FullBlockClosure(BlockClosure)>>cull:
	Receiver: [ :presenter | self accept ]
	Arguments and temporary variables: 
		anArg: 	a SpDialogWindowPresenter
	Receiver's instance variables: 
		outerContext: 	IceTipRegisterRepositoryDialog(IceTipOptionDialog)>>initializ[..]
		compiledBlock: 	a CompiledBlock: [ :presenter | self accept ]
		numArgs: 	1
		receiver: 	an IceTipRegisterRepositoryDialog


[ aBlock cull: self ] in SpDialogWindowPresenter>>addButton:do:
	Receiver: a SpDialogWindowPresenter
	Arguments and temporary variables: 
		aString: 	'Ok'
		aBlock: 	[ :presenter | self accept ]
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicDialogWindowAdapter a SpDialogWind[..]
		announcer: 	an Announcer
		owner: 	nil
		adapter: 	a SpMorphicDialogWindowAdapter
		needRebuild: 	true
		eventHandler: 	nil
		application: 	a StPharoApplication
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ nil ]
		windowIcon: 	an ObservableValueHolder[ Form(16x16x32) ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ true ]
		titleHolder: 	an ObservableValueHolder[ 'Import from existing clone' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ nil ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		borderWidth: 	an ObservableValueHolder[ nil ]
		borderColor: 	an ObservableValueHolder[ nil ]
		dragEnabled: 	an ObservableValueHolder[ false ]
		dropEnabled: 	an ObservableValueHolder[ false ]
		color: 	an ObservableValueHolder[ nil ]
		help: 	an ObservableValueHolder[ nil ]
		enabled: 	an ObservableValueHolder[ true ]
		wantsDrop: 	an ObservableValueHolder[ [ :transfer | self dropEnabled ] ]
		acceptDrop: 	an ObservableValueHolder[ [ :transfer | ] ]
		deferredActions: 	nil
		presenter: 	an ObservableValueHolder[ an IceTipRegisterRepositoryDialog ]
		initialPosition: 	an ObservableValueHolder[ nil ]
		initialExtent: 	an ObservableValueHolder[ (700@300) ]
		menu: 	an ObservableValueHolder[ nil ]
		centered: 	an ObservableValueHolder[ false ]
		isClosed: 	an ObservableValueHolder[ false ]
		toolbar: 	an ObservableValueHolder[ nil ]
		statusbar: 	an ObservableValueHolder[ nil ]
		window: 	an ObservableValueHolder[ a SpDialogWindowMorph(8821248) named: Imp[..]
		decorations: 	an ObservableValueHolder[ true ]
		resizable: 	an ObservableValueHolder[ true ]
		buttons: 	an OrderedCollection(a SpButtonPresenter a SpButtonPresenter)
		okAction: 	[ 
		cancelled := false.
		self close ]
		cancelAction: 	[ 
		cancelled := true.
		self close ]
		cancelled: 	true
		defaultButton: 	nil


SpButtonPresenter>>performAction
	Receiver: a SpButtonPresenter
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicButtonAdapter)
		announcer: 	an Announcer
		owner: 	a SpButtonBarPresenter
		adapter: 	a SpMorphicButtonAdapter
		needRebuild: 	true
		eventHandler: 	nil
		application: 	nil
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ nil ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Button' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpAbstractWidgetLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		borderWidth: 	an ObservableValueHolder[ nil ]
		borderColor: 	an ObservableValueHolder[ nil ]
		dragEnabled: 	an ObservableValueHolder[ false ]
		dropEnabled: 	an ObservableValueHolder[ false ]
		color: 	an ObservableValueHolder[ nil ]
		help: 	an ObservableValueHolder[ nil ]
		enabled: 	an ObservableValueHolder[ true ]
		wantsDrop: 	an ObservableValueHolder[ [ :transfer | self dropEnabled ] ]
		acceptDrop: 	an ObservableValueHolder[ [ :transfer | ] ]
		deferredActions: 	nil
		icon: 	an ObservableValueHolder[ nil ]
		label: 	an ObservableValueHolder[ 'Ok' ]
		action: 	an ObservableValueHolder[ [ aBlock cull: self ] ]
		actionPerformed: 	an ObservableValueHolder[ nil ]
		askBeforeChanging: 	an ObservableValueHolder[ false ]
		font: 	an ObservableValueHolder[ nil ]
		shortcut: 	an ObservableValueHolder[ nil ]
		state: 	an ObservableValueHolder[ false ]
		contextMenu: 	an ObservableValueHolder[ nil ]


SpMorphicButtonAdapter>>action
	Receiver: a SpMorphicButtonAdapter
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpPluggableButtonMorph(570548736))
		announcer: 	nil
		model: 	a SpButtonPresenter
		widget: 	a SpPluggableButtonMorph(570548736)
		selector: 	nil
		owner: 	a SpButtonPresenter
		unsubscribed: 	false
		subMenuWidget: 	nil
		styleName: 	nil


SpPluggableButtonMorph(PluggableButtonMorph)>>performAction:
	Receiver: a SpPluggableButtonMorph(570548736)
	Arguments and temporary variables: 
		event: 	[(1125@582) mouseUp 24634808 nil]
	Receiver's instance variables: 
		bounds: 	(1072.0@571.0) corner: (1172.0@601.0)
		owner: 	a PanelMorph(698386432)
		submorphs: 	an Array(an AlignmentMorph(710766848))
		fullBounds: 	nil
		color: 	(Color r: 0.9012707722385142 g: 0.9012707722385142 b: 0.901270772238[..]
		extension: 	a MorphExtension (284495872) [eventHandler = a MorphicEventHandl[..]
		borderWidth: 	1
		borderColor: 	#simple
		model: 	a SpMorphicButtonAdapter
		label: 	'Ok'
		icon: 	nil
		getIconSelector: 	nil
		getStateSelector: 	#state
		actionSelector: 	#action
		font: 	nil
		getLabelSelector: 	#label
		getMenuSelector: 	#menu:
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	#enabled
		getFontSelector: 	#font
		labelMorph: 	a LabelMorph(480891136)'Ok'
		iconMorph: 	nil
		iconPosition: 	#left
		lastState: 	false
		backgroundColor: 	nil


[:m |
		(m containsPoint: evt cursorPoint) ifTrue: [m enabled ifTrue: [ m performAction: evt ]]] in SpPluggableButtonMorph(PluggableButtonMorph)>>mouseUp:
	Receiver: a SpPluggableButtonMorph(570548736)
	Arguments and temporary variables: 
		evt: 	[(1125@582) mouseUp 24634808 nil]
		all: 	an Array(a SpPluggableButtonMorph(150047232) a SpPluggableButtonMorph([..]
		m: 	a SpPluggableButtonMorph(570548736)
	Receiver's instance variables: 
		bounds: 	(1072.0@571.0) corner: (1172.0@601.0)
		owner: 	a PanelMorph(698386432)
		submorphs: 	an Array(an AlignmentMorph(710766848))
		fullBounds: 	nil
		color: 	(Color r: 0.9012707722385142 g: 0.9012707722385142 b: 0.901270772238[..]
		extension: 	a MorphExtension (284495872) [eventHandler = a MorphicEventHandl[..]
		borderWidth: 	1
		borderColor: 	#simple
		model: 	a SpMorphicButtonAdapter
		label: 	'Ok'
		icon: 	nil
		getIconSelector: 	nil
		getStateSelector: 	#state
		actionSelector: 	#action
		font: 	nil
		getLabelSelector: 	#label
		getMenuSelector: 	#menu:
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	#enabled
		getFontSelector: 	#font
		labelMorph: 	a LabelMorph(480891136)'Ok'
		iconMorph: 	nil
		iconPosition: 	#left
		lastState: 	false
		backgroundColor: 	nil


Array(SequenceableCollection)>>do:
	Receiver: an Array(a SpPluggableButtonMorph(150047232) a SpPluggableButtonMorph(570548736))
	Arguments and temporary variables: 
		aBlock: 	[:m |
		(m containsPoint: evt cursorPoint) ifTrue: [m enabled ifTru[..]
		index: 	2
	Receiver's instance variables: 
an Array(a SpPluggableButtonMorph(150047232) a SpPluggableButtonMorph(570548736))

SpPluggableButtonMorph(PluggableButtonMorph)>>mouseUp:
	Receiver: a SpPluggableButtonMorph(570548736)
	Arguments and temporary variables: 
		evt: 	[(1125@582) mouseUp 24634808 nil]
		all: 	an Array(a SpPluggableButtonMorph(150047232) a SpPluggableButtonMorph([..]
	Receiver's instance variables: 
		bounds: 	(1072.0@571.0) corner: (1172.0@601.0)
		owner: 	a PanelMorph(698386432)
		submorphs: 	an Array(an AlignmentMorph(710766848))
		fullBounds: 	nil
		color: 	(Color r: 0.9012707722385142 g: 0.9012707722385142 b: 0.901270772238[..]
		extension: 	a MorphExtension (284495872) [eventHandler = a MorphicEventHandl[..]
		borderWidth: 	1
		borderColor: 	#simple
		model: 	a SpMorphicButtonAdapter
		label: 	'Ok'
		icon: 	nil
		getIconSelector: 	nil
		getStateSelector: 	#state
		actionSelector: 	#action
		font: 	nil
		getLabelSelector: 	#label
		getMenuSelector: 	#menu:
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	#enabled
		getFontSelector: 	#font
		labelMorph: 	a LabelMorph(480891136)'Ok'
		iconMorph: 	nil
		iconPosition: 	#left
		lastState: 	false
		backgroundColor: 	nil


SpPluggableButtonMorph(Morph)>>handleMouseUp:
	Receiver: a SpPluggableButtonMorph(570548736)
	Arguments and temporary variables: 
		anEvent: 	[(1125@582) mouseUp 24634808 nil]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(1072.0@571.0) corner: (1172.0@601.0)
		owner: 	a PanelMorph(698386432)
		submorphs: 	an Array(an AlignmentMorph(710766848))
		fullBounds: 	nil
		color: 	(Color r: 0.9012707722385142 g: 0.9012707722385142 b: 0.901270772238[..]
		extension: 	a MorphExtension (284495872) [eventHandler = a MorphicEventHandl[..]
		borderWidth: 	1
		borderColor: 	#simple
		model: 	a SpMorphicButtonAdapter
		label: 	'Ok'
		icon: 	nil
		getIconSelector: 	nil
		getStateSelector: 	#state
		actionSelector: 	#action
		font: 	nil
		getLabelSelector: 	#label
		getMenuSelector: 	#menu:
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	#enabled
		getFontSelector: 	#font
		labelMorph: 	a LabelMorph(480891136)'Ok'
		iconMorph: 	nil
		iconPosition: 	#left
		lastState: 	false
		backgroundColor: 	nil


MouseButtonEvent>>sentTo:
	Receiver: [(1125@582) mouseUp 24634808 nil]
	Arguments and temporary variables: 
		anObject: 	a SpPluggableButtonMorph(570548736)
	Receiver's instance variables: 
		timeStamp: 	24634808
		source: 	a HandMorph(337424384)
		windowIndex: 	nil
		type: 	#mouseUp
		buttons: 	0
		position: 	(1125@582)
		handler: 	nil
		wasHandled: 	true
		whichButton: 	4


SpPluggableButtonMorph(Morph)>>handleEvent:
	Receiver: a SpPluggableButtonMorph(570548736)
	Arguments and temporary variables: 
		anEvent: 	[(1125@582) mouseUp 24634808 nil]
	Receiver's instance variables: 
		bounds: 	(1072.0@571.0) corner: (1172.0@601.0)
		owner: 	a PanelMorph(698386432)
		submorphs: 	an Array(an AlignmentMorph(710766848))
		fullBounds: 	nil
		color: 	(Color r: 0.9012707722385142 g: 0.9012707722385142 b: 0.901270772238[..]
		extension: 	a MorphExtension (284495872) [eventHandler = a MorphicEventHandl[..]
		borderWidth: 	1
		borderColor: 	#simple
		model: 	a SpMorphicButtonAdapter
		label: 	'Ok'
		icon: 	nil
		getIconSelector: 	nil
		getStateSelector: 	#state
		actionSelector: 	#action
		font: 	nil
		getLabelSelector: 	#label
		getMenuSelector: 	#menu:
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	#enabled
		getFontSelector: 	#font
		labelMorph: 	a LabelMorph(480891136)'Ok'
		iconMorph: 	nil
		iconPosition: 	#left
		lastState: 	false
		backgroundColor: 	nil


SpPluggableButtonMorph(Morph)>>handleFocusEvent:
	Receiver: a SpPluggableButtonMorph(570548736)
	Arguments and temporary variables: 
		anEvent: 	[(1125@582) mouseUp 24634808 nil]
	Receiver's instance variables: 
		bounds: 	(1072.0@571.0) corner: (1172.0@601.0)
		owner: 	a PanelMorph(698386432)
		submorphs: 	an Array(an AlignmentMorph(710766848))
		fullBounds: 	nil
		color: 	(Color r: 0.9012707722385142 g: 0.9012707722385142 b: 0.901270772238[..]
		extension: 	a MorphExtension (284495872) [eventHandler = a MorphicEventHandl[..]
		borderWidth: 	1
		borderColor: 	#simple
		model: 	a SpMorphicButtonAdapter
		label: 	'Ok'
		icon: 	nil
		getIconSelector: 	nil
		getStateSelector: 	#state
		actionSelector: 	#action
		font: 	nil
		getLabelSelector: 	#label
		getMenuSelector: 	#menu:
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	#enabled
		getFontSelector: 	#font
		labelMorph: 	a LabelMorph(480891136)'Ok'
		iconMorph: 	nil
		iconPosition: 	#left
		lastState: 	false
		backgroundColor: 	nil


[
		result := focusHolder handleFocusEvent: transformedEvent.
	] in HandMorph>>sendFocusEvent:to:clear:
	Receiver: a HandMorph(337424384)
	Arguments and temporary variables: 
		anEvent: 	[(1125@582) mouseUp 24634808 nil]
		focusHolder: 	a SpPluggableButtonMorph(570548736)
		aBlock: 	[self mouseFocus: nil]
		w: 	a WorldMorph(341720576) [world]
		transformedEvent: 	[(1125@582) mouseUp 24634808 nil]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(1125@582.0) corner: (1141@598.0)
		owner: 	a WorldMorph(341720576) [world]
		submorphs: 	#()
		fullBounds: 	(1125@582.0) corner: (1141@598.0)
		color: 	Color blue
		extension: 	a MorphExtension (370611968)
		mouseFocus: 	nil
		keyboardFocus: 	a SpPluggableButtonMorph(570548736)
		eventListeners: 	nil
		mouseListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(1125@582) mouseUp 24634808 nil]
		targetOffset: 	(53.0@11.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 0 0 0 0 0 nil nil)
		captureBlock: 	nil
		recentModifiers: 	0
		pendingEventQueue: 	WaitfreeQueue with 0 items
		supressNextKeyPress: 	false


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
		result := focusHolder handleFocusEvent: transformedEvent.
	]
	Arguments and temporary variables: 
		exception: 	Error
		handlerAction: 	[ :ex |
			ActiveWorld := priorWorld.
			ex pass ]
	Receiver's instance variables: 
		outerContext: 	HandMorph>>sendFocusEvent:to:clear:
		compiledBlock: 	a CompiledBlock: [
		result := focusHolder handleFocusEvent:[..]
		numArgs: 	0
		receiver: 	a HandMorph(337424384)


WorldMorph>>becomeActiveDuring:
	Receiver: a WorldMorph(341720576) [world]
	Arguments and temporary variables: 
		aBlock: 	[
		result := focusHolder handleFocusEvent: transformedEvent.
	]
		priorWorld: 	a WorldMorph(341720576) [world]
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1728@1080)
		owner: 	nil
		submorphs: 	an Array(a MenubarMorph(112886016) a TaskbarMorph(279458560) a S[..]
		fullBounds: 	(0@0) corner: (1728@1080)
		color: 	(Color r: 0.9403714565004888 g: 0.9403714565004888 b: 0.940371456500[..]
		extension: 	a MorphExtension (1012946432) [other:  (dragEnabled -> true) (dr[..]
		borderWidth: 	0
		borderColor: 	(Color r: 0.8611925708699902 g: 1.0 b: 0.7223851417399805 alph[..]
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil


HandMorph>>sendFocusEvent:to:clear:
	Receiver: a HandMorph(337424384)
	Arguments and temporary variables: 
		result: 	nil
		anEvent: 	[(1125@582) mouseUp 24634808 nil]
		focusHolder: 	a SpPluggableButtonMorph(570548736)
		aBlock: 	[self mouseFocus: nil]
		w: 	a WorldMorph(341720576) [world]
		transformedEvent: 	[(1125@582) mouseUp 24634808 nil]
	Receiver's instance variables: 
		bounds: 	(1125@582.0) corner: (1141@598.0)
		owner: 	a WorldMorph(341720576) [world]
		submorphs: 	#()
		fullBounds: 	(1125@582.0) corner: (1141@598.0)
		color: 	Color blue
		extension: 	a MorphExtension (370611968)
		mouseFocus: 	nil
		keyboardFocus: 	a SpPluggableButtonMorph(570548736)
		eventListeners: 	nil
		mouseListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(1125@582) mouseUp 24634808 nil]
		targetOffset: 	(53.0@11.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 0 0 0 0 0 nil nil)
		captureBlock: 	nil
		recentModifiers: 	0
		pendingEventQueue: 	WaitfreeQueue with 0 items
		supressNextKeyPress: 	false


HandMorph>>sendEvent:focus:clear:
	Receiver: a HandMorph(337424384)
	Arguments and temporary variables: 
		anEvent: 	[(1125@582) mouseUp 24634808 nil]
		focusHolder: 	a SpPluggableButtonMorph(570548736)
		aBlock: 	[self mouseFocus: nil]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(1125@582.0) corner: (1141@598.0)
		owner: 	a WorldMorph(341720576) [world]
		submorphs: 	#()
		fullBounds: 	(1125@582.0) corner: (1141@598.0)
		color: 	Color blue
		extension: 	a MorphExtension (370611968)
		mouseFocus: 	nil
		keyboardFocus: 	a SpPluggableButtonMorph(570548736)
		eventListeners: 	nil
		mouseListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(1125@582) mouseUp 24634808 nil]
		targetOffset: 	(53.0@11.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 0 0 0 0 0 nil nil)
		captureBlock: 	nil
		recentModifiers: 	0
		pendingEventQueue: 	WaitfreeQueue with 0 items
		supressNextKeyPress: 	false


HandMorph>>sendMouseEvent:
	Receiver: a HandMorph(337424384)
	Arguments and temporary variables: 
		anEvent: 	[(1125@582) mouseUp 24634808 nil]
	Receiver's instance variables: 
		bounds: 	(1125@582.0) corner: (1141@598.0)
		owner: 	a WorldMorph(341720576) [world]
		submorphs: 	#()
		fullBounds: 	(1125@582.0) corner: (1141@598.0)
		color: 	Color blue
		extension: 	a MorphExtension (370611968)
		mouseFocus: 	nil
		keyboardFocus: 	a SpPluggableButtonMorph(570548736)
		eventListeners: 	nil
		mouseListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(1125@582) mouseUp 24634808 nil]
		targetOffset: 	(53.0@11.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 0 0 0 0 0 nil nil)
		captureBlock: 	nil
		recentModifiers: 	0
		pendingEventQueue: 	WaitfreeQueue with 0 items
		supressNextKeyPress: 	false


HandMorph>>handleEvent:
	Receiver: a HandMorph(337424384)
	Arguments and temporary variables: 
		anEvent: 	[(1125@582) mouseUp 24634808 nil]
		evt: 	[(1125@582) mouseUp 24634808 nil]
	Receiver's instance variables: 
		bounds: 	(1125@582.0) corner: (1141@598.0)
		owner: 	a WorldMorph(341720576) [world]
		submorphs: 	#()
		fullBounds: 	(1125@582.0) corner: (1141@598.0)
		color: 	Color blue
		extension: 	a MorphExtension (370611968)
		mouseFocus: 	nil
		keyboardFocus: 	a SpPluggableButtonMorph(570548736)
		eventListeners: 	nil
		mouseListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(1125@582) mouseUp 24634808 nil]
		targetOffset: 	(53.0@11.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 0 0 0 0 0 nil nil)
		captureBlock: 	nil
		recentModifiers: 	0
		pendingEventQueue: 	WaitfreeQueue with 0 items
		supressNextKeyPress: 	false


[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil ]) ifTrue: [
			morphicWorld activeHand handleEvent: anEvent
		]
	] in OSWindowMorphicEventHandler>>dispatchMorphicEvent:
	Receiver: an OSWindowMorphicEventHandler
	Arguments and temporary variables: 
		anEvent: 	[(1125@582) mouseUp 24634808 nil]
	Receiver's instance variables: 
		morphicWorld: 	a WorldMorph(341720576) [world]


WorldState>>runStepMethodsIn:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(341720576) [world]
		queue: 	WaitfreeQueue with 0 items
		nextInQueue: 	[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNo[..]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(337424384))
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap()
		lastStepTime: 	24632782
		lastStepMessage: 	nil
		alarms: 	a Heap()
		lastAlarmTime: 	24634794
		activeHand: 	a HandMorph(337424384)
		currentCursor: 	((CursorWithMask
	extent: (16@16)
	depth: 1
	fromArray: #(
	[..]
		worldRenderer: 	an OSWorldRenderer
		realWindowExtent: 	(1728@1080)
		deferredUIMessages: 	WaitfreeQueue with 0 items


WorldMorph>>runStepMethods
	Receiver: a WorldMorph(341720576) [world]
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1728@1080)
		owner: 	nil
		submorphs: 	an Array(a MenubarMorph(112886016) a TaskbarMorph(279458560) a S[..]
		fullBounds: 	(0@0) corner: (1728@1080)
		color: 	(Color r: 0.9403714565004888 g: 0.9403714565004888 b: 0.940371456500[..]
		extension: 	a MorphExtension (1012946432) [other:  (dragEnabled -> true) (dr[..]
		borderWidth: 	0
		borderColor: 	(Color r: 0.8611925708699902 g: 1.0 b: 0.7223851417399805 alph[..]
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil


WorldState>>doOneCycleFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(341720576) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(337424384))
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap()
		lastStepTime: 	24632782
		lastStepMessage: 	nil
		alarms: 	a Heap()
		lastAlarmTime: 	24634794
		activeHand: 	a HandMorph(337424384)
		currentCursor: 	((CursorWithMask
	extent: (16@16)
	depth: 1
	fromArray: #(
	[..]
		worldRenderer: 	an OSWorldRenderer
		realWindowExtent: 	(1728@1080)
		deferredUIMessages: 	WaitfreeQueue with 0 items


WorldMorph>>doOneCycleNow
	Receiver: a WorldMorph(341720576) [world]
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1728@1080)
		owner: 	nil
		submorphs: 	an Array(a MenubarMorph(112886016) a TaskbarMorph(279458560) a S[..]
		fullBounds: 	(0@0) corner: (1728@1080)
		color: 	(Color r: 0.9403714565004888 g: 0.9403714565004888 b: 0.940371456500[..]
		extension: 	a MorphExtension (1012946432) [other:  (dragEnabled -> true) (dr[..]
		borderWidth: 	0
		borderColor: 	(Color r: 0.8611925708699902 g: 1.0 b: 0.7223851417399805 alph[..]
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil


WorldMorph>>doOneCycle
	Receiver: a WorldMorph(341720576) [world]
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1728@1080)
		owner: 	nil
		submorphs: 	an Array(a MenubarMorph(112886016) a TaskbarMorph(279458560) a S[..]
		fullBounds: 	(0@0) corner: (1728@1080)
		color: 	(Color r: 0.9403714565004888 g: 0.9403714565004888 b: 0.940371456500[..]
		extension: 	a MorphExtension (1012946432) [other:  (dragEnabled -> true) (dr[..]
		borderWidth: 	0
		borderColor: 	(Color r: 0.8611925708699902 g: 1.0 b: 0.7223851417399805 alph[..]
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil


[
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMutex critical: [
			                     self extraWorldList ].
		extraWorldsToDraw do: [ :world | world doOneCycle ].

		(self currentWorld isNotNil and: [
			 (extraWorldsToDraw includes: self currentWorld) not ]) ifTrue: [
			self currentWorld doOneCycle ] ] in WorldMorph class>>doOneCycle
	Receiver: WorldMorph
	Arguments and temporary variables: 
		extraWorldsToDraw: 	#()
	Receiver's instance variables: 
		superclass: 	PasteUpMorph
		methodDict: 	a MethodDictionary(#acceptDroppingMorph:event:->WorldMorph>>#ac[..]
		format: 	65547
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		commentSourcePointer: 	nil
		subclasses: 	{AthensWorldMorph. OSWindowWorldMorph}
		name: 	#WorldMorph
		classPool: 	a Dictionary(#AllowDropFiles->nil #CursorOwnerWorld->a WorldMorp[..]
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Morphic-Core-Worlds'
		announcer: 	nil
		displayScaleFactor: 	1


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMutex critical: [
			  [..]
	Arguments and temporary variables: 
		aBlock: 	[
		self doInterCycleWait
	]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	WorldMorph class>>doOneCycle
		compiledBlock: 	a CompiledBlock: [
		| extraWorldsToDraw |
		extraWorldsToDr[..]
		numArgs: 	0
		receiver: 	WorldMorph


WorldState class>>doDrawCycleWith:
	Receiver: WorldState
	Arguments and temporary variables: 
		aBlock: 	[
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMute[..]
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary(#activeHand->WorldState>>#activeHand #active[..]
		format: 	65548
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		commentSourcePointer: 	nil
		subclasses: 	{AthensWorldState}
		name: 	#WorldState
		classPool: 	a Dictionary(#CanSurrenderToOS->nil #DebugShowDamage->false #Des[..]
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Morphic-Core-Worlds'


WorldMorph class>>doOneCycle
	Receiver: WorldMorph
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		superclass: 	PasteUpMorph
		methodDict: 	a MethodDictionary(#acceptDroppingMorph:event:->WorldMorph>>#ac[..]
		format: 	65547
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		commentSourcePointer: 	nil
		subclasses: 	{AthensWorldMorph. OSWindowWorldMorph}
		name: 	#WorldMorph
		classPool: 	a Dictionary(#AllowDropFiles->nil #CursorOwnerWorld->a WorldMorp[..]
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Morphic-Core-Worlds'
		announcer: 	nil
		displayScaleFactor: 	1


MorphicRenderLoop>>doOneCycle
	Receiver: a MorphicRenderLoop
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
a MorphicRenderLoop

MorphicRenderLoop>>doOneCycleWhile:
	Receiver: a MorphicRenderLoop
	Arguments and temporary variables: 
		aBlock: 	[ true ]
	Receiver's instance variables: 
a MorphicRenderLoop

[ MorphicRenderLoop new doOneCycleWhile: [ true ] ] in MorphicUIManager>>spawnNewProcess
	Receiver: a MorphicUIManager
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		activeTranscript: 	nil



--- The full stack ---
IceTipLocalRepositoryPanel(Object)>>assert:description:
IceTipLocalRepositoryPanel>>validate
IceTipRegisterRepositoryDialog>>doAccept
[ 
	  self doAccept.
	  self closeWindow ] in IceTipRegisterRepositoryDialog(IceTipOptionDialog)>>accept
FullBlockClosure(BlockClosure)>>on:do:
IceTipRegisterRepositoryDialog(IceTipOptionDialog)>>accept
[ :presenter | self accept ] in IceTipRegisterRepositoryDialog(IceTipOptionDialog)>>initializeDialogWindow:
FullBlockClosure(BlockClosure)>>cull:
[ aBlock cull: self ] in SpDialogWindowPresenter>>addButton:do:
SpButtonPresenter>>performAction
SpMorphicButtonAdapter>>action
SpPluggableButtonMorph(PluggableButtonMorph)>>performAction:
[:m |
		(m containsPoint: evt cursorPoint) ifTrue: [m enabled ifTrue: [ m performAction: evt ]]] in SpPluggableButtonMorph(PluggableButtonMorph)>>mouseUp:
Array(SequenceableCollection)>>do:
SpPluggableButtonMorph(PluggableButtonMorph)>>mouseUp:
SpPluggableButtonMorph(Morph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
SpPluggableButtonMorph(Morph)>>handleEvent:
SpPluggableButtonMorph(Morph)>>handleFocusEvent:
[
		result := focusHolder handleFocusEvent: transformedEvent.
	] in HandMorph>>sendFocusEvent:to:clear:
FullBlockClosure(BlockClosure)>>on:do:
WorldMorph>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil ]) ifTrue: [
			morphicWorld activeHand handleEvent: anEvent
		]
	] in OSWindowMorphicEventHandler>>dispatchMorphicEvent:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycleNow
WorldMorph>>doOneCycle
[
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMutex critical: [
			                     self extraWorldList ].
		extraWorldsToDraw do: [ :world | world doOneCycle ].

		(self currentWorld isNotNil and: [
			 (extraWorldsToDraw includes: self currentWorld) not ]) ifTrue: [
			self currentWorld doOneCycle ] ] in WorldMorph class>>doOneCycle
FullBlockClosure(BlockClosure)>>ensure:
WorldState class>>doDrawCycleWith:
WorldMorph class>>doOneCycle
MorphicRenderLoop>>doOneCycle
MorphicRenderLoop>>doOneCycleWhile:
[ MorphicRenderLoop new doOneCycleWhile: [ true ] ] in MorphicUIManager>>spawnNewProcess
 - - - - - - - - - - - - - - -
			- - - - - - - - - - - - - - - - - -
[self value.
			"IMPORTANT: Do not step over next line of code. See method comments for details"
			Processor terminateRealActive] in FullBlockClosure(BlockClosure)>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
IceError: Branch main already exists
13 November 2023 11:36:20.789088 pm

VM: Mac OS - arm64 - 1000 - CoInterpreter VMMaker-tonel.1 uuid: 902dd483-c0c4-0d00-86f2-0f880df24b96 Oct 23 2023
StackToRegisterMappingCogit VMMaker-tonel.1 uuid: 902dd483-c0c4-0d00-86f2-0f880df24b96 Oct 23 2023
v10.0.8 - Commit: b323c5fb - Date: 2023-10-20 16:02:07 -0400

Image: Pharo11.0.0 [Build information: Pharo-11.0.0+build.710.sha.ea28d8552cac85a7ce1e9c34ab1e7bd45f7b9910 (64 Bit)]

[ :branch | IceError signal: ('Branch {1} already exists' format: { self shortName }) ] in IceGitRemoteBranch(IceRemoteBranch)>>checkout:
	Receiver: IceGitRemoteBranch(origin/main)
	Arguments and temporary variables: 
		aCheckoutStrategy: 	an IceCheckoutAlreadyLoadedPackages
		localBranch: 	nil
		branch: 	IceGitLocalBranch(main)
	Receiver's instance variables: 
		repository: 	IceLibgitRepository(pp-rep2533)
		name: 	'refs/remotes/origin/main'


[ presentBlock value: (self basicNewBranchNamed: found name) ] in [ | found |
		found := self repositoryHandle lookupLocalBranch: aString ifAbsent: [ nil ].
		^ found ifNil: absentBlock ifNotNil: [ presentBlock value: (self basicNewBranchNamed: found name) ] ] in IceLibgitRepository>>branchNamed:ifPresent:ifAbsent:
	Receiver: IceLibgitRepository(pp-rep2533)
	Arguments and temporary variables: 
		aString: 	'main'
		presentBlock: 	[ :branch | IceError signal: ('Branch {1} already exists' for[..]
		absentBlock: 	[ self ]
		found: 	a LGitReference ('refs/heads/main')
	Receiver's instance variables: 
		name: 	'pp-rep2533'
		workingCopy: 	an IceWorkingCopy
		index: 	an IceGitIndex
		commitsInPackageCache: 	nil
		location: 	File @ /Users/ryanperez/Documents/GitHub/pp-rep2533
		commitCache: 	a LRUCache(#3 3/30 [ 1 ] 100%)
		handle: 	a LGitRepository (/Users/ryanperez/Documents/GitHub/pp-rep2533)


FullBlockClosure(BlockClosure)>>cull:
	Receiver: [ presentBlock value: (self basicNewBranchNamed: found name) ]
	Arguments and temporary variables: 
		anArg: 	a LGitReference ('refs/heads/main')
	Receiver's instance variables: 
		outerContext: 	[ | found |
		found := self repositoryHandle lookupLocalBranc[..]
		compiledBlock: 	a CompiledBlock: [ presentBlock value: (self basicNewBranchN[..]
		numArgs: 	0
		receiver: 	IceLibgitRepository(pp-rep2533)


LGitReference(ProtoObject)>>ifNil:ifNotNil:
	Receiver: a LGitReference ('refs/heads/main')
	Arguments and temporary variables: 
		nilBlock: 	[ self ]
		ifNotNilBlock: 	[ presentBlock value: (self basicNewBranchNamed: found name) ]
	Receiver's instance variables: 
		handle: 	@ 16r600002605E50
		repository: 	a LGitRepository (/Users/ryanperez/Documents/GitHub/pp-rep2533)


[ | found |
		found := self repositoryHandle lookupLocalBranch: aString ifAbsent: [ nil ].
		^ found ifNil: absentBlock ifNotNil: [ presentBlock value: (self basicNewBranchNamed: found name) ] ] in IceLibgitRepository>>branchNamed:ifPresent:ifAbsent:
	Receiver: IceLibgitRepository(pp-rep2533)
	Arguments and temporary variables: 
		aString: 	'main'
		presentBlock: 	[ :branch | IceError signal: ('Branch {1} already exists' for[..]
		absentBlock: 	[ self ]
		found: 	a LGitReference ('refs/heads/main')
	Receiver's instance variables: 
		name: 	'pp-rep2533'
		workingCopy: 	an IceWorkingCopy
		index: 	an IceGitIndex
		commitsInPackageCache: 	nil
		location: 	File @ /Users/ryanperez/Documents/GitHub/pp-rep2533
		commitCache: 	a LRUCache(#3 3/30 [ 1 ] 100%)
		handle: 	a LGitRepository (/Users/ryanperez/Documents/GitHub/pp-rep2533)


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [ | found |
		found := self repositoryHandle lookupLocalBranch: aString ifAbsent: [ ni[..]
	Arguments and temporary variables: 
		exception: 	LGitCallReturnHandler
		handlerAction: 	[ :error | error acceptError: (IceLibgitErrorVisitor onConte[..]
	Receiver's instance variables: 
		outerContext: 	IceLibgitRepository>>branchNamed:ifPresent:ifAbsent:
		compiledBlock: 	a CompiledBlock: [ | found |
		found := self repositoryHandl[..]
		numArgs: 	0
		receiver: 	IceLibgitRepository(pp-rep2533)


IceLibgitRepository>>handleLibgitError:
	Receiver: IceLibgitRepository(pp-rep2533)
	Arguments and temporary variables: 
		aBlock: 	[ | found |
		found := self repositoryHandle lookupLocalBranch: aSt[..]
	Receiver's instance variables: 
		name: 	'pp-rep2533'
		workingCopy: 	an IceWorkingCopy
		index: 	an IceGitIndex
		commitsInPackageCache: 	nil
		location: 	File @ /Users/ryanperez/Documents/GitHub/pp-rep2533
		commitCache: 	a LRUCache(#3 3/30 [ 1 ] 100%)
		handle: 	a LGitRepository (/Users/ryanperez/Documents/GitHub/pp-rep2533)


IceLibgitRepository>>branchNamed:ifPresent:ifAbsent:
	Receiver: IceLibgitRepository(pp-rep2533)
	Arguments and temporary variables: 
		aString: 	'main'
		presentBlock: 	[ :branch | IceError signal: ('Branch {1} already exists' for[..]
		absentBlock: 	[ self ]
	Receiver's instance variables: 
		name: 	'pp-rep2533'
		workingCopy: 	an IceWorkingCopy
		index: 	an IceGitIndex
		commitsInPackageCache: 	nil
		location: 	File @ /Users/ryanperez/Documents/GitHub/pp-rep2533
		commitCache: 	a LRUCache(#3 3/30 [ 1 ] 100%)
		handle: 	a LGitRepository (/Users/ryanperez/Documents/GitHub/pp-rep2533)


IceLibgitRepository(IceRepository)>>branchNamed:ifPresent:
	Receiver: IceLibgitRepository(pp-rep2533)
	Arguments and temporary variables: 
		aString: 	'main'
		aBlockClosure: 	[ :branch | IceError signal: ('Branch {1} already exists' fo[..]
	Receiver's instance variables: 
		name: 	'pp-rep2533'
		workingCopy: 	an IceWorkingCopy
		index: 	an IceGitIndex
		commitsInPackageCache: 	nil
		location: 	File @ /Users/ryanperez/Documents/GitHub/pp-rep2533
		commitCache: 	a LRUCache(#3 3/30 [ 1 ] 100%)
		handle: 	a LGitRepository (/Users/ryanperez/Documents/GitHub/pp-rep2533)


IceGitRemoteBranch(IceRemoteBranch)>>checkout:
	Receiver: IceGitRemoteBranch(origin/main)
	Arguments and temporary variables: 
		aCheckoutStrategy: 	an IceCheckoutAlreadyLoadedPackages
		localBranch: 	nil
	Receiver's instance variables: 
		repository: 	IceLibgitRepository(pp-rep2533)
		name: 	'refs/remotes/origin/main'


IceTipCheckoutModel>>checkout
	Receiver: an IceTipCheckoutModel
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		commitish: 	an IceTipBranchModel[origin/main]
		diffModel: 	an IceTipCommitDiffModel
		checkoutStrategy: 	an IceCheckoutAlreadyLoadedPackages
		checkoutStrategies: 	an OrderedCollection(an IceCheckoutAlreadyLoadedPackage[..]


[ self checkout ] in IceTipCheckoutModel>>newCheckoutAction
	Receiver: an IceTipCheckoutModel
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		commitish: 	an IceTipBranchModel[origin/main]
		diffModel: 	an IceTipCommitDiffModel
		checkoutStrategy: 	an IceCheckoutAlreadyLoadedPackages
		checkoutStrategies: 	an OrderedCollection(an IceCheckoutAlreadyLoadedPackage[..]


FullBlockClosure(BlockClosure)>>cull:
	Receiver: [ self checkout ]
	Arguments and temporary variables: 
		anArg: 	an IceTipCheckoutPreviewBrowser
	Receiver's instance variables: 
		outerContext: 	IceTipCheckoutModel>>newCheckoutAction
		compiledBlock: 	a CompiledBlock: [ self checkout ]
		numArgs: 	0
		receiver: 	an IceTipCheckoutModel


[ result := actionBlock cull: self context ] in IceTipStandardAction>>basicExecute
	Receiver: an IceTipStandardAction
	Arguments and temporary variables: 
		result: 	nil
	Receiver's instance variables: 
		context: 	an IceTipCheckoutPreviewBrowser
		repository: 	IceLibgitRepository(pp-rep2533)
		successBlock: 	[ self closeWindow ]
		message: 	'Checking out origin/main from pp-rep2533'
		successAnnounceBlock: 	[ IceRepositoryModified for: self repository ]
		actionBlock: 	[ self checkout ]


[:bar | bar label: aString. aBlock value] in MorphicUIManager(UIManager)>>informUser:during:
	Receiver: a MorphicUIManager
	Arguments and temporary variables: 
		aString: 	'Checking out origin/main from pp-rep2533'
		aBlock: 	[ result := actionBlock cull: self context ]
		bar: 	a Job
	Receiver's instance variables: 
		activeTranscript: 	nil


[:bar | aBlock value: bar] in MorphicUIManager>>informUserDuring:
	Receiver: a MorphicUIManager
	Arguments and temporary variables: 
		aBlock: 	[:bar | bar label: aString. aBlock value]
		bar: 	a Job
	Receiver's instance variables: 
		activeTranscript: 	nil


FullBlockClosure(BlockClosure)>>cull:
	Receiver: [:bar | aBlock value: bar]
	Arguments and temporary variables: 
		anArg: 	a Job
	Receiver's instance variables: 
		outerContext: 	MorphicUIManager>>informUserDuring:
		compiledBlock: 	a CompiledBlock: [:bar | aBlock value: bar]
		numArgs: 	1
		receiver: 	a MorphicUIManager


[ ^ block cull: self ] in [ self prepareForRunning.
	  CurrentJob value: self during: [ ^ block cull: self ] ] in Job>>run
	Receiver: a Job
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		block: 	[:bar | aBlock value: bar]
		currentValue: 	1
		min: 	1
		max: 	100
		title: 	'Checking out origin/main from pp-rep2533'
		children: 	an OrderedCollection()
		isRunning: 	true
		parent: 	nil
		process: 	a Process in nil
		owner: 	a MorphicUIManager


[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in CurrentJob(DynamicVariable)>>value:during:
	Receiver: a CurrentJob
	Arguments and temporary variables: 
		anObject: 	a Job
		aBlock: 	[ ^ block cull: self ]
		activeProcess: 	a Process in nil
		oldValue: 	nil
	Receiver's instance variables: 
		index: 	2


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ]
	Arguments and temporary variables: 
		aBlock: 	[
			activeProcess
				psValueAt: index
				put: oldValue ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	CurrentJob(DynamicVariable)>>value:during:
		compiledBlock: 	a CompiledBlock: [ activeProcess
			psValueAt: index
			put:[..]
		numArgs: 	0
		receiver: 	a CurrentJob


CurrentJob(DynamicVariable)>>value:during:
	Receiver: a CurrentJob
	Arguments and temporary variables: 
		anObject: 	a Job
		aBlock: 	[ ^ block cull: self ]
		activeProcess: 	a Process in nil
		oldValue: 	nil
	Receiver's instance variables: 
		index: 	2


CurrentJob class(DynamicVariable class)>>value:during:
	Receiver: CurrentJob
	Arguments and temporary variables: 
		anObject: 	a Job
		aBlock: 	[ ^ block cull: self ]
	Receiver's instance variables: 
		superclass: 	DynamicVariable
		methodDict: 	a MethodDictionary()
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		commentSourcePointer: 	nil
		subclasses: 	nil
		name: 	#CurrentJob
		classPool: 	nil
		sharedPools: 	nil
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Jobs-Base'
		soleInstance: 	a CurrentJob


[ self prepareForRunning.
	  CurrentJob value: self during: [ ^ block cull: self ] ] in Job>>run
	Receiver: a Job
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		block: 	[:bar | aBlock value: bar]
		currentValue: 	1
		min: 	1
		max: 	100
		title: 	'Checking out origin/main from pp-rep2533'
		children: 	an OrderedCollection()
		isRunning: 	true
		parent: 	nil
		process: 	a Process in nil
		owner: 	a MorphicUIManager


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ self prepareForRunning.
	  CurrentJob value: self during: [ ^ block cull: self ] ]
	Arguments and temporary variables: 
		aBlock: 	[ self cleanupAfterRunning ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	Job>>run
		compiledBlock: 	a CompiledBlock: [ self prepareForRunning.
	  CurrentJob val[..]
		numArgs: 	0
		receiver: 	a Job


Job>>run
	Receiver: a Job
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		block: 	[:bar | aBlock value: bar]
		currentValue: 	1
		min: 	1
		max: 	100
		title: 	'Checking out origin/main from pp-rep2533'
		children: 	an OrderedCollection()
		isRunning: 	true
		parent: 	nil
		process: 	a Process in nil
		owner: 	a MorphicUIManager


MorphicUIManager(UIManager)>>displayProgress:from:to:during:
	Receiver: a MorphicUIManager
	Arguments and temporary variables: 
		titleString: 	''
		minVal: 	1
		maxVal: 	100
		workBlock: 	[:bar | aBlock value: bar]
	Receiver's instance variables: 
		activeTranscript: 	nil


MorphicUIManager>>informUserDuring:
	Receiver: a MorphicUIManager
	Arguments and temporary variables: 
		aBlock: 	[:bar | bar label: aString. aBlock value]
	Receiver's instance variables: 
		activeTranscript: 	nil


MorphicUIManager(UIManager)>>informUser:during:
	Receiver: a MorphicUIManager
	Arguments and temporary variables: 
		aString: 	'Checking out origin/main from pp-rep2533'
		aBlock: 	[ result := actionBlock cull: self context ]
	Receiver's instance variables: 
		activeTranscript: 	nil


IceTipStandardAction>>basicExecute
	Receiver: an IceTipStandardAction
	Arguments and temporary variables: 
		result: 	nil
	Receiver's instance variables: 
		context: 	an IceTipCheckoutPreviewBrowser
		repository: 	IceLibgitRepository(pp-rep2533)
		successBlock: 	[ self closeWindow ]
		message: 	'Checking out origin/main from pp-rep2533'
		successAnnounceBlock: 	[ IceRepositoryModified for: self repository ]
		actionBlock: 	[ self checkout ]


[ 
		result := self basicExecute.
		self finishSuccess ] in IceTipStandardAction(IceTipAction)>>execute
	Receiver: an IceTipStandardAction
	Arguments and temporary variables: 
		result: 	nil
	Receiver's instance variables: 
		context: 	an IceTipCheckoutPreviewBrowser
		repository: 	IceLibgitRepository(pp-rep2533)
		successBlock: 	[ self closeWindow ]
		message: 	'Checking out origin/main from pp-rep2533'
		successAnnounceBlock: 	[ IceRepositoryModified for: self repository ]
		actionBlock: 	[ self checkout ]


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [ 
		result := self basicExecute.
		self finishSuccess ]
	Arguments and temporary variables: 
		exception: 	an ExceptionSet
		handlerAction: 	[ :e | 
		e acceptError: (IceTipInteractiveErrorVisitor 
			[..]
	Receiver's instance variables: 
		outerContext: 	IceTipStandardAction(IceTipAction)>>execute
		compiledBlock: 	a CompiledBlock: [ 
		result := self basicExecute.
		self fi[..]
		numArgs: 	0
		receiver: 	an IceTipStandardAction


IceTipStandardAction(IceTipAction)>>withErrorHandlingDo:
	Receiver: an IceTipStandardAction
	Arguments and temporary variables: 
		aBlock: 	[ 
		result := self basicExecute.
		self finishSuccess ]
	Receiver's instance variables: 
		context: 	an IceTipCheckoutPreviewBrowser
		repository: 	IceLibgitRepository(pp-rep2533)
		successBlock: 	[ self closeWindow ]
		message: 	'Checking out origin/main from pp-rep2533'
		successAnnounceBlock: 	[ IceRepositoryModified for: self repository ]
		actionBlock: 	[ self checkout ]


IceTipStandardAction(IceTipAction)>>execute
	Receiver: an IceTipStandardAction
	Arguments and temporary variables: 
		result: 	nil
	Receiver's instance variables: 
		context: 	an IceTipCheckoutPreviewBrowser
		repository: 	IceLibgitRepository(pp-rep2533)
		successBlock: 	[ self closeWindow ]
		message: 	'Checking out origin/main from pp-rep2533'
		successAnnounceBlock: 	[ IceRepositoryModified for: self repository ]
		actionBlock: 	[ self checkout ]


IceTipStandardAction(IceTipAction)>>executeWithContext:
	Receiver: an IceTipStandardAction
	Arguments and temporary variables: 
		aContext: 	an IceTipCheckoutPreviewBrowser
	Receiver's instance variables: 
		context: 	an IceTipCheckoutPreviewBrowser
		repository: 	IceLibgitRepository(pp-rep2533)
		successBlock: 	[ self closeWindow ]
		message: 	'Checking out origin/main from pp-rep2533'
		successAnnounceBlock: 	[ IceRepositoryModified for: self repository ]
		actionBlock: 	[ self checkout ]


IceTipCheckoutPreviewBrowser>>doCheckout
	Receiver: an IceTipCheckoutPreviewBrowser
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicBoxAdapter a SpMorphicBoxAdapter)
		announcer: 	an Announcer
		owner: 	a SpWindowPresenter
		adapter: 	a SpMorphicBoxAdapter
		needRebuild: 	true
		eventHandler: 	nil
		application: 	a StPharoApplication
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ nil ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Untitled window' ]
		additionalSubpresentersMap: 	a Dictionary()
		layout: 	an ObservableValueHolder[ a SpBoxLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		decorations: 	nil
		model: 	an IceTipCheckoutModel
		toolbar: 	nil
		diffPanel: 	an IceTipDiffPanel
		actionPanel: 	a SpButtonBarPresenter
		button: 	a SpButtonPresenter
		checkoutStrategyLabel: 	a SpLabelPresenter
		checkoutStrategyList: 	a SpDropListPresenter
		selectedCheckoutStrategy: 	nil


[ self doCheckout ] in IceTipCheckoutPreviewBrowser>>newActionButton
	Receiver: an IceTipCheckoutPreviewBrowser
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicBoxAdapter a SpMorphicBoxAdapter)
		announcer: 	an Announcer
		owner: 	a SpWindowPresenter
		adapter: 	a SpMorphicBoxAdapter
		needRebuild: 	true
		eventHandler: 	nil
		application: 	a StPharoApplication
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ nil ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Untitled window' ]
		additionalSubpresentersMap: 	a Dictionary()
		layout: 	an ObservableValueHolder[ a SpBoxLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		decorations: 	nil
		model: 	an IceTipCheckoutModel
		toolbar: 	nil
		diffPanel: 	an IceTipDiffPanel
		actionPanel: 	a SpButtonBarPresenter
		button: 	a SpButtonPresenter
		checkoutStrategyLabel: 	a SpLabelPresenter
		checkoutStrategyList: 	a SpDropListPresenter
		selectedCheckoutStrategy: 	nil


SpButtonPresenter>>performAction
	Receiver: a SpButtonPresenter
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicButtonAdapter)
		announcer: 	an Announcer
		owner: 	a SpButtonBarPresenter
		adapter: 	a SpMorphicButtonAdapter
		needRebuild: 	true
		eventHandler: 	nil
		application: 	nil
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ nil ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Button' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpAbstractWidgetLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		borderWidth: 	an ObservableValueHolder[ nil ]
		borderColor: 	an ObservableValueHolder[ nil ]
		dragEnabled: 	an ObservableValueHolder[ false ]
		dropEnabled: 	an ObservableValueHolder[ false ]
		color: 	an ObservableValueHolder[ nil ]
		help: 	an ObservableValueHolder[ 'Checks out origin/main into your image.' ]
		enabled: 	an ObservableValueHolder[ true ]
		wantsDrop: 	an ObservableValueHolder[ [ :transfer | self dropEnabled ] ]
		acceptDrop: 	an ObservableValueHolder[ [ :transfer | ] ]
		deferredActions: 	nil
		icon: 	an ObservableValueHolder[ Form(16x16x32) ]
		label: 	an ObservableValueHolder[ 'Checkout' ]
		action: 	an ObservableValueHolder[ [ self doCheckout ] ]
		actionPerformed: 	an ObservableValueHolder[ nil ]
		askBeforeChanging: 	an ObservableValueHolder[ false ]
		font: 	an ObservableValueHolder[ nil ]
		shortcut: 	an ObservableValueHolder[ nil ]
		state: 	an ObservableValueHolder[ false ]
		contextMenu: 	an ObservableValueHolder[ nil ]


SpMorphicButtonAdapter>>action
	Receiver: a SpMorphicButtonAdapter
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpPluggableButtonMorph(862438144))
		announcer: 	nil
		model: 	a SpButtonPresenter
		widget: 	a SpPluggableButtonMorph(862438144)
		selector: 	nil
		owner: 	a SpButtonPresenter
		unsubscribed: 	false
		subMenuWidget: 	nil
		styleName: 	nil


SpPluggableButtonMorph(PluggableButtonMorph)>>performAction:
	Receiver: a SpPluggableButtonMorph(862438144)
	Arguments and temporary variables: 
		event: 	[(865@614) mouseUp 371218 nil]
	Receiver's instance variables: 
		bounds: 	(826.0@594.0) corner: (926.0@624.0)
		owner: 	a PanelMorph(464935168)
		submorphs: 	an Array(an AlignmentMorph(557272832))
		fullBounds: 	(826@594) corner: (926@624)
		color: 	(Color r: 0.9012707722385142 g: 0.9012707722385142 b: 0.901270772238[..]
		extension: 	a MorphExtension (569120256) [balloonText]  [eventHandler = a Mo[..]
		borderWidth: 	1
		borderColor: 	#simple
		model: 	a SpMorphicButtonAdapter
		label: 	an IconicListItemMorph(910180864)
		icon: 	nil
		getIconSelector: 	nil
		getStateSelector: 	#state
		actionSelector: 	#action
		font: 	nil
		getLabelSelector: 	#label
		getMenuSelector: 	#menu:
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	#enabled
		getFontSelector: 	#font
		labelMorph: 	an IconicListItemMorph(910180864)
		iconMorph: 	nil
		iconPosition: 	#left
		lastState: 	false
		backgroundColor: 	nil



--- The full stack ---
[ :branch | IceError signal: ('Branch {1} already exists' format: { self shortName }) ] in IceGitRemoteBranch(IceRemoteBranch)>>checkout:
[ presentBlock value: (self basicNewBranchNamed: found name) ] in [ | found |
		found := self repositoryHandle lookupLocalBranch: aString ifAbsent: [ nil ].
		^ found ifNil: absentBlock ifNotNil: [ presentBlock value: (self basicNewBranchNamed: found name) ] ] in IceLibgitRepository>>branchNamed:ifPresent:ifAbsent:
FullBlockClosure(BlockClosure)>>cull:
LGitReference(ProtoObject)>>ifNil:ifNotNil:
[ | found |
		found := self repositoryHandle lookupLocalBranch: aString ifAbsent: [ nil ].
		^ found ifNil: absentBlock ifNotNil: [ presentBlock value: (self basicNewBranchNamed: found name) ] ] in IceLibgitRepository>>branchNamed:ifPresent:ifAbsent:
FullBlockClosure(BlockClosure)>>on:do:
IceLibgitRepository>>handleLibgitError:
IceLibgitRepository>>branchNamed:ifPresent:ifAbsent:
IceLibgitRepository(IceRepository)>>branchNamed:ifPresent:
IceGitRemoteBranch(IceRemoteBranch)>>checkout:
IceTipCheckoutModel>>checkout
[ self checkout ] in IceTipCheckoutModel>>newCheckoutAction
FullBlockClosure(BlockClosure)>>cull:
[ result := actionBlock cull: self context ] in IceTipStandardAction>>basicExecute
[:bar | bar label: aString. aBlock value] in MorphicUIManager(UIManager)>>informUser:during:
[:bar | aBlock value: bar] in MorphicUIManager>>informUserDuring:
FullBlockClosure(BlockClosure)>>cull:
[ ^ block cull: self ] in [ self prepareForRunning.
	  CurrentJob value: self during: [ ^ block cull: self ] ] in Job>>run
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in CurrentJob(DynamicVariable)>>value:during:
FullBlockClosure(BlockClosure)>>ensure:
CurrentJob(DynamicVariable)>>value:during:
CurrentJob class(DynamicVariable class)>>value:during:
[ self prepareForRunning.
	  CurrentJob value: self during: [ ^ block cull: self ] ] in Job>>run
FullBlockClosure(BlockClosure)>>ensure:
Job>>run
MorphicUIManager(UIManager)>>displayProgress:from:to:during:
MorphicUIManager>>informUserDuring:
MorphicUIManager(UIManager)>>informUser:during:
IceTipStandardAction>>basicExecute
[ 
		result := self basicExecute.
		self finishSuccess ] in IceTipStandardAction(IceTipAction)>>execute
FullBlockClosure(BlockClosure)>>on:do:
IceTipStandardAction(IceTipAction)>>withErrorHandlingDo:
IceTipStandardAction(IceTipAction)>>execute
IceTipStandardAction(IceTipAction)>>executeWithContext:
IceTipCheckoutPreviewBrowser>>doCheckout
[ self doCheckout ] in IceTipCheckoutPreviewBrowser>>newActionButton
SpButtonPresenter>>performAction
SpMorphicButtonAdapter>>action
SpPluggableButtonMorph(PluggableButtonMorph)>>performAction:
 - - - - - - - - - - - - - - -
			- - - - - - - - - - - - - - - - - -
[:m |
		(m containsPoint: evt cursorPoint) ifTrue: [m enabled ifTrue: [ m performAction: evt ]]] in SpPluggableButtonMorph(PluggableButtonMorph)>>mouseUp:
Array(SequenceableCollection)>>do:
SpPluggableButtonMorph(PluggableButtonMorph)>>mouseUp:
SpPluggableButtonMorph(Morph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
SpPluggableButtonMorph(Morph)>>handleEvent:
SpPluggableButtonMorph(Morph)>>handleFocusEvent:
[
		result := focusHolder handleFocusEvent: transformedEvent.
	] in HandMorph>>sendFocusEvent:to:clear:
FullBlockClosure(BlockClosure)>>on:do:
WorldMorph>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil ]) ifTrue: [
			morphicWorld activeHand handleEvent: anEvent
		]
	] in OSWindowMorphicEventHandler>>dispatchMorphicEvent:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycleNow
WorldMorph>>doOneCycle
[
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMutex critical: [
			                     self extraWorldList ].
		extraWorldsToDraw do: [ :world | world doOneCycle ].

		(self currentWorld isNotNil and: [
			 (extraWorldsToDraw includes: self currentWorld) not ]) ifTrue: [
			self currentWorld doOneCycle ] ] in WorldMorph class>>doOneCycle
FullBlockClosure(BlockClosure)>>ensure:
WorldState class>>doDrawCycleWith:
WorldMorph class>>doOneCycle
MorphicRenderLoop>>doOneCycle
MorphicRenderLoop>>doOneCycleWhile:
[ MorphicRenderLoop new doOneCycleWhile: [ true ] ] in MorphicUIManager>>spawnNewProcess
[self value.
			"IMPORTANT: Do not step over next line of code. See method comments for details"
			Processor terminateRealActive] in FullBlockClosure(BlockClosure)>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
IceError: Branch main already exists
13 November 2023 11:36:20.821256 pm

VM: Mac OS - arm64 - 1000 - CoInterpreter VMMaker-tonel.1 uuid: 902dd483-c0c4-0d00-86f2-0f880df24b96 Oct 23 2023
StackToRegisterMappingCogit VMMaker-tonel.1 uuid: 902dd483-c0c4-0d00-86f2-0f880df24b96 Oct 23 2023
v10.0.8 - Commit: b323c5fb - Date: 2023-10-20 16:02:07 -0400

Image: Pharo11.0.0 [Build information: Pharo-11.0.0+build.710.sha.ea28d8552cac85a7ce1e9c34ab1e7bd45f7b9910 (64 Bit)]

[ :branch | IceError signal: ('Branch {1} already exists' format: { self shortName }) ] in IceGitRemoteBranch(IceRemoteBranch)>>checkout:
	Receiver: IceGitRemoteBranch(origin/main)
	Arguments and temporary variables: 
		aCheckoutStrategy: 	an IceCheckoutAlreadyLoadedPackages
		localBranch: 	nil
		branch: 	IceGitLocalBranch(main)
	Receiver's instance variables: 
		repository: 	IceLibgitRepository(pp-rep2533)
		name: 	'refs/remotes/origin/main'


[ presentBlock value: (self basicNewBranchNamed: found name) ] in [ | found |
		found := self repositoryHandle lookupLocalBranch: aString ifAbsent: [ nil ].
		^ found ifNil: absentBlock ifNotNil: [ presentBlock value: (self basicNewBranchNamed: found name) ] ] in IceLibgitRepository>>branchNamed:ifPresent:ifAbsent:
	Receiver: IceLibgitRepository(pp-rep2533)
	Arguments and temporary variables: 
		aString: 	'main'
		presentBlock: 	[ :branch | IceError signal: ('Branch {1} already exists' for[..]
		absentBlock: 	[ self ]
		found: 	a LGitReference ('refs/heads/main')
	Receiver's instance variables: 
		name: 	'pp-rep2533'
		workingCopy: 	an IceWorkingCopy
		index: 	an IceGitIndex
		commitsInPackageCache: 	nil
		location: 	File @ /Users/ryanperez/Documents/GitHub/pp-rep2533
		commitCache: 	a LRUCache(#3 3/30 [ 1 ] 100%)
		handle: 	a LGitRepository (/Users/ryanperez/Documents/GitHub/pp-rep2533)


FullBlockClosure(BlockClosure)>>cull:
	Receiver: [ presentBlock value: (self basicNewBranchNamed: found name) ]
	Arguments and temporary variables: 
		anArg: 	a LGitReference ('refs/heads/main')
	Receiver's instance variables: 
		outerContext: 	[ | found |
		found := self repositoryHandle lookupLocalBranc[..]
		compiledBlock: 	a CompiledBlock: [ presentBlock value: (self basicNewBranchN[..]
		numArgs: 	0
		receiver: 	IceLibgitRepository(pp-rep2533)


LGitReference(ProtoObject)>>ifNil:ifNotNil:
	Receiver: a LGitReference ('refs/heads/main')
	Arguments and temporary variables: 
		nilBlock: 	[ self ]
		ifNotNilBlock: 	[ presentBlock value: (self basicNewBranchNamed: found name) ]
	Receiver's instance variables: 
		handle: 	@ 16r600002605E50
		repository: 	a LGitRepository (/Users/ryanperez/Documents/GitHub/pp-rep2533)


[ | found |
		found := self repositoryHandle lookupLocalBranch: aString ifAbsent: [ nil ].
		^ found ifNil: absentBlock ifNotNil: [ presentBlock value: (self basicNewBranchNamed: found name) ] ] in IceLibgitRepository>>branchNamed:ifPresent:ifAbsent:
	Receiver: IceLibgitRepository(pp-rep2533)
	Arguments and temporary variables: 
		aString: 	'main'
		presentBlock: 	[ :branch | IceError signal: ('Branch {1} already exists' for[..]
		absentBlock: 	[ self ]
		found: 	a LGitReference ('refs/heads/main')
	Receiver's instance variables: 
		name: 	'pp-rep2533'
		workingCopy: 	an IceWorkingCopy
		index: 	an IceGitIndex
		commitsInPackageCache: 	nil
		location: 	File @ /Users/ryanperez/Documents/GitHub/pp-rep2533
		commitCache: 	a LRUCache(#3 3/30 [ 1 ] 100%)
		handle: 	a LGitRepository (/Users/ryanperez/Documents/GitHub/pp-rep2533)


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [ | found |
		found := self repositoryHandle lookupLocalBranch: aString ifAbsent: [ ni[..]
	Arguments and temporary variables: 
		exception: 	LGitCallReturnHandler
		handlerAction: 	[ :error | error acceptError: (IceLibgitErrorVisitor onConte[..]
	Receiver's instance variables: 
		outerContext: 	IceLibgitRepository>>branchNamed:ifPresent:ifAbsent:
		compiledBlock: 	a CompiledBlock: [ | found |
		found := self repositoryHandl[..]
		numArgs: 	0
		receiver: 	IceLibgitRepository(pp-rep2533)


IceLibgitRepository>>handleLibgitError:
	Receiver: IceLibgitRepository(pp-rep2533)
	Arguments and temporary variables: 
		aBlock: 	[ | found |
		found := self repositoryHandle lookupLocalBranch: aSt[..]
	Receiver's instance variables: 
		name: 	'pp-rep2533'
		workingCopy: 	an IceWorkingCopy
		index: 	an IceGitIndex
		commitsInPackageCache: 	nil
		location: 	File @ /Users/ryanperez/Documents/GitHub/pp-rep2533
		commitCache: 	a LRUCache(#3 3/30 [ 1 ] 100%)
		handle: 	a LGitRepository (/Users/ryanperez/Documents/GitHub/pp-rep2533)


IceLibgitRepository>>branchNamed:ifPresent:ifAbsent:
	Receiver: IceLibgitRepository(pp-rep2533)
	Arguments and temporary variables: 
		aString: 	'main'
		presentBlock: 	[ :branch | IceError signal: ('Branch {1} already exists' for[..]
		absentBlock: 	[ self ]
	Receiver's instance variables: 
		name: 	'pp-rep2533'
		workingCopy: 	an IceWorkingCopy
		index: 	an IceGitIndex
		commitsInPackageCache: 	nil
		location: 	File @ /Users/ryanperez/Documents/GitHub/pp-rep2533
		commitCache: 	a LRUCache(#3 3/30 [ 1 ] 100%)
		handle: 	a LGitRepository (/Users/ryanperez/Documents/GitHub/pp-rep2533)


IceLibgitRepository(IceRepository)>>branchNamed:ifPresent:
	Receiver: IceLibgitRepository(pp-rep2533)
	Arguments and temporary variables: 
		aString: 	'main'
		aBlockClosure: 	[ :branch | IceError signal: ('Branch {1} already exists' fo[..]
	Receiver's instance variables: 
		name: 	'pp-rep2533'
		workingCopy: 	an IceWorkingCopy
		index: 	an IceGitIndex
		commitsInPackageCache: 	nil
		location: 	File @ /Users/ryanperez/Documents/GitHub/pp-rep2533
		commitCache: 	a LRUCache(#3 3/30 [ 1 ] 100%)
		handle: 	a LGitRepository (/Users/ryanperez/Documents/GitHub/pp-rep2533)


IceGitRemoteBranch(IceRemoteBranch)>>checkout:
	Receiver: IceGitRemoteBranch(origin/main)
	Arguments and temporary variables: 
		aCheckoutStrategy: 	an IceCheckoutAlreadyLoadedPackages
		localBranch: 	nil
	Receiver's instance variables: 
		repository: 	IceLibgitRepository(pp-rep2533)
		name: 	'refs/remotes/origin/main'


IceTipCheckoutModel>>checkout
	Receiver: an IceTipCheckoutModel
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		commitish: 	an IceTipBranchModel[origin/main]
		diffModel: 	an IceTipCommitDiffModel
		checkoutStrategy: 	an IceCheckoutAlreadyLoadedPackages
		checkoutStrategies: 	an OrderedCollection(an IceCheckoutAlreadyLoadedPackage[..]


[ self checkout ] in IceTipCheckoutModel>>newCheckoutAction
	Receiver: an IceTipCheckoutModel
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		commitish: 	an IceTipBranchModel[origin/main]
		diffModel: 	an IceTipCommitDiffModel
		checkoutStrategy: 	an IceCheckoutAlreadyLoadedPackages
		checkoutStrategies: 	an OrderedCollection(an IceCheckoutAlreadyLoadedPackage[..]


FullBlockClosure(BlockClosure)>>cull:
	Receiver: [ self checkout ]
	Arguments and temporary variables: 
		anArg: 	an IceTipCheckoutPreviewBrowser
	Receiver's instance variables: 
		outerContext: 	IceTipCheckoutModel>>newCheckoutAction
		compiledBlock: 	a CompiledBlock: [ self checkout ]
		numArgs: 	0
		receiver: 	an IceTipCheckoutModel


[ result := actionBlock cull: self context ] in IceTipStandardAction>>basicExecute
	Receiver: an IceTipStandardAction
	Arguments and temporary variables: 
		result: 	nil
	Receiver's instance variables: 
		context: 	an IceTipCheckoutPreviewBrowser
		repository: 	IceLibgitRepository(pp-rep2533)
		successBlock: 	[ self closeWindow ]
		message: 	'Checking out origin/main from pp-rep2533'
		successAnnounceBlock: 	[ IceRepositoryModified for: self repository ]
		actionBlock: 	[ self checkout ]


[:bar | bar label: aString. aBlock value] in MorphicUIManager(UIManager)>>informUser:during:
	Receiver: a MorphicUIManager
	Arguments and temporary variables: 
		aString: 	'Checking out origin/main from pp-rep2533'
		aBlock: 	[ result := actionBlock cull: self context ]
		bar: 	a Job
	Receiver's instance variables: 
		activeTranscript: 	nil


[:bar | aBlock value: bar] in MorphicUIManager>>informUserDuring:
	Receiver: a MorphicUIManager
	Arguments and temporary variables: 
		aBlock: 	[:bar | bar label: aString. aBlock value]
		bar: 	a Job
	Receiver's instance variables: 
		activeTranscript: 	nil


FullBlockClosure(BlockClosure)>>cull:
	Receiver: [:bar | aBlock value: bar]
	Arguments and temporary variables: 
		anArg: 	a Job
	Receiver's instance variables: 
		outerContext: 	MorphicUIManager>>informUserDuring:
		compiledBlock: 	a CompiledBlock: [:bar | aBlock value: bar]
		numArgs: 	1
		receiver: 	a MorphicUIManager


[ ^ block cull: self ] in [ self prepareForRunning.
	  CurrentJob value: self during: [ ^ block cull: self ] ] in Job>>run
	Receiver: a Job
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		block: 	[:bar | aBlock value: bar]
		currentValue: 	1
		min: 	1
		max: 	100
		title: 	'Checking out origin/main from pp-rep2533'
		children: 	an OrderedCollection()
		isRunning: 	true
		parent: 	nil
		process: 	a Process in nil
		owner: 	a MorphicUIManager


[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in CurrentJob(DynamicVariable)>>value:during:
	Receiver: a CurrentJob
	Arguments and temporary variables: 
		anObject: 	a Job
		aBlock: 	[ ^ block cull: self ]
		activeProcess: 	a Process in nil
		oldValue: 	nil
	Receiver's instance variables: 
		index: 	2


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ]
	Arguments and temporary variables: 
		aBlock: 	[
			activeProcess
				psValueAt: index
				put: oldValue ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	CurrentJob(DynamicVariable)>>value:during:
		compiledBlock: 	a CompiledBlock: [ activeProcess
			psValueAt: index
			put:[..]
		numArgs: 	0
		receiver: 	a CurrentJob


CurrentJob(DynamicVariable)>>value:during:
	Receiver: a CurrentJob
	Arguments and temporary variables: 
		anObject: 	a Job
		aBlock: 	[ ^ block cull: self ]
		activeProcess: 	a Process in nil
		oldValue: 	nil
	Receiver's instance variables: 
		index: 	2


CurrentJob class(DynamicVariable class)>>value:during:
	Receiver: CurrentJob
	Arguments and temporary variables: 
		anObject: 	a Job
		aBlock: 	[ ^ block cull: self ]
	Receiver's instance variables: 
		superclass: 	DynamicVariable
		methodDict: 	a MethodDictionary()
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		commentSourcePointer: 	nil
		subclasses: 	nil
		name: 	#CurrentJob
		classPool: 	nil
		sharedPools: 	nil
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Jobs-Base'
		soleInstance: 	a CurrentJob


[ self prepareForRunning.
	  CurrentJob value: self during: [ ^ block cull: self ] ] in Job>>run
	Receiver: a Job
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		block: 	[:bar | aBlock value: bar]
		currentValue: 	1
		min: 	1
		max: 	100
		title: 	'Checking out origin/main from pp-rep2533'
		children: 	an OrderedCollection()
		isRunning: 	true
		parent: 	nil
		process: 	a Process in nil
		owner: 	a MorphicUIManager


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ self prepareForRunning.
	  CurrentJob value: self during: [ ^ block cull: self ] ]
	Arguments and temporary variables: 
		aBlock: 	[ self cleanupAfterRunning ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	Job>>run
		compiledBlock: 	a CompiledBlock: [ self prepareForRunning.
	  CurrentJob val[..]
		numArgs: 	0
		receiver: 	a Job


Job>>run
	Receiver: a Job
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		block: 	[:bar | aBlock value: bar]
		currentValue: 	1
		min: 	1
		max: 	100
		title: 	'Checking out origin/main from pp-rep2533'
		children: 	an OrderedCollection()
		isRunning: 	true
		parent: 	nil
		process: 	a Process in nil
		owner: 	a MorphicUIManager


MorphicUIManager(UIManager)>>displayProgress:from:to:during:
	Receiver: a MorphicUIManager
	Arguments and temporary variables: 
		titleString: 	''
		minVal: 	1
		maxVal: 	100
		workBlock: 	[:bar | aBlock value: bar]
	Receiver's instance variables: 
		activeTranscript: 	nil


MorphicUIManager>>informUserDuring:
	Receiver: a MorphicUIManager
	Arguments and temporary variables: 
		aBlock: 	[:bar | bar label: aString. aBlock value]
	Receiver's instance variables: 
		activeTranscript: 	nil


MorphicUIManager(UIManager)>>informUser:during:
	Receiver: a MorphicUIManager
	Arguments and temporary variables: 
		aString: 	'Checking out origin/main from pp-rep2533'
		aBlock: 	[ result := actionBlock cull: self context ]
	Receiver's instance variables: 
		activeTranscript: 	nil


IceTipStandardAction>>basicExecute
	Receiver: an IceTipStandardAction
	Arguments and temporary variables: 
		result: 	nil
	Receiver's instance variables: 
		context: 	an IceTipCheckoutPreviewBrowser
		repository: 	IceLibgitRepository(pp-rep2533)
		successBlock: 	[ self closeWindow ]
		message: 	'Checking out origin/main from pp-rep2533'
		successAnnounceBlock: 	[ IceRepositoryModified for: self repository ]
		actionBlock: 	[ self checkout ]


[ 
		result := self basicExecute.
		self finishSuccess ] in IceTipStandardAction(IceTipAction)>>execute
	Receiver: an IceTipStandardAction
	Arguments and temporary variables: 
		result: 	nil
	Receiver's instance variables: 
		context: 	an IceTipCheckoutPreviewBrowser
		repository: 	IceLibgitRepository(pp-rep2533)
		successBlock: 	[ self closeWindow ]
		message: 	'Checking out origin/main from pp-rep2533'
		successAnnounceBlock: 	[ IceRepositoryModified for: self repository ]
		actionBlock: 	[ self checkout ]


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [ 
		result := self basicExecute.
		self finishSuccess ]
	Arguments and temporary variables: 
		exception: 	an ExceptionSet
		handlerAction: 	[ :e | 
		e acceptError: (IceTipInteractiveErrorVisitor 
			[..]
	Receiver's instance variables: 
		outerContext: 	IceTipStandardAction(IceTipAction)>>execute
		compiledBlock: 	a CompiledBlock: [ 
		result := self basicExecute.
		self fi[..]
		numArgs: 	0
		receiver: 	an IceTipStandardAction


IceTipStandardAction(IceTipAction)>>withErrorHandlingDo:
	Receiver: an IceTipStandardAction
	Arguments and temporary variables: 
		aBlock: 	[ 
		result := self basicExecute.
		self finishSuccess ]
	Receiver's instance variables: 
		context: 	an IceTipCheckoutPreviewBrowser
		repository: 	IceLibgitRepository(pp-rep2533)
		successBlock: 	[ self closeWindow ]
		message: 	'Checking out origin/main from pp-rep2533'
		successAnnounceBlock: 	[ IceRepositoryModified for: self repository ]
		actionBlock: 	[ self checkout ]


IceTipStandardAction(IceTipAction)>>execute
	Receiver: an IceTipStandardAction
	Arguments and temporary variables: 
		result: 	nil
	Receiver's instance variables: 
		context: 	an IceTipCheckoutPreviewBrowser
		repository: 	IceLibgitRepository(pp-rep2533)
		successBlock: 	[ self closeWindow ]
		message: 	'Checking out origin/main from pp-rep2533'
		successAnnounceBlock: 	[ IceRepositoryModified for: self repository ]
		actionBlock: 	[ self checkout ]


IceTipStandardAction(IceTipAction)>>executeWithContext:
	Receiver: an IceTipStandardAction
	Arguments and temporary variables: 
		aContext: 	an IceTipCheckoutPreviewBrowser
	Receiver's instance variables: 
		context: 	an IceTipCheckoutPreviewBrowser
		repository: 	IceLibgitRepository(pp-rep2533)
		successBlock: 	[ self closeWindow ]
		message: 	'Checking out origin/main from pp-rep2533'
		successAnnounceBlock: 	[ IceRepositoryModified for: self repository ]
		actionBlock: 	[ self checkout ]


IceTipCheckoutPreviewBrowser>>doCheckout
	Receiver: an IceTipCheckoutPreviewBrowser
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicBoxAdapter a SpMorphicBoxAdapter)
		announcer: 	an Announcer
		owner: 	a SpWindowPresenter
		adapter: 	a SpMorphicBoxAdapter
		needRebuild: 	true
		eventHandler: 	nil
		application: 	a StPharoApplication
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ nil ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Untitled window' ]
		additionalSubpresentersMap: 	a Dictionary()
		layout: 	an ObservableValueHolder[ a SpBoxLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		decorations: 	nil
		model: 	an IceTipCheckoutModel
		toolbar: 	nil
		diffPanel: 	an IceTipDiffPanel
		actionPanel: 	a SpButtonBarPresenter
		button: 	a SpButtonPresenter
		checkoutStrategyLabel: 	a SpLabelPresenter
		checkoutStrategyList: 	a SpDropListPresenter
		selectedCheckoutStrategy: 	nil


[ self doCheckout ] in IceTipCheckoutPreviewBrowser>>newActionButton
	Receiver: an IceTipCheckoutPreviewBrowser
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicBoxAdapter a SpMorphicBoxAdapter)
		announcer: 	an Announcer
		owner: 	a SpWindowPresenter
		adapter: 	a SpMorphicBoxAdapter
		needRebuild: 	true
		eventHandler: 	nil
		application: 	a StPharoApplication
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ nil ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Untitled window' ]
		additionalSubpresentersMap: 	a Dictionary()
		layout: 	an ObservableValueHolder[ a SpBoxLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		decorations: 	nil
		model: 	an IceTipCheckoutModel
		toolbar: 	nil
		diffPanel: 	an IceTipDiffPanel
		actionPanel: 	a SpButtonBarPresenter
		button: 	a SpButtonPresenter
		checkoutStrategyLabel: 	a SpLabelPresenter
		checkoutStrategyList: 	a SpDropListPresenter
		selectedCheckoutStrategy: 	nil


SpButtonPresenter>>performAction
	Receiver: a SpButtonPresenter
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicButtonAdapter)
		announcer: 	an Announcer
		owner: 	a SpButtonBarPresenter
		adapter: 	a SpMorphicButtonAdapter
		needRebuild: 	true
		eventHandler: 	nil
		application: 	nil
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ nil ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Button' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpAbstractWidgetLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		borderWidth: 	an ObservableValueHolder[ nil ]
		borderColor: 	an ObservableValueHolder[ nil ]
		dragEnabled: 	an ObservableValueHolder[ false ]
		dropEnabled: 	an ObservableValueHolder[ false ]
		color: 	an ObservableValueHolder[ nil ]
		help: 	an ObservableValueHolder[ 'Checks out origin/main into your image.' ]
		enabled: 	an ObservableValueHolder[ true ]
		wantsDrop: 	an ObservableValueHolder[ [ :transfer | self dropEnabled ] ]
		acceptDrop: 	an ObservableValueHolder[ [ :transfer | ] ]
		deferredActions: 	nil
		icon: 	an ObservableValueHolder[ Form(16x16x32) ]
		label: 	an ObservableValueHolder[ 'Checkout' ]
		action: 	an ObservableValueHolder[ [ self doCheckout ] ]
		actionPerformed: 	an ObservableValueHolder[ nil ]
		askBeforeChanging: 	an ObservableValueHolder[ false ]
		font: 	an ObservableValueHolder[ nil ]
		shortcut: 	an ObservableValueHolder[ nil ]
		state: 	an ObservableValueHolder[ false ]
		contextMenu: 	an ObservableValueHolder[ nil ]


SpMorphicButtonAdapter>>action
	Receiver: a SpMorphicButtonAdapter
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpPluggableButtonMorph(862438144))
		announcer: 	nil
		model: 	a SpButtonPresenter
		widget: 	a SpPluggableButtonMorph(862438144)
		selector: 	nil
		owner: 	a SpButtonPresenter
		unsubscribed: 	false
		subMenuWidget: 	nil
		styleName: 	nil


SpPluggableButtonMorph(PluggableButtonMorph)>>performAction:
	Receiver: a SpPluggableButtonMorph(862438144)
	Arguments and temporary variables: 
		event: 	[(865@614) mouseUp 371218 nil]
	Receiver's instance variables: 
		bounds: 	(826.0@594.0) corner: (926.0@624.0)
		owner: 	a PanelMorph(464935168)
		submorphs: 	an Array(an AlignmentMorph(557272832))
		fullBounds: 	(826@594) corner: (926@624)
		color: 	(Color r: 0.9012707722385142 g: 0.9012707722385142 b: 0.901270772238[..]
		extension: 	a MorphExtension (569120256) [balloonText]  [eventHandler = a Mo[..]
		borderWidth: 	1
		borderColor: 	#simple
		model: 	a SpMorphicButtonAdapter
		label: 	an IconicListItemMorph(910180864)
		icon: 	nil
		getIconSelector: 	nil
		getStateSelector: 	#state
		actionSelector: 	#action
		font: 	nil
		getLabelSelector: 	#label
		getMenuSelector: 	#menu:
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	#enabled
		getFontSelector: 	#font
		labelMorph: 	an IconicListItemMorph(910180864)
		iconMorph: 	nil
		iconPosition: 	#left
		lastState: 	false
		backgroundColor: 	nil



--- The full stack ---
[ :branch | IceError signal: ('Branch {1} already exists' format: { self shortName }) ] in IceGitRemoteBranch(IceRemoteBranch)>>checkout:
[ presentBlock value: (self basicNewBranchNamed: found name) ] in [ | found |
		found := self repositoryHandle lookupLocalBranch: aString ifAbsent: [ nil ].
		^ found ifNil: absentBlock ifNotNil: [ presentBlock value: (self basicNewBranchNamed: found name) ] ] in IceLibgitRepository>>branchNamed:ifPresent:ifAbsent:
FullBlockClosure(BlockClosure)>>cull:
LGitReference(ProtoObject)>>ifNil:ifNotNil:
[ | found |
		found := self repositoryHandle lookupLocalBranch: aString ifAbsent: [ nil ].
		^ found ifNil: absentBlock ifNotNil: [ presentBlock value: (self basicNewBranchNamed: found name) ] ] in IceLibgitRepository>>branchNamed:ifPresent:ifAbsent:
FullBlockClosure(BlockClosure)>>on:do:
IceLibgitRepository>>handleLibgitError:
IceLibgitRepository>>branchNamed:ifPresent:ifAbsent:
IceLibgitRepository(IceRepository)>>branchNamed:ifPresent:
IceGitRemoteBranch(IceRemoteBranch)>>checkout:
IceTipCheckoutModel>>checkout
[ self checkout ] in IceTipCheckoutModel>>newCheckoutAction
FullBlockClosure(BlockClosure)>>cull:
[ result := actionBlock cull: self context ] in IceTipStandardAction>>basicExecute
[:bar | bar label: aString. aBlock value] in MorphicUIManager(UIManager)>>informUser:during:
[:bar | aBlock value: bar] in MorphicUIManager>>informUserDuring:
FullBlockClosure(BlockClosure)>>cull:
[ ^ block cull: self ] in [ self prepareForRunning.
	  CurrentJob value: self during: [ ^ block cull: self ] ] in Job>>run
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in CurrentJob(DynamicVariable)>>value:during:
FullBlockClosure(BlockClosure)>>ensure:
CurrentJob(DynamicVariable)>>value:during:
CurrentJob class(DynamicVariable class)>>value:during:
[ self prepareForRunning.
	  CurrentJob value: self during: [ ^ block cull: self ] ] in Job>>run
FullBlockClosure(BlockClosure)>>ensure:
Job>>run
MorphicUIManager(UIManager)>>displayProgress:from:to:during:
MorphicUIManager>>informUserDuring:
MorphicUIManager(UIManager)>>informUser:during:
IceTipStandardAction>>basicExecute
[ 
		result := self basicExecute.
		self finishSuccess ] in IceTipStandardAction(IceTipAction)>>execute
FullBlockClosure(BlockClosure)>>on:do:
IceTipStandardAction(IceTipAction)>>withErrorHandlingDo:
IceTipStandardAction(IceTipAction)>>execute
IceTipStandardAction(IceTipAction)>>executeWithContext:
IceTipCheckoutPreviewBrowser>>doCheckout
[ self doCheckout ] in IceTipCheckoutPreviewBrowser>>newActionButton
SpButtonPresenter>>performAction
SpMorphicButtonAdapter>>action
SpPluggableButtonMorph(PluggableButtonMorph)>>performAction:
 - - - - - - - - - - - - - - -
			- - - - - - - - - - - - - - - - - -
[:m |
		(m containsPoint: evt cursorPoint) ifTrue: [m enabled ifTrue: [ m performAction: evt ]]] in SpPluggableButtonMorph(PluggableButtonMorph)>>mouseUp:
Array(SequenceableCollection)>>do:
SpPluggableButtonMorph(PluggableButtonMorph)>>mouseUp:
SpPluggableButtonMorph(Morph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
SpPluggableButtonMorph(Morph)>>handleEvent:
SpPluggableButtonMorph(Morph)>>handleFocusEvent:
[
		result := focusHolder handleFocusEvent: transformedEvent.
	] in HandMorph>>sendFocusEvent:to:clear:
FullBlockClosure(BlockClosure)>>on:do:
WorldMorph>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil ]) ifTrue: [
			morphicWorld activeHand handleEvent: anEvent
		]
	] in OSWindowMorphicEventHandler>>dispatchMorphicEvent:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycleNow
WorldMorph>>doOneCycle
[
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMutex critical: [
			                     self extraWorldList ].
		extraWorldsToDraw do: [ :world | world doOneCycle ].

		(self currentWorld isNotNil and: [
			 (extraWorldsToDraw includes: self currentWorld) not ]) ifTrue: [
			self currentWorld doOneCycle ] ] in WorldMorph class>>doOneCycle
FullBlockClosure(BlockClosure)>>ensure:
WorldState class>>doDrawCycleWith:
WorldMorph class>>doOneCycle
MorphicRenderLoop>>doOneCycle
MorphicRenderLoop>>doOneCycleWhile:
[ MorphicRenderLoop new doOneCycleWhile: [ true ] ] in MorphicUIManager>>spawnNewProcess
[self value.
			"IMPORTANT: Do not step over next line of code. See method comments for details"
			Processor terminateRealActive] in FullBlockClosure(BlockClosure)>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
IceGenericError: invalid argument: 'id'
13 November 2023 11:36:36.428413 pm

VM: Mac OS - arm64 - 1000 - CoInterpreter VMMaker-tonel.1 uuid: 902dd483-c0c4-0d00-86f2-0f880df24b96 Oct 23 2023
StackToRegisterMappingCogit VMMaker-tonel.1 uuid: 902dd483-c0c4-0d00-86f2-0f880df24b96 Oct 23 2023
v10.0.8 - Commit: b323c5fb - Date: 2023-10-20 16:02:07 -0400

Image: Pharo11.0.0 [Build information: Pharo-11.0.0+build.710.sha.ea28d8552cac85a7ce1e9c34ab1e7bd45f7b9910 (64 Bit)]

IceLibgitErrorVisitor>>visitGenericError:
	Receiver: an IceLibgitErrorVisitor
	Arguments and temporary variables: 
		anError: 	LGit_GIT_ERROR: invalid argument: 'id'
	Receiver's instance variables: 
		context: 	IceLibgitRepository(pp-rep2533)


IceLibgitErrorVisitor>>visitERROR:
	Receiver: an IceLibgitErrorVisitor
	Arguments and temporary variables: 
		anError: 	LGit_GIT_ERROR: invalid argument: 'id'
	Receiver's instance variables: 
		context: 	IceLibgitRepository(pp-rep2533)


LGit_GIT_ERROR>>acceptError:
	Receiver: LGit_GIT_ERROR: invalid argument: 'id'
	Arguments and temporary variables: 
		aVisitor: 	an IceLibgitErrorVisitor
	Receiver's instance variables: 
		messageText: 	'invalid argument: ''id'''
		tag: 	nil
		signaler: 	a LGitReturnCodeEnum(#git_error [-1])
		signalContext: 	LGit_GIT_ERROR(Exception)>>signal
		handlerContext: 	FullBlockClosure(BlockClosure)>>on:do:
		outerContext: 	nil
		object: 	a LGitErrorTypeEnum(#giterr_invalid [3])


[ :error | error acceptError: (IceLibgitErrorVisitor onContext: self) ] in IceLibgitRepository>>handleLibgitError:
	Receiver: IceLibgitRepository(pp-rep2533)
	Arguments and temporary variables: 
		aBlock: 	[ | gitCommit gitId |
		gitId := (self repositoryHandle lookupRemot[..]
		error: 	LGit_GIT_ERROR: invalid argument: 'id'
	Receiver's instance variables: 
		name: 	'pp-rep2533'
		workingCopy: 	an IceWorkingCopy
		index: 	an IceGitIndex
		commitsInPackageCache: 	nil
		location: 	File @ /Users/ryanperez/Documents/GitHub/pp-rep2533
		commitCache: 	a LRUCache(#3 3/30 [ 1 ] 100%)
		handle: 	a LGitRepository (/Users/ryanperez/Documents/GitHub/pp-rep2533)


FullBlockClosure(BlockClosure)>>cull:
	Receiver: [ :error | error acceptError: (IceLibgitErrorVisitor onContext: self) ]
	Arguments and temporary variables: 
		anArg: 	LGit_GIT_ERROR: invalid argument: 'id'
	Receiver's instance variables: 
		outerContext: 	IceLibgitRepository>>handleLibgitError:
		compiledBlock: 	a CompiledBlock: [ :error | error acceptError: (IceLibgitErr[..]
		numArgs: 	1
		receiver: 	IceLibgitRepository(pp-rep2533)


Context>>evaluateSignal:
	Receiver: FullBlockClosure(BlockClosure)>>on:do:
	Arguments and temporary variables: 
		exception: 	LGit_GIT_ERROR: invalid argument: 'id'
		value: 	nil
	Receiver's instance variables: 
		sender: 	IceLibgitRepository>>handleLibgitError:
		pc: 	30
		stackp: 	2
		method: 	BlockClosure>>#on:do:
		closureOrNil: 	nil
		receiver: 	[ | gitCommit gitId |
		gitId := (self repositoryHandle lookupRem[..]


Context>>handleSignal:
	Receiver: FullBlockClosure(BlockClosure)>>on:do:
	Arguments and temporary variables: 
		exception: 	LGit_GIT_ERROR: invalid argument: 'id'
	Receiver's instance variables: 
		sender: 	IceLibgitRepository>>handleLibgitError:
		pc: 	30
		stackp: 	2
		method: 	BlockClosure>>#on:do:
		closureOrNil: 	nil
		receiver: 	[ | gitCommit gitId |
		gitId := (self repositoryHandle lookupRem[..]


LGit_GIT_ERROR(Exception)>>signal
	Receiver: LGit_GIT_ERROR: invalid argument: 'id'
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		messageText: 	'invalid argument: ''id'''
		tag: 	nil
		signaler: 	a LGitReturnCodeEnum(#git_error [-1])
		signalContext: 	LGit_GIT_ERROR(Exception)>>signal
		handlerContext: 	FullBlockClosure(BlockClosure)>>on:do:
		outerContext: 	nil
		object: 	a LGitErrorTypeEnum(#giterr_invalid [3])


LGit_GIT_ERROR class(LGitCallReturnHandler class)>>signalWith:
	Receiver: LGit_GIT_ERROR
	Arguments and temporary variables: 
		anError: 	a LGitError ()
	Receiver's instance variables: 
		superclass: 	LGitCallReturnHandler
		methodDict: 	a MethodDictionary(#acceptError:->LGit_GIT_ERROR>>#acceptError: )
		format: 	65543
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		commentSourcePointer: 	nil
		subclasses: 	nil
		name: 	#LGit_GIT_ERROR
		classPool: 	nil
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'LibGit-Core-Exceptions-ReturnCodes'


LGitReturnCodeEnum>>handleLGitReturnCode
	Receiver: a LGitReturnCodeEnum(#git_error [-1])
	Arguments and temporary variables: 
		handler: 	LGit_GIT_ERROR
	Receiver's instance variables: 
		value: 	-1


LGitCommit(LGitExternalObject)>>withReturnHandlerDo:
	Receiver: a LGitCommit (<not initialized>)
	Arguments and temporary variables: 
		callBlock: 	[ 
		self
			commit_lookup: self
			repo: self repository
			id:[..]
	Receiver's instance variables: 
		handle: 	@ 16r00000000
		repository: 	a LGitRepository (/Users/ryanperez/Documents/GitHub/pp-rep2533)
		id: 	nil


LGitCommit>>lookup
	Receiver: a LGitCommit (<not initialized>)
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		handle: 	@ 16r00000000
		repository: 	a LGitRepository (/Users/ryanperez/Documents/GitHub/pp-rep2533)
		id: 	nil


LGitCommit(LGitObject)>>initializeWithId:
	Receiver: a LGitCommit (<not initialized>)
	Arguments and temporary variables: 
		gitOid: 	nil
	Receiver's instance variables: 
		handle: 	@ 16r00000000
		repository: 	a LGitRepository (/Users/ryanperez/Documents/GitHub/pp-rep2533)
		id: 	nil


LGitCommit class(LGitObject class)>>of:fromId:
	Receiver: LGitCommit
	Arguments and temporary variables: 
		aRepository: 	a LGitRepository (/Users/ryanperez/Documents/GitHub/pp-rep2533)
		id: 	nil
	Receiver's instance variables: 
		superclass: 	LGitObject
		methodDict: 	a MethodDictionary(#=->LGitCommit>>#= #asIcebergObjectInReposit[..]
		format: 	65539
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		commentSourcePointer: 	nil
		subclasses: 	#()
		name: 	#LGitCommit
		classPool: 	nil
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'LibGit-Core-CoreObjects'


[ | gitCommit gitId |
		gitId := (self repositoryHandle lookupRemoteBranch: self name) targetId.
		gitCommit := LGitCommit of: self repositoryHandle fromId: gitId.
		^ self repository commitFromGitCommit: gitCommit ] in IceGitRemoteBranch>>commit
	Receiver: IceGitRemoteBranch(origin/HEAD)
	Arguments and temporary variables: 
		gitCommit: 	nil
		gitId: 	nil
	Receiver's instance variables: 
		repository: 	IceLibgitRepository(pp-rep2533)
		name: 	'refs/remotes/origin/HEAD'


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [ | gitCommit gitId |
		gitId := (self repositoryHandle lookupRemoteBranch: self name)[..]
	Arguments and temporary variables: 
		exception: 	LGitCallReturnHandler
		handlerAction: 	[ :error | error acceptError: (IceLibgitErrorVisitor onConte[..]
	Receiver's instance variables: 
		outerContext: 	IceGitRemoteBranch>>commit
		compiledBlock: 	a CompiledBlock: [ | gitCommit gitId |
		gitId := (self repo[..]
		numArgs: 	0
		receiver: 	IceGitRemoteBranch(origin/HEAD)


IceLibgitRepository>>handleLibgitError:
	Receiver: IceLibgitRepository(pp-rep2533)
	Arguments and temporary variables: 
		aBlock: 	[ | gitCommit gitId |
		gitId := (self repositoryHandle lookupRemot[..]
	Receiver's instance variables: 
		name: 	'pp-rep2533'
		workingCopy: 	an IceWorkingCopy
		index: 	an IceGitIndex
		commitsInPackageCache: 	nil
		location: 	File @ /Users/ryanperez/Documents/GitHub/pp-rep2533
		commitCache: 	a LRUCache(#3 3/30 [ 1 ] 100%)
		handle: 	a LGitRepository (/Users/ryanperez/Documents/GitHub/pp-rep2533)


IceGitRemoteBranch>>commit
	Receiver: IceGitRemoteBranch(origin/HEAD)
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		repository: 	IceLibgitRepository(pp-rep2533)
		name: 	'refs/remotes/origin/HEAD'


IceGitRemoteBranch(IceCommitish)>>changesTo:
	Receiver: IceGitRemoteBranch(origin/HEAD)
	Arguments and temporary variables: 
		aCommitish: 	an IceWorkingCopy
	Receiver's instance variables: 
		repository: 	IceLibgitRepository(pp-rep2533)
		name: 	'refs/remotes/origin/HEAD'


IceDiff>>build
	Receiver: an IceDiff
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		tree: 	nil
		source: 	IceGitRemoteBranch(origin/HEAD)
		target: 	an IceWorkingCopy
		writerClass: 	nil
		mergedTree: 	nil


IceDiff class>>from:to:
	Receiver: IceDiff
	Arguments and temporary variables: 
		sourceCommitish: 	IceGitRemoteBranch(origin/HEAD)
		targetCommitish: 	an IceWorkingCopy
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary(#accept:->IceDiff>>#accept: #build->IceDiff>[..]
		format: 	65541
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		commentSourcePointer: 	nil
		subclasses: 	nil
		name: 	#IceDiff
		classPool: 	nil
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Iceberg-Changes'


IceGitRemoteBranch(IceCommitish)>>diffTo:
	Receiver: IceGitRemoteBranch(origin/HEAD)
	Arguments and temporary variables: 
		aCommitish: 	an IceWorkingCopy
	Receiver's instance variables: 
		repository: 	IceLibgitRepository(pp-rep2533)
		name: 	'refs/remotes/origin/HEAD'


IceTipCheckoutModel>>calculateDiff
	Receiver: an IceTipCheckoutModel
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		commitish: 	an IceTipBranchModel[origin/HEAD]
		diffModel: 	nil
		checkoutStrategy: 	an IceCheckoutAlreadyLoadedPackages
		checkoutStrategies: 	an OrderedCollection(an IceCheckoutAlreadyLoadedPackage[..]


[ diff := self calculateDiff ] in IceTipCheckoutModel(IceTipDiffPreviewModel)>>diff
	Receiver: an IceTipCheckoutModel
	Arguments and temporary variables: 
		diff: 	nil
	Receiver's instance variables: 
		commitish: 	an IceTipBranchModel[origin/HEAD]
		diffModel: 	nil
		checkoutStrategy: 	an IceCheckoutAlreadyLoadedPackages
		checkoutStrategies: 	an OrderedCollection(an IceCheckoutAlreadyLoadedPackage[..]


[:bar | bar label: aString. aBlock value] in MorphicUIManager(UIManager)>>informUser:during:
	Receiver: a MorphicUIManager
	Arguments and temporary variables: 
		aString: 	'Calculating diff'
		aBlock: 	[ diff := self calculateDiff ]
		bar: 	a Job
	Receiver's instance variables: 
		activeTranscript: 	nil


[:bar | aBlock value: bar] in MorphicUIManager>>informUserDuring:
	Receiver: a MorphicUIManager
	Arguments and temporary variables: 
		aBlock: 	[:bar | bar label: aString. aBlock value]
		bar: 	a Job
	Receiver's instance variables: 
		activeTranscript: 	nil


FullBlockClosure(BlockClosure)>>cull:
	Receiver: [:bar | aBlock value: bar]
	Arguments and temporary variables: 
		anArg: 	a Job
	Receiver's instance variables: 
		outerContext: 	MorphicUIManager>>informUserDuring:
		compiledBlock: 	a CompiledBlock: [:bar | aBlock value: bar]
		numArgs: 	1
		receiver: 	a MorphicUIManager


[ ^ block cull: self ] in [ self prepareForRunning.
	  CurrentJob value: self during: [ ^ block cull: self ] ] in Job>>run
	Receiver: a Job
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		block: 	[:bar | aBlock value: bar]
		currentValue: 	1
		min: 	1
		max: 	100
		title: 	'Calculating diff'
		children: 	an OrderedCollection()
		isRunning: 	true
		parent: 	nil
		process: 	a Process in nil
		owner: 	a MorphicUIManager


[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in CurrentJob(DynamicVariable)>>value:during:
	Receiver: a CurrentJob
	Arguments and temporary variables: 
		anObject: 	a Job
		aBlock: 	[ ^ block cull: self ]
		activeProcess: 	a Process in nil
		oldValue: 	nil
	Receiver's instance variables: 
		index: 	2


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ]
	Arguments and temporary variables: 
		aBlock: 	[
			activeProcess
				psValueAt: index
				put: oldValue ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	CurrentJob(DynamicVariable)>>value:during:
		compiledBlock: 	a CompiledBlock: [ activeProcess
			psValueAt: index
			put:[..]
		numArgs: 	0
		receiver: 	a CurrentJob


CurrentJob(DynamicVariable)>>value:during:
	Receiver: a CurrentJob
	Arguments and temporary variables: 
		anObject: 	a Job
		aBlock: 	[ ^ block cull: self ]
		activeProcess: 	a Process in nil
		oldValue: 	nil
	Receiver's instance variables: 
		index: 	2


CurrentJob class(DynamicVariable class)>>value:during:
	Receiver: CurrentJob
	Arguments and temporary variables: 
		anObject: 	a Job
		aBlock: 	[ ^ block cull: self ]
	Receiver's instance variables: 
		superclass: 	DynamicVariable
		methodDict: 	a MethodDictionary()
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		commentSourcePointer: 	nil
		subclasses: 	nil
		name: 	#CurrentJob
		classPool: 	nil
		sharedPools: 	nil
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Jobs-Base'
		soleInstance: 	a CurrentJob


[ self prepareForRunning.
	  CurrentJob value: self during: [ ^ block cull: self ] ] in Job>>run
	Receiver: a Job
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		block: 	[:bar | aBlock value: bar]
		currentValue: 	1
		min: 	1
		max: 	100
		title: 	'Calculating diff'
		children: 	an OrderedCollection()
		isRunning: 	true
		parent: 	nil
		process: 	a Process in nil
		owner: 	a MorphicUIManager


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ self prepareForRunning.
	  CurrentJob value: self during: [ ^ block cull: self ] ]
	Arguments and temporary variables: 
		aBlock: 	[ self cleanupAfterRunning ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	Job>>run
		compiledBlock: 	a CompiledBlock: [ self prepareForRunning.
	  CurrentJob val[..]
		numArgs: 	0
		receiver: 	a Job


Job>>run
	Receiver: a Job
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		block: 	[:bar | aBlock value: bar]
		currentValue: 	1
		min: 	1
		max: 	100
		title: 	'Calculating diff'
		children: 	an OrderedCollection()
		isRunning: 	true
		parent: 	nil
		process: 	a Process in nil
		owner: 	a MorphicUIManager


MorphicUIManager(UIManager)>>displayProgress:from:to:during:
	Receiver: a MorphicUIManager
	Arguments and temporary variables: 
		titleString: 	''
		minVal: 	1
		maxVal: 	100
		workBlock: 	[:bar | aBlock value: bar]
	Receiver's instance variables: 
		activeTranscript: 	nil


MorphicUIManager>>informUserDuring:
	Receiver: a MorphicUIManager
	Arguments and temporary variables: 
		aBlock: 	[:bar | bar label: aString. aBlock value]
	Receiver's instance variables: 
		activeTranscript: 	nil


MorphicUIManager(UIManager)>>informUser:during:
	Receiver: a MorphicUIManager
	Arguments and temporary variables: 
		aString: 	'Calculating diff'
		aBlock: 	[ diff := self calculateDiff ]
	Receiver's instance variables: 
		activeTranscript: 	nil


IceTipCheckoutModel(IceTipDiffPreviewModel)>>diff
	Receiver: an IceTipCheckoutModel
	Arguments and temporary variables: 
		diff: 	nil
	Receiver's instance variables: 
		commitish: 	an IceTipBranchModel[origin/HEAD]
		diffModel: 	nil
		checkoutStrategy: 	an IceCheckoutAlreadyLoadedPackages
		checkoutStrategies: 	an OrderedCollection(an IceCheckoutAlreadyLoadedPackage[..]



--- The full stack ---
IceLibgitErrorVisitor>>visitGenericError:
IceLibgitErrorVisitor>>visitERROR:
LGit_GIT_ERROR>>acceptError:
[ :error | error acceptError: (IceLibgitErrorVisitor onContext: self) ] in IceLibgitRepository>>handleLibgitError:
FullBlockClosure(BlockClosure)>>cull:
Context>>evaluateSignal:
Context>>handleSignal:
LGit_GIT_ERROR(Exception)>>signal
LGit_GIT_ERROR class(LGitCallReturnHandler class)>>signalWith:
LGitReturnCodeEnum>>handleLGitReturnCode
LGitCommit(LGitExternalObject)>>withReturnHandlerDo:
LGitCommit>>lookup
LGitCommit(LGitObject)>>initializeWithId:
LGitCommit class(LGitObject class)>>of:fromId:
[ | gitCommit gitId |
		gitId := (self repositoryHandle lookupRemoteBranch: self name) targetId.
		gitCommit := LGitCommit of: self repositoryHandle fromId: gitId.
		^ self repository commitFromGitCommit: gitCommit ] in IceGitRemoteBranch>>commit
FullBlockClosure(BlockClosure)>>on:do:
IceLibgitRepository>>handleLibgitError:
IceGitRemoteBranch>>commit
IceGitRemoteBranch(IceCommitish)>>changesTo:
IceDiff>>build
IceDiff class>>from:to:
IceGitRemoteBranch(IceCommitish)>>diffTo:
IceTipCheckoutModel>>calculateDiff
[ diff := self calculateDiff ] in IceTipCheckoutModel(IceTipDiffPreviewModel)>>diff
[:bar | bar label: aString. aBlock value] in MorphicUIManager(UIManager)>>informUser:during:
[:bar | aBlock value: bar] in MorphicUIManager>>informUserDuring:
FullBlockClosure(BlockClosure)>>cull:
[ ^ block cull: self ] in [ self prepareForRunning.
	  CurrentJob value: self during: [ ^ block cull: self ] ] in Job>>run
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in CurrentJob(DynamicVariable)>>value:during:
FullBlockClosure(BlockClosure)>>ensure:
CurrentJob(DynamicVariable)>>value:during:
CurrentJob class(DynamicVariable class)>>value:during:
[ self prepareForRunning.
	  CurrentJob value: self during: [ ^ block cull: self ] ] in Job>>run
FullBlockClosure(BlockClosure)>>ensure:
Job>>run
MorphicUIManager(UIManager)>>displayProgress:from:to:during:
MorphicUIManager>>informUserDuring:
MorphicUIManager(UIManager)>>informUser:during:
IceTipCheckoutModel(IceTipDiffPreviewModel)>>diff
 - - - - - - - - - - - - - - -
			- - - - - - - - - - - - - - - - - -
IceTipCheckoutPreviewBrowser(IceTipPreviewBrowser)>>initializePresenters
IceTipCheckoutPreviewBrowser>>initializePresenters
IceTipCheckoutPreviewBrowser(SpPresenter)>>initializePrivateHooks
IceTipCheckoutPreviewBrowser(SpPresenter)>>initialize
IceTipCheckoutPreviewBrowser(IceTipBrowser)>>initialize
IceTipCheckoutPreviewBrowser class(SpPresenter class)>>newApplication:model:
IceTipCheckoutPreviewBrowser class(SpPresenter class)>>on:
IceTipCheckoutPreviewBrowser class>>onBranch:
IceTipBranchModel>>previewCheckout
IceTipCachedModel>>forwardMessage:
IceTipCachedModel>>doesNotUnderstand: #previewCheckout
IceTipCheckoutBranchPanel>>doAccept
IceTipCheckoutBranchDialog>>doAccept
[ 
	  self doAccept.
	  self closeWindow ] in IceTipCheckoutBranchDialog(IceTipOptionDialog)>>accept
FullBlockClosure(BlockClosure)>>on:do:
IceTipCheckoutBranchDialog(IceTipOptionDialog)>>accept
[ :presenter | self accept ] in IceTipCheckoutBranchDialog(IceTipOptionDialog)>>initializeDialogWindow:
FullBlockClosure(BlockClosure)>>cull:
[ aBlock cull: self ] in SpDialogWindowPresenter>>addButton:do:
SpButtonPresenter>>performAction
SpMorphicButtonAdapter>>action
SpPluggableButtonMorph(PluggableButtonMorph)>>performAction:
[:m |
		(m containsPoint: evt cursorPoint) ifTrue: [m enabled ifTrue: [ m performAction: evt ]]] in SpPluggableButtonMorph(PluggableButtonMorph)>>mouseUp:
Array(SequenceableCollection)>>do:
SpPluggableButtonMorph(PluggableButtonMorph)>>mouseUp:
SpPluggableButtonMorph(Morph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
SpPluggableButtonMorph(Morph)>>handleEvent:
SpPluggableButtonMorph(Morph)>>handleFocusEvent:
[
		result := focusHolder handleFocusEvent: transformedEvent.
	] in HandMorph>>sendFocusEvent:to:clear:
FullBlockClosure(BlockClosure)>>on:do:
WorldMorph>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil ]) ifTrue: [
			morphicWorld activeHand handleEvent: anEvent
		]
	] in OSWindowMorphicEventHandler>>dispatchMorphicEvent:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycleNow
WorldMorph>>doOneCycle
[
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMutex critical: [
			                     self extraWorldList ].
		extraWorldsToDraw do: [ :world | world doOneCycle ].

		(self currentWorld isNotNil and: [
			 (extraWorldsToDraw includes: self currentWorld) not ]) ifTrue: [
			self currentWorld doOneCycle ] ] in WorldMorph class>>doOneCycle
FullBlockClosure(BlockClosure)>>ensure:
WorldState class>>doDrawCycleWith:
WorldMorph class>>doOneCycle
MorphicRenderLoop>>doOneCycle
MorphicRenderLoop>>doOneCycleWhile:
[ MorphicRenderLoop new doOneCycleWhile: [ true ] ] in MorphicUIManager>>spawnNewProcess
[self value.
			"IMPORTANT: Do not step over next line of code. See method comments for details"
			Processor terminateRealActive] in FullBlockClosure(BlockClosure)>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
IceGenericError: invalid argument: 'id'
13 November 2023 11:36:36.454138 pm

VM: Mac OS - arm64 - 1000 - CoInterpreter VMMaker-tonel.1 uuid: 902dd483-c0c4-0d00-86f2-0f880df24b96 Oct 23 2023
StackToRegisterMappingCogit VMMaker-tonel.1 uuid: 902dd483-c0c4-0d00-86f2-0f880df24b96 Oct 23 2023
v10.0.8 - Commit: b323c5fb - Date: 2023-10-20 16:02:07 -0400

Image: Pharo11.0.0 [Build information: Pharo-11.0.0+build.710.sha.ea28d8552cac85a7ce1e9c34ab1e7bd45f7b9910 (64 Bit)]

IceLibgitErrorVisitor>>visitGenericError:
	Receiver: an IceLibgitErrorVisitor
	Arguments and temporary variables: 
		anError: 	LGit_GIT_ERROR: invalid argument: 'id'
	Receiver's instance variables: 
		context: 	IceLibgitRepository(pp-rep2533)


IceLibgitErrorVisitor>>visitERROR:
	Receiver: an IceLibgitErrorVisitor
	Arguments and temporary variables: 
		anError: 	LGit_GIT_ERROR: invalid argument: 'id'
	Receiver's instance variables: 
		context: 	IceLibgitRepository(pp-rep2533)


LGit_GIT_ERROR>>acceptError:
	Receiver: LGit_GIT_ERROR: invalid argument: 'id'
	Arguments and temporary variables: 
		aVisitor: 	an IceLibgitErrorVisitor
	Receiver's instance variables: 
		messageText: 	'invalid argument: ''id'''
		tag: 	nil
		signaler: 	a LGitReturnCodeEnum(#git_error [-1])
		signalContext: 	LGit_GIT_ERROR(Exception)>>signal
		handlerContext: 	FullBlockClosure(BlockClosure)>>on:do:
		outerContext: 	nil
		object: 	a LGitErrorTypeEnum(#giterr_invalid [3])


[ :error | error acceptError: (IceLibgitErrorVisitor onContext: self) ] in IceLibgitRepository>>handleLibgitError:
	Receiver: IceLibgitRepository(pp-rep2533)
	Arguments and temporary variables: 
		aBlock: 	[ | gitCommit gitId |
		gitId := (self repositoryHandle lookupRemot[..]
		error: 	LGit_GIT_ERROR: invalid argument: 'id'
	Receiver's instance variables: 
		name: 	'pp-rep2533'
		workingCopy: 	an IceWorkingCopy
		index: 	an IceGitIndex
		commitsInPackageCache: 	nil
		location: 	File @ /Users/ryanperez/Documents/GitHub/pp-rep2533
		commitCache: 	a LRUCache(#3 3/30 [ 1 ] 100%)
		handle: 	a LGitRepository (/Users/ryanperez/Documents/GitHub/pp-rep2533)


FullBlockClosure(BlockClosure)>>cull:
	Receiver: [ :error | error acceptError: (IceLibgitErrorVisitor onContext: self) ]
	Arguments and temporary variables: 
		anArg: 	LGit_GIT_ERROR: invalid argument: 'id'
	Receiver's instance variables: 
		outerContext: 	IceLibgitRepository>>handleLibgitError:
		compiledBlock: 	a CompiledBlock: [ :error | error acceptError: (IceLibgitErr[..]
		numArgs: 	1
		receiver: 	IceLibgitRepository(pp-rep2533)


Context>>evaluateSignal:
	Receiver: FullBlockClosure(BlockClosure)>>on:do:
	Arguments and temporary variables: 
		exception: 	LGit_GIT_ERROR: invalid argument: 'id'
		value: 	nil
	Receiver's instance variables: 
		sender: 	IceLibgitRepository>>handleLibgitError:
		pc: 	30
		stackp: 	2
		method: 	BlockClosure>>#on:do:
		closureOrNil: 	nil
		receiver: 	[ | gitCommit gitId |
		gitId := (self repositoryHandle lookupRem[..]


Context>>handleSignal:
	Receiver: FullBlockClosure(BlockClosure)>>on:do:
	Arguments and temporary variables: 
		exception: 	LGit_GIT_ERROR: invalid argument: 'id'
	Receiver's instance variables: 
		sender: 	IceLibgitRepository>>handleLibgitError:
		pc: 	30
		stackp: 	2
		method: 	BlockClosure>>#on:do:
		closureOrNil: 	nil
		receiver: 	[ | gitCommit gitId |
		gitId := (self repositoryHandle lookupRem[..]


LGit_GIT_ERROR(Exception)>>signal
	Receiver: LGit_GIT_ERROR: invalid argument: 'id'
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		messageText: 	'invalid argument: ''id'''
		tag: 	nil
		signaler: 	a LGitReturnCodeEnum(#git_error [-1])
		signalContext: 	LGit_GIT_ERROR(Exception)>>signal
		handlerContext: 	FullBlockClosure(BlockClosure)>>on:do:
		outerContext: 	nil
		object: 	a LGitErrorTypeEnum(#giterr_invalid [3])


LGit_GIT_ERROR class(LGitCallReturnHandler class)>>signalWith:
	Receiver: LGit_GIT_ERROR
	Arguments and temporary variables: 
		anError: 	a LGitError ()
	Receiver's instance variables: 
		superclass: 	LGitCallReturnHandler
		methodDict: 	a MethodDictionary(#acceptError:->LGit_GIT_ERROR>>#acceptError: )
		format: 	65543
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		commentSourcePointer: 	nil
		subclasses: 	nil
		name: 	#LGit_GIT_ERROR
		classPool: 	nil
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'LibGit-Core-Exceptions-ReturnCodes'


LGitReturnCodeEnum>>handleLGitReturnCode
	Receiver: a LGitReturnCodeEnum(#git_error [-1])
	Arguments and temporary variables: 
		handler: 	LGit_GIT_ERROR
	Receiver's instance variables: 
		value: 	-1


LGitCommit(LGitExternalObject)>>withReturnHandlerDo:
	Receiver: a LGitCommit (<not initialized>)
	Arguments and temporary variables: 
		callBlock: 	[ 
		self
			commit_lookup: self
			repo: self repository
			id:[..]
	Receiver's instance variables: 
		handle: 	@ 16r00000000
		repository: 	a LGitRepository (/Users/ryanperez/Documents/GitHub/pp-rep2533)
		id: 	nil


LGitCommit>>lookup
	Receiver: a LGitCommit (<not initialized>)
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		handle: 	@ 16r00000000
		repository: 	a LGitRepository (/Users/ryanperez/Documents/GitHub/pp-rep2533)
		id: 	nil


LGitCommit(LGitObject)>>initializeWithId:
	Receiver: a LGitCommit (<not initialized>)
	Arguments and temporary variables: 
		gitOid: 	nil
	Receiver's instance variables: 
		handle: 	@ 16r00000000
		repository: 	a LGitRepository (/Users/ryanperez/Documents/GitHub/pp-rep2533)
		id: 	nil


LGitCommit class(LGitObject class)>>of:fromId:
	Receiver: LGitCommit
	Arguments and temporary variables: 
		aRepository: 	a LGitRepository (/Users/ryanperez/Documents/GitHub/pp-rep2533)
		id: 	nil
	Receiver's instance variables: 
		superclass: 	LGitObject
		methodDict: 	a MethodDictionary(#=->LGitCommit>>#= #asIcebergObjectInReposit[..]
		format: 	65539
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		commentSourcePointer: 	nil
		subclasses: 	#()
		name: 	#LGitCommit
		classPool: 	nil
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'LibGit-Core-CoreObjects'


[ | gitCommit gitId |
		gitId := (self repositoryHandle lookupRemoteBranch: self name) targetId.
		gitCommit := LGitCommit of: self repositoryHandle fromId: gitId.
		^ self repository commitFromGitCommit: gitCommit ] in IceGitRemoteBranch>>commit
	Receiver: IceGitRemoteBranch(origin/HEAD)
	Arguments and temporary variables: 
		gitCommit: 	nil
		gitId: 	nil
	Receiver's instance variables: 
		repository: 	IceLibgitRepository(pp-rep2533)
		name: 	'refs/remotes/origin/HEAD'


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [ | gitCommit gitId |
		gitId := (self repositoryHandle lookupRemoteBranch: self name)[..]
	Arguments and temporary variables: 
		exception: 	LGitCallReturnHandler
		handlerAction: 	[ :error | error acceptError: (IceLibgitErrorVisitor onConte[..]
	Receiver's instance variables: 
		outerContext: 	IceGitRemoteBranch>>commit
		compiledBlock: 	a CompiledBlock: [ | gitCommit gitId |
		gitId := (self repo[..]
		numArgs: 	0
		receiver: 	IceGitRemoteBranch(origin/HEAD)


IceLibgitRepository>>handleLibgitError:
	Receiver: IceLibgitRepository(pp-rep2533)
	Arguments and temporary variables: 
		aBlock: 	[ | gitCommit gitId |
		gitId := (self repositoryHandle lookupRemot[..]
	Receiver's instance variables: 
		name: 	'pp-rep2533'
		workingCopy: 	an IceWorkingCopy
		index: 	an IceGitIndex
		commitsInPackageCache: 	nil
		location: 	File @ /Users/ryanperez/Documents/GitHub/pp-rep2533
		commitCache: 	a LRUCache(#3 3/30 [ 1 ] 100%)
		handle: 	a LGitRepository (/Users/ryanperez/Documents/GitHub/pp-rep2533)


IceGitRemoteBranch>>commit
	Receiver: IceGitRemoteBranch(origin/HEAD)
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		repository: 	IceLibgitRepository(pp-rep2533)
		name: 	'refs/remotes/origin/HEAD'


IceGitRemoteBranch(IceCommitish)>>changesTo:
	Receiver: IceGitRemoteBranch(origin/HEAD)
	Arguments and temporary variables: 
		aCommitish: 	an IceWorkingCopy
	Receiver's instance variables: 
		repository: 	IceLibgitRepository(pp-rep2533)
		name: 	'refs/remotes/origin/HEAD'


IceDiff>>build
	Receiver: an IceDiff
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		tree: 	nil
		source: 	IceGitRemoteBranch(origin/HEAD)
		target: 	an IceWorkingCopy
		writerClass: 	nil
		mergedTree: 	nil


IceDiff class>>from:to:
	Receiver: IceDiff
	Arguments and temporary variables: 
		sourceCommitish: 	IceGitRemoteBranch(origin/HEAD)
		targetCommitish: 	an IceWorkingCopy
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary(#accept:->IceDiff>>#accept: #build->IceDiff>[..]
		format: 	65541
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		commentSourcePointer: 	nil
		subclasses: 	nil
		name: 	#IceDiff
		classPool: 	nil
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Iceberg-Changes'


IceGitRemoteBranch(IceCommitish)>>diffTo:
	Receiver: IceGitRemoteBranch(origin/HEAD)
	Arguments and temporary variables: 
		aCommitish: 	an IceWorkingCopy
	Receiver's instance variables: 
		repository: 	IceLibgitRepository(pp-rep2533)
		name: 	'refs/remotes/origin/HEAD'


IceTipCheckoutModel>>calculateDiff
	Receiver: an IceTipCheckoutModel
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		commitish: 	an IceTipBranchModel[origin/HEAD]
		diffModel: 	nil
		checkoutStrategy: 	an IceCheckoutAlreadyLoadedPackages
		checkoutStrategies: 	an OrderedCollection(an IceCheckoutAlreadyLoadedPackage[..]


[ diff := self calculateDiff ] in IceTipCheckoutModel(IceTipDiffPreviewModel)>>diff
	Receiver: an IceTipCheckoutModel
	Arguments and temporary variables: 
		diff: 	nil
	Receiver's instance variables: 
		commitish: 	an IceTipBranchModel[origin/HEAD]
		diffModel: 	nil
		checkoutStrategy: 	an IceCheckoutAlreadyLoadedPackages
		checkoutStrategies: 	an OrderedCollection(an IceCheckoutAlreadyLoadedPackage[..]


[:bar | bar label: aString. aBlock value] in MorphicUIManager(UIManager)>>informUser:during:
	Receiver: a MorphicUIManager
	Arguments and temporary variables: 
		aString: 	'Calculating diff'
		aBlock: 	[ diff := self calculateDiff ]
		bar: 	a Job
	Receiver's instance variables: 
		activeTranscript: 	nil


[:bar | aBlock value: bar] in MorphicUIManager>>informUserDuring:
	Receiver: a MorphicUIManager
	Arguments and temporary variables: 
		aBlock: 	[:bar | bar label: aString. aBlock value]
		bar: 	a Job
	Receiver's instance variables: 
		activeTranscript: 	nil


FullBlockClosure(BlockClosure)>>cull:
	Receiver: [:bar | aBlock value: bar]
	Arguments and temporary variables: 
		anArg: 	a Job
	Receiver's instance variables: 
		outerContext: 	MorphicUIManager>>informUserDuring:
		compiledBlock: 	a CompiledBlock: [:bar | aBlock value: bar]
		numArgs: 	1
		receiver: 	a MorphicUIManager


[ ^ block cull: self ] in [ self prepareForRunning.
	  CurrentJob value: self during: [ ^ block cull: self ] ] in Job>>run
	Receiver: a Job
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		block: 	[:bar | aBlock value: bar]
		currentValue: 	1
		min: 	1
		max: 	100
		title: 	'Calculating diff'
		children: 	an OrderedCollection()
		isRunning: 	true
		parent: 	nil
		process: 	a Process in nil
		owner: 	a MorphicUIManager


[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in CurrentJob(DynamicVariable)>>value:during:
	Receiver: a CurrentJob
	Arguments and temporary variables: 
		anObject: 	a Job
		aBlock: 	[ ^ block cull: self ]
		activeProcess: 	a Process in nil
		oldValue: 	nil
	Receiver's instance variables: 
		index: 	2


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ]
	Arguments and temporary variables: 
		aBlock: 	[
			activeProcess
				psValueAt: index
				put: oldValue ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	CurrentJob(DynamicVariable)>>value:during:
		compiledBlock: 	a CompiledBlock: [ activeProcess
			psValueAt: index
			put:[..]
		numArgs: 	0
		receiver: 	a CurrentJob


CurrentJob(DynamicVariable)>>value:during:
	Receiver: a CurrentJob
	Arguments and temporary variables: 
		anObject: 	a Job
		aBlock: 	[ ^ block cull: self ]
		activeProcess: 	a Process in nil
		oldValue: 	nil
	Receiver's instance variables: 
		index: 	2


CurrentJob class(DynamicVariable class)>>value:during:
	Receiver: CurrentJob
	Arguments and temporary variables: 
		anObject: 	a Job
		aBlock: 	[ ^ block cull: self ]
	Receiver's instance variables: 
		superclass: 	DynamicVariable
		methodDict: 	a MethodDictionary()
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		commentSourcePointer: 	nil
		subclasses: 	nil
		name: 	#CurrentJob
		classPool: 	nil
		sharedPools: 	nil
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Jobs-Base'
		soleInstance: 	a CurrentJob


[ self prepareForRunning.
	  CurrentJob value: self during: [ ^ block cull: self ] ] in Job>>run
	Receiver: a Job
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		block: 	[:bar | aBlock value: bar]
		currentValue: 	1
		min: 	1
		max: 	100
		title: 	'Calculating diff'
		children: 	an OrderedCollection()
		isRunning: 	true
		parent: 	nil
		process: 	a Process in nil
		owner: 	a MorphicUIManager


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ self prepareForRunning.
	  CurrentJob value: self during: [ ^ block cull: self ] ]
	Arguments and temporary variables: 
		aBlock: 	[ self cleanupAfterRunning ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	Job>>run
		compiledBlock: 	a CompiledBlock: [ self prepareForRunning.
	  CurrentJob val[..]
		numArgs: 	0
		receiver: 	a Job


Job>>run
	Receiver: a Job
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		block: 	[:bar | aBlock value: bar]
		currentValue: 	1
		min: 	1
		max: 	100
		title: 	'Calculating diff'
		children: 	an OrderedCollection()
		isRunning: 	true
		parent: 	nil
		process: 	a Process in nil
		owner: 	a MorphicUIManager


MorphicUIManager(UIManager)>>displayProgress:from:to:during:
	Receiver: a MorphicUIManager
	Arguments and temporary variables: 
		titleString: 	''
		minVal: 	1
		maxVal: 	100
		workBlock: 	[:bar | aBlock value: bar]
	Receiver's instance variables: 
		activeTranscript: 	nil


MorphicUIManager>>informUserDuring:
	Receiver: a MorphicUIManager
	Arguments and temporary variables: 
		aBlock: 	[:bar | bar label: aString. aBlock value]
	Receiver's instance variables: 
		activeTranscript: 	nil


MorphicUIManager(UIManager)>>informUser:during:
	Receiver: a MorphicUIManager
	Arguments and temporary variables: 
		aString: 	'Calculating diff'
		aBlock: 	[ diff := self calculateDiff ]
	Receiver's instance variables: 
		activeTranscript: 	nil


IceTipCheckoutModel(IceTipDiffPreviewModel)>>diff
	Receiver: an IceTipCheckoutModel
	Arguments and temporary variables: 
		diff: 	nil
	Receiver's instance variables: 
		commitish: 	an IceTipBranchModel[origin/HEAD]
		diffModel: 	nil
		checkoutStrategy: 	an IceCheckoutAlreadyLoadedPackages
		checkoutStrategies: 	an OrderedCollection(an IceCheckoutAlreadyLoadedPackage[..]



--- The full stack ---
IceLibgitErrorVisitor>>visitGenericError:
IceLibgitErrorVisitor>>visitERROR:
LGit_GIT_ERROR>>acceptError:
[ :error | error acceptError: (IceLibgitErrorVisitor onContext: self) ] in IceLibgitRepository>>handleLibgitError:
FullBlockClosure(BlockClosure)>>cull:
Context>>evaluateSignal:
Context>>handleSignal:
LGit_GIT_ERROR(Exception)>>signal
LGit_GIT_ERROR class(LGitCallReturnHandler class)>>signalWith:
LGitReturnCodeEnum>>handleLGitReturnCode
LGitCommit(LGitExternalObject)>>withReturnHandlerDo:
LGitCommit>>lookup
LGitCommit(LGitObject)>>initializeWithId:
LGitCommit class(LGitObject class)>>of:fromId:
[ | gitCommit gitId |
		gitId := (self repositoryHandle lookupRemoteBranch: self name) targetId.
		gitCommit := LGitCommit of: self repositoryHandle fromId: gitId.
		^ self repository commitFromGitCommit: gitCommit ] in IceGitRemoteBranch>>commit
FullBlockClosure(BlockClosure)>>on:do:
IceLibgitRepository>>handleLibgitError:
IceGitRemoteBranch>>commit
IceGitRemoteBranch(IceCommitish)>>changesTo:
IceDiff>>build
IceDiff class>>from:to:
IceGitRemoteBranch(IceCommitish)>>diffTo:
IceTipCheckoutModel>>calculateDiff
[ diff := self calculateDiff ] in IceTipCheckoutModel(IceTipDiffPreviewModel)>>diff
[:bar | bar label: aString. aBlock value] in MorphicUIManager(UIManager)>>informUser:during:
[:bar | aBlock value: bar] in MorphicUIManager>>informUserDuring:
FullBlockClosure(BlockClosure)>>cull:
[ ^ block cull: self ] in [ self prepareForRunning.
	  CurrentJob value: self during: [ ^ block cull: self ] ] in Job>>run
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in CurrentJob(DynamicVariable)>>value:during:
FullBlockClosure(BlockClosure)>>ensure:
CurrentJob(DynamicVariable)>>value:during:
CurrentJob class(DynamicVariable class)>>value:during:
[ self prepareForRunning.
	  CurrentJob value: self during: [ ^ block cull: self ] ] in Job>>run
FullBlockClosure(BlockClosure)>>ensure:
Job>>run
MorphicUIManager(UIManager)>>displayProgress:from:to:during:
MorphicUIManager>>informUserDuring:
MorphicUIManager(UIManager)>>informUser:during:
IceTipCheckoutModel(IceTipDiffPreviewModel)>>diff
 - - - - - - - - - - - - - - -
			- - - - - - - - - - - - - - - - - -
IceTipCheckoutPreviewBrowser(IceTipPreviewBrowser)>>initializePresenters
IceTipCheckoutPreviewBrowser>>initializePresenters
IceTipCheckoutPreviewBrowser(SpPresenter)>>initializePrivateHooks
IceTipCheckoutPreviewBrowser(SpPresenter)>>initialize
IceTipCheckoutPreviewBrowser(IceTipBrowser)>>initialize
IceTipCheckoutPreviewBrowser class(SpPresenter class)>>newApplication:model:
IceTipCheckoutPreviewBrowser class(SpPresenter class)>>on:
IceTipCheckoutPreviewBrowser class>>onBranch:
IceTipBranchModel>>previewCheckout
IceTipCachedModel>>forwardMessage:
IceTipCachedModel>>doesNotUnderstand: #previewCheckout
IceTipCheckoutBranchPanel>>doAccept
IceTipCheckoutBranchDialog>>doAccept
[ 
	  self doAccept.
	  self closeWindow ] in IceTipCheckoutBranchDialog(IceTipOptionDialog)>>accept
FullBlockClosure(BlockClosure)>>on:do:
IceTipCheckoutBranchDialog(IceTipOptionDialog)>>accept
[ :presenter | self accept ] in IceTipCheckoutBranchDialog(IceTipOptionDialog)>>initializeDialogWindow:
FullBlockClosure(BlockClosure)>>cull:
[ aBlock cull: self ] in SpDialogWindowPresenter>>addButton:do:
SpButtonPresenter>>performAction
SpMorphicButtonAdapter>>action
SpPluggableButtonMorph(PluggableButtonMorph)>>performAction:
[:m |
		(m containsPoint: evt cursorPoint) ifTrue: [m enabled ifTrue: [ m performAction: evt ]]] in SpPluggableButtonMorph(PluggableButtonMorph)>>mouseUp:
Array(SequenceableCollection)>>do:
SpPluggableButtonMorph(PluggableButtonMorph)>>mouseUp:
SpPluggableButtonMorph(Morph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
SpPluggableButtonMorph(Morph)>>handleEvent:
SpPluggableButtonMorph(Morph)>>handleFocusEvent:
[
		result := focusHolder handleFocusEvent: transformedEvent.
	] in HandMorph>>sendFocusEvent:to:clear:
FullBlockClosure(BlockClosure)>>on:do:
WorldMorph>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil ]) ifTrue: [
			morphicWorld activeHand handleEvent: anEvent
		]
	] in OSWindowMorphicEventHandler>>dispatchMorphicEvent:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycleNow
WorldMorph>>doOneCycle
[
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMutex critical: [
			                     self extraWorldList ].
		extraWorldsToDraw do: [ :world | world doOneCycle ].

		(self currentWorld isNotNil and: [
			 (extraWorldsToDraw includes: self currentWorld) not ]) ifTrue: [
			self currentWorld doOneCycle ] ] in WorldMorph class>>doOneCycle
FullBlockClosure(BlockClosure)>>ensure:
WorldState class>>doDrawCycleWith:
WorldMorph class>>doOneCycle
MorphicRenderLoop>>doOneCycle
MorphicRenderLoop>>doOneCycleWhile:
[ MorphicRenderLoop new doOneCycleWhile: [ true ] ] in MorphicUIManager>>spawnNewProcess
[self value.
			"IMPORTANT: Do not step over next line of code. See method comments for details"
			Processor terminateRealActive] in FullBlockClosure(BlockClosure)>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
AssertionFailure: Project location does not seems to be a valid git repository.
13 November 2023 11:43:43.27409 pm

VM: Mac OS - arm64 - 1000 - CoInterpreter VMMaker-tonel.1 uuid: 902dd483-c0c4-0d00-86f2-0f880df24b96 Oct 23 2023
StackToRegisterMappingCogit VMMaker-tonel.1 uuid: 902dd483-c0c4-0d00-86f2-0f880df24b96 Oct 23 2023
v10.0.8 - Commit: b323c5fb - Date: 2023-10-20 16:02:07 -0400

Image: Pharo11.0.0 [Build information: Pharo-11.0.0+build.710.sha.ea28d8552cac85a7ce1e9c34ab1e7bd45f7b9910 (64 Bit)]

IceTipLocalRepositoryPanel(Object)>>assert:description:
	Receiver: an IceTipLocalRepositoryPanel
	Arguments and temporary variables: 
		aBlock: 	false
		aStringOrBlock: 	'Project location does not seems to be a valid git repository.'
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicGridAdapter)
		announcer: 	an Announcer
		owner: 	a SpDialogWindowPresenter
		adapter: 	a SpMorphicGridAdapter
		needRebuild: 	true
		eventHandler: 	nil
		application: 	a StPharoApplication
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ nil ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Untitled window' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpGridLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		decorations: 	nil
		projectLocationLabel: 	a SpLabelPresenter
		projectLocation: 	an IceTipDirectoryPresenter
		remoteLabel: 	nil
		remoteInputText: 	nil
		repository: 	nil


IceTipLocalRepositoryPanel>>validate
	Receiver: an IceTipLocalRepositoryPanel
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicGridAdapter)
		announcer: 	an Announcer
		owner: 	a SpDialogWindowPresenter
		adapter: 	a SpMorphicGridAdapter
		needRebuild: 	true
		eventHandler: 	nil
		application: 	a StPharoApplication
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ nil ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Untitled window' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpGridLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		decorations: 	nil
		projectLocationLabel: 	a SpLabelPresenter
		projectLocation: 	an IceTipDirectoryPresenter
		remoteLabel: 	nil
		remoteInputText: 	nil
		repository: 	nil


[ 
			dialog validate.
			self repositoryModel updateLocation: dialog location.
			true ] in IceTipRepairLocateRepository>>basicExecute
	Receiver: an IceTipRepairLocateRepository
	Arguments and temporary variables: 
		dialog: 	an IceTipLocalRepositoryPanel
	Receiver's instance variables: 
		context: 	an IceTipRepairRepositoryDialog
		repository: 	nil
		successBlock: 	nil
		repositoryModel: 	an IceTipCachedModel(an IceTipRepositoryModel)


FullBlockClosure(BlockClosure)>>cull:
	Receiver: [ 
			dialog validate.
			self repositoryModel updateLocation: dialog location.
			true ]
	Arguments and temporary variables: 
		anArg: 	a SpDialogWindowPresenter
	Receiver's instance variables: 
		outerContext: 	IceTipRepairLocateRepository>>basicExecute
		compiledBlock: 	a CompiledBlock: [ 
			dialog validate.
			self repositoryMo[..]
		numArgs: 	0
		receiver: 	an IceTipRepairLocateRepository


SpDialogWindowPresenter>>triggerOkAction
	Receiver: a SpDialogWindowPresenter
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicDialogWindowAdapter a SpDialogWind[..]
		announcer: 	an Announcer
		owner: 	nil
		adapter: 	a SpMorphicDialogWindowAdapter
		needRebuild: 	true
		eventHandler: 	nil
		application: 	a StPharoApplication
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ nil ]
		windowIcon: 	an ObservableValueHolder[ Form(16x16x32) ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ true ]
		titleHolder: 	an ObservableValueHolder[ 'Import from existing clone' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ nil ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		borderWidth: 	an ObservableValueHolder[ nil ]
		borderColor: 	an ObservableValueHolder[ nil ]
		dragEnabled: 	an ObservableValueHolder[ false ]
		dropEnabled: 	an ObservableValueHolder[ false ]
		color: 	an ObservableValueHolder[ nil ]
		help: 	an ObservableValueHolder[ nil ]
		enabled: 	an ObservableValueHolder[ true ]
		wantsDrop: 	an ObservableValueHolder[ [ :transfer | self dropEnabled ] ]
		acceptDrop: 	an ObservableValueHolder[ [ :transfer | ] ]
		deferredActions: 	nil
		presenter: 	an ObservableValueHolder[ an IceTipLocalRepositoryPanel ]
		initialPosition: 	an ObservableValueHolder[ nil ]
		initialExtent: 	an ObservableValueHolder[ (500@137) ]
		menu: 	an ObservableValueHolder[ nil ]
		centered: 	an ObservableValueHolder[ false ]
		isClosed: 	an ObservableValueHolder[ false ]
		toolbar: 	an ObservableValueHolder[ nil ]
		statusbar: 	an ObservableValueHolder[ nil ]
		window: 	an ObservableValueHolder[ a SpDialogWindowMorph(816775680) named: I[..]
		decorations: 	an ObservableValueHolder[ true ]
		resizable: 	an ObservableValueHolder[ true ]
		buttons: 	an OrderedCollection(a SpButtonPresenter a SpButtonPresenter)
		okAction: 	[ 
			dialog validate.
			self repositoryModel updateLocation: di[..]
		cancelAction: 	[ 
		cancelled := true.
		self close ]
		cancelled: 	true
		defaultButton: 	nil


[ :presenter | 
			presenter triggerOkAction.
			presenter close ] in IceTipLocalRepositoryPanel(SpAbstractPresenter)>>initializeDialogWindow:
	Receiver: an IceTipLocalRepositoryPanel
	Arguments and temporary variables: 
		aDialogWindowPresenter: 	a SpDialogWindowPresenter
		presenter: 	a SpDialogWindowPresenter
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicGridAdapter)
		announcer: 	an Announcer
		owner: 	a SpDialogWindowPresenter
		adapter: 	a SpMorphicGridAdapter
		needRebuild: 	true
		eventHandler: 	nil
		application: 	a StPharoApplication
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ nil ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Untitled window' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpGridLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		decorations: 	nil
		projectLocationLabel: 	a SpLabelPresenter
		projectLocation: 	an IceTipDirectoryPresenter
		remoteLabel: 	nil
		remoteInputText: 	nil
		repository: 	nil


FullBlockClosure(BlockClosure)>>cull:
	Receiver: [ :presenter | 
			presenter triggerOkAction.
			presenter close ]
	Arguments and temporary variables: 
		anArg: 	a SpDialogWindowPresenter
	Receiver's instance variables: 
		outerContext: 	IceTipLocalRepositoryPanel(SpAbstractPresenter)>>initializeDi[..]
		compiledBlock: 	a CompiledBlock: [ :presenter | 
			presenter triggerOkActio[..]
		numArgs: 	1
		receiver: 	an IceTipLocalRepositoryPanel


[ aBlock cull: self ] in SpDialogWindowPresenter>>addButton:do:
	Receiver: a SpDialogWindowPresenter
	Arguments and temporary variables: 
		aString: 	'Ok'
		aBlock: 	[ :presenter | 
			presenter triggerOkAction.
			presenter close ]
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicDialogWindowAdapter a SpDialogWind[..]
		announcer: 	an Announcer
		owner: 	nil
		adapter: 	a SpMorphicDialogWindowAdapter
		needRebuild: 	true
		eventHandler: 	nil
		application: 	a StPharoApplication
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ nil ]
		windowIcon: 	an ObservableValueHolder[ Form(16x16x32) ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ true ]
		titleHolder: 	an ObservableValueHolder[ 'Import from existing clone' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ nil ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		borderWidth: 	an ObservableValueHolder[ nil ]
		borderColor: 	an ObservableValueHolder[ nil ]
		dragEnabled: 	an ObservableValueHolder[ false ]
		dropEnabled: 	an ObservableValueHolder[ false ]
		color: 	an ObservableValueHolder[ nil ]
		help: 	an ObservableValueHolder[ nil ]
		enabled: 	an ObservableValueHolder[ true ]
		wantsDrop: 	an ObservableValueHolder[ [ :transfer | self dropEnabled ] ]
		acceptDrop: 	an ObservableValueHolder[ [ :transfer | ] ]
		deferredActions: 	nil
		presenter: 	an ObservableValueHolder[ an IceTipLocalRepositoryPanel ]
		initialPosition: 	an ObservableValueHolder[ nil ]
		initialExtent: 	an ObservableValueHolder[ (500@137) ]
		menu: 	an ObservableValueHolder[ nil ]
		centered: 	an ObservableValueHolder[ false ]
		isClosed: 	an ObservableValueHolder[ false ]
		toolbar: 	an ObservableValueHolder[ nil ]
		statusbar: 	an ObservableValueHolder[ nil ]
		window: 	an ObservableValueHolder[ a SpDialogWindowMorph(816775680) named: I[..]
		decorations: 	an ObservableValueHolder[ true ]
		resizable: 	an ObservableValueHolder[ true ]
		buttons: 	an OrderedCollection(a SpButtonPresenter a SpButtonPresenter)
		okAction: 	[ 
			dialog validate.
			self repositoryModel updateLocation: di[..]
		cancelAction: 	[ 
		cancelled := true.
		self close ]
		cancelled: 	true
		defaultButton: 	nil


SpButtonPresenter>>performAction
	Receiver: a SpButtonPresenter
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicButtonAdapter)
		announcer: 	an Announcer
		owner: 	a SpButtonBarPresenter
		adapter: 	a SpMorphicButtonAdapter
		needRebuild: 	true
		eventHandler: 	nil
		application: 	nil
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ nil ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Button' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpAbstractWidgetLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		borderWidth: 	an ObservableValueHolder[ nil ]
		borderColor: 	an ObservableValueHolder[ nil ]
		dragEnabled: 	an ObservableValueHolder[ false ]
		dropEnabled: 	an ObservableValueHolder[ false ]
		color: 	an ObservableValueHolder[ nil ]
		help: 	an ObservableValueHolder[ nil ]
		enabled: 	an ObservableValueHolder[ true ]
		wantsDrop: 	an ObservableValueHolder[ [ :transfer | self dropEnabled ] ]
		acceptDrop: 	an ObservableValueHolder[ [ :transfer | ] ]
		deferredActions: 	nil
		icon: 	an ObservableValueHolder[ nil ]
		label: 	an ObservableValueHolder[ 'Ok' ]
		action: 	an ObservableValueHolder[ [ aBlock cull: self ] ]
		actionPerformed: 	an ObservableValueHolder[ nil ]
		askBeforeChanging: 	an ObservableValueHolder[ false ]
		font: 	an ObservableValueHolder[ nil ]
		shortcut: 	an ObservableValueHolder[ nil ]
		state: 	an ObservableValueHolder[ false ]
		contextMenu: 	an ObservableValueHolder[ nil ]


SpMorphicButtonAdapter>>action
	Receiver: a SpMorphicButtonAdapter
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpPluggableButtonMorph(204482048))
		announcer: 	nil
		model: 	a SpButtonPresenter
		widget: 	a SpPluggableButtonMorph(204482048)
		selector: 	nil
		owner: 	a SpButtonPresenter
		unsubscribed: 	false
		subMenuWidget: 	nil
		styleName: 	nil


SpPluggableButtonMorph(PluggableButtonMorph)>>performAction:
	Receiver: a SpPluggableButtonMorph(204482048)
	Arguments and temporary variables: 
		event: 	[(685@505) mouseUp 818101 nil]
	Receiver's instance variables: 
		bounds: 	(643.0@485.0) corner: (743.0@515.0)
		owner: 	a PanelMorph(82750208)
		submorphs: 	an Array(an AlignmentMorph(6081280))
		fullBounds: 	nil
		color: 	(Color r: 0.9012707722385142 g: 0.9012707722385142 b: 0.901270772238[..]
		extension: 	a MorphExtension (1025126912) [eventHandler = a MorphicEventHand[..]
		borderWidth: 	1
		borderColor: 	#simple
		model: 	a SpMorphicButtonAdapter
		label: 	'Ok'
		icon: 	nil
		getIconSelector: 	nil
		getStateSelector: 	#state
		actionSelector: 	#action
		font: 	nil
		getLabelSelector: 	#label
		getMenuSelector: 	#menu:
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	#enabled
		getFontSelector: 	#font
		labelMorph: 	a LabelMorph(124643072)'Ok'
		iconMorph: 	nil
		iconPosition: 	#left
		lastState: 	false
		backgroundColor: 	nil


[:m |
		(m containsPoint: evt cursorPoint) ifTrue: [m enabled ifTrue: [ m performAction: evt ]]] in SpPluggableButtonMorph(PluggableButtonMorph)>>mouseUp:
	Receiver: a SpPluggableButtonMorph(204482048)
	Arguments and temporary variables: 
		evt: 	[(685@505) mouseUp 818101 nil]
		all: 	an Array(a SpPluggableButtonMorph(835258112) a SpPluggableButtonMorph([..]
		m: 	a SpPluggableButtonMorph(204482048)
	Receiver's instance variables: 
		bounds: 	(643.0@485.0) corner: (743.0@515.0)
		owner: 	a PanelMorph(82750208)
		submorphs: 	an Array(an AlignmentMorph(6081280))
		fullBounds: 	nil
		color: 	(Color r: 0.9012707722385142 g: 0.9012707722385142 b: 0.901270772238[..]
		extension: 	a MorphExtension (1025126912) [eventHandler = a MorphicEventHand[..]
		borderWidth: 	1
		borderColor: 	#simple
		model: 	a SpMorphicButtonAdapter
		label: 	'Ok'
		icon: 	nil
		getIconSelector: 	nil
		getStateSelector: 	#state
		actionSelector: 	#action
		font: 	nil
		getLabelSelector: 	#label
		getMenuSelector: 	#menu:
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	#enabled
		getFontSelector: 	#font
		labelMorph: 	a LabelMorph(124643072)'Ok'
		iconMorph: 	nil
		iconPosition: 	#left
		lastState: 	false
		backgroundColor: 	nil


Array(SequenceableCollection)>>do:
	Receiver: an Array(a SpPluggableButtonMorph(835258112) a SpPluggableButtonMorph(204482048))
	Arguments and temporary variables: 
		aBlock: 	[:m |
		(m containsPoint: evt cursorPoint) ifTrue: [m enabled ifTru[..]
		index: 	2
	Receiver's instance variables: 
an Array(a SpPluggableButtonMorph(835258112) a SpPluggableButtonMorph(204482048))

SpPluggableButtonMorph(PluggableButtonMorph)>>mouseUp:
	Receiver: a SpPluggableButtonMorph(204482048)
	Arguments and temporary variables: 
		evt: 	[(685@505) mouseUp 818101 nil]
		all: 	an Array(a SpPluggableButtonMorph(835258112) a SpPluggableButtonMorph([..]
	Receiver's instance variables: 
		bounds: 	(643.0@485.0) corner: (743.0@515.0)
		owner: 	a PanelMorph(82750208)
		submorphs: 	an Array(an AlignmentMorph(6081280))
		fullBounds: 	nil
		color: 	(Color r: 0.9012707722385142 g: 0.9012707722385142 b: 0.901270772238[..]
		extension: 	a MorphExtension (1025126912) [eventHandler = a MorphicEventHand[..]
		borderWidth: 	1
		borderColor: 	#simple
		model: 	a SpMorphicButtonAdapter
		label: 	'Ok'
		icon: 	nil
		getIconSelector: 	nil
		getStateSelector: 	#state
		actionSelector: 	#action
		font: 	nil
		getLabelSelector: 	#label
		getMenuSelector: 	#menu:
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	#enabled
		getFontSelector: 	#font
		labelMorph: 	a LabelMorph(124643072)'Ok'
		iconMorph: 	nil
		iconPosition: 	#left
		lastState: 	false
		backgroundColor: 	nil


SpPluggableButtonMorph(Morph)>>handleMouseUp:
	Receiver: a SpPluggableButtonMorph(204482048)
	Arguments and temporary variables: 
		anEvent: 	[(685@505) mouseUp 818101 nil]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(643.0@485.0) corner: (743.0@515.0)
		owner: 	a PanelMorph(82750208)
		submorphs: 	an Array(an AlignmentMorph(6081280))
		fullBounds: 	nil
		color: 	(Color r: 0.9012707722385142 g: 0.9012707722385142 b: 0.901270772238[..]
		extension: 	a MorphExtension (1025126912) [eventHandler = a MorphicEventHand[..]
		borderWidth: 	1
		borderColor: 	#simple
		model: 	a SpMorphicButtonAdapter
		label: 	'Ok'
		icon: 	nil
		getIconSelector: 	nil
		getStateSelector: 	#state
		actionSelector: 	#action
		font: 	nil
		getLabelSelector: 	#label
		getMenuSelector: 	#menu:
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	#enabled
		getFontSelector: 	#font
		labelMorph: 	a LabelMorph(124643072)'Ok'
		iconMorph: 	nil
		iconPosition: 	#left
		lastState: 	false
		backgroundColor: 	nil


MouseButtonEvent>>sentTo:
	Receiver: [(685@505) mouseUp 818101 nil]
	Arguments and temporary variables: 
		anObject: 	a SpPluggableButtonMorph(204482048)
	Receiver's instance variables: 
		timeStamp: 	818101
		source: 	a HandMorph(337424384)
		windowIndex: 	nil
		type: 	#mouseUp
		buttons: 	0
		position: 	(685@505)
		handler: 	nil
		wasHandled: 	true
		whichButton: 	4


SpPluggableButtonMorph(Morph)>>handleEvent:
	Receiver: a SpPluggableButtonMorph(204482048)
	Arguments and temporary variables: 
		anEvent: 	[(685@505) mouseUp 818101 nil]
	Receiver's instance variables: 
		bounds: 	(643.0@485.0) corner: (743.0@515.0)
		owner: 	a PanelMorph(82750208)
		submorphs: 	an Array(an AlignmentMorph(6081280))
		fullBounds: 	nil
		color: 	(Color r: 0.9012707722385142 g: 0.9012707722385142 b: 0.901270772238[..]
		extension: 	a MorphExtension (1025126912) [eventHandler = a MorphicEventHand[..]
		borderWidth: 	1
		borderColor: 	#simple
		model: 	a SpMorphicButtonAdapter
		label: 	'Ok'
		icon: 	nil
		getIconSelector: 	nil
		getStateSelector: 	#state
		actionSelector: 	#action
		font: 	nil
		getLabelSelector: 	#label
		getMenuSelector: 	#menu:
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	#enabled
		getFontSelector: 	#font
		labelMorph: 	a LabelMorph(124643072)'Ok'
		iconMorph: 	nil
		iconPosition: 	#left
		lastState: 	false
		backgroundColor: 	nil


SpPluggableButtonMorph(Morph)>>handleFocusEvent:
	Receiver: a SpPluggableButtonMorph(204482048)
	Arguments and temporary variables: 
		anEvent: 	[(685@505) mouseUp 818101 nil]
	Receiver's instance variables: 
		bounds: 	(643.0@485.0) corner: (743.0@515.0)
		owner: 	a PanelMorph(82750208)
		submorphs: 	an Array(an AlignmentMorph(6081280))
		fullBounds: 	nil
		color: 	(Color r: 0.9012707722385142 g: 0.9012707722385142 b: 0.901270772238[..]
		extension: 	a MorphExtension (1025126912) [eventHandler = a MorphicEventHand[..]
		borderWidth: 	1
		borderColor: 	#simple
		model: 	a SpMorphicButtonAdapter
		label: 	'Ok'
		icon: 	nil
		getIconSelector: 	nil
		getStateSelector: 	#state
		actionSelector: 	#action
		font: 	nil
		getLabelSelector: 	#label
		getMenuSelector: 	#menu:
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	#enabled
		getFontSelector: 	#font
		labelMorph: 	a LabelMorph(124643072)'Ok'
		iconMorph: 	nil
		iconPosition: 	#left
		lastState: 	false
		backgroundColor: 	nil


[
		result := focusHolder handleFocusEvent: transformedEvent.
	] in HandMorph>>sendFocusEvent:to:clear:
	Receiver: a HandMorph(337424384)
	Arguments and temporary variables: 
		anEvent: 	[(685@505) mouseUp 818101 nil]
		focusHolder: 	a SpPluggableButtonMorph(204482048)
		aBlock: 	[self mouseFocus: nil]
		w: 	a WorldMorph(341720576) [world]
		transformedEvent: 	[(685@505) mouseUp 818101 nil]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(685@505.0) corner: (701@521.0)
		owner: 	a WorldMorph(341720576) [world]
		submorphs: 	#()
		fullBounds: 	(685@505.0) corner: (701@521.0)
		color: 	Color blue
		extension: 	a MorphExtension (370611968)
		mouseFocus: 	nil
		keyboardFocus: 	a SpPluggableButtonMorph(204482048)
		eventListeners: 	nil
		mouseListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(685@505) mouseUp 818101 nil]
		targetOffset: 	(42.0@20.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 0 0 0 0 0 nil nil)
		captureBlock: 	nil
		recentModifiers: 	0
		pendingEventQueue: 	WaitfreeQueue with 0 items
		supressNextKeyPress: 	false


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
		result := focusHolder handleFocusEvent: transformedEvent.
	]
	Arguments and temporary variables: 
		exception: 	Error
		handlerAction: 	[ :ex |
			ActiveWorld := priorWorld.
			ex pass ]
	Receiver's instance variables: 
		outerContext: 	HandMorph>>sendFocusEvent:to:clear:
		compiledBlock: 	a CompiledBlock: [
		result := focusHolder handleFocusEvent:[..]
		numArgs: 	0
		receiver: 	a HandMorph(337424384)


WorldMorph>>becomeActiveDuring:
	Receiver: a WorldMorph(341720576) [world]
	Arguments and temporary variables: 
		aBlock: 	[
		result := focusHolder handleFocusEvent: transformedEvent.
	]
		priorWorld: 	a WorldMorph(341720576) [world]
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1728@1080)
		owner: 	nil
		submorphs: 	an Array(a MenubarMorph(112886016) a TaskbarMorph(279458560) a S[..]
		fullBounds: 	(0@0) corner: (1728@1080)
		color: 	(Color r: 0.9403714565004888 g: 0.9403714565004888 b: 0.940371456500[..]
		extension: 	a MorphExtension (1012946432) [other:  (dragEnabled -> true) (dr[..]
		borderWidth: 	0
		borderColor: 	(Color r: 0.8611925708699902 g: 1.0 b: 0.7223851417399805 alph[..]
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil


HandMorph>>sendFocusEvent:to:clear:
	Receiver: a HandMorph(337424384)
	Arguments and temporary variables: 
		result: 	nil
		anEvent: 	[(685@505) mouseUp 818101 nil]
		focusHolder: 	a SpPluggableButtonMorph(204482048)
		aBlock: 	[self mouseFocus: nil]
		w: 	a WorldMorph(341720576) [world]
		transformedEvent: 	[(685@505) mouseUp 818101 nil]
	Receiver's instance variables: 
		bounds: 	(685@505.0) corner: (701@521.0)
		owner: 	a WorldMorph(341720576) [world]
		submorphs: 	#()
		fullBounds: 	(685@505.0) corner: (701@521.0)
		color: 	Color blue
		extension: 	a MorphExtension (370611968)
		mouseFocus: 	nil
		keyboardFocus: 	a SpPluggableButtonMorph(204482048)
		eventListeners: 	nil
		mouseListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(685@505) mouseUp 818101 nil]
		targetOffset: 	(42.0@20.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 0 0 0 0 0 nil nil)
		captureBlock: 	nil
		recentModifiers: 	0
		pendingEventQueue: 	WaitfreeQueue with 0 items
		supressNextKeyPress: 	false


HandMorph>>sendEvent:focus:clear:
	Receiver: a HandMorph(337424384)
	Arguments and temporary variables: 
		anEvent: 	[(685@505) mouseUp 818101 nil]
		focusHolder: 	a SpPluggableButtonMorph(204482048)
		aBlock: 	[self mouseFocus: nil]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(685@505.0) corner: (701@521.0)
		owner: 	a WorldMorph(341720576) [world]
		submorphs: 	#()
		fullBounds: 	(685@505.0) corner: (701@521.0)
		color: 	Color blue
		extension: 	a MorphExtension (370611968)
		mouseFocus: 	nil
		keyboardFocus: 	a SpPluggableButtonMorph(204482048)
		eventListeners: 	nil
		mouseListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(685@505) mouseUp 818101 nil]
		targetOffset: 	(42.0@20.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 0 0 0 0 0 nil nil)
		captureBlock: 	nil
		recentModifiers: 	0
		pendingEventQueue: 	WaitfreeQueue with 0 items
		supressNextKeyPress: 	false


HandMorph>>sendMouseEvent:
	Receiver: a HandMorph(337424384)
	Arguments and temporary variables: 
		anEvent: 	[(685@505) mouseUp 818101 nil]
	Receiver's instance variables: 
		bounds: 	(685@505.0) corner: (701@521.0)
		owner: 	a WorldMorph(341720576) [world]
		submorphs: 	#()
		fullBounds: 	(685@505.0) corner: (701@521.0)
		color: 	Color blue
		extension: 	a MorphExtension (370611968)
		mouseFocus: 	nil
		keyboardFocus: 	a SpPluggableButtonMorph(204482048)
		eventListeners: 	nil
		mouseListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(685@505) mouseUp 818101 nil]
		targetOffset: 	(42.0@20.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 0 0 0 0 0 nil nil)
		captureBlock: 	nil
		recentModifiers: 	0
		pendingEventQueue: 	WaitfreeQueue with 0 items
		supressNextKeyPress: 	false


HandMorph>>handleEvent:
	Receiver: a HandMorph(337424384)
	Arguments and temporary variables: 
		anEvent: 	[(685@505) mouseUp 818101 nil]
		evt: 	[(685@505) mouseUp 818101 nil]
	Receiver's instance variables: 
		bounds: 	(685@505.0) corner: (701@521.0)
		owner: 	a WorldMorph(341720576) [world]
		submorphs: 	#()
		fullBounds: 	(685@505.0) corner: (701@521.0)
		color: 	Color blue
		extension: 	a MorphExtension (370611968)
		mouseFocus: 	nil
		keyboardFocus: 	a SpPluggableButtonMorph(204482048)
		eventListeners: 	nil
		mouseListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(685@505) mouseUp 818101 nil]
		targetOffset: 	(42.0@20.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 0 0 0 0 0 nil nil)
		captureBlock: 	nil
		recentModifiers: 	0
		pendingEventQueue: 	WaitfreeQueue with 0 items
		supressNextKeyPress: 	false


[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil ]) ifTrue: [
			morphicWorld activeHand handleEvent: anEvent
		]
	] in OSWindowMorphicEventHandler>>dispatchMorphicEvent:
	Receiver: an OSWindowMorphicEventHandler
	Arguments and temporary variables: 
		anEvent: 	[(685@505) mouseUp 818101 nil]
	Receiver's instance variables: 
		morphicWorld: 	a WorldMorph(341720576) [world]


WorldState>>runStepMethodsIn:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(341720576) [world]
		queue: 	WaitfreeQueue with 0 items
		nextInQueue: 	[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNo[..]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(337424384))
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap()
		lastStepTime: 	660660
		lastStepMessage: 	nil
		alarms: 	a Heap()
		lastAlarmTime: 	818081
		activeHand: 	a HandMorph(337424384)
		currentCursor: 	((CursorWithMask
	extent: (16@16)
	depth: 1
	fromArray: #(
	[..]
		worldRenderer: 	an OSWorldRenderer
		realWindowExtent: 	(1728@1080)
		deferredUIMessages: 	WaitfreeQueue with 0 items


WorldMorph>>runStepMethods
	Receiver: a WorldMorph(341720576) [world]
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1728@1080)
		owner: 	nil
		submorphs: 	an Array(a MenubarMorph(112886016) a TaskbarMorph(279458560) a S[..]
		fullBounds: 	(0@0) corner: (1728@1080)
		color: 	(Color r: 0.9403714565004888 g: 0.9403714565004888 b: 0.940371456500[..]
		extension: 	a MorphExtension (1012946432) [other:  (dragEnabled -> true) (dr[..]
		borderWidth: 	0
		borderColor: 	(Color r: 0.8611925708699902 g: 1.0 b: 0.7223851417399805 alph[..]
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil


WorldState>>doOneCycleFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(341720576) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(337424384))
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap()
		lastStepTime: 	660660
		lastStepMessage: 	nil
		alarms: 	a Heap()
		lastAlarmTime: 	818081
		activeHand: 	a HandMorph(337424384)
		currentCursor: 	((CursorWithMask
	extent: (16@16)
	depth: 1
	fromArray: #(
	[..]
		worldRenderer: 	an OSWorldRenderer
		realWindowExtent: 	(1728@1080)
		deferredUIMessages: 	WaitfreeQueue with 0 items


WorldMorph>>doOneCycleNow
	Receiver: a WorldMorph(341720576) [world]
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1728@1080)
		owner: 	nil
		submorphs: 	an Array(a MenubarMorph(112886016) a TaskbarMorph(279458560) a S[..]
		fullBounds: 	(0@0) corner: (1728@1080)
		color: 	(Color r: 0.9403714565004888 g: 0.9403714565004888 b: 0.940371456500[..]
		extension: 	a MorphExtension (1012946432) [other:  (dragEnabled -> true) (dr[..]
		borderWidth: 	0
		borderColor: 	(Color r: 0.8611925708699902 g: 1.0 b: 0.7223851417399805 alph[..]
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil


WorldMorph>>doOneCycle
	Receiver: a WorldMorph(341720576) [world]
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1728@1080)
		owner: 	nil
		submorphs: 	an Array(a MenubarMorph(112886016) a TaskbarMorph(279458560) a S[..]
		fullBounds: 	(0@0) corner: (1728@1080)
		color: 	(Color r: 0.9403714565004888 g: 0.9403714565004888 b: 0.940371456500[..]
		extension: 	a MorphExtension (1012946432) [other:  (dragEnabled -> true) (dr[..]
		borderWidth: 	0
		borderColor: 	(Color r: 0.8611925708699902 g: 1.0 b: 0.7223851417399805 alph[..]
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil


[
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMutex critical: [
			                     self extraWorldList ].
		extraWorldsToDraw do: [ :world | world doOneCycle ].

		(self currentWorld isNotNil and: [
			 (extraWorldsToDraw includes: self currentWorld) not ]) ifTrue: [
			self currentWorld doOneCycle ] ] in WorldMorph class>>doOneCycle
	Receiver: WorldMorph
	Arguments and temporary variables: 
		extraWorldsToDraw: 	#()
	Receiver's instance variables: 
		superclass: 	PasteUpMorph
		methodDict: 	a MethodDictionary(#acceptDroppingMorph:event:->WorldMorph>>#ac[..]
		format: 	65547
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		commentSourcePointer: 	nil
		subclasses: 	{AthensWorldMorph. OSWindowWorldMorph}
		name: 	#WorldMorph
		classPool: 	a Dictionary(#AllowDropFiles->nil #CursorOwnerWorld->a WorldMorp[..]
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Morphic-Core-Worlds'
		announcer: 	nil
		displayScaleFactor: 	1


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMutex critical: [
			  [..]
	Arguments and temporary variables: 
		aBlock: 	[
		self doInterCycleWait
	]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	WorldMorph class>>doOneCycle
		compiledBlock: 	a CompiledBlock: [
		| extraWorldsToDraw |
		extraWorldsToDr[..]
		numArgs: 	0
		receiver: 	WorldMorph


WorldState class>>doDrawCycleWith:
	Receiver: WorldState
	Arguments and temporary variables: 
		aBlock: 	[
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMute[..]
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary(#activeHand->WorldState>>#activeHand #active[..]
		format: 	65548
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		commentSourcePointer: 	nil
		subclasses: 	{AthensWorldState}
		name: 	#WorldState
		classPool: 	a Dictionary(#CanSurrenderToOS->nil #DebugShowDamage->false #Des[..]
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Morphic-Core-Worlds'


WorldMorph class>>doOneCycle
	Receiver: WorldMorph
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		superclass: 	PasteUpMorph
		methodDict: 	a MethodDictionary(#acceptDroppingMorph:event:->WorldMorph>>#ac[..]
		format: 	65547
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		commentSourcePointer: 	nil
		subclasses: 	{AthensWorldMorph. OSWindowWorldMorph}
		name: 	#WorldMorph
		classPool: 	a Dictionary(#AllowDropFiles->nil #CursorOwnerWorld->a WorldMorp[..]
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Morphic-Core-Worlds'
		announcer: 	nil
		displayScaleFactor: 	1


MorphicRenderLoop>>doOneCycle
	Receiver: a MorphicRenderLoop
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
a MorphicRenderLoop

MorphicRenderLoop>>doOneCycleWhile:
	Receiver: a MorphicRenderLoop
	Arguments and temporary variables: 
		aBlock: 	[ true ]
	Receiver's instance variables: 
a MorphicRenderLoop

[ MorphicRenderLoop new doOneCycleWhile: [ true ] ] in MorphicUIManager>>spawnNewProcess
	Receiver: a MorphicUIManager
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		activeTranscript: 	nil


[self value.
			"IMPORTANT: Do not step over next line of code. See method comments for details"
			Processor terminateRealActive] in FullBlockClosure(BlockClosure)>>newProcess
	Receiver: [ MorphicRenderLoop new doOneCycleWhile: [ true ] ]
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		outerContext: 	MorphicUIManager>>spawnNewProcess
		compiledBlock: 	a CompiledBlock: [ MorphicRenderLoop new doOneCycleWhile: [ [..]
		numArgs: 	0
		receiver: 	a MorphicUIManager



--- The full stack ---
IceTipLocalRepositoryPanel(Object)>>assert:description:
IceTipLocalRepositoryPanel>>validate
[ 
			dialog validate.
			self repositoryModel updateLocation: dialog location.
			true ] in IceTipRepairLocateRepository>>basicExecute
FullBlockClosure(BlockClosure)>>cull:
SpDialogWindowPresenter>>triggerOkAction
[ :presenter | 
			presenter triggerOkAction.
			presenter close ] in IceTipLocalRepositoryPanel(SpAbstractPresenter)>>initializeDialogWindow:
FullBlockClosure(BlockClosure)>>cull:
[ aBlock cull: self ] in SpDialogWindowPresenter>>addButton:do:
SpButtonPresenter>>performAction
SpMorphicButtonAdapter>>action
SpPluggableButtonMorph(PluggableButtonMorph)>>performAction:
[:m |
		(m containsPoint: evt cursorPoint) ifTrue: [m enabled ifTrue: [ m performAction: evt ]]] in SpPluggableButtonMorph(PluggableButtonMorph)>>mouseUp:
Array(SequenceableCollection)>>do:
SpPluggableButtonMorph(PluggableButtonMorph)>>mouseUp:
SpPluggableButtonMorph(Morph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
SpPluggableButtonMorph(Morph)>>handleEvent:
SpPluggableButtonMorph(Morph)>>handleFocusEvent:
[
		result := focusHolder handleFocusEvent: transformedEvent.
	] in HandMorph>>sendFocusEvent:to:clear:
FullBlockClosure(BlockClosure)>>on:do:
WorldMorph>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil ]) ifTrue: [
			morphicWorld activeHand handleEvent: anEvent
		]
	] in OSWindowMorphicEventHandler>>dispatchMorphicEvent:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycleNow
WorldMorph>>doOneCycle
[
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMutex critical: [
			                     self extraWorldList ].
		extraWorldsToDraw do: [ :world | world doOneCycle ].

		(self currentWorld isNotNil and: [
			 (extraWorldsToDraw includes: self currentWorld) not ]) ifTrue: [
			self currentWorld doOneCycle ] ] in WorldMorph class>>doOneCycle
FullBlockClosure(BlockClosure)>>ensure:
WorldState class>>doDrawCycleWith:
WorldMorph class>>doOneCycle
MorphicRenderLoop>>doOneCycle
MorphicRenderLoop>>doOneCycleWhile:
[ MorphicRenderLoop new doOneCycleWhile: [ true ] ] in MorphicUIManager>>spawnNewProcess
[self value.
			"IMPORTANT: Do not step over next line of code. See method comments for details"
			Processor terminateRealActive] in FullBlockClosure(BlockClosure)>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
AssertionFailure: Project location does not seems to be a valid git repository.
13 November 2023 11:43:43.310254 pm

VM: Mac OS - arm64 - 1000 - CoInterpreter VMMaker-tonel.1 uuid: 902dd483-c0c4-0d00-86f2-0f880df24b96 Oct 23 2023
StackToRegisterMappingCogit VMMaker-tonel.1 uuid: 902dd483-c0c4-0d00-86f2-0f880df24b96 Oct 23 2023
v10.0.8 - Commit: b323c5fb - Date: 2023-10-20 16:02:07 -0400

Image: Pharo11.0.0 [Build information: Pharo-11.0.0+build.710.sha.ea28d8552cac85a7ce1e9c34ab1e7bd45f7b9910 (64 Bit)]

IceTipLocalRepositoryPanel(Object)>>assert:description:
	Receiver: an IceTipLocalRepositoryPanel
	Arguments and temporary variables: 
		aBlock: 	false
		aStringOrBlock: 	'Project location does not seems to be a valid git repository.'
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicGridAdapter)
		announcer: 	an Announcer
		owner: 	a SpDialogWindowPresenter
		adapter: 	a SpMorphicGridAdapter
		needRebuild: 	true
		eventHandler: 	nil
		application: 	a StPharoApplication
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ nil ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Untitled window' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpGridLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		decorations: 	nil
		projectLocationLabel: 	a SpLabelPresenter
		projectLocation: 	an IceTipDirectoryPresenter
		remoteLabel: 	nil
		remoteInputText: 	nil
		repository: 	nil


IceTipLocalRepositoryPanel>>validate
	Receiver: an IceTipLocalRepositoryPanel
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicGridAdapter)
		announcer: 	an Announcer
		owner: 	a SpDialogWindowPresenter
		adapter: 	a SpMorphicGridAdapter
		needRebuild: 	true
		eventHandler: 	nil
		application: 	a StPharoApplication
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ nil ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Untitled window' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpGridLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		decorations: 	nil
		projectLocationLabel: 	a SpLabelPresenter
		projectLocation: 	an IceTipDirectoryPresenter
		remoteLabel: 	nil
		remoteInputText: 	nil
		repository: 	nil


[ 
			dialog validate.
			self repositoryModel updateLocation: dialog location.
			true ] in IceTipRepairLocateRepository>>basicExecute
	Receiver: an IceTipRepairLocateRepository
	Arguments and temporary variables: 
		dialog: 	an IceTipLocalRepositoryPanel
	Receiver's instance variables: 
		context: 	an IceTipRepairRepositoryDialog
		repository: 	nil
		successBlock: 	nil
		repositoryModel: 	an IceTipCachedModel(an IceTipRepositoryModel)


FullBlockClosure(BlockClosure)>>cull:
	Receiver: [ 
			dialog validate.
			self repositoryModel updateLocation: dialog location.
			true ]
	Arguments and temporary variables: 
		anArg: 	a SpDialogWindowPresenter
	Receiver's instance variables: 
		outerContext: 	IceTipRepairLocateRepository>>basicExecute
		compiledBlock: 	a CompiledBlock: [ 
			dialog validate.
			self repositoryMo[..]
		numArgs: 	0
		receiver: 	an IceTipRepairLocateRepository


SpDialogWindowPresenter>>triggerOkAction
	Receiver: a SpDialogWindowPresenter
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicDialogWindowAdapter a SpDialogWind[..]
		announcer: 	an Announcer
		owner: 	nil
		adapter: 	a SpMorphicDialogWindowAdapter
		needRebuild: 	true
		eventHandler: 	nil
		application: 	a StPharoApplication
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ nil ]
		windowIcon: 	an ObservableValueHolder[ Form(16x16x32) ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ true ]
		titleHolder: 	an ObservableValueHolder[ 'Import from existing clone' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ nil ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		borderWidth: 	an ObservableValueHolder[ nil ]
		borderColor: 	an ObservableValueHolder[ nil ]
		dragEnabled: 	an ObservableValueHolder[ false ]
		dropEnabled: 	an ObservableValueHolder[ false ]
		color: 	an ObservableValueHolder[ nil ]
		help: 	an ObservableValueHolder[ nil ]
		enabled: 	an ObservableValueHolder[ true ]
		wantsDrop: 	an ObservableValueHolder[ [ :transfer | self dropEnabled ] ]
		acceptDrop: 	an ObservableValueHolder[ [ :transfer | ] ]
		deferredActions: 	nil
		presenter: 	an ObservableValueHolder[ an IceTipLocalRepositoryPanel ]
		initialPosition: 	an ObservableValueHolder[ nil ]
		initialExtent: 	an ObservableValueHolder[ (500@137) ]
		menu: 	an ObservableValueHolder[ nil ]
		centered: 	an ObservableValueHolder[ false ]
		isClosed: 	an ObservableValueHolder[ false ]
		toolbar: 	an ObservableValueHolder[ nil ]
		statusbar: 	an ObservableValueHolder[ nil ]
		window: 	an ObservableValueHolder[ a SpDialogWindowMorph(816775680) named: I[..]
		decorations: 	an ObservableValueHolder[ true ]
		resizable: 	an ObservableValueHolder[ true ]
		buttons: 	an OrderedCollection(a SpButtonPresenter a SpButtonPresenter)
		okAction: 	[ 
			dialog validate.
			self repositoryModel updateLocation: di[..]
		cancelAction: 	[ 
		cancelled := true.
		self close ]
		cancelled: 	true
		defaultButton: 	nil


[ :presenter | 
			presenter triggerOkAction.
			presenter close ] in IceTipLocalRepositoryPanel(SpAbstractPresenter)>>initializeDialogWindow:
	Receiver: an IceTipLocalRepositoryPanel
	Arguments and temporary variables: 
		aDialogWindowPresenter: 	a SpDialogWindowPresenter
		presenter: 	a SpDialogWindowPresenter
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicGridAdapter)
		announcer: 	an Announcer
		owner: 	a SpDialogWindowPresenter
		adapter: 	a SpMorphicGridAdapter
		needRebuild: 	true
		eventHandler: 	nil
		application: 	a StPharoApplication
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ nil ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Untitled window' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpGridLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		decorations: 	nil
		projectLocationLabel: 	a SpLabelPresenter
		projectLocation: 	an IceTipDirectoryPresenter
		remoteLabel: 	nil
		remoteInputText: 	nil
		repository: 	nil


FullBlockClosure(BlockClosure)>>cull:
	Receiver: [ :presenter | 
			presenter triggerOkAction.
			presenter close ]
	Arguments and temporary variables: 
		anArg: 	a SpDialogWindowPresenter
	Receiver's instance variables: 
		outerContext: 	IceTipLocalRepositoryPanel(SpAbstractPresenter)>>initializeDi[..]
		compiledBlock: 	a CompiledBlock: [ :presenter | 
			presenter triggerOkActio[..]
		numArgs: 	1
		receiver: 	an IceTipLocalRepositoryPanel


[ aBlock cull: self ] in SpDialogWindowPresenter>>addButton:do:
	Receiver: a SpDialogWindowPresenter
	Arguments and temporary variables: 
		aString: 	'Ok'
		aBlock: 	[ :presenter | 
			presenter triggerOkAction.
			presenter close ]
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicDialogWindowAdapter a SpDialogWind[..]
		announcer: 	an Announcer
		owner: 	nil
		adapter: 	a SpMorphicDialogWindowAdapter
		needRebuild: 	true
		eventHandler: 	nil
		application: 	a StPharoApplication
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ nil ]
		windowIcon: 	an ObservableValueHolder[ Form(16x16x32) ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ true ]
		titleHolder: 	an ObservableValueHolder[ 'Import from existing clone' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ nil ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		borderWidth: 	an ObservableValueHolder[ nil ]
		borderColor: 	an ObservableValueHolder[ nil ]
		dragEnabled: 	an ObservableValueHolder[ false ]
		dropEnabled: 	an ObservableValueHolder[ false ]
		color: 	an ObservableValueHolder[ nil ]
		help: 	an ObservableValueHolder[ nil ]
		enabled: 	an ObservableValueHolder[ true ]
		wantsDrop: 	an ObservableValueHolder[ [ :transfer | self dropEnabled ] ]
		acceptDrop: 	an ObservableValueHolder[ [ :transfer | ] ]
		deferredActions: 	nil
		presenter: 	an ObservableValueHolder[ an IceTipLocalRepositoryPanel ]
		initialPosition: 	an ObservableValueHolder[ nil ]
		initialExtent: 	an ObservableValueHolder[ (500@137) ]
		menu: 	an ObservableValueHolder[ nil ]
		centered: 	an ObservableValueHolder[ false ]
		isClosed: 	an ObservableValueHolder[ false ]
		toolbar: 	an ObservableValueHolder[ nil ]
		statusbar: 	an ObservableValueHolder[ nil ]
		window: 	an ObservableValueHolder[ a SpDialogWindowMorph(816775680) named: I[..]
		decorations: 	an ObservableValueHolder[ true ]
		resizable: 	an ObservableValueHolder[ true ]
		buttons: 	an OrderedCollection(a SpButtonPresenter a SpButtonPresenter)
		okAction: 	[ 
			dialog validate.
			self repositoryModel updateLocation: di[..]
		cancelAction: 	[ 
		cancelled := true.
		self close ]
		cancelled: 	true
		defaultButton: 	nil


SpButtonPresenter>>performAction
	Receiver: a SpButtonPresenter
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicButtonAdapter)
		announcer: 	an Announcer
		owner: 	a SpButtonBarPresenter
		adapter: 	a SpMorphicButtonAdapter
		needRebuild: 	true
		eventHandler: 	nil
		application: 	nil
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ nil ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Button' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpAbstractWidgetLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		borderWidth: 	an ObservableValueHolder[ nil ]
		borderColor: 	an ObservableValueHolder[ nil ]
		dragEnabled: 	an ObservableValueHolder[ false ]
		dropEnabled: 	an ObservableValueHolder[ false ]
		color: 	an ObservableValueHolder[ nil ]
		help: 	an ObservableValueHolder[ nil ]
		enabled: 	an ObservableValueHolder[ true ]
		wantsDrop: 	an ObservableValueHolder[ [ :transfer | self dropEnabled ] ]
		acceptDrop: 	an ObservableValueHolder[ [ :transfer | ] ]
		deferredActions: 	nil
		icon: 	an ObservableValueHolder[ nil ]
		label: 	an ObservableValueHolder[ 'Ok' ]
		action: 	an ObservableValueHolder[ [ aBlock cull: self ] ]
		actionPerformed: 	an ObservableValueHolder[ nil ]
		askBeforeChanging: 	an ObservableValueHolder[ false ]
		font: 	an ObservableValueHolder[ nil ]
		shortcut: 	an ObservableValueHolder[ nil ]
		state: 	an ObservableValueHolder[ false ]
		contextMenu: 	an ObservableValueHolder[ nil ]


SpMorphicButtonAdapter>>action
	Receiver: a SpMorphicButtonAdapter
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpPluggableButtonMorph(204482048))
		announcer: 	nil
		model: 	a SpButtonPresenter
		widget: 	a SpPluggableButtonMorph(204482048)
		selector: 	nil
		owner: 	a SpButtonPresenter
		unsubscribed: 	false
		subMenuWidget: 	nil
		styleName: 	nil


SpPluggableButtonMorph(PluggableButtonMorph)>>performAction:
	Receiver: a SpPluggableButtonMorph(204482048)
	Arguments and temporary variables: 
		event: 	[(685@505) mouseUp 818101 nil]
	Receiver's instance variables: 
		bounds: 	(643.0@485.0) corner: (743.0@515.0)
		owner: 	a PanelMorph(82750208)
		submorphs: 	an Array(an AlignmentMorph(6081280))
		fullBounds: 	nil
		color: 	(Color r: 0.9012707722385142 g: 0.9012707722385142 b: 0.901270772238[..]
		extension: 	a MorphExtension (1025126912) [eventHandler = a MorphicEventHand[..]
		borderWidth: 	1
		borderColor: 	#simple
		model: 	a SpMorphicButtonAdapter
		label: 	'Ok'
		icon: 	nil
		getIconSelector: 	nil
		getStateSelector: 	#state
		actionSelector: 	#action
		font: 	nil
		getLabelSelector: 	#label
		getMenuSelector: 	#menu:
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	#enabled
		getFontSelector: 	#font
		labelMorph: 	a LabelMorph(124643072)'Ok'
		iconMorph: 	nil
		iconPosition: 	#left
		lastState: 	false
		backgroundColor: 	nil


[:m |
		(m containsPoint: evt cursorPoint) ifTrue: [m enabled ifTrue: [ m performAction: evt ]]] in SpPluggableButtonMorph(PluggableButtonMorph)>>mouseUp:
	Receiver: a SpPluggableButtonMorph(204482048)
	Arguments and temporary variables: 
		evt: 	[(685@505) mouseUp 818101 nil]
		all: 	an Array(a SpPluggableButtonMorph(835258112) a SpPluggableButtonMorph([..]
		m: 	a SpPluggableButtonMorph(204482048)
	Receiver's instance variables: 
		bounds: 	(643.0@485.0) corner: (743.0@515.0)
		owner: 	a PanelMorph(82750208)
		submorphs: 	an Array(an AlignmentMorph(6081280))
		fullBounds: 	nil
		color: 	(Color r: 0.9012707722385142 g: 0.9012707722385142 b: 0.901270772238[..]
		extension: 	a MorphExtension (1025126912) [eventHandler = a MorphicEventHand[..]
		borderWidth: 	1
		borderColor: 	#simple
		model: 	a SpMorphicButtonAdapter
		label: 	'Ok'
		icon: 	nil
		getIconSelector: 	nil
		getStateSelector: 	#state
		actionSelector: 	#action
		font: 	nil
		getLabelSelector: 	#label
		getMenuSelector: 	#menu:
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	#enabled
		getFontSelector: 	#font
		labelMorph: 	a LabelMorph(124643072)'Ok'
		iconMorph: 	nil
		iconPosition: 	#left
		lastState: 	false
		backgroundColor: 	nil


Array(SequenceableCollection)>>do:
	Receiver: an Array(a SpPluggableButtonMorph(835258112) a SpPluggableButtonMorph(204482048))
	Arguments and temporary variables: 
		aBlock: 	[:m |
		(m containsPoint: evt cursorPoint) ifTrue: [m enabled ifTru[..]
		index: 	2
	Receiver's instance variables: 
an Array(a SpPluggableButtonMorph(835258112) a SpPluggableButtonMorph(204482048))

SpPluggableButtonMorph(PluggableButtonMorph)>>mouseUp:
	Receiver: a SpPluggableButtonMorph(204482048)
	Arguments and temporary variables: 
		evt: 	[(685@505) mouseUp 818101 nil]
		all: 	an Array(a SpPluggableButtonMorph(835258112) a SpPluggableButtonMorph([..]
	Receiver's instance variables: 
		bounds: 	(643.0@485.0) corner: (743.0@515.0)
		owner: 	a PanelMorph(82750208)
		submorphs: 	an Array(an AlignmentMorph(6081280))
		fullBounds: 	nil
		color: 	(Color r: 0.9012707722385142 g: 0.9012707722385142 b: 0.901270772238[..]
		extension: 	a MorphExtension (1025126912) [eventHandler = a MorphicEventHand[..]
		borderWidth: 	1
		borderColor: 	#simple
		model: 	a SpMorphicButtonAdapter
		label: 	'Ok'
		icon: 	nil
		getIconSelector: 	nil
		getStateSelector: 	#state
		actionSelector: 	#action
		font: 	nil
		getLabelSelector: 	#label
		getMenuSelector: 	#menu:
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	#enabled
		getFontSelector: 	#font
		labelMorph: 	a LabelMorph(124643072)'Ok'
		iconMorph: 	nil
		iconPosition: 	#left
		lastState: 	false
		backgroundColor: 	nil


SpPluggableButtonMorph(Morph)>>handleMouseUp:
	Receiver: a SpPluggableButtonMorph(204482048)
	Arguments and temporary variables: 
		anEvent: 	[(685@505) mouseUp 818101 nil]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(643.0@485.0) corner: (743.0@515.0)
		owner: 	a PanelMorph(82750208)
		submorphs: 	an Array(an AlignmentMorph(6081280))
		fullBounds: 	nil
		color: 	(Color r: 0.9012707722385142 g: 0.9012707722385142 b: 0.901270772238[..]
		extension: 	a MorphExtension (1025126912) [eventHandler = a MorphicEventHand[..]
		borderWidth: 	1
		borderColor: 	#simple
		model: 	a SpMorphicButtonAdapter
		label: 	'Ok'
		icon: 	nil
		getIconSelector: 	nil
		getStateSelector: 	#state
		actionSelector: 	#action
		font: 	nil
		getLabelSelector: 	#label
		getMenuSelector: 	#menu:
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	#enabled
		getFontSelector: 	#font
		labelMorph: 	a LabelMorph(124643072)'Ok'
		iconMorph: 	nil
		iconPosition: 	#left
		lastState: 	false
		backgroundColor: 	nil


MouseButtonEvent>>sentTo:
	Receiver: [(685@505) mouseUp 818101 nil]
	Arguments and temporary variables: 
		anObject: 	a SpPluggableButtonMorph(204482048)
	Receiver's instance variables: 
		timeStamp: 	818101
		source: 	a HandMorph(337424384)
		windowIndex: 	nil
		type: 	#mouseUp
		buttons: 	0
		position: 	(685@505)
		handler: 	nil
		wasHandled: 	true
		whichButton: 	4


SpPluggableButtonMorph(Morph)>>handleEvent:
	Receiver: a SpPluggableButtonMorph(204482048)
	Arguments and temporary variables: 
		anEvent: 	[(685@505) mouseUp 818101 nil]
	Receiver's instance variables: 
		bounds: 	(643.0@485.0) corner: (743.0@515.0)
		owner: 	a PanelMorph(82750208)
		submorphs: 	an Array(an AlignmentMorph(6081280))
		fullBounds: 	nil
		color: 	(Color r: 0.9012707722385142 g: 0.9012707722385142 b: 0.901270772238[..]
		extension: 	a MorphExtension (1025126912) [eventHandler = a MorphicEventHand[..]
		borderWidth: 	1
		borderColor: 	#simple
		model: 	a SpMorphicButtonAdapter
		label: 	'Ok'
		icon: 	nil
		getIconSelector: 	nil
		getStateSelector: 	#state
		actionSelector: 	#action
		font: 	nil
		getLabelSelector: 	#label
		getMenuSelector: 	#menu:
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	#enabled
		getFontSelector: 	#font
		labelMorph: 	a LabelMorph(124643072)'Ok'
		iconMorph: 	nil
		iconPosition: 	#left
		lastState: 	false
		backgroundColor: 	nil


SpPluggableButtonMorph(Morph)>>handleFocusEvent:
	Receiver: a SpPluggableButtonMorph(204482048)
	Arguments and temporary variables: 
		anEvent: 	[(685@505) mouseUp 818101 nil]
	Receiver's instance variables: 
		bounds: 	(643.0@485.0) corner: (743.0@515.0)
		owner: 	a PanelMorph(82750208)
		submorphs: 	an Array(an AlignmentMorph(6081280))
		fullBounds: 	nil
		color: 	(Color r: 0.9012707722385142 g: 0.9012707722385142 b: 0.901270772238[..]
		extension: 	a MorphExtension (1025126912) [eventHandler = a MorphicEventHand[..]
		borderWidth: 	1
		borderColor: 	#simple
		model: 	a SpMorphicButtonAdapter
		label: 	'Ok'
		icon: 	nil
		getIconSelector: 	nil
		getStateSelector: 	#state
		actionSelector: 	#action
		font: 	nil
		getLabelSelector: 	#label
		getMenuSelector: 	#menu:
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	#enabled
		getFontSelector: 	#font
		labelMorph: 	a LabelMorph(124643072)'Ok'
		iconMorph: 	nil
		iconPosition: 	#left
		lastState: 	false
		backgroundColor: 	nil


[
		result := focusHolder handleFocusEvent: transformedEvent.
	] in HandMorph>>sendFocusEvent:to:clear:
	Receiver: a HandMorph(337424384)
	Arguments and temporary variables: 
		anEvent: 	[(685@505) mouseUp 818101 nil]
		focusHolder: 	a SpPluggableButtonMorph(204482048)
		aBlock: 	[self mouseFocus: nil]
		w: 	a WorldMorph(341720576) [world]
		transformedEvent: 	[(685@505) mouseUp 818101 nil]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(685@505.0) corner: (701@521.0)
		owner: 	a WorldMorph(341720576) [world]
		submorphs: 	#()
		fullBounds: 	(685@505.0) corner: (701@521.0)
		color: 	Color blue
		extension: 	a MorphExtension (370611968)
		mouseFocus: 	nil
		keyboardFocus: 	a SpPluggableButtonMorph(204482048)
		eventListeners: 	nil
		mouseListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(685@505) mouseUp 818101 nil]
		targetOffset: 	(42.0@20.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 0 0 0 0 0 nil nil)
		captureBlock: 	nil
		recentModifiers: 	0
		pendingEventQueue: 	WaitfreeQueue with 0 items
		supressNextKeyPress: 	false


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
		result := focusHolder handleFocusEvent: transformedEvent.
	]
	Arguments and temporary variables: 
		exception: 	Error
		handlerAction: 	[ :ex |
			ActiveWorld := priorWorld.
			ex pass ]
	Receiver's instance variables: 
		outerContext: 	HandMorph>>sendFocusEvent:to:clear:
		compiledBlock: 	a CompiledBlock: [
		result := focusHolder handleFocusEvent:[..]
		numArgs: 	0
		receiver: 	a HandMorph(337424384)


WorldMorph>>becomeActiveDuring:
	Receiver: a WorldMorph(341720576) [world]
	Arguments and temporary variables: 
		aBlock: 	[
		result := focusHolder handleFocusEvent: transformedEvent.
	]
		priorWorld: 	a WorldMorph(341720576) [world]
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1728@1080)
		owner: 	nil
		submorphs: 	an Array(a MenubarMorph(112886016) a TaskbarMorph(279458560) a S[..]
		fullBounds: 	(0@0) corner: (1728@1080)
		color: 	(Color r: 0.9403714565004888 g: 0.9403714565004888 b: 0.940371456500[..]
		extension: 	a MorphExtension (1012946432) [other:  (dragEnabled -> true) (dr[..]
		borderWidth: 	0
		borderColor: 	(Color r: 0.8611925708699902 g: 1.0 b: 0.7223851417399805 alph[..]
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil


HandMorph>>sendFocusEvent:to:clear:
	Receiver: a HandMorph(337424384)
	Arguments and temporary variables: 
		result: 	nil
		anEvent: 	[(685@505) mouseUp 818101 nil]
		focusHolder: 	a SpPluggableButtonMorph(204482048)
		aBlock: 	[self mouseFocus: nil]
		w: 	a WorldMorph(341720576) [world]
		transformedEvent: 	[(685@505) mouseUp 818101 nil]
	Receiver's instance variables: 
		bounds: 	(685@505.0) corner: (701@521.0)
		owner: 	a WorldMorph(341720576) [world]
		submorphs: 	#()
		fullBounds: 	(685@505.0) corner: (701@521.0)
		color: 	Color blue
		extension: 	a MorphExtension (370611968)
		mouseFocus: 	nil
		keyboardFocus: 	a SpPluggableButtonMorph(204482048)
		eventListeners: 	nil
		mouseListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(685@505) mouseUp 818101 nil]
		targetOffset: 	(42.0@20.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 0 0 0 0 0 nil nil)
		captureBlock: 	nil
		recentModifiers: 	0
		pendingEventQueue: 	WaitfreeQueue with 0 items
		supressNextKeyPress: 	false


HandMorph>>sendEvent:focus:clear:
	Receiver: a HandMorph(337424384)
	Arguments and temporary variables: 
		anEvent: 	[(685@505) mouseUp 818101 nil]
		focusHolder: 	a SpPluggableButtonMorph(204482048)
		aBlock: 	[self mouseFocus: nil]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(685@505.0) corner: (701@521.0)
		owner: 	a WorldMorph(341720576) [world]
		submorphs: 	#()
		fullBounds: 	(685@505.0) corner: (701@521.0)
		color: 	Color blue
		extension: 	a MorphExtension (370611968)
		mouseFocus: 	nil
		keyboardFocus: 	a SpPluggableButtonMorph(204482048)
		eventListeners: 	nil
		mouseListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(685@505) mouseUp 818101 nil]
		targetOffset: 	(42.0@20.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 0 0 0 0 0 nil nil)
		captureBlock: 	nil
		recentModifiers: 	0
		pendingEventQueue: 	WaitfreeQueue with 0 items
		supressNextKeyPress: 	false


HandMorph>>sendMouseEvent:
	Receiver: a HandMorph(337424384)
	Arguments and temporary variables: 
		anEvent: 	[(685@505) mouseUp 818101 nil]
	Receiver's instance variables: 
		bounds: 	(685@505.0) corner: (701@521.0)
		owner: 	a WorldMorph(341720576) [world]
		submorphs: 	#()
		fullBounds: 	(685@505.0) corner: (701@521.0)
		color: 	Color blue
		extension: 	a MorphExtension (370611968)
		mouseFocus: 	nil
		keyboardFocus: 	a SpPluggableButtonMorph(204482048)
		eventListeners: 	nil
		mouseListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(685@505) mouseUp 818101 nil]
		targetOffset: 	(42.0@20.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 0 0 0 0 0 nil nil)
		captureBlock: 	nil
		recentModifiers: 	0
		pendingEventQueue: 	WaitfreeQueue with 0 items
		supressNextKeyPress: 	false


HandMorph>>handleEvent:
	Receiver: a HandMorph(337424384)
	Arguments and temporary variables: 
		anEvent: 	[(685@505) mouseUp 818101 nil]
		evt: 	[(685@505) mouseUp 818101 nil]
	Receiver's instance variables: 
		bounds: 	(685@505.0) corner: (701@521.0)
		owner: 	a WorldMorph(341720576) [world]
		submorphs: 	#()
		fullBounds: 	(685@505.0) corner: (701@521.0)
		color: 	Color blue
		extension: 	a MorphExtension (370611968)
		mouseFocus: 	nil
		keyboardFocus: 	a SpPluggableButtonMorph(204482048)
		eventListeners: 	nil
		mouseListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(685@505) mouseUp 818101 nil]
		targetOffset: 	(42.0@20.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 0 0 0 0 0 nil nil)
		captureBlock: 	nil
		recentModifiers: 	0
		pendingEventQueue: 	WaitfreeQueue with 0 items
		supressNextKeyPress: 	false


[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil ]) ifTrue: [
			morphicWorld activeHand handleEvent: anEvent
		]
	] in OSWindowMorphicEventHandler>>dispatchMorphicEvent:
	Receiver: an OSWindowMorphicEventHandler
	Arguments and temporary variables: 
		anEvent: 	[(685@505) mouseUp 818101 nil]
	Receiver's instance variables: 
		morphicWorld: 	a WorldMorph(341720576) [world]


WorldState>>runStepMethodsIn:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(341720576) [world]
		queue: 	WaitfreeQueue with 0 items
		nextInQueue: 	[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNo[..]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(337424384))
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap()
		lastStepTime: 	660660
		lastStepMessage: 	nil
		alarms: 	a Heap()
		lastAlarmTime: 	818081
		activeHand: 	a HandMorph(337424384)
		currentCursor: 	((CursorWithMask
	extent: (16@16)
	depth: 1
	fromArray: #(
	[..]
		worldRenderer: 	an OSWorldRenderer
		realWindowExtent: 	(1728@1080)
		deferredUIMessages: 	WaitfreeQueue with 0 items


WorldMorph>>runStepMethods
	Receiver: a WorldMorph(341720576) [world]
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1728@1080)
		owner: 	nil
		submorphs: 	an Array(a MenubarMorph(112886016) a TaskbarMorph(279458560) a S[..]
		fullBounds: 	(0@0) corner: (1728@1080)
		color: 	(Color r: 0.9403714565004888 g: 0.9403714565004888 b: 0.940371456500[..]
		extension: 	a MorphExtension (1012946432) [other:  (dragEnabled -> true) (dr[..]
		borderWidth: 	0
		borderColor: 	(Color r: 0.8611925708699902 g: 1.0 b: 0.7223851417399805 alph[..]
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil


WorldState>>doOneCycleFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(341720576) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(337424384))
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap()
		lastStepTime: 	660660
		lastStepMessage: 	nil
		alarms: 	a Heap()
		lastAlarmTime: 	818081
		activeHand: 	a HandMorph(337424384)
		currentCursor: 	((CursorWithMask
	extent: (16@16)
	depth: 1
	fromArray: #(
	[..]
		worldRenderer: 	an OSWorldRenderer
		realWindowExtent: 	(1728@1080)
		deferredUIMessages: 	WaitfreeQueue with 0 items


WorldMorph>>doOneCycleNow
	Receiver: a WorldMorph(341720576) [world]
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1728@1080)
		owner: 	nil
		submorphs: 	an Array(a MenubarMorph(112886016) a TaskbarMorph(279458560) a S[..]
		fullBounds: 	(0@0) corner: (1728@1080)
		color: 	(Color r: 0.9403714565004888 g: 0.9403714565004888 b: 0.940371456500[..]
		extension: 	a MorphExtension (1012946432) [other:  (dragEnabled -> true) (dr[..]
		borderWidth: 	0
		borderColor: 	(Color r: 0.8611925708699902 g: 1.0 b: 0.7223851417399805 alph[..]
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil


WorldMorph>>doOneCycle
	Receiver: a WorldMorph(341720576) [world]
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1728@1080)
		owner: 	nil
		submorphs: 	an Array(a MenubarMorph(112886016) a TaskbarMorph(279458560) a S[..]
		fullBounds: 	(0@0) corner: (1728@1080)
		color: 	(Color r: 0.9403714565004888 g: 0.9403714565004888 b: 0.940371456500[..]
		extension: 	a MorphExtension (1012946432) [other:  (dragEnabled -> true) (dr[..]
		borderWidth: 	0
		borderColor: 	(Color r: 0.8611925708699902 g: 1.0 b: 0.7223851417399805 alph[..]
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil


[
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMutex critical: [
			                     self extraWorldList ].
		extraWorldsToDraw do: [ :world | world doOneCycle ].

		(self currentWorld isNotNil and: [
			 (extraWorldsToDraw includes: self currentWorld) not ]) ifTrue: [
			self currentWorld doOneCycle ] ] in WorldMorph class>>doOneCycle
	Receiver: WorldMorph
	Arguments and temporary variables: 
		extraWorldsToDraw: 	#()
	Receiver's instance variables: 
		superclass: 	PasteUpMorph
		methodDict: 	a MethodDictionary(#acceptDroppingMorph:event:->WorldMorph>>#ac[..]
		format: 	65547
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		commentSourcePointer: 	nil
		subclasses: 	{AthensWorldMorph. OSWindowWorldMorph}
		name: 	#WorldMorph
		classPool: 	a Dictionary(#AllowDropFiles->nil #CursorOwnerWorld->a WorldMorp[..]
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Morphic-Core-Worlds'
		announcer: 	nil
		displayScaleFactor: 	1


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMutex critical: [
			  [..]
	Arguments and temporary variables: 
		aBlock: 	[
		self doInterCycleWait
	]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	WorldMorph class>>doOneCycle
		compiledBlock: 	a CompiledBlock: [
		| extraWorldsToDraw |
		extraWorldsToDr[..]
		numArgs: 	0
		receiver: 	WorldMorph


WorldState class>>doDrawCycleWith:
	Receiver: WorldState
	Arguments and temporary variables: 
		aBlock: 	[
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMute[..]
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary(#activeHand->WorldState>>#activeHand #active[..]
		format: 	65548
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		commentSourcePointer: 	nil
		subclasses: 	{AthensWorldState}
		name: 	#WorldState
		classPool: 	a Dictionary(#CanSurrenderToOS->nil #DebugShowDamage->false #Des[..]
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Morphic-Core-Worlds'


WorldMorph class>>doOneCycle
	Receiver: WorldMorph
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		superclass: 	PasteUpMorph
		methodDict: 	a MethodDictionary(#acceptDroppingMorph:event:->WorldMorph>>#ac[..]
		format: 	65547
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		commentSourcePointer: 	nil
		subclasses: 	{AthensWorldMorph. OSWindowWorldMorph}
		name: 	#WorldMorph
		classPool: 	a Dictionary(#AllowDropFiles->nil #CursorOwnerWorld->a WorldMorp[..]
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Morphic-Core-Worlds'
		announcer: 	nil
		displayScaleFactor: 	1


MorphicRenderLoop>>doOneCycle
	Receiver: a MorphicRenderLoop
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
a MorphicRenderLoop

MorphicRenderLoop>>doOneCycleWhile:
	Receiver: a MorphicRenderLoop
	Arguments and temporary variables: 
		aBlock: 	[ true ]
	Receiver's instance variables: 
a MorphicRenderLoop

[ MorphicRenderLoop new doOneCycleWhile: [ true ] ] in MorphicUIManager>>spawnNewProcess
	Receiver: a MorphicUIManager
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		activeTranscript: 	nil


[self value.
			"IMPORTANT: Do not step over next line of code. See method comments for details"
			Processor terminateRealActive] in FullBlockClosure(BlockClosure)>>newProcess
	Receiver: [ MorphicRenderLoop new doOneCycleWhile: [ true ] ]
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		outerContext: 	MorphicUIManager>>spawnNewProcess
		compiledBlock: 	a CompiledBlock: [ MorphicRenderLoop new doOneCycleWhile: [ [..]
		numArgs: 	0
		receiver: 	a MorphicUIManager



--- The full stack ---
IceTipLocalRepositoryPanel(Object)>>assert:description:
IceTipLocalRepositoryPanel>>validate
[ 
			dialog validate.
			self repositoryModel updateLocation: dialog location.
			true ] in IceTipRepairLocateRepository>>basicExecute
FullBlockClosure(BlockClosure)>>cull:
SpDialogWindowPresenter>>triggerOkAction
[ :presenter | 
			presenter triggerOkAction.
			presenter close ] in IceTipLocalRepositoryPanel(SpAbstractPresenter)>>initializeDialogWindow:
FullBlockClosure(BlockClosure)>>cull:
[ aBlock cull: self ] in SpDialogWindowPresenter>>addButton:do:
SpButtonPresenter>>performAction
SpMorphicButtonAdapter>>action
SpPluggableButtonMorph(PluggableButtonMorph)>>performAction:
[:m |
		(m containsPoint: evt cursorPoint) ifTrue: [m enabled ifTrue: [ m performAction: evt ]]] in SpPluggableButtonMorph(PluggableButtonMorph)>>mouseUp:
Array(SequenceableCollection)>>do:
SpPluggableButtonMorph(PluggableButtonMorph)>>mouseUp:
SpPluggableButtonMorph(Morph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
SpPluggableButtonMorph(Morph)>>handleEvent:
SpPluggableButtonMorph(Morph)>>handleFocusEvent:
[
		result := focusHolder handleFocusEvent: transformedEvent.
	] in HandMorph>>sendFocusEvent:to:clear:
FullBlockClosure(BlockClosure)>>on:do:
WorldMorph>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil ]) ifTrue: [
			morphicWorld activeHand handleEvent: anEvent
		]
	] in OSWindowMorphicEventHandler>>dispatchMorphicEvent:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycleNow
WorldMorph>>doOneCycle
[
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMutex critical: [
			                     self extraWorldList ].
		extraWorldsToDraw do: [ :world | world doOneCycle ].

		(self currentWorld isNotNil and: [
			 (extraWorldsToDraw includes: self currentWorld) not ]) ifTrue: [
			self currentWorld doOneCycle ] ] in WorldMorph class>>doOneCycle
FullBlockClosure(BlockClosure)>>ensure:
WorldState class>>doDrawCycleWith:
WorldMorph class>>doOneCycle
MorphicRenderLoop>>doOneCycle
MorphicRenderLoop>>doOneCycleWhile:
[ MorphicRenderLoop new doOneCycleWhile: [ true ] ] in MorphicUIManager>>spawnNewProcess
[self value.
			"IMPORTANT: Do not step over next line of code. See method comments for details"
			Processor terminateRealActive] in FullBlockClosure(BlockClosure)>>newProcess
-------------------------------------------------------------------------------

