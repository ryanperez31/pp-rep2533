----QUIT----2023-10-11T17:20:33.681381+02:00 Pharo11-SNAPSHOT-64bit-ea28d85.image priorSource: 0!----QUIT----2023-10-11T17:21:09.725751+02:00 Pharo11-SNAPSHOT-64bit-ea28d85.image priorSource: 0!----QUIT----2023-10-23T22:08:45.328-05:00 Visualizer.image priorSource: 99!Object subclass: #VisualizerMain	instanceVariableNames: '' 	classVariableNames: ''	package: 'Visualizer'!!BaselineOfNeoJSON commentStamp: '' prior: 0!I am BaselineOfNeoJSON, I load the code for the NeoJSON project.I am a BaselineOf.!!BaselineOfNeoJSON methodsFor: 'baselines'!baseline: spec	<baseline>	spec		for: #common		do: [ spec				package: 'Neo-JSON-Core';				package: 'Neo-JSON-Tests' with: [ spec requires: #('Neo-JSON-Core') ];				group: 'default' with: #('core' 'tests');				group: 'core' with: #('Neo-JSON-Core');				group: 'tests' with: #('Neo-JSON-Tests') ].	spec		for: #pharo		do: [ spec				package: 'Neo-JSON-Pharo-Core' with: [ spec requires: #('Neo-JSON-Core') ];				package: 'Neo-JSON-Pharo-Tests' with: [ spec requires: #('Neo-JSON-Tests') ];				package: 'Neo-JSON-Pharo-Examples' with: [ spec requires: #('Neo-JSON-Core') ];				package: 'Neo-JSON-GT' with: [ spec requires: #('Neo-JSON-Core') ];				group: 'core' with: #('Neo-JSON-Core' 'Neo-JSON-Pharo-Core');				group: 'tests' with: #('Neo-JSON-Tests' 'Neo-JSON-Pharo-Tests');				group: 'examples' with: #('Neo-JSON-Pharo-Examples');				group: 'gt' with: #('Neo-JSON-GT') ].! !"BaselineOfNeoJSON"!!NeoJSONFloatPrinter commentStamp: '' prior: 0!I am NeoJSONFloatPrinter.I print Float numbers in a compact, human friendly format.The following (default) parameters are used: - base 10 - hardcoded (for now) - precision 5 digits - decimal point - hardcoded (for now) - exponent e - hardcoded (for now) - NaN, Inf and -Inf - hardcoded (for now) - lower 1e-4 - upper 1e6 - decimal notation for abs values inside abs [ lower, upper ] - scientific notation for abs values outside [ lower, upper ] - no padding, no trailing zeros in fraction part - only negative sign, never a positive sign - no thousands separators - no engineering notationSee my class side for configuration examples.My public interface is in the printing protocol.!!NeoJSONMapper commentStamp: '' prior: 0!I am NeoJSONMapper.I hold a mapping from schema identifiers to objects that known how to read or write instances from or to JSON.Schema identifiers are either Smalltalk classes or Symbols.I offer a builder interface to construct mappings. The standard object mapping represents a Smalltalk object as a map, mapping some or all instance variables, or a set of accessors (getter/setter methods). Furthermore, for each value an optional schema can be specified.Using a custom mapping, a reader and/or writer block can deal with special cases such as specific collection types with an optional schema for the elements, or a direct mapping of semi primitive types such as Date or DateAndTime.A mapping can be specified explicitely on a mapper, or can be resolved using the #neoJsonMapping: class method.Here are some examples:	mapper mapAllInstVarsFor: Point.	mapper for: TestObject do: [ :mapping |		mapping mapInstVars: #(id name).		(mapping mapInstVar: #timestamp to: 'created-at') valueSchema: DateAndTime.		(mapping mapInstVar: #points) valueSchema: #ArrayOfPoints.		(mapping mapInstVar: #bytes) valueSchema: ByteArray ].	mapper for: DateAndTime customDo: [ :mapping |		mapping decoder: [ :string | DateAndTime fromString: string ].		mapping encoder: [ :dateAndTime | dateAndTime printString ] ].	mapper for: #ArrayOfPoints customDo: [ :mapping |		mapping listOfElementSchema: Point ].  	mapper for: ByteArray customDo: [ :mapping |		mapping listOfType: ByteArray ]!!NeoJSONReader commentStamp: '' prior: 0!I am NeoJSONReader.I am a NeoJSONMapper.I parse a JSON representation from a textual stream into Smalltalk objects.Primitive types are automatically mapped to their Smalltalk counterpart: Numbers, Strings, Booleans and UndefinedObject.When parsing using #next, lists normally become Arrays and maps become Dictionaries.An alternative listClass or mapClass can be specified.When parsing using #nextAs: a schema can be specified. This schema defines a mapping to be used.Here are some examples:	NeoJSONReader fromString: ' [ 1,2,3 ] '.	NeoJSONReader fromString: ' [ 3.14159, true, false, null, "string" ] '.	NeoJSONReader fromString: ' { "x" : 1, "y" : 2 } '.		(NeoJSONReader on: ' { "x" : 1, "y" : 2 } ' readStream)		mapInstVarsFor: Point;		nextAs: Point.					(NeoJSONReader on: '[ { "x" : 1, "y" : 2 }, { "x" : 3, "y" : 4 } ]' readStream)		mapInstVarsFor: Point;		for: #ArrayOfPoints customDo: [ :mapping |			mapping listOfElementSchema: Point ];		nextAs: #ArrayOfPoints.	(NeoJSONReader on: '[ { "x" : 1, "y" : 2 }, { "x" : 3, "y" : 4 } ]' readStream)		mapInstVarsFor: Point;		nextListAs: Point.!!NeoJSONWriter commentStamp: '' prior: 0!I am NeoJSONWriter.I am a NeoJSONMapper.I write a JSON representation of Smalltalk objects to a textual stream.Objects implementing #neoJsonOn: can be encoded.A number of primitive types, like Strings, Numbers, Booleans and UndefinedObject are treated specially.Collection are encoded as lists, except for Dictionaries that are encoded as maps.All other objects need a mapping to help in doing the encoding.Here are some examples:	NeoJSONWriter toString: #(1 2 3).	NeoJSONWriter toString: { Float pi. true. false. 'string' }.	NeoJSONWriter toStringPretty: (Dictionary new at: #x put: 1; at: #y put: 2; yourself).		String streamContents: [ :stream |		(NeoJSONWriter on: stream)			prettyPrint: true;			mapInstVarsFor: Point;			nextPut: (Array with: 1@3 with: -1@3) ].	!!NeoJSONMapping commentStamp: '' prior: 0!I am NeoJSONMapping, an abstract superclass for mapping definitions.!!NeoJSONCustomMapping commentStamp: '' prior: 0!I am NeoJSONCustomMapping.I read the next JSON value and turn it into a Smalltalk object using a converter block.!!NeoJSONObjectMapping commentStamp: '' prior: 0!I am NeoJSONObjectMapping.I describe how instances of a Smalltalk class are mapped to a JSON map.I do this using set of NeoJSONPropertyMappings.I know the Smalltalk class that I am a mapping for. This class is the schema identifier and is used to instanciate new objects.A mapping can be based on any combination of instance variables or accessors (getter/setter pairs). I offer a builder interface to constuct property mappings.!!NeoJSONPropertyMapping commentStamp: '' prior: 0!I am NeoJSONPropertyMapping.I describe how a property of a Smalltalk class maps to a JSON property.A property is either an instance variable or getter/setter pair.I hold a getter and setter block to do the actual work. The property name is used in JSON.Optionally, the schema for the value of my property can be specified. This is then used recursively.!!NeoJSONStreamingWriter commentStamp: '' prior: 0!I am NeoJSONStreamingWriter.I help in writing streamed maps and lists.This is an internal class used by NeoJSONWriter to deal with interleaving elements and separators as well as pretty printing.!!NeoJSONMappingNotFound commentStamp: '' prior: 0!I am NeoJSONMappingNotFound. I am signalled when no mapping is found for a schema.Portability comment: In Pharo,  I could technically subclass from NotFound directly, avoid all my defined methods and only keep #messageText and #standardMessageText. However, NotFound exception does not exist in other dialects. To keep NeoJSON as portable as possible we duplicate some Pharo code into myself. !!NeoJSONParseError commentStamp: '' prior: 0!I am NeoJSONParseError.I am an Error.I am signalled when JSON input is not valid while parsing.!!NeoJSONObject commentStamp: '' prior: 0!I am NeoJSONObject.I am an OrderedDictionary.I behave more like a JavaScript object. I return nil for missing keys. I allow any property to be read or set by using a normal accessor message.The following are equivalent:	self foo.	self at: #foo.As are the following	self foo: 1. 	self at: #foo put: 1.	Except that in the first case, self is returned.I can optionally be used by NeoJSONReader as mapClass (see #mapClass:).For output, I act just like my superclass (it is thus not necessary to do any conversions).Example:	NeoJSONObject fromString: '{"foo":1,"bar":-2}'.	NeoJSONObject new foo: 1; bar: -2.	{ #x -> 100. #y -> 200 } as: NeoJSONObject.	(NeoJSONObject new data: (NeoJSONObject new id: #sensor1; value: 37.5)) asString.I use JSON as my printed representation. To convert me to JSON, use #printString or #asString.Additionally, I support path access for nested instances of me, using #atPath: and #atPath:put:The first is special because it returns nil as soon as a key is missing. The second is special because it creates extra levels (instances of me) as needed to follow the path of keys.	NeoJSONObject new atPath: #(one two three) put: 42; yourself.	NeoJSONObject new atPath: #(one two three) put: 42; atPath: #(one two three).The fact that I am an OrderedDictionary means to I maintain the order of keys. This is meant as a convenience feature only as the official JSON specification clearly states "An object is an unordered set of name/value pairs".!!NeoJSONArray commentStamp: '' prior: 0!I am NeoJSONArray.I am an Array.I am often used in combination with NeoJSONObject, to represent the result of parsing JSON.Used in its generic way, NeoJSONParser will return Arrays and Dictionaries.Returning NeoJSONArrays and NeoJSONObjects, simple subclasses, allows to add some convenience methods.!!NeoJSONFloatPrinter class methodsFor: 'instance creation'!lowPrecision	^ self new		precision: 2;		lower: 1e-2;		upper: 1e5;		yourself! !!NeoJSONFloatPrinter class methodsFor: 'instance creation'!scientificOnly	^ self new		lower: 0;		upper: 0;		yourself! !!NeoJSONFloatPrinter methodsFor: 'constants'!decimalPoint	^ $.! !!NeoJSONFloatPrinter methodsFor: 'constants'!exponent	^ $e! !!NeoJSONFloatPrinter methodsFor: 'constants'!infinite	^ 'Inf'! !!NeoJSONFloatPrinter methodsFor: 'initialize-release'!initialize	super initialize.	base := 10.	precision := 5.	lower := 1e-4.	upper := 1e6! !!NeoJSONFloatPrinter methodsFor: 'initialize-release'!lower: number	lower := number! !!NeoJSONFloatPrinter methodsFor: 'constants'!nan	^ 'NaN'! !!NeoJSONFloatPrinter methodsFor: 'initialize-release'!precision: numberOfDigits	self assert: (numberOfDigits between: 1 and: 20).	precision := numberOfDigits! !!NeoJSONFloatPrinter methodsFor: 'printing'!print: float	^ String new: 16 streamContents: [ :out | 			self print: float on: out ]! !!NeoJSONFloatPrinter methodsFor: 'private'!print: float decimalOn: stream	stream print: float asInteger.	stream nextPut: self decimalPoint.	self 		print: (float fractionPart * (base raisedTo: precision)) rounded 		fractionOn: stream! !!NeoJSONFloatPrinter methodsFor: 'private'!print: fractionPart fractionOn: stream	| zeros |	zeros := 0. "leading zeros are significant, trailing zeros are not printed"	precision to: 1 by: -1 do: [ :position | | digit |		digit := fractionPart digitAt: position base: base.		digit = 0			ifTrue: [ zeros := zeros +1 ]			ifFalse: [				zeros > 0 ifTrue: [ 					zeros timesRepeat: [ stream nextPut: $0 ]. 					zeros := 0 ].				stream nextPut: digit asCharacterDigit ] ]! !!NeoJSONFloatPrinter methodsFor: 'printing'!print: float on: stream	| int abs |	(float isZero or: [ float isFinite not ])		ifTrue: [ ^ self print: float specialOn: stream ].	self print: float signOn: stream.	((abs := float abs) between: lower and: upper)		ifTrue: [ 			(int := abs asInteger) = abs 				ifTrue: [ int printOn: stream ]				ifFalse: [ self print: abs decimalOn: stream ] ]		ifFalse: [ self print: abs scientificOn: stream ]! !!NeoJSONFloatPrinter methodsFor: 'private'!print: float scientificOn: stream	| exponent mantissa |	exponent := (float ln / base ln) floor.	mantissa := float / (base raisedTo: exponent).	self print: mantissa decimalOn: stream.	stream		nextPut: self exponent;		print: exponent! !!NeoJSONFloatPrinter methodsFor: 'private'!print: float signOn: stream	float sign = -1		ifTrue: [ stream nextPut: $- ]! !!NeoJSONFloatPrinter methodsFor: 'private'!print: float specialOn: stream	float isZero		ifTrue: [ 			stream nextPut: $0 ]		ifFalse: [			float isNaN 				ifTrue: [ 					stream nextPutAll: self nan ]				ifFalse: [					self print: float signOn: stream.					stream nextPutAll: self infinite ] ]! !!NeoJSONFloatPrinter methodsFor: 'printing'!printFloat: float on: stream	self print: float on: stream! !!NeoJSONFloatPrinter methodsFor: 'initialize-release'!upper: number	upper := number! !!NeoJSONMapper methodsFor: 'private'!customMappingFor: schemaName	^ self mappings		at: schemaName		ifAbsentPut: [ 			NeoJSONCustomMapping new				schemaName: schemaName;				yourself ]! !!NeoJSONMapper methodsFor: 'mapping'!for: schemaName customDo: block	"Execute the code in block to further customize the mapping for schemaName.	Create and add a new custom mapping for schemaName if necessary."		| mapping |	mapping := self customMappingFor: schemaName.	block value: mapping.	^ mapping! !!NeoJSONMapper methodsFor: 'mapping'!for: smalltalkClass do: block	"Execute the code in block to further customize the mapping for schemaName.	Create and add a new standard object mapping for schemaName if necessary."		| mapping |	mapping := self objectMappingFor: smalltalkClass.	block value: mapping.	^ mapping! !!NeoJSONMapper methodsFor: 'convencience'!mapAllInstVarsFor: smalltalkClass	"Map the instance variables of smalltalkClass and all its super classes"	| mapping |	mapping := self objectMappingFor: smalltalkClass.	mapping mapAllInstVars.	^ mapping! !!NeoJSONMapper methodsFor: 'convencience'!mapInstVarsFor: smalltalkClass	"Map the instance variables of smalltalkClass"	| mapping |	mapping := self objectMappingFor: smalltalkClass.	mapping mapInstVars.	^ mapping! !!NeoJSONMapper methodsFor: 'accessing'!mappingFor: schema	^ self 		mappingFor: schema 		ifAbsent: [ NeoJSONMappingNotFound signalFor: schema in: self ]! !!NeoJSONMapper methodsFor: 'accessing'!mappingFor: schema ifAbsent: block	(self mappings includesKey: schema)		ifFalse: [ self resolveMappingFor: schema ].	^ self mappings		at: schema		ifAbsent: block! !!NeoJSONMapper methodsFor: 'private'!mappings	^ mappings		ifNil: [ mappings := Dictionary new ]! !!NeoJSONMapper methodsFor: 'private'!objectMappingFor: smalltalkClass	^ self mappings		at: smalltalkClass		ifAbsentPut: [ 			NeoJSONObjectMapping new				subjectClass: smalltalkClass;				yourself ]! !!NeoJSONMapper methodsFor: 'private'!resolveMappingFor: class	(class respondsTo: #neoJsonMapping:)		ifTrue: [ 			class perform: #neoJsonMapping: with: self ]! !!NeoJSONReader class methodsFor: 'convenience'!fromString: string	^ (self on: string readStream) next! !!NeoJSONReader class methodsFor: 'convenience'!fromString: string as: schema	^ (self on: string readStream) nextAs: schema! !!NeoJSONReader class methodsFor: 'instance creation'!on: readStream	"Initialize on readStream, which should be a character stream that 	implements #next, #peek, #atEnd and (optionally) #close."	^ self new		on: readStream;		yourself! !!NeoJSONReader methodsFor: 'testing'!atEnd	^ readStream atEnd! !!NeoJSONReader methodsFor: 'initialize-release'!close	readStream ifNotNil: [		readStream close.		readStream := nil ]! !!NeoJSONReader methodsFor: 'private'!consumeWhitespace	"Strip whitespaces from the input stream."	[ readStream atEnd not and: [ readStream peek isSeparator ] ]		whileTrue: [ 			readStream next ]! !!NeoJSONReader methodsFor: 'private'!error: text	NeoJSONParseError signal: text! !!NeoJSONReader methodsFor: 'private'!expectChar: character	"Expect character and consume input and optional whitespace at the end,	 throw an error otherwise."	(self matchChar: character)		ifFalse: [ self error: character asString, ' expected' ]! !!NeoJSONReader methodsFor: 'parsing'!failIfNotAtEnd	self atEnd		ifFalse: [ self error: 'extraneous input detected' ]! !!NeoJSONReader methodsFor: 'initialize-release'!initialize 	super initialize.	propertyNamesAsSymbols := false! !!NeoJSONReader methodsFor: 'accessing'!listClass	"Return the collection type to use for JSON lists"		^ listClass ifNil: [ Array ]! !!NeoJSONReader methodsFor: 'initialize-release'!listClass: collectionClass	listClass := collectionClass! !!NeoJSONReader methodsFor: 'accessing'!mapClass	"Return the collection type to use for JSON maps"		^ mapClass ifNil: [ Dictionary ]! !!NeoJSONReader methodsFor: 'initialize-release'!mapClass: collectionClass	mapClass := collectionClass! !!NeoJSONReader methodsFor: 'private'!match: string do: block	"Try to read and consume string and execute block if successful.	Else do nothing (but do not back up)"	(string allSatisfy: [ :each | readStream peekFor: each ])		ifTrue: [ 			self consumeWhitespace.			block value ]! !!NeoJSONReader methodsFor: 'private'!matchChar: character	"Tries to match character, consume input and 	answer true if successful and consumes whitespace at the end.	When character does not match, return false and leave stream untouched."	^ (readStream peekFor: character)		ifTrue: [ 			self consumeWhitespace.			true ]		ifFalse: [ false ]! !!NeoJSONReader methodsFor: 'accessing'!next	"Primary interface to parse a JSON value.	Return either primitives, a listClass or a mapClass instance."		^ self 		consumeWhitespace; 		parseValue! !!NeoJSONReader methodsFor: 'accessing'!nextAs: schema	"Secondary interface to parse JSON.	Return an object according to schema.	If schema is nil, act like #next"		| mapping |	schema ifNil: [ ^ self next ].	self consumeWhitespace.	mapping := self mappingFor: schema.	^ mapping readFrom: self! !!NeoJSONReader methodsFor: 'accessing'!nextListAs: schema	"Secondary interface to parse JSON.	Return a list of objects, each element according to schema."		^ self listClass streamContents: [ :stream |			self parseListDo: [ 				stream nextPut: (self nextAs: schema) ] ]! !!NeoJSONReader methodsFor: 'initialize-release'!on: aReadStream	"Initialize on aReadStream, which should be a character stream that 	implements #next, #peek, #atEnd and (optionally) #close."		readStream := aReadStream! !!NeoJSONReader methodsFor: 'parsing'!parseCharacter	| char |	(char := readStream next) = $\ 		ifFalse: [ ^ char ].	('/"\' includes: (char := readStream next))		ifTrue: [ ^ char ].	('bfnrt' includes: char)		ifTrue: [ ^ self unescapeChar: char ].	char = $u		ifTrue: [ ^ self parseCharacterHex ].	char 		ifNil: [ self error: 'invalid escape, end of file' ]		ifNotNil: [ self error: 'invalid escape character \' , char asString ]! !!NeoJSONReader methodsFor: 'private'!parseCharacterHex	| value codePoint |	value := self parseCharacterHex4Value.	(value < 16rD800 or: [ value > 16rDBFF ])		ifTrue: [ codePoint := value ]		ifFalse: [ | leadSurrogate trailSurrogate |			"Characters not in the Basic Multilingual Plane are encoded as a UTF-16 surrogate pair"			"See https://tools.ietf.org/html/rfc7159#section-7"			leadSurrogate := value.			trailSurrogate := self parseTrailingSurrogateHexEscape.			codePoint := (leadSurrogate - 16rD800) * 16r400 + (trailSurrogate - 16rDC00).			codePoint := 16r10000 + codePoint.			codePoint > 16r10FFFF 				ifTrue: [ self error: 'Character Unicode code point outside encoder range' ] ].	^ Character codePoint: codePoint! !!NeoJSONReader methodsFor: 'private'!parseCharacterHex4Value	| value |	value := self parseCharacterHexDigit.	3 timesRepeat: [ 		value := (value << 4) + self parseCharacterHexDigit ].	^ value! !!NeoJSONReader methodsFor: 'private'!parseCharacterHexDigit	| digit |	readStream atEnd 		ifFalse: [ 			digit := readStream next asInteger.			(digit between: "$0" 48 and: "$9" 57)				ifTrue: [ ^ digit - 48 ].			(digit between: "$A" 65 and: "$F" 70)				ifTrue: [ ^ digit - 55 ].			(digit between: "$a" 97 and: "$f" 102)				ifTrue: [ ^ digit - 87 ] ].	self error: 'hex-digit expected'! !!NeoJSONReader methodsFor: 'private'!parseConstantDo: block	"Parse and consume either true|false|nil|null and execute block 	or else do nothing (but do not back up).	Hand written implementation to avoid the use of #position:"		(readStream peek = $t)		ifTrue: [			^ self match: 'true' do: [ block value: true ] ].	(readStream peek = $f)		ifTrue: [			^ self match: 'false' do: [ block value: false ] ].	(readStream peek = $n)		ifTrue: [			^ self match: 'null' do: [ block value: nil ] ]! !!NeoJSONReader methodsFor: 'parsing'!parseList	^ self listClass 		streamContents: [ :stream |			self parseListElementsDo: [ :each |				stream nextPut: each ] ]		! !!NeoJSONReader methodsFor: 'parsing'!parseListDo: block	self expectChar: $[.	(self matchChar: $]) 		ifTrue: [ ^ self ].	[ readStream atEnd ] 		whileFalse: [			block value.			(self matchChar: $]) 				ifTrue: [ ^ self ].			(self matchChar: $,)				ifFalse: [ self error: ', or ] expected' ] ].	self error: 'incomplete list'! !!NeoJSONReader methodsFor: 'parsing'!parseListElementsDo: block	self parseListDo: [ 		block value: self parseValue ]! !!NeoJSONReader methodsFor: 'parsing'!parseMap	| map |	map := self mapClass new.	self parseMapKeysAndValuesDo: [ :key :value |		map at: key put: value ].	^ map! !!NeoJSONReader methodsFor: 'parsing'!parseMapDo: block	self expectChar: ${.	(self matchChar: $})		ifTrue: [ ^ self ].	[ readStream atEnd ] whileFalse: [		block value.		(self matchChar: $}) 			ifTrue: [ ^ self ].		(self matchChar: $,)			ifFalse: [ self error: ', or } expected' ] ].	self error: 'incomplete map'! !!NeoJSONReader methodsFor: 'parsing'!parseMapKeysAndValuesDo: block	self parseMapKeysDo: [ :key |		block value: key value: self parseValue ]! !!NeoJSONReader methodsFor: 'parsing'!parseMapKeysDo: block	self parseMapDo: [ | key |		key := self parsePropertyName.		self expectChar: $:.		block value: key ]! !!NeoJSONReader methodsFor: 'parsing'!parseNumber	| negated number isFloat |	negated := readStream peekFor: $-.	number := self parseNumberInteger.	isFloat := (readStream peekFor: $.)		ifTrue: [ number := number + self parseNumberFraction. true ]		ifFalse: [ false ].	((readStream peekFor: $e) or: [ readStream peekFor: $E ])		ifTrue: [ number := number * self parseNumberExponent ].	isFloat ifTrue: [ number := number asFloat ].	negated		ifTrue: [ number := number negated ].	self consumeWhitespace.	^ number! !!NeoJSONReader methodsFor: 'parsing'!parseNumberExponent	| number negated |	number := 0.	(negated := readStream peekFor: $-)		ifFalse: [ readStream peekFor: $+ ].	(readStream atEnd or: [ readStream peek isDigit not ])		ifTrue: [ self error: 'number exponent expected' ].	[ readStream atEnd not and: [ readStream peek isDigit ] ]		whileTrue: [ number := 10 * number + readStream next digitValue ].	negated		ifTrue: [ number := number negated ].	number positive 		ifTrue: [ number > Float emax ifTrue: [ self error: 'number exponent too large' ] ]		ifFalse: [ number < Float emin ifTrue: [ self error: 'number exponent too small' ] ].	^ 10 raisedTo: number! !!NeoJSONReader methodsFor: 'parsing'!parseNumberFraction	| number power |	number := 0.	power := 1.	[ readStream atEnd not and: [ readStream peek isDigit ] ] 		whileTrue: [			number := 10 * number + readStream next digitValue.			power := power * 10 ].	^ number / power! !!NeoJSONReader methodsFor: 'parsing'!parseNumberInteger	| number |	number := nil.	[ readStream atEnd not and: [ readStream peek isDigit ] ] 		whileTrue: [ 			number := 10 * (number ifNil: [ 0 ]) + readStream next digitValue ].	number ifNil: [ self error: 'Integer digit expected' ].	^ number! !!NeoJSONReader methodsFor: 'parsing'!parsePropertyName	| name |	name := self parseValue.	^ name isString		ifTrue: [ 			propertyNamesAsSymbols 				ifTrue: [ name asSymbol ]				ifFalse: [ name ] ]		ifFalse: [ 			self error: 'property name must be a string, not ', name asString ]! !!NeoJSONReader methodsFor: 'parsing'!parseString	| result |	(readStream peekFor: $")		ifFalse: [ self error: '" expected' ].	result := self stringStreamContents: [ :stream | 		[ readStream atEnd or: [ readStream peek = $" ] ] 			whileFalse: [ stream nextPut: self parseCharacter ] ].	self expectChar: $".	^ result! !!NeoJSONReader methodsFor: 'private'!parseTrailingSurrogateHexEscape	(readStream next = $\ and: [ readStream next = $u ])		ifTrue: [ ^ self parseCharacterHex4Value ]		ifFalse: [ self error: 'trailing surrogate hex escape expected' ]! !!NeoJSONReader methodsFor: 'parsing'!parseValue	| char |	readStream atEnd ifFalse: [ 		char := readStream peek.		char = ${			ifTrue: [ ^ self parseMap ].		char = $[			ifTrue: [ ^ self parseList ].		char = $"			ifTrue: [ ^ self parseString ].		(char = $- or: [ char isDigit ])			ifTrue: [ ^ self parseNumber ].		self parseConstantDo: [ :value | ^ value ] ].	self error: 'invalid input: ', char asString! !!NeoJSONReader methodsFor: 'initialize-release'!propertyNamesAsSymbols: boolean	propertyNamesAsSymbols := boolean! !!NeoJSONReader methodsFor: 'private'!stringStreamClass	"Answer the class of the collection used for the stringStream of receiver.		NOTE: It is String, but if receiver's readStream is over 	another class of String, then this provides compatibility for that."	^ readStream collectionSpecies! !!NeoJSONReader methodsFor: 'private'!stringStreamContents: block	"Like String streamContents: block	but reusing the underlying buffer for improved efficiency"	stringStream ifNil: [ 		stringStream := (self stringStreamClass new: 32) writeStream ].	stringStream reset.	block value: stringStream.	^ stringStream contents! !!NeoJSONReader methodsFor: 'private'!unescapeChar: char	"Handle one of the named character escapes, b, f, n, r or t. Else fail."		char = $b		ifTrue: [ ^ Character backspace ].	char = $f		ifTrue: [ ^ Character newPage ].	char = $n		ifTrue: [ ^ Character lf ].	char = $r		ifTrue: [ ^ Character cr ].	char = $t		ifTrue: [ ^ Character tab ].	self error: 'Unknown escape char: ', (String with: char)! !!NeoJSONWriter class methodsFor: 'instance creation'!on: writeStream	"Initialize on writeStream, which should be a character stream that 	implements #nextPut:, #nextPutAll:, #space and (optionally) #close."	^ self new		on: writeStream;		yourself! !!NeoJSONWriter class methodsFor: 'convenience'!toString: object	^ String streamContents: [ :stream |			(self on: stream) nextPut: object ]! !!NeoJSONWriter class methodsFor: 'convenience'!toStringPretty: object	^ String streamContents: [ :stream |			(self on: stream)				prettyPrint: true; 				nextPut: object ]! !!NeoJSONWriter methodsFor: 'initialize-release'!asciiOnly: boolean	"Set whether I should escape all non ASCII characters or not"		asciiOnly := boolean! !!NeoJSONWriter methodsFor: 'initialize-release'!close	"Close the stream that I write to"		writeStream ifNotNil: [		writeStream close.		writeStream := nil ]! !!NeoJSONWriter methodsFor: 'private'!doesCodePointNeedEscaping: code	code < 32 ifTrue: [ ^ true ].	( code = 34 or: [ code = 92 ]) ifTrue: [ ^ true ].	^ asciiOnly and: [ code > 126 ]	! !!NeoJSONWriter methodsFor: 'private'!encodeChar: char	| code |	code := char codePoint.	(self doesCodePointNeedEscaping: code)		ifTrue: [ self escapeChar: code ]		ifFalse: [ writeStream nextPut: char ]! !!NeoJSONWriter methodsFor: 'private'!encodeKey: key	key isString ifFalse: [ ^ self error: 'JSON key names in objects must be strings' ].	self nextPut: key.	self prettyPrintSpace.	writeStream nextPut: $:.	self prettyPrintSpace! !!NeoJSONWriter methodsFor: 'private'!encodeKey: key value: value	self encodeKey: key.	self nextPut: value! !!NeoJSONWriter methodsFor: 'private'!encodeKey: key value: value as: valueSchema	self encodeKey: key.	self nextPut: value as: valueSchema! !!NeoJSONWriter methodsFor: 'private'!escapeChar: code	code = 34		ifTrue: [ ^ writeStream nextPutAll: '\"' ].	code = 92		ifTrue: [ ^ writeStream nextPutAll: '\\' ].	code = 47		ifTrue: [ ^ writeStream nextPutAll: '\/' ].	code = 8		ifTrue: [ ^ writeStream nextPutAll: '\b' ].	code = 12		ifTrue: [ ^ writeStream nextPutAll: '\f' ].			code = 10		ifTrue: [ ^ writeStream nextPutAll: '\n' ].			code = 13		ifTrue: [ ^ writeStream nextPutAll: '\r' ].			code = 9		ifTrue: [ ^ writeStream nextPutAll: '\t' ].			self escapeUnicode: code! !!NeoJSONWriter methodsFor: 'private'!escapeUnicode4: codePoint	writeStream nextPutAll: '\u'.	codePoint printOn: writeStream base: 16 nDigits: 4! !!NeoJSONWriter methodsFor: 'private'!escapeUnicode: codePoint	codePoint <= 16rFFFF		ifTrue: [ self escapeUnicode4: codePoint ]		ifFalse: [ 			codePoint <= 16r10FFFF				ifTrue: [ | leadSurrogate trailSurrogate shifted |					"Characters not in the Basic Multilingual Plane are encoded as a UTF-16 surrogate pair"					"See https://tools.ietf.org/html/rfc7159#section-7"					shifted := codePoint - 16r10000.					leadSurrogate := 16rD800 + (shifted // 16r400).					trailSurrogate := 16rDC00 + (shifted \\ 16r400).					self escapeUnicode4: leadSurrogate.					self escapeUnicode4: trailSurrogate ]				ifFalse: [ self error: 'Character Unicode code point outside encoder range' ] ]! !!NeoJSONWriter methodsFor: 'initialize-release'!floatPrinter: anObject	"Set the float print, an object that implements #printFloat:on:	By default, I am my own float printer"		floatPrinter := anObject! !!NeoJSONWriter methodsFor: 'private'!indentedDo: block	level := level + 1.	block value.	level := level - 1! !!NeoJSONWriter methodsFor: 'initialize-release'!initialize	super initialize.	self newLine: OSPlatform current lineEnding.	self prettyPrint: false.	self asciiOnly: false.	self writeNil: false.	self floatPrinter: self.	level := 0! !!NeoJSONWriter methodsFor: 'private'!listElementSeparator	writeStream nextPut: $,.	self newlineIndent! !!NeoJSONWriter methodsFor: 'private'!mapElementSeparator	writeStream nextPut: $,.	self newlineIndent! !!NeoJSONWriter methodsFor: 'initialize-release'!newLine: string	"Set the newline string that I should use when pretty printing"		newLine := string! !!NeoJSONWriter methodsFor: 'accessing'!newline	"Write a newline on the stream that I wrap.	What gets written depends on the configuration, see #newLine:"		writeStream nextPutAll: newLine! !!NeoJSONWriter methodsFor: 'private'!newlineIndent	prettyPrint		ifTrue: [ 			self newline.			level timesRepeat: [ writeStream nextPut: Character tab ] ]! !!NeoJSONWriter methodsFor: 'accessing'!nextPut: anObject	"Primary interface. Write a JSON representation of anObject to my stream."		anObject neoJsonOn: self! !!NeoJSONWriter methodsFor: 'accessing'!nextPut: anObject as: schema	"Secondary interface to write JSON.	Write objects according to schema."		| mapping |	(schema isNil or: [ anObject isNil ]) ifTrue: [ ^ self nextPut: anObject ].	mapping := self mappingFor: schema.	^ mapping writeObject: anObject on: self! !!NeoJSONWriter methodsFor: 'initialize-release'!on: aWriteStream	"Initialize on aWriteStream, which should be a character stream that 	implements #nextPut:, #nextPutAll:, #space and (optionally) #close."	writeStream := aWriteStream! !!NeoJSONWriter methodsFor: 'initialize-release'!prettyPrint: boolean	"Set whether I should pretty print the JSON that I write"	prettyPrint := boolean! !!NeoJSONWriter methodsFor: 'private'!prettyPrintSpace	prettyPrint		ifTrue: [ writeStream nextPut: Character space ]! !!NeoJSONWriter methodsFor: 'printing'!printFloat: float on: stream	"See NeoJSONFloatPrinter for a custom float printer"		float printOn: stream! !!NeoJSONWriter methodsFor: 'writing'!writeBoolean: boolean	boolean printOn: writeStream! !!NeoJSONWriter methodsFor: 'writing'!writeFloat: float	floatPrinter printFloat: float on: writeStream! !!NeoJSONWriter methodsFor: 'writing'!writeInteger: integer	integer printOn: writeStream	! !!NeoJSONWriter methodsFor: 'writing'!writeList: collection	self writeListStreamingDo: [ :jsonListWriter |		collection do: [ :each |			jsonListWriter writeElement: each ] ]! !!NeoJSONWriter methodsFor: 'writing'!writeListStreamingDo: block	writeStream nextPut: $[.	self writeStreamingDo: block.	writeStream nextPut: $]! !!NeoJSONWriter methodsFor: 'writing'!writeMap: keyValueCollection	self writeMapStreamingDo: [ :jsonMapWriter |		keyValueCollection keysAndValuesDo: [ :key :value |			jsonMapWriter writeKey: key value: value ] ]! !!NeoJSONWriter methodsFor: 'writing'!writeMapStreamingDo: block	writeStream nextPut: ${.	self writeStreamingDo: block.	writeStream nextPut: $}! !!NeoJSONWriter methodsFor: 'accessing'!writeNil	"Return whether I will write nil/null properties of objects or skip them."		^ writeNil! !!NeoJSONWriter methodsFor: 'initialize-release'!writeNil: boolean	"Set whether I will write nil/null properties of objects or skip them."		writeNil := boolean! !!NeoJSONWriter methodsFor: 'writing'!writeNull	writeStream nextPutAll: 'null'! !!NeoJSONWriter methodsFor: 'writing'!writeObject: anObject	| mapping |	mapping := self mappingFor: anObject class.	mapping		writeObject: anObject		on: self! !!NeoJSONWriter methodsFor: 'writing'!writeStreamingDo: block	| mapWriter |	mapWriter := NeoJSONStreamingWriter on: self.	self indentedDo: [		block value: mapWriter ].	mapWriter wasUsed		ifTrue: [ self newlineIndent ]		ifFalse: [ self prettyPrintSpace ]! !!NeoJSONWriter methodsFor: 'writing'!writeString: string	writeStream nextPut: $".	1 to: string size do: [ :index |		self encodeChar: (string at: index) ].	writeStream nextPut: $"! !!NeoJSONCustomMapping methodsFor: 'mapping'!decoder: block	"Set a decoder block that accepts the next object representation read 	and converts it into the actual object to be returned."	self reader: [ :jsonReader | | representation |		representation := jsonReader next.		block value: representation ]! !!NeoJSONCustomMapping methodsFor: 'mapping'!encoder: block	"Set a encoder block that accepts the next object to be written 	and converts it into the actual representation to be written."	self writer: [ :jsonWriter :anObject | | representation |		representation := block value: anObject.		jsonWriter nextPut: representation ]! !!NeoJSONCustomMapping methodsFor: 'accessing'!identifier	^ schemaName ! !!NeoJSONCustomMapping methodsFor: 'mapping'!listOfElementSchema: elementSchema	"Set the reader to a block that will create an instance of the	standard listClass while reading a list of elements of type elementSchema"	self reader: [ :jsonReader |		jsonReader listClass streamContents: [ :stream |			jsonReader parseListDo: [ | element |				element := jsonReader nextAs: elementSchema.				stream nextPut: element ] ] ].	self writer: [ :jsonWriter :list | 		jsonWriter writeListStreamingDo: [ :listWriter |			list do: [ :each | listWriter writeElement: each as: elementSchema ] ] ]! !!NeoJSONCustomMapping methodsFor: 'mapping'!listOfType: collectionClass	"Set the reader to a block that will create an instance of collectionClass 	using #streamContents: while reading a list of elements"	self reader: [ :jsonReader |		collectionClass streamContents: [ :stream |			jsonReader parseListDo: [ | element |				element := jsonReader next.				stream nextPut: element ] ] ]	"we do not set a writer, #neoJsonOn: should be sufficient, no element type known anyway"! !!NeoJSONCustomMapping methodsFor: 'mapping'!listOfType: collectionClass andElementSchema: elementSchema	"Set the reader to a block that will create an instance of collectionClass 	using #streamContents: while reading a list of elements of type elementSchema"	self reader: [ :jsonReader |		collectionClass streamContents: [ :stream |			jsonReader parseListDo: [ | element |				element := jsonReader nextAs: elementSchema.				stream nextPut: element ] ] ].	self writer: [ :jsonWriter :list | 		jsonWriter writeListStreamingDo: [ :listWriter |			list do: [ :each | 				listWriter writeElement: each as: elementSchema ] ] ]! !!NeoJSONCustomMapping methodsFor: 'mapping'!mapWithValueSchema: valueSchema	"Set the reader to a block that will create an instance of the	standard mapClass while reading values of type valueSchema,	with standard keys"	self reader: [ :jsonReader | | map |		map := jsonReader mapClass new.		jsonReader parseMapKeysDo: [ :key | | value |				value := jsonReader nextAs: valueSchema.				map at: key put: value ].		map ].	self writer: [ :jsonWriter :map | 		jsonWriter writeMapStreamingDo: [ :mapWriter |			map keysAndValuesDo: [ :key :value | 				mapWriter writeKey: key value: value as: valueSchema ] ] ]! !!NeoJSONCustomMapping methodsFor: 'parsing'!readFrom: jsonReader	^ reader 		ifNil: [ jsonReader next ]		ifNotNil: [ reader value: jsonReader ]! !!NeoJSONCustomMapping methodsFor: 'accessing'!reader: block	"Set the reader to block, a 1 argument block that when given 	a jsonReader as argument reads the object that I represent.	When there is no reader block, the default #next will be used."		reader := block! !!NeoJSONCustomMapping methodsFor: 'accessing'!schemaName: schema	schemaName := schema! !!NeoJSONCustomMapping methodsFor: 'writing'!writeObject: anObject on: jsonWriter	writer 		ifNil: [ anObject neoJsonOn: jsonWriter ]		ifNotNil: [ writer value: jsonWriter value: anObject ]! !!NeoJSONCustomMapping methodsFor: 'accessing'!writer: block	"Set the writer to block, a 2 argument block that when given: a jsonWriter 	and the object to write will write the object that I represent.	When there is no writer block, the default #neoJsonOn: will be used."		writer := block! !!NeoJSONMapping methodsFor: 'accessing'!identifier	self subclassResponsibility ! !!NeoJSONMapping methodsFor: 'printing'!printOn: stream	super printOn: stream.	stream nextPut: $(; print: self identifier; nextPut: $)! !!NeoJSONMapping methodsFor: 'parsing'!readFrom: jsonReader	self subclassResponsibility ! !!NeoJSONMapping methodsFor: 'writing'!writeObject: anObject on: jsonWriter	self subclassResponsibility ! !!NeoJSONObjectMapping methodsFor: 'initialize-release'!allowNil	"Set that I will allow nil/null values when I read/expect an object"		allowNil := true! !!NeoJSONObjectMapping methodsFor: 'accessing'!identifier	^ subjectClass ! !!NeoJSONObjectMapping methodsFor: 'initialize-release'!initialize	super initialize.	properties := OrderedCollection new.	allowNil := false! !!NeoJSONObjectMapping methodsFor: 'mapping'!mapAccessor: accessor	^ self mapAccessor: accessor to: accessor ! !!NeoJSONObjectMapping methodsFor: 'mapping'!mapAccessor: accessor mutator: mutator to: propertyName	^ self 		mapProperty: propertyName		getter: [ :object | object perform: accessor ]		setter: [ :object :value | object perform: mutator with: value ] ! !!NeoJSONObjectMapping methodsFor: 'mapping'!mapAccessor: accessor to: propertyName	^ self 		mapProperty: propertyName		getter: [ :object | object perform: accessor ]		setter: [ :object :value | object perform: accessor asMutator with: value ] ! !!NeoJSONObjectMapping methodsFor: 'mapping'!mapAccessors: accessors	^ accessors collect: [ :each | self mapAccessor: each ]! !!NeoJSONObjectMapping methodsFor: 'convenience'!mapAllInstVars	^ self mapInstVars: subjectClass allInstVarNames! !!NeoJSONObjectMapping methodsFor: 'mapping'!mapInstVar: instVarName	^ self mapInstVar: instVarName to: instVarName ! !!NeoJSONObjectMapping methodsFor: 'mapping'!mapInstVar: instVarName to: propertyName	| index |	index := 		"For portability reasons, do not use instVarIndexFor:ifAbsent: 		(it doesn't exist in all Smalltalk dialects) but the below approach.		Also, convert to symbols for portability reasons"		(subjectClass allInstVarNames collect: [ :each | each asSymbol ]) 			indexOf: instVarName asSymbol 			ifAbsent: [ self error: 'Inst var not found: ', instVarName printString ].	^ self 		mapProperty: propertyName asString		getter: [ :object | object instVarAt: index ]		setter: [ :object :value | object instVarAt: index put: value ] 	! !!NeoJSONObjectMapping methodsFor: 'convenience'!mapInstVars	^ self mapInstVars: subjectClass instVarNames! !!NeoJSONObjectMapping methodsFor: 'mapping'!mapInstVars: instVarNames	^ instVarNames collect: [ :each | self mapInstVar: each ]! !!NeoJSONObjectMapping methodsFor: 'mapping'!mapProperty: propertyName getter: readBlock setter: writeBlock	| propertyMapping |	propertyMapping := NeoJSONPropertyMapping new.	propertyMapping 		propertyName: propertyName;		getter: readBlock;		setter: writeBlock.	properties removeAllSuchThat: [ :each | each propertyName = propertyMapping propertyName ].	properties addLast: propertyMapping.	^ propertyMapping ! !!NeoJSONObjectMapping methodsFor: 'accessing'!propertyNamed: propertyName ifAbsent: block	| symbolPropertyName |	symbolPropertyName := propertyName asSymbol.	^ properties detect: [ :each | each propertyName = symbolPropertyName ] ifNone: block! !!NeoJSONObjectMapping methodsFor: 'parsing'!readFrom: jsonReader	| anObject |	anObject := subjectClass new.	allowNil ifTrue: [ 		jsonReader parseConstantDo: [ :value | 			^ value ifNotNil: [ jsonReader error: 'Unexpected boolean constant' ] ] ].	jsonReader parseMapKeysDo: [ :key |		(self propertyNamed: key ifAbsent: [ nil ])			ifNil: [				"read, skip & ignore value"				jsonReader next ]			ifNotNil: [ :mapping |				mapping readObject: anObject from: jsonReader ] ].	^ anObject! !!NeoJSONObjectMapping methodsFor: 'accessing'!subjectClass: smalltalkClass	subjectClass := smalltalkClass! !!NeoJSONObjectMapping methodsFor: 'writing'!writeObject: anObject on: jsonWriter	jsonWriter writeMapStreamingDo: [ :jsonMapWriter |		properties do: [ :each |			each writeObject: anObject on: jsonMapWriter ] ]! !!NeoJSONPropertyMapping methodsFor: 'accessing'!getter: block	getter := block! !!NeoJSONPropertyMapping methodsFor: 'printing'!printOn: stream	super printOn: stream.	stream nextPut: $(; print: propertyName; nextPut: $)! !!NeoJSONPropertyMapping methodsFor: 'accessing'!propertyName	^ propertyName ! !!NeoJSONPropertyMapping methodsFor: 'accessing'!propertyName: symbolOrString	propertyName := symbolOrString asSymbol! !!NeoJSONPropertyMapping methodsFor: 'parsing'!readObject: anObject from: jsonReader	| value |	value := jsonReader nextAs: valueSchema.	setter value: anObject value: value! !!NeoJSONPropertyMapping methodsFor: 'accessing'!setter: block	setter := block! !!NeoJSONPropertyMapping methodsFor: 'accessing'!valueSchema: schemaName	valueSchema := schemaName! !!NeoJSONPropertyMapping methodsFor: 'writing'!writeObject: anObject on: jsonMapWriter	| value |	value := getter value: anObject.	(value notNil or: [ jsonMapWriter writeNil ])		ifTrue: [ jsonMapWriter writeKey: propertyName value: value as: valueSchema ] ! !!NeoJSONStreamingWriter class methodsFor: 'instance creation'!on: jsonWriter	^ self new		on: jsonWriter;		yourself! !!NeoJSONStreamingWriter methodsFor: 'initialize-release'!initialize	super initialize.	first := true! !!NeoJSONStreamingWriter methodsFor: 'initialize-release'!on: aJSONWriter	jsonWriter := aJSONWriter! !!NeoJSONStreamingWriter methodsFor: 'testing'!wasUsed	^ first not! !!NeoJSONStreamingWriter methodsFor: 'writing'!writeElement: value	first 		ifTrue: [ 			jsonWriter newlineIndent. 			first := false ]		ifFalse: [ 			jsonWriter listElementSeparator ].	jsonWriter nextPut: value ! !!NeoJSONStreamingWriter methodsFor: 'writing'!writeElement: value as: valueSchema	first 		ifTrue: [ 			jsonWriter newlineIndent. 			first := false ]		ifFalse: [ 			jsonWriter listElementSeparator ].	jsonWriter nextPut: value as: valueSchema! !!NeoJSONStreamingWriter methodsFor: 'writing'!writeKey: key value: value	first 		ifTrue: [ 			jsonWriter newlineIndent. 			first := false ]		ifFalse: [ 			jsonWriter mapElementSeparator ].	jsonWriter encodeKey: key value: value ! !!NeoJSONStreamingWriter methodsFor: 'writing'!writeKey: key value: value as: valueSchema	first 		ifTrue: [ 			jsonWriter newlineIndent. 			first := false ]		ifFalse: [ 			jsonWriter mapElementSeparator ].	jsonWriter encodeKey: key value: value as: valueSchema! !!NeoJSONStreamingWriter methodsFor: 'accessing'!writeNil	^ jsonWriter writeNil! !!Object methodsFor: '*neo-json-core'!neoJsonOn: neoJSONWriter	neoJSONWriter writeObject: self! !!Number methodsFor: '*neo-json-core'!neoJsonOn: neoJSONWriter	neoJSONWriter writeFloat: self asFloat! !!Dictionary methodsFor: '*neo-json-core'!neoJsonOn: neoJSONWriter	neoJSONWriter writeMap: self! !!UndefinedObject methodsFor: '*neo-json-core'!neoJsonOn: neoJSONWriter	neoJSONWriter writeNull! !!String methodsFor: '*neo-json-core'!neoJsonOn: neoJSONWriter	neoJSONWriter writeString: self! !!Boolean methodsFor: '*neo-json-core'!neoJsonOn: neoJSONWriter	neoJSONWriter writeBoolean: self! !!NeoJSONMappingNotFound class methodsFor: 'instance creation'!signalFor: anObject	"Create and signal an exception for anObject in the default receiver."		^ self new		object: anObject;		signal! !!NeoJSONMappingNotFound class methodsFor: 'instance creation'!signalFor: anObject in: aCollection	"Create and signal an exception for anObject in aCollection."	^ self new		object: anObject;		collection: aCollection;		signal! !!NeoJSONMappingNotFound methodsFor: 'accessing'!collection	"Return the collection where something is not found in"		^ collection! !!NeoJSONMappingNotFound methodsFor: 'accessing'!collection: aCollection	"Set the collection where something is not found in"		collection := aCollection! !!NeoJSONMappingNotFound methodsFor: 'accessing'!messageText	"Overwritten with standard text. To ease portability to other Smalltalk dialects we do not access the instVar 'messageText' as not all dialects have it. Not caching the value on the instVar shouldn't bring any performance hit in this case. "		^ self standardMessageText ! !!NeoJSONMappingNotFound methodsFor: 'accessing'!object	"Return the object that was not found"		^ object! !!NeoJSONMappingNotFound methodsFor: 'accessing'!object: anObject	"Set the object that was not found"		object := anObject! !!NeoJSONMappingNotFound methodsFor: 'private'!standardMessageText	^ String streamContents: [ :stream |		stream << 'No mapping found for '.		stream print: self object.		stream << ' in '.		stream print: self collection class ]! !!Integer methodsFor: '*neo-json-core'!neoJsonOn: neoJSONWriter	neoJSONWriter writeInteger: self! !!NeoJSONObject class methodsFor: 'example'!exampleMagnitudeClassHierarchy	<gtExample>	| builder |	builder := [ :aClass | 		NeoJSONObject new			name: aClass name;			superclass: aClass superclass name;			instanceVariables: aClass instVarNames;			category: aClass category;			totalInstanceVariablesCount: aClass allInstVarNames size;			methodCount: aClass methods size;			totalMethodCount: aClass allMethods size;			subclasses: (aClass subclasses 								collect: [ :aSubclass | builder value: aSubclass ] 								as: NeoJSONArray) ].	^ builder value: Magnitude! !!NeoJSONObject class methodsFor: 'example'!exampleNested	<gtExample>	^ self exampleSimple array: NeoJSONArray exampleSimple! !!NeoJSONObject class methodsFor: 'example'!exampleNestedRoundtrip	<gtExample>	| json result|	json := self exampleNested printString.	result := self fromString: json.	self assert: result equals: self exampleNested.	^ result! !!NeoJSONObject class methodsFor: 'example'!exampleSimple	<gtExample>	^ self new		foo: 100;		bar: 200! !!NeoJSONObject class methodsFor: 'example'!exampleSimpleJSON	<gtExample>	^ '{"foo":100,"bar":200}'! !!NeoJSONObject class methodsFor: 'example'!exampleSimpleParsing	<gtExample>	| result |	result := self fromString: self exampleSimpleJSON.	self assert: result equals: self exampleSimple.	^ result! !!NeoJSONObject class methodsFor: 'example'!exampleSimpleWriting	<gtExample>	| result |	result := self exampleSimple printString.	self assert: result equals: self exampleSimpleJSON.	^ result! !!NeoJSONObject class methodsFor: 'convenience'!fromString: string	"Parse string as JSON, so that maps become instances of me"	^ (NeoJSONReader on: string readStream)			mapClass: self;			listClass: NeoJSONArray;			propertyNamesAsSymbols: true;			next! !!NeoJSONObject methodsFor: 'accessing'!at: key	"I return nil for missing keys.	My superclass would signal a KeyNotFound."	^ self at: key ifAbsent: [ nil ]! !!NeoJSONObject methodsFor: 'nested dictionaries'!at: firstKey at: secondKey	"I return nil for missing keys.	My superclass would signal a KeyNotFound."	^ self atPath: { firstKey. secondKey }! !!NeoJSONObject methodsFor: 'nested dictionaries'!at: firstKey at: secondKey put: value	"Store value under secondKey in nested object under firstKey, create new level when needed"	^ self atPath: { firstKey. secondKey } put: value! !!NeoJSONObject methodsFor: 'accessing'!at: key ifPresent: aPresentBlock ifAbsentPut: anAbsentBlock	"Lookup the given key in the receiver. If it is present, answer the	value of evaluating the first block optionally with the value associated with the key.	Otherwise store and return the result of evaluating the second block as the new value of the key."	"Overwritten to patch a bug in the superclass implementation in Pharo 7 and 8.	This problem was fixed in Pharo 9 where this overwrite is no longer necessary but harmless."	^ self		at: key		ifPresent: aPresentBlock		ifAbsent: [ self at: key put: anAbsentBlock value ]! !!NeoJSONObject methodsFor: 'accessing'!atPath: keyCollection	"Use each key in keyCollection recursively, stop when nil is encountered"	| value |	value := self.	keyCollection do: [ :each |		value := value at: each.		value ifNil: [ ^ nil ] ].	^ value! !!NeoJSONObject methodsFor: 'accessing'!atPath: keyCollection put: newValue	"Use each key in keyCollection recursively, create new levels when needed"	| target |	keyCollection ifEmpty: [ ^ self ].	target := self.	keyCollection allButLastDo: [ :each |		(target at: each)			ifNil: [ target := target at: each put: target species new ]			ifNotNil: [ :subValue | target := subValue ] ].	^ target at: keyCollection last put: newValue! !!NeoJSONObject methodsFor: 'reflective operations'!doesNotUnderstand: message	"Overwritten so that 'self foo' becomes 'self at: #foo'	and 'self foo: 1' becomes 'self at: #foo put: 1' except that self is returned"	| key |	key := message selector.	key isUnary		ifTrue: [ ^ self at: key ].	^ (key isKeyword and: [ key numArgs = 1 ])		ifTrue: [ self at: key allButLast asSymbol put: message arguments first; yourself ]		ifFalse: [ super doesNotUnderstand: message ]! !!NeoJSONObject methodsFor: 'accessing'!name	"Overwritten to make this accessor available as key"	^ self at: #name! !!NeoJSONObject methodsFor: 'printing'!printOn: stream	"I use my JSON representation when printing myself"	[ (NeoJSONWriter on: stream) nextPut: self ]		on: Error		do: [ :exception |			stream				nextPutAll: ' Error printing JSON: ';				print: exception ]! !!NeoJSONObject methodsFor: 'evaluating'!value	"Overwritten to make this accessor available as key"	^ self at: #value! !!NeoJSONArray class methodsFor: 'example'!exampleNumbers	<gtExample>	| numbers |	numbers := self new: 128.	0 to: 127 do: [ :n | 		numbers			at: n + 1			put: (NeoJSONObject new					integer: n;					decimal: (n printStringBase: 10);					octal: (n printStringBase: 8);					hexadecimal: (n printStringBase: 16);					binary: (n printStringBase: 2);					roman: n printStringRoman;					words: n asWords;					prime: n isPrime;					character: n asCharacter asString) ].	^ numbers! !!NeoJSONArray class methodsFor: 'example'!exampleSimple	<gtExample>	^ self withAll: { 0 . 1 . Float pi. 'string' . true . false. nil }! !!NeoJSONArray methodsFor: 'print'!printOn: stream	"I use my JSON representation when printing myself"	[ (NeoJSONWriter on: stream) nextPut: self ]		on: Error		do: [ :exception |			stream				nextPutAll: ' Error printing JSON: ';				print: exception ]! !!Collection methodsFor: '*neo-json-core'!neoJsonOn: neoJSONWriter	neoJSONWriter writeList: self! !"Neo-JSON-Core"!!NeoJSONBenchmarkTests commentStamp: '' prior: 0!I am NeoJSONBenchmarkTests.This test is obviously dependent on hardware, but the margin is quite high.!!NeoJSONExamplesTests commentStamp: '' prior: 0!NeoJSONExamplesTests runs a couple of examples as tests!!NeoJSONFloatPrinterTests commentStamp: '' prior: 0!I am NeoJSONFloatPrinterTests, the collection of unit tests for NeoJSONFloatPrinter.!!NeoJSONMappingTests commentStamp: '' prior: 0!I am NeoJSONMappingTests, testing more exotic kinds of mapping constructs.!!NeoJSONObjectTests commentStamp: '' prior: 0!I am NeoJSONObjectTests, I hold unit tests for NeoJSONObject.!!NeoJSONReaderTests commentStamp: '' prior: 0!I am NeoJSONReaderTests, a test suite for NeoJSONReader.!!NeoJSONWriteReadTests commentStamp: '' prior: 0!I am NeoJSONWriteReadTests.!!NeoJSONWriteReadAsciiOnlyTests commentStamp: '' prior: 0!I am NeoJSONWriteReadAsciiOnlyTests.!!NeoJSONWriteReadMockStreamTests commentStamp: '' prior: 0!I am NeoJSONWriteReadMockStreamTests.!!NeoJSONWriteReadPrettyPrintedTests commentStamp: '' prior: 0!I am NeoJSONWriteReadPrettyPrintedTests.!!NeoJSONWriterTests commentStamp: '' prior: 0!I am NeoJSONWriterTests, a test suite for NeoJSONWriter.!!NeoJSONBenchmark commentStamp: '' prior: 0!I am NeoJSONBenchmark.I hold 1000 objects of the form Dictionary('color'->'green' 'enabled'->false 'id'->1 'name'->'Name-1' 'value'->0.002 ) in an Array.I hold the JSON serialization of that as a String of the form '[{"value":0.002,"enabled":false,"name":"Name-1","color":"green","id":1}, ...| benchmark |benchmark := NeoJSONBenchmark new.[benchmark read] bench.| benchmark |benchmark := NeoJSONBenchmark new.[benchmark write] bench.| benchmark |benchmark := NeoJSONBenchmark new.[benchmark read] timeToRun.| benchmark |benchmark := NeoJSONBenchmark new.[benchmark write] timeToRun.!!NeoJSONMockStream commentStamp: '' prior: 0!I am NeoJSONMockStream.I wrap another stream to validate the limited API used.!!NeoJSONTestObject1 commentStamp: '' prior: 0!I am NeoJSONTestObject1.I repesent a domain model object.I have the following properties:- id <Integer>- name <String>- timestamp <DateAndTime>- points <Array of: Point>- bytes <ByteArray>My JSON representation is like this:- id <Number>- name <String>- created-at <ISO8601 String>- points <Array of: <Map x,y>- bytes <Array of: Number>!!NeoJSONTestObject2 commentStamp: '' prior: 0!I am NeoJSONTestObject2.Instance Variables	data:		<String>	height:		<Integer>	id:			<Integer>	width:		<Integer>Used for benchmarking and other tests.!!NeoJSONTestObject3 commentStamp: '' prior: 0!I am NeoJSONTestObject3, a subclass of NeoJSONTestObject2.Instance Variables	color:			<String>	transparent :	<Boolean>I am used for inheritance testing.!!NeoJSONValidation commentStamp: '' prior: 0!I am NeoJSONValidation, a set of tests to validate NeoJSON against some external rules.Both positive & negative tests are includes.Some of these are implementation choices.http://seriot.ch/parsing_json.phphttps://github.com/nst/JSONTestSuitehttps://github.com/nst/JSONTestSuite.git  test_parsing  test_transformhttps://github.com/miloyip/nativejson-benchmarkhttps://github.com/miloyip/nativejson-benchmark.git  data/jsonchecker  data/roundtripThis can only be run with the correct setup (checkout/config).  NeoJSONValidation new runNativeJsonBenchmarkRoundTrip.  NeoJSONValidation new runNativeJsonBenchmarkJsonCheckerPasses.  NeoJSONValidation new runNativeJsonBenchmarkJsonCheckerFailures.  NeoJSONValidation new runJsonTestSuiteTestParsingPasses.  NeoJSONValidation new runJsonTestSuiteTestParsingFailures.  NeoJSONValidation new runJsonTestSuiteTestParsingInfo.Logging goes to a file, neo-json-validation.log!!NeoJSONBenchmarkTests methodsFor: 'testing'!testObject2	| json |	json := NeoJSONWriter toString: NeoJSONTestObject2 new.	self 		assert: (NeoJSONReader fromString: json as: NeoJSONTestObject2)		equals: NeoJSONTestObject2 new! !!NeoJSONBenchmarkTests methodsFor: 'testing'!testPrettyPrinted	| benchmark |	benchmark := NeoJSONBenchmark new.	self		assert: benchmark writePrettyPrintedRead		equals: benchmark read! !!NeoJSONBenchmarkTests methodsFor: 'testing'!testRead	| benchmark |	benchmark := NeoJSONBenchmark new.	benchmark read! !!NeoJSONBenchmarkTests methodsFor: 'testing'!testWrite	| benchmark |	benchmark := NeoJSONBenchmark new.	benchmark write! !!NeoJSONExamplesTests methodsFor: 'tests'!testPoints	| points json result |		points := Array with: 1@2 with: 3@4 with: 5@6.		json := String streamContents: [ :out |		(NeoJSONWriter on: out)			prettyPrint: true;			mapInstVarsFor: Point;			nextPut: points ].			result := (NeoJSONReader on: json readStream)		mapInstVarsFor: Point;		for: #ListOfPoints customDo: [ :mapping |			mapping listOfElementSchema: Point ];		nextAs: #ListOfPoints.		self assert: result equals: points.				result := (NeoJSONReader on: json readStream)		mapInstVarsFor: Point;		nextListAs: Point.		self assert: result equals: points.			result := (NeoJSONReader on: json readStream)		mapInstVarsFor: Point;		for: #OrderedCollectionOfPoints customDo: [ :mapping |			mapping listOfType: OrderedCollection andElementSchema: Point ];		nextAs: #OrderedCollectionOfPoints.		self assert: result equals: points asOrderedCollection.! !!NeoJSONExamplesTests methodsFor: 'tests'!testRectanglePoints	| rectangle rectangleJson result |	rectangle := Rectangle origin: 3 @ 4 extent: 5 @ 6.	rectangleJson := String streamContents: [ :stream | 		(NeoJSONWriter on: stream)			prettyPrint: true;			mapInstVarsFor: Point;			mapInstVarsFor: Rectangle;			nextPut: rectangle ].	result := (NeoJSONReader on: rectangleJson readStream)		mapInstVarsFor: Point;		for: Rectangle do: [ :mapping | 			(mapping mapInstVar: #origin) valueSchema: Point.			(mapping mapInstVar: #corner) valueSchema: Point ];		nextAs: Rectangle.	self assert: result equals: rectangle.	result := (NeoJSONReader on: rectangleJson readStream)		mapInstVarsFor: Point;		for: Rectangle do: [ :mapping | 			mapping mapInstVars do: [ :each | each valueSchema: Point ] ];		nextAs: Rectangle.			self assert: result equals: rectangle ! !!NeoJSONExamplesTests methodsFor: 'tests'!testRectanglePointsWithNils	self		assert: 			(String streamContents: [ :stream | 				(NeoJSONWriter on: stream)					for: Point do: [ :mapping | mapping mapAllInstVars ];					for: Rectangle do: [ :mapping | 						(mapping mapInstVar: #origin) valueSchema: Point.						(mapping mapInstVar: #corner) valueSchema: Point ];					nextPut: Rectangle new ])		equals: '{}'.	self		assert:			(String streamContents: [ :stream | 				(NeoJSONWriter on: stream)					for: Point do: [ :mapping | mapping mapAllInstVars ];					for: Rectangle	do: [ :mapping | 						(mapping mapInstVar: #origin) valueSchema: Point.						(mapping mapInstVar: #corner) valueSchema: Point ];					writeNil: true;					nextPut: Rectangle new ])		equals: '{"origin":null,"corner":null}'.! !!NeoJSONFloatPrinterTests methodsFor: 'running'!setUp	super setUp.	printer := NeoJSONFloatPrinter new! !!NeoJSONFloatPrinterTests methodsFor: 'tests'!testDecimalNotation	self assert: (printer print: 1.5) equals: '1.5'.	self assert: (printer print: -1.5) equals: '-1.5'.	self assert: (printer print: 0.5) equals: '0.5'.	self assert: (printer print: -0.5) equals: '-0.5'.	self assert: (printer print: (1/3) asFloat) equals: '0.33333'.	self assert: (printer print: (-1/3) asFloat) equals: '-0.33333'.	self assert: (printer print: 0.00123) equals: '0.00123'.	self assert: (printer print: -0.00123) equals: '-0.00123'.	self assert: (printer print: 0.00012) equals: '0.00012'.	self assert: (printer print: -0.00012) equals: '-0.00012'.	self assert: (printer print: 123456.12345) equals: '123456.12345'.	self assert: (printer print: -123456.12345) equals: '-123456.12345'.! !!NeoJSONFloatPrinterTests methodsFor: 'tests'!testInteger	self assert: (printer print: 1.0) equals: '1'.	self assert: (printer print: 0.0) equals: '0'.	self assert: (printer print: -1.0) equals: '-1'.	self assert: (printer print: 123.0) equals: '123'.	self assert: (printer print: 123456.0) equals: '123456'.	! !!NeoJSONFloatPrinterTests methodsFor: 'tests'!testLowPrecision	printer := NeoJSONFloatPrinter lowPrecision.	self assert: (printer print: (4/3) asFloat) equals: '1.33'.	self assert: (printer print: 12345.66) equals: '12345.66'.	self assert: (printer print: -123456.77) equals: '-1.23e5'.	self assert: (printer print: Float pi) equals: '3.14'.	self assert: (printer print: Float e negated) equals: '-2.72'.	"the earth's mass in kg"	self assert: (printer print: 5.9724e24) equals: '5.97e24'.	"mass of electron in kg"	self assert: (printer print: 9.10938356e-31) equals: '9.11e-31'.! !!NeoJSONFloatPrinterTests methodsFor: 'tests'!testScientificNotation	self assert: (printer print: 1234567.5) equals: '1.23457e6'. "note the rounding"	self assert: (printer print: -1234567.5) equals: '-1.23457e6'. "note the rounding"	self assert: (printer print: 0.0000123) equals: '1.23e-5'.	self assert: (printer print: -0.0000123) equals: '-1.23e-5'.! !!NeoJSONFloatPrinterTests methodsFor: 'tests'!testScientificOnly	printer := NeoJSONFloatPrinter scientificOnly.	self assert: (printer print: (4/3) asFloat) equals: '1.33333e0'.	self assert: (printer print: 12345.66) equals: '1.23457e4'.	self assert: (printer print: Float pi) equals: '3.14159e0'.	self assert: (printer print: Float e negated) equals: '-2.71828e0'.	"the earth's mass in kg"	self assert: (printer print: 5.9724e24) equals: '5.9724e24'.	"mass of electron in kg"	self assert: (printer print: 9.10938356e-31) equals: '9.10938e-31'.! !!NeoJSONFloatPrinterTests methodsFor: 'tests'!testSpecialValues	self assert: (printer print: Float zero) equals: '0'.	self assert: (printer print: Float nan) equals: 'NaN'.	self assert: (printer print: Float infinity) equals: 'Inf'.	self assert: (printer print: Float infinity negated) equals: '-Inf'.! !!NeoJSONFloatPrinterTests methodsFor: 'tests'!testWellKnownConstants	self assert: (printer print: Float pi) equals: '3.14159'.	self assert: (printer print: Float e) equals: '2.71828'.	"the earth's mass in kg"	self assert: (printer print: 5.9724e24) equals: '5.9724e24'.	"mass of electron in kg"	self assert: (printer print: 9.10938356e-31) equals: '9.10938e-31'.	"planck's constant in Js"	self assert: (printer print: 1.05457e-34) equals: '1.05457e-34'.	"speed of light in m/s"	self assert: (printer print: 2.99792e8) equals: '2.99792e8'.	"charge of electron in C"	self assert: (printer print: -1.60218e-19) equals: '-1.60218e-19'.	"boltzmann's constant in J/K"	self assert: (printer print: 1.38065e-23) equals: '1.38065e-23'.! !!NeoJSONMappingTests methodsFor: 'testing'!testDynamicTyping	| data customMapping json result |	data := Array with: 'foo'->1 with: #('foo' 2).	"The idea is to map a key value combination as either a classic association or a simple pair, 	using key & value properties as well as a type property to distinguish between the two"	customMapping := [ :mapper |		mapper 			for: #AssocOrPair customDo: [ :mapping |				mapping					encoder: [ :x | 						x isArray 							ifTrue: [ Dictionary new at: 'type' put: 'pair'; at: 'key' put: x first; at: 'value' put: x second; yourself ] 							ifFalse: [ Dictionary new at: 'type' put: 'assoc'; at: 'key' put: x key; at: 'value' put: x value; yourself ] ];					decoder: [ :x |						(x at: 'type') = 'pair'							ifTrue: [ Array with: (x at: 'key') with: (x at: 'value') ]							ifFalse: [ (x at: 'key') -> (x at: 'value')] ] ];			for: #ArrayOfAssocOrPair customDo: [ :mapping |				mapping listOfType: Array andElementSchema: #AssocOrPair ];			yourself ].	json := String streamContents: [ :out |		(customMapping value: (NeoJSONWriter on: out)) nextPut: data as: #ArrayOfAssocOrPair ].	result := (customMapping value: (NeoJSONReader on: json readStream)) nextAs: #ArrayOfAssocOrPair.	self assert: result equals: data! !!NeoJSONMappingTests methodsFor: 'testing'!testSymbolOrStringInstVarMapping	| data out1 out2 result1 result2 |	data := Array with: 1@2 with: 3@4.	out1 := String streamContents: [ :out |		(NeoJSONWriter on: out)			for: Point do: [ :mapping | mapping mapInstVars: #(x y) ];			nextPut: data ].	result1 := (NeoJSONReader on: out1 readStream)		for: Point do: [ :mapping | mapping mapInstVars: #(x y) ];		nextListAs: Point.	self assert: result1 equals: data.	out2 := String streamContents: [ :out |		(NeoJSONWriter on: out)			for: Point do: [ :mapping | mapping mapInstVars: #('x' 'y') ];			nextPut: data ].	result2 := (NeoJSONReader on: out1 readStream)		for: Point do: [ :mapping | mapping mapInstVars: #('x' 'y') ];		nextListAs: Point.	self assert: result2 equals: data! !!NeoJSONMappingTests methodsFor: 'testing'!testVirtualTransferObject	| data customMapping extraJson json result |	data := NeoJSONObject new data: (Array with: 1@1 with: 2@2).	extraJson := '{"foo":1,"data":[{"x":1,"y":1},{"x":2,"y":2,"z":-1}]}'.	"The idea here is that we are not interested in the top level object just in its data property, 	which should be of a specific type, hence we create a virtual transfer object"	customMapping := [ :mapper |		mapper			for: Point do: [ :mapping |				mapping mapInstVars: #(x y) ];			for: #ArrayOfPoints customDo: [ :mapping |				mapping listOfElementSchema: Point ];			for: #TransferObject do: [ :mapping |				mapping subjectClass: NeoJSONObject.				(mapping mapAccessor: #data) valueSchema: #ArrayOfPoints ];			yourself ].	"By using NeoJSONObject accessors (#data & #data:) are translated to generic #at:[put:] messages.	A longer alternative is 	(mapping mapProperty: #data getter: [ :obj | obj at: #data ] setter: [ :obj :x | obj at: #data put: x]) valueSchema: #ArrayOfPoints	where the blocks give you the flexibility to use a plain Dictionary for example"	result := (customMapping value: (NeoJSONReader on: extraJson readStream)) nextAs: #TransferObject.	self assert: result equals: data.	json := String streamContents: [ :out |		(customMapping value: (NeoJSONWriter on: out)) nextPut: data as: #TransferObject ].	result := (customMapping value: (NeoJSONReader on: json readStream)) nextAs: #TransferObject.	self assert: result equals: data! !!NeoJSONObjectTests methodsFor: 'testing'!testAtAt	| object |	object := NeoJSONObject new.	self assert: (object at: #foo) isNil.	self assert: (object at: #foo at: #bar) isNil.	object at: #foo at: #bar put: 123.	self assert: (object at: #foo) notNil.	self assert: (object at: #foo at: #bar) equals: 123.	self assert: object foo bar equals: 123.	object at: #foo at: #bar put: -1.	self assert: (object at: #foo at: #bar) equals: -1.	self assert: (object at: #foo at: #foo) isNil! !!NeoJSONObjectTests methodsFor: 'testing'!testAtPath	| object |	object := NeoJSONObject newFrom:  (Array with:  #one -> ( NeoJSONObject newFrom:  (Array with:  #two -> ( NeoJSONObject newFrom: (Array with:  #three -> 42) ) ) )).	self assert: (object atPath: #(one two three)) equals: 42.	self assert: (object atPath: #(one two three)) equals: object one two three.		self assert: (object atPath: #(missing)) equals: nil.	self assert: (object atPath: #(one missing)) equals: nil.	self assert: (object atPath: #(one two missing)) equals: nil.	self assert: (object atPath: #(one two missing)) equals: object one two missing.		object := NeoJSONObject newFrom:  (Array with: #foo -> 42).	self assert: (object atPath: #(foo)) equals: 42.	self assert: (object atPath: #(foo)) equals: object foo.	self assert: (object atPath: #(foo)) equals: (object at: #foo).	self assert: (object atPath: #()) equals: object.	! !!NeoJSONObjectTests methodsFor: 'testing'!testAtPathPut	| object |	object := NeoJSONObject new.	object atPath: #(one test) put: 42.	self assert: (object atPath: #(one test)) equals: 42.	self assert: object one test equals: 42.	object atPath: #(one two three) put: #foo.	self assert: (object atPath: #(one two three)) equals: #foo.	self assert: object one two three equals: #foo.	object atPath: #(one two threeBis) put: #bar.	self assert: (object atPath: #(one two threeBis)) equals: #bar.	self assert: object one two threeBis equals: #bar.		self assert: object foo isNil.	self assert: (object atPath: #() put: 1) equals: object.	self assert: (object atPath: #(foo) put: 1) equals: 1.	self assert: (object atPath: #(foo)) equals: 1.	self assert: object foo equals: 1	 ! !!NeoJSONObjectTests methodsFor: 'testing'!testCRUD	| object |	object := NeoJSONObject new.	self assert: object isEmpty.	self assert: object foo equals: nil.	object foo: 123.	self assert: object foo equals: 123.	self assert: object printString equals: '{"foo":123}'.	object name: 'test'.	object value: Float pi.	self assert: object name equals: 'test'.	self assert: (object value closeTo: Float pi).	self assert: object keys asSet equals: #(foo name value) asSet.	object removeKey: #foo.	self assert: object foo equals: nil.	object removeAll.	self assert: object isEmpty! !!NeoJSONObjectTests methodsFor: 'testing'!testJSON	| data  json object |	data := NeoJSONObject newFrom: (Array with: #foo->1 with: #bar->2 with: #str->'Str!!' with: #bool->true with: #flt->1.5).	json := NeoJSONWriter toString: data .	object := NeoJSONObject fromString: json.	self assert: object class equals: NeoJSONObject.	self assert: object equals: data.	json := (NeoJSONWriter toString: object).	self assert: (NeoJSONObject fromString: json) equals: object! !!NeoJSONReaderTests methodsFor: 'testing'!testAllowNil	self 		should: [ 			(NeoJSONReader on: 'null' readStream)				mapInstVarsFor: Point;				nextAs: Point ] 		raise: NeoJSONParseError.	self		assert: ((NeoJSONReader on: 'null' readStream)						mapInstVarsFor: Point;						for: Point do: [ :mapping | mapping allowNil ];						nextAs: Point)		equals: nil.	self		assert: ((NeoJSONReader on: '[ { "x" : 1, "y" : 2 }, null, { "x" : 3, "y" : -1 } ]' readStream)						mapInstVarsFor: Point;						for: Point do: [ :mapping | mapping allowNil ];						for: #ArrayOfPoints customDo: [ :mapping | mapping listOfElementSchema: Point ];						nextAs: #ArrayOfPoints)		equals: (Array with: 1 @ 2 with: nil with: 3 @ -1).! !!NeoJSONReaderTests methodsFor: 'testing'!testArrayOfPoints	| reader |	reader := [ :string | 		(NeoJSONReader on: string readStream) 			for: Point do: [ :mapping |				mapping mapInstVars: #(x y) ];			for: #ArrayOfPoints customDo: [ :mapping |				mapping listOfElementSchema: Point ];			nextAs: #ArrayOfPoints ].	self assert: (reader value: '[ { "x":1, "y":2 }, { "x":-1, "y":-2 } ]') equals: (Array with: 1@2 with: -1@ -2) . 	self assert: (reader value: '[ ]') equals: #().	self assert: (reader value: '[ { } ]') equals: (Array with: Point new)! !!NeoJSONReaderTests methodsFor: 'testing'!testArrayOfPointsUsingNextListAs	| reader |	reader := [ :string | 		(NeoJSONReader on: string readStream) 			mapInstVarsFor: Point;			nextListAs: Point ].	self assert: (reader value: '[ { "x":1, "y":2 }, { "y":-2, "x":-1 } ]') equals: (Array with: 1@2 with: -1@ -2) . 	self assert: (reader value: '[ ]') equals: #().	self assert: (reader value: '[ { } ]') equals: (Array with: Point new) ! !!NeoJSONReaderTests methodsFor: 'testing'!testAssociation	| reader |	reader := [ :string | 		(NeoJSONReader on: string readStream) 			for: Association do: [ :mapping |				mapping mapAccessors: #(key value) ]; 			nextAs: Association ].	self assert: (reader value: '{"key":"foo","value":42}') equals: 'foo' -> 42. 	self assert: (reader value: '{}') equals: Association new! !!NeoJSONReaderTests methodsFor: 'testing'!testBooleans	self assert: (NeoJSONReader on: 'true' readStream) next equals: true.	self assert: (NeoJSONReader on: 'false' readStream) next equals: false.	self should: [ (NeoJSONReader on: 'tru' readStream) next ] raise: NeoJSONParseError.	self should: [ (NeoJSONReader on: 'falsE' readStream) next ] raise: NeoJSONParseError.! !!NeoJSONReaderTests methodsFor: 'testing'!testByteArray	| reader |	reader := [ :string | 		(NeoJSONReader on: string readStream) 			for: ByteArray customDo: [ :mapping |				mapping listOfType: ByteArray ];			nextAs: ByteArray ].	self assert: (reader value: '[ 1, 2, 3 ]') equals: #[1 2 3].	self assert: (reader value: '[ ]') equals: ByteArray new! !!NeoJSONReaderTests methodsFor: 'testing'!testDate	| reader |	reader := [ :input | 		(NeoJSONReader on: input readStream) 			for: Date customDo: [ :mapping |				mapping decoder: [ :string | Date fromString: string ] ];			nextAs: Date ].	self assert: (reader value: ' "2012-06-08" ') equals: (Date fromString: '2012-06-08') ! !!NeoJSONReaderTests methodsFor: 'testing'!testDateAndTime 	| reader |	reader := [ :input | 		(NeoJSONReader on: input readStream) 			for: DateAndTime customDo: [ :mapping |				mapping decoder: [ :string | DateAndTime fromString: string ] ];			nextAs: DateAndTime ].	self 		assert: (reader value: ' "2012-02-14T16:40:18+01:00" ') 		equals: (DateAndTime year: 2012 month: 2 day: 14 hour: 16 minute: 40 second: 18 offset: 1 hour)! !!NeoJSONReaderTests methodsFor: 'testing'!testFloats	| reader |	reader := [ :string |		(NeoJSONReader on: string readStream) next ].	self assert: ((reader value: '123.0') closeTo: 123.0).	self assert: ((reader value: '-123.0') closeTo: -123.0).	self assert: ((reader value: '123.0e0') closeTo: 123.0).	self assert: ((reader value: '123e6') closeTo: 123e6).	self assert: ((reader value: '123e+6') closeTo: 123e6).	self assert: ((reader value: '123e-6') closeTo: 123e-6).	self assert: ((reader value: '123E6') closeTo: 123e6).	self assert: ((reader value: '123E+6') closeTo: 123e6).	self assert: ((reader value: '123E-6') closeTo: 123e-6).	self assert: ((reader value: '-123e6') closeTo: -123e6).	self assert: ((reader value: '-123e-6') closeTo: -123e-6).	self assert: ((reader value: '-123E6') closeTo: -123e6).	self assert: ((reader value: '-123E-6') closeTo: -123e-6).	self assert: ((reader value: '3.14159') closeTo: Float pi).	self assert: ((reader value: '0.123e6') closeTo: 0.123e6).	self assert: ((reader value: '0.123e-6') closeTo: 0.123e-6).	self assert: ((reader value: '-0.123E6') closeTo: -0.123e6).	self assert: ((reader value: '-0.123E-6') closeTo: -0.123e-6).! !!NeoJSONReaderTests methodsFor: 'testing'!testIntegers	| reader |	reader := [ :string |		(NeoJSONReader on: string readStream) next ].	self assert: (reader value: '123') equals: 123.	self assert: (reader value: '00123') equals: 123.	self assert: (reader value: '-123') equals: -123.	self assert: (reader value: '-0123') equals: -123.	self assert: (reader value: '0') equals: 0.	self assert: (reader value: '-0') equals: 0.	self assert: (reader value: '00') equals: 0.	self assert: (reader value: ' 123	') equals: 123.	self should: [ reader value: '+1' ] raise: NeoJSONParseError.	self should: [ reader value: ' - ' ] raise: NeoJSONParseError.! !!NeoJSONReaderTests methodsFor: 'testing'!testLists	| reader |	reader := [ :string |		(NeoJSONReader on: string readStream) next ].	self assert: (reader value: '[1,2,3]') equals: #(1 2 3).	self assert: (reader value: '[]') equals: #().	self assert: (reader value: ' [ 1 , 2 , 3 ] ') equals: #(1 2 3).	self assert: (reader value: ' [ ] ') equals: #().	self should: [ reader value: '[1,]' ] raise: NeoJSONParseError. 	self should: [ reader value: '[' ] raise: NeoJSONParseError.	self should: [ reader value: ']' ] raise: NeoJSONParseError.	self should: [ reader value: '[}' ] raise: NeoJSONParseError! !!NeoJSONReaderTests methodsFor: 'testing'!testMaps	| reader |	reader := [ :string |		(NeoJSONReader on: string readStream) next ].	self assert: (reader value: '{"x":1,"y":2}') equals: (Dictionary newFromPairs: #( 'x' 1 'y' 2)).	self assert: (reader value: '{}') equals: Dictionary new.	self assert: (reader value: ' { "x" : 1 , "y" : 2 } ' ) equals: (Dictionary newFromPairs: #( 'x' 1 'y' 2)).	self assert: (reader value: ' { } ') equals: Dictionary new.	self should: [ reader value: '{"foo":}' ] raise: NeoJSONParseError. 	self should: [ reader value: '{"foo":9,}' ] raise: NeoJSONParseError. 	self should: [ reader value: '{9:true,}' ] raise: NeoJSONParseError. 	self should: [ reader value: '{' ] raise: NeoJSONParseError.	self should: [ reader value: '}' ] raise: NeoJSONParseError.	self should: [ reader value: '{]' ] raise: NeoJSONParseError! !!NeoJSONReaderTests methodsFor: 'testing'!testNextStringAsHex	| string |	string := (NeoJSONReader on: '"466F6F2062617221"' readStream)		for: #StringAsHex			customDo: [ :mapping | 					mapping						encoder: [ :x | x asByteArray hex asUppercase ];						decoder: [ :x | (ByteArray readHexFrom: x) asString ] ];		nextAs: #StringAsHex.	self assert: string equals: 'Foo bar!!'! !!NeoJSONReaderTests methodsFor: 'testing'!testNonBMPCharacterDecoding	"Characters not in the Basic Multilingual Plane are encoded as a UTF-16 surrogate pair"	| string object |	string := 16r1D11E asCharacter asString. "MUSICAL SYMBOL G CLEF"	object := (NeoJSONReader fromString: '"\uD834\uDD1E"').	self assert: object equals: string.		"UTF-16 surrogate pairs might be invalid, make sure an error is raised"	self should: [ NeoJSONReader fromString: '"\udbff\ue000"' ] raise: NeoJSONParseError! !!NeoJSONReaderTests methodsFor: 'testing'!testNull	self assert: (NeoJSONReader on: 'null' readStream) next equals: nil.	self assert: (NeoJSONReader on: '	null ' readStream) next equals: nil.	self should: [ (NeoJSONReader on: '	nil ' readStream) next ] raise: NeoJSONParseError.! !!NeoJSONReaderTests methodsFor: 'testing'!testOrderedCollection	| json list |	json := '[ 1, 2, 3 ]'.	list := (NeoJSONReader on: json readStream) 		listClass: OrderedCollection;		next.	self 		assert: list 		equals: (OrderedCollection with: 1 with: 2 with: 3).	self 		assert: list class 		equals: OrderedCollection! !!NeoJSONReaderTests methodsFor: 'testing'!testOrderedCollectionOfPoints	| reader |	reader := [ :string | 		(NeoJSONReader on: string readStream) 			for: Point do: [ :mapping |				mapping mapInstVars: #(x y) ];			for: #OrderedCollectionOfPoints customDo: [ :mapping |				mapping listOfType: OrderedCollection andElementSchema: Point ];			nextAs: #OrderedCollectionOfPoints ].	self assert: (reader value: '[ { "x":1, "y":2 }, { "x":-1, "y":-2 } ]') equals: (Array with: 1@2 with: -1@ -2) asOrderedCollection. 	self assert: (reader value: '[ ]') equals: OrderedCollection new.	self assert: (reader value: '[ { } ]') equals: (OrderedCollection with: Point new)! !!NeoJSONReaderTests methodsFor: 'testing'!testParseErrors	self should: [ NeoJSONReader fromString: 'zero' ] raise: NeoJSONParseError.	self should: [ NeoJSONReader fromString: '#' ] raise: NeoJSONParseError.	self should: [ NeoJSONReader fromString: '@' ] raise: NeoJSONParseError.		self should: [ (NeoJSONReader on: '[1,2,3]true' readStream) next; failIfNotAtEnd ] raise: NeoJSONParseError.	self should: [ (NeoJSONReader on: '{"foo":1}"extra"' readStream) next; failIfNotAtEnd ] raise: NeoJSONParseError.	self should: [ (NeoJSONReader on: '[]"extra"' readStream) next; failIfNotAtEnd ] raise: NeoJSONParseError.! !!NeoJSONReaderTests methodsFor: 'testing'!testPoint	| reader |	reader := [ :string | 		(NeoJSONReader on: string readStream) nextAs: Point ].	self should: [ reader value: '{"x":1,"y":2}' ] raise: NeoJSONMappingNotFound! !!NeoJSONReaderTests methodsFor: 'testing'!testPoint1	| reader |	reader := [ :string | 		(NeoJSONReader on: string readStream) 			for: Point do: [ :mapping |				mapping mapProperty: 'x' getter: [ :point | point x ] setter: [ :point :value | point setX: value setY: point y ].				mapping mapProperty: 'y' getter: [ :point | point y ] setter: [ :point :value | point setX: point x setY: value ]. ];			nextAs: Point ].	self assert: (reader value: '{"x":1,"y":2}') equals: 1@2. 	self assert: (reader value: '{}') equals: Point new! !!NeoJSONReaderTests methodsFor: 'testing'!testPoint2	| reader |	reader := [ :string | 		(NeoJSONReader on: string readStream) 			mapAllInstVarsFor: Point;			nextAs: Point ].	self assert: (reader value: '{"x":1,"y":2}') equals: 1@2. 	self assert: (reader value: '{}') equals: Point new! !!NeoJSONReaderTests methodsFor: 'testing'!testPoint3	| reader |	reader := [ :string | 		(NeoJSONReader on: string readStream) 			for: Point do: [ :mapping |				mapping mapInstVars: #(x y) ];			nextAs: Point ].	self assert: (reader value: '{"x":1,"y":2}') equals: 1@2. 	self assert: (reader value: '{}') equals: Point new! !!NeoJSONReaderTests methodsFor: 'testing'!testPointUsingAsString	| point |	point := (NeoJSONReader on: '{"x":"1","y":"2"}' readStream)		for: Point			do: [ :mapping | 					(mapping 						mapProperty: #x 						getter: [ :object | object x ] 						setter: [ :object :value | object setX: value setY: object y ])						valueSchema: #AsString.					(mapping						mapProperty: #y						getter: [ :object | object y ]						setter: [ :object :value | object setX: object x setY: value ]) 						valueSchema: #AsString ];		for: #AsString			customDo: [ :mapping | 					mapping						encoder: [ :x | x asString ];						decoder: [ :x | x asNumber ] ];		nextAs: Point.	self assert: point equals: 1 @ 2! !!NeoJSONReaderTests methodsFor: 'testing'!testPropertyNamesAsSymbols	| json map |	json := '{ "x" : true, "y" : false, "key-1" : 1 }'.	map := (NeoJSONReader on: json readStream) 		propertyNamesAsSymbols: true; 		next.	self 		assert: map 		equals: (Dictionary new at: #x put: true; at: #y put: false; at: #'key-1' put: 1; yourself).	self assert: (map keys allSatisfy: [ :each | each isSymbol ])! !!NeoJSONReaderTests methodsFor: 'testing'!testSmallDictionary	| json map smallDictionaryClass |	json := '{ "x" : true, "y" : false, "key-1" : 1 }'.	smallDictionaryClass := Smalltalk at: #SmallDictionary ifAbsent: [ Dictionary ].	map := (NeoJSONReader on: json readStream) 		mapClass: smallDictionaryClass;		next.	self 		assert: map 		equals: (smallDictionaryClass new at: 'x' put: true; at: 'y' put: false; at: 'key-1' put: 1; yourself).	self 		assert: map class 		equals: smallDictionaryClass! !!NeoJSONReaderTests methodsFor: 'testing'!testStrings	| reader |	reader := [ :string |		(NeoJSONReader on: string readStream) next ].	self assert: (reader value: '"foo"') equals: 'foo'.	self assert: (reader value: '""') equals: ''.	self assert: (reader value: '"Foo BAR"') equals: 'Foo BAR'.	self assert: (reader value: '" foo "') equals: ' foo '.	self assert: (reader value: '"\u00E9l\u00E8ve en Fran\u00E7ais"') equals: 'lve en Franais'.	self 		assert: (reader value: '"\"\\\/\t\r\n\f\b"') 		equals: (String withAll: ( OrderedCollection new 			add: $";			add: $\; 			add: $/;			add: Character tab;			add: Character cr;			add: Character lf;			add: Character newPage; 			add: Character backspace;			yourself )).	self should: [ reader value: '"open' ] raise: NeoJSONParseError.	self should: [ reader value: '"\uAA"' ] raise: NeoJSONParseError.	self should: [ reader value: '"\uZZ"' ] raise: NeoJSONParseError.	self should: [ reader value: '"\x"' ] raise: NeoJSONParseError.	self should: [ reader value: ' " ' ] raise: NeoJSONParseError.! !!NeoJSONReaderTests methodsFor: 'testing'!testSymbol	| reader |	reader := [ :input | 		(NeoJSONReader on: input readStream) 			for: Symbol customDo: [ :mapping |				mapping decoder: [ :string | string asSymbol ] ];			nextAs: Symbol ].	self assert: (reader value: ' "foo" ') equals: #foo.	self assert: (reader value: ' "FOO-1" ') equals: #'FOO-1'! !!NeoJSONReaderTests methodsFor: 'testing'!testTime	| reader |	reader := [ :input | 		(NeoJSONReader on: input readStream) 			for: Time customDo: [ :mapping |				mapping decoder: [ :string | Time fromString: string ] ];			nextAs: Time ].	self assert: (reader value: ' "14:30:08" ') equals: (Time hour: 14 minute: 30 second: 8)! !!NeoJSONWriteReadAsciiOnlyTests methodsFor: 'private'!writeRead: object	| json |	json := String streamContents: [ :stream |		(NeoJSONWriter on: stream) asciiOnly: true; nextPut: object ].	^ (NeoJSONReader on: json readStream) next ! !!NeoJSONWriteReadMockStreamTests methodsFor: 'private'!writeRead: object	| json |	json := String streamContents: [ :stream |		(NeoJSONWriter on: (NeoJSONMockStream on: stream))			prettyPrint: true;			nextPut: object ].	^ (NeoJSONReader on: (NeoJSONMockStream on: json readStream)) next ! !!NeoJSONWriteReadPrettyPrintedTests methodsFor: 'testing'!testDictionaryOfObject2	| data json reader |	data := Dictionary new.	data 		at: 'one' put: NeoJSONTestObject2 example1;		at: 'two' put: NeoJSONTestObject2 example1.	json := NeoJSONWriter toStringPretty: data.	reader := NeoJSONReader on: json readStream.	reader for: #DictionaryOfObject2 customDo: [ :mapping |		mapping mapWithValueSchema: NeoJSONTestObject2 ].  	self 		assert: (reader nextAs: #DictionaryOfObject2)		equals: data! !!NeoJSONWriteReadPrettyPrintedTests methodsFor: 'testing'!testObject1	| json |	json := NeoJSONWriter toStringPretty: NeoJSONTestObject1 example1.	self 		assert: (NeoJSONReader fromString: json as: NeoJSONTestObject1)		equals: NeoJSONTestObject1 example1! !!NeoJSONWriteReadPrettyPrintedTests methodsFor: 'testing'!testObject2	| json |	json := NeoJSONWriter toStringPretty: NeoJSONTestObject2 example1.	self 		assert: (NeoJSONReader fromString: json as: NeoJSONTestObject2)		equals: NeoJSONTestObject2 example1! !!NeoJSONWriteReadPrettyPrintedTests methodsFor: 'testing'!testObject3	| json |	json := NeoJSONWriter toStringPretty: NeoJSONTestObject3 example1.	self 		assert: (NeoJSONReader fromString: json as: NeoJSONTestObject3)		equals: NeoJSONTestObject3 example1! !!NeoJSONWriteReadPrettyPrintedTests methodsFor: 'private'!writeRead: object	| json |	json := String streamContents: [ :stream |		(NeoJSONWriter on: stream) 			prettyPrint: true;			nextPut: object ].	^ (NeoJSONReader on: json readStream) next ! !!NeoJSONWriteReadTests methodsFor: 'testing'!testDictionaryOfObject2	| data json reader |	data := Dictionary new.	data 		at: 'one' put: NeoJSONTestObject2 example1;		at: 'two' put: NeoJSONTestObject2 example1.	json := NeoJSONWriter toString: data.	reader := NeoJSONReader on: json readStream.	reader for: #DictionaryOfObject2 customDo: [ :mapping |		mapping mapWithValueSchema: NeoJSONTestObject2 ].  	self 		assert: (reader nextAs: #DictionaryOfObject2)		equals: data! !!NeoJSONWriteReadTests methodsFor: 'testing'!testFloats	| objects |	objects := OrderedCollection new add: Float pi; add: 1.0; add: -1.0; add: 0.0; add: 1.5e6; add: -1.5e6; add: 1.5e-6; add: -1.5e-6; yourself.	(self writeRead: objects) 		with: objects 		do: [ :first :second | self assert: (first closeTo: second) ]! !!NeoJSONWriteReadTests methodsFor: 'testing'!testIntegers	| objects |	objects := Array with: 1 with: -1 with: 0 with: 123467890 with: -1234567890.	self 		assert: (self writeRead: objects)		equals: objects! !!NeoJSONWriteReadTests methodsFor: 'testing'!testLists	| objects |	objects := Array with: #(1 2 3) with: #() with: #( 'foo' 'bar').	self 		assert: (self writeRead: objects)		equals: objects! !!NeoJSONWriteReadTests methodsFor: 'testing'!testMaps	| objects |	objects := Array 		with: Dictionary new		with: (Dictionary with: 'x' -> 1)		with: (Dictionary newFromPairs: #( 'foo' true 'bar' false 'zero' 0 'null' nil 'string' 'Hello World!!' )).	self 		assert: (self writeRead: objects)		equals: objects! !!NeoJSONWriteReadTests methodsFor: 'testing'!testObject1	| json |	json := NeoJSONWriter toString: NeoJSONTestObject1 example1.	self 		assert: (NeoJSONReader fromString: json as: NeoJSONTestObject1)		equals: NeoJSONTestObject1 example1! !!NeoJSONWriteReadTests methodsFor: 'testing'!testObject2	| json |	json := NeoJSONWriter toString: NeoJSONTestObject2 example1.	self 		assert: (NeoJSONReader fromString: json as: NeoJSONTestObject2)		equals: NeoJSONTestObject2 example1! !!NeoJSONWriteReadTests methodsFor: 'testing'!testObject3	| json |	json := NeoJSONWriter toString: NeoJSONTestObject3 example1.	self 		assert: (NeoJSONReader fromString: json as: NeoJSONTestObject3)		equals: NeoJSONTestObject3 example1! !!NeoJSONWriteReadTests methodsFor: 'testing'!testSpecials	| objects |	objects := Array with: true with: false with: nil.	self 		assert: (self writeRead: objects)		equals: objects! !!NeoJSONWriteReadTests methodsFor: 'testing'!testStrings	| objects |	objects := OrderedCollection new		add: 'foo'; add: 'Foo BAR'; add: ''; add: '	\\'''; 		add: 'lve en Franais';		add: (Character codePoint: 12354) asString; "HIRAGANA LETTER A" 		yourself;		asArray.	self 		assert: (self writeRead: objects)		equals: objects! !!NeoJSONWriteReadTests methodsFor: 'private'!writeRead: object	| json |	json := String streamContents: [ :stream |		(NeoJSONWriter on: stream) nextPut: object ].	^ (NeoJSONReader on: json readStream) next ! !!NeoJSONWriterTests methodsFor: 'testing'!testAsciiOnlyStrings	| writer |	writer := [ :object | 		String streamContents: [ :stream |			(NeoJSONWriter on: stream) 				asciiOnly: true;				nextPut: object ] ].	self assert: (writer value: 'lve franais') equals: '"\u00E9l\u00E8ve fran\u00E7ais"'.	self assert: (writer value: 'foo') equals: '"foo"'.	self assert: (writer value: 'Foo BAR') equals: '"Foo BAR"'.	self assert: (writer value: '') equals: '""'.	self		assert: (writer value: (String withAll: ( OrderedCollection new 			add: $";			add: $\; 			add: $/;			add: Character tab;			add: Character cr;			add: Character lf;			add: Character newPage; 			add: Character backspace;			yourself )))		equals: '"\"\\/\t\r\n\f\b"'! !!NeoJSONWriterTests methodsFor: 'testing'!testAssociation	| writer |	writer := [ :object | 		String streamContents: [ :stream |			(NeoJSONWriter on: stream) 				for: Association do: [ :mapping |					mapping mapAccessors: #(key value) ]; 				nextPut: object ] ].	self assert: (writer value: 'foo' -> 42) equals: '{"key":"foo","value":42}'.	self assert: (writer value: Association new) equals: '{}'! !!NeoJSONWriterTests methodsFor: 'testing'!testBooleans	| writer |	writer := [ :object | 		String streamContents: [ :stream |			(NeoJSONWriter on: stream) nextPut: object ] ].	self assert: (writer value: true) equals: 'true'.	self assert: (writer value: false) equals: 'false'.! !!NeoJSONWriterTests methodsFor: 'testing'!testByteArray	| writer |	writer := [ :object | 		String streamContents: [ :stream |			(NeoJSONWriter on: stream) nextPut: object ] ].	self assert: (writer value: #[1 2 3]) equals: '[1,2,3]'.	self assert: (writer value: #[]) equals: '[]'! !!NeoJSONWriterTests methodsFor: 'testing'!testDate	| writer |	writer := [ :object | 		String streamContents: [ :stream |			(NeoJSONWriter on: stream) 				for: Date customDo: [ :mapping |					mapping encoder: [ :date | date yyyymmdd ] ];				nextPut: object ] ].	self assert: (writer value: (Date fromString: '2012-06-08')) equals: '"2012-06-08"'! !!NeoJSONWriterTests methodsFor: 'testing'!testDateAndTime 	| writer |	writer := [ :object | 		String streamContents: [ :stream |			(NeoJSONWriter on: stream) 				for: DateAndTime customDo: [ :mapping |					mapping encoder: [ :dateAndTime | dateAndTime printString ] ];				nextPut: object ] ].	self 		assert: (writer value: (DateAndTime year: 2012 month: 2 day: 14 hour: 16 minute: 40 second: 18 offset: 1 hour)) 		equals: '"2012-02-14T16:40:18+01:00"'! !!NeoJSONWriterTests methodsFor: 'testing'!testFloatPrinter	| writer |	writer := [ :object | 		String streamContents: [ :stream |			(NeoJSONWriter on: stream) 				floatPrinter: NeoJSONFloatPrinter new;				nextPut: object ] ].	self assert: (writer value: 123.0) equals: '123'.	self assert: (writer value: -123.0) equals: '-123'.	self assert: (writer value: 0.0) equals: '0'.	self assert: (writer value: 1.50) equals: '1.5'.	self assert: (writer value: -1.25) equals: '-1.25'.	self assert: (writer value: Float pi) equals: '3.14159'.	self assert: (writer value: 9.10938356e-31) equals: '9.10938e-31'.	self assert: (writer value: 5.9724e24) equals: '5.9724e24'.	self assert: (writer value: 1234567890.1234567890) equals: '1.23457e9'.	self assert: (writer value: (1/3) asFloat) equals: '0.33333'.! !!NeoJSONWriterTests methodsFor: 'testing'!testFloats	| writer |	writer := [ :object | 		String streamContents: [ :stream |			(NeoJSONWriter on: stream) nextPut: object ] ].	self assert: (writer value: 123.0) equals: '123.0'.	self assert: (writer value: -123.0) equals: '-123.0'.	self assert: (writer value: 0.0) equals: '0.0'.! !!NeoJSONWriterTests methodsFor: 'testing'!testIntegers	| writer |	writer := [ :object | 		String streamContents: [ :stream |			(NeoJSONWriter on: stream) nextPut: object ] ].	self assert: (writer value: 123) equals: '123'.	self assert: (writer value: -123) equals: '-123'.	self assert: (writer value: 0) equals: '0'.! !!NeoJSONWriterTests methodsFor: 'testing'!testLists	| writer |	writer := [ :object | 		String streamContents: [ :stream |			(NeoJSONWriter on: stream) nextPut: object ] ].	self assert: (writer value: #(1 2 3)) equals: '[1,2,3]'.	self assert: (writer value: #()) equals: '[]'.! !!NeoJSONWriterTests methodsFor: 'testing'!testListsExtra	| writer |	writer := [ :object | 		String streamContents: [ :stream |			(NeoJSONWriter on: stream) nextPut: object ] ].	#( OrderedCollection LinkedList ByteArray IntegerArray SortedCollection ) do: [ :each |		Smalltalk at: each ifPresent: [ :collectionClass |			self assert: (writer value: (collectionClass withAll: #(1 2 3))) equals: '[1,2,3]'.			self assert: (writer value: collectionClass new) equals: '[]' ] ]! !!NeoJSONWriterTests methodsFor: 'testing'!testMapKeysMustBeStrings	self should: [ NeoJSONWriter toString: { 1->#a } asDictionary ] raise: Error.	self should: [ NeoJSONWriter toString: { true->#a } asDictionary ] raise: Error.	self should: [ NeoJSONWriter toString: { nil->#a } asDictionary ] raise: Error.	self should: [ NeoJSONWriter toString: { #()->#a } asDictionary ] raise: Error.	self should: [ NeoJSONWriter toString: { Dictionary new->#a } asDictionary ] raise: Error.	self should: [ NeoJSONWriter toString: { Float pi->#a } asDictionary ] raise: Error.! !!NeoJSONWriterTests methodsFor: 'testing'!testMaps	| writer |	writer := [ :object | 		String streamContents: [ :stream |			(NeoJSONWriter on: stream) nextPut: object ] ].	self assert: ((writer value: (Dictionary newFromPairs: #( 'x' 1 'y' 2))) includesSubstring: '"x":1').	self assert: ((writer value: (Dictionary newFromPairs: #( 'x' 1 'y' 2))) includesSubstring: '"y":2').	self assert: (writer value: Dictionary new) equals: '{}'.! !!NeoJSONWriterTests methodsFor: 'testing'!testMapsExtra	| writer |	writer := [ :object | 		String streamContents: [ :stream |			(NeoJSONWriter on: stream) nextPut: object ] ].	self assert: (writer value: (IdentityDictionary newFromPairs: #( 'x' 1))) equals: '{"x":1}'.	self assert: (writer value: IdentityDictionary new) equals: '{}'.	#( SmallDictionary OrderedDictionary OrderedIdentityDictionary ) do: [ :each |		| dictionaryClass |		dictionaryClass := Smalltalk at: each ifAbsent: [ nil ].		dictionaryClass ifNotNil: [				self assert: (writer value: (dictionaryClass new at: 'x' put: 1; at: 'y' put: 2; yourself)) equals: '{"x":1,"y":2}'.			self assert: (writer value: dictionaryClass new) equals: '{}'] ]! !!NeoJSONWriterTests methodsFor: 'testing'!testNextPutStringAsHex	| output |	output := String		streamContents: [ :out | 			(NeoJSONWriter on: out)				for: #StringAsHex					customDo: [ :mapping | 							mapping								encoder: [ :x | x asByteArray hex asUppercase ];								decoder: [ :x | (ByteArray readHexFrom: x) asString ] ];				nextPut: 'Foo bar!!' as: #StringAsHex ].	self assert: output equals: '"466F6F2062617221"'! !!NeoJSONWriterTests methodsFor: 'testing'!testNonBMPCharacterEncoding	"Characters not in the Basic Multilingual Plane are encoded as a UTF-16 surrogate pair"	| string json |	string := 16r1D11E asCharacter asString. "MUSICAL SYMBOL G CLEF"	json := String streamContents: [ :out |		(NeoJSONWriter on: out) asciiOnly: true; nextPut: string ].	self assert: json equals: '"\uD834\uDD1E"'! !!NeoJSONWriterTests methodsFor: 'testing'!testNull	| writer |	writer := [ :object | 		String streamContents: [ :stream |			(NeoJSONWriter on: stream) nextPut: object ] ].	self assert: (writer value: nil) equals: 'null'! !!NeoJSONWriterTests methodsFor: 'testing'!testPoint	| writer |	writer := [ :object | 		String streamContents: [ :stream |			(NeoJSONWriter on: stream) nextPut: object ] ].	self should: [ writer value: 1@2 ] raise: NeoJSONMappingNotFound! !!NeoJSONWriterTests methodsFor: 'testing'!testPoint1	| writer |	writer := [ :object | 		String streamContents: [ :stream |			(NeoJSONWriter on: stream) 				for: Point do: [ :mapping |					mapping mapProperty: 'x' getter: [ :point | point x ] setter: [ :point :value | point x: value ].					mapping mapProperty: 'y' getter: [ :point | point y ] setter: [ :point :value | point y: value ]. ];				nextPut: object ] ].	self assert: (writer value: 1@2) equals: '{"x":1,"y":2}'.	self assert: (writer value: Point new) equals: '{}'! !!NeoJSONWriterTests methodsFor: 'testing'!testPoint2	| writer |	writer := [ :object | 		String streamContents: [ :stream |			(NeoJSONWriter on: stream) 				mapAllInstVarsFor: Point;				nextPut: object ] ].	self assert: (writer value: 1@2) equals: '{"x":1,"y":2}'.	self assert: (writer value: Point new) equals: '{}'! !!NeoJSONWriterTests methodsFor: 'testing'!testPoint3	| writer |	writer := [ :object | 		String streamContents: [ :stream |			(NeoJSONWriter on: stream) 				for: Point do: [ :mapping |					mapping mapInstVars: #(x y) ];				nextPut: object ] ].	self assert: (writer value: 1@2) equals: '{"x":1,"y":2}'.	self assert: (writer value: Point new) equals: '{}'! !!NeoJSONWriterTests methodsFor: 'testing'!testPointUsingAsString	| output |	output := String		streamContents: [ :out | 			(NeoJSONWriter on: out)				for: Point					do: [ :mapping | 							(mapping 								mapProperty: #x 								getter: [ :object | object x ] 								setter: [ :object :value | object setX: value setY: object y ])								valueSchema: #AsString.							(mapping								mapProperty: #y								getter: [ :object | object y ]								setter: [ :object :value | object setX: object x setY: value ]) 								valueSchema: #AsString ];				for: #AsString					customDo: [ :mapping | 							mapping								encoder: [ :x | x asString ];								decoder: [ :x | x asNumber ] ];				nextPut: 1 @ 2 ].	self assert: output equals: '{"x":"1","y":"2"}'! !!NeoJSONWriterTests methodsFor: 'testing'!testPointWriteNil	| writer |	writer := [ :object | 		String streamContents: [ :stream |			(NeoJSONWriter on: stream) 				writeNil: true;				mapAllInstVarsFor: Point;				nextPut: object ] ].	self assert: (writer value: 1@2) equals: '{"x":1,"y":2}'.	self assert: (writer value: Point new) equals: '{"x":null,"y":null}'! !!NeoJSONWriterTests methodsFor: 'testing'!testPreservePropertyOrder	| writer testObject |	(testObject := NeoJSONTestObject2 new)		id: 123;		width: 100;		height: 50;		data: 'test'.	writer := [ :object | 		String streamContents: [ :stream |			(NeoJSONWriter on: stream) 				for: NeoJSONTestObject2 do: [ :mapping | mapping mapInstVars: #(id width height data) ];				nextPut: object ] ].	self assert: (writer value: testObject) equals: '{"id":123,"width":100,"height":50,"data":"test"}'.	writer := [ :object | 		String streamContents: [ :stream |			(NeoJSONWriter on: stream) 				for: NeoJSONTestObject2 do: [ :mapping | mapping mapInstVars: #(width height data id) ];				nextPut: object ] ].	self assert: (writer value: testObject) equals: '{"width":100,"height":50,"data":"test","id":123}'.	writer := [ :object | 		String streamContents: [ :stream |			(NeoJSONWriter on: stream) 				for: NeoJSONTestObject2 do: [ :mapping | mapping mapInstVars: #(data id height width) ];				nextPut: object ] ].	self assert: (writer value: testObject) equals: '{"data":"test","id":123,"height":50,"width":100}'.! !!NeoJSONWriterTests methodsFor: 'testing'!testStrings	| writer |	writer := [ :object | 		String streamContents: [ :stream |			(NeoJSONWriter on: stream) nextPut: object ] ].	self assert: (writer value: 'foo') equals: '"foo"'.	self assert: (writer value: 'Foo BAR') equals: '"Foo BAR"'.	self assert: (writer value: '') equals: '""'.	self		assert: (writer value: (String withAll: ( OrderedCollection new 			add: $";			add: $\; 			add: $/;			add: Character tab;			add: Character cr;			add: Character lf;			add: Character newPage; 			add: Character backspace;			yourself )))		equals: '"\"\\/\t\r\n\f\b"'! !!NeoJSONWriterTests methodsFor: 'testing'!testSymbol	| writer |	writer := [ :object | 		String streamContents: [ :stream |			(NeoJSONWriter on: stream) nextPut: object ] ].	self assert: (writer value: #foo) equals: '"foo"'.	self assert: (writer value: #'FOO-1') equals: '"FOO-1"'! !!NeoJSONWriterTests methodsFor: 'testing'!testTime	| writer |	writer := [ :object | 		String streamContents: [ :stream |			(NeoJSONWriter on: stream) 				for: Time customDo: [ :mapping |					mapping encoder: [ :time | time printString ] ];				nextPut: object ] ].	self assert: ((writer value: (Time fromSeconds: 52208)) includesSubstring: '2:30:08')! !!NeoJSONBenchmark methodsFor: 'initialize-release'!initialize	super initialize.	objects := Array new: 1000.	1 to: 1000 do: [ :each |		| map |		(map := Dictionary new)			at: 'id' put: each;			at: 'name' put: 'Name-', each asString;			at: 'enabled' put: (#( true false) at: (each \\ 2) + 1);			at: 'color' put: (#( 'red' 'green' 'blue' ) at: (each \\ 3) + 1);			at: 'value' put: each + each / 1000.0.		objects at: each put: map ].	json := String streamContents: [ :stream |		(NeoJSONWriter on: stream) nextPut: objects ]		! !!NeoJSONBenchmark methodsFor: 'public'!read	^ (NeoJSONReader on: json readStream) next! !!NeoJSONBenchmark methodsFor: 'public'!write	^ String streamContents: [ :stream |		(NeoJSONWriter on: stream) nextPut: objects ]! !!NeoJSONBenchmark methodsFor: 'public'!writePrettyPrintedRead	| output |	output := String streamContents: [ :stream |		(NeoJSONWriter on: stream) 			prettyPrint: true;			nextPut: objects ].	^ (NeoJSONReader on: output readStream) 		next! !!NeoJSONMockStream class methodsFor: 'instance creation'!on: stream	^ self new		stream: stream;		yourself! !!NeoJSONMockStream methodsFor: 'testing'!atEnd	^ stream atEnd! !!NeoJSONMockStream methodsFor: 'accessing'!close	^ stream close! !!NeoJSONMockStream methodsFor: 'accessing'!collectionSpecies	^ stream collectionSpecies! !!NeoJSONMockStream methodsFor: 'accessing'!next	^ stream next! !!NeoJSONMockStream methodsFor: 'accessing'!nextPut: character	^ stream nextPut: character! !!NeoJSONMockStream methodsFor: 'accessing'!nextPutAll: string	^ stream nextPutAll: string! !!NeoJSONMockStream methodsFor: 'accessing'!peek	^ stream peek! !!NeoJSONMockStream methodsFor: 'accessing'!peekFor: char	^ stream peekFor: char! !!NeoJSONMockStream methodsFor: 'accessing'!space	^ stream space! !!NeoJSONMockStream methodsFor: 'initialize-release'!stream: anObject	stream := anObject! !!NeoJSONTestObject1 class methodsFor: 'instance creation'!example1	^ self new		id: 123;		name: 'Example1';		timestamp: (DateAndTime year: 2012 month: 06 day: 08 hour: 14 minute: 30 second: 15 offset: 1 hour);		points: (Array with: 1@2 with: 3@4);		bytes: #[ 2 4 6 8 ];		yourself! !!NeoJSONTestObject1 class methodsFor: 'accessing'!neoJsonMapping: mapper	mapper for: self do: [ :mapping |		mapping mapInstVars: #(id name).		(mapping mapInstVar: #timestamp to: 'created-at') valueSchema: DateAndTime.		(mapping mapInstVar: #points) valueSchema: #ArrayOfPoints.		(mapping mapInstVar: #bytes) valueSchema: ByteArray ].	mapper for: DateAndTime customDo: [ :mapping |		mapping decoder: [ :string | DateAndTime fromString: string ].		mapping encoder: [ :dateAndTime | dateAndTime printString ] ].	mapper for: #ArrayOfPoints customDo: [ :mapping |		mapping listOfElementSchema: Point ].  	mapper mapAllInstVarsFor: Point.	mapper for: ByteArray customDo: [ :mapping |		mapping listOfType: ByteArray ]! !!NeoJSONTestObject1 methodsFor: 'comparing'!= anObject	self == anObject		ifTrue: [ ^ true ].	self class = anObject class		ifFalse: [ ^ false ].	^ id = anObject id		and: [			name = anObject name				and: [					timestamp = anObject timestamp						and: [							points = anObject points								and: [ bytes = anObject bytes ] ] ] ]! !!NeoJSONTestObject1 methodsFor: 'accessing'!bytes	^ bytes! !!NeoJSONTestObject1 methodsFor: 'accessing'!bytes: byteArray	bytes := byteArray! !!NeoJSONTestObject1 methodsFor: 'comparing'!hash	^ id hash bitXor: (name hash bitXor: (timestamp hash bitXor: (points hash bitXor: bytes hash)))! !!NeoJSONTestObject1 methodsFor: 'accessing'!id	^ id! !!NeoJSONTestObject1 methodsFor: 'accessing'!id: integer	id := integer! !!NeoJSONTestObject1 methodsFor: 'accessing'!name	^ name! !!NeoJSONTestObject1 methodsFor: 'accessing'!name: string	name := string! !!NeoJSONTestObject1 methodsFor: 'accessing'!points	^ points! !!NeoJSONTestObject1 methodsFor: 'accessing'!points: arrayOfPoints	points := arrayOfPoints ! !!NeoJSONTestObject1 methodsFor: 'accessing'!timestamp	^ timestamp! !!NeoJSONTestObject1 methodsFor: 'accessing'!timestamp: dateAndTime 	timestamp := dateAndTime ! !!NeoJSONTestObject2 class methodsFor: 'testing'!benchmark10k	"self benchmark10k"		self benchmark: 10000! !!NeoJSONTestObject2 class methodsFor: 'testing'!benchmark10kAsDictionary	"self benchmark10kAsDictionary"		self benchmarkAsDictionary: 10000! !!NeoJSONTestObject2 class methodsFor: 'testing'!benchmark200k	"self benchmark200k"		self benchmark: 200000! !!NeoJSONTestObject2 class methodsFor: 'testing'!benchmark: count	"self benchmark: 1000"		| collection json size |	collection := Array new: count withAll: self example1.	size := 2 + (count * (NeoJSONWriter toString: self example1) size) + count - 1.	Transcript 		cr;		<< ('Serializing {1} objects took ms ' format: (Array with: count) );		show: [ json := String new: size streamContents: [ :stream |								(NeoJSONWriter on: stream) nextPut: collection ] ] timeToRun.	Transcript 		cr;		<< ('Deserializing {1} objects took ms ' format: (Array with: count) );		show: [ NeoJSONReader fromString: json ] timeToRun.! !!NeoJSONTestObject2 class methodsFor: 'testing'!benchmarkAsDictionary: count	"self benchmarkAsDictionary: 1000"		| collection json size |	collection := Array new: count withAll: self example1 asDictionary.	size := 2 + (count * (NeoJSONWriter toString: self example1 asDictionary) size) + count - 1.	Transcript 		cr;		<< ('Serializing {1} objects took ms ' format: (Array with: count) );		show: [ json := String new: size streamContents: [ :stream |								(NeoJSONWriter on: stream) nextPut: collection ] ] timeToRun.	Transcript 		cr;		<< ('Deserializing {1} objects took ms ' format: (Array with: count) );		show: [ NeoJSONReader fromString: json ] timeToRun.! !!NeoJSONTestObject2 class methodsFor: 'instance creation'!example1	^ self new		id: 13;		width: 250;		height: 110;		data: (String new: 512 withAll: $a);		yourself! !!NeoJSONTestObject2 class methodsFor: 'accessing'!neoJsonMapping: mapper	"For inheritance mapping to work, the schema/classname must be self,	but the instance variables have to be enumerated manually per class"	mapper for: self do: [ :mapping |		mapping mapInstVars: #(id width height data) ] ! !!NeoJSONTestObject2 methodsFor: 'comparing'!= anObject	self == anObject		ifTrue: [ ^ true ].	self class = anObject class		ifFalse: [ ^ false ].	^ id = anObject id		and: [			height = anObject height				and: [					width = anObject width						and: [							data = anObject data ] ] ]! !!NeoJSONTestObject2 methodsFor: 'converting'!asDictionary	^ Dictionary new		at: #id put: id;		at: #height put: height;		at: #width put: width;		at: #data put: data;		yourself! !!NeoJSONTestObject2 methodsFor: 'accessing'!data	^ data! !!NeoJSONTestObject2 methodsFor: 'accessing'!data: anObject	data := anObject! !!NeoJSONTestObject2 methodsFor: 'comparing'!hash	^ id hash bitXor: (width hash bitXor: (height hash bitXor: data hash))! !!NeoJSONTestObject2 methodsFor: 'accessing'!height	^ height! !!NeoJSONTestObject2 methodsFor: 'accessing'!height: anObject	height := anObject! !!NeoJSONTestObject2 methodsFor: 'accessing'!id	^ id! !!NeoJSONTestObject2 methodsFor: 'accessing'!id: anObject	id := anObject! !!NeoJSONTestObject2 methodsFor: 'accessing'!width	^ width! !!NeoJSONTestObject2 methodsFor: 'accessing'!width: anObject	width := anObject! !!NeoJSONTestObject3 class methodsFor: 'instance creation'!example1	^ super example1		data: (String new: 8 withAll: $a);		color: 'red';		transparent: true;		yourself! !!NeoJSONTestObject3 class methodsFor: 'accessing'!neoJsonMapping: mapper	"For inheritance mapping to work, the schema/classname must be self,	but the instance variables have to be enumerated manually per class"		super neoJsonMapping: mapper.	mapper for: self do: [ :mapping |		mapping mapInstVars: #(color transparent) ]! !!NeoJSONTestObject3 methodsFor: 'comparing'!= anObject	^ super = anObject 		and: [ color = anObject color			and: [ transparent = anObject transparent ] ]! !!NeoJSONTestObject3 methodsFor: 'converting'!asDictionary	^ super asDictionary		at: #color put: color;		at: #transparent put: transparent;		yourself! !!NeoJSONTestObject3 methodsFor: 'accessing'!color	^ color! !!NeoJSONTestObject3 methodsFor: 'accessing'!color: anObject	color := anObject! !!NeoJSONTestObject3 methodsFor: 'accessing'!transparent	^ transparent! !!NeoJSONTestObject3 methodsFor: 'accessing'!transparent: anObject	transparent := anObject! !!NeoJSONValidation methodsFor: 'private'!closeLog	logStream ifNotNil: [ 		logStream close.		logStream := nil ].	^ self logFile exists		ifTrue: [ self logFile contents ] 		ifFalse: [ 'log file is empty' ]! !!NeoJSONValidation methodsFor: 'private'!ensureLog	logStream ifNil: [ 		logStream := self logFile ensureDelete; writeStream. 		logStream setToEnd ]	! !!NeoJSONValidation methodsFor: 'accessing'!gitDirectory	^ gitDirectory ifNil: [ gitDirectory := FileLocator home / #Develop / #git ]! !!NeoJSONValidation methodsFor: 'accessing'!gitDirectory: fileReference	gitDirectory := fileReference! !!NeoJSONValidation methodsFor: 'accessing'!jsonTestSuiteDirectory	^ self gitDirectory / #JSONTestSuite! !!NeoJSONValidation methodsFor: 'accessing'!jsonTestSuiteTestParsingDirectory	^ self jsonTestSuiteDirectory / 'test_parsing'! !!NeoJSONValidation methodsFor: 'accessing'!jsonTestSuiteTestParsingFailFiles	^ self jsonTestSuiteTestParsingDirectory childrenMatching: 'n_*.json'! !!NeoJSONValidation methodsFor: 'accessing'!jsonTestSuiteTestParsingInfoFiles	^ self jsonTestSuiteTestParsingDirectory childrenMatching: 'i_*.json'! !!NeoJSONValidation methodsFor: 'accessing'!jsonTestSuiteTestParsingPassFiles	^ self jsonTestSuiteTestParsingDirectory childrenMatching: 'y_*.json'! !!NeoJSONValidation methodsFor: 'accessing'!jsonTestSuiteTestTransformDirectory	^ self jsonTestSuiteDirectory / 'test_transform'! !!NeoJSONValidation methodsFor: 'private'!log: message	self ensureLog.	logStream nextPutAll: message; lf; flush! !!NeoJSONValidation methodsFor: 'private'!logFile	^ 'neo-json-validation.log' asFileReference! !!NeoJSONValidation methodsFor: 'accessing'!nativeJsonBenchmarkDataDirectory	^ self nativeJsonBenchmarkDirectory / #data! !!NeoJSONValidation methodsFor: 'accessing'!nativeJsonBenchmarkDirectory	^ self gitDirectory / 'nativejson-benchmark'! !!NeoJSONValidation methodsFor: 'accessing'!nativeJsonBenchmarkJsonCheckerDirectory	^ self nativeJsonBenchmarkDataDirectory / #jsonchecker! !!NeoJSONValidation methodsFor: 'accessing'!nativeJsonBenchmarkJsonCheckerFailFiles	^ self nativeJsonBenchmarkJsonCheckerDirectory childrenMatching: 'fail*.json'! !!NeoJSONValidation methodsFor: 'accessing'!nativeJsonBenchmarkJsonCheckerPassFiles	^ self nativeJsonBenchmarkJsonCheckerDirectory childrenMatching: 'pass*.json'! !!NeoJSONValidation methodsFor: 'accessing'!nativeJsonBenchmarkRoundTripDirectory	^ self nativeJsonBenchmarkDataDirectory / #roundtrip! !!NeoJSONValidation methodsFor: 'accessing'!nativeJsonBenchmarkRoundTripFiles	^ self nativeJsonBenchmarkRoundTripDirectory children! !!NeoJSONValidation methodsFor: 'running'!runJsonTestSuiteTestParsingFailures	^ self		validateFiles: self jsonTestSuiteTestParsingFailFiles 		usingTest: [ :file | 			| data success |			success := false.			[ data := file readStreamDo: [ :in | (NeoJSONReader on: in) next; failIfNotAtEnd ] ]				on: NeoJSONParseError				do: [ :exception | self log: exception printString. success := true ].			success ]! !!NeoJSONValidation methodsFor: 'running'!runJsonTestSuiteTestParsingInfo	^ self		validateFiles: self jsonTestSuiteTestParsingInfoFiles 		usingTest: [ :file | 			| data success |			success := true.			[ data := file readStreamDo: [ :in | (NeoJSONReader on: in) next ] ]				on: NeoJSONParseError				do: [ :exception | self log: exception printString. success := false ].			success ]! !!NeoJSONValidation methodsFor: 'running'!runJsonTestSuiteTestParsingPasses	^ self		validateFiles: self jsonTestSuiteTestParsingPassFiles 		usingTest: [ :file | 			| data success |			success := true.			[ data := file readStreamDo: [ :in | (NeoJSONReader on: in) next ] ]				on: NeoJSONParseError				do: [ :exception | self log: exception printString. success := false ].			success ]! !!NeoJSONValidation methodsFor: 'running'!runNativeJsonBenchmarkJsonCheckerFailures	^ self		validateFiles: self nativeJsonBenchmarkJsonCheckerFailFiles		usingTest: [ :file | 			| data success |			success := false.			[ data := file readStreamDo: [ :in | (NeoJSONReader on: in) next; failIfNotAtEnd ] ]				on: NeoJSONParseError				do: [ :exception | self log: exception printString. success := true ].			success ]! !!NeoJSONValidation methodsFor: 'running'!runNativeJsonBenchmarkJsonCheckerPasses	^ self		validateFiles: self nativeJsonBenchmarkJsonCheckerPassFiles		usingTest: [ :file | 			| data success |			success := true.			[ data := file readStreamDo: [ :in | (NeoJSONReader on: in) next ] ]				on: NeoJSONParseError				do: [ :exception | self log: exception printString. success := false ].			success ]! !!NeoJSONValidation methodsFor: 'running'!runNativeJsonBenchmarkRoundTrip	^ self 		validateFiles: self nativeJsonBenchmarkRoundTripFiles		usingTest: [ :file |			| data json |			data := file readStreamDo: [ :in | (NeoJSONReader on: in) next ].			json := NeoJSONWriter toString: data.			json = file contents ]! !!NeoJSONValidation methodsFor: 'private'!validateFiles: files usingTest: block	| total succeeded failed |	total := succeeded := failed := 0.	files do: [ :file | 		| success |		self log: 'Running ' , file pathString.		self log: ([ file contents contractTo: 64 ] on: Error do: [ :exception | exception printString ]).		success := [ block value: file ]			on: Error			do: [ :exception | self log: '  Errored. ' , exception printString. false ].		total := total + 1.		success			ifTrue: [ succeeded := succeeded + 1 ]			ifFalse: [ failed := failed + 1 ].		self log: (success ifTrue: [ '  Succeeded' ] ifFalse: [ '  Failed' ]); log: '' ].	self log: ('{1} total = {2} succeeded + {3} failed' format: (Array with: total with: succeeded with: failed) ).	^ self closeLog! !"Neo-JSON-Tests"!!OrderedDictionary methodsFor: '*neo-json-pharo-core'!neoJsonOn: neoJSONWriter	neoJSONWriter writeMap: self! !!SmallDictionary methodsFor: '*neo-json-pharo-core'!neoJsonOn: neoJSONWriter	neoJSONWriter writeMap: self! !!VisualizerMain methodsFor: 'as yet unclassified' stamp: 'readAndParseJSON 10/23/2023 23:16'!readAndParseJSON: aFilePath    | jsonContent jsonObject |    jsonContent := aFilePath asFileReference contents.    jsonObject := NeoJSONReader fromString: jsonContent.    ^ jsonObject! !!BaselineOfRoassal3 methodsFor: 'baselines' prior: 18272146!baseline: spec	<baseline>	"https://github.com/ObjectProfile/Roassal3"	"pharo7 not supported"	spec for: #'pharo8.x' do: [ self baselineForPharo8: spec ].	spec for: #'pharo9.x' do: [ self baselineForPharo9: spec ].	spec for: #'pharo10.x' do: [ self baselineForPharo10: spec ].	spec for: #'pharo11.x' do: [ self baselineForPharo11: spec ].	spec for: #'common' do: [ self baselineForCommon: spec ].! !!BaselineOfRoassal3 methodsFor: 'baselines' prior: 18269997!baselineForCommon: spec	self dependencies: spec.	self registerPackages: spec.	self roassalGroups: spec 		core: self corePackagesNames		examples: self examplePackagesNames		tests: self testPackagesNames.! !!BaselineOfRoassal3 methodsFor: 'baselines'!baselineForPharo10: spec	self dependencies: spec.	self registerPackages: spec.	spec package: #'Roassal3-Pharo9'.	spec package: #'Roassal3-Pharo'.	self roassalGroups: spec 		core: self corePackagesNames, #('Roassal3-Pharo9' 'Roassal3-Pharo')		examples: self examplePackagesNames		tests: self testPackagesNames.! !!BaselineOfRoassal3 methodsFor: 'baselines'!baselineForPharo11: spec	self baselineForPharo10: spec! !!BaselineOfRoassal3 methodsFor: 'baselines' prior: 18272786!baselineForPharo8: spec	self dependencies: spec.	self registerPackages: spec.	spec package: #'Roassal3-Pharo8'.	spec package: #'Roassal3-Spec-Obsolete'.	spec package: #'Roassal3-Pharo'.	self roassalGroups: spec 		core: self corePackagesNames, #('Roassal3-Pharo8' 'Roassal3-Spec-Obsolete' 'Roassal3-Pharo')		examples: self examplePackagesNames		tests: self testPackagesNames.! !!BaselineOfRoassal3 methodsFor: 'baselines' prior: 18270310!baselineForPharo9: spec	self dependencies: spec.	self registerPackages: spec.	spec package: #'Roassal3-Pharo9'.	spec package: #'Roassal3-Pharo'.	self roassalGroups: spec 		core: self corePackagesNames, #('Roassal3-Pharo9' 'Roassal3-Pharo')		examples: self examplePackagesNames		tests: self testPackagesNames.! !!BaselineOfRoassal3 methodsFor: 'API-packages' prior: 18270426!corePackagesNames	^ #(	'Roassal3-Event'	'Roassal3-Builders'	'Roassal3-Shapes'	'Roassal3-Animation'	'Roassal3-Interaction'	'Roassal3-Layouts-Util'	'Roassal3-Layouts'	'Roassal3-Colors'	'Roassal3-Legend'	'Roassal3-UML'	'Roassal3-Sunburst'	'Roassal3-FlameGraph'	'Roassal3-Pie'	'Roassal3-Inspector'	'Roassal3-Chart'	'Roassal3-DSM'	'Roassal3-Menu'	'Roassal3-Spec'	'Roassal3-Spec-Morphic'	'Roassal3-BaselineMap'	'Roassal3-SVG'	)! !!BaselineOfRoassal3 methodsFor: 'dependencies' prior: 18269367!dependencies: spec	spec baseline: 'Bloc' with: [		spec repository: 'github://pharo-graphics/Bloc:dev-1.0/src' ].	spec baseline: 'AthensSVG' with: [		spec repository: 'github://pharo-contributions/Athens-SVG/src' ].	spec package: 'Athens-SVG-PathConverter' with: [		spec repository: 'github://pharo-contributions/Athens-SVG/src'].	spec baseline: 'Geometry' with: [ 		spec repository: 'github://pharo-contributions/Geometry/src' ].	spec baseline: 'NumericScales'with: [ 		spec repository: 'github://ObjectProfile/NumericScales:v1.01/src' ].	spec 		baseline: 'OSSubprocess'		with: [ spec repository: 'github://pharo-contributions/OSSubprocess/repository' ].! !!BaselineOfRoassal3 methodsFor: 'API-packages' prior: 18271268!extraPackagesNames	^ #(	'Roassal3-Mondrian'	'Roassal3-Experimental'	'Roassal3-LayoutStudio'	'Roassal3-LayoutStudio-Tests')! !!BaselineOfRoassal3 methodsFor: 'baselines' prior: 18271399!registerPackages: spec	"The packages to use, but not load"	spec package: #'Roassal3' with: [ spec requires: #('Geometry' 'NumericScales') ].	self corePackagesNames, 	self examplePackagesNames, 	self testPackagesNames, 	self extraPackagesNames do: [ :name | spec package: name ].		spec				package: #'Roassal3-Bloc' with: [ spec requires: #('Bloc') ];		package: #'Roassal3-SVG' with: [ spec requires: #('Athens-SVG-PathConverter') ];		package: #'Roassal3-SVG-Tests';		package: #'Roassal3-SVG-Examples';		package: #'Roassal3-SVG-Importer' with: [ spec requires: #('AthensSVG') ].			spec package: #'Roassal3-GraphViz' with: [ spec requires: #('OSSubprocess') ].		spec package: #'Roassal3-Gtk'.	spec package: #'Roassal3-Spec-Gtk'.! !!BaselineOfRoassal3 methodsFor: 'baselines' prior: 18273223!roassalGroups: spec core: arr1 examples: arr2 tests: arr3	| core |	core := #('Core').	spec		group: 'Core' with: #('Roassal3'), arr1;		group: 'Examples' with: core, arr2;		group: 'Tests' with: core, arr3;		group: 'SVGExamples' with: #('Examples' 'Roassal3-SVG-Examples');		group: 'SVGImporter' with: #('SVGExamples' 'Roassal3-SVG-Importer');		group: 'Gtk' with: #('Roassal3-Gtk' 'Roassal3-Spec-Gtk');		group: 'Mini' with: #('Tests' 'SVGExamples');		group: 'Full' with: #('Mini'), self extraPackagesNames;		group: 'GraphViz' with: #('Full' 'Roassal3-GraphViz');		group: 'BlocFull' with: #('Full' 'Roassal3-Bloc');		group: 'default' with: #('Mini')! !!BaselineOfRoassal3 methodsFor: 'API-packages' prior: 18270917!testPackagesNames	^ #(	'Roassal3-Global-Tests'	'Roassal3-Animation-Tests'	'Roassal3-Shapes-Tests'	'Roassal3-Interaction-Tests'	'Roassal3-Layouts-Tests'	'Roassal3-Chart-Tests'	'Roassal3-UML-Tests'	'Roassal3-Spec-Tests'	'Roassal3-Inspector-Tests'	'Roassal3-BaselineMap-Tests'	'Roassal3-SVG-Tests'	)! !"BaselineOfRoassal3"!!ASConverter commentStamp: '' prior: 0!A converter is a kind of parser.!!ASPathConverter commentStamp: '' prior: 0!The syntax of path data is concise in order to allow for minimal file size and efficient downloads, since many SVG files will be dominated by their path data. Some of the ways that SVG attempts to minimize the size of path data are as follows: All instructions are expressed as one character (e.g., a moveto is expressed as an M). Superfluous white space and separators such as commas can be eliminated (e.g., "M 100 100 L 200 200"contains unnecessary spaces and could be expressed more compactly as "M100 100L200 200"). The command letter can be eliminated on subsequent commands if the same command is used multiple timesin a row (e.g., you can drop the second "L" in "M 100 200 L 200 100 L -100 -200" and use "M 100 200 L 200100 -100 -200" instead). Relative versions of all commands are available (uppercase means absolute coordinates, lowercase meansrelative coordinates). Alternate forms of lineto are available to optimize the special cases of horizontal and vertical lines (absolute andrelative). Alternate forms of curve are available to optimize the special cases where some of the control points on thecurrent segment can be determined automatically from the control points on the previous segment.!!ASConverter methodsFor: 'parsing-public'!nextNumber	"read the number from stream.	or answer nil if not successfull"	"<number> (real number value): The specification of real number values is different for property values than for XML attribute values. CSS2 [CSS2] states that a property value which is a <number> is specified in decimal notation (i.e., a <decimal-number>), which consists of either an <integer>, or an optional sign character followed byzero or more digits followed by a dot (.) followed by one or more digits. Thus, for conformance withCSS2, any property in SVG which accepts <number> values is specified in decimal notation only. For SVG's XML attributes, to provide as much scalability in numeric values as possible, real numbervalues can be provided either in decimal notation or in scientific notation (i.e., a <scientific-number>), which consists of a <decimal-number> immediately followed by the letter ''e'' or ''E'' immediately followed by an <integer>.Unless stated otherwise for a particular attribute or property, a <number> has the capacity for at least a single- precision floating point number (see [ICC32]) and has a range (at a minimum) of -3.4e+38F to +3.4e+38F.It is recommended that higher precision floating point storage and computation be performed on operations such as coordinate system transformations to provide the best possible precision and to prevent round-off errors.Conforming High-Quality SVG Viewers are required to use at least double-precision floating point (see [ICC32]) for intermediate calculations on certain numerical operations.Within the SVG DOM, a <number> is represented as a float or an SVGAnimatedNumber."		| result sign esign pos int frac exponent |		esign := sign := 1.	pos := stream position.		stream peek = $- ifTrue: [ sign := -1.  stream next ].	int := self readInteger.		stream peek = $. ifTrue: [		stream next.		frac := self readFraction.	].		(stream peek = $e or: [ stream peek = $E ]) ifTrue: [		stream next.		stream peek = $- ifTrue: [ esign := -1.  stream next ].		exponent := self readInteger * esign ].		"failed"	(int isNil and: [ frac isNil ]) ifTrue: [ stream position: pos.  ^ nil ].		int ifNil: [ int := 0 ].	frac ifNil: [ frac := 0 ].	exponent ifNil: [ exponent := 0 ].		result :=  (int + frac * (10 raisedTo: exponent) * sign).		result isFraction ifTrue: [  ^ result asFloat ] ifFalse: [ ^ result ]! !!ASConverter methodsFor: 'accessing'!noFill	^ ASNoFill soleInstance ! !!ASConverter methodsFor: 'parsing'!parseColor: aString	^ Color fromString: aString! !!ASConverter methodsFor: 'operations'!readFraction"read fraction, what is after the decimal point:.12345"	| result mul |	(stream atEnd or: [ stream peek isDigit not ]) ifTrue: [ ^ nil ].		mul := 1/10. 	result := 0.	[ stream peek notNil and: [ stream peek isDigit ] ] whileTrue: [		result := result + ( (stream next digitValue) * mul ).		mul := mul / 10	].	^ result! !!ASConverter methodsFor: 'write and read'!readInteger	| result |	(stream atEnd or: [ stream peek isDigit not ]) ifTrue: [ ^ nil ].		result := 0.	[ stream peek notNil and: [ stream peek isDigit ] ] whileTrue: [		result := result * 10 + (stream next digitValue)	].	^ result! !!ASConverter methodsFor: 'operations'!skipBlanks	[ stream atEnd not and: [ stream peek isSeparator ] ] whileTrue: [ stream next ].! !!ASConverter methodsFor: 'operations'!skipBlanksAndComma	[ stream atEnd not and: [ stream peek isSeparator or: [stream peek =$,]] ] whileTrue: [ stream next ].! !!ASConverter methodsFor: 'accessing'!stream	^ stream! !!ASConverter methodsFor: 'accessing'!stream: aStream	stream := aStream! !!ASPathConverter methodsFor: 'path commands'!A	self absolute; ellipticalArc! !!ASPathConverter methodsFor: 'path commands'!C	^ self absolute; cubicBezier ! !!ASPathConverter methodsFor: 'path commands'!H	self absolute; hLineTo ! !!ASPathConverter methodsFor: 'path commands'!L	self absolute; lineTo.! !!ASPathConverter methodsFor: 'path commands'!M	"move-to absolute"	" 		Start a new sub-path at the given (x,y) coordinate. M (uppercase) indicates that absolute coordinates will follow; m (lowercase) indicates that relative coordinates will follow. 		If a relative moveto (m) appears as the first element of the path, then it is treated as a pair of absolute coordinates. 		If a moveto is followed by multiple pairs of coordinates, the subsequent pairs are treated as implicit lineto commands.		"	self absolute; moveTo.! !!ASPathConverter methodsFor: 'path commands'!Q	self absolute; quadraticBezier! !!ASPathConverter methodsFor: 'path commands'!S	self absolute; reflectedCubicBezier! !!ASPathConverter methodsFor: 'path commands'!T	self absolute; smoothQuadraticBezier! !!ASPathConverter methodsFor: 'path commands'!V	self absolute; vLineTo ! !!ASPathConverter methodsFor: 'path commands'!Z	self close! !!ASPathConverter methodsFor: 'path commands'!a	self relative; ellipticalArc! !!ASPathConverter methodsFor: 'builder commands'!absolute	absolute := true.	self addSegment ! !!ASPathConverter methodsFor: 'adding'!addSegment	| sel args |	sel := 	thisContext sender selector.	args := thisContext sender arguments.	"update min/max for calculatin bounding box"		path add: { sel. args }! !!ASPathConverter methodsFor: 'converting'!assertValidCommand: aCharacter 	( #( $M $m $Z $z $L $l $H $h $V $v $C $c $S $s $Q $q $T $t $A $a ) includes: aCharacter ) ifFalse: [		self error: 'invalid path segment command' ]! !!ASPathConverter methodsFor: 'accessing'!bbox	^ 100@100! !!ASPathConverter methodsFor: 'path commands'!c	^ self relative; cubicBezier ! !!ASPathConverter methodsFor: 'builder commands'!close	self addSegment ! !!ASPathConverter methodsFor: 'operations'!convertPathData	path := OrderedCollection new.		[ self skipBlanks. stream atEnd ] whileFalse: [		| cmd |		cmd := stream next.		self assertValidCommand: cmd.		self perform: cmd asString asSymbol.	].	^ path	! !!ASPathConverter methodsFor: 'operations'!cubicBezier"C/c (x1 y1 x2 y2 x y)+Draws a cubic Bezier curve from the current point to (x,y) using (x1,y1) as the control point at the beginning of the curve and (x2,y2) as the control point at the end of the curve. C (uppercase) indicates that absolute coordinates will follow; c (lowercase) indicates that relative coordinates will follow. Multiple sets of coordinates may be specified to draw a polybezier. At the end of the command, the new current point becomes the final (x,y) coordinate pair used in the polybezier."	| p1 p2 p3 |		p1 := self readPoint.	p2 := self readPoint.	p3 := self readPoint.		p3 ifNil: [ self error: 'Invalid path data: 3 points expected for cubic bezier '].	self curveVia: p1 and:  p2 to: p3. 		[ 		(p1 := self readPoint) ifNil: [ ^ self ].		p2 := self readPoint.		p3 := self readPoint.		p3 ifNil: [ self error: 'Invalid path data: 3 points expected for cubic bezier '].		self curveVia: p1 and:  p2 to: p3. 	] repeat.! !!ASPathConverter methodsFor: 'builder commands'!curveVia: aPoint and: aPoint2 to: aPoint3 	self addSegment ! !!ASPathConverter methodsFor: 'builder commands'!curveVia: aPoint to: aPoint2 	self addSegment ! !!ASPathConverter methodsFor: 'operations'!ellipticalArc "A (absolute) a (relative)elliptical arc(rx ry x-axis-rotation large-arc-flag sweep-flag x y)+Draws an elliptical arc from the current point to (x, y). The size and orientation of the ellipse are defined by two radii (rx, ry) and an x-axis-rotation, which indicates how the ellipse as a whole is rotated relative to the current coordinate system. The center (cx, cy) of the ellipse is calculated automatically to satisfy the constraints imposed by the other parameters. large-arc-flag and sweep- flag contribute to the automatic calculations and help determine how the arc is drawn."	| r xrot large sweep pt |		[	r := self readPoint.	r ifNil: [ ^ self ].		self skipBlanksAndComma.		xrot := self nextNumber.	self skipBlanksAndComma.		large := self nextNumber.	self skipBlanksAndComma.	sweep := self nextNumber.		pt := self readPoint.		pt ifNil: [ self error: 'Invalid path data for elliptical arc segment'].	self ellipticalArc: r xrot: xrot large: large sweep: sweep to: pt relative: absolute not.	] repeat.! !!ASPathConverter methodsFor: 'operations'!ellipticalArc: r xrot: xrot large: large sweep: sweep to: pt	self addSegment! !!ASPathConverter methodsFor: 'operations'!ellipticalArc: r xrot: xrot large: large sweep: sweep to: pt relative: isRelative	self addSegment! !!ASPathConverter methodsFor: 'path commands'!h	self relative; hLineTo ! !!ASPathConverter methodsFor: 'operations'!hLineTo"H (absolute) h (relative)x +Draws a horizontal line from the current point (cpx, cpy) to (x, cpy). H (uppercase) indicates that absolute coordinates will follow; h (lowercase) indicates that relative coordinates will follow. Multiple x values can be provided (although usually this doesn't make sense). At the end of the command, the new current point becomes (x, cpy) for the final value of x."	| x |		self skipBlanks.	x := self nextNumber ifNil: [ ^ self error: 'number expected for horizontal line segment'   ].		self hLineTo: x.		[ self skipBlanks. x := self nextNumber. x notNil ] whileTrue: [		self hLineTo: x	].! !!ASPathConverter methodsFor: 'builder commands'!hLineTo: aNumber	self addSegment ! !!ASPathConverter methodsFor: 'path commands'!l	self relative; lineTo.! !!ASPathConverter methodsFor: 'operations'!lastBezierPoint	path reverseDo: [ :arr | arr first caseOf: { 		[ #relative ] -> [ "ignore" ] } ]! !!ASPathConverter methodsFor: 'operations'!lineTo" L (absolute) l (relative)lineto(x y)+Draw a line from the current point to the given (x,y) coordinate which becomes the new current point. L (uppercase) indicates that absolute coordinates will follow; l (lowercase) indicates that relative coordinates will follow. A number of coordinates pairs may be specified to draw a polyline. At the end of the command, the new current point is set to the final set of coordinates provided."	| pt |	pt := self readPoint.		pt ifNil: [ self error: 'point expected for line segment' ].		self lineTo: pt.		[ pt := self readPoint. pt notNil ] whileTrue: [ self lineTo: pt ]! !!ASPathConverter methodsFor: 'builder commands'!lineTo: aPoint 	self addSegment ! !!ASPathConverter methodsFor: 'path commands'!m	"move-to relative"	" 		Start a new sub-path at the given (x,y) coordinate. M (uppercase) indicates that absolute coordinates will follow; m (lowercase) indicates that relative coordinates will follow. 		If a relative moveto (m) appears as the first element of the path, then it is treated as a pair of absolute coordinates. 		If a moveto is followed by multiple pairs of coordinates, the subsequent pairs are treated as implicit lineto commands.		"	| pt |	pt := self readPoint.	pt ifNil: [ self error: 'a point expected following after M/m command'].	path isEmpty ifTrue: [ 			self absolute; moveTo: pt; relative ] 		ifFalse: [ self relative; moveTo: pt ].	[ pt := self readPoint. pt notNil ] whileTrue: [ self lineTo: pt ]! !!ASPathConverter methodsFor: 'operations'!moveTo	"move-to"	" 		Start a new sub-path at the given (x,y) coordinate. M (uppercase) indicates that absolute coordinates will follow; m (lowercase) indicates that relative coordinates will follow. 		If a relative moveto (m) appears as the first element of the path, then it is treated as a pair of absolute coordinates. 		If a moveto is followed by multiple pairs of coordinates, the subsequent pairs are treated as implicit lineto commands.		"	| pt |	pt := self readPoint.	pt ifNil: [ self error: 'a point expected following after M/m command'].		self moveTo: pt.		[ pt := self readPoint. pt notNil ] whileTrue: [ self lineTo: pt ]! !!ASPathConverter methodsFor: 'builder commands'!moveTo: aPoint 	self addSegment ! !!ASPathConverter methodsFor: 'path commands'!q	self relative; quadraticBezier! !!ASPathConverter methodsFor: 'operations'!quadraticBezier "Q/q (x1 y1 x y)+Draws a quadratic Bezier curve from the current point to (x,y) using (x1,y1) as the control point. Q (uppercase) indicates that absolute coordinates will follow; q (lowercase) indicates that relative coordinates will follow. Multiple sets of coordinates may be specified to draw a polybezier. At the end of the command, the new current point becomes the final (x,y) coordinate pair used in the polybezier."	| p1 p2 |		p1 := self readPoint.	p2 := self readPoint.		p2 ifNil: [ self error: 'Invalid path data: 2 points expected for quadratic bezier '].		self curveVia: p1 to: p2. 		[ 		(p1 := self readPoint) ifNil: [ ^ self ].		p2 := self readPoint.		p2 ifNil: [ self error: 'Invalid path data: 2 points expected for quadratic bezier '].		self curveVia: p1 to: p2. 	] repeat.! !!ASPathConverter methodsFor: 'operations'!readPoint	" A path data permits specifying points without comma separator "	| x y pos |	self skipBlanksAndComma.	pos := stream position.	x := self nextNumber ifNil: [ ^ nil ].		self skipBlanksAndComma.		y := self nextNumber ifNil: [ stream position: pos. ^ nil ].		^ x @ y! !!ASPathConverter methodsFor: 'operations'!reflectedCubicBezier"S/s (x2 y2 x y)+cubic Bzier curve from the current point to (x,y). The first control point is assumed to be the reflection of the second control point on the previous command relative to the current point. (If there is no previous command or if the previous command was not an C, c, S or s, assume the first control point is coincident with the current point.) (x2,y2) is the second control point (i.e., the control point at the end of the curve). S (uppercase) indicates that absolute coordinates will follow; s (lowercase) indicates that relative coordinates will follow. Multiple sets of coordinates may be specified to draw a polybzier. At the end of the command, the new current point becomes the final (x,y) coordinate pair used in the polybzier."	| p1 p2 |		p1 := self readPoint.	p2 := self readPoint.		p2 ifNil: [ self error: 'Invalid path data: 2 points expected for reflected cubic bezier '].	self reflectedCurveVia: p1 to: p2. 		[ 		(p1 := self readPoint) ifNil: [ ^ self ].		p2 := self readPoint.		p2 ifNil: [ self error: 'Invalid path data: 2 points expected for reflected cubic bezier '].		self reflectedCurveVia: p1 to: p2. 	] repeat.! !!ASPathConverter methodsFor: 'builder commands'!reflectedCurveVia: aPoint to: aPoint2 	self addSegment ! !!ASPathConverter methodsFor: 'builder commands'!relative	absolute := false.	self addSegment ! !!ASPathConverter methodsFor: 'path commands'!s	self relative; reflectedCubicBezier! !!ASPathConverter methodsFor: 'operations'!smoothQuadraticBezier	self notYetImplemented ! !!ASPathConverter methodsFor: 'path commands'!t	self relative; smoothQuadraticBezier! !!ASPathConverter methodsFor: 'path commands'!v	self relative; vLineTo ! !!ASPathConverter methodsFor: 'operations'!vLineTo"V (absolute) v (relative)Draws a vertical line from the current point (cpx, cpy) to (cpx, y). V (uppercase) indicates that absolute coordinates will follow; v (lowercase) indicates that relative coordinates will follow. Multiple y values can be provided (although usually this doesn't make sense). At the end of the command, the new current point becomes (cpx, y) for the final value of y."	| y |		self skipBlanks.	y := self nextNumber ifNil: [ ^ self error: 'number expected for horizontal line segment'   ].		self vLineTo: y.		[ self skipBlanks. y := self nextNumber. y notNil ] whileTrue: [		self vLineTo: y	].! !!ASPathConverter methodsFor: 'builder commands'!vLineTo: aNumber		self addSegment ! !!ASPathConverter methodsFor: 'path commands'!z	self close! !!ASNoFill class methodsFor: 'accessing'!soleInstance	^ soleInstance ifNil: [ soleInstance  := self new ]	! !!ASNoFill methodsFor: 'public'!fill: aShape on: aCanvas	"do nothing"! !!ASNoFill methodsFor: 'public'!resolveIds: aDictionary 	^ self! !!ASNoFill methodsFor: 'public'!stroke: aShape on: aCanvas	"do nothing" ! !!AthensCairoPathBuilder methodsFor: '*Athens-SVG-PathConverter'!arcDegreeStart: aStartAngle sweep: aSweepAngle centerX: anX y: aY radius: aRadius 	^self 		arcRadianStart: aStartAngle degreesToRadians		sweep: aSweepAngle degreesToRadians		centerX: anX		y: aY		radius: aRadius! !!AthensCairoPathBuilder methodsFor: '*Athens-SVG-PathConverter'!arcRadianStart: aStartAngle sweep: aSweepAngle centerX: anX y: aY radius: aRadius 	| endAngle |		endAngle := aStartAngle + aSweepAngle.	aSweepAngle positive 		ifTrue: 			[ self arcCenterX: anX centerY: aY radius: aRadius startAngle: aStartAngle endAngle: endAngle ]		ifFalse: 			[ self arcNegativeCenterX: anX centerY: aY radius: aRadius startAngle: aStartAngle endAngle: endAngle ].! !!AthensCairoPathBuilder methodsFor: '*Athens-SVG-PathConverter'!ellipticalArc3: radii xrot: xAxisRotation large: largeArcFlag sweep: sweepFlag to: theEndPoint"	 self cwArcTo: pt angle: 45 degreesToRadians  "		| rx ry x1 y1 x2 y2 dx2 dy2 phi cosAngle sinAngle arx ary coeff cx1 cy1 ux uy vx vy sign xPrime1 yPrime1 radical startAngle sweepAngle cx cy aPoint |	aPoint := lastControlPoint.		rx := radii x.	ry := radii y.		(rx - ry) abs < 1e-7 ifTrue: [		^self "self computeCircleArcAt: aPoint"].		x1 := aPoint x.	y1 := aPoint y.	x2 := theEndPoint x.	y2 := theEndPoint y.	dx2 := (x1 - x2) / 2.	dy2 := (y1 - y2) / 2.	phi := (xAxisRotation \\ 360) degreesToRadians.	cosAngle := phi cos.	sinAngle := phi sin.	xPrime1 := cosAngle * dx2 + (sinAngle * dy2).	yPrime1 := cosAngle * dy2 - (sinAngle * dx2).	"Ensure radii are positive"	arx := rx abs.	ary := ry abs.	"Ensure radii are large enough"	"lambda := (x1 squared / arx squared) + (y1 squared / ary squared).	lambda > 1 ifTrue: [		arx := arx * lambda sqrt.		ary := ary * lambda sqrt]."	"Step 2: Compute (cx1, cy1) "	radical := (arx squared * ary squared - (arx squared * yPrime1 squared)				- (ary squared * xPrime1 squared))					/ (arx squared * yPrime1 squared + (ary squared * xPrime1 squared)).	radical abs <= 1e-4 ifTrue: [radical := 0.0].	coeff := radical sqrt.	sweepFlag == largeArcFlag ifTrue: [coeff := coeff negated].	cx1 := coeff * arx * yPrime1 / ary.	cy1 := (coeff * ary * xPrime1 / arx) negated.	"Step 3: Compute (cx, cy)"	cx := cosAngle * cx1 - (sinAngle * cy1) + ((x1 + x2) / 2).	cy := sinAngle * cx1 + (cosAngle * cy1) + ((y1 + y2) / 2).	"Step 4: Compute startAngle and sweepAngle"	ux := (xPrime1 - cx1) / arx.	uy := (yPrime1 - cy1) / ary.	vx := (xPrime1 negated - cx1) / arx.	vy := (yPrime1 negated - cy1) / ary.	sign := ux * vy - (uy * vx) < 0 ifTrue: [-1] ifFalse: [1].	startAngle := ((ux / (ux squared + uy squared) sqrt) arcCos * uy sign)				radiansToDegrees \\ 360.	sweepAngle := (((ux * vx + (uy * vy))				/ ((ux squared + uy squared) * (vx squared + vy squared)) abs sqrt) asFloat				arcCos * sign)				radiansToDegrees \\ 360.	(sweepAngle abs < 180 and: [largeArcFlag])		ifTrue: 			[sweepAngle < 0				ifTrue: [sweepAngle := 360 + sweepAngle]				ifFalse: [sweepAngle := sweepAngle - 360]].	sweepFlag		ifTrue: [sweepAngle < 0 ifTrue: [sweepAngle := sweepAngle + 360]]		ifFalse: [sweepAngle > 0 ifTrue: [sweepAngle := sweepAngle - 360]].			! !!AthensCairoPathBuilder methodsFor: '*Athens-SVG-PathConverter'!ellipticalArc: radii xrot: xAxisRotation large: largeArcFlag sweep: sweepFlag to: theEndPoint"	 self cwArcTo: pt angle: 45 degreesToRadians  "		| rx ry x1 y1 x2 y2 dx2 dy2 phi cosAngle sinAngle arx ary coeff cx1 cy1 ux uy vx vy sign xPrime1 yPrime1 radical startAngle sweepAngle cx cy aPoint lFlag swFlag isRelative aCenter |	aPoint := 0@0.		lFlag := false.	swFlag := false.		rx := radii x.	ry := radii y.			x1 := aPoint x.	y1 := aPoint y.	x2 := theEndPoint x.	y2 := theEndPoint y.	dx2 := (x1 - x2) / 2.	dy2 := (y1 - y2) / 2.	phi := (xAxisRotation \\ 360) degreesToRadians.	cosAngle := phi cos.	sinAngle := phi sin.	xPrime1 := cosAngle * dx2 + (sinAngle * dy2).	yPrime1 := cosAngle * dy2 - (sinAngle * dx2).	"Ensure radii are positive"	arx := rx abs.	ary := ry abs.	"Ensure radii are large enough"	"lambda := (x1 squared / arx squared) + (y1 squared / ary squared).	lambda > 1 ifTrue: [		arx := arx * lambda sqrt.		ary := ary * lambda sqrt]."	"Step 2: Compute (cx1, cy1) "	radical := (arx squared * ary squared - (arx squared * yPrime1 squared)				- (ary squared * xPrime1 squared))					/ (arx squared * yPrime1 squared + (ary squared * xPrime1 squared)).	radical "abs" <= 1e-4 ifTrue: [radical := 0.0].	coeff := radical sqrt.	swFlag == lFlag ifTrue: [coeff := coeff negated].	cx1 := coeff * arx * yPrime1 / ary.	cy1 := (coeff * ary * xPrime1 / arx) negated.	"Step 3: Compute (cx, cy)"	cx := cosAngle * cx1 - (sinAngle * cy1) + ((x1 + x2) / 2).	cy := sinAngle * cx1 + (cosAngle * cy1) + ((y1 + y2) / 2).	"Step 4: Compute startAngle and sweepAngle"	ux := (xPrime1 - cx1) / arx.	uy := (yPrime1 - cy1) / ary.	vx := (xPrime1 negated - cx1) / arx.	vy := (yPrime1 negated - cy1) / ary.	sign := ux * vy - (uy * vx) < 0 ifTrue: [-1] ifFalse: [1].	startAngle := ((ux / (ux squared + uy squared) sqrt) arcCos * uy sign)				radiansToDegrees \\ 360.	sweepAngle := (((ux * vx + (uy * vy))				/ ((ux squared + uy squared) * (vx squared + vy squared)) abs sqrt) asFloat				arcCos * sign)				radiansToDegrees \\ 360.	(sweepAngle abs < 180 and: [lFlag])		ifTrue: 			[sweepAngle < 0				ifTrue: [sweepAngle := 360 + sweepAngle]				ifFalse: [sweepAngle := sweepAngle - 360]].	swFlag		ifTrue: [sweepAngle < 0 ifTrue: [sweepAngle := sweepAngle + 360]]		ifFalse: [sweepAngle > 0 ifTrue: [sweepAngle := sweepAngle - 360]].			isRelative := false.	aCenter := isRelative ifTrue: [ endPoint + (cx@cy)] ifFalse: [cx@cy].		self arcDegreeStart: startAngle sweep: sweepAngle centerX: aCenter x y: aCenter y radius: rx abs.	endPoint := self toAbsolute: theEndPoint."self arcDegreeStart: startAngle sweep: sweepAngle centerX: cx y: cy radius: 1.0 "		"	self arcCenterX: xc centerY: yc radius: radius startAngle: angle1 endAngle: angle2  "! !!AthensCairoPathBuilder methodsFor: '*Athens-SVG-PathConverter'!ellipticalArc: radii xrot: xAxisRotation large: largeArcFlag sweep: sweepFlag to: theEndPoint relative: isRelative"	 self cwArcTo: pt angle: 45 degreesToRadians  "		| rx ry x1 y1 x2 y2 dx2 dy2 arx ary coeff cx1 cy1 ux uy vx vy sign xPrime1 yPrime1 radical  startAngle sweepAngle cx cy aPoint lFlag swFlag aCenter uySign |			aPoint := isRelative				ifTrue: [0.0 @ 0.0]				ifFalse: [endPoint].		lFlag := false.	swFlag := sweepFlag = 1.0.		rx := radii x.	ry := radii y.			x1 := aPoint x.	y1 := aPoint y.	x2 := theEndPoint x.	y2 := theEndPoint y.	dx2 := (x1 - x2) / 2.	dy2 := (y1 - y2) / 2."	phi := (xAxisRotation \\ 360) degreesToRadians.	cosAngle := phi cos.	sinAngle := phi sin.	xPrime1 := cosAngle * dx2 + (sinAngle * dy2).	yPrime1 := cosAngle * dy2 - (sinAngle * dx2)."		xPrime1 := dx2.	yPrime1 := dy2.	"Ensure radii are positive"	arx := rx abs.	ary := ry abs.	"Ensure radii are large enough"	"lambda := (x1 squared / arx squared) + (y1 squared / ary squared).	lambda > 1 ifTrue: [		arx := arx * lambda sqrt.		ary := ary * lambda sqrt]."	"Step 2: Compute (cx1, cy1) "	radical := (arx squared * ary squared - (arx squared * yPrime1 squared)				- (ary squared * xPrime1 squared))					/ (arx squared * yPrime1 squared + (ary squared * xPrime1 squared)).	radical abs <= 1e-4 ifTrue: [radical := 0.0].	coeff := radical abs sqrt.	sweepFlag == largeArcFlag ifTrue: [coeff := coeff negated].	cx1 := coeff * yPrime1.	cy1 := (coeff * xPrime1) negated.	"Step 3: Compute (cx, cy)"	cx := cx1 + ((x1 + x2) / 2).	cy := cy1 + ((y1 + y2) / 2).	"Step 4: Compute startAngle and sweepAngle"	ux := (xPrime1 - cx1) / arx.	uy := (yPrime1 - cy1) / ary.	vx := (xPrime1 negated - cx1) / arx.	vy := (yPrime1 negated - cy1) / ary.	sign := ux * vy - (uy * vx) <= 0 ifTrue: [-1] ifFalse: [1].	uySign := uy = 0 ifTrue: [1] ifFalse: [uy sign].	startAngle := ((ux / (ux squared + uy squared) sqrt) arcCos * uySign)				radiansToDegrees \\ 360.	sweepAngle := (((ux * vx + (uy * vy))				/ ((ux squared + uy squared) * (vx squared + vy squared)) abs sqrt) asFloat				arcCos * sign)				radiansToDegrees \\ 360.	(sweepAngle abs < 180 and: [lFlag])		ifTrue: 			[sweepAngle < 0				ifTrue: [sweepAngle := 360 + sweepAngle]				ifFalse: [sweepAngle := sweepAngle - 360]].	swFlag		ifTrue: [sweepAngle < 0 ifTrue: [sweepAngle := sweepAngle + 360]]		ifFalse: [sweepAngle > 0 ifTrue: [sweepAngle := sweepAngle - 360]].					aCenter := isRelative ifTrue: [ endPoint + (cx@cy)] ifFalse: [cx@cy].		self arcDegreeStart: startAngle sweep: sweepAngle centerX: aCenter x y: aCenter y radius: rx abs.	endPoint := self toAbsolute: theEndPoint."self arcDegreeStart: startAngle sweep: sweepAngle centerX: cx y: cy radius: 1.0 "		"	self arcCenterX: xc centerY: yc radius: radius startAngle: angle1 endAngle: angle2  "! !"Athens-SVG-PathConverter"!!NSNiceLinearScaleStep commentStamp: '' prior: 0!I am an utility class for RTNiceStepSizeGenerator>>next!!NSNiceLinearScaleStepSizeGenerator commentStamp: '' prior: 0!Nice numbers are just step sizes and used for tick spacing. We will use only niceStep tick spaces and place tick marks at multiples of tick spacing.    References:  	[1] An Extension of Wilkinson's Algorithm for positioning Tick Labels on Axes  		 				(Justin Talbot, Sharon Lin, Pat Hanrahan)   [2] Nice Numbers for Graph Labels (Paul S. Heckbert, Graphic Gems I)Here is an example on how to use it:-=-=-=-=-=-=-=-=-=nice := RSNiceStepSizeGenerator new.lg := RSLabelGenerator nice: nice.lg setLooseFlag: true.label := lg searchMin: -98.0 max: 18.0 desired: 3.label asString-=-=-=-=-=-=-=-=-=This prints  '(Score: 0.14) -100.00	-60.00	-20.00	20.00	'!!NSNiceLinearTicksGenerator commentStamp: '' prior: 0!Reference: 	[1] An Extension of Wilkinson's Algorithm for positioning Tick Labels on Axes  (Justin Talbot, Sharon Lin, Pat Hanrahan)!!RSNiceLinearScaleResult commentStamp: '' prior: 0!I am an utility class for RSLabelGenerator.-=-=-=-=-=-=-=-=-=values := #(1 2.3 4.3).c := RSChart new.d := RSScatterPlot new x: values y: values.c addPlot: d.c addDecoration: RSHorizontalTick new.tick := RSVerticalTick new.c addDecoration: tick.c build.tick createNiceLabelIn: c -=-=-=-=-=-=-=-=-=prints the following: "(Score: 0.75) 1.00	2.00	3.00	4.00	5.00	"					The min and max represents the range of the ticks!!NSLogScale commentStamp: '' prior: 51986434!For scale log, for positive domains or negative domainsplease note that you can not use numbers that contains zero.For example```log := NSLogScale new	domain: #(1 100).log scale: 0```!!NSNiceLinearScaleStep methodsFor: 'accessing'!i	^ i! !!NSNiceLinearScaleStep methodsFor: 'accessing'!i: aNumber	i := aNumber! !!NSNiceLinearScaleStep methodsFor: 'accessing'!j	^ j! !!NSNiceLinearScaleStep methodsFor: 'accessing'!j: aNumber	j := aNumber! !!NSNiceLinearScaleStep methodsFor: 'accessing'!offset	^ offset! !!NSNiceLinearScaleStep methodsFor: 'accessing'!offset: aNumber	offset := aNumber! !!NSNiceLinearScaleStep methodsFor: 'accessing'!stepSize	^ stepSize! !!NSNiceLinearScaleStep methodsFor: 'accessing'!stepSize: aNumber	stepSize := aNumber! !!NSNiceLinearScaleStepSizeGenerator methodsFor: 'accessing'!base	^ base! !!NSNiceLinearScaleStepSizeGenerator methodsFor: 'initialization'!initialize	"Generates a NiceNumberGenerator"	super initialize.	niceStep := NSNiceLinearScaleStep new.	o := 0.0.	self setQ: #(1 5 2 2.5 4 3) base: 10! !!NSNiceLinearScaleStepSizeGenerator methodsFor: 'private'!logB: a	^ a ln / base ln! !!NSNiceLinearScaleStepSizeGenerator methodsFor: 'public'!next	| oSet |	niceStep		stepSize: ss;		offset: o;		i: i; "all output and calculations shouls add 1 because wilkinsons index start from 1"		j: j.	"Keep track of existing offsets and stepSizes to avoid duplicate returns of	step size, offset pairs"	(ssOffMap includesKey: ss) ifTrue: [		oSet := ssOffMap at: ss.		[ | b |			b := oSet includes: o.			oSet add: o.			b not and: [io < (ovar size - 1)] ] whileTrue: [			 io := io +1.			 niceStep offset: (o := ovar at: io +1 ). ].		 ] ifFalse: [		oSet := Set new.		oSet add: o.		ssOffMap at: ss put: oSet.		 ].	io := io +1."position for next offset if it exists"	"iterate for next call"	io < ovar size ifTrue: [ o := ovar at: io +1  ]	ifFalse: [		io := 0.		i := (i< (qvar size - 1) ) ifTrue: [ i+1 ] ifFalse: [ 0 ] .		j := i = 0 ifTrue: [ j+1 ] ifFalse: [ j ].		q := self qat: i.		ss := self stepSize: j q: q.		ovar := self offsets: j q: q.		o := ovar at: io + 1.	].	resetRequired := true.	^ niceStep! !!NSNiceLinearScaleStepSizeGenerator methodsFor: 'private'!offsets: tj q: tq	| offs |	offs := Array new: tj.	(0 to: tj-1) do: [ :ti |		offs at: ti+1 put: ((tq*ti) raisedTo: (self logB: tj*tq) ) ].	^ offs! !!NSNiceLinearScaleStepSizeGenerator methodsFor: 'private'!qat: index	^ qvar at: index + 1! !!NSNiceLinearScaleStepSizeGenerator methodsFor: 'accessing'!qvar	^ qvar! !!NSNiceLinearScaleStepSizeGenerator methodsFor: 'initialization'!reset	resetRequired ifFalse: [ ^ self ].	i := 0.	io := 0.	j := 1.	q := self qat: i.	ss := self stepSize: j q: q.	ssOffMap := Dictionary new.	resetRequired := false! !!NSNiceLinearScaleStepSizeGenerator methodsFor: 'initialization'!setQ: anArray base: aNumber	"anArray: preference ordered list of niceStep step sizes.	The deault is set by the initializer selector	aNumber: is a number of logs and exps usually changed together with Q"	qvar := anArray.	base := aNumber.	i := 0.	io := 0.	j := 1.	q := self qat: i.	ss := self stepSize: j q: q.	ovar := self offsets: j q: q.	ssOffMap := Dictionary new.	resetRequired := false! !!NSNiceLinearScaleStepSizeGenerator methodsFor: 'private'!stepSize: tj q: tq	^ tj * tq / (base raisedTo: (self logB: tj*tq ) floor )! !!NSNiceLinearTicksGenerator class methodsFor: 'instance creation'!nice: aNiceGenerator	^ self new nice: aNiceGenerator! !!NSNiceLinearTicksGenerator methodsFor: 'private'!coverageMin: dmin max: dmax lmin: lmin lmax: lmax	| a b c|	a := dmax - lmax.	b := dmin - lmin.	c := 0.1 * (dmax - dmin).	^ 1 - ( 0.5 * (((a * a) + (b * b))/ (c * c)) )! !!NSNiceLinearTicksGenerator methodsFor: 'private'!coverageMin: dmin max: dmax span: span	| range r half|	range := dmax - dmin.	(span > range) ifTrue: [		half := (span - range)/2.		r := 0.1*range.		^ 1 - (half * half / (r * r) )].	^ 1.0! !!NSNiceLinearTicksGenerator methodsFor: 'private'!density: k m: m dmin: dmin dmax: dmax lmin: lmin lmax: lmax	"* k		number of labels	 * m		number of desired labels	 * dmin	data range minimum	 * dmax	data range maximum	 * lmin	label range minimum	 * lmax	label range maximum	 * ^	density	 k-1 number of intervals between labels	 m-1 number of intervals between desired number of labels	 r   label interval length/label range	 rt  desired label interval length/actual range"	| r rt |	r := (k -1)/(lmax - lmin).	rt := (m - 1)/((lmax max: dmax) - (lmin min: dmin) ).	^ 2 - ( (r/rt) max: (rt/r) )! !!NSNiceLinearTicksGenerator methodsFor: 'private'!densityMax: k m: m	(k >= m) ifTrue: [ ^ 2 - ((k-1)/(m-1)) ].	^ 1! !!NSNiceLinearTicksGenerator methodsFor: 'private'!epsilon	" Compute the machine epsilon for the float type, the largest positive 	floating-point value that, when added to 1, results in a value equal to 1 due to 	roundoff."	| temp |	epsilon ifNotNil: [ ^ epsilon ].	temp := 0.5.	[ (1 + temp) > 1 ] whileTrue: [ temp := temp / 2 ].	epsilon := temp.	^ epsilon! !!NSNiceLinearTicksGenerator methodsFor: 'private'!flooredMod: a n: num	^ a - (num * (a / num) floor)! !!NSNiceLinearTicksGenerator methodsFor: 'initialization'!initialize	super initialize.	loose := false.	w := #(0.25 0.2 0.5 0.05).	self nice: NSNiceLinearScaleStepSizeGenerator new! !!NSNiceLinearTicksGenerator methodsFor: 'private'!legibility: min max: max step: step	^ 1! !!NSNiceLinearTicksGenerator methodsFor: 'public'!nice: aNiceGenerator	nice := aNiceGenerator! !!NSNiceLinearTicksGenerator methodsFor: 'public'!searchMin: dmin max: dmax desired: desiredNumberOfTicks	| best sm dm cm delta bestScore k |	best := RSNiceLinearScaleResult new.	bestScore := -2.	desiredNumberOfTicks <= 0 ifTrue: [ self error: 'The minimun value of desiredNumberOfTicks is 1' ].	"In case of a particular situation"	(dmin = 0 and: [ dmax = 0 ]) ifTrue: [		best			min: 0;			max: 1;			step: 1;			score: bestScore.		^ best ].	[ :break |		[ true ] whileTrue: [			n := nice next.			sm := self simplicityMax.			((self w: sm c: 1 d: 1 l: 1) < bestScore)				ifTrue: [ break value ].			k := 2.			[ :break2 |				[ true ] whileTrue: [ | z |					dm := [ self densityMax: k m: desiredNumberOfTicks ] on: ZeroDivide do: [ :ex | self error: 'Please increase the value of desiredNumberOfTicks/labels' ].					((self w: sm c: 1 d: dm l: 1) < bestScore)						ifTrue: [ break2 value ].					delta := (dmax - dmin)/(k+1)/ n j/ (nice qat: n i).					z := (nice logB: delta) ceiling.					[ :break3|						[ true ] whileTrue: [							[ :continue | | minStart maxStart step |								step := n j * (nice qat: n i) * (nice base raisedTo: z).								cm := self coverageMin: dmin max: dmax span: step * (k-1).								((self w: sm c: cm d: dm l: 1) < bestScore)									ifTrue: [ break3 value ].								minStart := ((dmax / step) floor - (k-1)) * n j.								maxStart := (dmin / step) ceiling * n j.								(minStart > maxStart) ifTrue: [									z := z +1.									continue value. ].								(minStart to: maxStart) do: [ :start |									| lmin lmax lstep c s d l score |									lmin := start * step / n j.									lmax := lmin + (step * (k -1)).									lstep := step.									c := self coverageMin: dmin max: dmax lmin: lmin lmax: lmax.									s := self simplicity: lmin max: lmax step: lstep.									d := self density: k m: desiredNumberOfTicks dmin: dmin dmax: dmax lmin: lmin lmax: lmax.									l := self legibility: lmin max: lmax step: lstep.									score := self w: s c: c d: d l: l.									((score > bestScore) and:									[ loose not or: [ (lmin <= dmin) and:														  [ lmax >= dmax ] ] ]) ifTrue: [										best											min: lmin;											max: lmax;											step: lstep;											score: score.											bestScore := score.									 ].								].								z := z +1.							] valueWithExit.						].					] valueWithExit.					k := k +1.				].			] valueWithExit.		 ]	] valueWithExit.	nice reset.	^ best! !!NSNiceLinearTicksGenerator methodsFor: 'public'!setLooseFlag: aBool	"Configuration to 'loose' labelings.	The extreme labels can be placement both inside(setLooseFlag: false) and outside (setLooseFlag: true) of the range of the data.	Example	.=.=.=.=.=.=.=.=.=.=.=.=.=.=.=.=.=	lg setLooseFlag: true.	label := lg searchMin: -98.0 max: 18.0 desired: 3.	self assert: label asString = '(Score: 0.14) -100.00	-60.00	-20.00	20.00	'.	lg setLooseFlag: false.	label := lg searchMin: -98.0 max: 18.0 desired: 3.	self assert: label asString = '(Score: 0.62) -100.00	-50.00	0.00	'.	.=.=.=.=.=.=.=.=.=.=.=.=.=.=.=.=.=	"	loose := aBool.	nice reset! !!NSNiceLinearTicksGenerator methodsFor: 'private'!simplicity: min max: max step: step	(nice qvar size > 1) ifTrue: [		^ 1 - (n i/ (nice qvar size - 1)) - n j + (self vMin: min max: max step: step) ].	^ 1 - n j + (self vMin: min max: max step: step)! !!NSNiceLinearTicksGenerator methodsFor: 'private'!simplicityMax	(nice qvar size > 1) ifTrue: [ ^ 1 - ((n i )/(nice qvar size -1)) - n j + 1.0 ].	 ^ 1 - n j + 1.0! !!NSNiceLinearTicksGenerator methodsFor: 'private'!vMin: min max: max step: step	^ ((self flooredMod: min n: step) < (self epsilon)	and: [ min <= 0 and: [ max >= 0 ] ]) ifTrue: [ 1 ] ifFalse: [ 0 ]! !!NSNiceLinearTicksGenerator methodsFor: 'private'!w: s c: c d: d l: l	^ (w first * s) + (w second * c) + (w third * d) + (w fourth * l)! !!RSNiceLinearScaleResult methodsFor: 'initialization'!initialize	super initialize.	score := 0! !!RSNiceLinearScaleResult methodsFor: 'accessing'!max	^ max! !!RSNiceLinearScaleResult methodsFor: 'accessing'!max: aNumber	max := aNumber! !!RSNiceLinearScaleResult methodsFor: 'accessing'!min	^ min! !!RSNiceLinearScaleResult methodsFor: 'accessing'!min: aNumber	min := aNumber! !!RSNiceLinearScaleResult methodsFor: 'accessing'!numberOfTicks	^ self ticks / step! !!RSNiceLinearScaleResult methodsFor: 'printing'!printOn: aStream	| x |	aStream		nextPutAll: '(Score: ';		nextPutAll: (score printShowingDecimalPlaces: 2);		nextPutAll: ') '.	x := min.	[x <= max ] whileTrue: [		aStream nextPutAll: (x printShowingDecimalPlaces: 2).		aStream nextPutAll: String tab.		x := x + step ]! !!RSNiceLinearScaleResult methodsFor: 'accessing'!score	^ score! !!RSNiceLinearScaleResult methodsFor: 'accessing'!score: aNumber	score := aNumber! !!RSNiceLinearScaleResult methodsFor: 'accessing'!step	^ step! !!RSNiceLinearScaleResult methodsFor: 'accessing'!step: aNumber	step := aNumber! !!RSNiceLinearScaleResult methodsFor: 'accessing'!ticks	^  min < 0 ifTrue: [		 max < 0			ifTrue: [ (max - min) abs ]			ifFalse: [ max + min abs  ]	] ifFalse: [ max - min ]! !!Number methodsFor: '*NumericInterpolator' prior: 52150529!to: upperBound count: count	"Answer an Interval from the receiver up to the argument, stop,	incrementing by step."	| answer |	count = 1 ifTrue: [ ^ Array with: self ].	answer := self to: upperBound by: (upperBound - self) / (count - 1).	"We need to do a bit of fiddling because of the float precision"	^ answer size = count			ifTrue: [ answer ]			ifFalse: [ answer asArray, { upperBound } ]! !!NSInterpolator class methodsFor: 'interpolation' prior: 51980243!interpolate: a and: b	| clazz |	clazz := self interpolatorFor: b.	^ clazz new start: a; stop: b! !!GradientPaint methodsFor: '*NumericInterpolator' prior: 27850101!interpolateTo: anObject at: t	| otherRamp ramp newRamp |	otherRamp := anObject isColor		ifTrue: [ colorRamp collect: [ :a | anObject ] ]		ifFalse: [ anObject colorRamp ].	ramp := self colorRamp.	ramp size = otherRamp size ifFalse: [ self error: 'invalid sizes for color ramp' ].	newRamp := self colorRamp collectWithIndex: [ :a :i | | a2 |		a2 := otherRamp at: i.		a key -> (a value interpolateTo: a2 value at: t) ].	^ self copy		colorRamp: newRamp! !!NSPolylinearScale methodsFor: 'private' prior: 52007274!findJ: x	| lo hi mid |	lo := 2.	hi := k.	[ lo < hi ] whileTrue: [		mid := ((lo + hi) / 2) asInteger.		(domain at: mid) > x			ifTrue: [ hi := mid ]			ifFalse: [ lo := mid + 1 ] ].	^ lo - 1! !!NSPolylinearScale methodsFor: 'hooks' prior: 52006669!rescale	| obj |	u := OrderedCollection new.	i := OrderedCollection new.	k := domain size min: range size.	obj := domain at: k.	((obj class canUnderstand: #<) and: [obj < domain first]) ifTrue: [		domain := domain reverse.		range := range reverse ].	2 to: k do: [ :j |		u add: (uninterpolate uninterpolate: (domain at: j -1 ) and: (domain at: j)).		i add: (interpolate interpolate: (range at: j -1) and: (range at: j) )		 ]! !!NSPolylinearScale methodsFor: 'transformation' prior: 52006521!scale: x	| j |	j := self findJ: x.	^ (i at: j) interpolate: ((u at: j) uninterpolate: x)! !!NSRoundInterpolator class methodsFor: 'interpolation' prior: 52011683!interpolate: a and: b	^ self new start: a; stop: b! !!NSLinearScale methodsFor: 'initialization' prior: 51981430!initialize	super initialize.	range := domain := #(0 1).	clamp := false.	interpolate := NSInterpolator.	self rescale! !!NSLinearScale methodsFor: 'accessing' prior: 51981902!interpolate: x	interpolate := x.	self rescale! !!NSLinearScale methodsFor: 'transformation' prior: 51981680!invert: y	^ input scale: y! !!NSLinearScale methodsFor: 'accessing'!niceTicks: numberOfTicks	| generator niceLabel |	domain min = domain max ifTrue: [ ^ self ticks: numberOfTicks ].	numberOfTicks < 2 ifTrue: [ ^ self ticks: numberOfTicks ].	generator := NSNiceLinearTicksGenerator new setLooseFlag: true.	niceLabel := generator searchMin: domain min max: domain max desired: numberOfTicks.	^ niceLabel min to: niceLabel max by: niceLabel step! !!NSLinearScale methodsFor: 'accessing' prior: 51982705!range: r	super range: r.	self rescale! !!NSLinearScale methodsFor: 'accessing' prior: 51981763!rangeRound: x	"x is a range"	self		range: x;		interpolate: NSRoundInterpolator! !!NSLinearScale methodsFor: 'hooks' prior: 51982001!rescale	| linear |	linear := (domain size min: range size ) > 2		ifTrue: [ NSPolylinearScale ]		ifFalse: [ NSBilinearScale ].	uninterpolate := clamp		ifTrue: [ NSUninterpolateClamp ]		ifFalse: [ NSUninterpolateNumber ].	output := linear new domain: domain; range: range;		uninterpolate: uninterpolate; interpolate: interpolate.	output rescale.	input := linear new domain: range; range: domain;		uninterpolate: uninterpolate; interpolate: NSInterpolator.	input rescale! !!NSPowPowScale class methodsFor: 'instance creation' prior: 52008699!exponent: exponent	^ self new		exponent: exponent;		yourself! !!NSOrdinalScale methodsFor: 'accessing' prior: 51991765!dictionary	^ dictionary! !!NSOrdinalScale methodsFor: 'accessing' prior: 51995195!domain: arr	domain := OrderedCollection new.	dictionary := Dictionary new.	arr do: [ :xi |		dictionary at: xi ifAbsentPut: [			domain add: xi.			domain size ] ].	self perform: ranger withArguments: argument! !!NSOrdinalScale methodsFor: 'initialization' prior: 51991852!initialize	super initialize.	ranger := #range:.	argument := #( #() ).	self domain: #()! !!NSOrdinalScale methodsFor: 'transformation' prior: 51992008!invert: anObject	^ self linearScale invert: anObject! !!NSOrdinalScale methodsFor: 'transformation'!linearScale	^ NSScale linear		domain: { domain first. domain last };		range: { range first.  range last };		yourself! !!NSOrdinalScale methodsFor: 'accessing' prior: 51995615!range: x	range := x.	rangeBand := 0.	ranger := #range:.	argument := Array with: x! !!NSOrdinalScale methodsFor: 'public' prior: 51990025!rangeBands: x padding: padding outerPadding: outerPadding	| start stop step reverse |	start := x first.	stop := x second.	reverse := false.	start > stop ifTrue: [| t |		t := start. start := stop. stop := t.		reverse := true. ].	step := (stop - start) / (domain size - padding + (2*outerPadding)).	range := self		steps: start + (step * outerPadding)		and: step.	reverse ifTrue: [ range := range reverse ].	rangeBand := step * (1 - padding).	range doWithIndex: [ :val :in | range at: in put: val + (rangeBand / 2.0) ].	ranger := #rangeBands:padding:outerPadding:.	argument := Array with: x with: padding with: outerPadding! !!NSOrdinalScale methodsFor: 'public' prior: 51992892!rangePoints: x padding: padding	| start stop step |	start := x first.	stop := x second.	step := domain size < 2		ifTrue: [ start := (start  + stop)/2. 0 ]		ifFalse: [ (stop - start)/(domain size - 1 + padding) ].	range := self		steps: start + (step * padding / 2)		and: step.	rangeBand := 0.	ranger := #rangePoints:padding:.	argument := Array with: x with: padding! !!NSOrdinalScale methodsFor: 'public' prior: 51992205!rangeRoundBands: x padding: padding outerPadding: outerPadding	| start stop step reverse |	start := x first.	stop := x second.	reverse := false.	start > stop ifTrue: [| t |		t := start. start := stop. stop := t.		reverse := true. ].	step := ((stop - start) / (domain size - padding + (2*outerPadding))) floor.	range := self		steps: start + ( (stop - start - ((domain size - padding) * step) ) / 2 ) rounded		and: step.	reverse ifTrue: [ range := range reverse ].	rangeBand := (step * (1 - padding)) rounded.	ranger := #rangeRoundBands:padding:outerPadding:.	argument := Array with: x with: padding with: outerPadding! !!NSOrdinalScale methodsFor: 'public' prior: 51993737!rangeRoundPoints: x padding: padding	| start stop step |	start := x first.	stop := x second.	step := domain size < 2		ifTrue: [ start := stop := ((start + stop)/2) rounded. 0 ]		ifFalse: [[ (stop - start)/(domain size -1 + padding)]			on: Error do: [ :ex | 0 ] ].	range := self		steps: start + ((step * padding / 2) + (stop - start -			((domain size - 1 + padding)* step) )/ 2) rounded		and: step.	rangeBand := 0.	ranger := #rangeRoundPoints:padding:.	argument := Array with: x with: padding! !!NSOrdinalScale methodsFor: 'transformation' prior: 51991110!scale: x	| index |	index := dictionary at: x ifAbsent: [ nil ].	(index isNil and: [ ranger = #range:]) ifTrue: [		domain add: x.		dictionary at: x put: (index := domain size) ].	index ifNil: [ ^ self linearScale scale: x ].	index := index % range size.	index isZero		ifTrue: [ index := range size ].	(x isNumber and: (ranger = #rangeBands:padding:outerPadding:)) ifTrue: [		^ NSScale linear		domain: {domain first. domain last};		range: {range first. range last};		scale: x		 ].	^ range at: index! !!NSAbstractInterpolator class methodsFor: 'testing' prior: 51971907!isAbstract	^ self == NSAbstractInterpolator! !!Random methodsFor: '*NumericInterpolator' prior: 59592937!rsNext: limit	^ self rsNext: 0 and: limit! !!Random methodsFor: '*NumericInterpolator' prior: 59592811!rsNext: u and: v	^ NSScale linear range: {u. v}; scale: self next! !!NSUninterpolate class methodsFor: 'interpolating' prior: 52024368!uninterpolate: aNum1 and: aNum2	^ self new uninterpolate: aNum1 and: aNum2! !!NSUninterpolate methodsFor: 'accessing' prior: 52023818!uninterpolate: aNum1 and: aNum2	a := aNum1.	b := aNum2.	(a isPoint or: [ b isPoint ]) ifTrue: [		| b2 |		a := a asPoint.		b2 := b := b asPoint.		b := b - a.		b := (self stopValue: b x stop: b2 x ) @ b y.		b := b x @ (self stopValue: b y stop: b2 y).		^ self  ].	a isNumber		ifFalse: [ ^ a := b := Float nan. ].	b  := b - a.	b := self stopValue: b stop: aNum2! !!NSColorRGBAInterpolator class methodsFor: 'color categories' prior: 51975871!category10	^ self colorHex: #(2062260 16744206 2924588 14034728 9725885 9197131 14907330 8355711 12369186 1556175)! !!NSColorRGBAInterpolator class methodsFor: 'color categories' prior: 51977307!category20	^ self colorHex: #(2062260 11454440 16744206 16759672 2924588 10018698 14034728 16750742 9725885 12955861 9197131 12885140 14907330 16234194 8355711 13092807 12369186 14408589 1556175 10410725)! !!NSColorRGBAInterpolator class methodsFor: 'color categories' prior: 51976426!category20b	^ self colorHex: #(3750777 5395619 7040719 10264286 6519097 9216594 11915115 13556636 9202993 12426809 15186514 15190932 8666169 11356490 14049643 15177372 8077683 10834324 13528509 14589654)! !!NSColorRGBAInterpolator class methodsFor: 'color categories' prior: 51976810!category20c	^ self colorHex: #(3244733 7057110 10406625 13032431 15095053 16616764 16625259 16634018 3253076 7652470 10607003 13101504 7695281 10394312 12369372 14342891 6513507 9868950 12434877 14277081)! !!NSColorRGBAInterpolator class methodsFor: 'helpers' prior: 51976194!colorHex: arr	^ arr collect: [ :value | Color colorFrom: (		(self hex: value >> 16),		(self hex: value >> 8 & 255),		(self hex: value & 255))		 ]! !!NSColorRGBAInterpolator class methodsFor: 'color categories' prior: 51977592!eva10	^ #('A57DBF' '562A65' 'A1DC5C' '46705C' 'B5A7DD' 'F1C123' 'C9783E' '605EA9' '730D0B' '5B5C65')		collect: [ :s | Color colorFrom: s ]! !!NSLnScale methodsFor: 'transformation' prior: 51985992!invert: x	^ (linear invert: x) exp! !!NSLnScale methodsFor: 'accessing' prior: 51986374!range: x	range := x.	linear range: x! !!NSLogScale methodsFor: 'accessing' prior: 51987671!base: number	base := number.	linear domain: (domain collect: [:n | self lg: n ])! !!NSLogScale methodsFor: 'accessing' prior: 51988080!domain: arr	positive := arr first >= 0.	domain := arr.	linear domain: (arr collect: [:n | self lg: n])! !!NSLogScale methodsFor: 'initialization' prior: 51987109!initialize	super initialize.	linear := self class linear.	base := 10.	positive := true.	domain := #(1 0)! !!NSLogScale methodsFor: 'transformation' prior: 51987276!invert: x	^ self pow: (linear invert: x)! !!NSLogScale methodsFor: 'math functions' prior: 51987464!lg: x	"logarithm"	^ (positive		ifTrue: [ (x max: 0) ln ]		ifFalse: [ (x > 0			ifTrue: [ 0 ]			ifFalse: [ 0 - x ] ) ln negated ])		/ (base ln)! !!NSLogScale methodsFor: 'math functions' prior: 51986628!pow: x	^ positive		ifTrue: [ base raisedTo: x ]		ifFalse: [ (base raisedTo: x negated) negated ]! !!NSLogScale methodsFor: 'accessing' prior: 51988238!range: x	range := x.	linear range: x! !!NSPowScale methodsFor: 'accessing' prior: 52010050!domain: x	linear domain: ((domain := x) collect: [ :i | powp scale: i ])! !!NSPowScale methodsFor: 'initialization' prior: 52009484!initialize	super initialize.	linear := self class linear.	exponent := 1.	domain := #(0 1).	powp := NSPowPowScale exponent: exponent.	powb := NSPowPowScale exponent: 1 / exponent! !!NSPowScale methodsFor: 'initialization' prior: 52010181!range: x	range := x.	linear range: x! !!NSScale class methodsFor: 'colors' prior: 52017299!fromColorCategory: symbol	^ self ordinal		range: ( symbol value: NSColorRGBAInterpolator);		yourself! !!NSScale class methodsFor: 'instance creation' prior: 52019101!linear	^ NSLinearScale new.! !!NSScale class methodsFor: 'instance creation' prior: 52016684!ordinal"Define an ordinal scale.Example:```Smalltalkc := RSCanvas new.colors := NSScale ordinal range: { Color red translucent . Color yellow translucent . Color blue translucent }.r := Random seed: 42.100 timesRepeat: [	txt := { 'hello' . 'bonjour' . 'Guten Morgen' } atRandom: r.	g := RSGroup new.	g add: (RSBox new width: 130; height: 20; model: txt; color: (colors scale: txt)).	g add: (RSLabel new text: txt).	c add: g asShape.	 ].RSGridLayout new lineItemsCount: 5; on: c shapes.c @ RSCanvasController.c open```"	^ NSOrdinalScale new! !!NSScale class methodsFor: 'instance creation' prior: 52017653!ordinalColored: numberOfBuckets"Define an ordinal scale for colors. It accepts the number of allocated buckets.Example:```Smalltalkc := RSCanvas new.colors := NSScale ordinalColored: 3.r := Random seed: 42.100 timesRepeat: [	txt := { 'hello' . 'bonjour' . 'Guten Morgen' } atRandom: r.	g := RSGroup new.	g add: (RSBox new width: 130; height: 20; model: txt; color: (colors scale: txt)).	g add: (RSLabel new text: txt).	c add: g asShape.	 ].RSGridLayout new lineItemsCount: 5; on: c shapes.c @ RSCanvasController.c open```"	^ self ordinal range: (Color wheel: numberOfBuckets saturation: 0.4 brightness: 1.0)! !!NSScale class methodsFor: 'instance creation' prior: 52018346!sqrt	^ self pow		exponent: 0.5;		yourself! !!NSScale methodsFor: 'accessing' prior: 52015495!from: value	self range: { value. self range last }! !!NSScale methodsFor: 'accessing'!niceTicks: aNumberOfTicks	^ self ticks: aNumberOfTicks! !!NSScale methodsFor: 'accessing' prior: 52016266!range: someValues	"Expect an array of two or more values.This is to what a domain is mapped to.For example:```s := NSScale linear.s range: { 5 . 10 }.s scale: 0.5```Return 7.5Another example:```s := NScale linear	range: { #white . #gray . #red };	domain: { 0 . 1 . 2}.s scale: 1.5.``Return a gray-red color`"	range := someValues! !!NSScale methodsFor: 'transformation'!ticks: anInteger	| rangeForDividing |	rangeForDividing := range first to: range last count: anInteger.	^ rangeForDividing collect: [ :e | self invert: e ]! !!NSSymLogScale methodsFor: 'accessing' prior: 52021996!constant: aNumber	constant := aNumber! !!NSSymLogScale methodsFor: 'accessing' prior: 52022882!domain: arr	domain := arr.	linear domain: (arr collect: [ :i | self transformSymLog: i ])! !!NSSymLogScale methodsFor: 'initialization' prior: 52022358!initialize	super initialize.	self constant: 1.	linear := self class linear! !!NSSymLogScale methodsFor: 'transformation' prior: 52022606!invert: x	^ self transformSymExp: (linear invert: x)! !!NSSymLogScale methodsFor: 'accessing' prior: 52023144!range: x	range := x.	linear range: x! !!NSSymLogScale methodsFor: 'transformation' prior: 52022166!scale: x	^ linear scale: (self transformSymLog: x)! !!NSSymLogScale methodsFor: 'accessing' prior: 52022491!transformSymExp: x	^ x sign *  (x abs exp - 1) * constant! !!NSNumberInterpolator methodsFor: 'interpolation' prior: 51989856!interpolate: t	^ (start * (1 - t)) + (stop * t)! !NSScale removeSelector: #rescale!"NumericInterpolator"!!NSPerlinNoise2 methodsFor: 'public' prior: 52003071!noise: xin y: yin z: zin	"(NSPerlinNoise2 new noise: 3.14 y: 42 z: 7) >>> 0.13691995878400012"	| x0 y0 z0 x y z u v w a aa ab b ba bb |	x0 := xin floor & 255.	y0 := yin floor & 255.	z0 := zin floor & 255.	x := xin - xin floor.	y := yin - yin floor.	z := zin - zin floor.	u := self fade: x.	v := self fade: y.	w := self fade: z.	a := (p at: x0)+y0.	aa := (p at: a)+z0.	ab := (p at: a+1)+z0.	b := (p at: x0+1)+y0.	ba := (p at: b) + z0.	bb := (p at: b+1) + z0.	"result will cover the range [-1,1]"	^ self lerp: w		a: (self lerp: v			a: (self lerp: u				a: (self grad: (p at: aa) x: x 	y: y z: z)				b: (self grad: (p at: ba) x: x-1	y: y z: z) )			b: (self lerp: u				a: (self grad: (p at: ab) x: x 	y: y-1 z: z)				b: (self grad: (p at: bb) x: x-1	y: y-1 z: z) ) )		b: (self lerp: v			a: (self lerp: u				a: (self grad: (p at: aa+1) x: x 	y: y z: z-1)				b: (self grad: (p at: ba+1) x: x-1	y: y z: z-1) )			b: (self lerp: u				a: (self grad: (p at: ab+1) x: x 	y: y-1 z: z-1)				b: (self grad: (p at: bb+1) x: x-1	y: y-1 z: z-1) ) )! !!NSPerlinNoise3 methodsFor: 'public' prior: 52005320!grad2d: i x: x y: y	| v |	v := (i &1) = 0		ifTrue: [ x ]		ifFalse: [ y ].	^ (i & 2) = 0 ifTrue: [ v negated ] ifFalse: [ v ]! !!NSPerlinNoise3 methodsFor: 'initialization' prior: 52005091!initialize	| r |	super initialize.	fallOff := 0.5.	self octaves: 1.	r := Random new.	p := Dictionary new.	0 to: 511 do: [ :i |		p at: i put: (r next * 256) asInteger ]! !!NSPerlinNoise3 methodsFor: 'public' prior: 52005593!noise2d: xin and: yin	| x1 y1 x y fx fy p0 p1 |	x1 := xin floor & 255.	y1 := yin floor & 255.	x := xin - xin floor.	y := yin - yin floor.	fx := (3- (2 * x)) * x * x.	fy := (3 -(2 * y)) * y * y.	p0 := (p at: x1) + y1.	p1 := (p at: x1 + 1)+ y1.	^ self lerp: fy		a: (self lerp: fx			a: (self grad2d: (p at: p0) x: x y: y)			b: (self grad2d: (p at: p1) x: x -1 y: y))		b: (self lerp: fx			a: (self grad2d: (p at: p0+1) x: x y: y-1)			b: (self grad2d: (p at: p1+1) x: x -1 y: y-1))! !!NSPerlinNoise3 methodsFor: 'public' prior: 52004745!noise: xin and: yin	| e k s |	e := 1.	k := 1.	s := 0.	1 to: octaves do: [ :i |		e := e * fallOff.		s := s + (e * (1 + (self noise2d: k * xin and: k * yin)/2) ).		k := k * 2 ].	^ s! !!NSPerlinNoise methodsFor: 'initialization' prior: 51999858!initialize	| p |	super initialize.	grad3 := #(		#(1 1 0)		#(-1 1 0)		#(1 -1 0)		#(-1 -1 0)		#(1 0 1)		#(-1 0 1)		#(1 0 -1)		#(-1 0 -1)		#(0 1 1)		#(0 -1 1)		#(0 1 -1)		#(0 -1 -1)).	p := #(151 160 137 91 90 15 131 13 201 95 96 53 194 233 7 225 140 36 103 30 69 142 8 99 37 240 21 10 23 190 6 148 247 120 234 75 0 26 197 62 94 252 219 203 117 35 11 32 57 177 33 88 237 149 56 87 174 20 125 136 171 168 68 175 74 165 71 134 139 48 27 166 77 146 158 231 83 111 229 122 60 211 133 230 220 105 92 41 55 46 245 40 244 102 143 54 65 25 63 161 1 216 80 73 209 76 132 187 208 89 18 169 200 196 135 130 116 188 159 86 164 100 109 198 173 186 3 64 52 217 226 250 124 123 5 202 38 147 118 126 255 82 85 212 207 206 59 227 47 16 58 17 182 189 28 42 223 183 170 213 119 248 152 2 44 154 163 70 221 153 101 155 167 43 172 9 129 22 39 253 19 98 108 110 79 113 224 232 178 185 112 104 218 246 97 228 251 34 242 193 238 210 144 12 191 179 162 241 81 51 145 235 249 14 239 107 49 192 214 31 181 199 106 157 184 84 204 176 115 121 50 45 127 4 150 254 138 236 205 93 222 114 67 29 24 72 243 141 128 195 78 66 215 61 156 180).	perm := Array new: 512.	1 to: 256 do: [ :i | | v |		v := p at: i.		perm at: i put: v.		perm at: i + 256 put: v ]! !!NSPerlinNoise methodsFor: 'public' prior: 51998474!noise: xin and: yin	"all this proces explained in http://webstaff.itn.liu.se/~stegu/simplexnoise/simplexnoise.pdf"	| f2 s i j g2 t xzero yzero x0 y0 i1 j1 x1 y1 x2 y2 ii jj gi0 gi1 gi2 t0 n0 t1 n1 t2 n2 |	f2 := 0.5 * (3 sqrt - 1).	s := (xin + yin) * f2.	i := (xin + s) floor.	j := (yin + s) floor.	g2 := (3 - 3 sqrt) / 6.	t := (i + j) * g2.	xzero := i - t.	yzero := j - t.	x0 := xin - xzero.	y0 := yin - yzero.	x0 > y0 ifTrue: [		i1 := 1.		j1 := 0 ]		ifFalse: [		i1 := 0.		j1 := 1 ].	x1 := x0 - i1 + g2.	y1 := y0 - j1 + g2.	x2 := x0 - 1 + (2* g2).	y2 := y0 - 1 + (2* g2).	ii := i & 255.	jj := j & 255.	gi0 := (self permAt: ii + (self permAt: jj)) % 12.	gi1 := (self permAt: ii + i1 + (self permAt: jj + j1)) % 12.	gi2 := (self permAt: ii + 1 + (self permAt: jj + 1) ) % 12.	t0 := 0.5 - (x0 * x0) - (y0 * y0).	t0 < 0 ifTrue: [ n0 := 0 ] ifFalse: [		t0 := t0 * t0.		n0 := t0 * t0 * (self dot: (self grad3At: gi0) and: x0 and: y0 ) ].	t1 := 0.5 - (x1*x1) - (y1 * y1).	t1 < 0 ifTrue: [ n1 := 0 ] ifFalse: [		t1 := t1 * t1.		n1 := t1 * t1 * (self dot: (self grad3At: gi1) and: x1 and: y1 ) ].	t2 := 0.5 - (x2 * x2) - (y2 * y2).	t2 < 0 ifTrue: [ n2 := 0 ] ifFalse: [		t2 := t2 * t2.		n2 := t2 * t2 * (self dot: (self grad3At: gi2) and: x2 and: y2) ].	^ 70.0 * (n0 + n1 + n2)! !"NumericNoise"!!NSClampTest methodsFor: 'tests' prior: 51973077!testBasic01	| x |	x := NSScale linear		domain: { -100. 100 };		range: { 500. 1000 }.	self deny: x clamp.	self assert: x uninterpolate equals: NSUninterpolateNumber.	self assert: (x scale: 0) equals: 750.	self assert: (x scale: 200) equals: 1250.	self assert: (x invert: 1250) equals: 200.	x clamp: true.	self assert: x uninterpolate equals: NSUninterpolateClamp.	self assert: (x scale: 0) equals: 750.	self assert: (x scale: 200) equals: 1000.	self assert: (x invert: 1250) equals: 100! !!NSClampTest methodsFor: 'tests' prior: 51973633!testBasic02	| x |	x := NSScale sqrt		domain: { -100. 100 };		range: { 500. 1000 }.	self deny: x clamp.	self assert: (x scale: 0) equals: 750.	self assert: (x scale: 200) closeTo: 1103.5533905932737.	self assert: (x invert: 1103.5533905932737) closeTo: 200.	x clamp: true.	self assert: (x scale: 0) closeTo: 750.	self assert: (x scale: 200) closeTo: 1000.	self assert: (x invert: 1250) closeTo: 100! !!NSClampTest methodsFor: 'tests' prior: 51972493!testBasic03	| x |	x := NSScale log		domain: { 1. 100 };		range: { 500. 1000 }.	self deny: x clamp.	self assert: x uninterpolate equals: NSUninterpolateNumber.	self assert: (x scale: 1) closeTo: 500.	self assert: (x scale: 200) closeTo: 1075.2574989159953.	self assert: (x invert: 1075.2574989159953) closeTo: 200.	x clamp: true.	self assert: x uninterpolate equals: NSUninterpolateClamp.	self assert: (x scale: 0) closeTo: 500.	self assert: (x scale: 200) closeTo: 1000.	self assert: (x invert: 1250) closeTo: 100! !!NSPowScaleTest methodsFor: 'test - scales' prior: 52010733!testPowScale	| pow |	pow := NSPowScale new.	self		assert: pow exponent equals: 1;		assert: (pow scale: 5) equals: 5.	pow exponent: 2.	self		assert: (pow scale: 5) equals: 25;		assert: (pow invert: 25) equals: 5;		assert: pow exponent equals: 2.	pow		domain: #(0 100);		range: #(-10 10);		clamp: true.	self		assert: (pow scale: 200) equals: 10;		assert: (pow scale: 99.9) closeTo: 9.960020000000004.	pow interpolate: NSRoundInterpolator.	self		assert: pow interpolate equals: NSRoundInterpolator;		assert: (pow scale: 99.9) equals: 10;		assert: pow range equals: #(-10 10)! !!NSPowScaleTest methodsFor: 'test - scales' prior: 52010373!testSqrt	| sqrt |	sqrt := NSScale sqrt.	self		assert: sqrt class equals: NSPowScale;		assert: sqrt exponent equals: 0.5;		assert: ((sqrt scale: 9) closeTo: 3).	sqrt := NSScale sqrt		domain: #(0 36756666);		range: #(0 220).	self assert: (sqrt scale: 4661900) closeTo: 78.34947695663722! !!NSPowScaleTest methodsFor: 'test - scales'!testTicks	| expectedTicks scale |	scale := NSPowScale new		domain: { 1. 100 };		range: { 0. 1 }.	expectedTicks := (0 to: 1 count: 19) collect: [ :e | scale invert: e ].	self assertCollection: (scale ticks: 19) hasSameElements: expectedTicks.	self assert: (scale ticks: 107) size equals: 107! !!NSLogScaleTest methodsFor: 'test - scales'!testMultiLogScaleInvert	| log |	log := NSLogScale new		       base: Float e;		       domain: (#( 0 5 9 ) collect: #exp);		       range: #( 300 80 0 ).	self assert: ((log invert: 300) closeTo: 0 exp).	self assert: ((log invert: 80) closeTo: 5 exp).	self assert: ((log invert: 0) closeTo: 9 exp)! !!NSLogScaleTest methodsFor: 'test - scales'!testMultiLogScaleScale	| log |	log := NSLogScale new		       base: Float e;		       domain: (#( 0 5 9 ) collect: #exp);		       range: #( 300 80 0 ).	self assert: ((log scale: 0 exp) closeTo: 300).	self assert: ((log scale: 5 exp) closeTo: 80).	self assert: ((log scale: 9 exp) closeTo: 0)! !!NSLogScaleTest methodsFor: 'test - scales'!testTicks	| expectedTicks scale |	scale := NSLogScale new		         domain: { 1. 100 };		         range: { 0. 1 }.	expectedTicks := (0 to: 1 count: 19) collect: [ :e | scale invert: e ].	self assertCollection: (scale ticks: 19) hasSameElements: expectedTicks.	self assert: (scale ticks: 107) size equals: 107! !!NSScaleTest methodsFor: 'tests' prior: 52020317!testAccessors	self assert: NSScale linear class equals: NSLinearScale.	self assert: NSScale log class equals: NSLogScale.	self assert: NSScale sqrt class equals: NSPowScale.	self assert: NSScale pow class equals: NSPowScale.	self assert: NSScale ordinal class equals: NSOrdinalScale! !!NSScaleTest methodsFor: 'tests' prior: 52019566!testAccessorsColors	#(category10 category20 category20b category20c eva10 google20 paired12 sky8)		do: [ :sel| | scale |		scale := NSScale perform: sel.		self assert: scale class equals: NSOrdinalScale.		self assert: scale range class equals: Array.		self assert: scale range first class equals: Color ]! !!NSScaleTest methodsFor: 'test - colors' prior: 52020663!testCategories	| color |	color := NSScale category10.	self assert: color range size equals: 10.	1 to: 10 do: [ :i |		self assert: (color scale: i) class equals: Color ].	1 to: 10 do: [ :i |		self assert: (color scale: i) equals: (color scale: i + 10) ].	color := NSScale category20.	self assert: color range size equals: 20.	0 to: 19 do: [ :i |		self assert: (color scale: i) class equals: Color ].	color := NSScale category20b.	self assert: color range size equals: 20.	color := NSScale category20c.	self assert: color range size equals: 20.	color := NSScale paired12.	self assert: color range size equals: 12! !!NSScaleTest methodsFor: 'test - colors' prior: 52019933!testSetInterpolator	| scale |	scale := NSScale linear		range: { 'white'. 'black' }.	self assert: (scale scale: 0.5) equals: Color gray.	scale interpolate: NSColorHSLAInterpolator.	self assert: (scale scale: 0.5) equals: Color gray.	scale interpolate: NSColorHSVAInterpolator.	self assert: (scale scale: 0.5) equals: Color gray! !!NSSLnScaleTest methodsFor: 'tests' prior: 52011787!testMultiple	| s |	s:= NSLnScale new		domain: {  0. 50. 100 };		range: { 100. 50. 200 }.	self assert: (s scale: 0) closeTo: 100.	self assert: (s scale: 50) closeTo: 50.	self assert: (s scale: 100) closeTo: 200.	self assert: (s scale: -100) closeTo: 100! !!NSSLnScaleTest methodsFor: 'tests'!testTicks	| expectedTicks scale |	scale := NSLnScale new		domain: { 1. 100 };		range: { 0. 1 }.	expectedTicks := (0 to: 1 count: 19) collect: [ :e | scale invert: e ].	self assertCollection: (scale ticks: 19) hasSameElements: expectedTicks.	self assert: (scale ticks: 107) size equals: 107! !!NSDomainAndRangeTest class methodsFor: 'building suites'!testParameters	^ ParametrizedTestMatrix new		  addCase: { (#scale -> NSLinearScale new) };		  addCase: { (#scale -> NSLogScale new) };		  addCase: { (#scale -> NSLnScale new) };		  addCase: { (#scale -> NSSymLogScale new) };		  addCase: { (#scale -> NSPowScale new) };		  yourself! !!NSDomainAndRangeTest methodsFor: 'tests'!scale	^ scale! !!NSDomainAndRangeTest methodsFor: 'tests'!scale: aScale	scale := aScale! !!NSDomainAndRangeTest methodsFor: 'running'!setUp	super setUp.	scale		domain: { 1. 70000 };		range: { 1. 2 }! !!NSDomainAndRangeTest methodsFor: 'tests'!testInvertRange	self assert: scale domain first closeTo: (scale invert: scale range first).	self assert: scale domain second closeTo: (scale invert: scale range second)! !!NSDomainAndRangeTest methodsFor: 'tests'!testScaleDomain	self assert: scale range first closeTo: (scale scale: scale domain first).	self assert: scale range second closeTo: (scale scale: scale domain second)! !!NSLinearScaleTest methodsFor: 'test - scales' prior: 51984846!testSameRange	| sc |	sc := self classToTest new		domain: #(0 100);		range: #(100 100).	self assert: (sc scale: 0) equals: 100.	self assert: (sc scale: 50) equals: 100.	self assert: (sc scale: 100) equals: 100.	self assert: (sc scale: 123123) equals: 100.	sc := NSScale linear		domain: #(0 100);		range: #(0 0).	self assert: (sc scale: 0) equals: 0.	self assert: (sc scale: 50) equals: 0.	self assert: (sc scale: 100) equals: 0.	self assert: (sc scale: 123123) equals: 0! !!NSLinearScaleTest methodsFor: 'test - linear' prior: 51983965!testScaleLinear	| linear |	linear := self classToTest new.	self		assert: linear domain equals: #(0 1);		assert: linear range equals: #(0 1).	linear range: #(1 10).	self		assert: (linear scale: 1) equals: 10;		assert: (linear scale: 0.5) equals: 5.5.	self assert: linear interpolate equals: NSInterpolator.	self assert: linear uninterpolate equals: NSUninterpolateNumber! !!NSLinearScaleTest methodsFor: 'test - linear' prior: 51982924!testScaleLinearInvert	| linear |	linear := self classToTest new		domain: #(-5 5);		range: #(40 50).	self		assert: (linear scale: 0) equals: 45;		assert: (linear scale: 5) equals: 50;		assert: (linear invert: 50) equals: 5;		assert: (linear invert: 40) equals: -5! !!NSLinearScaleTest methodsFor: 'test - linear' prior: 51984416!testScaleLinearRound	| linear |	linear := self classToTest new		domain: #(-5 5);		rangeRound: #(40 50).	self		assert: (linear scale: 0.2) equals: 45;		assert: (linear scale: 5.1) equals: 50;		assert: (linear invert: 50) equals: 5;		assert: (linear invert: 40) equals: -5! !!NSLinearScaleTest methodsFor: 'tests'!testTicks	| expectedTicks scale |	scale := self classToTest new		         domain: { 0. 100 };		         range: { 0. 1 }.	expectedTicks := { 0. 25. 50. 75. 100 }.	self assertCollection: (scale ticks: 5) hasSameElements: expectedTicks.	expectedTicks := { 0. 10. 20. 30. 40. 50. 60. 70. 80. 90. 100 }.	self assertCollection: (scale ticks: 11) hasSameElements: expectedTicks.	self assert: (scale ticks: 107) size equals: 107! !!NSOrdinalScaleTest methodsFor: 'test - scales' prior: 51997579!testOrdinalScale	| ordinal |	ordinal := self classToTest new		domain: #('a' 'b' 'c' 'd' 'e' 'f');		range: #(10 20 30 40 50 60).	self		assert: (ordinal scale: 'a') equals: 10;		assert: (ordinal scale: 'd') equals: 40;		assert: (ordinal scale: 'f') equals: 60! !!NSOrdinalScaleTest methodsFor: 'test - scales' prior: 51995961!testOrdinalScaleRangeBands	| ordinal |	ordinal := self classToTest new		domain: #('a' 'b' 'c' 'd' 'e' 'f');		rangeBands: #(0 960).	self		assert: ordinal rangeBand equals: 160;		assert: (ordinal scale: 'a') equals: 80.0;		assert: (ordinal scale: 'd') equals: 560.0;		assert: (ordinal scale: 'f') equals: 880.0;		assert: ordinal rangeExtent equals: #(0 960)! !!NSOrdinalScaleTest methodsFor: 'test - scales' prior: 51996393!testOrdinalScaleRangePoints	| ordinal |	ordinal := self classToTest new		domain: #('apple' 'orange' 'banana' 'grape');		rangePoints: #(0 960).	self		assert: (ordinal scale: 'apple') equals: 0;		assert: (ordinal scale: 'orange') equals: 320;		assert: (ordinal scale: 'grape') equals: 960;		assert: ordinal rangeExtent equals: #(0 960)! !!NSOrdinalScaleTest methodsFor: 'test - scales' prior: 51996808!testOrdinalScaleRangeRoundBands	| ordinal |	ordinal := self classToTest new		domain: #('a' 'b' 'c' 'd' 'e' 'f');		rangeRoundBands: #(0 960) padding: 0.1.	self		assert: ordinal rangeBand equals: 141;		assert: (ordinal scale: 'a') equals: 17;		assert: (ordinal scale: 'd') equals: 488;		assert: (ordinal scale: 'f') equals: 802;		assert: ordinal rangeExtent equals: #(0 960).	ordinal := NSScale ordinal		domain: #('a' 'b' 'c' 'd' 'e' 'f');		rangeRoundBands: #(0 960).	self		assert: ordinal rangeBand equals: 160;		assert: (ordinal scale: 'a') equals: 0;		assert: (ordinal scale: 'd') equals: 480;		assert: (ordinal scale: 'f') equals: 800;		assert: ordinal rangeExtent equals: #(0 960)! !!NSOrdinalScaleTest methodsFor: 'test - scales' prior: 51997999!testOrdinalScaleRangeRoundPoints	| ordinal |	ordinal := self classToTest new		domain: #(1 2 3 4);		rangeRoundPoints: #(0 100).	self		assert: ordinal rangeBand equals: 0;		assert: (ordinal scale: 1) equals: 0;		assert: (ordinal scale: 2) equals: 33.333333333333333;		assert: (ordinal scale: 4) equals: 100! !!NSPolylinearScaleTest methodsFor: 'test - linear' prior: 52007668!testScalePolyLinear	| linear |	linear := NSScale linear		domain: #(0 0.5 1);		range: #(10 80 10).	self		assert: linear input class equals: NSPolylinearScale;		assert: linear output class equals: NSPolylinearScale;		assert: (linear scale: 0) equals: 10;		assert: (linear scale: 0.5) equals: 80;		assert: (linear scale: 1) equals: 10;		assert: (linear scale: 1.5) equals: -60.	linear := NSScale linear		domain: #(0 0.5 1);		range: #('white' 'black' 'white').	self		assert: (linear scale: 0) equals: Color white;		assert: (linear scale: 0.25) equals: Color gray;		assert: (linear scale: 0.75) equals: Color gray! !!NSSymLogScaleTest methodsFor: 'tests' prior: 52023225!testBasic	| log |	log := NSSymLogScale new		domain: #(0 100);		range: #(50 1150).	self assert: (log scale: 71) closeTo: 1069.330419162588.	self assert: (log scale: 0) closeTo: 50.	self assert: (log invert: 50) closeTo: 0! !!NSSymLogScaleTest methodsFor: 'tests'!testInvert	| scale domain range |	domain := { -5.0 . 500.0 }.	range := { 0. 1 }.	scale := NSSymLogScale new		domain: domain;		range: range;		yourself.	self assert: scale domain first closeTo: (scale invert: scale range first).	self assert: scale domain second closeTo: (scale invert: scale range second)! !!NSSymLogScaleTest methodsFor: 'tests'!testTicks	| expectedTicks scale |	scale := NSSymLogScale new		         domain: { -11. 100 };		         range: { 0. 1 }.	expectedTicks := (0 to: 1 count: 19) collect: [ :e | scale invert: e ].	self assertCollection: (scale ticks: 19) hasSameElements: expectedTicks.	self assert: (scale ticks: 107) size equals: 107! !!NSNiceLinearTicksGeneratorTest methodsFor: 'running'!setUp	| nice |	super setUp.	nice := NSNiceLinearScaleStepSizeGenerator new.	lg := NSNiceLinearTicksGenerator nice: nice! !!NSNiceLinearTicksGeneratorTest methodsFor: 'tests'!testError	self		should: [ lg searchMin: -98.0 max: 18.0 desired: 1 ]		raise: Error		description: 'entry to short'.	self		should: [ lg searchMin: -98.0 max: 18.0 desired: 0 ]		raise: Error		description: 'entry to short'! !!NSNiceLinearTicksGeneratorTest methodsFor: 'tests'!testSearch	| label |	lg setLooseFlag: true.	label := lg searchMin: -98.0 max: 18.0 desired: 3.	self		assert: label asString		equals: '(Score: 0.14) -100.00	-60.00	-20.00	20.00	'.	lg setLooseFlag: false.	label := lg searchMin: -98.0 max: 18.0 desired: 3.	self		assert: label asString		equals: '(Score: 0.62) -100.00	-50.00	0.00	'.	lg setLooseFlag: true.	label := lg searchMin: -1 max: 3.5 desired: 4.	self		assert: label asString		equals: '(Score: 0.54) -1.00	0.00	1.00	2.00	3.00	4.00	'.	lg setLooseFlag: false.	label := lg searchMin: -1 max: 3.5 desired: 4.	self		assert: label asString		equals: '(Score: 0.63) -1.00	0.00	1.00	2.00	3.00	'.	lg setLooseFlag: true.	label := lg searchMin: -1 max: 200 desired: 3.	self		assert: label asString		equals: '(Score: -0.29) -25.00	50.00	125.00	200.00	'.	lg setLooseFlag: false.	label := lg searchMin: -1 max: 200 desired: 3.	self		assert: label asString		equals: '(Score: 1.00) 0.00	100.00	200.00	'.	lg setLooseFlag: true.	label := lg searchMin: 119 max: 178 desired: 3.	self		assert:			(label asString = '(Score: -0.65) 110.00	150.00	190.00	'				or: [ label asString						= '(Score: -0.65) 110.00	130.00	150.00	170.00	190.00	' ]).	lg setLooseFlag: false.	label := lg searchMin: 119 max: 178 desired: 3.	self		assert: label asString		equals: '(Score: 0.48) 120.00	150.00	180.00	'.	lg setLooseFlag: true.	label := lg searchMin: -31 max: 27 desired: 4.	self		assert: label asString		equals: '(Score: 0.07) -40.00	-30.00	-20.00	-10.00	0.00	10.00	20.00	30.00	'.	lg setLooseFlag: false.	label := lg searchMin: -31 max: 27 desired: 3.	self		assert: label asString		equals: '(Score: 0.71) -30.00	0.00	30.00	'.	lg setLooseFlag: true.	label := lg searchMin: -55.45 max: -49.99 desired: 2.	self assert: label asString equals: '(Score: -1.13) -56.00	-48.00	'.	lg setLooseFlag: false.	label := lg searchMin: -55.45 max: -49.99 desired: 3.	self		assert: label asString		equals: '(Score: 0.49) -55.00	-52.50	-50.00	'.	lg setLooseFlag: false.	label := lg searchMin: 0 max: 100 desired: 2.	self assert: label asString equals: '(Score: 1.00) 0.00	100.00	'.	label := lg searchMin: 0 max: 100 desired: 3.	self		assert: label asString		equals: '(Score: 0.95) 0.00	50.00	100.00	'.	label := lg searchMin: 0 max: 100 desired: 4.	self		assert: label asString		equals: '(Score: 0.70) 0.00	50.00	100.00	'.	label := lg searchMin: 0 max: 100 desired: 5.	self		assert: label asString		equals: '(Score: 0.85) 0.00	25.00	50.00	75.00	100.00	'.	label := lg searchMin: 0 max: 100 desired: 6.	self		assert: label asString		equals: '(Score: 0.90) 0.00	20.00	40.00	60.00	80.00	100.00	'.	label := lg searchMin: 0 max: 100 desired: 7.	self		assert: label asString		equals: '(Score: 0.80) 0.00	20.00	40.00	60.00	80.00	100.00	'.	label := lg searchMin: 0 max: 100 desired: 8.	self		assert: label asString		equals:			'(Score: 0.79) 0.00	10.00	20.00	30.00	40.00	50.00	60.00	70.00	80.00	90.00	100.00	'.	label := lg searchMin: 0 max: 100 desired: 9.	self		assert: label asString		equals:			'(Score: 0.88) 0.00	10.00	20.00	30.00	40.00	50.00	60.00	70.00	80.00	90.00	100.00	'.	label := lg searchMin: 0 max: 100 desired: 10.	self		assert: label asString		equals:			'(Score: 0.94) 0.00	10.00	20.00	30.00	40.00	50.00	60.00	70.00	80.00	90.00	100.00	'! !!NSNumberTest methodsFor: 'tests'!testToCount	| c |	c := 1 to: 10 count: 5.	self assert: c size equals: 5! !!NSNumberTest methodsFor: 'tests'!testToCount2	| c |	c := 1 to: 10 count: 2.	self assert: c size equals: 2! !!NSNumberTest methodsFor: 'tests'!testToCount3	| c |	c := 1 to: 10 count: 1.	self assert: c size equals: 1.	self assert: c equals: (Array with: 1)! !!NSNumberTest methodsFor: 'tests'!testToCount4	| c |	c := 0.02 to: 1.0 count: 120.	self assert: c first equals: 0.02.	self assert: c last equals: 1.0.	self assert: c size equals: 120! !"NumericInterpolator-Tests"!!RSCamera commentStamp: '' prior: 58399835!All shapes in Roassal are contained in a `RSCanvas`. The canvas has an infinite 2D dimension. The portion of the canvas that is visible within the window is given by a camera. `RSCamera` describes a camera in Roassal. A camera has a scale and a position. The camera contains a matrix tranformation `AthensAffineTransform`### Responsibility: Identify the portion and the zoom level of a canvas that must be visible. Whenever the canvas is scrolled with the mouse or the key, then the camera is responsible for this.### Collaborators:A `RSCanvas` has a `RSCamera`. ### Variables:- `position` is a point representing coordinates of the canvas on which the viewing window frame will be centered. Position can be changes with the method `#translateBy:` and `#translateTo:`. Both methods accept morph based coordinates.- `scale` defines a magnitude of zooming applied to the canvas and its elements.- `origin` defines system coordinate `RSCoordinates`. By default is `RSCenterMiddleCoordinates` but you can use `RSCamera >> #originMode:` to change it.*Example*:```Smalltalkc := RSCanvas new.1 to: 100 do: [ :i |	| g |	g := RSGroup new.	g add: (RSEllipse new size: 30; color: Color gray lighter).	g add: (RSLabel new text: i).	c add: g asShape ].RSGridLayout on: c shapes.camera := c canvas camera.camera translateBy: 500 @ 50.camera scale: 0.5.c```!!RSCoordinates commentStamp: '' prior: 0!A class to change the system coordinates in `RSCanvas` and `RSCamera`!!RSCenterMiddleCoordinates commentStamp: '' prior: 0!This is the default coordinate system in roassal, it puts the origin in the center(x) middle(y) of the window. that means that `0@0` is there !!RSTopLeftCoordinates commentStamp: '' prior: 0!It uses the center in the top left of the morph window!!RSRNode methodsFor: 'adding' prior: 59084104!add: anObject path: list	self isLeaf ifTrue: [		left := self class new: self contents.		right := self class new: anObject.		height := 2.		contents := nil.	]ifFalse: [ | leastEnlargementChild |		leastEnlargementChild := self leastEnlargementChild: anObject.		list add: (right = leastEnlargementChild) -> leastEnlargementChild.		leastEnlargementChild add: anObject path: list.		height := (left height max: right height) + 1.	].	rectangle := Rectangle merging: {left rectangle. right rectangle}! !!RSRNode methodsFor: 'private' prior: 59095522!balanceZ: z y: y x: x	| a b c |	c := z value.	b := y value.	a := x value.	(y key and: [ x key ]) ifTrue: [		^ self rrrotationZ: c y: b x: a ].	(y key not and: [ x key not ]) ifTrue: [		^ self llrotationZ: c y: b x: a ].	(y key not and: [ x key ]) ifTrue: [		^ self lrrotationZ: c y: b x: a ].	"(y key and: [ x key not ])"	^ self rlrotationZ: c y: b x: a.	"self notYetImplemented."! !!RSRNode methodsFor: 'private' prior: 59092960!checkPath: aCollection	| recomputeHeight |	aCollection size < 3 ifTrue: [ ^ self ].	recomputeHeight := false.	(1 to: aCollection size - 2) reverseDo: [ :index |		| assoc |		assoc := aCollection at: index.		recomputeHeight ifTrue: [			assoc value height: (assoc value left height max: assoc value right height)+1		] ifFalse: [			(assoc value isBalanced) ifFalse: [ | z y x |				z := aCollection at: index.				y := aCollection at: index + 1.				x := aCollection at: index + 2.				recomputeHeight := true.				self balanceZ: z y: y x: x.			]		]	].	"recomputeHeight ifTrue: [ root computeHeight ]"! !!RSRNode methodsFor: 'enumerating' prior: 59091140!do: aBlock	self isLeaf		ifTrue: [ aBlock value: self contents ]		ifFalse: [			self childrenDo: [ :child | child do: aBlock ].			 ]! !!RSRNode methodsFor: 'initialization' prior: 59100072!fromNode: aNode	contents := aNode contents.	left := aNode left.	right := aNode right.	rectangle := aNode rectangle.	height := aNode height! !!RSRNode methodsFor: 'private' prior: 59089096!fromShape: aRSShape	contents := aRSShape.	height := 1.	rectangle := self bbox: aRSShape! !!RSRNode methodsFor: 'accessing' prior: 59084019!height: anInteger	height := anInteger! !!RSRNode methodsFor: 'testing' prior: 59091982!isTotalBalanced	^ self isBalanced		and: [ (left isNil or: [ left isTotalBalanced ])			and: [ right isNil or: [ right isTotalBalanced ] ] ]! !!RSRNode methodsFor: 'private' prior: 59094859!leastEnlargementChild: anRSShape	| minRectangleEnlargement rect leftRect rightRect leftDiff rightDiff area1 area2 |	minRectangleEnlargement := nil.	rect := self bbox: anRSShape.	leftRect := Rectangle merging: {left rectangle. rect }.	rightRect := Rectangle merging: {right rectangle. rect }.	area1 := left rectangle area.	area2 := right rectangle area.	leftDiff := leftRect area - area1.	rightDiff := rightRect area - area2.	^ rightDiff = leftDiff		ifTrue: [ area1 < area2				ifTrue: [ left ]				ifFalse: [ right ] ]		ifFalse: [			leftDiff < rightDiff				ifTrue: [ left ]				ifFalse: [ right ] ]! !!RSRNode methodsFor: 'accessing' prior: 59086373!left: aRSRNode	left := aRSRNode! !!RSRNode methodsFor: 'private' prior: 59089813!llrotationZ: z y: y x: x	| a3 a4 new |	a3 := y right.	a4 := z right.	new := self class new.	new left: a3; right: a4; computeRectangle.	z left: x; right: new; computeRectangle! !!RSRNode methodsFor: 'private' prior: 59098730!lrrotationZ: z y: y x: x	| a1 a2 a3 new |	a1 := y left.	a2 := x left.	a3 := x right.	new := self class new.	new left: a1; right: a2; computeRectangle.	y left: new; right: a3; computeRectangle.	self llrotationZ: z y: y x: new! !!RSRNode methodsFor: 'finding/searching' prior: 59086463!nodesIntersetcsRectangle: aRectangle list: aCollection	(self rectangle intersects: aRectangle) ifFalse: [ ^ self ].	self isLeaf ifTrue: [ aCollection add: self contents ]	ifFalse: [		self childrenDo: [ :child |			child nodesIntersetcsRectangle: aRectangle list: aCollection			 ] ]! !!RSRNode methodsFor: 'finding/searching' prior: 59087959!nodesWithPoint: aPoint list: aCollection	(self rectangle containsPoint: aPoint)		ifFalse: [ ^ self ].	self isLeaf ifTrue:[		(self contents includesPoint: aPoint)			ifTrue: [ aCollection add: self contents ]	] ifFalse: [		self childrenDo: [ :child | child nodesWithPoint: aPoint list: aCollection ]	]! !!RSRNode methodsFor: 'accessing' prior: 59090898!right: aRSRNode	right := aRSRNode! !!RSRNode methodsFor: 'private' prior: 59085387!rlrotationZ: z y: y x: x	| a1 a2 a3 a4 new |	a1 := z left.	a2 := x left.	a3 := x right.	a4 := y right.	new := self class new.	new left: a3; right: a4; computeRectangle.	y left: a2; right: new; computeRectangle.	self rrrotationZ: z y: y x: new! !!RSRNode methodsFor: 'private' prior: 59099012!rrrotationZ: z y: y x: x	"right right rotation"	| a1 a2 new |	a1 := z left.	a2 := y left.	new := self class new.	new left: a1; right: a2; computeRectangle.	z left: new; right: x; computeRectangle! !!RSRNode methodsFor: 'finding/searching' prior: 59096914!searchPath: shape rectangle: shapeRect in: path dir: aBoolean	(self rectangle containsRect: shapeRect)		ifFalse: [ ^ self ].	self isLeaf ifTrue: [		contents = shape ifTrue: [			path addFirst: aBoolean -> self		] ifFalse: [  ]	] ifFalse: [		left searchPath: shape rectangle: shapeRect in: path dir: false.		path ifNotEmpty: [ path addFirst: aBoolean -> self. ^ self ].		right searchPath: shape rectangle: shapeRect in: path dir: true.		path ifNotEmpty: [ path addFirst: aBoolean -> self. ].	 ]! !!RSMonitorEvents methodsFor: 'public'!onNewEventDo: aBlockClosure for: aSubscriber	| events |	self assert: self target isNotNil description: 'Must provide a target'.	events := self announcementClasses.	events ifNil:  [ events := target announcementClasses ].	events do: [ :evt |		target when: evt do: aBlockClosure for: aSubscriber ]! !!RSMonitorEvents methodsFor: 'public' prior: 58974867!unRegister	target removeInteractionIfPresent: self class! !!RSCamera class methodsFor: 'accessing coordinates'!originCenterMiddle	^ RSCoordinates originCenterMiddle! !!RSCamera class methodsFor: 'accessing coordinates'!originTopLeft	^ RSCoordinates originTopLeft! !!RSCamera methodsFor: 'zoom'!computeScaleFor: anExtent rectangle: rect	| sc |	sc := anExtent / (self class maxExtentFor: rect).	sc := sc x min: sc y.	^ sc! !!RSCamera methodsFor: 'accessing' prior: 58403207!extent	^ extent! !!RSCamera methodsFor: 'convertion' prior: 58401033!fromPixelToSpace: aPoint	^ originMode fromPixelToSpace: aPoint camera: self! !!RSCamera methodsFor: 'convertion' prior: 58402829!fromSpaceToPixel: aPoint	^ originMode fromSpaceToPixel: aPoint camera: self! !!RSCamera methodsFor: 'initialization' prior: 58402489!initialize	super initialize.	matrix := AthensAffineTransform new.	scale := 1.000000.	originMode := RSCoordinates originCenterMiddle.! !!RSCamera methodsFor: 'accessing'!matrix	^ matrix! !!RSCamera methodsFor: 'accessing'!matrix: anAthensAffineTransform	matrix := anAthensAffineTransform! !!RSCamera methodsFor: 'accessing' prior: 58404231!originMode	"#center or #topLeft"	^ originMode! !!RSCamera methodsFor: 'accessing' prior: 58404573!position	"Return the position of the camera. For example:```c := RSCanvas new.c add: (RSEllipse new size: 30).c camera translateBy: 25 @ 15.c camera position```returns the value `25 @ 15`"	^ matrix translation! !!RSCamera methodsFor: 'accessing' prior: 58402714!position: aPoint	"Set the camera position"	matrix translation: aPoint! !!RSCamera methodsFor: 'accessing'!positionFromSpace: aPoint	| morphPosition zeroPosition |	morphPosition := self fromSpaceToPixel: aPoint.	zeroPosition := self fromSpaceToPixel: 0@0.	^ (morphPosition - zeroPosition) negated + (originMode gapToCenter: self)! !!RSCamera methodsFor: 'private'!privateScale: aFloatNumber	| position |	scale := aFloatNumber.	position := matrix translation.	matrix		loadIdentity;		scaleBy: scale;		translation: position! !!RSCamera methodsFor: 'accessing' prior: 58401858!scale: aFloatNumber	"Set the scaling factor applied by the camera. A factor of 1.0 means that no zooming is applied. if the factor is < 1, then the perceived effect is a zoom out. If the factor is > 1, then the effect is a zoom out."	| oldScale |	scale = aFloatNumber ifTrue: [ ^ self ].	oldScale := scale.	"this method will call loadIdentity in camera matrix"	self privateScale: aFloatNumber.	self canvas announce: [ RSScaleChangedEvent new		canvas: self canvas;		oldScale: oldScale;		newScale: aFloatNumber ]! !!RSCamera methodsFor: 'public' prior: 58404328!setMatrix: anAthensAffineTransform	anAthensAffineTransform multiplyBy: (originMode matrixFor: self)! !!RSCamera methodsFor: 'accessing' prior: 58403055!visibleRectangle	^ originMode visibleRectangleFor: self! !!RSCamera methodsFor: 'zoom' prior: 58403429!zoomToFit: anExtent	self		zoomToFit: anExtent		rectangle: canvas encompassingRectangle! !!RSCamera methodsFor: 'zoom' prior: 58403650!zoomToFit: anExtent extent: otherExtent	self		zoomToFit: anExtent		rectangle: (Rectangle floatCenter: 0@0 extent: otherExtent)! !!RSCamera methodsFor: 'zoom' prior: 58403828!zoomToFit: anExtent rectangle: rect	| sc |	sc := (self computeScaleFor: anExtent rectangle: rect).	"we can improve this method"	self scale: sc.	self translateTo: (self positionFromSpace: rect floatCenter)! !!RSCenterMiddleCoordinates methodsFor: 'public'!gapDistance: anRSCamera	^ anRSCamera canvas extent / 2! !!RSCoordinates class methodsFor: 'coordinates'!originCenterMiddle	^ RSCenterMiddleCoordinates new! !!RSCoordinates class methodsFor: 'coordinates'!originTopLeft	^ RSTopLeftCoordinates new! !!RSCoordinates methodsFor: 'public'!fromPixelToSpace: aPoint camera: camera	^ (self matrixFor: camera) inverseTransform: aPoint! !!RSCoordinates methodsFor: 'public'!fromSpaceToPixel: aPoint camera: camera	^ (self matrixFor: camera) transform: aPoint! !!RSCoordinates methodsFor: 'hooks'!gapDistance: anRSCamera	^ 0@0! !!RSCoordinates methodsFor: 'hooks'!gapToCenter: camera	^ 0@0! !!RSCoordinates methodsFor: 'public'!matrixFor: anRSCamera	^ AthensAffineTransform new		translateBy: (self gapDistance: anRSCamera);		multiplyBy: anRSCamera matrix;		yourself! !!RSCoordinates methodsFor: 'public'!visibleRectangleFor: anRSCamera	| rectangle |	"returns the visible rectangle in the canvas space"	rectangle := 0 @ 0 corner: anRSCamera canvas extent.	^ self visibleRectangleFor: anRSCamera rectangle: rectangle! !!RSCoordinates methodsFor: 'public'!visibleRectangleFor: anRSCamera rectangle: aRectangle	| matrix |	"returns the visible rectangle in the canvas space"	matrix := self matrixFor: anRSCamera.	^ Rectangle encompassing: (aRectangle corners collect: [ :point | 			   matrix inverseTransform: point ])! !!RSTopLeftCoordinates class methodsFor: 'hooks'!gapToCenter: camera	^ camera canvas extent / 2! !!RSTopLeftCoordinates class methodsFor: 'public'!matrixFor: anRSCamera	^ anRSCamera matrix! !!RSTopLeftCoordinates methodsFor: 'hooks'!gapToCenter: camera	^ camera canvas extent / 2! !!RSTopLeftCoordinates methodsFor: 'hooks'!matrixFor: anRSCamera	^ anRSCamera matrix! !!RSHost methodsFor: 'accessing'!canvas	^ canvas! !!RSHost methodsFor: 'accessing'!canvas: aRSCanvas	canvas := aRSCanvas! !!RSHost methodsFor: 'accessing'!defaultWindowTitle	^ 'Roassal'! !!RSHost methodsFor: 'opening'!openWithTitle: aTitleAsString	"Open a canvas with a given title"	^ self subclassResponsibility! !!RSHost methodsFor: 'opening'!signalUpdate	"Signal a platform signal that the canvas should be refreshed. This is important when some shapes are modified (color or position)."	self subclassResponsibility! !!RSMorphicHost methodsFor: 'private'!createMorph	"Create a Morph that contains myself. This is a private method"	morph := RSAthensMorph new. 	morph renderer: RSAthensRenderer new.	morph canvas: canvas.	^ morph! !!RSMorphicHost methodsFor: 'accessing'!morph	"Return the Athens morph used by the canvas to render the visualization"	^ morph! !!RSMorphicHost methodsFor: 'accessing'!morph: aMorph	"Set the RSAthensMorph. The canvas will directly render in the morph"	morph := aMorph! !!RSMorphicHost methodsFor: 'accessing'!openWithTitle: aTitleAsString	"Open a canvas with a given title"	| window |	self createMorph.	window := morph openInWindowLabeled: aTitleAsString.	window extent: 500 @ 500.	morph privateOwner: window.	^ window! !!RSMorphicHost methodsFor: 'signalling'!signalUpdate	"Signal a platform signal that the canvas should be refreshed. This is important when some shapes are modified (color or position)."	morph changed! !!RSObject class methodsFor: 'documentation'!addDocumentSection: aBuilder label: label methods: methods	methods ifEmpty: [ ^ self ].	aBuilder newLine.	aBuilder header: [ :builder | builder text: label ] withLevel: 2.	aBuilder unorderedListDuring: [		(methods sorted: #selector ascending) do: [ :each |			aBuilder item: [ 				aBuilder monospace: (String streamContents:[:s | 					s << each methodClass name << '>>#' <<  each selector					] ) ] ] ]! !!RSObject class methodsFor: 'documentation'!buildMicroDownUsing: aBuilder withComment: aString	super buildMicroDownUsing: aBuilder withComment: aString.	self documentSections keysAndValuesDo: [ :label :methods |		self addDocumentSection: aBuilder label: label methods: methods ].! !!RSObject class methodsFor: 'documentation'!documentSections	^ OrderedDictionary newFromPairs: {		'Examples'. self class methods select: [ :each | each selector beginsWith: 'example' ].		}! !!Class methodsFor: '*Roassal3' prior: 19511477!dependentClassesWithOccurences	"Return the list of classes used myself. The result may contains multiple times the same element."	"Morph dependentClassesWithOccurences"	| cll |	cll := OrderedCollection new.	"A class depends on its superclass"	self superclass ifNotNil: [ cll add: self superclass ].	"We unify a class and its metaclass"	(self methods, self classSide methods)		do: [ :m | m literalsDo: [ :l |					"We also check if the method is not an extension"					((((l isVariableBinding					and: [ l value notNil ])					and: [ l value isBehavior ])					and: [ m category notEmpty ] )					and: [ m category first ~= $* ])  ifTrue: [ cll add: l value ] ]  ].	^ cll asArray! !!Class methodsFor: '*Roassal3' prior: 19505322!numberOfVariables	"Return the number of variables"	^ self instVarNames size! !!RSSequenceableCollection methodsFor: 'adding' prior: 59180200!add: newObject	group add: newObject! !!RSSequenceableCollection methodsFor: 'enumerating' prior: 59179641!do: aBlock	group do: aBlock! !!RSSequenceableCollection methodsFor: 'initialization' prior: 59180085!initialize	super initialize.	group := RSGroup new! !!RSSequenceableCollection methodsFor: 'finding/searching' prior: 59180311!shapesAtPoint: position	| result |	group reverseDo: [ :shape |		result := shape shapeWithActionForPosition: position.		result ifNotNil: [ ^ { result }  ].		 ].	^ {  }! !!RSSequenceableCollection methodsFor: 'finding/searching' prior: 59179905!shapesAtRectangle: aRectangle	^ group select: [ :each | each encompassingRectangle intersects: aRectangle ]! !!RPackage methodsFor: '*Roassal3' prior: 57859229!dependentPackages	"	Return the list of packages that I depend on	(RPackageOrganizer default packageNamed: 'Roassal3') dependentPackages	"	^ (self definedClasses flatCollect: #dependentClasses), self extendedClasses collect: #package as: Set! !!RSTContainer methodsFor: 'adding nodes edges' prior: 59280775!add: aShape	self		assert: aShape notNil		description: 'Nil cannot be added to a canvas'.	aShape		addedIn: self;		renderOn: self.	^ aShape! !!RSTContainer methodsFor: 'adding nodes edges' prior: 59281111!addAll: aCollection	"Add a collection of shapes to the canvas. The argument is a collection of shapes."	self assert: [ aCollection isCollection ] description: 'Need to provide a collection as argument'.	self assert: [ aCollection allSatisfy: [ :e | e isKindOf: RSShape ] ] description: 'Need to provide a collection of RSShape'.	"Add each shape"	aCollection do: [ :aShape | self add: aShape ]! !!RSTContainer methodsFor: 'adding' prior: 59282082!addAllShapes: aCollection	self assert: [ aCollection isCollection ] description: 'Need to provide a collection as argument'.	self assert: [ aCollection allSatisfy: [ :e | e isKindOf: RSShape ] ] description: 'Need to provide a collection of RSShape'.	aCollection do: [ :shape | self addShape: shape ]! !!RSTContainer methodsFor: 'accessing' prior: 59285058!allChildren	| allChildren index |	index := 1.	allChildren := OrderedCollection withAll: self shapes.	[ index <= allChildren size ] whileTrue: [		allChildren addAll: ((allChildren at: index) children ifNil: [#()]).		index := index + 1 ].	^ allChildren! !!RSTContainer methodsFor: 'accessing' prior: 59281564!nodes	"Return all the shapes except lines contained in the canvas."	^ self privateNodes		ifNil: [ | res |			self privateNodes: (res := RSGroup new).			res ]! !!RSTContainer methodsFor: 'removing' prior: 59283436!removeEdge: anEdge	self edges remove: anEdge ifAbsent: [  ]! !!RSTContainer methodsFor: 'removing' prior: 59282865!removeNode: aNode	self nodes remove: aNode ifAbsent: [  ]! !!RSTContainer methodsFor: 'accessing' prior: 59282710!shapes	^ self privateShapes		ifNil: [ | res |			self privateShapes: (res := RSGroup new).			res ]! !!RSTAnnounceable methodsFor: 'announcer' prior: 59267984!announcer	^ self privateAnnouncer ifNil: [		| a |		a := Announcer new.		self announcer: a.		a ]! !!RSTAnnounceable methodsFor: 'public' prior: 59267626!click	"Simulate a click.For example:-=-=-=-=-=-=-=-=-=c := RSCanvas new.box := RSBox new size: 40.box when: RSMouseClick do: [ :evt | self inform: 'hello' ].c add: box.box click.c-=-=-=-=-=-=-=-=-="	self announce: (RSMouseClick new		canvas: self canvas;		shape: self;		yourself)! !!RSTAnnounceable methodsFor: 'public' prior: 59268139!executeWithoutAnnouncer: aBlock	| ann |	ann := self privateAnnouncer.	self announcer: nil.	aBlock value.	self announcer: ann! !!RSTAnnounceable methodsFor: 'protocol' prior: 59268900!when: anAnnouncementClass do: aValuable	| subscriberForDeprecation |	aValuable receiver ifNil: [		self error:			'You must specify a subscriber object for this subscription. Please use #when:do:for: method.' ].	subscriberForDeprecation := thisContext sender receiver = aValuable receiver		                            ifTrue: [ 'self' ]		                            ifFalse: [ '`@arg2 receiver' ].	self		deprecated:			'Since there are some block closures (Clean and Constant) without a receiver, the API of announcements was changed to send the subscriber explicitly. 			We are deprecating this method because it was asking for the receiver of the block to use it as the subscriber.'		transformWith: '`@receiver when: `@arg1 do: `@arg2'			->			('`@receiver when: `@arg1 do: `@arg2 for: '			 , subscriberForDeprecation).	self when: anAnnouncementClass do: aValuable for: aValuable receiver! !!RSTAnnounceable methodsFor: 'announcer'!when: event do: aBlock for: aSubscriber	self announcer when: event do: aBlock for: aSubscriber! !!Symbol methodsFor: '*Roassal3' prior: 85423518!rsValue: anObject	^ anObject perform: self! !!SequenceableCollection methodsFor: '*Roassal3' prior: 62057385!reverseSortedAs: aSortBlockOrSymbol	"Answer a SortedCollection whose elements are the elements of the	receiver. The sort order is defined by the argument, aSortBlock."	| aSortedCollection aSortBlock |	aSortedCollection := SortedCollection new: self size.	aSortBlock :=		aSortBlockOrSymbol isSymbol			ifTrue: [ [:a :b | |t1 t2|							t1 := (a perform: aSortBlockOrSymbol).							t2 := (b perform: aSortBlockOrSymbol).							((t1 isKindOf: Boolean) and: [t2 isKindOf: Boolean])								ifTrue: [ t1 ]								ifFalse: [ t1 > t2 ] ] ]			ifFalse: [				(aSortBlockOrSymbol numArgs = 1)					ifTrue: [ [ :v1 :v2 | (aSortBlockOrSymbol value: v1) > (aSortBlockOrSymbol value: v2) ] ]					ifFalse: [ aSortBlockOrSymbol ] ].	aSortedCollection sortBlock: aSortBlock.	aSortedCollection addAll: self.	^ aSortedCollection! !!SequenceableCollection methodsFor: '*Roassal3' prior: 62067094!sortedAs: aSortBlockOrSymbol	"Answer a SortedCollection whose elements are the elements of the	receiver. The sort order is defined by the argument, aSortBlock."	| aSortedCollection aSortBlock |	aSortedCollection := SortedCollection new: self size.	aSortBlock :=		aSortBlockOrSymbol isSymbol			ifTrue: [ [:a :b | |t1 t2|							t1 := (a perform: aSortBlockOrSymbol).							t2 := (b perform: aSortBlockOrSymbol).							((t1 isKindOf: Boolean) and: [t2 isKindOf: Boolean])								ifTrue: [ t1 ]								ifFalse: [ t1 < t2 ] ] ]			ifFalse: [				(aSortBlockOrSymbol numArgs = 1)					ifTrue: [ [ :v1 :v2 | (aSortBlockOrSymbol value: v1) < (aSortBlockOrSymbol value: v2) ] ]					ifFalse: [ aSortBlockOrSymbol ] ].	aSortedCollection sortBlock: aSortBlock.	aSortedCollection addAll: self.	^ aSortedCollection! !!RSShapeCollection methodsFor: 'finding/searching'!shapeAtPoint: aPoint	| result |	result := self shapesAtPoint: aPoint.	result ifEmpty: [ ^ nil ].	^ result anyOne! !!RSShapeCollection methodsFor: 'finding/searching' prior: 59224787!shapesAtPoint: position	^ self subclassResponsibility! !!RSBulkLoadRTreeCollection methodsFor: 'adding' prior: 58396267!bulkLoad: aCollection	aCollection ifEmpty: [ ^ self ].	root := RSRNode new.	root bulkLoad: aCollection from: 1 to: aCollection size! !!RSShape class methodsFor: 'accessing' prior: 59223299!models: someObjects	"Create a RSGroup made of shapes. Each shape has an element of the argument as model."	^ someObjects collect: [ :obj | self model: obj ] as: RSGroup! !!RSShape class methodsFor: 'accessing' prior: 59223526!models: someObjects forEach: twoArgBlock	"Create a RSGroup made of shapes. Each shape has an element of the argument as model. The second argument is used to initialize the shape.	For example:```c := RSCanvas new.classes := RSCircle models: Collection withAllSubclasses forEach: [ :aShape :aClass | aShape size: aClass numberOfMethods ].c addAll: classes.RSFlowLayout on: classes.c @ RSCanvasController```	"	| r |	r := someObjects collect: [ :obj | self model: obj ] as: RSGroup.	r with: someObjects do: [ :aShape :anObject | twoArgBlock value: aShape value: anObject ].	^ r! !!RSShape methodsFor: 'adding' prior: 59212423!accept: aVisitor	self subclassResponsibility! !!RSShape methodsFor: 'private - adding' prior: 59209974!addPendingAnimationsIn: aShapeOrCanvas	| key myAnimations parentAnimations |	key := #todoAnimations.	(self hasProperty: key) ifFalse: [ ^ self ].	myAnimations := self propertyAt: key.	aShapeOrCanvas isShape ifTrue: [		parentAnimations := parent propertyAt: key ifAbsentPut: [ OrderedCollection new ].		parentAnimations addAll: myAnimations.	] ifFalse: [		myAnimations do: [:anime|			aShapeOrCanvas addAnimation: anime ] ].	self removeKey: key! !!RSShape methodsFor: 'private - adding' prior: 59212684!addedIn: aCanvas	"This is a private method"	| evt |	self isFixed		ifTrue: [ aCanvas addFixedShape: self ]		ifFalse: [ aCanvas addBasicShape: self ].	parent ifNotNil: [ self remove ].	parent := aCanvas.	self addPendingAnimationsIn: parent.	evt := RSShapeAddedEvent new shape: self.	aCanvas announce: evt.	self announce: evt! !!RSShape methodsFor: 'announcer' prior: 59215519!announce: anEventOrAnEventClassOrABlock	"Send an event. The event is provided as argument, and may be either an event object, an event class, or a block (taking no argument) that returns an event object. These different way of specifying events addresses some performance concern."	| theEventToSend |	announcer ifNil: [ ^ self ].	theEventToSend := anEventOrAnEventClassOrABlock value asAnnouncement.	theEventToSend canvas: self canvas.	theEventToSend shape: self.	announcer announce: theEventToSend! !!RSShape methodsFor: 'announcer' prior: 59212279!announcementClasses	^ RSShapeEvent withAllSubclasses		reject: [ :subcls| subcls hasSubclasses ]! !!RSShape methodsFor: 'border'!borderWidth: aNumber	border ifNil: [ self withBorder ].	self border width: aNumber! !!RSShape methodsFor: 'accessing - computed' prior: 59213660!canvas	"Return the canvas in which I belong to. Can return nil if the shape is not added to a canvas"	parent ifNil: [ ^ nil ].	^ parent isShape		ifTrue: [ parent canvas ]		ifFalse: [ parent ]! !!RSShape methodsFor: 'accessing' prior: 59217866!color	^ paint! !!RSShape methodsFor: 'accessing' prior: 59214888!color: aColor	"Set the color of the shape.```Smalltalkc := RSCanvas new.c add: (RSBox new size: 50; color: #blue).c``````Smalltalkc := RSCanvas new.c add: (RSBox new size: 50; color: Color blue).c```	"	paint := aColor.	paint isColor ifTrue: [ ^ self ].	paint := Color colorFrom: aColor! !!RSShape methodsFor: 'accessing' prior: 59220867!computeEncompassingRectangleFor: rect matrix: aMatrix	| groupOfPoints |	groupOfPoints := #(topLeft topRight bottomRight bottomLeft)		collect: [ :s | aMatrix transform: (s value: rect) ].	^ Rectangle encompassing: groupOfPoints! !!RSShape methodsFor: 'copying' prior: 59216382!copyWithAnnouncer	"Answer a copy of this shape that shares the same instance of announcer (The default #postCopy cleans it).	This means that interactions and subscription handlers to any RSEvent will be shared between both instances.	This is useful for optimizations. Senders should be careful!!	Example:		base := RSBox new		    size: 100;		    color: Color blue;		    popup;		    draggable.		shapes := (1 to: 20) collect:[:i |		    base copyWithEvents		        model: i;		        yourself.		    ].		c := RSCanvas new.		RSHorizontalLineLayout on: shapes.		c addAll: shapes.		c zoomToFit.	"	^ self copy		announcer: announcer;		yourself! !!RSShape methodsFor: 'accessing' prior: 59211824!encompassingRectangle	^ encompassingRectangle ifNil: [		encompassingRectangle := self computeEncompassingRectangle ]! !!RSShape methodsFor: 'accessing'!fill: aColor	self color: (aColor isNumber ifTrue: [ Color r: aColor g: aColor b: aColor range: 255 ])! !!RSShape methodsFor: 'testing' prior: 59219629!hasBorder	^ border notNil and: [ border width > 0 ]! !!RSShape methodsFor: 'testing' prior: 59222429!hasEventCallback	"Return true if at least one event callback has been added to the shape"	^ announcer notNil and: [ announcer numberOfSubscriptions > 0 ]! !!RSShape methodsFor: 'initialization' prior: 59220396!initialize	super initialize.	paint := Color lightGray.	isFixed := false! !!RSShape methodsFor: 'testing' prior: 59218226!isFixed	^ isFixed! !!RSShape methodsFor: 'copying' prior: 59219075!postCopy	self		parent: nil;		announcer: nil;		resetPath;		resetBBox! !!RSShape methodsFor: 'printing' prior: 59214218!printOn: stream	super printOn: stream.	model ifNil: [ ^ self ].	stream << '('; << model asString; << ')'! !!RSShape methodsFor: 'actions' prior: 59209712!pushBack	"Move the element behind. This method can be called only if the shape is in a canvas"	self assert: [ parent notNil ] description: 'Should add the shape in a canvas first'.	parent pushBack: self! !!RSShape methodsFor: 'actions' prior: 59214699!pushFront	parent pushFront: self! !!RSShape methodsFor: 'actions' prior: 59210704!remove	"Do nothing if the line is not already in a canvas"	self isInACanvas ifFalse: [ ^ self ].	parent removeShape: self! !!RSShape methodsFor: 'initialization' prior: 59214380!resetBBox	encompassingRectangle := nil! !!RSShape methodsFor: 'accessing' prior: 59211546!resetChildren! !!RSShape methodsFor: 'actions' prior: 59213137!setAsFixed	"Per default, a shape is subject to the camera mouvement. If the camera is relocated, shapes appears to be relocated. This behavior can be avoided by sending the message #setAsFixed to a shape, which makes the shape fixed in the canvas. This is useful to define menus.	The message setAsFixed must be send after being added to a canvas"	parent ifNil: [ self error: 'Add first this shape in the canvas' ].	parent setAsFixed: self.	isFixed := true! !!RSShape methodsFor: 'accessing - computed' prior: 59219274!shapeWithAction: eventClass forPosition: position	^ (self hasEventCallback and: [		(self announcer handleEventClass: eventClass)			and: [ self includesPoint: position ] ])			ifTrue: [ self ]			ifFalse: [ nil ]! !!RSShape methodsFor: 'accessing - computed' prior: 59217493!shapeWithActionForPosition: position	^ (self hasEventCallback and: [ self includesPoint: position ] )			ifTrue: [ self ]			ifFalse: [ nil ]! !!RSAbstractRNode methodsFor: 'finding/searching' prior: 58232806!nodesWithPoint: aPoint list: list! !!AthensAffineTransform methodsFor: '*Roassal3' prior: 17405721!asFloatTransform	^ self copy floatValues; yourself! !!AthensAffineTransform methodsFor: '*Roassal3' prior: 17405836!floatValues	"convert all the values to float"	x := x asFloat.	y := y asFloat.	sx := sx asFloat.	sy := sy asFloat.	shx := shx asFloat.	shy := shy asFloat! !!AthensAffineTransform methodsFor: '*Roassal3' prior: 17406063!printOn: stream	stream << 'x: '. x printOn: stream.	stream << ' y: '. y printOn: stream.	stream << ' sx: '. sx printOn: stream.	stream << ' sy: '. sy printOn: stream.	stream << ' shx: '. shx printOn: stream.	stream << ' shy: '. shy printOn: stream! !!RSRNodeVisitor methodsFor: 'visiting' prior: 59101467!visitNode: aNode	block value: aNode.	aNode childrenDo: [ :child | child accept: self ]! !!AthensCairoPathBuilder methodsFor: '*Roassal3' prior: 17545604!arcAround: aCenterPoint radius: aRadius startAngle: aStartAngle endAngle: anEndAngle	self		arcCenterX: aCenterPoint x		centerY: aCenterPoint y		radius: aRadius		startAngle: aStartAngle		endAngle: anEndAngle! !!AthensCairoPathBuilder methodsFor: '*Roassal3' prior: 17547043!arcAround: aCenterPoint radius: aRadius startAngle: aStartAngle endAngle: anEndAngle cw: aBool	aBool ifTrue: [		self		arcNegativeCenterX: aCenterPoint x		centerY: aCenterPoint y		radius: aRadius		startAngle: aStartAngle		endAngle: anEndAngle ]	ifFalse: [ self		arcCenterX: aCenterPoint x		centerY: aCenterPoint y		radius: aRadius		startAngle: aStartAngle		endAngle: anEndAngle ]! !!AthensCairoPathBuilder methodsFor: '*Roassal3' prior: 17542089!arcCos: num	| temp |	temp := num.	num < -1.0 ifTrue: [ temp := -1.0 ].	num > 1.0 ifTrue: [ temp := 1.0 ].	^ temp arcCos! !!AthensCairoPathBuilder methodsFor: '*Roassal3' prior: 17543218!ellipticalArc2: radii xrot: rotationAxis large: largeFlag sweep: sweepFlag to: aPoint	"raddi Point, rotationAxis Number, largeFlag Number, sweepFlag Number, aPoint Point"	"implentation based on the svg specification"	| ep x0 y0 x y dx2 dy2 theta x1 y1 tcos tsin rx ry prx pry px1 py1 d sign coef cx1 cy1 sx2 sy2 cx cy ux uy vx vy n p angleStart angleExtent pi2 |	self flag: 'Not yet for real elliptic arcs'.	pi2 := Float pi * 2.	(radii x = 0 or: [ radii y = 0 ]) ifTrue: [		^ self lineTo: aPoint ].	ep := self getCurrentPoint.	x0 := ep x.	y0 := ep y.	x := aPoint x.	y := aPoint y.	dx2 := (x0 - x)/2.0.	dy2 := (y0 - y)/2.0.	theta := rotationAxis degreesToRadians.	tcos := theta cos.	tsin := theta sin.	x1 := (tcos * dx2) + (tsin * dy2).	y1 := (tsin negated* dx2) + (tcos * dy2).	rx := radii x abs.	ry := radii y abs.	prx := rx * rx.	pry := ry * ry.	px1 := x1 * x1.	py1 := y1 * y1.	d := (px1 / prx) + (py1 / pry).	d > 1 ifTrue: [		rx := rx * d sqrt.		ry := ry * d sqrt.		prx := rx * rx.		pry := ry * ry ].	sign := largeFlag = sweepFlag ifTrue: [ -1 ] ifFalse: [ 1 ].	coef := sign * (( (prx * pry) - (prx * py1) - (pry * px1) )/( (prx * py1) + (pry * px1) ) max: 0) sqrt.	cx1 := coef * rx * y1 / ry.	cy1 := coef * (ry * x1 / rx) negated.	sx2 := (x0 + x)/2.	sy2 := (y0 + y)/2.	cx := sx2 + ((tcos * cx1) - (tsin * cy1)).	cy := sy2 + ((tsin * cx1) + (tcos * cy1)).	ux := (x1 - cx1)/rx.	uy := (y1 - cy1)/ry.	vx := (x1 + cx1) negated /rx.	vy := (y1 + cy1) negated /ry.	"Angle start"	n := ((ux * ux) + (uy * uy)) sqrt.	p := ux.	sign := uy < 0 ifTrue: [ -1 ] ifFalse: [ 1 ].	angleStart := sign * (self arcCos: p / n).	"angle extent"	n := (((ux * ux) + (uy * uy)) * ((vx * vx) + (vy * vy))) sqrt.	p := (ux * vx) + (uy * vy).	sign := ((ux * vy) - (uy * vx)) < 0 ifTrue: [ -1 ] ifFalse: [ 1 ].	angleExtent := sign * (self arcCos: p / n).	(sweepFlag = 0 and: [ angleExtent > 0]) ifTrue: [		angleExtent := angleExtent - pi2.	 ] ifFalse: [ (sweepFlag = 1 and: [ angleExtent < 0 ]) ifTrue: [		angleExtent := angleExtent + pi2.		 ] ].	angleExtent := angleExtent % pi2.	angleStart := angleStart % pi2.	self		arcAround: (cx asFloat)@ (cy asFloat)		radius: rx asFloat		startAngle: angleStart asFloat		endAngle: angleExtent asFloat + angleStart		cw: sweepFlag = 0! !!RSAthensMorph methodsFor: 'session management' prior: 58304160!checkSession	"The mechanism of session is useful in case you have a visualization open, save-and-quit the image, and open the image again.	Naturally, you wish to see the visualization again. The session mechanism makes sure that low-level resources that belongs to Cairo are properly recreated"	session == Smalltalk session ifTrue: [ ^ self ].	surface := nil.	self createSurface.	self sessionChanged! !!RSAthensMorph methodsFor: 'surface management' prior: 58298855!createSurface	surface := AthensCairoSurface extent: self extent asIntegerPoint.	session := Smalltalk session! !!RSAthensMorph methodsFor: 'drawing' prior: 58308700!drawOn: aCanvas	"Draw the whole visualization"	isDrawing ifTrue: [ ^ self ].	isDrawing := true.	[		self checkSession.		self recreateSurfaceIfNecessary.		aCanvas			fillRectangle: self bounds			fillStyle: roassalCanvas color			borderStyle: self borderStyle.		roassalCanvas playAnimations.		self drawShapes.		surface hasBeenFreed			ifTrue: [ self createSurface ].		[ aCanvas			image: surface asForm			at: self bounds origin asIntegerPoint			sourceRect: (0 @ 0 extent: surface extent)			rule: 34 ]		on: Exception		do: [ :ex | ex traceCr ]	] ensure: [ isDrawing := false ]! !!RSAthensMorph methodsFor: 'drawing' prior: 58296869!drawShapes	"The drawing has to be done when a change in the shapes occured or when there is an animation."	surface drawDuring: [ :athensCanvas |		roassalCanvas shouldClearBackground			ifTrue: [ surface clear ].		"We display the elements that are subject to the camera"		renderer canvas: athensCanvas.		roassalCanvas accept: renderer.	]! !!RSAthensMorph methodsFor: 'events - processed' prior: 58311321!eventKeyDown: aMorphicEvent	| trEvent |	trEvent := self eventOfClass: RSKeyDown from: aMorphicEvent.	trEvent		position: (roassalCanvas camera fromPixelToSpace: trEvent position);		keyValue: aMorphicEvent keyValue;		keyName: aMorphicEvent key name. "(self class keyNameFor: aMorphicEvent keyValue)".	trEvent shape announce: trEvent! !!RSAthensMorph methodsFor: 'events - processed' prior: 58299030!eventMouseClick: aMorphicEvent	| trEvent |	trEvent := self		mouseEventOfClass: RSMouseClick		ifLeftButton: RSMouseLeftClick		ifRightButton: RSMouseRightClick		from: aMorphicEvent.	trEvent position: (roassalCanvas camera fromPixelToSpace: trEvent position).	trEvent shape announce: trEvent! !!RSAthensMorph methodsFor: 'events - processed' prior: 58312579!eventMouseDoubleClick: aMorphicEvent	| trEvent |	trEvent := self		mouseEventOfClass: RSMouseDoubleClick		ifLeftButton: RSMouseDoubleLeftClick		ifRightButton: RSMouseDoubleRightClick		from: aMorphicEvent.	trEvent position: (roassalCanvas camera fromPixelToSpace: trEvent position).	trEvent shape announce: trEvent! !!RSAthensMorph methodsFor: 'events - processed' prior: 58301613!eventMouseDragEnd: aMorphicEvent	| trEvent |	trEvent := self eventOfClass: RSMouseDragEnd from: aMorphicEvent.	trEvent shape: shapeBeingPointed.	shapeBeingPointed announce: trEvent.	eventBeginingDragging := nil! !!RSAthensMorph methodsFor: 'events - processed' prior: 58302522!eventMouseDragStart: aMorphicEvent	| trEvent trEventClass |	eventBeginingDragging := aMorphicEvent copy.	trEventClass := RSMouseDragStart.	aMorphicEvent redButtonChanged		ifTrue: [ trEventClass := RSMouseLeftDragStart ].	aMorphicEvent yellowButtonChanged		ifTrue: [ trEventClass := RSMouseRightDragStart ].	aMorphicEvent blueButtonChanged		ifTrue: [ trEventClass := RSMouseMiddleDragStart ].	trEvent := self eventOfClass: trEventClass actionClass: RSMouseDragging from: aMorphicEvent.	shapeBeingPointed := trEvent shape.	shapeBeingPointed announce: trEvent! !!RSAthensMorph methodsFor: 'events - processed' prior: 58299391!eventMouseDragging: aMorphicEvent	| trEvent step |	eventBeginingDragging ifNil: [ ^ self ].	step := aMorphicEvent position - eventBeginingDragging position.	trEvent := self eventOfClass: RSMouseDragging from: aMorphicEvent.	trEvent position: (roassalCanvas camera fromPixelToSpace: trEvent position).	trEvent step: step.	shapeBeingPointed ifNil: [ shapeBeingPointed := trEvent shape ].	"If the element was removed during the drag then cancel the event"	shapeBeingPointed parent ifNil: [		eventBeginingDragging := nil.		shapeBeingPointed := nil.		^ self ].	trEvent shape: shapeBeingPointed.	shapeBeingPointed announce: trEvent.	eventBeginingDragging := aMorphicEvent copy! !!RSAthensMorph methodsFor: 'events - processed' prior: 58297284!eventMouseEnter: aMorphicEvent	| trEvent |	trEvent := self eventOfClass: RSMouseEnter from: aMorphicEvent.	trEvent shape announce: trEvent! !!RSAthensMorph methodsFor: 'events - processed' prior: 58308359!eventMouseLeave: aMorphicEvent	| trEvent |	trEvent := self eventOfClass: RSMouseLeave from: aMorphicEvent.	shapeBeingPointed ifNotNil: [		trEvent shape: shapeBeingPointed].	trEvent shape announce: trEvent! !!RSAthensMorph methodsFor: 'events - processed' prior: 58310323!eventMouseMove: aMorphicEvent	| trEvent |	trEvent := self eventOfClass: RSMouseMove from: aMorphicEvent.	trEvent position: (roassalCanvas camera fromPixelToSpace: trEvent position).	trEvent shape announce: trEvent! !!RSAthensMorph methodsFor: 'events - processed' prior: 58306891!eventMouseUp: aMorphicEvent	| trEvent |	trEvent := self		mouseEventOfClass: RSMouseUp		ifLeftButton: RSMouseUpLeft		ifRightButton: RSMouseUpRight		from: aMorphicEvent.	trEvent position: (roassalCanvas camera fromPixelToSpace: trEvent position).	trEvent shape announce: trEvent! !!RSAthensMorph methodsFor: 'events - processed' prior: 58309358!eventMouseWheel: aMorphicEvent	| trEvent |	trEvent := self eventOfClass: RSMouseWheelEvent from: aMorphicEvent.	trEvent		direction: aMorphicEvent direction;		position: (roassalCanvas camera fromPixelToSpace: trEvent position).	trEvent shape announce: trEvent! !!RSAthensMorph methodsFor: 'events - processed' prior: 58312099!eventOfClass: anEventClass actionClass: anActionClass from: aMorphicEvent	| relativePosition trEvent shape |	relativePosition := self relativePositionFor: aMorphicEvent.	shape := self shapeWithAction: anActionClass forPositionInPixels: relativePosition.	trEvent := anEventClass fromEvent: aMorphicEvent.	trEvent		morph: self;		canvas: roassalCanvas;		shape: shape;		position: relativePosition.	^ trEvent! !!RSAthensMorph methodsFor: 'drawing' prior: 58303535!fullDrawOnAthensCanvas: aCanvas	isDrawing ifTrue: [ ^ self ].	isDrawing := true.	[		self checkSession.		self recreateSurfaceIfNecessary.		aCanvas setPaint: roassalCanvas color.		aCanvas drawShape: (bounds translateBy: bounds origin negated).		roassalCanvas playAnimations.		self drawShapes.		surface hasBeenFreed ifTrue: [ self createSurface ].		aCanvas pathTransform restoreAfter: [			aCanvas pathTransform loadIdentity.			aCanvas paintMode restoreAfter: [				aCanvas					setPaint: surface;					drawShape: (0@0 extent: self extent) ] ] ]	ensure: [		isDrawing := false ]! !!RSAthensMorph methodsFor: 'event handling' prior: 58297486!handleKeyDown: anEvent	super handleKeyDown: anEvent.	self eventKeyDown: anEvent! !!RSAthensMorph methodsFor: 'events - processing' prior: 58300857!handleMouseMove: anEvent	super handleMouseMove: anEvent.	anEvent anyButtonPressed ifFalse: [ self eventMouseMove: anEvent ]! !!RSAthensMorph methodsFor: 'events - processing' prior: 58305046!handleMouseOver: aMorphicEvent	| currentElement rsEvent "ime times" |	self window = SystemWindow topWindow		ifFalse: [ ^ self ].	aMorphicEvent wasHandled		ifTrue: [ ^ self ].	"Do nothing if it was already handled"	self isDragging		ifTrue: [ ^ self ].	"Do nothing if we are dragging"	lastMousePosition = aMorphicEvent position		ifTrue: [ ^ self].		"Do nothing if it is in the same position"	shapeBeingPointed ifNil: [		shapeBeingPointed := self shapeForEvent: aMorphicEvent ].	"time := [currentElement := self shapeForEvent: aMorphicEvent] timeToRun.	times := roassalCanvas propertyAt: #times ifAbsentPut: [ OrderedCollection new ].	times add: time.	times average traceCr."	currentElement := self shapeForEvent: aMorphicEvent.	lastMousePosition := aMorphicEvent position.	currentElement == shapeBeingPointed		ifTrue: [ ^ self ].	rsEvent := self eventOfClass: RSMouseLeave from: aMorphicEvent.	rsEvent shape: shapeBeingPointed.	shapeBeingPointed announce: rsEvent.	shapeBeingPointed := currentElement.	self eventMouseEnter: aMorphicEvent! !!RSAthensMorph methodsFor: 'accessing'!lastMousePosition	^ lastMousePosition! !!RSAthensMorph methodsFor: 'initialization' prior: 58303281!layoutChanged	"react on morph resize"	super layoutChanged.	self checkSession! !!RSAthensMorph methodsFor: 'accessing' prior: 58310851!surface: anAthensCairoSurface	surface := anAthensCairoSurface! !!RSAthensMorph methodsFor: 'testing' prior: 58298367!wantsSteps	^ roassalCanvas hasAnimation! !!RSAthensMorph methodsFor: 'event handling' prior: 58300648!wouldAcceptKeyboardFocusUponTab	"Answer whether the receiver might accept keyboard focus if	tab were hit in some container playfield"	^ true! !!RSRenderer methodsFor: 'accessing' prior: 59131666!canvas	^ athensCanvas! !!RSRenderer methodsFor: 'visiting' prior: 59132145!visitLabel: label! !!CompiledMethod methodsFor: '*Roassal3' prior: 22157901!dependentClassesWithOccurences	"Return the list of classes used myself. The result contains my superclass. The result may contains multiple times the same element."	"(Morph>>#drawOn:) dependentClassesWithOccurences"	"(CompiledMethod>>#dependentClassesWithOccurences) dependentClassesWithOccurences"	| cll |	cll := OrderedCollection new.	"We unify a class and its metaclass"	self literalsDo: [ :l |					"We also check if the method is not an extension"					((l isVariableBinding					and: [ l value notNil ])					and: [ l value isBehavior ])  ifTrue: [ cll add: l value ] ].	^ cll asArray! !!SubscriptionRegistry methodsFor: '*Roassal3' prior: 85159093!getInteractionsForClass: eventClass	"Return the list of subscription for a given Event class"	| answer |	answer := OrderedCollection new.	subscriptions do: [ :sub |		((sub subscriber class == eventClass) or:			[ sub subscriber class inheritsFrom: eventClass ]) ifTrue: [ answer add: sub subscriber ] ].	^ answer! !!RSGroup methodsFor: 'public - forwarding' prior: 58716147!color: aColor	"Give the same color to all the shapes"	self do: [ :s | s color: (aColor rsValue: s model) ]! !!RSGroup methodsFor: 'accessing' prior: 58717346!height	^ self extent y! !!RSGroup methodsFor: 'public - forwarding' prior: 58710572!pushBack	"Push back all the shapes contained in the group"	self do: [ :each | each pushBack ]! !!RSGroup methodsFor: 'accessing' prior: 58713303!shapeFromModel: anObject	"Return a shape that corresponds to the object provided as parameter. If none is found, then return nil```Smalltalkg := RSGroup new.g add: (RSBox new model: 'hello').g add: (RSEllipse new model: 'world').g shapeFromModel: 'hello'```=> a RSBox(hello))	"	| t |	self shapeFromModelCache		at: anObject		ifPresent: [ :v |			v isCollection ifFalse: [ ^ v ] ].	"We have this line because of a bug of the implementation of CompiledMethod>>#="	t := (anObject class == CompiledMethod)		ifTrue: [ self detect: [ :el | el model == anObject ] ifNone: [ nil ] ]		ifFalse: [ self detect: [ :el | el model = anObject ] ifNone: [ nil ] ].	self shapeFromModelCache at: anObject put: t.	^ t! !!RSGroup methodsFor: 'accessing' prior: 58709605!shapesFromModel: anObject	"Return a shape that corresponds to the object provided as parameter. If none is found, then return nil.For example:-=-=-=-=-=-=-=-=-=g := RSGroup new.g add: (RSBox new model: 'hello').g add: (RSEllipse new model: 'world').g shapesFromModel: 'hello'-=-=-=-=-=-=-=-=-==> a RSGroup(a RSBox(hello))	"	| t key |	self shapeFromModelCache at: anObject ifPresent: [ :v | v isCollection ifTrue: [ ^ v ] ].	"We have this line because of a bug of the implementation of CompiledMethod>>#="	t := (anObject class == CompiledMethod)				ifTrue: [ self select: [ :el | el model == anObject ] ]				ifFalse: [ self select: [ :el | el model = anObject ] ].	"We have this hack for nil objects because in visualWorks a dictionary cannot have nil as a key"	key := anObject isNil ifTrue: [ 'KeyForNilObjects' ] ifFalse: [ anObject ].	self shapeFromModelCache at: key put: t.	^ t! !!RSGroup methodsFor: 'accessing' prior: 58711782!shapesFromModels: objects	"Return elements that corresponds to the objects provided as parameter. If none is found, then return an empty collection"	| answer t |	self assert: [ objects isCollection ] description: 'Provide a set of shapes instead of one single shape'.	answer := RSGroup new.	objects do: [ :o |		t := self shapesFromModel: o.		t notNil ifTrue: [ answer addAll: t ] ].	^ answer! !!RSGroup methodsFor: 'public - forwarding' prior: 58711228!size: aNumber	"Convenient method. For example:```c := RSCanvas new.shapes := RSCircle models: (1 to: 9).shapes size: 30.c addAll: shapes.RSGridLayout on: shapes.c @ RSCanvasController```"	self do: [ :s | s size: (aNumber rsValue: s model) ]! !!RSGroup methodsFor: 'protocol' prior: 58715712!when: anAnnouncementClass do: aValuable	| subscriberForDeprecation |	aValuable receiver ifNil: [		self error:			'You must specify a subscriber object for this subscription. Please use #when:do:for: method.' ].	subscriberForDeprecation := thisContext sender receiver = aValuable receiver		                            ifTrue: [ 'self' ]		                            ifFalse: [ '`@arg2 receiver' ].	self		deprecated:			'Since there are some block closures (Clean and Constant) without a receiver, the API of announcements was changed to send the subscriber explicitly. 			We are deprecating this method because it was asking for the receiver of the block to use it as the subscriber.'		transformWith: '`@receiver when: `@arg1 do: `@arg2'			->			('`@receiver when: `@arg1 do: `@arg2 for: '			 , subscriberForDeprecation).	self when: anAnnouncementClass do: aValuable for: aValuable receiver! !!RSGroup methodsFor: 'public - forwarding'!when: event do: aOneArgBlock for: aSubscriber	"Define a callback for each of the shape contained in the group. For example:```c := RSCanvas new.shapes := RSCircle models: (1 to: 9).shapes size: 30.c addAll: shapes.RSGridLayout on: shapes.shapes when: RSMouseClick do: [ :evt | evt shape @ RSBlink ].c @ RSCanvasController```"	self do: [ :shape | shape when: event do: aOneArgBlock for: aSubscriber ]! !!RSGroup methodsFor: 'accessing' prior: 58717615!width	"Return the width of the encompassing rectangle of the group"	^ self extent x! !!RSGroup methodsFor: 'public - forwarding' prior: 58712241!withBorder	"Makes all the shapes having a border```c := RSCanvas new.circles := RSCircle models: (1 to: 20).circles size: 20.circles withBorder.c addAll: circles.RSGridLayout on: circles.c```	"	self do: #withBorder! !!RSAthensRenderer methodsFor: 'utilities' prior: 58324005!applyRadius: radius on: controlPoints from: start to: end	"based on https://riptutorial.com/html5-canvas/example/18766/render-a-rounded-polygon-"	| cp p1 p2 p3 arc v1 len1 a1 v2 len2 a2 sinA sin90	angle radDir drawDir halfAngle cRadius lenOut p a b len |	cp := controlPoints.	len := cp size.	p1 := p2 := p3 := nil.	arc := [		v1 := p1 - p2.		len1 := ((v1 x * v1 x) + (v1 y * v1 y)) sqrt.		v1 := v1 / len1.		a1 := v1 angle.		v2 := p3 - p2.		len2 := ((v2 x * v2 x) + (v2 y * v2 y)) sqrt.		v2 := v2 / len2.		a2 := v2 angle.		sinA := (v1 x * v2 y) - (v1 y * v2 x).		sin90 := (v1 x * v2 x) - (v1 y * v2 y negated).		angle := sinA arcSin.		radDir := 1.		drawDir := false.		sin90 < 0 ifTrue: [			angle < 0 ifTrue: [				angle := angle + Float pi ]			ifFalse: [				angle := angle - Float pi.				radDir := -1.				drawDir := true ] ]		ifFalse: [			angle >= 0 ifTrue: [				radDir := -1.				drawDir := true. ] ].		halfAngle := angle / 2.		sinA :=  halfAngle sin.		lenOut := sinA = 0			ifTrue: [ Float infinity ]			ifFalse: [ (halfAngle cos * radius/ sinA) abs].		cRadius := radius.		lenOut > ((len1 / 2) min: (len2 / 2)) ifTrue: [			lenOut := (len1 / 2) min: (len2 / 2).			cRadius := (lenOut * halfAngle tan) abs.			].		p := p2 + (v2 * lenOut) + (v2 y negated@ v2 x * cRadius * radDir).		a := a1 + (Float halfPi * radDir).		b := a2 - (Float halfPi * radDir).		(a closeTo: b) ifTrue: [ a := b ].		builder			arcAround: p			radius: cRadius			startAngle: a			endAngle: b			cw: drawDir. ].	start to: end do: [ :i |		p1 := cp at: (i)%len + 1.		p2 := cp at: (i + 1)%len + 1.		p3 := cp at: (i + 2)%len + 1.		(p1 = p2 or: [p2 = p3]) ifFalse: [ arc value ] ]! !!RSAthensRenderer methodsFor: 'utilities' prior: 58326856!arcCornerTangets: p0 p1: p1 r: r1 rc: rc cw: cw	| x01 y01 lo ox oy x1 y1 x2 y2 x3 y3 dx dy d2 r d D cx0 cy0 cx1 cy1 dx0 dy0 dx1 dy1 |	x01 := p0 x - p1 x.	y01 := p0 y - p1 y.	lo := (cw ifTrue:[rc ] ifFalse: [ rc negated ]) / ((x01 * x01) + (y01*y01)) sqrt.	ox := lo * y01.	oy := lo negated * x01.	x1 := p0 x + ox.	y1 := p0 y + oy.	x2 := p1 x + ox.	y2 := p1 y + oy.	x3 := (x1 + x2)/2.	y3 := (y1 + y2)/2.	dx := x2 - x1.	dy := y2 - y1.	d2 := (dx * dx) + (dy * dy).	r := r1 - rc.	D := (x1 * y2) - (x2 * y1).	d := (dy < 0 ifTrue: [ -1 ] ifFalse: [ 1 ]) * (0 max: ((r*r *d2) - (D * D) ) ) sqrt.	cx0 := ((D * dy) - (dx * d)) / d2.	cy0 := ( (D negated * dx) - (dy * d) ) / d2.	cx1 := ((D * dy) + (dx * d)) / d2.	cy1 := ( (D negated * dx) + (dy * d) ) / d2.	dx0 := cx0 - x3.	dy0 := cy0 - y3.	dx1 := cx1 - x3.	dy1 := cy1 - y3.	((dx0 * dx0) + (dy0 * dy0)) > ((dx1 * dx1) + (dy1 * dy1)) ifTrue: [		cx0 := cx1.		cy0 := cy1 ].	^  (cx0 - ox)@ (cy0 - oy) negated -> ((cx0 * r1 / r)@(cy0 * r1/r) negated)! !!RSAthensRenderer methodsFor: 'utilities' prior: 58329781!arcSweep: p1 and: p2	^ ((p1 x - p2 x)* p1 y) - ((p1 y - p2 y) * p1 x) > 0		ifTrue: [ 1 ]		ifFalse: [ 0 ]! !!RSAthensRenderer methodsFor: 'utilities' prior: 58330678!asin: x	^ x >= 1	ifTrue: [ 1.5707963267948966 ]	ifFalse: [ x <= -1		ifTrue: [ -1.5707963267948966 ]		ifFalse: [ x arcSin ] ]! !!RSAthensRenderer methodsFor: 'creating path' prior: 58329951!buildBezierPath: bezier	| points |	points := bezier controlPoints.	points size = 2 ifTrue: [		builder			absolute;			moveTo: points first;			lineTo: points second.		^ self ].	points size = 3 ifTrue: [		builder			absolute;			moveTo: points first;			curveVia: points second				to: points third.		^ self ].	points size = 4 ifTrue: [		builder			absolute;			moveTo: points first;			curveVia: points second				and: points third				to: points fourth  ]! !!RSAthensRenderer methodsFor: 'creating path' prior: 58328884!buildCornerBoxPath: box	| c rectangle e w2 h2 tl tr bl br min |	c := box cornerRadius.	rectangle := box baseRectangle.	e := rectangle extent.	w2 := e x / 2.0.	h2 := e y / 2.0.	min := w2 min: h2.	tl := (c topLeft min: min) max: 0.	tr := (c topRight min: min) max: 0.	bl := (c bottomLeft min: min) max: 0.	br := (c bottomRight min: min) max: 0.	builder		absolute;		moveTo: rectangle topLeft + (tl@0);		lineTo: rectangle topRight - (tr@0);		cwArcTo: rectangle topRight + (0@tr) angle: Float halfPi;		lineTo: rectangle bottomRight- (0 @ br);		cwArcTo: rectangle bottomRight - (br @ 0) angle: Float halfPi;		lineTo: rectangle bottomLeft + (bl @ 0);		cwArcTo: rectangle bottomLeft - (0@ bl) angle: Float halfPi;		lineTo: rectangle topLeft + (0@ tl);		cwArcTo: rectangle topLeft + (tl @0) angle: Float halfPi;		closePath! !!RSAthensRenderer methodsFor: 'creating path' prior: 58314525!buildEllipsePath: ellipse	| extent halfWidth halfHeight |	extent := ellipse baseRectangle extent.	halfWidth := extent x / 2 asFloat.	halfHeight := extent y / 2 asFloat.	builder		absolute;		moveTo: 0@0;		relative;		moveTo: halfWidth negated @ 0;		curveVia: 0 @ (halfHeight negated * 0.55)			and: (0.45 * halfWidth) @ halfHeight negated			to: halfWidth @ halfHeight negated;		curveVia: (halfWidth * 0.55) @ 0			and: halfWidth @ (0.45 * halfHeight)			to: halfWidth @ halfHeight;		curveVia: 0 @ (halfHeight * 0.55)			and: (0.45 * halfWidth negated) @ halfHeight			to: halfWidth negated @ halfHeight;		curveVia: (halfWidth negated * 0.55) @ 0			and: halfWidth negated @ (halfHeight negated * 0.45)			to: halfWidth negated @ halfHeight negated! !!RSAthensRenderer methodsFor: 'creating path' prior: 58327939!buildLinePath: line	builder		absolute;		moveTo: line startPoint;		lineTo: line endPoint! !!RSAthensRenderer methodsFor: 'creating path' prior: 58332386!buildPolygonPath: polygon	| first radius cp |	builder absolute.	radius := polygon cornerRadii.	cp := polygon points.	[	(radius ~= 0 and: [ cp size > 2 ]) ifTrue: [		builder moveTo: (cp first + cp second) /2.		self applyRadius: radius on: cp from: 0 to: cp size-1.		^ self ].	first := true.	cp do: [ :point |		first ifTrue: [			first := false.			builder moveTo: point ]		ifFalse: [			builder lineTo: point ] ].	] ensure: [ builder closePath. ]! !!RSAthensRenderer methodsFor: 'creating path' prior: 58321255!buildPolylinePath: line	| first cp radius |	builder absolute.	cp := line controlPoints.	radius := line cornerRadii.	(radius ~= 0 and: [ cp size > 2 ]) ifTrue: [		builder moveTo: cp first.		self applyRadius: radius on: cp from: 0 to: cp size - 3.		builder lineTo: cp last.		^ self ].	first := true.	cp do: [ :point |		first ifTrue: [			first := false.			builder moveTo: point ]		ifFalse: [			builder lineTo: point ] ]! !!RSAthensRenderer methodsFor: 'creating path' prior: 58316748!buildRingPath: ring	| aAngle bAngle xAngle i e center ap epsilon aAngle2 bAngle2	rp da da0 da1 rc x1 x2 x3 x4 y1 y2 y3 y4 rc0 rc1 t41 t23  t14 t32 |	epsilon := 1e-12.	ap := (ring segmentSpacing / 2) degreesToRadians.	aAngle := ring alphaAngle degreesToRadians.	bAngle := ring betaAngle degreesToRadians.	da := da0 := da1 := (aAngle - bAngle) abs.	aAngle2 := aAngle.	bAngle2 := bAngle.	center := 0@0.	i := ring innerRadius asFloat.	e := ring externalRadius asFloat.	e < i ifTrue: [ | r0 |		r0 := i. i := e. e := r0. ].	builder absolute.	"is it a point? "	e < epsilon ifTrue: [ ^ builder  moveTo: center ].	"or is a circle? "	da0 > (Float pi * 2 - epsilon) ifTrue: [		builder			moveTo: ((e * aAngle cos)@( e * aAngle sin negated)) + center ;			arcAround: center radius: e startAngle: aAngle endAngle: bAngle.		i > epsilon ifTrue: [			builder				moveTo: (i * (aAngle cos @ aAngle sin negated) )+ center ;				arcAround: center radius: i startAngle: aAngle endAngle: bAngle ].		builder close.		^ self ].	"circle part"	xAngle := (aAngle + bAngle)/2.	rp := ((i*i) + (e*e)) sqrt.	"apply padding"	rp > epsilon ifTrue: [ | p0 p1 |		p0 := i isZero			ifTrue: [ self asin: Float infinity ]			ifFalse: [ self asin: (rp / i * ap sin) ].		p1 := self asin: (rp / e * ap sin).		da0 := da0 - (p0*2).		da0 > epsilon			ifTrue: [ aAngle2 := aAngle2 + p0. bAngle2 := bAngle - p0 ]			ifFalse: [ aAngle2 := bAngle2 := (aAngle + bAngle)/2. ].		da1 := da1 - (p1*2).		da1 > epsilon			ifTrue: [ aAngle := aAngle + p1. bAngle := bAngle - p1 ]			ifFalse: [ aAngle := bAngle := xAngle ] ].	x1 := e*aAngle cos.	y1 := e*aAngle sin.	x2 := e*bAngle cos.	y2 := e*bAngle sin.	x4 := i*aAngle2 cos.	y4 := i*aAngle2 sin.	x3 := i*bAngle2 cos.	y3 := i*bAngle2 sin.	"is it small circle part?"	(aAngle - bAngle) abs < 0.001 ifTrue: [		builder			moveTo: (x3@y3) + center;			close.		^ self ].	"apply corner radius"	rc := ((i -e) abs /2) min: ring cornerRadii.	rc0 := rc1 := rc.	(da > epsilon and: [ rc > 0.001 ]) ifTrue: [		da < Float pi ifTrue: [			| oc ax ay bx by kc lc |			oc := self geomPolygonIntersectC: x1@y1 d: x4@y4 a: x2@y2  b: x3@y3.			ax := x1 - oc x.			ay := y1 - oc y.			bx := x2 - oc x.			by := y2 - oc y.			kc := 1 / (( ((ax*bx) + (ay*by)) /  ( ((ax*ax)+ (ay*ay)) sqrt * ( (bx*bx)+(by*by) ) sqrt ) ) arcCos / 2) sin.			lc := ((oc x * oc x) + (oc y*oc y)) sqrt.			rc0 := rc0 min: ((e - lc) / (kc + 1)).			rc1 := rc1 min: ((i - lc) / (kc - 1)) ].		t41 := self arcCornerTangets: x4@y4 p1: x1@y1 r: e rc: rc0 cw: true.		t23 := self arcCornerTangets: x2@y2 p1: x3@y3 r: e rc: rc0 cw: true.		builder moveTo: t41 key + center.		rc0 == rc ifTrue: [			builder				ellipticalArc2: rc0@rc0					xrot: 0					large: 0					sweep: 0					to: t41 value + center;				ellipticalArc2: e@e					xrot: 0					large: (self arcSweep: t41 value and: t23 value)					sweep: 0					to: t23 value + center;				ellipticalArc2: rc0@rc0					xrot: 0					large: 0					sweep: 0					to: t23 key + center.				 ]		ifFalse: [			builder				ellipticalArc2: rc0@rc0					xrot: 0					large: 1					sweep: 0					to: t23 key + center ].		(x4 isZero & y4 isZero) ifTrue: [			builder lineTo: center. ]		ifFalse: [			t14 := self arcCornerTangets: x1@y1 p1: x4@y4 r: i rc: rc1 negated cw: true.			t32 := self arcCornerTangets: x3@y3 p1: x2@y2 r: i rc: rc1 negated cw: true.			builder lineTo: t32 key + center.			(rc == rc1 and: [da0 > 0 ]) ifTrue: [				builder					ellipticalArc2: rc1@ rc1						xrot: 0						large: 0						sweep: 0						to: t32 value + center;					ellipticalArc2: i@i						xrot: 0						large: (self arcSweep: t14 value and: t32 value)						sweep: 1						to: t14 value + center;					ellipticalArc2: rc1@rc1						xrot: 0						large: 0						sweep: 0						to: t14 key + center			] ifFalse: [				builder					ellipticalArc2: rc1@ rc1						xrot: 0						large: 0						sweep: 0						to: t14 key + center		 ] ]	] ifFalse: [ | l0 l1 |		l1 := (bAngle - aAngle) abs <= Float pi ifTrue: [ 0 ] ifFalse: [ 1 ].		l0 := (bAngle2 - aAngle2) abs <= Float pi ifTrue: [ 0 ] ifFalse: [ 1 ].		builder			moveTo: x1 @ y1 negated;			ellipticalArc2: e@ e negated		 		xrot: 0				large: l1				sweep: 0				to: x2@y2 negated;			lineTo: x3@y3 negated;			ellipticalArc2: i@i negated				xrot: 0				large: l0				sweep: 1				to: x4@y4 negated.	].	builder close! !!RSAthensRenderer methodsFor: 'utilities' prior: 58315646!createStrokePaintFor: border	| stroke style |	stroke := (border paint asAthensPaintOn: athensCanvas) asStrokePaintOn: athensCanvas.	stroke width: border width asFloat.	style := border style.	style ifNil: [ ^ stroke ].	style dashArray		ifNotNil: [ :a | stroke dashes: a offset: style dashOffset ].	style capStyle		ifNotNil: [:s | s value: stroke ].	style joinStyle		ifNotNil: [:s | s value: stroke ].	^ stroke! !!RSAthensRenderer methodsFor: 'visiting - helpers' prior: 58328098!drawPathLabel: label	| utf8String act f stroke |	utf8String := label path.	utf8String ifNil: [		act := AthensCairoText new.		utf8String := act convertTextUtf8: label text.		label path: utf8String.	 ].	f := label cairoFont.	athensCanvas newPath.	f lock.	athensCanvas		setPathMatrix;		setScaledFont: f.	label paint ifNotNil: [		(label paint asAthensPaintOn: athensCanvas)"			setMatrix: athensCanvas paintTransform inverted;"			loadOnCairoCanvas: athensCanvas. ].	athensCanvas textPath: utf8String.	label paint ifNotNil: [ athensCanvas fillPreserve ].	label hasBorder ifTrue: [		stroke := label border accept: self.		stroke prepareForDrawingOn: athensCanvas.		athensCanvas stroke.	 ].	f unlock! !!RSAthensRenderer methodsFor: 'visiting - helpers' prior: 58316137!drawShadowRectangle: rect	| r |	athensCanvas setPaint: (Color blue alpha: 0.1).	r := rect origin asFloatPoint corner: rect corner asFloatPoint.	athensCanvas drawShape: r! !!RSAthensRenderer methodsFor: 'visiting - helpers' prior: 58323535!drawSimpleLabel: label	| font |	(label paint isNil or: [ label cairoGlyphs isNil ]) ifTrue: [ ^ self ].	"returns a CairoScaledFont"	font := label cairoFont.	font lock.	athensCanvas		setPathMatrix;		setScaledFont: font.	(label paint asAthensPaintOn: athensCanvas)		loadOnCairoCanvas: athensCanvas.	athensCanvas		showGlyphs: label cairoGlyphs getHandle		size: label cairoGlyphs size.	font unlock! !!RSAthensRenderer methodsFor: 'paint' prior: 58323152!paintFor: shape form: form	form isForm ifFalse: [ ^ form ].	^ CairoBackendCache soleInstance		at: form		ifAbsentPut: [			| paint |			paint := (AthensCairoPatternSurfacePaint				createForSurface: (AthensCairoSurface				fromForm: form)).			paint origin: (form extent /2) negated asFloatPoint.			paint ]! !!RSAthensRenderer methodsFor: 'visiting' prior: 58326173!visitBoundingShape: shape	self visitShapeIfNecessary: shape block: [		| path paint |		athensCanvas pathTransform loadAffineTransform: matrix.		path := self getOrCreatePathOf: shape.		paint := shape paintOn: self.		paint ifNotNil: [			athensCanvas				setPaint: paint;				drawShape: path ].		self visitBorderIfNecessary: shape.		self visitShadowRectangleIfNecessary: shape.		self visitChildrenIfNecessary: shape.	]! !!RSAthensRenderer methodsFor: 'visiting' prior: 58322076!visitCanvas: aRSCanvas	matrix := AthensAffineTransform new.	originMatrix := matrix copy.	canvasRect := aRSCanvas visibleRectangle.	showRectangles := aRSCanvas shouldShowRectangles.	athensCanvas fillRuleEvenOdd.	athensCanvas setAA: aRSCanvas antialiasing.	aRSCanvas camera accept: self.	aRSCanvas shapes accept: self.	"We display the elements that are _NOT_ subject to the camera"	matrix loadIdentity.	originMatrix loadIdentity.	canvasRect := 0@0 extent: aRSCanvas extent.	aRSCanvas fixedShapes accept: self! !!RSAthensRenderer methodsFor: 'visiting - helpers' prior: 58330877!visitChildrenIfNecessary: shape	| draw |	shape hasChildren ifFalse: [ ^ self ].	draw := [ shape children accept: self ].	shape clipChildren		ifTrue: [ athensCanvas clipBy: shape path during: draw ]		ifFalse: [ draw value ]! !!RSAthensRenderer methodsFor: 'visiting' prior: 58314382!visitGroup: aRSGroup	aRSGroup do: [ :roassalShape | roassalShape accept: self ]! !!RSAthensRenderer methodsFor: 'visiting' prior: 58331770!visitLabel: label	label hasText ifFalse: [ ^ self ].	self visitShapeIfNecessary: label block: [		| lbtranslation |		lbtranslation := label textExtents translationPoint asFloatPoint.		matrix translateBy: lbtranslation.		athensCanvas pathTransform loadAffineTransform: matrix.		label hasBorder			ifTrue: [ self drawPathLabel: label ]			ifFalse: [ self drawSimpleLabel: label ].		self visitLabelDecoratorsIfNecessary: label.		athensCanvas pathTransform translateBy: lbtranslation negated.		self visitShadowRectangleIfNecessary: label	]! !!RSAthensRenderer methodsFor: 'visiting - helpers' prior: 58331175!visitLabelDecoratorsIfNecessary: label	| advance |	(label isUnderlined or: [label isStruckOut]) ifFalse: [ ^ self ].	athensCanvas setPaint: label paint.	advance := (CairoFontMetricsProvider new			font: label font;			extentsOf: label text) x_advance.	label isUnderlined		ifTrue: [ athensCanvas drawShape: ((0 @ 1 extent: advance @ 1)) ].	label isStruckOut ifFalse:  [ ^ self ].	athensCanvas pathTransform		translateBy: (0@ (label textHeight / 4)) negated asFloatPoint.	athensCanvas drawShape: ((0 @ 1 extent: advance @ 1))! !!RSAthensRenderer methodsFor: 'visiting' prior: 58313889!visitLine: line	| path paint |	(line intersects: canvasRect) ifFalse: [ ^ self ].	athensCanvas pathTransform loadAffineTransform: matrix .	path := self getOrCreatePathOf: line.	paint := line paintOn: self.	paint ifNotNil: [		athensCanvas			setPaint: paint;			drawShape: path ].	self visitBorderIfNecessary: line.	line markerShapesInPositionDo: [ :shape | shape accept: self ].	self visitShadowRectLineIfNecessary: line! !!RSAthensRenderer methodsFor: 'visiting - helpers' prior: 58315357!visitShadowRectLineIfNecessary: line	showRectangles ifFalse: [ ^ self ].	self drawShadowRectangle: line encompassingRectangle! !!RSAthensRenderer methodsFor: 'visiting - helpers' prior: 58326675!visitShadowRectangleIfNecessary: shape	showRectangles ifFalse: [ ^ self ].	self drawShadowRectangle: shape baseRectangle! !!RSAthensRenderer methodsFor: 'visiting - helpers' prior: 58322667!visitShapeIfNecessary: shape block: aBlock	matrix restoreAfter: [		| shapeMatrix |		shapeMatrix := shape matrix asFloatTransform.		matrix multiplyBy: shapeMatrix.		originMatrix restoreAfter: [			| rect |			originMatrix multiplyBy: shapeMatrix.			rect := shape				computeEncompassingRectangleFor: shape baseRectangle				matrix: originMatrix.			(rect intersects: canvasRect) ifFalse: [ ^ self ].				aBlock value ].	]! !!RSCanvas class methodsFor: 'instance creation'!newCenterMiddleOrigin	^ self new		originCenterMiddle;		yourself! !!RSCanvas class methodsFor: 'instance creation'!newTopLeftOrigin	^ self new		originTopLeft;		yourself! !!RSCanvas methodsFor: 'adding - nodes edges' prior: 58425228!add: aShape	"Main method to add a shape to a shape to a canvas"	self		assert: aShape notNil		description: 'Nil cannot be added to a canvas'.	self		assert: (aShape class inheritsFrom: RSShape)		description: 'A shape must be provided'.	aShape		addedIn: self;		renderOn: self.	^ aShape! !!RSCanvas methodsFor: 'adding - removing shapes' prior: 58440421!addBasicShape: aShape	shapes add: aShape.	"shapeCollection add: aShape"! !!RSCanvas methodsFor: 'adding - removing shapes' prior: 58436736!addFixedShape: aShape	"This is a private method. Should not be called directly (use RSShape>>setAsFixed instead).Add a shape and make the shape fixed. It is therefore not subject to the camera.```c := RSCanvas new.lbl := RSLabel text: 'Fixed Label'.c addFixedShape: lbl.lbl translateBy: 100 @ 20.lbl := RSLabel text: 'Unfixed Label'.c addShape: lbl.c @ RSCanvasController.```"	fixedShapes add: aShape! !!RSCanvas methodsFor: 'adding - removing shapes' prior: 58426853!addShape: aShape before: otherShape	aShape addedIn: self.	shapes remove: aShape.	shapes add: aShape before: otherShape! !!RSCanvas methodsFor: 'announcer' prior: 58424458!announce: anEventOrAnEventClass	"Send an event"	| theEventToSend |	announcer ifNil: [ ^ self ].	theEventToSend := anEventOrAnEventClass value asAnnouncement.	theEventToSend canvas: self.	announcer announce: theEventToSend! !!RSCanvas methodsFor: 'announcer' prior: 58433959!announcementClasses	^ {RSCanvasEvent. RSShapeEvent}		flatCollect: [ :cls |			cls withAllSubclasses reject: [ :subcls|				subcls hasSubclasses ] ]! !!RSCanvas methodsFor: 'antialiasing' prior: 58434930!antialiasing	^ self propertyAt: #aa ifAbsent: [ CAIRO_ANTIALIAS_BEST ]! !!RSCanvas methodsFor: 'accessing'!background	^ self color! !!RSCanvas methodsFor: 'accessing'!background: aColor	self color: aColor! !!RSCanvas methodsFor: 'camera' prior: 58430938!camera	"Return the camera used by the canvas:For example:```Smalltalkc := RSCanvas new.(1 to: 10) do: [ :i | c add: (RSEllipse new size: 20) ].RSGridLayout on: c shapes.c camera translateBy: -30 @ 50.c```"	^ camera! !!RSCanvas methodsFor: 'camera' prior: 58430821!camera: anRSCamera	"Set a new camera for the canvas."	camera := anRSCamera! !!RSCanvas methodsFor: 'accessing' prior: 58425702!color	"Return the color of the canvas background"	^ color! !!RSCanvas methodsFor: 'accessing' prior: 58435150!color: aColor	"Set the color of the canvas background.```Smalltalkc := RSCanvas new .c color: Color blue.c add: (RSBox new size: 30; color: #red).c```"	color := aColor.	color isColor ifTrue: [ ^ self ].	color := Color colorFrom: aColor! !!RSCanvas methodsFor: 'private' prior: 58430599!createMorph	"Create a Morph that contains myself. This is a private method"	<deprecated: 'This only works when the host is a RSMorphicHost'>		^ host	 createMorph! !!RSCanvas methodsFor: 'accessing' prior: 58422192!deepNodes	"Return the list of all the nodes contained in the visualization"	| result |	result := OrderedCollection new.	self nodes do: [ :n |		n addRecursivelyIn: result ].	^ result! !!RSCanvas methodsFor: 'initialization'!defaultExtent	^ 500@500! !!RSCanvas methodsFor: 'initialization'!defaultShapeCollection	^ RSSequenceableCollection new! !!RSCanvas methodsFor: 'antialiasing' prior: 58434402!disableAntialiasing	self hasAntialiasing: false! !!RSCanvas methodsFor: 'accessing - computed' prior: 58421290!encompassingRectangleOf: aCollectionOfShapes	| r |	r := aCollectionOfShapes		ifEmpty: [ 0@0 corner: 0@0 ]		ifNotEmpty: [ Rectangle			merging: (aCollectionOfShapes				collect: [:each | each encompassingRectangle] ) ].	^ r topLeft extent: (self camera class maxExtentFor: r)! !!RSCanvas methodsFor: 'accessing' prior: 58422535!fixedShapes	"Return the list of shapes that are fixed, i.e., not subjet to the camera"	^ fixedShapes! !!RSCanvas methodsFor: 'accessing' prior: 58424134!fixedShapes: aCollection	fixedShapes := aCollection! !!RSCanvas methodsFor: 'antialiasing' prior: 58421624!hasAntialiasing: aBoolean	aBoolean		ifTrue: [ self aaGood ]		ifFalse: [ self aaNone ]! !!RSCanvas methodsFor: 'initialization' prior: 58427030!initialize	super initialize.	self shapeCollection: self defaultShapeCollection.	shapes := RSGroup new.	fixedShapes := RSGroup new.	nodes := RSGroup new.	edges := RSGroup new.	animations := OrderedCollection new.	color := Color white.	extent := self defaultExtent.	camera := RSCamera new		canvas: self;		yourself.	self useMorphicHost! !!RSCanvas methodsFor: 'accessing' prior: 58421763!morph	"Return the Athens morph used by the canvas to render the visualization"	<deprecated: 'This only works when the host is a RSMorphicHost'>		^ host morph! !!RSCanvas methodsFor: 'accessing' prior: 58444412!morph: aMorph	"Set the RSAthensMorph. The canvas will directly render in the morph"	<deprecated: 'This only works when the host is a RSMorphicHost'>	host morph: aMorph! !!RSCanvas methodsFor: 'opening' prior: 58419396!open	^ self openWithTitle: host defaultWindowTitle! !!RSCanvas methodsFor: 'opening' prior: 58420640!openOnceWithTitle: aTitle	"Open a visualization and record the position. When #openOnce is called a second time,	the new window replace the previous one, at the recorded position. This method is useful when	demoing and scripting. Return the open window"	| bounds win |	bounds := nil.	Smalltalk at: #previousWindow ifPresent: [ :w | bounds := w bounds. w close ].	win := self openWithTitle: aTitle.	Smalltalk at: #previousWindow put: win.	bounds ifNotNil: [		win bounds: bounds ].	^ win! !!RSCanvas methodsFor: 'opening' prior: 58437916!openWithTitle: aTitleAsString	"Open a canvas with a given title"	^ host openWithTitle: aTitleAsString! !!RSCanvas methodsFor: 'camera'!originCenterMiddle	camera originMode: RSCamera originCenterMiddle! !!RSCanvas methodsFor: 'camera'!originMode	^ camera originMode! !!RSCanvas methodsFor: 'camera'!originTopLeft	camera originMode: RSCamera originTopLeft! !!RSCanvas methodsFor: 'animations' prior: 58437453!playAnimations	| shouldClean |	shouldClean := false.	animations do: [ :animation |		animation refresh.		animation hasCompleted			ifTrue: [ shouldClean := true. ] ].	shouldClean ifTrue: [		animations copy do: [ :animation |			animation hasCompleted ifTrue: [ animation remove ] ] ]! !!RSCanvas methodsFor: 'shapes ordering' prior: 58423600!pushBack: aShape	"Shapes are ordered in the same order they are inserted. The order can be changed using #pushFront: and #pushBack.For example:```Smalltalkc := RSCanvas new.shape1 := RSEllipse new size: 50; color: #red.shape2 := RSEllipse new size: 50; color: #blue.shape2 translateBy: -25@0.c add: shape1; add: shape2.c pushBack: shape2.c.```"	| col |	col := aShape isFixed		ifTrue: [ fixedShapes ]		ifFalse: [ shapes ].	col		remove: aShape;		addFirst: aShape! !!RSCanvas methodsFor: 'shapes ordering' prior: 58417340!pushFront: aShape	"Shapes are ordered in the same order they are inserted. The order can be changed using #pushFront: and #pushBack.For example:```Smalltalkc := RSCanvas new.shape1 := RSEllipse new size: 50; color: #red.shape2 := RSEllipse new size: 50; color: #blue.shape2 translateBy: -25@0.c add: shape1; add: shape2.c pushFront: shape1.c.```The red circle is in front of the blue one, despite the red one is inserted first."	| col |	col := aShape isFixed		ifTrue: [ fixedShapes ]		ifFalse: [ shapes ].	col		remove: aShape ifAbsent: [];		addLast: aShape! !!RSCanvas methodsFor: 'adding - removing shapes' prior: 58423082!removeShape: shape	| evt index |	index := shapes indexOf: shape.	index = 0		ifTrue: [ index := fixedShapes indexOf: shape.			index = 0 ifFalse: [ fixedShapes remove: shape ] ]		ifFalse: [ shapes removeAt: index ].	shape parent: nil.	evt := RSShapeRemovedEvent new shape: shape.	self announce: evt.	shape announce: evt! !!RSCanvas methodsFor: 'antialiasing' prior: 58432352!setAA: aNumber	self propertyAt: #aa put: aNumber! !!RSCanvas methodsFor: 'adding - removing shapes' prior: 58442227!setAsFixed: aShape	self removeShape: aShape.	aShape isFixed: true.	self addShape: aShape! !!RSCanvas methodsFor: 'accessing'!shapeCollection	^ shapeCollection! !!RSCanvas methodsFor: 'accessing'!shapeCollection: anRSShapeCollection	shapeCollection := anRSShapeCollection! !!RSCanvas methodsFor: 'accessing - shapes' prior: 58440521!shapeWithAction: eventClass forPositionInPixels: position	"position is in pixel, it corresponds to the physical location in the window.	e.g., 0 @ 0 is top left of the window"	| block |	block := [ :list :pos|		list reverseDo: [ :s | | shape |			shape := s shapeWithAction: eventClass forPosition: pos.			shape ifNotNil: [ ^ shape ] ] ].	block value: fixedShapes value: position.	block value: shapes value: (self camera fromPixelToSpace: position).	^ self! !!RSCanvas methodsFor: 'accessing - shapes' prior: 58438855!shapeWithActionForPositionInPixels: position	"position is in pixel, it corresponds to the physical location in the window.	e.g., 0 @ 0 is top left of the window"	| block |	block := [ :list :pos |		list reverseDo: [ :s | | shape |			shape := s shapeWithActionForPosition: pos.			shape ifNotNil: [^ shape ] ] ].	block value: fixedShapes value: position.	"| shape |	shape := self quadTree shapeWithActionForPosition: (self camera fromPixelToSpace: position).	"	block value: shapes value: (self camera fromPixelToSpace: position).	"shape ifNil: [ shape := self ].	^ shape"	^ self! !!RSCanvas methodsFor: 'accessing' prior: 58426110!shapes	"Return all the shapes added to the canvas. An empty canvas would return an empty collection.For example```Smalltalks1 := RSBox new.s2 := RSEllipse new.c := RSCanvas new.c add: s1; add: s2.```The expression `c shapes` returns a `RSGroup` containing both `s1` and `s2`"	^ shapes copy! !!RSCanvas methodsFor: 'accessing - shapes' prior: 58432462!shapesFromModels: objects	"Return shapes that corresponds to the objects provided as parameter. If none is found, then return an empty collection"	^ self nodes shapesFromModels: objects! !!RSCanvas methodsFor: 'testing' prior: 58442458!shouldClearBackground	"Return whether the screen must be cleaned at each screen refresh"	^ self propertyAt: #shouldClearBackground ifAbsent: [ true ]! !!RSCanvas methodsFor: 'accessing' prior: 58419483!shouldClearBackground: aBool	"Determine if the canvas must be cleaned at each screen refresh. Per default it is, which means that if some shapes are translated, a footprint is left. This is useful to realize interesting visual effects.For example, evaluate the following script:```c := RSCanvas new.c shouldClearBackground: false.(1 to: 10) do: [ :i | c add: (RSEllipse new size: 20) ].RSGridLayout on: c shapes.c.```And execute the expression `c camera translateBy: 1 @ 1.`"	self propertyAt: #shouldClearBackground put: aBool! !!RSCanvas methodsFor: 'updating' prior: 58440195!signalUpdate	"Signal a platform signal that the canvas should be refreshed. This is important when some shapes are modified (color or position)."	host signalUpdate! !!RSCanvas methodsFor: 'accessing'!useMorphicHost	host := RSMorphicHost new		        canvas: self;		        yourself! !!RSCanvas methodsFor: 'camera' prior: 58441367!visibleArea: aRectangle	self camera zoomToFit: self extent rectangle: aRectangle.	self signalUpdate! !!RSCanvas methodsFor: 'camera' prior: 58431319!visibleRectangle	"returns the visible rectangle in the space"	^ self camera visibleRectangle! !!RSObjectWithProperty methodsFor: 'interactions' prior: 59003880!@ anInteractionClassOrInstance	"Add an interaction to the canvas or a shape.Here is an example that illustrate two interactions, one for a shape and another for the canvas:-=-=-=-=-=-=-=-=-=c := RSCanvas new.shape := RSEllipse new size: 30; model: 'hello'.c add: shape.shape @ RSPopup.c @ RSCanvasController-=-=-=-=-=-=-=-=-=	"	self addInteraction: anInteractionClassOrInstance! !!RSObjectWithProperty methodsFor: 'events' prior: 59008203!click	"Simulate a click. 	For example:-=-=-=-=-=-=-=-=-=c := RSCanvas new.box := RSBox new size: 40.box when: RSMouseClick do: [ :evt | self inform: 'hello' ].c add: box.box click.c-=-=-=-=-=-=-=-=-="	self announcer announce: (RSMouseClick new 		canvas: self canvas;		shape: self; 		yourself).! !!RSObjectWithProperty methodsFor: 'interactions' prior: 59005962!hasInteraction: anInteractionClass	"Return true or false if the receiver has an interaction. Note that the argument has to be an interaction class. And not an event"	self announcer subscriptions ifNil: [ ^ false ].	^ self announcer subscriptions handleSubscriberClass: anInteractionClass! !!RSObjectWithProperty methodsFor: 'properties' prior: 59006469!hasProperty: aKey	^ properties notNil and: [ properties includesKey: aKey ]! !!RSObjectWithProperty methodsFor: 'properties' prior: 59004333!propertiesDo: block	self hasProperties ifFalse: [ ^ self ].	block value: self properties! !!RSObjectWithProperty methodsFor: 'properties' prior: 59004927!propertyAt: aKey ifAbsent: anAbsentBlock	^ self properties at: aKey ifAbsent: anAbsentBlock! !!RSObjectWithProperty methodsFor: 'properties' prior: 59006609!propertyAt: aKey ifAbsentPut: anAbsentBlock	^ self properties at: aKey ifAbsentPut: anAbsentBlock! !!RSObjectWithProperty methodsFor: 'properties' prior: 59005084!propertyAt: aKey ifPresent: aPresentBlock	^ self properties at: aKey ifPresent: aPresentBlock! !!RSObjectWithProperty methodsFor: 'properties' prior: 59005678!propertyAt: aKey put: value	"Keep a value under a key. The key is usually a symbol.For example:```RSBox new propertyAt: #hello put: 'World'; propertyAt: #hello```return World	"	^ self properties at: aKey put: value! !!RSObjectWithProperty methodsFor: 'properties' prior: 59005243!removeKey: aKey	| prop |	prop := self properties.	(prop includesKey: aKey) ifFalse: [ ^ self ].	prop removeKey: aKey.	prop ifEmpty: [ prop := nil ]! !!RSRTreeShapeCollection methodsFor: 'private - removing' prior: 59101820!balanceRemovedPath: path	"| times |	times := 0.	self haltIf: path last value contents model = 53."	(1 to: path size -2) reverseDo: [ :index | | tree |		tree := (path at: index) value.		tree height: (tree left height max: tree right height)+1.		tree isBalanced ifFalse: [ | toMove brother |			"times := times + 1."			tree left height < tree right height ifTrue: [				toMove := tree left.				brother := tree right.			] ifFalse: [				toMove := tree right.				brother := tree left ].			tree fromNode: brother.			toMove do: [ :shape | tree addChild: shape ].			"this means that when you remove a node,			 in order to keed it balanced			maybe you can move a lot of nodes"		].	].	"(path last value contents model asString, ' - ', times asString, ' times') traceCr."! !!RSRTreeShapeCollection methodsFor: 'enumerating' prior: 59102671!do: aBlock	root do: aBlock! !!RSRTreeShapeCollection methodsFor: 'initialization' prior: 59103325!initialize	super initialize.	root := RSRNilNode new! !!RSRTreeShapeCollection methodsFor: 'removing' prior: 59102762!remove: oldObject ifAbsent: anExceptionBlock	| path |	path := root searchPath: oldObject.	path ifEmpty: [ ^ anExceptionBlock value ].	path size = 1 ifTrue: [		root := RSRNilNode new.	] ifFalse: [		self removeLastNodeInPath: path.	].	^ path last value contents! !!RSRTreeShapeCollection methodsFor: 'private - removing' prior: 59105213!removeLastNodeInPath: path	| last parent isRight brother |	last := path last.	parent := path nextToLast value.	isRight := last key.	last := last value.	brother := isRight ifTrue: [ parent left ] ifFalse: [ parent right ].	parent fromNode: brother.	path size < 3 ifTrue: [ ^ self ].	self balanceRemovedPath: path! !!RSRTreeShapeCollection methodsFor: 'finding/searching' prior: 59105693!shapesAtPoint: aPoint	| res |	res := OrderedCollection new.	root nodesWithPoint: aPoint list: res.	^ res! !!Object methodsFor: '*Roassal3' prior: 52866292!rsValue: anArgument	^ self! !!RSQuadTree class methodsFor: 'instance creation' prior: 59066276!withAll: aRSGroup rectangle: rectangle	| root extent |	extent := rectangle extent.	(extent x closeTo: extent y) ifTrue: [		root := self new.		root rectangle: rectangle.		aRSGroup do: [ :shape | root add: shape ].		^ root ].	^ extent x > extent y		ifTrue: [			self				withAll: aRSGroup				rectangle: (rectangle origin					corner: rectangle corner x @ (extent x + rectangle origin y)) ]		ifFalse: [			self				withAll: aRSGroup				rectangle: (rectangle origin					corner: (extent y + rectangle origin x) @ rectangle corner y) ]! !!RSQuadTree methodsFor: 'adding' prior: 59063083!add: aShape	isLeaf ifTrue: [		soleChild			ifNil: [ soleChild := aShape ]			ifNotNil: [				((self position: soleChild) closeTo: (self position: aShape))					ifTrue: [ self addChild: aShape ]					ifFalse: [						| firstChild |						firstChild := soleChild.						soleChild := nil.						self							addChild: aShape;							addChild: firstChild ] ] ]	ifFalse: [ self addChild: aShape ]! !!RSQuadTree methodsFor: 'adding' prior: 59064775!addChild: aShape	| center origin corner position |	isLeaf := false.	center := rectangle floatCenter.	origin := rectangle origin.	corner := rectangle corner.	position := self position: aShape.	position x < center x		ifTrue: [			position y < center y				ifTrue: [					northWestQuad ifNil: [						northWestQuad := self class new							rectangle: (origin corner: center);							yourself ].					northWestQuad add: aShape ]				ifFalse: [					southWestQuad ifNil: [						southWestQuad := self class new							rectangle: ((origin x @ center y ) corner: (center x @ corner y));							yourself ].					southWestQuad add: aShape ] ]		ifFalse: [			position y < center y				ifTrue: [					northEastQuad ifNil: [						northEastQuad := self class new							rectangle: ((center x @ origin y) corner: (corner x @ center y));							yourself ].					northEastQuad add: aShape ]				ifFalse: [					southEastQuad ifNil: [						southEastQuad := self class new							rectangle: (center corner: corner);							yourself ].					southEastQuad add: aShape ] ]! !!RSQuadTree methodsFor: 'initialization' prior: 59062643!initialize	super initialize.	isLeaf := true! !!RSQuadTree methodsFor: 'accessing' prior: 59062986!position: aShape	^ self class position: aShape! !!RSQuadTree methodsFor: 'accessing' prior: 59064405!rectangle: aRectangle	rectangle := aRectangle! !!RSQuadTree methodsFor: 'enumeration' prior: 59062744!subQuadsDo: aBlockClosure  northWestQuad ifNotNil: aBlockClosure.  northEastQuad ifNotNil: aBlockClosure.  southWestQuad ifNotNil: aBlockClosure.  southEastQuad ifNotNil: aBlockClosure! !!RSQuadTree methodsFor: 'private' prior: 59063529!visibleShapeContains: aPoint list: listResult	(self rectangle containsPoint: aPoint) ifFalse: [ ^ self ].	self isLeaf ifTrue: [		(self soleChild encompassingRectangle containsPoint: aPoint)			ifTrue: [ listResult add: self soleChild ]	] ifFalse: [		self subQuadsDo: [ :aQuad |			aQuad visibleShapeContains: aPoint list: listResult ]	]! !!RSQuadTree methodsFor: 'private' prior: 59063996!visibleShapesFrom: aRectangle list: listResult	(self rectangle intersects: aRectangle) ifFalse: [ ^ self ].	self isLeaf		ifTrue: [			(self soleChild encompassingRectangle intersects: aRectangle)				ifTrue: [ listResult add: self soleChild ] ]		ifFalse: [			self subQuadsDo: [ :aQuad |				aQuad visibleShapesFrom: aRectangle list: listResult ] ]! !RSMonitorEvents removeSelector: #onNewEventDo:!RSCanvas class removeSelector: #exampleSpec!RSCanvas class removeSelector: #exampleSimple!"Roassal3"!!RSShapeEvent methodsFor: 'accessing' prior: 59225376!position	^ position ifNil: [ self shape position ]! !!RSShapeEvent methodsFor: 'accessing' prior: 59225285!position: aPoint	position := aPoint! !!RSShapeEvent methodsFor: 'accessing' prior: 59224993!positionFromCamera	"Return the position from the camera. I.e., 0 @ 0 is at the center of the window if the camera has not been translated"	^ canvas		ifNotNil: [ canvas camera fromPixelToSpace: self position ]		ifNil: [ -250 @ -250 ]! !!RSEvent methodsFor: 'accessing' prior: 58660504!canvas	^ canvas ifNil: [ canvas := shape canvas ]! !!RSEvent methodsFor: 'accessing' prior: 58661085!shape: aRSShape	"An event should now the shape to which it is related to.	The shape has to be set before emitting the event."	shape := aRSShape! !!RSEvent methodsFor: 'accessing' prior: 58661281!signalUpdate	"Trigger a refresh of the morph. The method signalUpdate has to be called when some visual properties are changed (e.g., color, position)"	morph notNil ifTrue: [ morph changed ]! !!RSExtentChangedEvent methodsFor: 'printing'!printOn: aStream	aStream <<'newExtent: '.	newExtent printOn: aStream.	aStream << ' oldExtent:'.	oldExtent printOn: aStream.! !!RSMouseDragging methodsFor: 'initialization' prior: 58980325!initialize	super initialize.	step := 0 @ 0! !"Roassal3-Event"!!RSMultilineLabelBuilder methodsFor: 'hooks' prior: 58983561!basicShapeFor: aString	| lines |	lines := aString lines.	^ lines size = 1		ifTrue: [ self singleLabelFor: lines first ]		ifFalse: [ self compositeLabelFor: lines ]! !!RSMultilineLabelBuilder methodsFor: 'hooks' prior: 58984197!compositeLabelFor: lines	| shapes |	shapes := lines collect: [:line |		self singleLabelFor: (line copyReplaceAll: String tab with: '   ') ]		as: RSGroup.	self layout on: shapes.	^ shapes asShape		position: 0@0;		yourself! !!RSMultilineLabelBuilder methodsFor: 'initialization' prior: 58982800!initialize	super initialize.	self labelShape: RSLabel new; textBlock: #asString.	self wrapStrategy: RSNoWrapStrategy new! !!RSMultilineLabelBuilder methodsFor: 'accessing' prior: 58984033!layout	^ layout ifNil: [ layout := RSVerticalLineLayout new		alignLeft;		gapSize: 0;		yourself ]! !!RSMultilineLabelBuilder methodsFor: 'hooks' prior: 58983896!singleLabelFor: text	^ self labelShape copy		text: text;		yourself! !!RSAbstractContainerBuilder methodsFor: 'accessing' prior: 58178832!asShapeFor: model	self build.	^ self container asShape		model: model;		yourself! !!RSAbstractContainerBuilder methodsFor: 'accessing' prior: 58178462!container	^ container ifNil: [ container := self defaultContainer ]! !!RSAbstractContainerBuilder methodsFor: 'updating' prior: 58178598!update	self container shapes do: #remove.	self build! !!RSNoWrapStrategy methodsFor: 'initialization' prior: 58991195!initialize	"Subclasses should redefine this method to perform initializations on instance creation"! !!RSAbstractShapesBuilder methodsFor: 'hooks' prior: 58239256!renderIn: aCanvas	aCanvas addAll: (shapes := self shapesFor: self objects)! !!RSAbstractShapesBuilder methodsFor: 'hooks' prior: 58239393!shapesFor: aCollection	| k |	k := 0.	^ aCollection collect: [ :m |		k := k + 1.		self shapeFor: m yourself index: k.		 ] as: RSGroup! !!RSPunchCardBuilder methodsFor: 'accessing' prior: 59060526!addMetric: aRoassalValue name: name	metrics at: name put: aRoassalValue! !!RSPunchCardBuilder methodsFor: 'initialization' prior: 59060265!initialize	super initialize.	metrics := OrderedDictionary new.	size := 10! !!RSPunchCardBuilder methodsFor: 'hooks' prior: 59059812!renderDots: aCanvas	| base |	base := RSEllipse new popup.	objects		doWithIndex: [ :cls :x |			metrics keys				doWithIndex: [ :k :y |					| metric res |					metric := metrics at: k.					res := metric rsValue: cls.					aCanvas						add:							(base copy								model: res;								position: x @ y * size;								size: (res + 1) ln + 1;								announcer: base announcer) ] ]! !!RSPunchCardBuilder methodsFor: 'hooks' prior: 59060655!renderXAxis: aCanvas	| labels |	labels := objects collectWithIndex: [ :cls :x |		          | label |		          label := (self labelFor: cls) rotateByDegrees: -90.		          label position: x @ 0 * size.		          label ].	RSAlignment new		shapes: labels;		bottom.	aCanvas addAll: labels! !!RSPunchCardBuilder methodsFor: 'hooks' prior: 59061396!renderYAxis: aCanvas	| labels |	labels := metrics keys collectWithIndex: [ :k :i |		          (self labelFor: k)			          position: 0 @ i * size;			          yourself ].	RSAlignment new		shapes: labels;		right.	aCanvas addAll: labels! !!RSWrapEllipsisStrategy methodsFor: 'hooks' prior: 59533307!wrapTextFor: aString with: aRSMultilineLabelBuilder	| width lines label currentTextWithEllipsis currentText ellipsis |	lines := aString lines.	lines size > 1 ifTrue: [ self error: 'Not supported for multiline' ].	width := self wrapMaxWidth.	ellipsis := self ellipsis.	currentText := currentTextWithEllipsis := aString.	[label := aRSMultilineLabelBuilder singleLabelFor: currentTextWithEllipsis.	label width > width and: [ currentText isNotEmpty ] ] whileTrue: [		currentText := currentText copyFrom: 1 to: currentText size - 1.		currentTextWithEllipsis := currentText , ellipsis.	].	^ label! !!RSAdjacencyMatrixBuilder methodsFor: 'public - cycle' prior: 58271321!getAllCycles	"Return all the cycles contained in the graph"	| answer |	answer := Set new.	objects do: [ :obj |		| s |		s := self getVisitedNodesStartingFrom: obj.		(s includes: obj) ifTrue: [ answer add: s ] ].	^ answer! !!RSAdjacencyMatrixBuilder methodsFor: 'public - cycle' prior: 58274268!getVisitedNodesStartingFrom: obj	| visiting |	visiting := Set new.	(self outgoingConnectionsOf: obj) do: [ :o |		  self hasCycleStartingFrom: o visiting: visiting ].	^ visiting! !!RSAdjacencyMatrixBuilder methodsFor: 'public - cycle' prior: 58270253!hasCycleStartingFrom: obj	^ (self getVisitedNodesStartingFrom: obj) includes: obj! !!RSAdjacencyMatrixBuilder methodsFor: 'public - cycle' prior: 58273465!hasCycleStartingFrom: obj visiting: visiting	(visiting includes: obj) ifTrue: [ ^ self ].	visiting add: obj.	(self numberOfOutgoingConnectionsOf: obj) = 0 ifTrue: [ ^ self ].	(self outgoingConnectionsOf: obj) do: [ :o |		self hasCycleStartingFrom: o visiting: visiting ]! !!RSAdjacencyMatrixBuilder methodsFor: 'hooks' prior: 58270399!renderIn: aCanvas	"Display the adjacency matrix"	| shape |	objects do: [ :obj1 |		objects do: [ :obj2 |			shape := RSBox new.			shape size: self defaultSize.			(self does: obj1 dependsOn: obj2)				ifTrue: [ shape color: self connectingColor ]				ifFalse: [ shape color: self nonConnectingColor ].			shape model: obj1 -> obj2.			aCanvas add: shape ] ].	RSGridLayout new		gapSize: 0;		lineItemsCount: self numberOfObjects;		on: aCanvas shapes.	aCanvas shapes @ RSPopup! !!RSAdjacencyMatrixBuilder methodsFor: 'public - sorting' prior: 58272669!sortByNumberOfIncomingConnections	objects := objects asSortedCollection: [ :a :b |		           (self numberOfIncomingConnectionsOf: a)		           < (self numberOfIncomingConnectionsOf: b) ].	objects := objects asArray! !!RSAdjacencyMatrixBuilder methodsFor: 'public - sorting' prior: 58273064!sortByNumberOfOutgoingConnections	objects := objects asSortedCollection: [ :a :b |		           (self numberOfOutgoingConnectionsOf: a)		           < (self numberOfOutgoingConnectionsOf: b) ].	objects := objects asArray! !!RSAbstractTreeBuilder methodsFor: 'private' prior: 58252968!createElements: atree nesting: block1 leaves: block2 depth: depth	| children aShape leaves nodes|	aShape := self shapeFor: atree.	shapes add: aShape.	children := block1 rsValue: atree.	aShape depth: depth.	children := children collect: [ :child | | aShape2 |		aShape2 := self createElements: child nesting: block1			leaves: block2 depth: depth + 1.		aShape2 sparent: aShape.		aShape2 ] as: Array.	leaves := (block2 rsValue: atree) collect: [:child | | aShape2 |		aShape2 := self createElements: child nesting: #()			leaves: #() depth: depth +1.		aShape2 sparent: aShape.		aShape2 ] as: Array.	nodes := OrderedCollection new: (leaves size + children size).	nodes addAll: children; addAll: leaves.	aShape schildren: nodes.	^ aShape! !!RSAbstractTreeBuilder methodsFor: 'private' prior: 58252533!createElements: atree using: ablock depth: depth	| children shape |	shape := self shapeFor: atree.	shapes add: shape.	children := ablock rsValue: atree.	shape depth: depth.	children := children collect: [ :child | | e2 |		e2 := self createElements: child using: ablock depth: depth + 1.		e2 sparent: shape.		e2 ] as: Array.	shape schildren: children.	^ shape! !!RSAbstractTreeBuilder methodsFor: 'public - building' prior: 58252271!explore: atree using: ablock	shapes := RSGroup new.	^ (self from: (Array with: atree) using: ablock) first! !!RSAbstractTreeBuilder methodsFor: 'initialization' prior: 58251360!initialize	super initialize.	rootNodes := RSGroup new! !!RSAbstractTreeBuilder methodsFor: 'weight' prior: 58252006!leafWeight: block	self weight: [ :shape | self weightLeafShape: shape block: block ]! !!RSAbstractTreeBuilder methodsFor: 'weight' prior: 58251764!modelWeight: anObject	self weight: [ :shape | anObject rsValue: shape model ]! !!RSAbstractTreeBuilder methodsFor: 'private' prior: 58250502!weightFromChildren: shape block: aBlock	| children weightValue |	children := shape schildren.	weightValue := children		ifEmpty: [ aBlock rsValue: shape model ]		ifNotEmpty: [			children				inject: 0				into: [ :s :child | s + (self weightLeafShape: child block: aBlock) ] ].	^ weightValue max: self minWeightValue! !!RSAbstractTreeBuilder methodsFor: 'private' prior: 58251562!weightLeafShape: shape block: aBlock	^ shape		propertyAt: self weightKey		ifAbsentPut: [			self weightFromChildren: shape block: aBlock ]! !!RSWrapStrategy methodsFor: 'hooks' prior: 59534141!wordsAndSpacesFor: aString	| tokens flag isWord i |	tokens := OrderedCollection new.	isWord := nil.	i := 1.	aString doWithIndex: [ :char :index |		flag := char tokenish.		isWord ifNil: [ isWord := flag ].		isWord = flag ifFalse: [			tokens add: (aString copyFrom: i to: index-1).			i := index.			isWord := flag.			].		].	tokens add: (aString copyFrom: i to: aString size).	^ tokens! !!RSWrapStrategy methodsFor: 'hooks' prior: 59534591!wrapLineShapesFor: line with: aRSMultilineLabelBuilder	| label tokens newLines i currentLine width lastLabel |	label := aRSMultilineLabelBuilder		singleLabelFor: line.	width := self wrapMaxWidth.	label width < width		ifTrue: [ ^ { label } ].	tokens := self wordsAndSpacesFor: line.	newLines := OrderedCollection new.	i := 1.	lastLabel := nil.	currentLine := ''.	[ i <= tokens size ] whileTrue: [		| token |		token := tokens at: i.		label := aRSMultilineLabelBuilder			singleLabelFor: currentLine, token.		label width > width			ifTrue: [				lastLabel ifNil: [					| k ok |					token := label text.					k := token size - 1.					ok := false.					[ k > 1 and: [ ok not ] ] whileTrue: [						lastLabel := aRSMultilineLabelBuilder							singleLabelFor: (token copyFrom: 1 to: k).						lastLabel width < width ifTrue: [							ok := true.							] ifFalse: [ k := k - 1 ] .					].					newLines add: lastLabel.					tokens at: i put: (token copyFrom: k+1 to: token size).				 ] ifNotNil: [					newLines add: lastLabel.					currentLine := ''.					lastLabel := nil				 ].			] ifFalse: [				currentLine := label text.				lastLabel := label.				i := i + 1 ]	].	currentLine ifNotEmpty: [		newLines add: (aRSMultilineLabelBuilder			singleLabelFor: currentLine). ].	^ newLines! !!RSWrapStrategy methodsFor: 'hooks' prior: 59535960!wrapTextFor: aString with: aRSMultilineLabelBuilder	| lines shapes |	lines := aString lines.	shapes := lines flatCollect: [ :line |		self wrapLineShapesFor: line with: aRSMultilineLabelBuilder ]		as: RSGroup.	aRSMultilineLabelBuilder layout on: shapes.	^ shapes asShape		position: 0@0;		yourself! !RSAbstractContainerBuilder removeSelector: #asPresenter!"Roassal3-Builders"!!RSTLine methodsFor: 'public - shape'!format	^ formatString! !!RSTLine methodsFor: 'public - shape' prior: 59320701!format: aString	"Format lines of the LinePlot.	Receive a string shortcut to define line and marker styles.	For markers use	'o' - circle	'^' - arrow	's' - square	'p' - pentagon	'h' - hexagon	'+' - plus	'd' - diamond	'*' - star	For stroke styles use:	'--' dashed line.	'-.' dashed line with small line then point	'.' dashed line with points		For colors use:	'r' red	'g' green	'b' blue	'c' cyan	'm' magenta	'y' yellow	'k' black	'w' white		There is no order of marker, stroke or color specification.	'r.o'	'.or'	'o.r'	 "	formatString := aString.	self shape format: formatString.! !!RSTLine methodsFor: 'public - shape' prior: 59319449!width: aNumber	"Set the width of the line. For example:-=-=-=-=-=-=-=-=-=-=c := RSCanvas new.from := RSBox new size: 30; model: 'from'.to := RSEllipse new size: 30; model: 'to'.c add: from.c add: to.RSEdgeBuilder line	canvas: c;	width: 10;	connectFrom: 'from' to: 'to'.from @ RSDraggable.to @ RSDraggable.to translateTo: 50 @ 40.c @ RSCanvasController-=-=-=-=-=-=-=-=-=-=	"	self shape width: aNumber! !!Array methodsFor: '*Roassal3-Shapes' prior: 17200478!asShapeFor: model	^ RSComposite new		model: model;		shapes: self;		yourself! !!RSCircle methodsFor: 'geometry' prior: 58492582!geometry	| rect e p |	rect := self encompassingRectangle.	e := rect extent / 2.	p := self position.	e = (0@0) ifTrue: [ ^ p asGPoint ].	^ GEllipse		center: p		vertex: p + (0@ e y)		coVertex:p + (e x@ 0)! !!RSCircle methodsFor: 'testing' prior: 58493336!preciseIncludesPoint: aPoint	"Implementation is taken over from EllipseMorph>>containsPoint:"	| invertedPoint radius other delta xOverY t1 t2 rect |	invertedPoint := matrix rsInverseTransform: aPoint.	rect := self baseRectangle.	(rect containsPoint: invertedPoint) ifFalse: [ ^ false ]. "quick elimination"	radius := rect height asFloat / 2.	other := rect width asFloat / 2.	delta := invertedPoint - rect topLeft - (other@radius).	xOverY := rect width asFloat / rect height asFloat.	t1 := (delta x asFloat / xOverY) squared + delta y squared.	t2 := radius squared.	^ (t1 < t2)  or: [ t1 closeTo: t2 ]! !!RSShortestHorizontalAttachPoint methodsFor: 'public - hooks' prior: 59233727!basicEndingPointOf: aLine	| r1 r2 off p1 p2 center |	r1 := aLine from globalEncompassingRectangle.	r2 := aLine to globalEncompassingRectangle.	off := endOffset@0.	p1 := r2 rightCenter + off.	p2 := r2 leftCenter - off.	center := r1 floatCenter.	^ (p1 distanceTo: center) < (p2 distanceTo: center)		ifTrue: [ p1 ]		ifFalse: [ p2 ]! !!RSShortestHorizontalAttachPoint methodsFor: 'public - hooks' prior: 59233306!basicStartingPointOf: aLine	| r1 r2 off p1 p2 center |	r1 := aLine from globalEncompassingRectangle.	r2 := aLine to globalEncompassingRectangle.	off := startOffset@0.	p1 := r1 rightCenter + off.	p2 := r1 leftCenter - off.	center := r2 floatCenter.	^ (p1 distanceTo: center) < (p2 distanceTo: center)		ifTrue: [ p1 ]		ifFalse: [ p2 ]! !!RSCairoFitMetricsProvider methodsFor: 'hooks' prior: 58399043!extentsOf: aRSLabel	| rawExt cairoFont glyphs |	cairoFont := aRSLabel cairoFont.	glyphs := aRSLabel cairoGlyphs.	rawExt := CairoTextExtents new.	cairoFont getExtentsOfGlyphs: glyphs getHandle ofLength: glyphs size into: rawExt.	^ RSTextExtents new		from: rawExt;		yourself! !!RSShortestHorizontalCPController methodsFor: 'hooks' prior: 59234497!controlPointsFor: aLine	| r1 r2 ap c1 c2 c3 c4 mid off1 off2 |	ap := aLine attachPoint.	r1 := self rectangleFor: aLine from line: aLine.	r2 := self rectangleFor: aLine to line: aLine.	c1 := r1 floatCenter.	c4 := r2 floatCenter.	off1 := startOffset @ 0.	off2 := endOffset @ 0.	c1 x < c4 x  ifTrue: [		c1 := r1 rightCenter + off1.		c4 := r2 leftCenter - off2.	] ifFalse: [		c1 := r1 leftCenter - off1.		c4 := r2 rightCenter + off2.	].	mid := (c1 x + c4 x)/2.	c2 :=	mid @ c1 y.	c3 := mid @ c4 y.	^ { c1. c2. c3. c4 }! !!RSShortestHorizontalCPController methodsFor: 'hooks' prior: 59235199!rectangleFor: shape line: line	| r ap |	ap := line attachPoint.	r := shape encompassingRectangle.	^ (ap positionFor: shape in: line point: r origin)		corner: (ap positionFor: shape in: line point: r corner)! !!RSGroup methodsFor: '*Roassal3-Shapes' prior: 58714977!asShapeFor: model	"Convert a RSGroup into a shape, and tis shape has a model. Pretty convenient to create a group of shapes as a composite.Consider the following example:```c := RSCanvas new.classes := Collection withAllSubclasses.elements := classes collect: [ :cls |	g := RSGroup new		add: (RSLabel new text: cls name);		add: (RSEllipse new size: (cls numberOfMethods + 5) sqrt; color: Color blue );		yourself.	RSVerticalLineLayout new alignCenter; on: g.	g asShapeFor: cls ] as: RSGroup.c addAll: elements.elements @ RSHighlightable red.RSGridLayout on: elements.c @ RSCanvasController```"	^ RSComposite new		model: model;		shapes: self;		yourself! !!RSOffsetAttachPoint class methodsFor: 'testing' prior: 59022189!isAbstract	^ self == RSOffsetAttachPoint! !!RSOffsetAttachPoint methodsFor: 'initialization' prior: 59021772!initialize	super initialize.	startOffset := endOffset := 0! !!RSOffsetAttachPoint methodsFor: 'accessing' prior: 59021978!startOffset: aNumber	startOffset := aNumber! !!RSLineBuilder class methodsFor: 'instance creation' prior: 58914752!arrowedDirectedBezier	| marker ext |	ext := 15 @ 20.	marker := RSShapeFactory triangle		extent: ext;		withBorder;		asMarker.	marker offset: ext y / 2.	^ self directedBezier		markerEnd: marker;		attachPoint: (RSBorderAttachPoint new endOffset: 0);		yourself! !!RSLineBuilder class methodsFor: 'instance creation' prior: 58921064!horizontalLine: aShape	^ (self new: aShape)		controlPointsController: RSHorizontalCPAPController new;		yourself! !!RSLineBuilder class methodsFor: 'instance creation' prior: 58919896!new: aRSShape	 ^ super new		shape: aRSShape;		yourself! !!RSLineBuilder class methodsFor: 'instance creation' prior: 58913926!orthoHorizontal	^ self horizontalLine: RSPolyline new! !!RSLineBuilder class methodsFor: 'instance creation' prior: 58921913!orthoVertical	^ self verticalLine: RSPolyline new! !!RSLineBuilder class methodsFor: 'instance creation' prior: 58924182!verticalLine: aShape	^ (self new: aShape)		controlPointsController: RSVerticalCPAPController new;		yourself! !!RSLineBuilder methodsFor: 'accessing' prior: 58897415!canvas	"Return the canvas if it was manually set using #canvas: or infer it from the shapes added to the builder"	(canvas isNil and: [ fromShapes notNil ]) ifTrue: [ canvas := fromShapes anyOne canvas ].	^ canvas! !!RSLineBuilder methodsFor: 'public - line' prior: 58898424!connectFrom: aFromBlock to: aBlockOrASymbol	| toShape fromShape |	self resetCreatedEdges.	self fromShapes copy do: [ :e |			fromShape := self fromShapes shapeFromModel: (aFromBlock rsValue: e model).			toShape := self toShapes shapeFromModel: (aBlockOrASymbol rsValue: e model).			toShape ifNotNil: [ self createEdgeIfNecessaryFrom: fromShape to: toShape ] ].	self moveBehindIfNecessary: createdEdges.	^ createdEdges! !!RSLineBuilder methodsFor: 'public - line' prior: 58911740!connectFrom: aFromBlock toAll: aBlockOrASymbol	"Define edges from a particular shape to another set of shapes. For example:```c := RSCanvas new.shapes := (30 to: 50) collect: [ :nb |	RSEllipse new size: nb; model: nb; yourself.	 ] as: RSGroup.c addAll: shapes.RSEdgeBuilder line	canvas: c;	withBorderAttachPoint;	connectFrom: 30 toAll: (31 to: 50).RSGridLayout on: shapes.RSLocation new	above;	move: shapes first on: shapes allButFirst.shapes @ RSDraggable.c @ RSCanvasController.c open```	"	| fromElement tes |	self resetCreatedEdges.	self fromShapes copy do: [ :e |		fromElement := self fromShapes shapeFromModel: (aFromBlock rsValue: e model).		tes := self toShapes shapesFromModels: (aBlockOrASymbol rsValue: e model).		tes ifNotNil: [			tes do: [ :toE |				self createEdgeIfNecessaryFrom: fromElement to: toE ] ] ].	self moveBehindIfNecessary: createdEdges.	^ createdEdges! !!RSLineBuilder methodsFor: 'public - line' prior: 58901922!connectFromAll: aFromBlockOrSymbol	^ self connectFromAll: aFromBlockOrSymbol to: [ :each | each ]! !!RSLineBuilder methodsFor: 'public - line' prior: 58907455!connectFromAll: aFromBlockOrSymbol to: aBlockOrASymbol	| toElement tfromElements |	self resetCreatedEdges.	self fromShapes copy do: [ :e |		tfromElements := self fromShapes shapesFromModels: (aFromBlockOrSymbol rsValue: e model).		toElement := self toShapes shapeFromModel: (aBlockOrASymbol rsValue: e model).		tfromElements ifNotNil: [			tfromElements do: [ :fromElement |				self createEdgeIfNecessaryFrom: fromElement to: toElement ] ] ].	self moveBehindIfNecessary: createdEdges.	^ createdEdges! !!RSLineBuilder methodsFor: 'public - line' prior: 58910841!connectToAll: aBlockOrASymbol	"Should this method use connectFrom:ToAll: ?????"	| tmptoElements |	self resetCreatedEdges.	self fromShapes copy do: [ :e |		tmptoElements := self toShapes shapesFromModels: (aBlockOrASymbol rsValue: e model).		tmptoElements ifNotNil: [			tmptoElements do: [ :toE |				self createEdgeIfNecessaryFrom: e to: toE ] ] ].	self moveBehindIfNecessary: createdEdges.	^ createdEdges! !!RSLineBuilder methodsFor: 'private - utility' prior: 58902084!edgeFrom: source to: target	"source and target are elements"	| line |	line := self shape copy		model: source model -> target model;		from: source;		to: target;		resetMarkers;		markerStart: self shape markerStart copy;		markerMid: self shape markerMid copy;		markerEnd: self shape markerEnd copy;		border: self shape border copy;		yourself.	self canvas ifNotNil: [ canvas add: line ].	^ line! !!RSLineBuilder methodsFor: 'accessing' prior: 58897687!fromObjects: someObjectsOrABlock	"Identify the elements we are considering for the edge building process. Note that the view has to be set beforehand."	self assert: [ canvasHasBeenManuallySet ] description: 'A canvas has to be set, please use #canvas: before'.	(someObjectsOrABlock isCollection and: [ someObjectsOrABlock isSymbol not ])		ifTrue: [ self fromShapes: (canvas shapesFromModels: someObjectsOrABlock) ]		ifFalse: [ self fromShapes: (canvas nodes select: [ :el | someObjectsOrABlock rsValue: el model ]) ]! !!RSLineBuilder methodsFor: 'initialization' prior: 58906601!initialize	super initialize.	self noRepetition.	shouldMoveBehind := false.	"The view has to be explicitly set by the end-user"	canvasHasBeenManuallySet := false.	"We could have edges from A to B, and from B to A"	self beDirectional! !!RSLineBuilder methodsFor: 'testing' prior: 58895107!isBidirectional	"Return true or false, indicating whether the edge builder is bidirectional or not (i.e., if	edges from A to B, __and__ B to A can be created"	^ beDirectional! !!RSLineBuilder methodsFor: 'public - configuration' prior: 58909315!noRepetition	"Avoid having more than one edge between two elements```b := RSMondrian new.b nodes: (1 to: 3).b line		color: Color red translucent;		withVerticalAttachPoint;		noRepetition;		useAssociations: { 1 -> 2 . 2 -> 3 . 1 -> 2}.b layout grid.b build.b canvas numberOfEdges```	"	allowRepetition := false! !!RSLineBuilder methodsFor: 'accessing' prior: 58900049!objects: someObjectsOrABlock	"Identify the elements we are considering for the edge building process. Note that the view has to be set beforehand."	self assert: [ canvasHasBeenManuallySet ] description: 'A view has to be set, please use #view:'.	self toObjects: someObjectsOrABlock.	self fromObjects: someObjectsOrABlock! !!RSLineBuilder methodsFor: 'accessing' prior: 58905952!shapes: someShapes	"This method is used to provide a set of Roassal shapes. Models will be looked up in these elements"	self assert: [ someShapes isCollection ] description: 'Must provide a collection'.	self assert: [ someShapes allSatisfy: [ :obj | obj class inheritsFrom: RSShape ] ] description: 'Must provide a collection of Roassal shapes'.	self assert: [ someShapes allSatisfy: #hasModel ] description: 'All shapes must have a model'.	self toShapes: someShapes.	self fromShapes: someShapes! !!RSLineBuilder methodsFor: 'public - source' prior: 58902550!source: objects connectFrom: fromblock to: toBlock	"Define some edges from objects that are not part of the canvas"	"	nbOfNodes := 40.nbOfRandomEdges := 40.nodes := 1 to: nbOfNodes.edges := (1 to: nbOfRandomEdges)				collect: [ :notUsed | nodes atRandom -> nodes atRandom ].b := RSCanvas new .b addAll: (nodes collect: [ :n|	RSEllipse new		model: n;		size: 5;		color: (Color black alpha: 0.5)]).RSEdgeBuilder line	color: (Color gray alpha: 0.3);	canvas: b;	source: edges connectFrom: #key to: #value.RSForceBasedLayout on: b nodes.b"	| assocs allObjects |	self assert: [ objects notNil ] description: 'Cannot provide a nil value as the source'.	self assert: [ objects isCollection ] description: 'Need to provide a collection as the source'.	allObjects := Set new.	assocs := objects collect: [ :o |		| f t |		f := fromblock rsValue: o.		t := toBlock rsValue: o.		allObjects add: f; add: t.		f -> t ].	self objects: allObjects asArray.	^ self useAssociations: assocs! !!RSLineBuilder methodsFor: 'public - source' prior: 58909700!source: objects connectFrom: fromblock toAll: toBlock	"Define some edges from objects that are not part of the viewnbOfNodes := 40.nbOfRandomEdges := 40.nodes := 1 to: nbOfNodes.edges := (1 to: nbOfRandomEdges)				collect: [ :notUsed | nodes atRandom -> {nodes atRandom . nodes atRandom} ].b := RSCanvas new .b addAll: (nodes collect: [ :n|	RSEllipse new		model: n;		size: 5;		color: (Color black alpha: 0.5)]).RSEdgeBuilder line	color: (Color gray alpha: 0.3);	canvas: b;	source: edges connectFrom: #key toAll: #value.RSForceBasedLayout on: b nodes.b"	| assocs allObjects |	allObjects := Set new.	assocs := objects flatCollect: [ :o |		| cc |		cc := toBlock rsValue: o.		cc collect: [ :ccc |			| t |			t := fromblock rsValue: o.			allObjects add: t; add: ccc.			t -> ccc ] ].	self objects: allObjects asArray.	^ self useAssociations: assocs! !!RSLineBuilder methodsFor: 'public - source' prior: 58904454!source: objects connectFromAll: fromBlock to: toBlock	"Define some edges from objects that are not part of the viewnbOfNodes := 40.nbOfRandomEdges := 40.nodes := 1 to: nbOfNodes.edges := (1 to: nbOfRandomEdges)				collect: [ :notUsed | {nodes atRandom . nodes atRandom} -> nodes atRandom ].b := RSCanvas new .b addAll: (nodes collect: [ :n|	RSEllipse new		model: n;		size: 5;		color: (Color black alpha: 0.5)]).RSEdgeBuilder line	color: (Color gray alpha: 0.3);	canvas: b;	source: edges connectFromAll: #key to: #value.RSForceBasedLayout on: b nodes.b"	| assocs allObjects |	allObjects := Set new.	assocs := objects flatCollect: [ :o |		| cc |		cc := fromBlock rsValue: o.		cc collect: [ :ccc |			| t |			t := toBlock rsValue: o.			allObjects add: ccc; add: t.			ccc -> t ] ].	self objects: allObjects asArray.	^ self useAssociations: assocs! !!RSLineBuilder methodsFor: 'accessing' prior: 58901065!toObjects: someObjectsOrABlock	"Identify the elements we are considering for the edge building process. Note that the view has to be set beforehand."	self assert: [ canvasHasBeenManuallySet ] description: 'A view has to be set, please use #view:'.	(someObjectsOrABlock isCollection and: [ someObjectsOrABlock isSymbol not ])		ifTrue: [ self toShapes: (canvas shapesFromModels: someObjectsOrABlock) ]		ifFalse: [ self toShapes: (canvas nodes select: [ :el | someObjectsOrABlock rsValue: el model ]) ]! !!RSLineBuilder methodsFor: 'public - associations' prior: 58900441!useAssociation: assoc	"assoc have to be between model objects"	| result |	self assert: [ assoc isKindOf: Association ] description: 'Please, provide an association instead'.	result := self useAssociations: (Array with: assoc).	result ifEmpty: [ ^ nil ].	^ result first! !!RSLineBuilder methodsFor: 'public - associations' prior: 58908416!useAssociations: associations	"Draw edges between shapes using associations. Each association has to follow the pattern: startmodel -> endmodelFor example```b := RSCanvas  new.b addAll: (RSCircle models: (1 to: 3)).RSLineBuilder line	color: Color red translucent;	canvas: b;	withVerticalAttachPoint;	noRepetition;	useAssociations: { 1 -> 2 . 2 -> 3 . 1 -> 2}.RSForceBasedLayout on: b nodes.b @ RSCanvasController.b open```"	| fromElement toElement |	createdEdges := RSGroup new.	associations do: [ :assoc |		fromElement := self fromShapes shapeFromModel: assoc key.		toElement := self toShapes shapeFromModel: assoc value.		(fromElement notNil and: [ toElement notNil ])			ifTrue: [ self createEdgeIfNecessaryFrom: fromElement to: toElement ] ].	self moveBehindIfNecessary: createdEdges.	^ createdEdges! !!RSLineBuilder methodsFor: 'instance creation' prior: 58905782!verticalLine: aShape	^ (self shape: aShape)		controlPointsController: RSVerticalCPAPController new;		yourself! !!RSLineBuilder methodsFor: 'public - attach point' prior: 58895755!withBorderAttachPoint	"Make the produced line use a border attach point. For example:-=-=-=-=-=-=-=-=-=-=c := RSCanvas new.from := RSBox new size: 30; model: 'from'.to := RSEllipse new size: 30; model: 'to'.c add: from.c add: to.RSEdgeBuilder line	canvas: c;	withBorderAttachPoint;	connectFrom: 'from' to: 'to'.from @ RSDraggable.to @ RSDraggable.to translateTo: 50 @ 40.c @ RSCanvasController-=-=-=-=-=-=-=-=-=-=	"	self attachPoint: RSBorderAttachPoint new! !!RSLineBuilder methodsFor: 'public - attach point' prior: 58893735!withHorizontalAttachPoint	"Make the produced line use a vertical attach point. For example:-=-=-=-=-=-=-=-=-=-=c := RSCanvas new.from := RSBox new size: 30; model: 'from'.to := RSEllipse new size: 30; model: 'to'.c add: from.c add: to.RSEdgeBuilder line	canvas: c;	withHorizontalAttachPoint;	connectFrom: 'from' to: 'to'.from @ RSDraggable.to @ RSDraggable.to translateTo: 50 @ 40.c @ RSCanvasController-=-=-=-=-=-=-=-=-=-=	"	self attachPoint: RSHorizontalAttachPoint new! !!RSLineBuilder methodsFor: 'public - attach point' prior: 58896558!withVerticalAttachPoint	"Make the produced line use a vertical attach point. For example:```c := RSCanvas new.from := RSBox new size: 30; model: 'from'.to := RSEllipse new size: 30; model: 'to'.c add: from.c add: to.RSEdgeBuilder line	canvas: c;	withVerticalAttachPoint;	connectFrom: 'from' to: 'to'.from @ RSDraggable.to @ RSDraggable.to translateTo: 50 @ 40.c @ RSCanvasController```	"	self attachPoint: RSVerticalAttachPoint new! !!GEllipse methodsFor: '*Roassal3-Shapes' prior: 27524330!rsScaleWith: anAthensAffineTransform	| m |	m := anAthensAffineTransform.	^ self class		center: (m transform: center)		vertex: (m transform: coVertex)		coVertex: (m transform: vertex)! !!RSShortestVerticalAttachPoint methodsFor: 'public - hooks' prior: 59236290!basicEndingPointOf: aLine	| r1 r2 off p1 p2 center |	r1 := aLine from globalEncompassingRectangle.	r2 := aLine to globalEncompassingRectangle.	off := 0@endOffset.	p1 := r2 topCenter - off.	p2 := r2 bottomCenter + off.	center := r1 floatCenter.	^ (p1 distanceTo: center) < (p2 distanceTo: center)		ifTrue: [ p1 ]		ifFalse: [ p2 ]! !!RSShortestVerticalAttachPoint methodsFor: 'public - hooks' prior: 59235871!basicStartingPointOf: aLine	| r1 r2 off p1 p2 center |	r1 := aLine from globalEncompassingRectangle.	r2 := aLine to globalEncompassingRectangle.	off := 0@startOffset.	p1 := r1 topCenter - off.	p2 := r1 bottomCenter + off.	center := r2 floatCenter.	^ (p1 distanceTo: center) < (p2 distanceTo: center)		ifTrue: [ p1 ]		ifFalse: [ p2 ]! !!RSBezier methodsFor: 'testing' prior: 58350660!basicIncludesPoint: aPoint	"Not perfect but close enough"	| cp lines ir |	cp := self controlPoints.	ir := self includedRadius.	cp size = 2 ifTrue: [		^ aPoint			onLineFrom: cp first			to: cp second			within: ir		 ].	lines := self lines.	lines ifNil: [ ^ false ].	^ (1 to: lines size - 1) anySatisfy: [ :i |		| p1 p2 |		p1 := lines at: i.		p2 := lines at: i + 1.		(aPoint			onLineFrom: p1			to: p2			within: ir )		 ]! !!RSBezier methodsFor: 'visiting' prior: 58351917!buildPathOn: visitor	visitor buildBezierPath: self! !!RSBezier methodsFor: 'accessing' prior: 58351151!controlPoints: anArrayOfPoints	self		assert: anArrayOfPoints notNil		description: 'The argument can not be nil';		assert: (anArrayOfPoints size between: 2 and: 4)		description: 'The array size must be between 2 and 4 points'.	super controlPoints: anArrayOfPoints! !!RSBezier methodsFor: 'initialization' prior: 58350547!initialize	super initialize.	controlPoints := { 0@0. 100@100 }! !!RSBezier methodsFor: 'private' prior: 58351468!lines	| c b a via1 via2 start end cp |	cp := controlPoints.	cp size <3 ifTrue: [ ^ nil ].	start := cp first.	via1 := cp second.	via2 := cp third.	end := cp size = 3		ifTrue: [ via2 ]		ifFalse: [ cp fourth ].	c := 3 * (via1 - start).	b := 3 * (via2 - via1) - c.	a := end - start - c - b.	^ (0 to: 1 by: 0.2) collect: [ :t |		a * (t raisedTo: 3) + (b * (t * t)) + (c * t) + start.		]! !!RSAbstractLine methodsFor: 'accessing' prior: 58208058!basicTranslateBy: delta	^ self subclassResponsibility! !!RSAbstractLine methodsFor: 'accessing-computed'!colorFromString: aString	| colorList |	colorList := {		#r. Color red. 		#g. Color green.		#b. Color blue.		#c. Color cyan.		#m. Color magenta.		#y. Color yellow.		#k. Color black.		#w. Color white.	}.	colorList pairsDo: [ 		:colorSymbol :colorValue |		(aString includesSubstring: colorSymbol) ifTrue: [ ^colorValue  ]].	^ self color. "Default case, when it isn't found the color in the list"! !!RSAbstractLine methodsFor: 'accessing' prior: 58215063!computeEncompassingRectangle	| cp |	cp := self controlPoints.	^ cp			ifEmpty: [ 0@0 corner: 0@0 ]			ifNotEmpty: [ Rectangle encompassing: cp ]! !!RSAbstractLine methodsFor: 'style - dashes' prior: 58215272!dashArray: arrayOfNumbers	self border dashArray: arrayOfNumbers! !!RSAbstractLine methodsFor: 'style - dashes' prior: 58214827!dashed	self dashArray: #(4)! !!RSAbstractLine methodsFor: 'accessing'!format: aString	"Format for lines a shortcut to define a line styles, or markers	For markers use	'o' - circle	'^' - arrow	's' - square	'p' - pentagon	'h' - hexagon	'+' - plus	'd' - diamond	'*' - star	For stroke styles use:	'--' dashed line.	'-.' dashed line with small line then point	'.' dashed line with points	Example:```| canvas |canvas := RSCanvas new.canvas add: (RSLine new	startPoint: 0@0;	endPoint: 100@0;	fmt:'-.*';	color: Color red;	yourself).canvas @ RSCanvasController.canvas open````	 "	self color: (self colorFromString: aString).	(RSShapeFactory shapeFromString: aString) ifNotNil: [ :markerShape |		markerShape			size: self border width * self markerSizeScale;			color: self color.		self marker: markerShape ].	(RSStrokeStyle fromString: aString) ifNotNil: [ :style |		self border style: style ]! !!RSAbstractLine methodsFor: 'initialization' prior: 58214917!initialize	super initialize.	self		withBorder;		noPaint;		withCenteredAttachPoint! !!RSAbstractLine methodsFor: 'testing' prior: 58209211!intersects: aRectangle	| rect res globalMatrix |	self isInACanvas ifFalse: [ ^ false ].	globalMatrix := self parent globalMatrix.	rect := self		computeEncompassingRectangleFor: self encompassingRectangle		matrix: globalMatrix.	res := rect intersects: aRectangle.	res ifTrue: [ ^ true ].	self hasMarkers ifFalse: [ ^ false ].	self markerShapesInPositionDo: [ :m |		rect := self			computeEncompassingRectangleFor: m shape encompassingRectangle			matrix: globalMatrix.		(rect intersects: aRectangle) ifTrue: [ ^ true ].		 ].	^ false! !!RSAbstractLine methodsFor: 'accessing'!markerSizeScale	^ 4! !!RSAbstractLine methodsFor: 'event handling' prior: 58208744!notifyExtentChanged	self announce: [ RSExtentChangedEvent new		shape: self;		oldExtent: nil;		newExtent: self controlPoints first - self controlPoints last ]! !!RSAbstractLine methodsFor: 'accessing - markers' prior: 58211355!privateMarkers: array	markers := array! !!RSAbstractLine methodsFor: 'adding' prior: 58209027!remove	parent ifNil: [ ^ self ].	parent removeEdge: self.	self		removeFromParent: to;		removeFromParent: from.	super remove! !!RSAbstractLine methodsFor: 'private' prior: 58216749!removeFromParent: aShape	aShape ifNil: [ ^ self ].	aShape isPoint ifTrue: [ ^ self ].	aShape connectedLines remove: self ifAbsent: [  ]! !!RSAbstractLine methodsFor: 'adding' prior: 58217346!renderOn: aCanvas	aCanvas addEdge: self.	self update! !!RSAbstractLine methodsFor: 'path' prior: 58215478!sessionChanged	"This method releases all the native graphical resources. This method is typically invoked when starting a Pharo image with a visualization that was previously open"	self resetPath.	self hasMarkers ifFalse: [ ^ self ].	self markersDo: [ :mark | mark shape sessionChanged ]! !!RSAbstractLine methodsFor: 'accessing' prior: 58215919!strokePaint: aPaint	self border paint: aPaint.	self markersDo: [:m | m shape paint: aPaint ]! !!RSAbstractLine methodsFor: 'accessing' prior: 58211451!to	^ to! !!RSAbstractLine methodsFor: 'accessing' prior: 58213735!width: aNumber	self border width: aNumber! !!RSAbstractLine methodsFor: 'attach point' prior: 58209951!withBorderAttachPoint	self attachPoint: RSBorderAttachPoint new! !!RSAbstractLine methodsFor: 'attach point' prior: 58214338!withCenteredAttachPoint	self attachPoint: RSCenteredAttachPoint new! !!RSAbstractLine methodsFor: 'attach point' prior: 58209819!withHorizontalAttachPoint	self attachPoint: RSHorizontalAttachPoint new! !!RSAbstractLine methodsFor: 'attach point' prior: 58210613!withVerticalAttachPoint	self attachPoint: RSVerticalAttachPoint new! !!RSSmartHorizontalCPController methodsFor: 'utilities' prior: 59244868!attachPointForRectangle: aRectangle lineAngle: anAngle	| angleInDegrees |	angleInDegrees := anAngle radiansToDegrees.	(angleInDegrees between: -45 and: 45)		ifTrue: [ ^ aRectangle rightCenter ].	(angleInDegrees between: -135 and: -45)		ifTrue: [ ^ aRectangle topCenter ].	((angleInDegrees between: -180 and: -135) or: [ angleInDegrees between: 135 and: 180 ])		ifTrue: [ ^ aRectangle leftCenter ].	(angleInDegrees between: 45 and: 135)		ifTrue: [ ^ aRectangle bottomCenter ].	^ aRectangle floatCenter! !!RSSmartHorizontalCPController methodsFor: 'hooks' prior: 59245462!controlPointsFor: aLine	"return an array of points generated from the line"	| fromShape fromRectangle toShape toRectangle angle from to mid firstAnglePoint secondAnglePoint |	fromShape := aLine from.	toShape := aLine to.	fromRectangle := fromShape encompassingRectangle.	toRectangle := toShape encompassingRectangle.	angle := (toShape position - fromShape position) angle.	from := self attachPointForRectangle: fromRectangle lineAngle: angle.	angle := (fromShape position - toShape position) angle.	to := self attachPointForRectangle: toRectangle lineAngle: angle.	mid := (from + to) / 2.	firstAnglePoint := fromRectangle floatCenter x = from x		ifTrue: [ from x @ mid y ]		ifFalse: [ mid x @ from y ].	secondAnglePoint := toRectangle floatCenter x = to x		ifTrue: [ to x @ mid y ]		ifFalse: [ mid x @ to y ].	^ { from. firstAnglePoint. secondAnglePoint. to }! !!RSCanvas methodsFor: '*Roassal3-Shapes' prior: 58429116!asShape	"Convert a canvas as a composite shape. Note that all the shapes are removed from the canvas after the convertion. Here is an example:```canvas := RSCanvas new.5 timesRepeat: [	tmpCanvas := RSCanvas new.	someShapes := RSCircle models: (1 to: 50) forEach: [ :s :e | s size: 10 ].	tmpCanvas addAll: someShapes.	RSGridLayout on: tmpCanvas shapes.	tmpCanvas shapes color: Color random translucent.	canvas add: tmpCanvas asShape.].RSGridLayout on: canvas shapes.canvas @ RSCanvasController```Another example:```g1 := RSChart new.p1 := RSLinePlot new.p1 y: #(5 10 3 -4 -5 15).g1 addPlot: p1.g1 addDecoration: (RSXLabelDecoration new title: 'Time'; offset: 0 @ 10).g1 addDecoration: (RSYLabelDecoration new title: 'Value'; offset: -20 @ 0).g1 addDecoration: (RSHorizontalTick new).g1 addDecoration: (RSVerticalTick new).g1 build.g2 := RSChart new.p2 := RSLinePlot new.p2 y: #(2 10 50 -20 40 30 25 12 4).g2 addPlot: p2.g2 addDecoration: (RSXLabelDecoration new title: 'Time'; offset: 0 @ 10).g2 addDecoration: (RSYLabelDecoration new title: 'Value'; offset: -20 @ 0).g2 addDecoration: (RSHorizontalTick new).g2 addDecoration: (RSVerticalTick new).g2 build.c := RSCanvas new.c add: (g1 canvas asShape).c add: (g2 canvas asShape).RSHorizontalLineLayout on: c shapes.c @ RSCanvasController.c```	"	| g |	g := self shapes copy.	g do: #remove.	^ RSComposite new		shapes: g;		yourself! !!RSCanvas methodsFor: '*Roassal3-Shapes' prior: 58427348!asShapeModel: aModelObject	"Convert a canvas as a composite shape. Note that all the shapes are removed from the canvas after the convertion. Attach a model to the composite shape. Here is an example:Another example:```g1 := RSChart new.p1 := RSLinePlot new.p1 y: #(5 10 3 -4 -5 15).g1 addPlot: p1.g1 addDecoration: (RSXLabelDecoration new title: 'Time'; offset: 0 @ 10).g1 addDecoration: (RSYLabelDecoration new title: 'Value'; offset: -20 @ 0).g1 addDecoration: (RSHorizontalTick new).g1 addDecoration: (RSVerticalTick new).g1 build.g2 := RSChart new.p2 := RSLinePlot new.p2 y: #(2 10 50 -20 40 30 25 12 4).g2 addPlot: p2.g2 addDecoration: (RSXLabelDecoration new title: 'Time'; offset: 0 @ 10).g2 addDecoration: (RSYLabelDecoration new title: 'Value'; offset: -20 @ 0).g2 addDecoration: (RSHorizontalTick new).g2 addDecoration: (RSVerticalTick new).g2 build.c := RSCanvas new.c add: (g1 canvas asShapeModel: 1).c add: (g2 canvas asShapeModel: 2).RSHorizontalLineLayout on: c shapes.c shapes @ RSDraggable.lb := RSLineBuilder arrowedLine.lb withBorderAttachPoint.lb canvas: c.lb useAssociation: 1 -> 2.c @ RSCanvasController.c```	"	^ self asShape model: aModelObject! !!RSAbstractDualLine methodsFor: 'accessing' prior: 58189299!controlPoints	^ Array with: self startPoint with: self endPoint! !!RSAbstractDualLine methodsFor: 'accessing' prior: 58187868!endPoint: point	endPoint := point.	self resetPath.	self notifyExtentChanged! !!RSAbstractDualLine methodsFor: 'initialization' prior: 58188097!initialize	super initialize.	startPoint := 0@0.	endPoint := 100@100! !!RSAbstractDualLine methodsFor: 'accessing' prior: 58188007!startPoint	^ startPoint! !!RSAbstractDualLine methodsFor: 'update' prior: 58188225!update	"Note that before calling this method, an attach point has to be set. Consider the following example:```b1 := RSBox new size: 20.b2 := RSBox new size: 20.b1 translateTo: 20 @ 30.b2 translateTo: 40 @ 50.l := RSLine new from: b1; to: b2.l attachPoint: RSBorderAttachPoint new .l update.```Removing the call to #attachPoint: raised an error	"	(attachPoint isNil | from isNil | to isNil) ifTrue: [ ^ self ].	self		startPoint: (attachPoint startingPointOf: self);		endPoint: (attachPoint endingPointOf: self);		notifyExtentChanged! !!RSComposite class methodsFor: 'public - creation'!boxesForModels: aCollection	| box label |	box := RSBox new.	box color: Color white.	box border: (RSBorder new joinMiter; color: Color black).	label := RSLabel new.	label color: Color black.	^ self models: aCollection box: box label: label! !!RSComposite class methodsFor: 'public - creation' prior: 58542737!model: anObject forIt: twoArgsBlock	"This method returns a collection (RSGroup) of composite shapes, for which each shape is defined using the the twoArgsBlock. The variable twoArgsBlock points to a two argument block. The first argument is the object model, and the second argument is the composite.For example:```c := RSCanvas new.compoShape := RSComposite model: 'Hello' forIt: [ :composite :title |	composite add: (RSLabel text: title).	composite add: (RSCircle new size: 20).	RSVerticalLineLayout new alignCenter; on: composite shapes.	composite @ RSDraggable ].c add: compoShape.c open```"	^ (self models: (Array with: anObject) forEach: twoArgsBlock) first! !!RSComposite class methodsFor: 'public - creation'!models: aCollection box: boxShape label: labelShape	^ aCollection collect: [ :each |		| box label |		box := boxShape copy.		label := labelShape copy.		label text: each asString.		box extent: label extent + 5.		box position: 0@0.		label position: 0@0.		{ box. label } asShape			model: each;			yourself ] as: RSGroup! !!RSComposite class methodsFor: 'public - creation' prior: 58543488!models: someObjects forEach: twoArgsBlock	"This method returns a collection (RSGroup) of composite shapes, for which each shape is defined using the the oneArgBlock.For example:```classes := ByteArray withAllSubclasses.c := RSCanvas new.boxes := RSComposite models: classes forEach: [ :cls :c |	c add: (RSLabel new text: cls name).	c add: (RSBox new size: cls numberOfLinesOfCode sqrt).	c model: cls.	RSVerticalLineLayout new alignCenter; on: c shapes.	c @ RSDraggable.].c addAll: boxes.RSFlowLayout on: c shapes.lb := RSLineBuilder line.lb withVerticalAttachPoint.lb shapes: boxes.lb connectFrom: #superclass.RSTreeLayout on: c nodes.c @ RSCanvasController.c open```"	^ someObjects		  collect: [ :obj |				| t |		  		t := twoArgsBlock valueWithArguments: (Array with: (self model: obj) with: obj).				t adjustToChildren ]		  as: RSGroup! !!RSComposite methodsFor: 'adding' prior: 58538651!addShape: aShape before: otherShape	"Add a shape in a composite shape"	aShape addedIn: self.	self children		remove: aShape;		add: aShape before: otherShape! !!RSComposite methodsFor: 'public' prior: 58539895!adjustToChildren"Recompute the encompassing rectangle of the composite shape from the position of the children.In case one wishes to have a padding in the composite, the method #padding: must be called _after_ calling #adjustToChildrenConsider the following example:```Smalltalkbox := RSBox new size: 20.circle := RSEllipse new size: 20.g := RSGroup new.g add: box; add: circle.composite := g asShape.composite extent. '=> (20.0@20.0)'RSVerticalLineLayout on: g.composite extent. '=> (20.0@20.0)'composite adjustToChildren.composite extent '=> (20.0@50.0)'```"	| rect delta |	children ifNil: [ ^ self ].	rect := children encompassingRectangle.	delta := rect floatCenter negated.	children do: [ :s | s basicTranslateBy: delta ].	self		extent: rect extent.	self position = (0@0) ifTrue: [ self translateTo: delta negated ]! !!RSComposite methodsFor: 'accessing' prior: 58532310!children: aRSGroup	"	create a groups of elements or trachel shapes, then added them to this composite shape	this method changes the position of the shapes and set the position of this composite shape	to the center of the encompassingRectangle.	"	aRSGroup copy do: [ :s |		s isInACanvas			ifTrue: [ s remove ] ].	self addAll: aRSGroup.	self adjustToChildren! !!RSComposite methodsFor: 'copying' prior: 58533002!copyWithoutAnnouncer	| copy |	copy := self copy.	copy privateShapes: (self children collect: [ :child |		child copyWithoutAnnouncer			parent: copy;			yourself ]).	copy privateNodes: #().	copy privateEdges: #().	^ copy! !!RSComposite methodsFor: 'initialization' prior: 58538870!initialize	super initialize.	self paint: nil.	self clipChildren: false.	self resetPath! !!RSComposite methodsFor: 'accessing' prior: 58531174!padding: anObject	"Set the padding, i.e., the distance between the nested shapes and the outter composite shape.The argument, anObject can be a number, a point or Margin.IMPORTANT:- The shapes must be added in the composite before calling #padding:- The padding must be set after having performed #adjustToChildrenHere is an example of usage:```Smalltalkbox := RSBox new    color: Color blue translucent;    fromRectangle: ((-38.5@ -20.0) corner: (38.5@20.0));    yourself.label := RSLabel new    text: 'Smalltalk';    yourself.g := RSGroup new.g add: box.g add: label.composite := g asShape.composite padding: 20.composite color: Color red.c := RSCanvas new.c add: composite.c```	"	| margin rect center temp |	temp := children		ifNil: [ RSGroup new: 0 ]		ifNotNil: [children].	margin := anObject asMargin.	rect := temp encompassingRectangle.	rect := margin expandRectangle: rect.	self extent: rect extent.	(center := rect floatCenter) = (0@0) ifTrue: [ ^ self ].	center := center negated.	temp do: [ :s | s basicTranslateBy: center ]! !!RSComposite methodsFor: 'actions' prior: 58528966!pushFront: shape	children		remove: shape ifAbsent: [];		addLast: shape! !!RSComposite methodsFor: 'removing' prior: 58533768!removeShape: shape	| evt |	children remove: shape.	shape parent: nil.	evt := RSShapeRemovedEvent new shape: shape.	self announce: evt.	shape announce: evt! !!RSComposite methodsFor: 'public' prior: 58530386!resetChildren	children := nil! !!RSComposite methodsFor: 'public' prior: 58529466!resizeWithChildrenTo: aPointExtent	self scaleBy: aPointExtent / self baseRectangle extent! !!RSComposite methodsFor: 'accessing - computed' prior: 58537821!shapeWithAction: eventClass forPosition: position	| res pos |	pos := self matrix rsInverseTransform: position.	self shapes reverseDo: [ :s |		res := s shapeWithAction: eventClass forPosition: pos.		res ifNotNil: [ ^ res] ].	^ super shapeWithAction: eventClass forPosition: position! !!RSComposite methodsFor: 'accessing - computed' prior: 58535401!shapeWithActionForPosition: position	| res pos |	pos := self matrix rsInverseTransform: position.	self shapes reverseDo: [ :s |		res := s shapeWithActionForPosition: pos.		res ifNotNil: [ ^ res] ].	^ super shapeWithActionForPosition: position! !!RSComposite methodsFor: 'edges - deprecated' prior: 58536171!updateConnectedEdges	"Update the edge connected to elements contained in the composite. This happens when a shape is drag and dropped. For example:-=-=-=-=-=-=-=-=-=c := RSCanvas new.c add: (RSLabel new text: 'I am connected to'; model: 0).c shapes first translateBy: -50 @ 50.g := RSGroup new.g add: (RSLabel new text: '1'; model: 1).g add: (RSLabel new text: '2'; model: 2).RSHorizontalLineLayout on: g.composite := g asShape.composite color: Color lightBlue.c add: composite.c shapes @ RSDraggable.c add: (RSLine new color: Color red; from: c shapes first; to: g first).c add: (RSLine new color: Color red; from: c shapes first; to: g second).c @ RSCanvasController-=-=-=-=-=-=-=-=-="	self shouldUpdateEdges		ifTrue: [ connectedLines do: [ :edge | edge update ] ].	self children do: [ :child |		child isNode			ifTrue: [ child updateConnectedEdges ] ]! !!RSComposite methodsFor: 'lines' prior: 58540999!updateConnectedLines	"Update the lines connected to elements contained in the composite. This happens when a shape is drag and dropped. For example:```c := RSCanvas new.c add: (RSLabel new text: 'I am connected to'; model: 0).c shapes first translateBy: -50 @ 50.g := RSGroup new.g add: (RSLabel new text: '1'; model: 1).g add: (RSLabel new text: '2'; model: 2).RSHorizontalLineLayout on: g.composite := g asShape.composite color: Color lightBlue.c add: composite.c shapes @ RSDraggable.c add: (RSLine new color: Color red; from: c shapes first; to: g first).c add: (RSLine new color: Color red; from: c shapes first; to: g second).c @ RSCanvasController```"	self shouldUpdateLines		ifTrue: [ connectedLines do: [ :line | line update ] ].	self children do: [ :child |		child isNode			ifTrue: [ child updateConnectedLines ] ]! !!RSBorder methodsFor: 'comparing' prior: 58359216!= anObject	^ self == anObject or: [		anObject notNil and: [			width = anObject width and: [				paint = anObject paint and: [					style = anObject style ] ] ] ]! !!RSBorder methodsFor: 'style - cap' prior: 58357561!capButt	self pStyle capStyle: #capButt! !!RSBorder methodsFor: 'style - cap' prior: 58357750!capRound	self pStyle capStyle: #capRound! !!RSBorder methodsFor: 'style - cap' prior: 58359436!capSquare	self pStyle capStyle: #capSquare! !!RSBorder methodsFor: 'accessing' prior: 58359530!color: aColor	"Set a color to the border. The color is provided as argument, and can be either a color object (e.g., `Color red`) or a symbol (e.g., `#yellow`)."	paint := aColor.	paint isColor ifTrue: [ ^ self ].	paint := Color colorFrom: aColor! !!RSBorder methodsFor: 'style - dashes' prior: 58358316!dashArray: arrayOfNumbers	"Set the pattern for the dash. For example:-=-=-=-=-=-=-=-=-=-=-=-=c := RSCanvas new.b := RSBorder new color: Color blue.b dashArray: #(1 5 10 15).(30 to: 60) do: [ :nb |	box := RSBox new size: nb.	ellipse := RSEllipse new width: nb; height: nb + 10.	box border: b.	ellipse border: b.	c add: box; add: ellipse.	 ].RSFlowLayout on: c shapes.c @ RSControlsCanvas.c-=-=-=-=-=-=-=-=-=-=-=-=	"	self pStyle dashArray: arrayOfNumbers! !!RSBorder methodsFor: 'accessing' prior: 58360135!dashOffset: offset	"Set the offset for the dash. The offset is useful when animating.```Smalltalkc := RSCanvas new.b := RSBorder new color: Color blue.b dashArray: #(5 1 5).(30 to: 60) do: [ :nb |	box := RSBox new size: nb.	ellipse := RSEllipse new width: nb; height: nb + 10.	box border: b.	ellipse border: b.	c add: box; add: ellipse.	 ].RSFlowLayout on: c shapes.c @ RSControlsCanvas.c newAnimation	from: 0;	to: 40;	on: b set: #dashOffset:.c```	"	self pStyle dashOffset: offset! !!RSBorder methodsFor: 'initialization' prior: 58358132!initialize	super initialize.	paint := Color gray.	width := 1! !!RSBorder methodsFor: 'private' prior: 58359828!pStyle	^ style ifNil: [ style := RSStrokeStyle new ]! !!RSBorder methodsFor: 'accessing' prior: 58358246!paint	^ paint! !!RSBorder methodsFor: 'printing' prior: 58358840!printOn: stream	width printOn: stream.	stream nextPutAll: ', '.	paint printOn: stream.	style ifNil: [ ^ self ].	stream nextPutAll: ', '.	style printOn: stream! !!RSBorder methodsFor: 'accessing' prior: 58361456!width	^ width! !!RSBorder methodsFor: 'accessing' prior: 58360694!width: anInteger	"Set the width of the border.For example:```Smalltalkc := RSCanvas new.shapes := (1 to: 30) collect: [ :v | RSBox new border: (RSBorder new color: Color red; width: 3); model: v ] as: RSGroup.c addAll: shapes.shapes @ RSPopup.RSNormalizer size	shapes: shapes;	normalize: #yourself.interaction := RSHighlightable new.interaction highlightColor: Color blue.interaction highlightBorder: (RSBorder new color: Color black; width: 3).shapes @ interaction.RSGridLayout on: shapes.c @ RSCanvasController```	"	width := anInteger! !!RSBoundingShape class methodsFor: 'accessing' prior: 58382468!models: someObjects size: aOneArgBlockOrSymbol	"Create a RSGroup made of shapes. Each shape has an element of the argument as model and a size.For example:```c := RSCanvas new.shapes := RSCircle models: (30 to: 50) size: [ :nb | nb ].c addAll: shapes.lines := RSEdgeBuilder line	canvas: c;	connectFrom: 30 toAll: (31 to: 50).lines do: [ :l | l attachPoint: (RSHorizontalAttachPoint new) ].RSGridLayout on: shapes.RSLocation new	above;	move: shapes first on: shapes allButFirst.shapes @ RSDraggable.c @ RSCanvasController.c open```"	^ someObjects		  collect: [ :obj |		  (self model: obj) size: (aOneArgBlockOrSymbol rsValue: obj) ]		  as: RSGroup! !!RSBoundingShape methodsFor: 'edges - deprecated' prior: 58367434!addConnectedEdge: anEdge	self assert: anEdge isEdge.	(self connectedEdges includes: anEdge)		ifFalse: [ self connectedEdges add: anEdge ]! !!RSBoundingShape methodsFor: 'lines' prior: 58379877!addConnectedLine: aLine	self assert: [ aLine isLine ] description: 'Only a line can be added'.	(self connectedLines includes: aLine)		ifFalse: [ self connectedLines add: aLine ]! !!RSBoundingShape methodsFor: 'private' prior: 58375195!allRecursiveConnectedShapesIn: aCollection	"Private method"	"If we already went through me, there is nothing to do"	(aCollection includes: self) ifTrue: [ ^ self ].	"Else, we add it and we do the recursion"	aCollection add: self.	self incomingShapes do: [ :s | s allRecursiveConnectedShapesIn: aCollection ].	self outgoingShapes do: [ :s | s allRecursiveConnectedShapesIn: aCollection ]! !!RSBoundingShape methodsFor: 'matrix' prior: 58368770!basicTranslateBy: delta	self updateLinesOFF.	self position: self position + delta.	self updateLinesON! !!RSBoundingShape methodsFor: 'accessing' prior: 58379645!computeEncompassingRectangle	^ self computeEncompassingRectangleFor: self baseRectangle! !!RSBoundingShape methodsFor: 'accessing' prior: 58374875!computeEncompassingRectangleFor: rect	^ self computeEncompassingRectangleFor: rect matrix: self matrix! !!RSBoundingShape methodsFor: 'accessing' prior: 58369518!extent: aPoint	| oldExtent extent |	extent := baseRectangle extent.	extent = aPoint ifTrue: [ ^ self ].	self assert: aPoint isPoint.	oldExtent := extent.	baseRectangle := Rectangle floatCenter: 0@0 extent: aPoint.	self resetBBox; resetPath.	self announce: [ RSExtentChangedEvent new		shape: self;		oldExtent: oldExtent;		newExtent: extent ]! !!RSBoundingShape methodsFor: 'initialization' prior: 58375655!fromRectangle: aRectangle	"Set the position and extent of the shape, using a rectangle as argument.For example:```c := RSCanvas new.box := RSBox new.box fromRectangle: (10 @ 10 corner: 50 @ 40).c add: box.c```"	self		translateTo: aRectangle floatCenter;		extent: aRectangle extent! !!RSBoundingShape methodsFor: 'geometry' prior: 58371950!geometry	| rect e |	rect := self encompassingRectangle.	e := rect extent.	e = (0@0) ifTrue: [ ^ rect floatCenter asGPoint ].	^ GRectangle		origin: rect origin		corner: rect corner! !!RSBoundingShape methodsFor: 'accessing' prior: 58372539!globalEncompassingRectangle	^ self		computeEncompassingRectangleFor: self baseRectangle		matrix: self globalMatrix! !!RSBoundingShape methodsFor: 'matrix' prior: 58380318!globalMatrix	^ parent globalMatrix multiplyBy: matrix! !!RSBoundingShape methodsFor: 'testing' prior: 58376188!includesPoint: aPoint	"Return true if the provided point is included in the shape"	"First we check if the encompassingRectangle has the point. If the point is outside, there is not need to transform the point"	(self encompassingRectangle containsPoint: aPoint)		ifFalse: [ ^ false ].	^ self preciseIncludesPoint: aPoint! !!RSBoundingShape methodsFor: 'initialization' prior: 58379450!initialize	super initialize.	self initializeMatrix; updateEdgesON.	baseRectangle := 0@0 corner: 0@0.	self extent: self defaultExtent! !!RSBoundingShape methodsFor: 'matrix' prior: 58368055!matrixDo: aBlock	aBlock value: matrix.	self resetBBox! !!RSBoundingShape methodsFor: 'matrix' prior: 58377620!position	^ matrix translation! !!RSBoundingShape methodsFor: 'matrix' prior: 58368465!position: aPoint	"This method is private. Use #translateTo: instead."	self		assert: [ (aPoint x isNaN | aPoint y isNaN) not ]		description: 'you must provide a real point'.	matrix translation: aPoint.	self resetBBox.	self updateConnectedLines! !!RSBoundingShape methodsFor: 'accessing' prior: 58381377!positionInCanvas	^ self globalMatrix transform: 0@0! !!RSBoundingShape methodsFor: 'testing' prior: 58377266!preciseIncludesPoint: aPoint	"Return true if the provided point is precisily included in the shape. Taking care of the transformation (aka scaling, position, rotation)"	| invertedPoint |	invertedPoint := matrix rsInverseTransform: aPoint.	^ self baseRectangle containsPoint: invertedPoint! !!RSBoundingShape methodsFor: 'matrix' prior: 58380736!rotateByDegrees: angle	"Rotate the shape. Here is an example:```c := RSCanvas new.polygon := RSPolygon new		points: { 0 @ -50 . 50 @ 0 . -50 @ 0 };		color: 'FFAE0B'.polygon cornerRadii: 5.polygon rotateByDegrees: -45.c add: polygon.c```Another example:```c := RSCanvas new.(0 to: 90 count: 10) do: [ :rotation |	lbl := RSLabel text: 'Hello world'.	lbl color: Color gray translucent.	lbl rotateByDegrees: rotation.	lbl @ RSHighlightable red.	lbl translateTopLeftTo: 0 @ 0.	c add: lbl	 ].c @ RSCanvasController.c open```	"	matrix rotateByDegrees: angle! !!RSBoundingShape methodsFor: 'matrix' prior: 58370218!scaleBy: scale	"Scale the shape. For example:```c := RSCanvas new.polygon := RSPolygon new		points: { 0 @ -50 . 50 @ 0 . -50 @ 0 };		color: 'FFAE0B'.polygon cornerRadii: 5.polygon rotateByDegrees: -45.polygon scaleBy: 4.c add: polygon.c```	"	matrix scaleBy: scale.	self resetBBox! !!RSBoundingShape methodsFor: 'actions' prior: 58371438!translateBottomLeftTo: aPositionAsPoint	"Translate the shape to make the top left corner at a given position```c := RSCanvas new.lbl := RSLabel text: 'Top left corner'.c add: lbl.lbl translateBottomLeftTo: 0 @ 0.dot := RSCircle new.c add: dot.c zoomToFit.c open```"	self translateTo: aPositionAsPoint + ((self extent / 2) * (1 @ -1))! !!RSBoundingShape methodsFor: 'actions' prior: 58377923!translateBottomRightTo: aPositionAsPoint	"Translate the shape to make the top left corner at a given position```c := RSCanvas new.lbl := RSLabel text: 'Top left corner'.c add: lbl.lbl translateBottomRightTo: 0 @ 0.dot := RSCircle new.c add: dot.c zoomToFit.c open```"	self translateTo: aPositionAsPoint + ((self extent / 2) * (-1 @ -1))! !!RSBoundingShape methodsFor: 'actions' prior: 58373293!translateMiddleRightTo: aPositionAsPoint	"Translate the shape to make the middle right position at a given position```c := RSCanvas new.center := RSEllipse new size: 2; color: Color red.c add: center.center translateTo: 0 @ 0.lbl := RSLabel text: 'Middle right corner'.c add: lbl.lbl translateMiddleRightTo: 0 @ 0.c @ RSCanvasController.c open```"	self translateTo: aPositionAsPoint - ((self extent x / 2) @ 0)! !!RSBoundingShape methodsFor: 'actions' prior: 58373885!translateTopLeftTo: aPositionAsPoint	"Translate the shape to make the top left corner at a given position```c := RSCanvas new.lbl := RSLabel text: 'Top left corner'.c add: lbl.lbl setAsFixed.lbl translateTopLeftTo: 0 @ 0.c open```"	self translateTo: aPositionAsPoint + (self extent / 2)! !!RSBoundingShape methodsFor: 'actions' prior: 58372714!translateTopRightTo: aPositionAsPoint	"Translate the shape to make the top left corner at a given position```c := RSCanvas new.lbl := RSLabel text: 'Top right corner'.c add: lbl.lbl translateTopRightTo: 0 @ 0.dot := RSCircle new.c add: dot.c zoomToFit.c open```"	self translateTo: aPositionAsPoint + ((self extent / 2) * (-1 @ 1))! !!RSBoundingShape methodsFor: 'edges - deprecated' prior: 58376016!updateConnectedEdges	self shouldUpdateEdges		ifFalse: [ ^ self ].	self connectedEdges do: [ :edge | edge update ]! !!RSBoundingShape methodsFor: 'lines' prior: 58382100!updateConnectedLines	self shouldUpdateLines		ifFalse: [ ^ self ].	self connectedLines do: [ :line | line update ]! !!RSEdgeBuilder methodsFor: 'documentation' prior: 58619017!README	"This class is voluntarily empty"! !!RSCornerRadius methodsFor: 'accessing' prior: 58558912!bottomLeft	"Define the bottom left of the radius"	^ bottomLeft! !!RSCornerRadius methodsFor: 'accessing' prior: 58559448!bottomRight	^ bottomRight! !!RSCornerRadius methodsFor: 'initialization' prior: 58559536!initialize	super initialize.	self radius: 0! !!RSCornerRadius methodsFor: 'accessing' prior: 58559638!topLeft	^ topLeft! !!RSStrokeStyle class methodsFor: 'instance creation' prior: 59250672!fromString: aString	| inst |	inst := self new.	(aString includesSubstring: '--')		ifTrue: [ ^ inst dashArray: #(4 2) ].	(aString includesSubstring: '-.')		ifTrue: [ ^ inst dashArray: #(4 1 1 1) ].	(aString includesSubstring: '.')		ifTrue: [ ^ inst dashArray: #(1) ].	^ nil! !!RSStrokeStyle methodsFor: 'comparing' prior: 59249831!= anObject	^ self == anObject or: [		anObject notNil and: [			capStyle = anObject capStyle and: [				joinStyle = anObject joinStyle and: [					dashOffset = anObject dashOffset and: [						dashArray = anObject dashArray ] ] ] ] ]! !!RSPolygon class methodsFor: 'utilities' prior: 59046725!fitPolygonToSquare: points	| maxx minx maxy miny sx sy x y |	minx := maxx :=  points first x.	miny := maxy :=  points first y.	points do: [ :p |		minx := minx min: p x.		miny := miny min: p y.		maxx := maxx max: p x.		maxy := maxy max: p y ].	"stretch factors"	sx := 2/(maxx - minx).	sy := 2/(maxy - miny).	points doWithIndex: [ :p :i|		x := p x * sx.		y := p y * sy.		points at: i put: x@y.		minx := minx min: x.		miny := miny min: y.		maxx := maxx max: x.		maxy := maxy max: y ].	miny < -1 ifTrue: [		points doWithIndex: [ :p :i |			points at: i put: p x @ ( p y - 1 - miny ) ] ].	^ points! !!RSPolygon class methodsFor: 'utilities' prior: 59046494!generateUnitNgonPoints: sides rotation: rotationAngle	^ self generateUnitNgonPoints: sides  rotation: rotationAngle		angle: [ :a :i | a negated ]		radius: [ :a :i | 1 ]! !!RSPolygon class methodsFor: 'utilities' prior: 59045352!generateUnitNgonPoints: sides rotation: rotationAngle angle: angleBloc radius: radiusBloc	"sides a Number	rotation is a number in radians	angle is a function of 2 args(current angle and index of angle) this return an angle	radius is a function of 2 args (current angle and index of angle) this retunr a number "	| increment startAngle points currentAngle currentRadius |	increment := 1.0 / sides * 2 * Float pi.	startAngle := sides even		ifTrue: [ (Float pi / 2) + (increment / 2) ]		ifFalse: [ Float pi / 2 ].	startAngle := startAngle + rotationAngle.	points := Array new: sides.	0 to: sides - 1 do: [ :i |		currentAngle := i * increment + startAngle.		currentAngle := angleBloc value: currentAngle value: i.		currentRadius := radiusBloc value: currentAngle value: i.		points at: i+1 put: (currentAngle cos @ currentAngle sin) * currentRadius ].	^ points! !!RSPolygon methodsFor: 'private' prior: 59042541!centerPoints	"Private method, should not be used externally"	| r center |	r := points		ifEmpty: [ 0@0 corner: 0@0 ]		ifNotEmpty: [ Rectangle encompassing: points ].	center := r floatCenter.	points := points collect: [ :p | p - center ].	^ r! !!RSPolygon methodsFor: 'accessing' prior: 59042842!cornerRadii	"Return the corner radii, indicating how smooth the polygon corners shoulid be"	^ radius ifNil: [ 0 ]! !!RSPolygon methodsFor: 'accessing' prior: 59044823!cornerRadii: aNumber	"Set the corner radii. Has the effect to make corners smooth	For example:c := RSCanvas new.polygon := RSPolygon new		points: { 0 @ -50 . 50 @ 0 . -50 @ 0 };		color: 'FFAE0B'.polygon cornerRadii: 5.polygon2 := RSPolygon new		points: { 0 @ -50 . 50 @ 0 . -50 @ 0 };		color: Color red trans.polygon2 rotateByDegrees: 90.polygon2 translateBy: 0 @ -50.c add: polygon.c add: polygon2.c	"	radius := aNumber abs.	self resetPath! !!RSPolygon methodsFor: 'private' prior: 59043440!extent: newExtent	| min max s extent |	self hasPoints		ifFalse: [ ^ self ].	extent := baseRectangle extent.	extent = newExtent		ifTrue: [ ^ self ].	min := Float fmax asPoint.	max := Float fmin asPoint.	points do: [ :p |		min := min min: p.		max := max max: p ].	s := newExtent / (max - min).	points := points collect: [ :p | p * s ].	super extent: newExtent! !!RSPolygon methodsFor: 'initialization' prior: 59043014!initialize	super initialize.	points := #()! !!RSPolygon methodsFor: 'testing' prior: 59044450!preciseIncludesPoint: aPoint	"Return true or false if a point is contained in the shape"	| invertedPoint |	invertedPoint := matrix rsInverseTransform: aPoint.	^ (self baseRectangle containsPoint: invertedPoint)		ifFalse: [ false ]		ifTrue: [(AthensPolygonTester new			polygon: points) includesPoint: invertedPoint]! !!RSBitmap class methodsFor: 'instance creation'!newFrom: anObject	| shape |	shape := self new.	shape form: (anObject isString 		ifTrue: [ (self iconNamed: anObject) ]		ifFalse: [anObject ]).	^ shape			! !!RSBitmap methodsFor: 'private' prior: 58353652!computeRectangle	baseRectangle := Rectangle floatCenter: 0@0 extent: (form		ifNil: [ 0@0 ]		ifNotNil: [ form extent ]).	encompassingRectangle := nil! !!RSBitmap methodsFor: 'accessing' prior: 58353461!extent: newExtent	| oldExtent |	oldExtent := self extent.	(oldExtent = (0 @ 0)) ifTrue: [ ^ self ].	matrix scaleBy: newExtent / oldExtent.	self resetBBox.	! !!RSBitmap methodsFor: 'accessing' prior: 58353855!form: aForm	aForm ifNil: [ ^ self ].	form := aForm.	self computeRectangle! !!RSSelfLoopCPController methodsFor: 'hooks' prior: 59178080!controlPointsFor: aLine	| ap from to |	ap := aLine attachPoint.	aLine from = aLine to		ifTrue: [ ^ self selfLoopControlPointsFor: aLine ].	from := ap startingPointOf: aLine.	to := ap endingPointOf: aLine.	^ Array with: from with: to! !!GradientPaint class methodsFor: '*Roassal3-Shapes' prior: 27851032!fromArray: array	^ self new		colorRamp: (array collect: [ :as | as key -> (Color colorFrom: as value)]);		yourself! !!RSHorizontalCPAPController methodsFor: 'hooks' prior: 58769478!controlPointsFrom: from to: to	| mid |	mid := (from + to)/2.	^ Array		with: from		with: mid x @ from y		with: mid x @ to y		with: to! !!RSPieSlice methodsFor: 'accessing' prior: 59039319!alphaAngle: stAngle	"Starting angle"	| old |	old := alphaAngle.	alphaAngle := stAngle.	old = alphaAngle ifTrue: [ ^ self ].	self resetPath! !!RSPieSlice methodsFor: 'accessing' prior: 59038847!betaAngle: ndAngle	"Finishing angle"	| old |	old := betaAngle.	betaAngle := ndAngle.	old = betaAngle ifTrue: [ ^ self ].	self resetPath! !!RSPieSlice methodsFor: 'accessing' prior: 59038627!centroid: off	| r a |	r := (innerRadius + externalRadius)/2.	r := r + off.	a := self middleAngle degreesToRadians.	^ (a cos @ (a sin negated) * r) + self position! !!RSPieSlice methodsFor: 'accessing' prior: 59039672!cornerRadii: aNumber	| old |	self		assert: [ aNumber >= 0 ]		description: 'Corner radius must be a non-negative!!'.	old := cornerRadii.	cornerRadii := aNumber.	old = cornerRadii ifTrue: [ ^ self ].	self resetPath! !!RSPieSlice methodsFor: 'utilities' prior: 59038431!emphasizeWith: anInteger	| angle |	angle := self middleAngle degreesToRadians.	self translateBy: (angle cos @ angle sin negated) * anInteger! !!RSPieSlice methodsFor: 'accessing' prior: 59038295!extent: aPoint	super extent: aPoint.	externalRadius := (aPoint x min: aPoint y)/2! !!RSPieSlice methodsFor: 'accessing' prior: 59039117!externalRadius: eR	self extent: (eR * 2) asPoint! !!RSPieSlice methodsFor: 'initialization' prior: 59037946!initialize	super initialize.	cornerRadii := innerRadius := externalRadius := betaAngle := alphaAngle := segmentSpacing := 0! !!RSPieSlice methodsFor: 'accessing' prior: 59037531!innerRadius: iR	| old |	old := innerRadius.	innerRadius := iR asFloat.	old = innerRadius ifTrue: [ ^ self ].	self resetPath! !!RSPieSlice methodsFor: 'accessing' prior: 59037319!segmentSpacing: anAngleInDegrees	| old |	old := segmentSpacing.	segmentSpacing := anAngleInDegrees.	old = segmentSpacing ifTrue: [ ^self ].	self resetPath! !!RSPieSlice methodsFor: 'accessing' prior: 59037712!shiftAngles: aNumber	self		alphaAngle: alphaAngle + aNumber;		betaAngle: betaAngle + aNumber! !!RSMarker methodsFor: 'initialization' prior: 58967360!initialize	super initialize.	offset := 0.	offsetRatio := 0! !!RSMarker methodsFor: 'accessing' prior: 58967739!offsetRatio: aFloat	"Set the offset ratio of the marker. The argument is a float and has to range from 0 to 1.```c := RSCanvas new.box := RSBox new.circle := RSCircle new.c add: box; add: circle.box @ RSDraggable.circle @ RSDraggable.circle translateTo: 50 @ 40.line := RSLine new.line withBorderAttachPoint.marker := (RSCircle new size: 5; color: #red) asMarker.marker offsetRatio: 0.7.line marker: marker.line from: box.line to: circle.c add: line.c zoomToFit.c open```"	offsetRatio := aFloat! !!RSMarker methodsFor: 'public' prior: 58969128!setPositionTo: from vector: vector do: aBlock	| angle pos |	angle := vector angle.	angle := angle + Float halfPi.	pos := from.	shape matrix		loadIdentity;		rotateByRadians: angle.	(self offset isZero and: [ self offsetRatio isZero ]) ifFalse: [		| unit |		unit := vector / (vector r max: 1).		pos := pos - (vector * self offsetRatio) - (unit * self offset).		 ].	shape position: pos.	aBlock value: shape! !!RSMarker methodsFor: 'public' prior: 58967469!withEnd: controlPoints do: aBlock	| from to |	controlPoints size < 2 ifTrue: [ ^ self ].	from := controlPoints at: controlPoints size - 1.	to := controlPoints last.	self setPositionTo: to vector: to-from do: aBlock! !!RSMarker methodsFor: 'public' prior: 58968308!withStart: controlPoints do: aBlock	| from to |	controlPoints size < 2 ifTrue: [ ^ self ].	from := controlPoints first.	to := controlPoints second.	self setPositionTo: from vector: from - to do: aBlock! !!RSHorizontalLeftRightController methodsFor: 'hooks' prior: 58771735!controlPointsFrom: from to: to	| mid c1 c2 c3 c4 delta diff |	mid := (from + to)/2.	c1 := from.	c4 := to.	c2 := mid x @ c1 y.	c3 := c1 x @ c4 y.	delta := 10.	diff := mid x - (c1 x + delta).	diff < 0 ifTrue: [		c2 := c1 x - diff  @ c1 y.		c3 := c4 x + diff @ c4 y ].	^{ c1. c2. c3. c4 }! !!RSCenteredAttachPoint methodsFor: 'public - hooks' prior: 58465758!basicEndingPointOf: aLine	^ self positionFor: aLine to in: aLine! !!RSCenteredAttachPoint methodsFor: 'public - hooks' prior: 58465618!basicStartingPointOf: aLine	^ self positionFor: aLine from in: aLine! !!RSNormalizer class methodsFor: 'instance creation' prior: 58999107!color	"Define a linear color normalizer. For example:```Smalltalkvalues := 1 to: 5.c := RSCanvas new.shapes := values collect: [ :v | RSEllipse new size: 20; model: v ] as: RSGroup.c addAll: shapes.shapes @ RSPopup.RSNormalizer color	shapes: shapes;	normalize: #yourself.RSFlowLayout on: shapes.c```"	| n |	n := self new.	n from: Color green.	n to: Color red.	n executeBlock: [ :shape :scaledValue | shape color: scaledValue ].	^ n! !!RSNormalizer class methodsFor: 'instance creation' prior: 58999632!fontSize"Here is example```v := RSCanvas new.v @ RSCanvasController.shapes := RSLabel models: (Collection withAllSubclasses).shapes do: [ :e | e translateTo: (Random new nextInt: 300) @ (Random new nextInt: 300) ].v addAll: shapes.RSNormalizer fontSize	shapes: shapes;	to: 30;	normalize: #numberOfMethods.v zoomToFit.v open```"	| n |	n := self new.	n from: 5.	n to: 100.	n executeBlock: [ :shape :scaledValue | shape fontSize: scaledValue ].	^ n! !!RSNormalizer class methodsFor: 'instance creation' prior: 59000173!height	| n |	n := self new.	n from: 5.	n to: 100.	n executeBlock: [ :shape :scaledValue | shape height: scaledValue ].	^ n! !!RSNormalizer class methodsFor: 'instance creation' prior: 59000567!position	"Create a normalizer for position.Here is an example:-=-=-=classes := Collection withAllSubclasses.v := RSView new.es := RSShapeBuilder circle			color: (Color gray alpha: 0.3);			elementsOn: classes.es @ RSPopup.v addAll: es.RSNormalizer size	elements: es;	from: 5;	to: 20;	normalize: [ :cls | cls instVarNames size ].RSNormalizer position	to: 500 @ -500;	elements: es;	normalize: [ :cls | cls numberOfMethods @ cls linesOfCode ].v open-=-=-=and a more elaborated example:-=-=-=classes := Collection withAllSubclasses.v := RSView new.line := RSSingleEdgeBuilder polyline	width: 2;	controlPoints: { 0@ -600. 0@0. 600@0 };	markerStartEnd: (RSShapeBuilder triangle		size: 20;		color: Color black;		element);	edge.es := RSShapeBuilder circle	interactionDo: [ :i | i popup; browseable ];	border: TSBorder new;	color: TSColorPalette sequential orrd9;	elementsOn: classes.v addAll: es.v add: line.RSNormalizer size	from: 5;	to: 20;	elements: es;	normalize: [ :cls | cls instVarNames size ].RSNormalizer position	from: 0@0;	to: 600@ -600;	elements: es;	normalize: [ :cls | cls numberOfMethods @ cls linesOfCode ].v @ RSControlsView.v-=-=-=	"	| n |	n := self new.	n from: 0 @ 0.	n to: 100 @ 100.	n executeBlock: [ :shape :scaledValue | shape translateTo: scaledValue ].	^ n! !!RSNormalizer class methodsFor: 'instance creation' prior: 58998913!size	| n |	n := self new.	n from: 5.	n to: 100.	n executeBlock: [ :shape :scaledValue | shape size: scaledValue ].	^ n! !!RSNormalizer class methodsFor: 'instance creation' prior: 59000371!width	| n |	n := self new.	n from: 5.	n to: 100.	n executeBlock: [ :shape :scaledValue | shape width: scaledValue ].	^ n! !!RSNormalizer methodsFor: 'accessing' prior: 58996951!from: aValue	"Set the lower limit of the normalized value. For example:```Smalltalkv := RSCanvas new.classes := Collection withAllSubclasses.es := classes collect: [ :cls | RSEllipse new model: cls ] as: RSGroup.v addAll: es.es @ RSPopup @ RSDraggable.RSNormalizer size	shapes: es;	from: 5;	to: 20;	normalize: #numberOfMethods.RSNormalizer color	shapes: es;	to: Color pink;	normalize: #numberOfMethods.RSGridLayout on: es.v @ RSCanvasController.v```"	scale from: aValue! !!RSNormalizer methodsFor: 'normalizer' prior: 58997505!normalize	"Normalize the shapes assuming that each shape refers to a number```Smalltalkvalues := #(20 30 40 50 10).c := RSCanvas new.shapes := RSEllipse models: values.shapes @ RSPopup.c addAll: shapes.RSNormalizer size	shapes: shapes;	from: 20;	to: 30;	normalize.RSNormalizer color	shapes: shapes;	normalize.RSGridLayout new gapSize: 40; on: shapes.shapes @ RSLabeled.c @ RSCanvasController.c openOnce```"	self normalize: #yourself! !!RSNormalizer methodsFor: 'normalizer' prior: 58994341!normalize: anOneArgBlockOrSymbol	"Trigger the normalization using a particular metric to normalize.The metric is computed on each model of the shapes that are considered.For example:```Smalltalkvalues := #(20 30 40 50 10).c := RSCanvas new.shapes := RSEllipse models: values.shapes @ RSPopup.c addAll: shapes.RSNormalizer size	shapes: shapes;	from: 20;	to: 30;	normalize: #yourself.RSNormalizer color	shapes: shapes;	normalize: #yourself.RSGridLayout new gapSize: 40; on: shapes.shapes @ RSLabeled.c @ RSCanvasController.c openOnce```	"	| minAndMax |	minAndMax := self minAndMaxFor: anOneArgBlockOrSymbol.	scale domain: minAndMax.	shapes do: [ :shape |		| scaledValue objectValue |		objectValue := shape propertyAt: self key.		scaledValue := scale scale: objectValue.		executeBlock value: shape value: scaledValue ]! !!RSNormalizer methodsFor: 'accessing' prior: 58996231!scale	^ scale! !!RSNormalizer methodsFor: 'accessing' prior: 58995253!scale: aNSScale	"Set the scale of the normalizer. For example```Smalltalkc := RSCanvas new.shapes := (1 to: 150) collect: [ :n | RSEllipse new size: 20; model: n ] as: RSGroup.c addAll: shapes.RSGridLayout on: shapes.RSNormalizer color	shapes: shapes;	scale: NSScale category20b;	normalize: #yourself.c @ RSCanvasController.c```"	scale := aNSScale! !!RSNormalizer methodsFor: 'accessing' prior: 58998562!shapes	"Return the shapes that should be normalized"	^ shapes! !!RSNormalizer methodsFor: 'accessing' prior: 58998021!to: aValue	"Set the upper limit of the normalized value. For example:```Smalltalkv := RSCanvas new.classes := Collection withAllSubclasses.es := classes collect: [ :cls | RSEllipse new model: cls ] as: RSGroup.v addAll: es.es @ RSPopup @ RSDraggable.RSNormalizer size	shapes: es;	to: 20;	normalize: #numberOfMethods.RSNormalizer color	shapes: es;	to: Color pink;	normalize: #numberOfMethods.RSGridLayout on: es.v @ RSCanvasController.v```"	scale to: aValue! !!RSCustomCPController methodsFor: 'hooks' prior: 58562140!controlPointFor: model at: aLine	| point |	model isPoint ifTrue: [ ^ model ].	point  := model value.	(model isKindOf: RSShape) ifTrue: [		model addConnectedLine: aLine.		point := model position ].	^ point! !!RSCustomCPController methodsFor: 'hooks' prior: 58562410!controlPointsFor: aLine	^ self models collect: [ :m | self controlPointFor: m at: aLine ]! !!RSBox methodsFor: 'accessing' prior: 58387225!cornerRadius: aRSCornerRadius	"Set the radius of the corners. Accept a number as argument or a RSCornerRadius.	For example:```c := RSCanvas new.r := Random seed: 42.40 timesRepeat: [	box := RSBox new extent: (r nextInteger: 80) @ (r nextInteger: 80); color: Color gray; cornerRadius: 10.	box color: Color random translucent.	box translateTo: (r nextInteger: 200) @ (r nextInteger: 200).	c add: box.].c @ RSCanvasController.c open```"	cornerRadius := aRSCornerRadius isNumber		ifTrue: [ RSCornerRadius new radius: aRSCornerRadius ]		ifFalse: [ aRSCornerRadius ].	self resetPath! !!RSPolyline methodsFor: 'testing' prior: 59047778!basicIncludesPoint: aPoint	"Answer whether any segment of this polyline includes aPoint."	self controlPoints overlappingPairsDo: [ :a :b |		(aPoint onLineFrom: a to: b within: self includedRadius)			ifTrue: [ ^ true ] ].	^ false! !!RSPolyline methodsFor: 'accessing' prior: 59047693!cornerRadii	^ radius ifNil: [ 0 ]! !!RSPolyline methodsFor: 'accessing' prior: 59048168!cornerRadii: aNumber	radius := aNumber abs.	self resetPath! !!RSMetricsProvider class methodsFor: 'accessing' prior: 58971294!default	^ Default ifNil: [ Default := RSCairoMetricsProvider new ]! !!RSLabel class methodsFor: 'public'!defaultFontSize	^  self defaultFont pointSize! !!RSLabel class methodsFor: 'public' prior: 58846529!familyFontName	"	self familyFontName	"	| fontList |	fontList := LogicalFontManager current allFamilies collect: #familyName.	(fontList includes: 'Source Sans Pro') ifTrue: [ ^ 'Source Sans Pro' ].	(fontList includes: 'DejaVu Sans') ifTrue: [ ^ 'DejaVu Sans' ].	fontList ifEmpty: [ ^ StandardFonts defaultFont familyName ].	(fontList includes: StandardFonts listFont familyName )		ifTrue: [ ^ StandardFonts listFont familyName ].	^  StandardFonts defaultFont familyName! !!RSLabel methodsFor: 'managing font' prior: 58843283!bold"Make the label bold```| c lbl1 lbl2 |c := RSCanvas new.lbl1 := RSLabel new bold; text: 'hello'.c addShape: lbl1.lbl2 := RSLabel new text: 'world'.c addShape: lbl2.RSLocation new below; move: lbl2 on: lbl1.c @ RSCanvasController.c open```"	self emphasisAdd: TextEmphasis bold! !!RSLabel methodsFor: 'accessing' prior: 58846317!cairoGlyphs	"used in drawing and extents computation"	^ cairoGlyphs ifNil: [		cairoGlyphs := CairoFontMetricsProvider new			font: font;			glyphsOf: text ]! !!RSLabel methodsFor: 'metrics' prior: 58839680!computeTextExtents	^ self hasText		ifTrue: [ self metricsProvider extentsOf: self ]		ifFalse: [ RSTextExtents empty ]! !!RSLabel methodsFor: 'private' prior: 58843944!createFont	| aFont |	aFont := LogicalFont		familyName: fontName		pointSize: fontSize.	aFont := aFont emphasized: emphasis emphasisCode.	^ aFont! !!RSLabel methodsFor: 'accessing' prior: 58840745!emphasis: aTextEmphasis"| c lbl |c := RSCanvas new.lbl := RSLabel new text: 'hello'; emphasis: TextEmphasis italic.c addShape: lbl.c @ RSCanvasController.c open"	emphasis = aTextEmphasis ifTrue: [ ^ self ].	emphasis := aTextEmphasis.	self resetFont! !!RSLabel methodsFor: 'managing font' prior: 58839566!emphasisAdd: anEmphasis	emphasis add: anEmphasis.	self resetFont! !!RSLabel methodsFor: 'accessing' prior: 58844441!font: aLogicalFont	font = aLogicalFont ifTrue: [ ^ self ].	font := aLogicalFont.	fontSize := font pointSize.	fontName := font familyName.	emphasis := TextEmphasis fromCode: font emphasis.	self fontName: self privateFontName.	self resetCache! !!RSLabel methodsFor: 'accessing' prior: 58839850!fontName: aString	"	LogicalFontManager current allFamilies inspect	"	fontName = aString ifTrue: [ ^ self ].	fontName := aString.	self resetFont! !!RSLabel methodsFor: 'accessing' prior: 58841268!fontSize	^ fontSize! !!RSLabel methodsFor: 'accessing' prior: 58840265!fontSize: aNumber	"Set the size of the label.Here is an example:```Smalltalkc := RSCanvas new.(1 to: 100 by: 5) shuffled do: [ :i |	lbl := RSLabel new fontSize: i; text: 'hello'; model: i.	c add: lbl.	lbl @ RSPopup.].RSFlowLayout on: c shapes.c @ RSCanvasController```"	fontSize = aNumber ifTrue: [ ^ self ].	fontSize := aNumber.	self resetFont! !!RSLabel methodsFor: 'initialization' prior: 58843631!initialize	super initialize.	paint := Color gray.	self font: self class defaultFont! !!RSLabel methodsFor: 'managing font' prior: 58842927!italic	"Make the label italic```| c lbl1 lbl2 |c := RSCanvas new.lbl1 := RSLabel new italic; text: 'hello'.c addShape: lbl1.lbl2 := RSLabel new text: 'world'.c addShape: lbl2.RSLocation new below; move: lbl2 on: lbl1.c @ RSCanvasController.c open```"	self emphasisAdd: TextEmphasis italic! !!RSLabel methodsFor: 'metrics' prior: 58841664!metricsProvider: aRSMetricsProvider	"Set the way metrics related to the label (e.g., height, width), can be computed. The metric provier per default is RSCairoMetricsProvider.	 The argument must be a subclass of RSMetricsProvider.	For example:```SmalltalkmetricsProvider := RSCairoMetricsProvider new.words := (String loremIpsum: 2000) substrings.labels := words collect: [ :w | RSLabel new metricsProvider: metricsProvider; text: w ].c := RSCanvas new.c addAll: labels.RSFlowLayout on: labels.c @ RSCanvasControllerc open```	"	metricsProvider := aRSMetricsProvider.	self resetCache! !!RSLabel methodsFor: 'managing font' prior: 58841342!normal	self emphasis: TextEmphasis normal! !!RSLabel methodsFor: 'private' prior: 58842767!privateFontName	^ font isTTCFont		ifTrue: [ font familyName ]		ifFalse: [ self class familyFontName ]! !!RSLabel methodsFor: 'initialization' prior: 58846120!resetCache	font ifNil: [ font := self createFont ].	textExtents := nil.	self resetCairoGlyphs.	self extent: self textWidth @ self textHeight! !!RSLabel methodsFor: 'initialization' prior: 58845888!resetFont	font := nil.	self resetCache! !!RSLabel methodsFor: 'managing font' prior: 58844744!struckOut	"Make the label strickethrough```| c lbl1 lbl2 |c := RSCanvas new.lbl1 := RSLabel new struckOut; text: 'hello'.c addShape: lbl1.lbl2 := RSLabel new text: 'world'.c addShape: lbl2.RSLocation new below; move: lbl2 on: lbl1.c @ RSCanvasController.c open```"	self emphasisAdd: TextEmphasis struckOut! !!RSLabel methodsFor: 'accessing' prior: 58841434!text: string	"Set the text of a label. do not try to write in the `text` variable directly."	text = string ifTrue: [ ^ self ].	text := string asString.	self resetCache; resetPath! !!RSLabel methodsFor: 'accessing' prior: 58845176!textExtents	^ textExtents ifNil: [ textExtents := self computeTextExtents ]! !!RSLabel methodsFor: 'managing font' prior: 58845517!underline	"Make the label underlined```| c lbl1 lbl2 |c := RSCanvas new.lbl1 := RSLabel new underline; text: 'hello'.c addShape: lbl1.lbl2 := RSLabel new text: 'world'.c addShape: lbl2.RSLocation new below; move: lbl2 on: lbl1.c @ RSCanvasController.c open```"	self emphasisAdd: TextEmphasis underlined! !!RSVerticalAttachPoint methodsFor: 'public - hooks' prior: 59515294!basicEndingPointOf: aLine	^ self		positionFor: aLine to		in: aLine		point: aLine to encompassingRectangle topCenter + (0@endOffset)! !!RSVerticalAttachPoint methodsFor: 'public - hooks' prior: 59515078!basicStartingPointOf: aLine	^ self		positionFor: aLine from		in: aLine		point: aLine from encompassingRectangle bottomCenter + (0@startOffset)! !!RSEllipse methodsFor: 'geometry' prior: 58656754!geometry	| rect e p |	rect := self encompassingRectangle.	e := rect extent / 2.	p := self position.	e = (0@0) ifTrue: [ ^ p asGPoint ].	^ GEllipse		center: p		vertex: p + (e x@ 0)		coVertex: p + (0@ e y)! !!RSEllipse methodsFor: 'testing' prior: 58657197!preciseIncludesPoint: aPoint	"Implementation is taken over from EllipseMorph>>containsPoint:"	| invertedPoint radius other delta xOverY t1 t2 rect |	invertedPoint := matrix rsInverseTransform: aPoint.	rect := self baseRectangle.	(rect containsPoint: invertedPoint) ifFalse: [ ^ false ]. "quick elimination"	radius := rect height asFloat / 2.	other := rect width asFloat / 2.	delta := invertedPoint - rect topLeft - (other@radius).	xOverY := rect width asFloat / rect height asFloat.	t1 := (delta x asFloat / xOverY) squared + delta y squared.	t2 := radius squared.	^ (t1 < t2)  or: [ t1 closeTo: t2 ]! !!RSCairoCachedMetricsProvider methodsFor: 'hooks' prior: 58398193!dictionaryFor: font	^ Dictionary new! !!RSCairoCachedMetricsProvider methodsFor: 'hooks' prior: 58398299!extentsOf: aRSLabel	| map font h w |	font := aRSLabel font.	map := cache		at: font		ifAbsentPut: [ self dictionaryFor: font ].	"this need to calculate the x_bearing and the kerning between characters"	w := aRSLabel text		ifEmpty: [ 0 ]	 	ifNotEmpty: [ (aRSLabel text			collect: [ :char | self widthOf: char map: map font: font ]			as: Array) sum asFloat ].	h := font getPreciseHeight asFloat.	^ RSTextExtents new		width: w;		height: h;		x_advance: 0;		y_advance: 0;		x_bearing: 0;		y_bearing: font getPreciseAscent negated;		yourself! !!RSCairoCachedMetricsProvider methodsFor: 'initialization' prior: 58397598!initialize	cache := Dictionary new! !!RSCairoCachedMetricsProvider methodsFor: 'hooks' prior: 58397700!widthOf: char map: map font: aLogicalFont	^ map at: char		ifAbsentPut: [			| glyphs rawExt cairoFont |			glyphs := CairoFontMetricsProvider new				font: aLogicalFont;				glyphsOf: char asString.			rawExt := CairoTextExtents new.			cairoFont := CairoScaledFont fromFreetypeFont: aLogicalFont asFreetypeFont.			cairoFont getExtentsOfGlyphs: glyphs getHandle ofLength: glyphs size into: rawExt.			rawExt x_advance			]! !!RSShapeFactory class methodsFor: 'shapes' prior: 59227427!composite	^ RSComposite new! !!RSShapeFactory class methodsFor: 'utilities' prior: 59225745!shapeFromString: aString	"self shapeFromString: 'd'"	#(o circle	^ arrow	s square	p pentagon	h hexagon	+ plus	d diamond	* star ) pairsDo: [ :k :sel |		(aString includesSubstring: k)			ifTrue: [ ^ sel value: self ] ].	^ nil! !!RSShapeFactory class methodsFor: 'shapes' prior: 59227685!star	| star5Points outerPoints innerPoints innerRadius ar |	star5Points := Array new: 10.	outerPoints := RSPolygon generateUnitNgonPoints: 5 rotation: 0.	innerPoints := RSPolygon generateUnitNgonPoints: 5 rotation: Float pi / -5.	"Outer radius is 1; inner radius of star is smaller"	innerRadius := 0.5.	innerPoints		doWithIndex: [ :p :i | innerPoints at: i put: (p x * innerRadius) @ (p y * innerRadius) ].	star5Points		doWithIndex: [ :p :i |			ar := i even				ifTrue: [ outerPoints ]				ifFalse: [ innerPoints ].			star5Points at: i put: (ar at: i // 2 + (i % 2)) ].	star5Points := RSPolygon fitPolygonToSquare: star5Points.	^ self polygonWithPoints: star5Points! !!RSLine methodsFor: 'testing' prior: 58889483!basicIncludesPoint: aPoint	^ aPoint		onLineFrom: self startPoint		to: self endPoint		within: self includedRadius! !!AthensAffineTransform methodsFor: '*Roassal3-Shapes' prior: 17404272!rsInverseTransform: aPoint	"We assume matrix is never degenerated"	| px py y0 x0 epsilon |	epsilon := 0.000001.	px := aPoint x.	py := aPoint y.	"for rotations around +/- half pi"	((sx closeTo: 0 precision: epsilon)		and:[ sy closeTo: 0 precision: epsilon ]) ifTrue:[		^ self inverseTransformHalfPi: aPoint.		].	"for rotations around +/- pi or 0"	((shx closeTo: 0 precision: epsilon)		and:[ shy closeTo: 0 precision: epsilon ]) ifTrue:[		^ self inverseTransformPiOrZero: aPoint.		].    "otherwise:     Given straight transformation formulae:	px := x0*sx + y0*shx + x.	py := x0*shy + y0*sy + y.	we doing inverse one, trying to find x0,y0 for rest of given variables (px,py,x,y,sx,sy,shx,shy).	x0 := px - x - (shx*y0) / sx.	y0 := py - y - (shy*x0) / sy.	y0 := py - y - (shy*(px - x - (shx*y0) / sx)) / sy.	sy * y0  == py - y - (shy*(px - x - (shx*y0) / sx)).	sx * sy * y0  == (sx*(py - y)) - (shy*(px - x - (shx*y0))).	sx * sy * y0  == sx*py - (sx*y) - (shy*px) + (shy*x) + (shy*shx*y0).	(sx * sy * y0) - (shy*shx*y0)  == sx*py - (sx*y) - (shy*px) + (shy*x) .	y0* ((sx * sy) - (shy*shx))  == sx*py - (sx*y) - (shy*px) + (shy*x) ."	y0  := sx*py - (sx*y) - (shy*px) + (shy*x) / ((sx * sy) - (shy*shx)).	x0 := px - x - (shx*y0) / sx.	^ x0@y0! !!RSBorderAttachPoint methodsFor: 'public - hooks' prior: 58363283!basicStartingPointOf: aLine	^ self		basicPointFrom: aLine from		to: aLine to		of: aLine		offset: startOffset! !!RSAttachPoint class methodsFor: 'testing' prior: 58336745!isAbstract	^ self == RSAttachPoint! !!RSAttachPoint methodsFor: 'public - hooks' prior: 58336445!basicEndingPointOf: aLine	^ self subclassResponsibility! !!RSAttachPoint methodsFor: 'public - hooks' prior: 58336150!basicStartingPointOf: aLine	^ self subclassResponsibility! !!RSAttachPoint methodsFor: 'private' prior: 58335373!commonParents: shape in: aLine	| current parents |	current := shape parent.	parents := OrderedCollection new.	[ current = aLine parent ] whileFalse: [		current ifNil: [ ^ nil ].		current parent = current ifTrue: [ ^ nil ].		parents add: current.		current := current parent ].	^ parents! !!RSAttachPoint methodsFor: 'public - hooks' prior: 58333613!endingPointOf: aLine	"Return the end point of a line.	b1 := RSBox new size: 20.	b2 := RSBox new size: 20.	b1 translateTo: 20 @ 30.	b2 translateTo: 60 @ 50.	l := RSLine new		from: b1;		to: b2.	l attachPoint: RSBorderAttachPoint new.	l update.	b1 @ RSDraggable.	b2 @ RSDraggable.	c := RSCanvas new.	c		add: b1;		add: b2;		add: l.	l attachPoint startingPointOf: l=> 	50 @ 45	"	(aLine from = aLine to)		ifTrue: [ ^ self positionFor: aLine from in: aLine ].    ^ inverted        ifTrue: [ self basicStartingPointOf: aLine ]        ifFalse: [ self basicEndingPointOf: aLine ]! !!RSAttachPoint methodsFor: 'initialization' prior: 58335139!initialize	super initialize.	inverted := false! !!RSAttachPoint methodsFor: 'testing' prior: 58333451!isInverted	^ inverted! !!RSAttachPoint methodsFor: 'private' prior: 58335721!positionFor: shape in: aLine point: pos	| commonParents |	shape isPoint ifTrue: [ ^ shape ].	(self hasParents: shape in: aLine) ifFalse: [ ^ pos ].	shape parent = aLine parent ifTrue: [ ^ pos ].	"TODO we can cache this info"	commonParents := self commonParents: shape in: aLine.	commonParents ifNil: [ ^ pos ].	^ (self matrixFor: commonParents) transform: pos! !!RSAttachPoint methodsFor: 'public - hooks' prior: 58334473!startingPointOf: aLine"Return the starting point of a line.	b1 := RSBox new size: 20.	b2 := RSBox new size: 20.	b1 translateTo: 20 @ 30.	b2 translateTo: 60 @ 50.	l := RSLine new		from: b1;		to: b2.	l attachPoint: RSBorderAttachPoint new.	l update.	b1 @ RSDraggable.	b2 @ RSDraggable.	c := RSCanvas new.	c		add: b1;		add: b2;		add: l.	l attachPoint startingPointOf: l=> 	30 @ 35	"	(aLine from = aLine to)		ifTrue: [ ^ self positionFor: aLine from in: aLine ].    ^ inverted        ifTrue: [ self basicEndingPointOf: aLine ]        ifFalse: [ self basicStartingPointOf: aLine ]! !!RSTMarkeable methodsFor: 'testing' prior: 59331700!hasMarkers	| m |	m := self privateMarkers.	^ m notNil and: [		m anySatisfy: [ :mar | mar notNil ].  ]! !!RSTMarkeable methodsFor: 'accessing - markers' prior: 59331539!marker: aMarker	| m |	m := aMarker asMarker.	self		markerStart: m;		markerMid: m;		markerEnd: m.	^ m! !!RSTMarkeable methodsFor: 'accessing - markers' prior: 59331959!markerEnd	^ self markers		ifNil: [ nil ]		ifNotNil: [ :m | m third ]! !!RSTMarkeable methodsFor: 'accessing - markers' prior: 59331401!markerMid	^ self markers		ifNil: [ nil ]		ifNotNil: [ :m | m second ]! !!RSTMarkeable methodsFor: 'public' prior: 59333137!markerShapesInPositionDo: aBlock	| cp |	cp := self controlPoints.	self markerStart ifNotNil: [ :marker | marker withStart: cp do: aBlock ].	self markerMid ifNotNil: [ :marker | marker withMid: cp do: aBlock ].	self markerEnd ifNotNil: [ :marker | marker withEnd: cp do: aBlock ]! !!RSTMarkeable methodsFor: 'accessing - markers' prior: 59333873!markerStart	^ self markers		ifNil: [ nil ]		ifNotNil: [ :m | m first ]! !!RSTMarkeable methodsFor: 'accessing - markers' prior: 59332688!markerStartEnd: aMarker	| m |	m := aMarker asMarker.	self		markerStart: m;		markerEnd: m.	^ m! !!RSTMarkeable methodsFor: 'accessing - markers' prior: 59332332!markers	^ self privateMarkers		ifNil: [ | array |			array := Array new: 3.			self privateMarkers: array.			array ]! !!RSTMarkeable methodsFor: 'accessing - markers' prior: 59332853!markersDo: block	self markers do: [ :m | m ifNotNil: block  ]! !!RSTMarkeable methodsFor: 'testing' prior: 59332084!markersIncludesPoint: aPoint	self hasMarkers ifFalse: [ ^ false ].	self markerShapesInPositionDo: [ :m |		(m shape preciseIncludesPoint: aPoint)			ifTrue: [ ^ true ] ].	^ false! !!RSTextExtents methodsFor: 'public' prior: 59433528!empty	self		width: 0;		height: 0;		x_advance: 0;		y_advance: 0;		x_bearing: 0;		y_bearing: 0! !!RSTextExtents methodsFor: 'public' prior: 59434036!from: ref	"ref is a CairoTextExtents"	self		width: ref width;		height: ref height;		x_advance: ref x_advance;		y_advance: ref y_advance;		x_bearing: ref x_bearing;		y_bearing: ref y_bearing! !!RSTextExtents methodsFor: 'printing' prior: 59433248!printOn: s	s << self className; << '('.	#(x_bearing y_bearing width height x_advance y_advance) do: [ :sel |		s << sel; << ':'; << String tab.		(sel value: self) printOn: s.		 ] separatedBy: [ s << String crlf ].	s << ')'! !!RSHorizontalAttachPoint methodsFor: 'public - hooks' prior: 58767267!basicEndingPointOf: aLine	^ self		positionFor: aLine to		in: aLine		point: aLine to encompassingRectangle leftCenter + (endOffset@0)! !!RSHorizontalAttachPoint methodsFor: 'public - hooks' prior: 58767050!basicStartingPointOf: aLine	^ self		positionFor: aLine from		in: aLine		point: aLine from encompassingRectangle rightCenter + (startOffset@0)! !!RSArrowedLine methodsFor: 'border' prior: 58295867!border: aRSBorder	super border: aRSBorder.	self markersDo: [ :m | m shape border: aRSBorder ]! !!RSArrowedLine methodsFor: 'initialization' prior: 58295751!initialize	super initialize.	self markerEnd: self defaultHead! !!RSArrowedLine methodsFor: 'copying' prior: 58296379!postCopy	super postCopy.	markers := nil.	self markerEnd: self defaultHead.	self border: self border copy! !!RSAbstractCPController methodsFor: 'hooks' prior: 58146503!controlPointsFor: aLine	"return an array of points generated from the line"	^ self subclassResponsibility! !!RSAbstractControlPointsLine methodsFor: 'actions' prior: 58186315!basicTranslateBy: delta	controlPoints := controlPoints collect: [:p | p + delta ]! !!RSAbstractControlPointsLine methodsFor: 'accessing' prior: 58186815!controlPoints	^ controlPoints ifNil: [ controlPoints := { 0@0. 0@0 } ]! !!RSAbstractControlPointsLine methodsFor: 'accessing' prior: 58187273!controlPoints: anArrayOfPoints	controlPoints := anArrayOfPoints collect: #asFloatPoint.	self resetPath! !!RSAbstractControlPointsLine methodsFor: 'accessing' prior: 58185830!endPoint: aPoint	self controlPoints		at: self controlPoints size		put: aPoint.	self resetPath! !!RSAbstractControlPointsLine methodsFor: 'accessing' prior: 58186672!startPoint: aPoint	self controlPoints at: 1 put: aPoint.	self resetPath! !!RSAbstractControlPointsLine methodsFor: 'update' prior: 58186102!update	controlPointsController ifNil: [ ^ self ].	self		controlPoints: (controlPointsController controlPointsFor: self);		notifyExtentChanged! !!RSPharoMetricsProvider methodsFor: 'hooks' prior: 59030836!extentsOf: aRSLabel	| w h font text |	font := aRSLabel font.	text := aRSLabel text.	w := (font widthOfString: text) asFloat.	h := font height asFloat.	^ RSTextExtents new		width: w;		height: h;		x_advance: w;		y_advance: h;		x_bearing: 0;		y_bearing: (h / 4) - h;		yourself! !!RSAbstractCPAPController methodsFor: 'hooks' prior: 58145905!controlPointsFor: aLine	| ap |	ap := aLine attachPoint.	^ self		controlPointsFrom: (ap startingPointOf: aLine)		to: (ap endingPointOf: aLine)! !RSBezier class removeSelector: #exampleControlPointsController!RSBezier class removeSelector: #exampleBezier!RSTLine removeSelector: #fmt:!RSLinePlot removeSelector: #fmt:!RSLineBuilder removeSelector: #fmt:!RSAbstractLine removeSelector: #fmt:!RSBitmap class removeSelector: #example!RSBox class removeSelector: #example!RSLine class removeSelector: #exampleLine!RSLine class removeSelector: #exampleFMT!RSArrowedLine class removeSelector: #exampleArrow!RSSelfLoopCPController class removeSelector: #example!RSPolyline class removeSelector: #examplePolyline!RSPolyline class removeSelector: #exampleArrowedPolyline!"Roassal3-Shapes"!!RSAnimationEvent methodsFor: 'accessing' prior: 58293552!animation: anAnimation	animation := anAnimation! !!RSAnimationEvent methodsFor: 'accessing'!canvas	^ self animation canvas! !!RSElasticInterpolator methodsFor: 'accessing' prior: 58655103!amplitude: a	amplitude := a.	period := period * tau.	self calculateS! !!RSElasticInterpolator methodsFor: 'accessing' prior: 58655392!calculateS	"var s = Math.asin(1 / (a = Math.max(1, a))) * (p /= tau);"	amplitude := 1 max: amplitude.	period := period / tau.	s := (1 / amplitude) arcSin * period! !!RSElasticInterpolator methodsFor: 'initialization' prior: 58655627!initialize	super initialize.	tau := 2* Float pi.	amplitude := 1.	period := 0.3.	self calculateS! !!RSElasticInterpolator methodsFor: 'interpolation' prior: 58655796!interpolateInOut: i	| t |	t := i * 2 - 1.	^ (t < 0		ifTrue: [ amplitude * (2 raisedTo: 10 * t) * ((s - t)/period) sin ]		ifFalse: [ 2 - (amplitude * (2 raisedTo: -10 * t) * ((s + t)/period) sin )   ]) / 2! !!RSElasticInterpolator methodsFor: 'accessing' prior: 58656309!period: p	period := p.	self calculateS! !!RSQuadInterpolator methodsFor: 'interpolation' prior: 59062220!interpolateInOut: i	| t |	t := i *2.	^ (t <= 1		ifTrue: [ t*t ]		ifFalse: [			t := t-1.			t * (2- t)+1 ]) /2! !!RSCubicInterpolator methodsFor: 'interpolation' prior: 58561502!interpolateInOut: i	| t |	t := i * 2.	^ (t <= 1		ifTrue: [ t * t * t  ]		ifFalse: [			t := t - 2.			t * t * t + 2 ])/2! !!RSSinInterpolator methodsFor: 'interpolation' prior: 59244537!interpolateInOut: t	^ (1 - (Float pi * t) cos ) / 2! !!RSAbstractAnimation methodsFor: 'accessing' prior: 58126792!canvas	^ canvas! !!RSAbstractAnimation methodsFor: 'actions' prior: 58128530!continue	isPaused ifFalse: [ ^ self ].	isPaused := false.	endPauseTime := self currentTime.	pauseTime := pauseTime + endPauseTime - startPauseTime! !!RSAbstractAnimation methodsFor: 'accessing' prior: 58124668!delay	^ delay! !!RSAbstractAnimation methodsFor: 'initialization' prior: 58130036!initialize	super initialize.	self reset.	canvas := RSDefaultTimer new! !!RSAbstractAnimation methodsFor: 'testing' prior: 58128393!isDelayDone	delay ifNil: [ ^ true ].	^ startTime + delay < self currentTime! !!RSAbstractAnimation methodsFor: 'testing' prior: 58129119!isRepeating	^ loops isInfinite! !!RSAbstractAnimation methodsFor: 'testing' prior: 58127962!isRunning	^ isRunning! !!RSAbstractAnimation methodsFor: 'private' prior: 58127622!loopDone	currentLoop := currentLoop + 1.	startPauseTime := endPauseTime := pauseTime := 0.	startLoopTime := self currentTime.	self announce: (RSAnimationLoopEvent new animation: self)! !!RSAbstractAnimation methodsFor: 'actions' prior: 58128967!pause	isPaused ifTrue: [ ^ self ].	isPaused := true.	startPauseTime := self currentTime! !!RSAbstractAnimation methodsFor: 'refreshing' prior: 58124745!refresh	self hasCompleted		ifTrue: [ ^ self ].	self isDelayDone		ifFalse: [ ^ self ].	self isPaused		ifTrue: [ ^ self ].	self step! !!RSAbstractAnimation methodsFor: 'actions' prior: 58125040!remove	canvas animations remove: self ifAbsent: [  ].	endTime := self currentTime.	isRunning := false.	currentLoop := nil.	startLoopTime := nil.	self announce: (RSAnimationEndEvent new animation: self)! !!RSAbstractAnimation methodsFor: 'initialization' prior: 58125973!reset	isRunning := false.	self noRepeat.	hasCompleted := false.	isPaused := false.	currentLoop := nil.	startLoopTime := nil.	startPauseTime := 0.	endPauseTime := 0.	pauseTime := 0! !!RSAbstractAnimation methodsFor: 'accessing' prior: 58128877!startLoopTime	^ startLoopTime! !!RSAbstractAnimation methodsFor: 'private' prior: 58131753!startStep	currentLoop		ifNil: [ currentLoop := 0 ].	startLoopTime		ifNil: [ startLoopTime := self currentTime ]! !!RSAbstractAnimation methodsFor: 'accessing' prior: 58127137!startTime	^ startTime! !!RSAbstractAnimation methodsFor: 'actions' prior: 58132130!stop	isRunning := false.	hasCompleted := true! !!RSAbstractAnimation methodsFor: 'actions' prior: 58128740!toggle	self isPaused		ifTrue: [ self continue ]		ifFalse: [ self pause ]! !!RSAbstractAnimation methodsFor: 'private' prior: 58127341!updateHasCompleted	hasCompleted ifFalse: [ hasCompleted := currentLoop >= loops ]! !!RSCanvas methodsFor: '*Roassal3-Animation' prior: 58424247!compositeAnimation: aRSCompositeAnimation from: array	aRSCompositeAnimation addAll: array.	self addAnimation: aRSCompositeAnimation.	^ aRSCompositeAnimation! !!RSCanvas methodsFor: '*Roassal3-Animation' prior: 58418507!currentTime	^ self timer currentTime! !!RSCanvas methodsFor: '*Roassal3-Animation' prior: 58441786!newAnimation	"Define a new transition animation, schedule it, and return it (useful to tune it).-=-==-=-=-=	c := RSCanvas new.	b := RSBox new		extent: 100@100;		withBorder.	c add: b.	c newAnimation			from: -100 @ -100;			to: 100 @ 100;			on: b set: #position:.	c-=-==-=-=-=	"	| anime |	anime := self transitionAnimation.	self addAnimation: anime.	^ anime! !!RSCanvas methodsFor: '*Roassal3-Animation' prior: 58422440!parallelAnimation	^ RSParallelAnimation new! !!RSCanvas methodsFor: '*Roassal3-Animation' prior: 58435870!parallelAnimationFrom: array	^ self compositeAnimation: self parallelAnimation from: array! !!RSCanvas methodsFor: '*Roassal3-Animation' prior: 58434828!sequentialAnimation	^ RSSequentialAnimation new! !!RSCanvas methodsFor: '*Roassal3-Animation' prior: 58423475!timer	^ self propertyAt: #timer ifAbsentPut: [ RSDefaultTimer new ]! !!RSCanvas methodsFor: '*Roassal3-Animation' prior: 58418607!transitionAnimation	^ RSTransitionAnimation new! !!RSBackInterpolator methodsFor: 'interpolation' prior: 58339789!interpolateInOut: i	"((t *= 2) < 1 ? t * t * ((s + 1) * t - s) : (t -= 2) * t * ((s + 1) * t + s) + 2) / 2;"	| t |	t := i * 2.	^ (t < 1		ifTrue: [ t * t * ((overshoot + 1) * t - overshoot) ]		ifFalse: [			t := t -2.			t * t * ((overshoot + 1) * t + overshoot) + 2 ])/2! !!RSBounceInterpolator methodsFor: 'interpolation' prior: 58365767!interpolateOut: i	| t |	t := i.	^ t < b1		ifTrue: [ b0 * t * t ]		ifFalse: [			t < b3 ifTrue: [				t := t - b2.				b0 * t * t + b4 ]			ifFalse: [				t < b6 ifTrue: [					t := t - b5.					b0 * t * t + b7 ]				ifFalse: [					t := t - b8.					b0 * t * t + b9 ] ] ]! !!RSCircleInterpolator methodsFor: 'interpolation' prior: 58494438!interpolateInOut: i	| t |	t := i * 2.	^ (t<=1		ifTrue: [ 1 - (1 - (t*t)) sqrt ]		ifFalse: [			t := t - 2.			(1 - (t*t)) sqrt + 1 ])/2! !!RSCircleInterpolator methodsFor: 'interpolation' prior: 58494313!interpolateOut: i	| t |	t := i -1.	^ (1 - (t* t)) sqrt! !!RSExpInterpolator methodsFor: 'interpolation' prior: 58664077!interpolateIn: t	^ 2 raisedTo: (10 * t - 10)! !!RSExpInterpolator methodsFor: 'interpolation' prior: 58663874!interpolateInOut: i	| t |	t := i * 2.	^ (t <= 1		ifTrue: [ 2 raisedTo: 10 * t - 10 ]		ifFalse: [ 2 - (2 raisedTo: 10 - (10 * t)) ])/2! !!RSExpInterpolator methodsFor: 'interpolation' prior: 58663764!interpolateOut: t	^ 1 - (2 raisedTo: -10 * t)! !!RSCompositeAnimation methodsFor: 'adding' prior: 58544803!add: anAnimation	animations add: anAnimation! !!RSCompositeAnimation methodsFor: 'adding' prior: 58544908!addAll: array	animations addAll: array! !!RSCompositeAnimation methodsFor: 'initialization' prior: 58544510!reset	super reset.	animations := OrderedCollection new! !!RSParallelAnimation methodsFor: 'actions' prior: 59028147!continue	super continue.	animations do: #continue! !!RSParallelAnimation methodsFor: 'actions' prior: 59027265!pause	super pause.	animations do: #pause! !!RSParallelAnimation methodsFor: 'refreshing' prior: 59027370!step	| activeAnimations activeSize |	self startStep.	activeAnimations := animations reject: [ :animation | animation hasCompleted ].	activeSize := 0.	activeAnimations do: [ :animation |		self startIfNessesary: animation.		animation refresh.		animation hasCompleted			ifTrue: [ animation remove ]			ifFalse: [ activeSize := activeSize + 1 ] ].	activeSize isZero ifTrue: [ self loopDone ].	self updateHasCompleted! !!RSShape methodsFor: '*Roassal3-Animation' prior: 59221512!newAnimation	"Create a new animation"	^ parent ifNil: [		| animations anime |		animations := self propertyAt: #todoAnimations ifAbsentPut: [ OrderedCollection new ].		anime := RSTransitionAnimation new.		animations add: anime.		anime.		 ] ifNotNil: [ parent newAnimation ]! !!RSTransitionAnimation methodsFor: 'accessing' prior: 59462730!easing: anInterpolator	easing := anInterpolator! !!RSTransitionAnimation methodsFor: 'initialization' prior: 59462847!initialize	super initialize.	self onStepDo: [ :t | ]! !!RSTransitionAnimation methodsFor: 'action handling' prior: 59464310!on: object set: setSelector	"Key method to set an animation. the first argument receives an object, typically a shape, a border, a line. The second argument is a selector that will be used to set the animated value. The selector must take one argument as parameter. Here is an example:```c := RSCanvas new.b := RSBorder new color: Color blue.b dashArray: #(5 1 5).(30 to: 60) do: [ :nb |	box := RSBox new size: nb.	ellipse := RSEllipse new width: nb; height: nb + 10.	box border: b.	ellipse border: b.	c add: box; add: ellipse.	 ].RSFlowLayout on: c shapes.c @ RSControlsCanvas.c newAnimation	from: 0;	to: 40;	on: b set: #dashOffset:.c```Another example, simpler:```c := RSCanvas new.b := RSBox new size: 30.c add: b.c newAnimation	from: 0 @ 0;	to: 100 @ 100;	on: b set: #position:.c```	"	| sel |	sel := setSelector asSymbol.	self assert: [ sel numArgs = 1 ] description: [ 'The selector ', sel, ' should accept one argument' ].	self		assert: (object class canUnderstand: sel)		description: 'Invalid input'.	self onStepDo: [ :t |		object perform: sel withArguments: { t }.		canvas signalUpdate.	]! !!RSTransitionAnimation methodsFor: 'accessing - computed' prior: 59466046!progressValue: progress	| value |	"interpolate the progress"	value := easing interpolate: progress.	"apply progress to the value"	^ self scale scale: value! !!RSTransitionAnimation methodsFor: 'initialization' prior: 59462370!reset	super reset.	self duration: self class defaultDuration.	easing := RSLinearInterpolator new.	scale := NSScale linear! !!RSTransitionAnimation methodsFor: 'accessing' prior: 59465822!to: aValue	scale to: aValue! !!RSPolyInterpolator methodsFor: 'initialization' prior: 59041809!initialize	super initialize.	self exponent: 3! !!RSPolyInterpolator methodsFor: 'interpolation' prior: 59041921!interpolateIn: i	^ i raisedTo: exponent! !!RSPolyInterpolator methodsFor: 'interpolation' prior: 59041601!interpolateInOut: i	| t |	t := i * 2.	^ (t <= 1		ifTrue: [ t raisedTo: exponent ]		ifFalse: [ 2 - ( ( 2 - t) raisedTo: exponent ) ]) / 2! !!RSPolyInterpolator methodsFor: 'interpolation' prior: 59041483!interpolateOut:  t	^ 1 - ((1 -t) raisedTo: exponent)! !!RSEasingInterpolator class methodsFor: 'poly' prior: 58617266!polyInOut	^ RSPolyInterpolator new! !!RSEasingInterpolator methodsFor: 'actions' prior: 58614882!in	useIn := true! !!RSEasingInterpolator methodsFor: 'initialization' prior: 58614387!initialize	super initialize.	self inOut! !!RSEasingInterpolator methodsFor: 'interpolation' prior: 58614689!interpolate: t	useIn ifTrue: [ ^ self interpolateIn: t ].	useOut ifTrue: [ ^ self interpolateOut: t ].	^ self interpolateInOut: t! !!RSEasingInterpolator methodsFor: 'interpolation' prior: 58614269!interpolateInOut: t	^ self subclassResponsibility! !!RSEasingInterpolator methodsFor: 'actions' prior: 58614602!out	useOut := true! !!RSVariableTimer methodsFor: 'public' prior: 59514280!addTime: aDuration	currentTime := currentTime + aDuration asMilliSeconds! !!RSVariableTimer methodsFor: 'initialization' prior: 59514149!initialize	super initialize.	currentTime := RSDefaultTimer new currentTime! !!RSSequentialAnimation methodsFor: 'actions' prior: 59181978!continue	super continue.	self currentDo: #continue! !!RSSequentialAnimation methodsFor: 'refreshing' prior: 59181431!current	^ animations at: currentIndex ifAbsent: [ nil ]! !!RSSequentialAnimation methodsFor: 'actions' prior: 59180651!currentDo: block	| current |	current := self current.	current ifNil: [ ^ self ].	block value: current! !!RSSequentialAnimation methodsFor: 'actions' prior: 59180818!pause	super pause.	self currentDo: #pause! !!RSSequentialAnimation methodsFor: 'actions' prior: 59181878!start	super start.	currentIndex := 1! !!RSSequentialAnimation methodsFor: 'refreshing' prior: 59181119!step	self startStep.	self stepCurrent.	self currentHasCompleted ifTrue: [		self current remove.		currentIndex := currentIndex + 1. ].	currentIndex > animations size ifTrue: [		currentIndex := 1.		self loopDone ].	self updateHasCompleted! !!RSSequentialAnimation methodsFor: 'refreshing' prior: 59180926!stepCurrent	| current |	current := self current.	current ifNil: [ ^ self ].	self startIfNessesary: current.	current refresh! !"Roassal3-Animation"!!RSAbstractControlCanvasInteraction commentStamp: '' prior: 58181036!I represent an abstract canvas interaction.I interact with:- `RSCanvasController`.- `RSControlConfiguration`My subclasses have to define:- `renderLegendOn:`, a nice description of the interaction. will be included in `Help` icon.- `onShape:`, with the expected behavior of the canvas interaction. `RSCanvasController` defines a set of default interactions.If users want to add more interaction user `RSCanvasController >> #addInteraction:` or to change the default interactions use `RSCanvasController >> #defaultInteractions`.Each interaction has access to a global configuration `RSControlConfiguration`, then you can customize the interactions with the canvas.My methods are utilities method to access information of the canvas, like the visible rectangle or the encompassing rectangle of the shapes.!!RSDraggableCanvasInteraction commentStamp: '' prior: 58602787!I set the drag event for canvas view.Use example:```stc := RSCanvas new.c add: (RSBox new size: 30).c @ RSDraggableCanvasInteraction```I work with `RSControlConfiguration` to obtain the padding/margin size.I am part of the default set of interactions in `RSCanvasController >> #defaultInteractions`.Users can drag and drop when they click over the canvas. Even the can drag out of the visible area(`visibleRectangle`), then an animation will start to put the canvas camera in the correct position.If you want to disable the animation interaction use `RSControlConfiguration >> #hasDraggableAnimation:`.Also you can configure the action event to activate the drag and drop: `left`, `right`, `middle` or `all`!!RSKeepCanvasPositionCanvasInteraction commentStamp: '' prior: 58818560!This class is used by `RSCanvasController class >> #simple `This is not a default interaction in `RSCanvasController >> #defaultInteractions`When the canvas is resized this interaction puts the camera view in the top left corner, (this because roassal origin is in the window's center).Because we have coordinates now, may be we can remove this class.!!RSKeyNavigationCanvasInteraction commentStamp: '' prior: 58821976!I add key events to the view to move it, zoom it with the key board.I interact with:- `RSCanvasController`- `RSControlConfiguration`### Keys- Arrows: small move in the desired direction- Arrows + Shift: large move in the desired direction- M: to expand or collapse the current window- O: to zoom out- I: to zoom in!!RSScrollBarsCanvasInteraction commentStamp: '' prior: 59146420!I put a scrool bars shapes to the canvas when the view moves.I interact with `RSCanvasController`.When the user changes the camera position or the camera scale, it will trigger`RSPositionChangedEvent` or `RSScaleChangedEvent`.No customization for the moment for bar shapesInstance variables- barShape, is a base shape, it defines the appereance and events for the bars.- horizontal, vertical are the bar shapes, they are copies of barShape.- animation, is a waiting animation, when finish will call hideAnimation- hideAnimation, will fade out the barsUse this class with `RSDraggableCanvasInteraction` and `RSKeyNavigationCanvasInteraction`!!RSScrollWheelCanvasInteraction commentStamp: '' prior: 59151884!This interaction simulates the vertical scroll with mouse wheel.When used will creates animations to translate canvas camera position!!RSSearchInCanvasInteraction commentStamp: '' prior: 59153338!`RSSearchInCanvas` am an option for the canvas controller. You can use `RSSearchInCanvas` as follows (press the S key and the R key):Examples- `RSSearchInCanvasInteraction class >>#exampleCollection`- `RSSearchInCanvasInteraction class >>#exampleCollection2`### Variables- canvas, the current canvas.- useExactMach, a configuration flag, if true it will use a exact regular expression- highlightesShapes, a collection of the group of shapes- colorsToUse, a color palette to highlight each search group- highlightableLabels, the current labels on the top left of the search.Search In Canvas will highlight with a shadow a current shape. You have to click on the search result to jump between results of the list.The selection of the elements is based on each shape model `asString`!!RSZoomToFitCanvasInteraction commentStamp: '' prior: 59546439!I put an interaction to zoom to fit the entire visualization inside the visible area provided by the morp.I work with `RSCanvasController` and `RSControlConfiguration`.Press `bar space key` in a canvas to zoom to fitNote: this interaction changes the RSCamera of the canvas for a custom camera.!!RSZoomLevelText commentStamp: '' prior: 0!Created for issue https://github.com/ObjectProfile/Roassal3/issues/56Please check class side for examples!!RSControlConfiguration commentStamp: '' prior: 58554749!A control configuration is shared by the interactions of `RSCanvasController`. For example, by modifying a control configuration, the minimum zoom, or maximum zoom, the padding.For examples:- `RSControlConfiguration class >> #example1`- `RSControlConfiguration class >> #example2`!!RSBlink commentStamp: '' prior: 58354250!Small example of how to create an interaction added a new animation in the canvas.Please check how to use this class here: `RSBlink class>> #example`!!RSDraggable commentStamp: '' prior: 58601340!This interaction allows to the user move shapes. Just click over a shape, then drag it, and finalyy relase the click button### Example- `RSDraggable class >> #example`!!RSGhostDraggable commentStamp: '' prior: 58695659!This interaction creates a new box(a ghost box) and it moves the box instead of the entire shape### Example- `RSGhostDraggable class >> #example`- `RSGhostDraggable class >> #exampleChangeColor`!!RSHighlightable commentStamp: '' prior: 58724480!`RSHighlightable` is an interaction for shapes to make them highlightable. *Responsibility*: make shapes highlightable*Collaborators*: closely colaborate with `RSShape`*Variables*:- `announcer`: highlightable uses announcement to trigger the interaction. - `copyKey`: symbol that is used to keep in the property the previous color. One needs to modity the `copyKey` to avoid conflict between several highlightable interactions.- `highlightShapes`: refers to a one-arg-block that takes as parameter a shape and returns the shapes that must be highlighted. - `propertyKey`: symbol that is used in the property of the `RSCanvas` to keep highlighted shapes. This is useful to avoid conflicts between different highlightable.   ## Examples- `RSHighlightable class >> #example`- `RSHighlightable class >> #exampleGrid`- `RSHighlightable class >> #exampleGrid2`- `RSHighlightable class >> #exampleNumbers`- `RSHighlightable class >> #exampleTree`- `RSHighlightable class >> #exampleInteractive`!!RSLabeled commentStamp: '' prior: 58860379!<keyClass>`RSLabeled` adds a label on shape. Per default, it is added on top of the shape. The label may be particularized using #text: in the default string representation is not sufficient. *Responsibility*: locate a label on top of a shape.*Collaborators*: can be added to any Roassal shape*Variables*:- `location`: a `RSLocation` indicating where the label should be located- `isHighlightable`: a boolean indicating whether the label should be highlighted- `lowColor`: a boolean indicating whether the label should be highlighted### Examples- `RSLabeled class >> #exampleBoxes`- `RSLabeled class >> #exampleLabeledHighlightable`!!RSMenuActivable commentStamp: '' prior: 58970178!With the mouse right click event I show a basic popup.`menuDo:` recives a block of two arguments to build the menu.- First argument is an instance of `MenuMorph`.- Second argument is the shape with the event### Example- `RSMenuActivable class >> #example`!!RSRotated commentStamp: '' prior: 59141198!This interaction put dragging events. Use mouse left click to start the draging operation.This interaction will modify the current matrix of the target shape.!!RSTransformable commentStamp: '' prior: 59451152!I provide shape resizing in all eight directions. Resizing handles are displayed after clicking on an associated shape, and are automatically removed when clicked on a canvas or another shape.!!!! AssumptionsYou must provide this class with aCanvas instance or the initialized element must be already added to the canvas.!!RSConfigurableCamera commentStamp: '' prior: 58552948!I am a camera to control the zoom interaction.This camera allows to connect the interaction configuration with the zoomToFit interaction.Also this camera has a configurable`zoomRatio:` default value is 0.9(90%) of the total extent of the canvas.I work with `RSZoomToFitCanvasInteraction`!!RSAbstractControlCanvasInteraction methodsFor: 'utilities'!computeExpandedRectangle: aCanvas	| rectangle matrix |	"we obtains the rectangle in the canvas space".	rectangle := self encompassingRectangleFor: aCanvas.	matrix := aCanvas camera originMode matrixFor: aCanvas camera.		"then we convert that to morph coordinates"	rectangle := Rectangle encompassing: (rectangle corners 		collect: [:corner | matrix transform: corner]).	"we expand the rectangle with the padding"	rectangle := self configuration padding expandRectangle: rectangle.	"the rectangle returns to the canvas space"	rectangle := Rectangle encompassing: (rectangle corners 		collect: [:corner | matrix inverseTransform: corner]).	^ rectangle! !!RSAbstractControlCanvasInteraction methodsFor: 'utilities'!correctCamera: camera	^ self correctCamera: camera matrixDo: [ :mat | ]! !!RSAbstractControlCanvasInteraction methodsFor: 'utilities'!correctCamera: camera matrixDo: aBlock	| canvas rectangle matrix origin correctRectangle |	canvas := camera canvas.	matrix := camera matrix.	origin := nil.	matrix restoreAfter: [ | diff |		aBlock value: matrix.		origin := matrix translation.		rectangle := self expandedRectangle: canvas.		correctRectangle := self correctRectangle: rectangle camera: camera.		diff := (matrix transform: rectangle origin) - (matrix transform: correctRectangle origin).		origin := origin - diff ].	^ origin.! !!RSAbstractControlCanvasInteraction methodsFor: 'utilities' prior: 58181989!correctCameraPosition: aCanvas inRectangle: rectangle position: position scale: scale	| canvasRect x y p |	p := position.		canvasRect := Rectangle		floatCenter: p		extent: aCanvas extent / scale.	canvasRect := aCanvas visibleRectangle.		x := rectangle width <= canvasRect width		ifTrue: [rectangle origin x < canvasRect origin x			ifTrue: [ p x - (canvasRect origin x - rectangle origin x) ]			ifFalse: [ rectangle corner x < canvasRect corner x				ifTrue: [ p x ]				ifFalse: [ p x - (canvasRect corner x - rectangle corner x) ] ] ]		ifFalse: [ canvasRect origin x < rectangle origin x			ifTrue: [ p x - (canvasRect origin x - rectangle origin x) ]			ifFalse: [ rectangle corner x < canvasRect corner x				ifTrue: [ p x - (canvasRect corner x - rectangle corner x) ]				ifFalse: [ p x ] ] ].	y := rectangle height <= canvasRect height		ifTrue: [rectangle origin y < canvasRect origin y			ifTrue: [ p y - (canvasRect origin y - rectangle origin y) ]			ifFalse: [ rectangle corner y < canvasRect corner y				ifTrue: [ p y ]				ifFalse: [ p y - (canvasRect corner y - rectangle corner y) ] ] ]		ifFalse: [ canvasRect origin y < rectangle origin y			ifTrue: [ p y - (canvasRect origin y - rectangle origin y) ]			ifFalse: [ rectangle corner y < canvasRect corner y				ifTrue: [ p y - (canvasRect corner y - rectangle corner y) ]				ifFalse: [ p y ] ] ].	^ x@y! !!RSAbstractControlCanvasInteraction methodsFor: 'utilities'!correctRectangle: rectangle camera: camera	| visibleRectangle correctX correctY |	visibleRectangle := camera visibleRectangle.	correctX := self correctValues: {		rectangle origin x.		rectangle corner x.		visibleRectangle origin x.		visibleRectangle corner x}.	correctY := self correctValues: {		rectangle origin y.		rectangle corner y.		visibleRectangle origin y.		visibleRectangle corner y}.	^ correctX @ correctY extent: rectangle extent! !!RSAbstractControlCanvasInteraction methodsFor: 'utilities'!correctValues: array	| min max targetMin targetMax width targetWidth res |	min := array first.	max := array second.	targetMin := array third.	targetMax := array fourth.	width := max - min.	targetWidth := targetMax - targetMin.	res := width < targetWidth ifTrue: [		max < targetMax ifTrue: [ 			min < targetMin				ifTrue: [ min + (targetMin - min) ]				ifFalse: [ min ]		] ifFalse: [ min - (max - targetMax) ].	] ifFalse: [ 		max < targetMax ifTrue: [ 			min-(max - targetMax)		] ifFalse: [ 			min < targetMin				ifTrue: [ min ]				ifFalse: [ min + (targetMin - min) ]		].	].		^ res! !!RSAbstractControlCanvasInteraction methodsFor: 'utilities' prior: 58181327!encompassingRectangleFor: aCanvas	^ aCanvas propertyAt: #encompassingRectangle		ifAbsentPut: [ aCanvas encompassingRectangle  ]! !!RSAbstractControlCanvasInteraction methodsFor: 'utilities' prior: 58184125!expandedRectangle: aCanvas	"^ aCanvas 		propertyAt: #expanedEncompassingRectangle		ifAbsentPut: [ self computeExpandedRectangle: aCanvas ]."	^ self computeExpandedRectangle: aCanvas! !!RSAbstractControlCanvasInteraction methodsFor: 'utilities' prior: 58181795!removeRectanglesFor: aCanvas	aCanvas		removeKey: #encompassingRectangle;		removeKey: #expanedEncompassingRectangle! !!RSAbstractControlCanvasInteraction methodsFor: 'rendering' prior: 58183841!renderLegendOn: anRSLegend	"put a nice description in this legend builder"	self subclassResponsibility! !!RSDraggableCanvasInteraction methodsFor: 'mouse' prior: 58605783!all	"Any mouse button can be used to drag and drop the view"	self mouseEvent: RSMouseDragStart.! !!RSDraggableCanvasInteraction methodsFor: 'computing' prior: 58606163!checkCamera: aCanvas	| camera p correct anime |	self hasDraggableAnimation		ifFalse: [ ^ self ].	camera := aCanvas camera.	p := camera position.	correct := self correctCamera: camera.	correct = p ifTrue: [ ^ self ].	self removeRectanglesFor: aCanvas.	aCanvas propertyAt: self key ifPresent: [ :a | a stop ].	anime := self newAnimation.	aCanvas addAnimation: anime.	aCanvas propertyAt: self key put: anime.	anime		from: p;		to: correct;		onStepDo: [ :t | camera translateTo: t. aCanvas signalUpdate ]! !!RSDraggableCanvasInteraction methodsFor: 'configuration'!hasDraggableAnimation	^ hasDraggableAnimation! !!RSDraggableCanvasInteraction methodsFor: 'configuration'!hasDraggableAnimation: aBoolean	hasDraggableAnimation := aBoolean! !!RSDraggableCanvasInteraction methodsFor: 'initialization' prior: 58603377!initialize	super initialize.	self		all;		hasDraggableAnimation: true.	isMoving := false! !!RSDraggableCanvasInteraction methodsFor: 'mouse' prior: 58605943!left	self mouseEvent: RSMouseLeftDragStart! !!RSDraggableCanvasInteraction methodsFor: 'mouse' prior: 58606049!middle	self mouseEvent: RSMouseMiddleDragStart! !!RSDraggableCanvasInteraction methodsFor: 'events'!mouseDragging: evt	| camera p correct |	isMoving ifFalse: [ ^ self ].	camera := evt camera.	lastStep := evt step.	self hasDraggableAnimation ifTrue: [		correct := self correctCamera: camera.		p := (correct - camera position) abs max: 1@1.		p := p x sqrt @ p y sqrt.		camera translateBy: lastStep/ p	] ifFalse: [		correct := self			correctCamera: camera			matrixDo: [:mat | 	mat translation: (camera position + lastStep) ].		camera translateTo: correct.	].	evt signalUpdate! !!RSDraggableCanvasInteraction methodsFor: 'events' prior: 58603976!mouseEnd: evt	| threshold aCanvas camera delta p correct anime |	isMoving := false.	self hasDraggableAnimation		ifFalse: [ ^ self ].	lastStep ifNil: [ ^ self ].	aCanvas := evt canvas.	camera := evt camera.	threshold := 4.	(lastStep distanceTo: 0@0) < threshold		ifTrue: [ ^ self checkCamera: aCanvas ].	delta := lastStep * 1.5.	lastStep := nil.	camera translateBy: delta.	correct := self correctCamera: camera.	camera translateBy: delta negated.	p := (correct - camera position) abs max: 1@1.	p := p x sqrt @ p y sqrt.	aCanvas propertyAt: self key ifPresent: [ :a | a stop ].	anime := aCanvas newAnimation.	aCanvas propertyAt: self key put: anime.	anime		easing: RSEasingInterpolator cubicOut;		duration: 200 milliSeconds;		from: camera position;		to: camera position + (delta / p);		onStepDo: [ :t | camera translateTo: t. aCanvas signalUpdate ];		when: RSAnimationEndEvent do: [			aCanvas removeKey: self key.			self checkCamera: aCanvas ]		for: self! !!RSDraggableCanvasInteraction methodsFor: 'events' prior: 58603690!mouseStart: evt	self removeRectanglesFor: evt canvas.	isMoving := true.	lastStep := nil! !!RSDraggableCanvasInteraction methodsFor: 'computing'!newAnimation	^ RSTransitionAnimation new		easing: RSEasingInterpolator cubicIn;		duration: 200 milliSeconds;		when: RSAnimationEndEvent do: [:evt | evt canvas removeKey: self key ] for: self;		yourself! !!RSDraggableCanvasInteraction methodsFor: 'hooks' prior: 58603121!onShape: aCanvas	aCanvas 		when: self mouseEvent send: #mouseStart: to: self;		when: RSMouseDragging send: #mouseDragging: to: self;		when: RSMouseDragEnd send: #mouseEnd: to: self.! !!RSDraggableCanvasInteraction methodsFor: 'mouse' prior: 58603012!right	self mouseEvent: RSMouseRightDragStart! !!RSElasticBoxInteraction methodsFor: 'event processing' prior: 58637466!boxEnded: event	| boxEvent |	boxEvent := self createEvent: RSSelectionEndEvent with: event.	boxEvent shape remove.	event canvas removeKey: self className.	boxEvent selectedShapes: selectedShapes.	self announce: boxEvent.	event signalUpdate! !!RSElasticBoxInteraction methodsFor: 'event processing' prior: 58640249!boxStarted: event	| boxEvent |	boxEvent := self createEvent: RSSelectionStartEvent with: event.	boxEvent selectedShapes: (selectedShapes := RSGroup new).	startPosition := event camera fromPixelToSpace: event position.	self announce: boxEvent! !!RSElasticBoxInteraction methodsFor: 'event processing' prior: 58641366!boxUpdated: event	| boxEvent newSelectedShapes |	boxEvent := self createEvent: RSSelectionChangedEvent with: event.	self updateBoxRectangle: boxEvent shape with: event.	newSelectedShapes := self selectedShapesWith: boxEvent shape.	selectedShapes = newSelectedShapes ifFalse: [		boxEvent			oldSelectedShapes: selectedShapes;			selectedShapes: newSelectedShapes.		selectedShapes := newSelectedShapes.		self announce: boxEvent.	].	event signalUpdate! !!RSElasticBoxInteraction methodsFor: 'event processing'!cameraMin: min max: max value: value	(value between: min and: max) ifTrue: [ ^ 0 ].	value < min ifTrue: [ ^ value - min ].	^ value - max! !!RSElasticBoxInteraction methodsFor: 'event processing'!computeCameraDelta: event	| padding visibleRect position x y |	padding := -10 asMargin.	visibleRect := event camera originMode		               visibleRectangleFor: event camera		               rectangle:		               (padding expandRectangle:			                (0 @ 0 corner: event canvas extent)).	position := event position.	x := self		     cameraMin: visibleRect origin x		     max: visibleRect corner x		     value: position x.	y := self		     cameraMin: visibleRect origin y		     max: visibleRect corner y		     value: position y.	cameraDelta := x @ y * -1! !!RSElasticBoxInteraction methodsFor: 'event processing'!createCameraAnimation: event	| canvas animation position correct |	canvas := event canvas.	cameraDelta := 0 asPoint.	(canvas hasProperty: self class) ifTrue: [ 		(canvas propertyAt: self class) stop ].	animation := canvas newAnimation.	animation		repeat;		onStepDo: [ 			canvas camera translateBy: cameraDelta.			position := canvas camera position.			correct := self correctCamera: canvas camera.			correct = position ifFalse: [ canvas camera position: correct ].			canvas signalUpdate ]! !!RSElasticBoxInteraction methodsFor: 'initialization' prior: 58633945!defaultBox	| color |	color := Color colorFrom: '3399FF'.	^ RSBox new		border: (RSBorder new color: color);		color: (color alpha: 0.2)		yourself! !!RSElasticBoxInteraction methodsFor: 'event processing' prior: 58635067!disableDrag: event	draggingCanvas := false.	self boxStarted: event.	self createCameraAnimation: event! !!RSElasticBoxInteraction methodsFor: 'event processing' prior: 58636504!enableDrag: event	draggingCanvas := true! !!RSElasticBoxInteraction methodsFor: 'helper' prior: 58638527!getOrCreateElasticBox: event	^ event canvas		propertyAt: self className		ifAbsentPut: [ self createElasticBox: event ]! !!RSElasticBoxInteraction methodsFor: 'initialization' prior: 58637783!initialize	super initialize.	self leftRight.	baseBox := self defaultBox.	self useNegativeBox.	self targetShapes: #nodes.	draggingCanvas := false! !!RSElasticBoxInteraction methodsFor: 'public' prior: 58642289!leftRight	events := { RSMouseLeftDragStart. RSMouseRightDragStart }! !!RSElasticBoxInteraction methodsFor: 'public' prior: 58640932!noNegativeBox	shouldUseNegativeBox := false! !!RSElasticBoxInteraction methodsFor: 'hooks' prior: 58638710!onShape: aCanvas		aCanvas		when: self dragStartEvent send: #enableDrag: to: self;		when: self boxStartEvent send: #disableDrag: to: self;		when: RSMouseDragging send: #processDrag: to: self;		when: RSMouseDragEnd send: #processDragEnd: to: self! !!RSElasticBoxInteraction methodsFor: 'event processing' prior: 58641049!processDrag: event	draggingCanvas ifTrue: [ ^ self ].	self computeCameraDelta: event.	self boxUpdated: event! !!RSElasticBoxInteraction methodsFor: 'event processing' prior: 58635473!processDragEnd: event	draggingCanvas		ifTrue: [ draggingCanvas := false ]		ifFalse: [ self boxEnded: event.			self stopCameraAnimation: event ]! !!RSElasticBoxInteraction methodsFor: 'public' prior: 58636248!rightLeft	events := { RSMouseRightDragStart. RSMouseLeftDragStart }! !!RSElasticBoxInteraction methodsFor: 'helper' prior: 58633667!selectedShapesWith: shape	| rect |	rect := shape encompassingRectangle.	^ (targetShapes rsValue: shape canvas)		select: [ :node | (node = shape) not and: [ node encompassingRectangle intersects: rect] ]! !!RSElasticBoxInteraction methodsFor: 'event processing'!stopCameraAnimation: event	event canvas propertyAt: self class ifPresent: [ :animation | 		animation stop.		event canvas removeKey: self class ]! !!RSElasticBoxInteraction methodsFor: 'public' prior: 58640684!useNegativeBox	shouldUseNegativeBox := true! !!RSKeepCanvasPositionCanvasInteraction methodsFor: 'hooks' prior: 58819096!onShape: aCanvas	aCanvas when: RSExtentChangedEvent send: #processEvent: to: self.	self processEvent: aCanvas! !!RSKeepCanvasPositionCanvasInteraction methodsFor: 'events - processing' prior: 58818710!processEvent: evt	| canvas camera r padding topLeftPadding zero origin |	self removeRectanglesFor: evt canvas.	camera := evt camera.	canvas := evt canvas.	r := self expandedRectangle: canvas.	padding := self configuration padding.	topLeftPadding := padding left @ padding top.	zero := camera fromSpaceToPixel: 0@0.	origin := camera fromSpaceToPixel: r origin.	camera translateTo: 0@0 - (origin - zero) - (camera originMode gapDistance: camera).	self removeRectanglesFor: canvas.	evt signalUpdate! !!RSKeepCanvasPositionCanvasInteraction methodsFor: 'rendering' prior: 58819287!renderLegendOn: aLegendBuilder! !!RSKeyNavigationCanvasInteraction methodsFor: 'events'!computeSteps: keyName	self hasHorizontalScrolling ifTrue: [		keyName = #LEFT ifTrue: [ steps add: 1 @ 0 ].		keyName = #RIGHT ifTrue: [ steps add:  -1 @ 0 ] ].	self hasVerticalScrolling ifFalse: [ ^ self ].	keyName = #UP ifTrue: [ steps add: 0 @ 1 ].	keyName = #DOWN ifTrue: [ steps add: 0 @ -1 ]! !!RSKeyNavigationCanvasInteraction methodsFor: 'scrollbar managing'!hasHorizontalScrolling	^ hasHorizontalScrolling! !!RSKeyNavigationCanvasInteraction methodsFor: 'scrollbar managing'!hasHorizontalScrolling: aBool	hasHorizontalScrolling := aBool! !!RSKeyNavigationCanvasInteraction methodsFor: 'scrollbar managing'!hasVerticalScrolling	^ hasVerticalScrolling! !!RSKeyNavigationCanvasInteraction methodsFor: 'scrollbar managing'!hasVerticalScrolling: aBool	hasVerticalScrolling := aBool! !!RSKeyNavigationCanvasInteraction methodsFor: 'initialization' prior: 58822445!initialize	super initialize.	self		hasHorizontalScrolling: true;		hasVerticalScrolling: true.	steps := Set new.	speed := 1! !!RSKeyNavigationCanvasInteraction methodsFor: 'hooks' prior: 58822242!onShape: aCanvas	aCanvas		when: RSKeyDown send: #processKeyDown: to: self;		when: RSKeyUp send: #processKeyUp: to: self! !!RSKeyNavigationCanvasInteraction methodsFor: 'events' prior: 58825016!processKeyDown: evt	| keyName |	keyName := evt keyName.	keyName = #I ifTrue: [ ^ self zoomIn: evt canvas ].	keyName = #O ifTrue: [ ^ self zoomOut: evt canvas ].	self computeSteps: keyName.	speedMult := evt shiftKeyPressed		ifTrue: [ 4 ]		ifFalse: [ 1 ].	animation ifNotNil: [ ^ self ].	steps ifEmpty: [ ^ self ].	self processStepsOn: evt canvas! !!RSKeyNavigationCanvasInteraction methodsFor: 'events' prior: 58822582!processKeyUp: evt	| keyName |	steps removeAll.	keyName := evt keyName.	keyName = #M ifTrue: [ ^ self expandCollapse: evt ].	animation ifNil: [ ^ self ].	self removeRectanglesFor: evt canvas.	animation stop.	animation := nil! !!RSKeyNavigationCanvasInteraction methodsFor: 'events' prior: 58824195!processStepsOn: aCanvas	| rect lastMS |	rect := self encompassingRectangleFor: aCanvas.	speed := (rect width min: rect height) * 0.0005.	animation := nil.	lastMS := nil.	animation := aCanvas newAnimation repeat onStepDo: [ :t |		| step camera correct position deltaMS current |		current := animation currentTime.		lastMS ifNil: [ lastMS := current-1 ].		deltaMS := (current - lastMS) max: 1.		lastMS := current.		step := steps inject: 0@0 into: [:p :s |p+s ].		camera := aCanvas camera.		camera translateBy: step / (aCanvas camera scale / (speed * speedMult * deltaMS)).		position := camera position.		correct := self correctCamera: camera.		correct = position 			ifFalse: [ camera position: correct ].		aCanvas signalUpdate.		].! !!RSKeyNavigationCanvasInteraction methodsFor: 'rendering' prior: 58823703!renderLegendOn: lb	lb		text: '   ' description: 'Arrow keys to move the view';		text: 'Shift + arrows' description: 'Accelerate the move';		text: 'M' description: 'Maximize or restore the window';		text: 'I' description: 'Zoom in';		text: 'O' description: 'Zoom out'! !!RSKeyNavigationCanvasInteraction methodsFor: 'events' prior: 58823035!zoomMove: aCanvas delta: delta	RSZoomableCanvasInteraction 		zoomMove: aCanvas 		newScale: (self scaleFor: aCanvas camera scale * delta)! !!RSKeyNavigationCanvasInteraction methodsFor: 'events-processing' prior: 58824070!zoomOut: aCanvas	self zoomMove: aCanvas delta: 0.5! !!RSScrollBarsCanvasInteraction methodsFor: 'hooks' prior: 59148473!addScrollBars: aCanvas	vertical := self barShapeCopy.	horizontal := self barShapeCopy.		aCanvas addShape: vertical; addShape: horizontal! !!RSScrollBarsCanvasInteraction methodsFor: 'private' prior: 59148685!color: color1 border: color2	| c1 c2 extent |	c1 := color1.	c2 := color2.	extent := vertical parent extent.	vertical height >= extent y		ifTrue: [ c1 := c2 := Color transparent ].	vertical		color: c1;		borderColor: c2.	c1 := color1.	c2 := color2.	horizontal width >= extent x		ifTrue: [ c1 := c2 := Color transparent ].	horizontal	 	color: c1;		borderColor: c2! !!RSScrollBarsCanvasInteraction methodsFor: 'initialization' prior: 59148240!initialize	super initialize.	self initializeShape! !!RSScrollBarsCanvasInteraction methodsFor: 'initialization' prior: 59150273!initializeHideAnimation	| sc1 sc2 |	sc1 := NSScale linear range: { self scrollColor. Color transparent }.	sc2 := NSScale linear range: { self scrollBorderColor. Color transparent }.	hideAnimation := vertical parent transitionAnimation		duration: 1 second;		onStepDo: [ :t |			self				color: (sc1 scale: t)				border: (sc2 scale: t).			vertical signalUpdate. ]! !!RSScrollBarsCanvasInteraction methodsFor: 'initialization' prior: 59151177!initializeShape	barShape := RSBox new		cornerRadius: (RSCornerRadius new radius: 5);		size: 10;		noPaint;		isFixed: true;		when: RSMouseDragging send: #moveScroll: to: self;		when: RSMouseEnter send: #mouseEnter: to: self;		when: RSMouseLeave send: #mouseLeave: to: self;		yourself! !!RSScrollBarsCanvasInteraction methodsFor: 'accessing' prior: 59150863!minBarSize	^ 5! !!RSScrollBarsCanvasInteraction methodsFor: 'events'!mouseEnter: evt	"used when the mouse enter in one scroll bar"	| shape |	self removeRectanglesFor: evt canvas.	self updateScrollbars.	shape := evt shape.	shape color isTransparent 		ifFalse: [ shape color: (self scrollColor alpha: 1) ].	animation stop.	hideAnimation stop ! !!RSScrollBarsCanvasInteraction methodsFor: 'events'!mouseLeave: evt	"used when the mouse leave the on bar shape"	| shape |	shape := evt shape.	shape color isTransparent 		ifFalse: [ shape color: self scrollColor ].	self removeRectanglesFor: evt canvas.	vertical parent addAnimation: animation! !!RSScrollBarsCanvasInteraction methodsFor: 'events' prior: 59146537!moveScroll: evt	| shape delta position camera canvasExtent shapesRect correct target |	shape := evt shape.	delta := evt step.	camera := evt camera.	canvasExtent := evt canvas extent.	shapesRect := self encompassingRectangleFor: evt canvas.	delta := shape = vertical		ifTrue: [ 0 @ delta y ]		ifFalse: [ delta x @ 0 ].		shape translateBy: delta.		position := horizontal position x @ vertical position y.	position := position * shapesRect extent / canvasExtent.	target := (position + shapesRect origin) * camera scale negated + (camera originMode gapToCenter: camera).	correct := self		correctCamera: camera		matrixDo: [ :mat | mat translation: target ].		camera translateTo: correct.	correct = target ifFalse: [ self updateBasicScrollbars ].	evt signalUpdate! !!RSScrollBarsCanvasInteraction methodsFor: 'hooks' prior: 59147918!onShape: aCanvas	self addScrollBars: aCanvas.	aCanvas 		when: RSPositionChangedEvent send: #updateScrollbars to: self;		when: RSScaleChangedEvent send: #updateScrollbars to: self;		when: RSExtentChangedEvent send: #updateScrollbars to: self! !!RSScrollBarsCanvasInteraction methodsFor: 'rendering' prior: 59150717!renderLegendOn: lb	lb text: '' description: 'Use scroll bars to navigate'! !!RSScrollBarsCanvasInteraction methodsFor: 'accessing' prior: 59148363!scrollColor	^ Color lightGray translucent! !!RSScrollBarsCanvasInteraction methodsFor: 'hooks' prior: 59149129!updateAnimation	| canvas |	canvas := vertical canvas.	hideAnimation 		ifNil: [ self initializeHideAnimation ].	animation ifNotNil: [ 		animation stop.		hideAnimation stop.		^ canvas addAnimation: animation ].	animation := canvas newAnimation		duration: 700 milliSeconds;		onStepDo: [ :t | canvas signalUpdate ];		when: RSAnimationLoopEvent do: [ 			canvas addAnimation: hideAnimation ]		for: self! !!RSScrollBarsCanvasInteraction methodsFor: 'hooks' prior: 59149601!updateBasicScrollbars	| canvas canvasRect shapesRect p pd ext scrollExtent |	canvas := vertical canvas.	canvasRect := canvas visibleRectangle.	shapesRect := self encompassingRectangleFor: canvas.		scrollExtent := vertical width @ horizontal height.	p := canvas extent - 1 - (scrollExtent / 2).		pd := canvas extent * (canvasRect floatCenter - shapesRect origin) / shapesRect extent.	ext := canvasRect extent * canvas extent / shapesRect extent.	vertical position: p x @ pd y ; height: (ext y max: self minBarSize).	horizontal position: pd x @ p y; width: (ext x max: self minBarSize)	! !!RSScrollWheelCanvasInteraction methodsFor: 'events - processing' prior: 59152506!move: aCanvas delta: delta	| correct p camera |	animation ifNotNil: [ animation stop ].	camera := aCanvas camera.		correct := self correctCamera: camera.	p := (correct - aCanvas camera position) abs max: 1@1.	p := (p x raisedTo: 1/3) @ (p y raisedTo: 1/3).	aCanvas camera translateBy: (0@ delta)/p.	aCanvas signalUpdate.		animation := aCanvas newAnimation		duration: 300 milliSeconds;		onStepDo: [ :t | aCanvas signalUpdate ];		when: RSAnimationLoopEvent do: [ :e |			animation := nil.			correct := self correctCamera: camera.			camera position = correct ifFalse: [				aCanvas newAnimation					duration: 200 milliSeconds;					from: aCanvas camera position;					to: correct;					onStepDo: [ :t | 						aCanvas camera translateTo: t.						aCanvas signalUpdate ] ]			] for: self.! !!RSScrollWheelCanvasInteraction methodsFor: 'events - processing' prior: 59152048!processEvent: evt	| delta |	delta := (evt isUp		ifTrue: [ 1]		ifFalse: [ -1 ]) * 30.	self move: evt canvas delta: delta.! !!RSScrollWheelCanvasInteraction methodsFor: 'rendering' prior: 59152392!renderLegendOn: aLegendBuilder! !!RSSearchInCanvasInteraction methodsFor: 'private - events' prior: 59157845!animateShadowPosition: shadow	| rect correct camera newPosition |	rect := shadow globalEncompassingRectangle.	(canvas visibleRectangle containsRect: rect)		ifTrue: [ ^ self ].	camera := canvas camera.	newPosition := camera positionFromSpace: rect floatCenter.	correct := self correctCamera: camera matrixDo: [ :mat | mat translation: newPosition ].	canvas newAnimation		duration: 500 milliSeconds;		from: canvas camera position;		to: correct;		on: camera set: #position:! !!RSSearchInCanvasInteraction methodsFor: 'util' prior: 59163179!candidateShapes	"Return shapes for which the model has to be matched.	 Only shapes that are not a line and having a model may be eligeable to be highligted"	self assert: [ canvas notNil ] description: 'Canvas should be set first'.	^ canvas allChildren select: [ :child | child model notNil and: [ child isNode ] ]! !!RSSearchInCanvasInteraction methodsFor: 'private - events' prior: 59157167!clickOnLabel: evt	| shapes label index shadow nextShadow |	label := evt shape.	shapes := label propertyAt: #shapesToHighlight.	(shapes isNil or: [shapes isEmpty]) ifTrue: [ ^ self ].	index := label propertyAt: #index ifAbsent: [ 1 ].	shadow := (shapes at: index) propertyAt: #shadow.	shadow color: label color.	index := evt class == RSMouseLeftClick		ifTrue: [ index % shapes size + 1]		ifFalse: [ index - 1 ].	index = 0 ifTrue: [ index := shapes size ].	label propertyAt: #index put: index.	nextShadow := (shapes at: index) propertyAt: #shadow.	self animateShadowPosition: nextShadow! !!RSSearchInCanvasInteraction methodsFor: 'public - configuration' prior: 59161139!colorToHighlight: aColor	"Set the color to highlight shapes when searching"	colorsToUse range at: 1 put: aColor! !!RSSearchInCanvasInteraction methodsFor: 'public' prior: 59165465!doUnhighlightShapes	highlightesShapes do: [ :s | self removeShadow: s ].	highlightesShapes := RSGroup new! !!RSSearchInCanvasInteraction methodsFor: 'private - events' prior: 59164672!hideCurrentShadow: evt	| shapes label index shadow anime |	label := evt shape.	shapes := label propertyAt: #shapesToHighlight.	anime := label propertyAt: #animation.	anime ifNotNil: [		anime stop.		label removeKey: #animation ].	(shapes isNil or: [shapes isEmpty]) ifTrue: [ ^ self ].	index := label propertyAt: #index ifAbsent: [ 1 ].	shadow := (shapes at: index) propertyAt: #shadow.	shadow color: label color! !!RSSearchInCanvasInteraction methodsFor: 'hooks' prior: 59162983!onShape: aCanvas	aCanvas		when: RSKeyUp send: #processKeyUp: to: self;		when: RSScaleChangedEvent send: #updateShadows: to: self! !!RSSearchInCanvasInteraction methodsFor: 'public' prior: 59159135!putShadowOn: shape	| shadow key |	key := #shadow.	shadow := RSBox new		paint: self colorToUseToHighlight;		yourself.	shape removeInteractionIfPresent: self class.	shape		when: RSPositionChangedEvent send: #updateShadow: to: self;		when: RSExtentChangedEvent send: #updateShadow: to: self;		when: RSShapeRemovedEvent send: #removeShadow: to: self.	shape parent ifNotNil: [ shape parent addShape: shadow before: shape ].	shape propertyAt: key		ifPresent: [ :oldShadow | oldShadow remove ].	shape propertyAt: key put: shadow.	self updateShadow: shape! !!RSSearchInCanvasInteraction methodsFor: 'public' prior: 59163839!removeShadow: evt	| shape |	shape := evt shape.	shape propertyAt: #shadow ifPresent: [ :shadow |		shadow remove.		shape removeKey: #shadow.	]! !!RSSearchInCanvasInteraction methodsFor: 'public' prior: 59160041!searchForShapes: regExp	"callback called when some shapes have to be search"	| shapesToHighlight lbl |	shapesToHighlight := self shapesToHighlightUsingRegExp:		                     (self adjustRegExpIfNecessary: regExp).	"No need to pursue if we have not found anything"	shapesToHighlight ifEmpty: [ ^ self ].	self doHighlightShapes: shapesToHighlight.	lbl := RSLabel new text: regExp.	lbl propertyAt: #shapesToHighlight put: shapesToHighlight.	lbl fontSize: 14.	lbl		@ (RSPopup text:  shapesToHighlight size asString, ' elements');		@ highlightableLabels.	lbl when: RSMouseClick send: #clickOnLabel: to: self.	lbl color: self colorToUseToHighlight.	canvas addShape: lbl.	lbl setAsFixed.	fixedLabels add: lbl.	RSHorizontalLineLayout on: fixedLabels.	fixedLabels translateTo: fixedLabels extent / 2 + (5 @ 5).	canvas signalUpdate! !!RSSearchInCanvasInteraction methodsFor: 'util' prior: 59164327!shapesToHighlightUsingRegExp: regExp	"Return the shapes to be highlighted"	| candidateShapes shapesToHighlight |	candidateShapes := self candidateShapes.	shapesToHighlight := candidateShapes		select: [ :s | regExp match: s model asString ].	^ shapesToHighlight! !!RSSearchInCanvasInteraction methodsFor: 'private - events' prior: 59155391!showCurrentShadow: evt	| shapes label anime index shadow |	label := evt shape.	shapes := label propertyAt: #shapesToHighlight.	anime := label propertyAt: #animation.	anime ifNotNil: [ anime stop ].	(shapes isNil or: [shapes isEmpty]) ifTrue: [ ^ self ].	index := label propertyAt: #index ifAbsent: [ 1 ].	shadow := (shapes at: index) propertyAt: #shadow.	self animateShadowPosition: shadow.	anime := label newAnimation		repeat;		duration: 1 second;		scale: (NSScale linear			domain: #(0 0.5 1);			range: {label color. label color negated. label color});		onStepDo: [:newColor |			shadow ifNotNil: [				index := label propertyAt: #index ifAbsent: [ 1 ].				shadow := (shapes at: index) propertyAt: #shadow.				shadow color: newColor.				shadow signalUpdate.			 ]		].	label propertyAt: #animation put: anime! !!RSSearchInCanvasInteraction methodsFor: 'public' prior: 59161532!updateShadow: evt	| shadow shape pad |	shape := evt shape.	shadow := shape propertyAt: #shadow.	shadow ifNil: [ ^ self ].	pad := 5/ (self scaleFrom: shape).	shadow		fromRectangle: (shape encompassingRectangle expandBy: pad);		cornerRadius: pad * 0.75! !!RSSearchInCanvasInteraction methodsFor: 'public' prior: 59158628!updateShadows: evt	highlightesShapes do: [ :each | self updateShadow: each ]! !!RSSelectionInCanvasInteraction class methodsFor: 'examples'!example1	^ (self canvasExample @ self) open! !!RSSelectionInCanvasInteraction class methodsFor: 'examples'!example2	| interaction |	interaction := self new.	interaction shadowColor: Color red.	^ (self canvasExample @ interaction) open! !!RSSelectionInCanvasInteraction methodsFor: 'accessing - defaults'!createBoxSelectionFor: shape	"| border canvas |	canvas := shape parent.	shape removeSelectionBox.				border := RSBox new		cornerRadius: 10;		noPaint;		border: (RSBorder new 			color: self shadowColor;			width: 5;			yourself);		yourself.	shape selectionBox: border.	HUpdateSelectionBox new updateSelectionBox: shape.	canvas addShape: border.	border pushBack."	! !!RSSelectionInCanvasInteraction methodsFor: 'initialization'!defaultShadowColor	^ Color black! !!RSSelectionInCanvasInteraction methodsFor: 'initialization'!initialize	super initialize.	shadowColor := self defaultShadowColor.! !!RSSelectionInCanvasInteraction methodsFor: 'hooks'!onShape: aCanvas	| elastic selectionHigh |	elastic := RSElasticBoxInteraction new.	elastic leftRight.	elastic targetShapes: aCanvas nodes.	selectionHigh := RSHighlightable new		                 "when: RSHighlightEvent		                 do: [ :evt | self createBoxSelectionFor: evt shape ]		                 for: self;		                 when: RSUnHighlightEvent		                 do: [ :evt | evt shape removeSelectionBox ]		                 for: self".	elastic		when: RSSelectionStartEvent		do: [ :evt | selectionHigh unhighlightRecordedShapes: evt canvas ]		for: self;		when: RSSelectionChangedEvent do: [ :evt |			selectionHigh				doHighlightShapes: evt selectedShapes				onCanvas: evt canvas ]		for: self;		when: RSSelectionEndEvent		do: [ :evt | evt canvas selectedShapes: evt selectedShapes ]		for: self.	aCanvas @ elastic! !!RSSelectionInCanvasInteraction methodsFor: 'rendering'!renderLegendOn: lb	lb text: 'Left click' description: 'Use drag and drop to select shapes'! !!RSSelectionInCanvasInteraction methodsFor: 'accessing'!shadowColor	^ shadowColor! !!RSSelectionInCanvasInteraction methodsFor: 'accessing'!shadowColor: aColor 	shadowColor := aColor! !!RSZoomToFitCanvasInteraction methodsFor: 'zoom animation' prior: 59547095!animatedZoomToFit: aCanvas	| oldScale newPosition newScale camera oldPosition |	camera := aCanvas camera.	oldScale := camera scale.	oldPosition := camera position.	aCanvas zoomToFit. 		newPosition := camera position.	newScale := camera scale.		camera translateTo: oldPosition; scale: oldScale.	oldScale < 1 ifTrue: [ 		aCanvas newAnimation			duration: 500 milliSeconds;			easing: RSEasingInterpolator backOut;			onStepDo: [ :t | 				camera					position: (oldPosition interpolateTo: newPosition at: t);					scale: (oldScale interpolateTo: newScale at: t).				aCanvas signalUpdate ].		^ self ].	"when the visualization is bigger and it has to be smaller to fit in the morph extent"	aCanvas animationFrom: {		aCanvas transitionAnimation			duration: 500 milliSeconds;			easing: RSEasingInterpolator backOut;			onStepDo: [:t |				camera position: (oldPosition interpolateTo: newPosition at: t).				camera scale: (oldScale interpolateTo: newScale at: t).				aCanvas signalUpdate];			yourself.		}	! !!RSZoomToFitCanvasInteraction methodsFor: 'initialization'!initialize	super initialize.	self useZoomToFitOnStart; noZoomToFitOnExtendChanged! !!RSZoomToFitCanvasInteraction methodsFor: 'configuration'!noZoomToFitOnExtendChanged	zoomToFitOnExtent := false! !!RSZoomToFitCanvasInteraction methodsFor: 'configuration'!noZoomToFitOnStart	zoomToFitOnStart := false! !!RSZoomToFitCanvasInteraction methodsFor: 'hooks' prior: 59546535!onShape: aCanvas	aCanvas when: RSKeyUp send: #processKeyUp: to: self.	aCanvas when: RSExtentChangedEvent send: #zoomToFitIfNecessary: to: self.	aCanvas camera: (self cameraFor: aCanvas).	self shouldZoomToFitOnStart ifFalse: [ ^ self ].	self zoomToFitOnStart: aCanvas! !!RSZoomToFitCanvasInteraction methodsFor: 'rendering' prior: 59548479!renderLegendOn: lb	lb text: 'Space' description: 'To zoom to fit the view'! !!RSZoomToFitCanvasInteraction methodsFor: 'testing'!shouldZoomToFitOnExtendChanged	^ zoomToFitOnExtent! !!RSZoomToFitCanvasInteraction methodsFor: 'testing'!shouldZoomToFitOnStart	^ zoomToFitOnStart! !!RSZoomToFitCanvasInteraction methodsFor: 'configuration'!useZoomToFitOnExtentChanged	zoomToFitOnExtent := true! !!RSZoomToFitCanvasInteraction methodsFor: 'configuration'!useZoomToFitOnStart	zoomToFitOnStart := true! !!RSZoomToFitCanvasInteraction methodsFor: 'zoom animation' prior: 59548290!zoomToFitIfNecessary: evt	self shouldZoomToFitOnExtendChanged ifFalse: [ ^ self ].	evt canvas zoomToFit! !!RSZoomLevelText methodsFor: 'hooks'!emptyLimit	^ 1! !!RSZoomLevelText methodsFor: 'hooks'!key	^ #referenceLabel! !!RSZoomLevelText methodsFor: 'hooks'!limitText	^ 3! !!RSZoomLevelText methodsFor: 'hooks'!newEmptyBox: shape	| rect |	rect := shape encompassingRectangle.	^ RSBox new		noPaint;		fromRectangle: rect;		yourself! !!RSZoomLevelText methodsFor: 'hooks'!newLine: shape	| rect |	rect := shape encompassingRectangle.	^ RSLine new		paint: shape paint;		startPoint: rect leftCenter;		endPoint: rect rightCenter;		width: rect height;		yourself! !!RSZoomLevelText methodsFor: 'hooks'!onShape: aCanvas	self prepareLabels: aCanvas.	aCanvas when: RSScaleChangedEvent send: #updateZoomLevel: to: self! !!RSZoomLevelText methodsFor: 'hooks'!prepareLabels: aCanvas	| key |	labels := aCanvas allChildren select: [ :shape | shape isLabel ].	key := self key.	labels do: [ :each | each propertyAt: key put: each ]! !!RSZoomLevelText methodsFor: 'hooks'!update: label withNewShape: shape	| currentShape parent key |	key := self key.	currentShape := label propertyAt: key.	parent := currentShape parent.	currentShape remove.	parent add: shape.	label propertyAt: key put: shape! !!RSZoomLevelText methodsFor: 'hooks'!updateZoomLevel: evt	| key |	key := self key.	labels do: [ :each |		| currentShape matrix rect parent |		currentShape := each propertyAt: key.		parent := currentShape parent.		matrix := parent globalMatrix.		matrix scaleBy: evt camera scale.		rect := each computeEncompassingRectangleFor: each encompassingRectangle matrix: matrix.		rect height >= self limitText ifTrue: [			currentShape == each ifFalse: [ self update: each withNewShape: each ]		].		(rect height between: self emptyLimit and: self limitText) ifTrue: [			currentShape isLine ifFalse: [				self update: each withNewShape: (self newLine: each).			]		].		(rect height < self emptyLimit) ifTrue: [			currentShape class = RSBox ifFalse: [				self update: each withNewShape: (self newEmptyBox: each).			]		]	].	evt signalUpdate! !!RSKeepBorderWidthRatioInteraction methodsFor: 'hooks' prior: 58818225!onShape: aShape	| width |	aShape isInACanvas ifFalse: [ self error: 'aShape needs to be part of one canvas' ].	width := aShape border width.	aShape canvas when: RSScaleChangedEvent do: [:evt |		aShape border width: (self scaleFor: evt) * width.		evt signalUpdate ]		for: self! !!RSControlConfiguration methodsFor: 'initialization' prior: 58557770!initialize	super initialize.	self		"used in zoom out"		minScale: 0.04;		"used in zoom in"		maxScale: 7;		padding: 25;		withLegend;		noBasicZoom! !!RSControlConfiguration methodsFor: 'configuration' prior: 58557473!noBasicZoom	shouldUseBasicZoom := false! !!RSControlConfiguration methodsFor: 'configuration' prior: 58558492!useBasicZoom	shouldUseBasicZoom := true! !!RSBlink methodsFor: 'hooks' prior: 58354563!onShape: aShape	| canvas previousColor |	canvas := aShape canvas.	previousColor := aShape color.	aShape color: Color red.	canvas signalUpdate.	canvas newAnimation		duration: 0.5 second;		onStepDo: [ :t | aShape signalUpdate ];		when: RSAnimationEndEvent do: [ :evt |			aShape color: previousColor.			canvas signalUpdate ] 		for: self! !!RSDraggable methodsFor: 'events' prior: 58602274!processDrag: evt	| d |	d := evt camera distanceFromPixelToSpace: evt step.	evt shape translateBy: d.	evt signalUpdate! !!RSGhostDraggable methodsFor: 'accessing' prior: 58696428!color	^ color ifNil: [ color := Color gray ]! !!RSGhostDraggable methodsFor: 'hooks' prior: 58696045!createGhost: evt	| shape ghost parent |	shape := evt shape.	ghost := shape copy		fromRectangle: shape encompassingRectangle;		border: (RSBorder new joinMiter; color: self color; dashArray: #(7 5));		connectedLines: nil;		resetChildren;		noPaint;		yourself.	shape propertyAt: #ghost put: ghost.	parent := shape parent.	parent add: ghost! !!RSGhostDraggable methodsFor: 'hooks' prior: 58695806!onShape: aShape	aShape		when: RSMouseDragStart send: #createGhost: to: self;		when: RSMouseDragging send: #updateGhost: to: self;		when: RSMouseDragEnd send: #removeGhost: to: self! !!RSGhostDraggable methodsFor: 'hooks' prior: 58696725!removeGhost: evt	| ghost |	ghost := evt shape propertyAt: #ghost.	ghost remove.	evt shape translateTo: ghost position.	evt shape removeKey: #ghost.	evt signalUpdate! !!RSGhostDraggable methodsFor: 'hooks' prior: 58696528!updateGhost: evt	| d |	d := evt camera distanceFromPixelToSpace: evt step.	(evt shape propertyAt: #ghost) translateBy: d.	evt signalUpdate! !!RSHighlightable class methodsFor: 'instance colors' prior: 58746659!blue	^ self color: Color blue! !!RSHighlightable class methodsFor: 'instance colors' prior: 58746879!color: aColor	| inst |	inst := self new.	inst highlightColor: aColor.	^ inst! !!RSHighlightable class methodsFor: 'public - lines' prior: 58746031!createEdgesWith: aBlock shape: aShape using: aRSLine from: aRSGroup	| models lines shapes parent |	models := aBlock value: aShape model.	parent := aShape canvas.	shapes := parent shapesFromModels: models.	lines := shapes collect: [:s |		aRSLine copy			from: aShape;			to: s;			yourself ].	parent addAll: lines.	^ lines! !!RSHighlightable class methodsFor: 'instance creation' prior: 58749425!sameModel: aCanvas	"Define an highlight object that is able to highlight the same elements pointed by the mouse.For example:```Smalltalkvalues := #(1 1 2 2 2 2 3 3 3 4 4 5 5 5 5 ).c := RSCanvas new.boxes := values collect: [ :vv | RSBox new size: 10; model: vv ] as: RSGroup.c addAll: boxes.boxes @ RSPopup.boxes @ (RSHighlightable sameModel: c).RSGridLayout on: boxes.c @ RSCanvasController```"	^ self new		highlightBorder: (RSBorder new color: Color yellow; width: 5);		highlightShapes: [ :ss | aCanvas nodes select: [ :sss | (sss model == ss model) and: [ sss ~~ ss ]  ] ]! !!RSHighlightable class methodsFor: 'public - lines' prior: 58743184!showEdges: aBlock using: aRSLine	^ self showEdges: aBlock using: aRSLine from: [ :aShape | aShape parent shapes ]! !!RSHighlightable class methodsFor: 'public - lines' prior: 58743776!showEdges: aBlock using: aRSLine from: aRSGroup	| i |	i := self new.	i		when: RSHighlightEvent do: [ :evt |			evt canvas				propertyAt: #lines				put: (self					createEdgesWith: aBlock					shape: evt shape					using: aRSLine					from: aRSGroup).		] for: self;		when: RSUnHighlightEvent do: [:evt |			evt canvas				propertyAt: #lines ifPresent: [:lines | lines do: #remove ];				removeKey: #lines.		] for: self.	^ i! !!RSHighlightable class methodsFor: 'public' prior: 58754179!withAntAnimation	| i |	i := self new.	i withLines.	i when: RSHighlightEvent do: [ :evt | | shape border |		shape := evt shape.		border := shape border.		shape propertyAt: #ob put: border.		border ifNil: [ border := RSBorder new ].		shape border: (RSBorder new width: border width * 2; color: border color).		shape isNode ifTrue: [			| array anime |			array := #(4).			shape connectedLines do: [ :edge | edge border				color: Color blue;				width: 2;				dashArray: array. ].			anime := shape newAnimation				repeat;				from: 0;				to: -8;				duration: 1 second;				onStepDo: [ :t |					shape connectedLines do: [ :ed |ed border dashOffset: t ].					shape signalUpdate ].			shape canvas propertyAt: #antAnimation put: anime.		].	] for: self.	i when: RSUnHighlightEvent do: [ :evt |		| att shape |		shape := evt shape.		shape border: (shape propertyAt: #ob).		shape removeKey: #ob.		shape isNode ifTrue: [			att := shape canvas properties.			(att at: #antAnimation) stop.			att removeKey: #antAnimation.		 ]	] for: self.	^ i! !!RSHighlightable methodsFor: 'announcer' prior: 58728507!announceHighlight: shape source: shapeOrCanvas	self announce: [ RSHighlightEvent new		interaction: self;		shape: shape;		source: shapeOrCanvas ]! !!RSHighlightable methodsFor: 'announcer' prior: 58732625!announceUnHightlight: shape source: shapeOrCanvas	self announce: [ RSUnHighlightEvent new		interaction: self;		shape: shape;		source: shapeOrCanvas ]! !!RSHighlightable methodsFor: 'actions' prior: 58739664!doHighlight: shape	| shapes |	self unhighlightRecordedShapes: shape.	shapes := self highlightShapesFor: shape.	shapes do: [ :e | self announceHighlight: e source: shape ].	shape canvas propertyAt: self propertyKey put: shapes! !!RSHighlightable methodsFor: 'actions' prior: 58731693!doHighlightShapes: shapes	shapes ifEmpty: [ ^ self ].	self doHighlightShapes: shapes onCanvas: shapes first canvas! !!RSHighlightable methodsFor: 'actions'!doHighlightShapes: shapes onCanvas: aCanvas	"Assuming all the shapes belongs to the same canvas"	| allHShapes |	self unhighlightRecordedShapes: aCanvas.	shapes ifEmpty: [ ^ self ].	allHShapes := shapes flatCollect: [ :s | 		              | hshapes |		              hshapes := self highlightShapesFor: s.		              hshapes do: [ :hs | 			              self announceHighlight: hs source: s ].		              hshapes ].	shapes first canvas propertyAt: self propertyKey put: allHShapes! !!RSHighlightable methodsFor: 'public' prior: 58735466!highlightBorder: aBorder	"Set the border. For example:```Smalltalkc := RSCanvas new.shapes := (1 to: 30) collect: [ :v | RSBox new  size: 20; model: v ] as: RSGroup.c addAll: shapes.shapes @ RSPopup.interaction := RSHighlightable new.interaction highlightBorder: (RSBorder new width: 3; color: Color pink).shapes @ interaction.RSGridLayout on: shapes.c @ RSCanvasController```	"	self		when: RSHighlightEvent do: [ :evt |			self record: evt shape selector: #border value: aBorder ] for: self;		when: RSUnHighlightEvent do: [ :evt | self restore: evt shape selector: #border ] for: self! !!RSHighlightable methodsFor: 'public' prior: 58730668!highlightColor: aColor	"Set the highlight color. For example:```Smalltalkc := RSCanvas new.shapes := (1 to: 30) collect: [ :v | RSBox new  size: 20; model: v ] as: RSGroup.c addAll: shapes.shapes @ RSPopup.interaction := RSHighlightable new.interaction highlightColor: Color blue.shapes @ interaction.RSGridLayout on: shapes.c @ RSCanvasController```Here is another example:```Smalltalkc := RSCanvas new.shapes := (1 to: 10) collect: [ :v | RSEllipse new size: 20; model: v ] as: RSGroup.c addAll: shapes.shapes @ RSPopup @ RSDraggable.RSGridLayout on: shapes.eb := RSEdgeBuilder arrowedLineWithOffset: 0.5.eb canvas: c.eb connectTo: [ :v | 1 ].int := RSHighlightable new withEdges highlightColor: Color red.shapes @ int.c @ RSCanvasController```	"	self		when: RSHighlightEvent do: [ :evt | self record: evt shape selector: #color value: aColor ] for: self;		when: RSUnHighlightEvent do: [ :evt | self restore: evt shape selector: #color ] for: self! !!RSHighlightable methodsFor: 'accessing' prior: 58729157!highlightShapes: aOneArgBlock	"the block accepts a shape (the one selected) should return a collection of shapes. Consider the example:```canvas := RSCanvas new.shapes := RSEllipse models: (1 to: 30).shapes @ RSPopup @ RSDraggable.canvas addAll: shapes.highlightable := RSHighlightable new.highlightable highlightColor: Color green.highlightable highlightShapes: [ :aShape |	shapes select: [ :s | (-1 to: 1) includes: (s model - aShape model)  ] ].shapes @ highlightable.RSGridLayout on: shapes.canvas @ RSCanvasController.canvas open```	"	highlightShapes := aOneArgBlock! !!RSHighlightable methodsFor: 'public - hooks' prior: 58735151!highlightShapesButKeep: aRSHighlightable	self		highlightShapes: [ :e | { e } ]		butKeep: aRSHighlightable! !!RSHighlightable methodsFor: 'public - hooks' prior: 58741210!incomingLines	self highlightShapes: [ :s |		s incomingLines collect: #yourself as: RSGroup ]! !!RSHighlightable methodsFor: 'initialization' prior: 58737748!initialize	super initialize.	self highlightShapes: [ :shape | Array with: shape ]! !!RSHighlightable methodsFor: 'public' prior: 58728710!lowColor: lowColor highColor: highColor	self		when: RSHighlightEvent do: [ :evt | evt shape color: highColor  ] for: self;		when: RSUnHighlightEvent do: [ :evt | evt shape color: lowColor ] for: self! !!RSHighlightable methodsFor: 'hooks' prior: 58736883!onShape: aShape	aShape		when: RSMouseEnter do: [ :evt | self doHighlight: evt shape. evt signalUpdate ] for: self;		when: RSMouseLeave do: [ :evt | self doUnhighlight: evt shape. evt signalUpdate ] for: self! !!RSHighlightable methodsFor: 'public - hooks' prior: 58737895!outgoingLines	self highlightShapes: [ :s |		s outgoingLines collect: #yourself as: RSGroup ]! !!RSHighlightable methodsFor: 'accessing - keys' prior: 58740079!propertyKey: aSymbol	propertyKey := aSymbol! !!RSHighlightable methodsFor: 'private' prior: 58729977!record: aShape selector: selector value: anObject	"Main method to change an attribute of a shape (e.g., colors, border)For example:	-=-=-=-=	c := RSCanvas new.	shapes := (1 to: 10) collect: [ :n | RSEllipse new size: 20; model: n ] as: RSGroup.	c addAll: shapes.	RSGridLayout on: shapes.	RSHighlightable new record: shapes fifth selector: #color value: Color blue.	c	-=-=-=-=	"	| savedValues |	savedValues := aShape properties		at: self copyKey , selector		ifAbsentPut: [ OrderedCollection new ].	savedValues add: (aShape perform: selector).	aShape		perform: selector asMutator		with: (anObject rsValue: aShape)! !!RSHighlightable methodsFor: 'actions' prior: 58741520!resetHighlightedShapes: shapeOrGroupOrCanvas	| att canvas |	(shapeOrGroupOrCanvas class == RSGroup)		ifTrue: [			shapeOrGroupOrCanvas ifEmpty: [ ^ self ].			canvas := shapeOrGroupOrCanvas anyOne canvas ]		ifFalse: [			canvas := shapeOrGroupOrCanvas canvas ].	att := canvas properties.	(att includesKey: self propertyKey) ifFalse: [ ^ self ].	att removeKey: self propertyKey! !!RSHighlightable methodsFor: 'private' prior: 58738737!restore: aShape selector: selector	"Main method to restore the attribute of a shape.	-=-=-=-=-=-=-=-=-=-=-=-=	c := RSCanvas new.	shapes := (1 to: 10) collect: [ :n | RSEllipse new size: 20; model: n ] as: RSGroup.	c addAll: shapes.	RSGridLayout on: shapes.	RSHighlightable new record: shapes fifth selector: #color value: Color blue.	RSHighlightable new restore: shapes fifth selector: #color.	c	-=-=-=-=-=-=-=-=-=-=-=-="	| key savedValues |	key := self copyKey, selector.	savedValues := aShape properties		at: key		ifAbsent: [ ^ self ].	aShape		perform: selector asMutator		with: savedValues removeLast.	savedValues ifEmpty: [ aShape properties removeKey: key ]! !!RSHighlightable methodsFor: 'public - hooks' prior: 58733737!withConnectedShapes	"Highlight shapes that are connected to the pointed shape. For example:```numberOfNodes := 25.numberOfLines := 90.r := Random seed: 42.graph := Dictionary new.1 to: numberOfNodes do: [ :aNode |	graph at: aNode put: Set new ].numberOfLines timesRepeat: [	fromNode := r nextInteger: numberOfNodes.	toNode := r nextInteger: numberOfNodes.	(graph at: fromNode) add: toNode ].canvas := RSCanvas new.nodes := RSCircle models: (1 to: numberOfNodes).nodes @ RSDraggable @ RSPopup.canvas addAll: nodes.highlightable := RSHighlightable new.highlightable highlightColor: Color red.highlightable withEdges.nodes @ highlightable.highlightable2 := RSHighlightable new.highlightable2 highlightColor: Color blue.highlightable2 withConnectedShapes.nodes @ highlightable2.lb := RSLineBuilder line.lb canvas: canvas.lb withBorderAttachPoint.lb makeBidirectional.lb moveBehind.lb objects: (1 to: numberOfNodes).lb connectToAll: [ :aNumber | graph at: aNumber ].RSForceBasedLayout new charge: -300; on: nodes.canvas @ RSCanvasController.canvas open```	"	self highlightShapes: [ :s |		| listIncoming listOutgoing |		listIncoming := s incomingLines collect: [ :aLine | aLine from ] as: RSGroup.		listOutgoing := s outgoingLines collect: [ :aLine | aLine to ] as: RSGroup.		listIncoming, listOutgoing ]! !!RSHighlightable methodsFor: 'public - hooks' prior: 58740571!withEdges	self highlightShapes: [ :s |		| list |		list := s connectedLines copy.		list add: s.		list ]! !!RSHighlightable methodsFor: 'obsolete' prior: 58732426!withIncomingEdges	self highlightShapes: [ :s |		| list |		list := s incomingLines collect: #yourself as: RSGroup.		list add: s.		list ]! !!RSHighlightable methodsFor: 'public - hooks' prior: 58728958!withIncomingLines	self highlightShapes: [ :s |		| list |		list := s incomingLines collect: #yourself as: RSGroup.		list add: s.		list ]! !!RSHighlightable methodsFor: 'public - hooks' prior: 58729813!withLines	self highlightShapes: [ :s |		| list |		list := s connectedLines copy.		list add: s.		list ]! !!RSHighlightable methodsFor: 'obsolete' prior: 58740736!withOutgoingEdges	self highlightShapes: [ :s |		| list |		list := s outgoingLines collect: #yourself as: RSGroup.		list addAll: (s outgoingLines collect: #to).		list ]! !!RSHighlightable methodsFor: 'public - hooks' prior: 58740973!withOutgoingLines	self highlightShapes: [ :s |		| list |		list := s outgoingLines collect: #yourself as: RSGroup.		list addAll: (s outgoingLines collect: #to).		list ]! !!RSHighlightable methodsFor: 'public - hooks' prior: 58732163!withOutgoingLinesOnly    self highlightShapes: [ :s |        | list |        list := s outgoingLines collect: #yourself as: RSGroup.        "list addAll: (s outgoingLines collect: #to)."        list ]! !!RSHighlightable methodsFor: 'public - hooks' prior: 58742152!withOutgoingShapes    self highlightShapes: [ :s |        s outgoingLines collect: [ :aLine | aLine to ] as: RSGroup ]! !!RSInteraction class methodsFor: 'examples'!canvasExample	| canvas |	canvas := RSCanvas new.	canvas background: 'veryVeryLightGray'.	canvas originCenterMiddle.			canvas add: (RSEllipse new		position: 0@0;		extent: 10@10;		borderColor: 'black';		model: 'origin';		color: 'red';		yourself).			canvas add: (RSBox new		position: 200@200;		extent: 200@200;		borderColor: 'black';		model: 'white';		fill: 255;		yourself).	canvas add: (RSBox new		position: 200@200;		extent: 100@100;		borderColor: 'black';		model: 'gray';		fill: 100;		yourself).	canvas shapes @ RSPopup.	^ canvas! !!RSInteraction class methodsFor: 'instance creation' prior: 58816614!onShape: aShape	| inst |	inst := self new.	inst onShape: aShape.	^ inst! !!RSInteraction methodsFor: 'hooks' prior: 58816380!onShape: aShape	self subclassResponsibility! !!RSLabeled class methodsFor: 'accessing' prior: 58865762!highlightable	"Create a label interaction that is highligtable```canvas := RSCanvas new.someColors := { Color red . Color blue . Color green }.shapes := (someColors collect: [ :aColor |	RSEllipse new size: 30; model: aColor; color: aColor ]) asGroup.canvas addAll: shapes.shapes @ RSDraggable.shapes @ RSLabeled highlightable.RSHorizontalLineLayout on: shapes.canvas @ RSCanvasController```"	^ self new highlightable! !!RSLabeled methodsFor: 'hooks' prior: 58861737!createLabel: aShape	| label color set targetLabel |	label := self shapeBuilder shapeFor: (self modelFor: aShape).	location stick: label on: aShape.	isHighlightable		ifFalse: [ ^ label ].	targetLabel := target value: label.	color := targetLabel color.	targetLabel color: self lowColor.	set := [ :c |		label pushFront.		targetLabel color: c.		label signalUpdate ].	aShape		when: RSMouseEnter do: [ set value: color ] for: self;		when: RSMouseLeave do: [ set value: lowColor ] for: self;		when: RSShapeRemovedEvent do: [ label remove ] for: self.	^ label! !!RSLabeled methodsFor: 'public - configuration' prior: 58862957!fontSize: fontSizeAsNumber	"Set the font size of the label```Smalltalkc := RSCanvas new.shapes := (1 to: 100) collect: [ :v |	RSBox new model: v.] as: RSGroup .c addAll: shapes.RSNormalizer size	shapes: shapes;	from: 10;	to: 30;	normalize: #yourself.RSGridLayout on: shapes.shapes @ (RSLabeled new fontSize: 10).c @ RSCanvasController.```"	self shapeBuilder labelShape fontSize: fontSizeAsNumber! !!RSLabeled methodsFor: 'hooks' prior: 58863533!getOrCreateLabel: aShape	| label parent |	label := aShape properties		at: #RSLabeled		ifAbsentPut: [ self createLabel: aShape ].	parent :=aShape parent.	aShape when: RSShapeRemovedEvent send: #remove to: label.	(label isInACanvas not and: [parent notNil ])		ifTrue: [ parent addShape: label shape ].	^ label! !!RSLabeled methodsFor: 'public - configuration' prior: 58864627!highlightable	"Make the label highlightable.For example:```Smalltalkc := RSCanvas new.shapes := (1 to: 10) collect: [ :v | RSBox new model: v; size: 30 ] as: RSGroup.c addAll: shapes.shapes @ RSLabeled new highlightable.RSNormalizer size shapes: shapes; normalize: #yourself.RSGridLayout on: shapes.c @ RSCanvasController.c```"	isHighlightable := true.	self		lowColor: Color veryVeryLightGray;		target: #yourself! !!RSLabeled methodsFor: 'initialization' prior: 58862731!initialize	super initialize.	self shapeBuilder: RSMultilineLabelBuilder new.	self model: #model.	location := RSLocation new above.	isHighlightable := false! !!RSLabeled methodsFor: 'hooks' prior: 58862494!onShape: aShape	aShape isInACanvas		ifTrue: [ self getOrCreateLabel: aShape ]		ifFalse: [ aShape when: RSShapeAddedEvent do: [ :evt |			self getOrCreateLabel: evt shape ] for: self ]! !!RSMenuActivable methodsFor: 'hooks' prior: 58970498!onShape: aShape	"No need to do anything if empty"	menuBlock isNil ifTrue: [ ^ self ].	aShape when: RSMouseRightClick do: [ :evt |		| menu |		menu := MenuMorph new.		menuBlock value: menu value: evt shape.		menu popUpInWorld ]	for: self! !!RSRotated methodsFor: 'hooks' prior: 59142102!dragEnd: evt	drag := false.	prevAngle := nil! !!RSRotated methodsFor: 'hooks' prior: 59142026!dragStart: evt	drag := true! !!RSRotated methodsFor: 'initialization' prior: 59141934!initialize	super initialize.	drag := false! !!RSRotated methodsFor: 'hooks' prior: 59141643!onShape: aShape	targetShape := aShape.	aShape parent		when: RSMouseLeftDragStart send: #dragStart: to: self;		when: RSMouseDragging send: #dragging: to: self;		when: RSMouseDragEnd send: #dragEnd: to: self! !!RSTransformable methodsFor: 'rectangle' prior: 59456774!bottomCenter: position rectangle: rectangle	^ rectangle origin -> (rectangle corner x @ position y)! !!RSTransformable methodsFor: 'rectangle' prior: 59457089!bottomLeft: position rectangle: rectangle	^ (position x @ rectangle origin y) -> (rectangle corner x @ position y)! !!RSTransformable methodsFor: 'rectangle' prior: 59452617!bottomRight: position rectangle: rectangle	^ rectangle origin -> position! !!RSTransformable methodsFor: 'accessing - shapes' prior: 59458624!boxShape	^ RSPolygon new		noPaint;		border: (RSBorder new			color: Color gray);		yourself! !!RSTransformable methodsFor: 'accessing' prior: 59453801!cornersAndSides	^ {	#topLeft -> #topLeft.	#topCenter -> #top.	#topRight -> #topRight.	#rightCenter -> #right.	#bottomRight -> #bottomRight.	#bottomCenter -> #bottom.	#bottomLeft -> #bottomLeft.	#leftCenter -> #left.}! !!RSTransformable methodsFor: 'accessing - shapes' prior: 59452019!createHandlesFor: shape	| handles circles |	handles := RSGroup new.	currentShape := shape.	self saveCurrentShapeState.	handles add: self boxShape.	circles := self cornersAndSides collect: [ :sel | self createHandleFor: sel ].	handles addAll: circles.	"TODO	handles add: self rotationShape."	self saveHandles: handles evt: shape.	self updateHandles: shape.	^ handles! !!RSTransformable methodsFor: 'public' prior: 59451534!disableHandles: evt	| shape key bool |	shape := evt shape.	key := self key.	bool := shape hasProperty: key.	self removeHandles: evt.	bool ifFalse: [ ^ self ].	shape propertyAt: key put: #disable! !!RSTransformable methodsFor: 'public' prior: 59458390!enableHandles: evt	| shape key |	shape := evt shape.	key := self key.	(shape hasProperty: key) ifFalse: [ ^ self ].	shape removeKey: key.	self showHandles: evt! !!RSTransformable methodsFor: 'rectangle' prior: 59452461!leftCenter: position rectangle: rectangle	^ (position x @ rectangle origin y) -> rectangle corner! !!RSTransformable methodsFor: 'hooks' prior: 59456349!onShape: aShape	aShape isNode ifFalse: [ ^ self ].	aShape announcer		when: RSMouseLeftClick send: #showHandles: to: self;		when: RSMouseDragStart send: #disableHandles: to: self;		when: RSMouseDragEnd send: #enableHandles: to: self! !!RSTransformable methodsFor: 'private' prior: 59456093!registerCanvasEventsIfNecessary: evt	| canvas |	canvas := evt canvas.	(canvas hasInteraction: self class) ifTrue: [ ^ self ].	canvas announcer		when: RSMouseClick		send: #removeHandles:		to: self! !!RSTransformable methodsFor: 'cursor' prior: 59451790!removeCursor	self setCursor: nil! !!RSTransformable methodsFor: 'public' prior: 59458779!removeHandles: evt	| canvas key handles |	canvas := evt canvas.	key := self key.	handles := canvas propertyAt: key.	handles ifNil: [ ^ self ].	evt shape ifNotNil: [ :s | s removeKey: key ].	handles do: #remove.	canvas removeKey: key.	canvas signalUpdate! !!RSTransformable methodsFor: 'rectangle' prior: 59456932!rightCenter: position rectangle: rectangle	^ rectangle origin -> (position x @ rectangle corner y)! !!RSTransformable methodsFor: 'private' prior: 59452959!saveCurrentShapeState	| r matrix |	currentShape ifNil: [ ^ self ].	matrix := currentShape matrix.	r := matrix.	r := r sx sign @ r sy sign.	r := currentShape extent * r / 2.	baseRectangle := Rectangle basicNew		privateSetOrigin: r negated;		privateSetCorner: r;		yourself.	currentMatrix := matrix copy		loadIdentity;		translation: currentShape position! !!RSTransformable methodsFor: 'private' prior: 59456641!saveHandles: handles evt: evt	evt canvas propertyAt: self key put: handles! !!RSTransformable methodsFor: 'cursor' prior: 59452825!showCursor: evt	self setCursor: (self cursorForCorner: evt shape model value)! !!RSTransformable methodsFor: 'public' prior: 59454898!showHandles: evt	| parent shape handles |	self removeHandles: evt.	self registerCanvasEventsIfNecessary: evt.	shape := evt shape.	shape propertyAt: self key put: #enable.	handles := self createHandlesFor: shape.	parent := shape parent.	parent addAll: handles.	evt signalUpdate! !!RSTransformable methodsFor: 'rectangle' prior: 59457262!topCenter: position rectangle: rectangle	^ (rectangle origin x @ position y) -> rectangle corner! !!RSTransformable methodsFor: 'rectangle' prior: 59451882!topLeft: position rectangle: rectangle	^ position -> rectangle corner! !!RSTransformable methodsFor: 'rectangle' prior: 59455794!topRight: position rectangle: rectangle	^ (rectangle origin x @ position y) -> (position x @ rectangle corner y)! !!RSTransformable methodsFor: 'update' prior: 59454187!updateHandles: evt	| canvas handles rect base points circles matrix  |	currentShape ifNil: [ ^ self ].	canvas := evt canvas.	handles := canvas propertyAt: self key ifAbsent: [ ^ self ].	rect := currentShape baseRectangle.	base := handles first.	circles := handles copyFrom: 2 to: handles size.	points := Array new: circles size.	matrix := currentShape matrix.	circles doWithIndex: [ :h :index | | position |		position := matrix transform: (h model key value: rect).		h position: position.		points at: index put: position ].	base points: points.	"TODO	rotate := handles last.	rotate position: (matrix transform: rect topCenter - (0@30) )."! !!RSMorphicPopupInteraction methodsFor: 'hooks' prior: 58978546!createPopupFor: aShape event: event	| popup vertices targetMorph world |	targetMorph := self morphBuilder cull: (self modelFor: aShape).	vertices := SimpleBalloonMorph getVertices: targetMorph bounds.	popup := SimpleBalloonMorph new		"color: self backgroundColor;"		addMorph: targetMorph;		setTarget: nil;		setVertices: vertices;		borderColor: Color transparent;		color: Color transparent.	world := event canvas morph world.	world ifNil: [ ^ popup ].	world addMorphFront: popup.	world activeHand balloonHelp: popup.	^ popup! !!RSMorphicPopupInteraction methodsFor: 'initialization' prior: 58977411!initialize	super initialize.	self morphBuilder: [ :model | self popupFor: model ].	gapFromPointer := 0@0! !!RSMorphicPopupInteraction methodsFor: 'hooks' prior: 58977798!translatePopup: aMorph event: evt	| position xdelta ydelta cMorph world |	cMorph := evt canvas morph.	world := cMorph world.	world ifNil: [ ^ self ].	position := (evt camera fromSpaceToPixel: evt position) + cMorph positionInWorld.	xdelta := gapFromPointer x.	ydelta := gapFromPointer y.	(position x + aMorph width) > world width		ifTrue: [ xdelta := xdelta negated - aMorph width ].	(position y + aMorph height) > world height		ifTrue: [ ydelta := ydelta negated - aMorph height ].	aMorph		lock;		fullBounds;		setProperty: #morphicLayerNumber toValue: aMorph morphicLayerNumber.	aMorph position: ((position x + xdelta) max: 0) @ ((position y + ydelta) max: 0)! !!RSSimpleBoxBuilder methodsFor: 'accessing' prior: 59238925!color: aColor	color := aColor! !!RSSimpleBoxBuilder methodsFor: 'initialization' prior: 59238462!initialize	super initialize.	self		border: (RSBorder new color: Color gray);		color: (Color colorFrom: 'efefef');		cornerRadius: 5;		padding: 10@7! !!RSSimpleBoxBuilder methodsFor: 'hooks' prior: 59239012!shapeFor: aRSLabel	^ RSBox new		color: self color;		cornerRadius: self cornerRadius;		border: self border;		extent: aRSLabel extent + self padding;		yourself! !!RSAbstractScaleInteraction methodsFor: 'initialization' prior: 58238025!initialize	super initialize.	self		minScale: 0.1;		maxScale: 3! !!RSAbstractScaleInteraction methodsFor: 'accessing' prior: 58238249!scaleFor: anEvent	| delta |	delta := 1 / anEvent newScale.	^ (maxScale min: delta ) max: minScale! !!RSAbstractPopupInteraction methodsFor: 'hooks' prior: 58231358!activePopupWith: evt	| popup |	popup := self createOrGetPopupOn: evt shape event: evt.	self translatePopup: popup event: evt.	"popup translateBy: (offset rsValue: popup)."	popup position: popup position + (offset rsValue: popup).	evt signalUpdate! !!RSAbstractPopupInteraction methodsFor: 'hooks' prior: 58229130!createOrGetPopupOn: aShape event: event	"Create a popup and register it"	| prop popupShape key |	prop := event canvas properties.	key := self popupKey.	"We checked if the very same shape has emitted the popup.	If this is the case, then we use the popup previously created,	else, we remove it"	((prop includesKey: key) and: [ (prop includesKey: #shapeWithPopup) ])		ifTrue: [ | popup |			popup := prop at: key.			(prop at: #shapeWithPopup) == aShape				ifTrue: [ ^ popup ]				ifFalse: [ self releasePopup: popup ] ].	popupShape := self createPopupFor: aShape event: event.	prop at: key put: popupShape.	prop at: #shapeWithPopup put: aShape.	^ popupShape! !!RSAbstractPopupInteraction methodsFor: 'initialization' prior: 58228855!initialize	super initialize.	self model: #model.	"Offset to locate the popup"	offset := 0 @ 0! !!RSAbstractPopupInteraction methodsFor: 'hooks' prior: 58231675!makeLocateAboveMouseCursor	"Make the popup located above the mouse cursor.```c := RSCanvas new.shapes := RSCircle models: (1 to: 5).RSNormalizer size	shapes: shapes;	normalize.RSNormalizer color	shapes: shapes;	normalize.c addAll: shapes.shapes @ (RSPopup new makeLocateAboveMouseCursor).RSHorizontalLineLayout on: shapes.c @ RSCanvasController```	"	self offset: [ :s | 0 @ (s height negated - 5) ]! !!RSAbstractPopupInteraction methodsFor: 'accessing' prior: 58228436!model: anObject	"	- can be a one arg BlockClosure	- can be a ByteString	"	modelBlock := anObject! !!RSAbstractPopupInteraction methodsFor: 'accessing' prior: 58230640!offset: anOffsetAsPointOrBlock	"Set the offset of the popup. The default behavior, is to have the popup at the location of the	mouse. Which could be cumbersome if the default mouse cursor from the OS is large	For example:```c := RSCanvas new.shapes := RSCircle models: (1 to: 5).RSNormalizer size	shapes: shapes;	normalize.RSNormalizer color	shapes: shapes;	normalize.c addAll: shapes.shapes @ (RSPopup new offset: [ :s | 0 @ (s height negated - 5) ]).RSHorizontalLineLayout on: shapes.c @ RSCanvasController```	"	offset := anOffsetAsPointOrBlock! !!RSAbstractPopupInteraction methodsFor: 'hooks' prior: 58228603!onShape: aShape	aShape removeInteractionIfPresent: self class.	self registerRemoveEventsOn: aShape.	aShape		when: self class activationEvent send: #activePopupWith: to: self! !!RSAbstractPopupInteraction methodsFor: 'hooks' prior: 58228218!registerRemoveEventsOn: aShape	self class removeEvents do: [ :clsEvent | 		aShape 			when: clsEvent			do: [ :evt |				self removePopupOn: evt ]			for: self ]! !!RSAbstractPopupInteraction methodsFor: 'hooks' prior: 58229868!removePopupOn: evt	| att popup key |	"It may happen that the canvas is not set. This is the case when an element is not added to a view.	If the element is not part of a view, then there is nothing to remove, so we exit early."	evt canvas ifNil: [ ^ self ].	att := evt canvas properties.	key := self popupKey.	(att includesKey: key) ifFalse: [ ^ self ].	popup := att at: key.	self releasePopup: popup.	att removeKey: key.	evt signalUpdate! !!RSCanvas methodsFor: '*Roassal3-Interaction'!selectedShapes	^ self propertyAt: #selectedShapes ifAbsent: [ #() ]! !!RSCanvas methodsFor: '*Roassal3-Interaction'!selectedShapes: aGroupOfShapes	self propertyAt: #selectedShapes put: aGroupOfShapes.! !!RSKeepFontSizeRatioInteraction methodsFor: 'hooks' prior: 58819518!onShape: aLabel	| fontSize |	aLabel isInACanvas ifFalse: [ self error: 'add this label to a canvas first' ].	fontSize := aLabel fontSize.	aLabel canvas when: RSScaleChangedEvent do: [ :evt |		aLabel fontSize: (self scaleFor: evt) * fontSize.		evt signalUpdate ]	for: self! !!RSPopup class methodsFor: 'accessing' prior: 59053433!text: aStringOrOneArgBlock	"Define a Popup interaction with a particular text. The argument can either be a text, a symbol, or a one-argument block that is evaluated on the model object of the shape. For example:```canvas := RSCanvas new.someColors := { Color red . Color blue . Color green }.shapes := RSGroup new.someColors do: [ :aColor |	shapes add: (RSEllipse new size: 30; model: aColor; color: aColor) ].canvas addAll: shapes.shapes @ RSDraggable.shapes @ RSLabeled highlightable.shapes @ (RSPopup text: [ :aColor | 'My color is ', aColor asString]).RSHorizontalLineLayout on: shapes.canvas @ RSCanvasController.canvas open.```	"	| inst |	inst := self new.	inst shapeBuilder textBlock: aStringOrOneArgBlock.	^ inst! !!RSPopup class methodsFor: 'accessing' prior: 59052962!themeText: aBlock	"you can create your own custom popups by adding extention methods for this class"	| popup theme |	popup := self text: aBlock.	theme := Smalltalk ui theme.	popup shapeBuilder labelBuilder labelShape color: theme textColor.	popup shapeBuilder boxBuilder		border: (RSBorder new color: theme textColor);		cornerRadius: 0;		color: (theme backgroundColor alpha: 0.8);		padding: 20.	^ popup! !!RSPopup methodsFor: 'hooks' prior: 59052379!createPopupFor: aShape event: event	| popupShape |	popupShape := shapeBuilder shapeFor: (self modelFor: aShape).	popupShape isFixed: true.	event canvas addShape: popupShape.	^ popupShape! !!RSPopup methodsFor: 'initialization' prior: 59051019!initialize	super initialize.	shapeBuilder := RSSimplePopupBuilder new! !!RSPopup methodsFor: 'accessing' prior: 59051218!shapeBuilder: aShapeBuilder	"Let one customize the way the popup is generated. The method accept a shape builder or a one-argument-block. For example:```canvas := RSCanvas new.shapes := RSLabel models: (1 to: 10).canvas addAll: shapes.RSGridLayout on: shapes.popup := RSPopup new.popup shapeBuilder: [ :aNumber |	| g |	g := RSGroup new.	g addAll: (RSCircle models: (1 to: aNumber)).	RSGridLayout on: g.	g asShape		color: Color white darker darker;		padding: 5.].shapes @ popup.canvas zoomToFit.canvas open```"	shapeBuilder := aShapeBuilder! !!RSPopup methodsFor: 'hooks' prior: 59051829!translatePopup: popup event: evt	| p e extent |	p := evt camera fromSpaceToPixel: evt position.	extent := popup canvas extent.	e := (popup extent /2) + 5.	p x + popup width > extent x ifTrue: [		e := e x negated @ e y.		p x - popup width < 0		ifTrue: [ e := p x negated + (popup width/2 + 4) @ e y ].		].	p y + popup height > extent y ifTrue: [		e := e x @ e y negated.		p y - popup height < 0		ifTrue: [ e := e x @ ( p y negated + (popup height/2 + 4) ) ]		].	popup translateTo: p + e! !!RSConfigurableCamera methodsFor: 'zoom'!computeScaleFor: anExtent rectangle: rect	| sc int canvasRect |	sc := super computeScaleFor: anExtent rectangle: rect.	int := self zoomInteraction.	sc := int scaleFor: sc. 	canvasRect := Rectangle		floatCenter: rect floatCenter		extent: canvas extent.	sc := int configuration shouldUseBasicZoom ifTrue: [ 		(canvasRect containsRect: rect)			ifTrue: [ 1 ]			ifFalse: [				int configuration minScale: sc.				sc ]	] ifFalse: [ sc ].	^ sc! !!RSConfigurableCamera methodsFor: 'accessing' prior: 58553148!zoomInteraction: aRSZoomToFitCanvasInteraction	zoomInteraction := aRSZoomToFitCanvasInteraction! !!RSConfigurableCamera methodsFor: 'zoom' prior: 58553470!zoomToFit	| int |	int := self zoomInteraction.	self 		zoomToFit: canvas extent * self zoomRatio		rectangle: (int encompassingRectangleFor: canvas).	int removeRectanglesFor: canvas.	canvas signalUpdate	! !!RSResizeParentWhenChildMoves methodsFor: 'hooks' prior: 59136693!brotherFor: shape from: children	^ children		detect: [ :child | child ~= shape ]		ifNone: [ nil ]! !!RSResizeParentWhenChildMoves methodsFor: 'initialization' prior: 59135248!initialize	super initialize.	self padding: self defaultPadding! !!RSResizeParentWhenChildMoves methodsFor: 'hooks' prior: 59135027!onShape: aCanvas	aCanvas isShape		ifTrue: [ ^ self registerShape: aCanvas ].	aCanvas allChildren do: [ :child | self registerShape: child ]! !!RSResizeParentWhenChildMoves methodsFor: 'hooks' prior: 59136533!registerShape: child	child		when: RSPositionChangedEvent		send: #resizeParent:		to: self! !!RSResizeParentWhenChildMoves methodsFor: 'hooks' prior: 59135379!resizeParent: evt	| shape parent lastPosition delta children brother reference |	shape := evt shape.	parent := self parentFor: shape.	(self isValidParent: parent) ifFalse: [^ self ].	lastPosition := parent position.	delta := evt newPosition - evt oldPosition.	children := self childrenFor: parent.	brother := self brotherFor: shape from: children.	reference := nil.	brother ifNotNil: [		reference := brother parent globalMatrix			transform: brother position ].	parent executeWithoutAnnouncer: [		self prepare: shape with: parent.		parent adjustToChildren.		parent padding: self padding.		 ].	children size = 1 ifTrue: [		shape position: evt oldPosition.		parent translateTo: lastPosition + delta.		^ self ].	parent position: lastPosition.	delta := (brother parent globalMatrix transform: brother position) - reference.	parent translateBy: delta negated! !!RSCanvasController class methodsFor: 'instance creation' prior: 58448626!simple	| inst |	inst := self new.	inst noLegend.	inst zoomToFitInteraction		noZoomToFitOnStart;		noZoomToFitOnExtendChanged.	inst draggableCanvasInteraction hasDraggableAnimation: false.	inst removeInteractionIfPresent: RSZoomToFitCanvasInteraction.	"this interaction works better when the visualization has already been created"	inst addInteractionClass: RSKeepCanvasPositionCanvasInteraction.	^ inst! !!RSCanvasController methodsFor: 'accessing' prior: 58448101!configuration: aRSControlLimits	configuration := aRSControlLimits.	self interactions do: [ :i | i configuration: configuration ]! !!RSCanvasController methodsFor: 'initialization' prior: 58447152!defaultInteractions	"create a subclass of RSCanvasController and define your own custom interactions for your canvas"	^ { 		  RSDraggableCanvasInteraction.		  RSKeyNavigationCanvasInteraction.		  RSZoomToFitCanvasInteraction.		  RSZoomableCanvasInteraction.		  RSScrollBarsCanvasInteraction.		  RSSearchInCanvasInteraction.		  RSSelectionInCanvasInteraction }! !!RSCanvasController methodsFor: 'accessing'!draggableCanvasInteraction	^ interactions at: RSDraggableCanvasInteraction! !!RSCanvasController methodsFor: 'accessing' prior: 58446839!interactionsFromArray: anArray	"{RSZoomableCanvasInteraction new. RSSearchInCanvasInteraction new}"	| collection |	collection := OrderedDictionary new.	anArray do: [ :int |		collection at: int class put: int ].	self interactions: collection! !!RSCanvasController methodsFor: 'accessing'!keyNavigationInteraction	^ interactions at: RSKeyNavigationCanvasInteraction! !!RSCanvasController methodsFor: 'hooks' prior: 58445837!onShape: aCanvas	aCanvas controllerInteraction ifNotNil: [ ^ self ].	aCanvas controllerInteraction: self.	self interactions do: [ :int | int onShape: aCanvas ].	self renderLegendOn: aCanvas! !!RSCanvasController methodsFor: 'hooks' prior: 58447600!renderLegendOn: aCanvas	| lb |	self shouldShowLegend ifFalse: [ ^ self ].	lb := RSLegend new		container: aCanvas;		yourself.	lb defaultTitle fontSize: 12.	lb defaultLabel fontSize: 10.	lb defaultBoldText fontSize: 10.	lb legendDo: [ :l |		l			border: RSBorder new;			color: (Color white alpha: 0.8);			padding: 10.		].	lb title: 'Shortcuts'.	self interactions do: [ :int | int renderLegendOn: lb ].	lb onDemand.	lb build! !!RSCanvasController methodsFor: 'accessing'!zoomToFitInteraction	^ interactions at: RSZoomToFitCanvasInteraction! !!RSKeepMarkersSizeRatioInteraction methodsFor: 'hooks' prior: 58821065!onShape: anEdge	| markers sizes offsets |	anEdge isInACanvas ifFalse: [ self error: 'add this edge to a canvas first' ].	markers := anEdge markers select: #notNil.	sizes := markers collect: [:marker | marker shape extent].	offsets := markers collect: #offset.	anEdge canvas when: RSScaleChangedEvent do: [ :evt | | delta |		delta := self scaleFor: evt.		markers doWithIndex: [ :marker :index |			marker shape extent: delta * (sizes at: index).			marker offset: delta * (offsets at: index)  ] ]	for: self! !!RSAnimatedPopup methodsFor: 'hooks' prior: 58292067!translatePopup: popup event: evt	| p pscale canvasExtent side scale rect shape canvas |	canvas := evt canvas.	shape := evt shape.	canvasExtent := canvas extent.	popup translateTo: 0@0.	shape isFixed ifTrue: [		rect := shape encompassingRectangle.		p := rect floatCenter.		p := p + (0@(shape height + popup height + 10 / 2)).	] ifFalse: [		rect := shape globalEncompassingRectangle.		p := (canvas camera			fromSpaceToPixel: rect bottomCenter)+(0@(popup height +	10/ 2)).	 ].	side := popup width / 2.	p x + side > canvasExtent x		ifTrue: [ p := (canvasExtent x - side - 5)@ p y ].	popup translateTo: p.	"animation part"	pscale := NSScale linear range: { p x @ (p y - (popup height / 2) ) . p }.	scale := popup matrix sx @ popup matrix sy.	evt shape newAnimation		duration: 300 milliSeconds;		from: 0.05; to: 1;		easing: RSEasingInterpolator backOut;		onStepDo: [ :t |			popup matrix				loadIdentity;				translation: (pscale scale: t);				scaleBy: (1@t) * scale.			evt signalUpdate.			]! !!RSShape methodsFor: '*Roassal3-Interaction' prior: 59214589!browseable	self when: RSMouseClick do: [ self model browse  ] for: self! !!RSShape methodsFor: '*Roassal3-Interaction' prior: 59219973!draggable	self @ RSDraggable! !!RSShape methodsFor: '*Roassal3-Interaction' prior: 59217697!labeled	self @ RSLabeled! !!RSShape methodsFor: '*Roassal3-Interaction' prior: 59209565!popup	self @ RSPopup! !!RSShape methodsFor: '*Roassal3-Interaction' prior: 59212181!popupText: aBlock	self @ (RSPopup text: aBlock)! !!RSNodeOnTopWhenPositionChanged methodsFor: 'hooks' prior: 58991823!moveToTop: evt	| shape |	shape := evt shape.	shape ifNil: [ ^ self ].	shape isInACanvas ifFalse: [ ^ self ].	shape pushFront.	(shape withAllChildren flatCollect: #connectedLines) do: #pushFront! !!RSNodeOnTopWhenPositionChanged methodsFor: 'hooks' prior: 58991669!onShape: aShape	aShape		when: RSPositionChangedEvent		send: #moveToTop:		to: self! !!RSSimplePopupBuilder methodsFor: 'hooks' prior: 59243519!boxFor: lbl	^ self boxBuilder shapeFor: lbl! !!RSSimplePopupBuilder methodsFor: 'initialization' prior: 59243230!initialize	super initialize.	self labelBuilder: RSMultilineLabelBuilder new.	self boxBuilder: RSSimpleBoxBuilder new! !!RSGraphCanvasMonitorInteraction methodsFor: 'accessing' prior: 58703986!box	^ RSBox new		extent: 100@ 50;		color: Color lightGray translucent;		cornerRadius: 5;		yourself! !!RSGraphCanvasMonitorInteraction methodsFor: 'initialization' prior: 58703250!initialize	polyScale := NSScale linear		domain: { 1@0. 100@65 };		range: { -50 @ 25. 50@ -25 }.	frames := OrderedCollection new.	super initialize! !!RSGraphCanvasMonitorInteraction methodsFor: 'update' prior: 58703475!updateShape	| cp |	frames add: self lastFramePerSecond.	frames size > shape shapes first extent x		ifTrue: [ frames removeFirst ].	self label text: frames last asString, 'fps'.	cp := frames collectWithIndex: [ :frame :i |		polyScale scale: i @ frame ].	self polyline controlPoints: cp.	cp := cp copy.	cp		add: (polyScale scale: cp size @ 0);		add: (polyScale scale: 0.7@0).	self polygon points: cp.	self updatePolygonPaint! !!RSZoomableCanvasInteraction class methodsFor: 'events'!zoomMove: aCanvas newScale: newScale	| scale camera position morphPosition |	camera := aCanvas camera.	scale := camera scale.		morphPosition := aCanvas morph lastMousePosition - aCanvas morph bounds origin.	position := camera fromPixelToSpace: morphPosition.		aCanvas newAnimation 		easing: RSEasingInterpolator backOut;		duration: 200 milliSeconds;		onStepDo: [ :t | | newPosition zero |			"this method call a loadIdentity in the camera matrix"			camera scale: (scale interpolateTo: newScale at: t).			newPosition := camera fromSpaceToPixel: position.			zero := camera fromSpaceToPixel: 0@0.			camera matrix translation: morphPosition - (newPosition - zero)-(camera originMode gapDistance: camera).			aCanvas signalUpdate ]! !!RSZoomableCanvasInteraction methodsFor: 'hooks' prior: 59550050!onShape: aCanvas	aCanvas when: RSMouseWheelEvent send: #processEvent: to: self! !!RSZoomableCanvasInteraction methodsFor: 'events - processing' prior: 59549792!processEvent: evt	| delta |	animation ifNotNil: [ ^ self ].	delta := evt isUp		ifTrue: [ 1.25 ]		ifFalse: [ 0.8 ].	self class zoomMove: evt canvas newScale: (self scaleFor: evt camera scale * delta).! !!RSZoomableCanvasInteraction methodsFor: 'rendering' prior: 59550199!renderLegendOn: lb	lb text: 'Wheel' description: 'To zoom in-out the view'! !!RSAbstractCanvasMonitorInteraction methodsFor: 'initialization' prior: 58147786!initialize	super initialize.	self initializeShape! !!RSAbstractCanvasMonitorInteraction methodsFor: 'initialization' prior: 58148727!initializeShape	self subclassResponsibility! !!RSAbstractCanvasMonitorInteraction methodsFor: 'hooks' prior: 58147348!onShape: aCanvas	| location |	self assert: shape notNil description: 'Define your monitor shape'.	shape isFixed: true.	aCanvas addShape: shape.	location := RSLocation new inner; bottom; left; offset: 10@0.	canvas := aCanvas.	aCanvas newAnimation		repeat;		onStepDo: [ :t |			self updateShape.			location move: shape on: aCanvas basicRectangle ]! !!RSTranscriptCanvasMonitor methodsFor: 'initialization'!initialize	canvasIdString := 'RSCanvas#{1}' format: { canvas identityHash }.	super initialize.! !!RSTranscriptCanvasMonitor methodsFor: 'initialization'!initializeShape	shape := RSLabel new		         text: 'Tracing FPS in Transcript - ', canvasIdString;		         yourself! !!RSTranscriptCanvasMonitor methodsFor: 'update'!updateShape	"Hacky: instead of updating the shape, we trace on the transcript."	('{1} - {2} fps' format: {			 canvasIdString.			 self lastFramePerSecond }) traceCr! !!RSGroup methodsFor: '*Roassal3-Interaction' prior: 58710729!@ interaction	"Apply an interaction on each shape contained in the group.For example:```Smalltalkg := RSGroup new.g add: (RSBox new size: 10; model: 'hello').g add: (RSBox new size: 10; model: 'World').RSHorizontalLineLayout on: g.g @ RSPopup.c := RSCanvas new.c addAll: g.c```"	self do: [ :e | e @ interaction ]! !!RSGroup methodsFor: '*Roassal3-Interaction' prior: 58717762!addInteraction: interaction	self do: [ :e | e addInteraction: interaction ]! !RSZoomableCanvasInteraction removeSelector: #renderOn:!RSZoomableCanvasInteraction removeSelector: #move:evtPosition:delta:!RSControlConfiguration removeSelector: #useZoomToFitOnStart!RSControlConfiguration removeSelector: #useZoomToFitOnExtendChanged!RSControlConfiguration removeSelector: #shouldZoomToFitOnStart!RSControlConfiguration removeSelector: #shouldZoomToFitOnExtendChanged!RSControlConfiguration removeSelector: #noZoomToFitOnStart!RSControlConfiguration removeSelector: #noZoomToFitOnExtendChanged!RSControlConfiguration removeSelector: #hasVerticalScrolling:!RSControlConfiguration removeSelector: #hasVerticalScrolling!RSControlConfiguration removeSelector: #hasHorizontalScrolling:!RSControlConfiguration removeSelector: #hasHorizontalScrolling!RSControlConfiguration removeSelector: #hasDraggableAnimation:!RSControlConfiguration removeSelector: #hasDraggableAnimation!RSDraggable class removeSelector: #wantsUniqueInstance!RSDraggableCanvasInteraction removeSelector: #mouseMove:!RSAbstractControlCanvasInteraction removeSelector: #correctCameraPosition:scale:!RSAbstractControlCanvasInteraction removeSelector: #correctCameraPosition:!RSInteraction class removeSelector: #wantsUniqueInstance!RSInteraction class removeSelector: #reset!RSInteraction class removeSelector: #instance!"Roassal3-Interaction"!!RSMockShape commentStamp: '' prior: 58972342!The RSMockShape class in Roassal3 is used for testing and mocking purposes. It provides a way to create mock shapes that can be used to test the behavior of other Roassal3 classes that depend on shapes.!!RSMockShape class methodsFor: 'accessing'!shapes: aCollection	^ aCollection collect: [ :shape | 		self new 			realShape: shape;			yourself ]! !!RSMockShape methodsFor: 'actions' prior: 58973882!applyToRealElement	isFixed ifTrue: [ ^ self ].	realShape translateTo: position! !!RSMockShape methodsFor: 'accessing' prior: 58974016!encompassingRectangle	^ Rectangle floatCenter: position extent: self extent! !!RSMockShape methodsFor: 'accessing' prior: 58973098!extent	^ width @ height! !!RSMockShape methodsFor: 'accessing' prior: 58974126!height	^ height! !!RSMockShape methodsFor: 'initialization' prior: 58972997!initialize	super initialize.	isFixed := false! !!RSMockShape methodsFor: 'accessing' prior: 58973488!isFixed	^ isFixed! !!RSMockShape methodsFor: 'accessing' prior: 58973724!realShape: aRSShape	| extent |	extent := aRSShape extent.	realShape := aRSShape.	position := aRSShape position.	width := extent x.	height := extent y.	self oldPosition: position! !!RSMockShape methodsFor: 'accessing'!textExtents	^ realShape textExtents! !!RSMockShape methodsFor: 'accessing' prior: 58974205!width	^ width! !!RSDummyNode class methodsFor: 'instance creation' prior: 58613559!on: anEdge slot: anIndex	^(self new)		edge: anEdge;		slot: anIndex;		yourself! !!RSDummyNode methodsFor: 'accessing' prior: 58613201!slot: anIndex! !!RSLayoutTranslator methodsFor: 'hook' prior: 58877620!translate: element to: newPosition	"Translate of the center of the element"	self subclassResponsibility! !!RSLayoutTranslator methodsFor: 'public - translating' prior: 58878002!translateBottomLeftOf: element to: newPosition	"Translate the bottom left corner of the element"	self translate: element to: newPosition direction: 1 @ -1! !!RSMockLine methodsFor: 'accessing' prior: 58971827!strength	^ strength! !!RSDSMGraph class methodsFor: 'instance creation' prior: 58573459!new: aNumber	^ self new		numberOfVertices: aNumber;		yourself! !!RSDSMGraph methodsFor: 'adding' prior: 58570273!addEdge: anInteger to: anInteger2	(graph at: anInteger ifAbsentPut: [ OrderedCollection new ]) add: anInteger2! !!RSDSMGraph methodsFor: 'public' prior: 58571046!computeSCCs	| stack visited gr groups |	groups := OrderedCollection new.	stack := Stack new.	visited := Array new: numberOfVertices withAll: false.	1 to: numberOfVertices do: [ :index |		(visited at: index)			ifFalse: [ self fillOrder: index visited: visited stack: stack ]	].	gr := self getTranspose.	visited := Array new: numberOfVertices withAll: false.	[ stack isEmpty ] whileFalse: [ | index |		index := stack pop.		(visited at: index) ifFalse: [			gr dfsUtil: index visited: visited groups: groups.			groups add: OrderedCollection new.		]	].	^ groups allButLast! !!RSDSMGraph methodsFor: 'utilties' prior: 58570791!dfsUtil: index visited: visited	visited at: index put: true.	index trace.	(graph at: index ifAbsent: [ #() ]) do: [ :each |		(visited at: each)			ifFalse: [ self dfsUtil: each visited: visited ]		 ]! !!RSDSMGraph methodsFor: 'utilties' prior: 58571795!dfsUtil: index visited: visited groups: groups	visited at: index put: true.	groups ifEmpty: [		groups add: OrderedCollection new.		 ].	groups last add: index.	(graph at: index ifAbsent: [ #() ]) do: [ :each |		(visited at: each)			ifFalse: [ self dfsUtil: each visited: visited groups: groups ]		 ]! !!RSDSMGraph methodsFor: 'examples' prior: 58570548!example01	<script: 'self new example01 inspect'>	| g |	g := self class new: 5.	g		addEdge: 2 to: 1;		addEdge: 1 to: 3;		addEdge: 3 to: 2;		addEdge: 1 to: 4;		addEdge: 4 to: 5.	g printSCCs! !!RSDSMGraph methodsFor: 'examples' prior: 58572157!example02	<script: 'self new example02 inspect'>	| g |	g := self class new: 5.	g		addEdge: 2 to: 1;		addEdge: 1 to: 3;		addEdge: 3 to: 2;		addEdge: 1 to: 4;		addEdge: 4 to: 5.	^ g computeSCCs! !!RSDSMGraph methodsFor: 'private' prior: 58572411!fillOrder: index visited: visited stack: stack	visited at: index put: true.	(graph at: index ifAbsent: [ #()]) do: [ :each |		(visited at: each)			ifFalse: [ self fillOrder: each visited: visited stack: stack ]		 ].	stack push: index! !!RSDSMGraph methodsFor: 'private' prior: 58573240!getTranspose	| g |	g := self class new: numberOfVertices.	graph keysAndValuesDo: [ :k :value |		value do: [ :j |			g addEdge: j to: k ]		 ].	^ g! !!RSDSMGraph methodsFor: 'initialization' prior: 58570442!initialize	super initialize.	graph := Dictionary new! !!RSDSMGraph methodsFor: 'accessing' prior: 58571685!numberOfVertices: anInteger	numberOfVertices := anInteger! !!RSDSMGraph methodsFor: 'public' prior: 58572703!printSCCs	| stack visited gr |	stack := Stack new.	visited := Array new: numberOfVertices withAll: false.	1 to: numberOfVertices do: [ :index |		(visited at: index)			ifFalse: [ self fillOrder: index visited: visited stack: stack ]	].	gr := self getTranspose.	visited := Array new: numberOfVertices withAll: false.	[ stack isEmpty ] whileFalse: [ | index |		index := stack pop.		(visited at: index) ifFalse: [			gr dfsUtil: index visited: visited.			'' traceCr.			 ]	 ]! !RSSortBlock removeSelector: #value:value:!RSSortBlock removeSelector: #fixTemps!Smalltalk globals removeClassNamed: #AnObsoleteRSSortBlock!"Roassal3-Layouts-Util"!!RSTGapsHolder commentStamp: '' prior: 59295737!This trait provides methods to propagate the vertical gap and horizontal gap!!RSTWalkBasedRegularHorizontalTreeLayout commentStamp: '' prior: 0!This trait defines methods to get information of a roassal shape like the gap, the width and height.It applies this properties for a horizontal tree layout.Check similarities with `RSTWalkBasedRegularVerticalTreeLayout`!!RSTWalkBasedRegularTreeLayoutOnShapeProperties commentStamp: '' prior: 0!I adds utility methods to access meta information of the layout algorithm and I store that information the the shape properties dictionary!!RSTWalkBasedRegularTreeLayoutRandomizedPositioning commentStamp: '' prior: 0!I generate a random position for a given shape!!RSTWalkBasedRegularVerticalTreeLayout commentStamp: '' prior: 0!This trait defines methods to get information of a roassal shape like the gap, the width and height.It applies this properties for a vertical tree layout.Check similarities with `RSTWalkBasedRegularHorizontalTreeLayout`!!RSAlignment commentStamp: '' prior: 58279033!Define alignment of aligment for shapes. Note that some layouts like `RSVerticalLineLayout` or `RSHorizontalLineLayout` uses internally this class for aligment operationsUsers should use `shapes` before any alignment operation.```align := RSAlignment new.align shapes: someShapes.align bottom.```# Operations- vertical operations are `bottom`, `top`, `middle`, `label`.	- `label` operation align labels based on its baseline.	- for vertical operation `label` shapes should be a collection of `RSLabel`- horizontal operations are `left`, `center`, `right`.- none, you can apply none operation, to skip any alignment.!!RSResize commentStamp: '' prior: 59132262!Adjust the size of the shapes!!RSLayout commentStamp: '' prior: 58867071!`RSLayout` is an abstract class which represents a layout made to set the position of a group of shapes.Layouts perform once on a group of shapes, if you want to apply a relayout, you have to call again the layout.You can use the layout creating a new instance of it.```stlayout := RSGridLayout new.layout on: shapes.```Or using the class method `RSLayout class >> #on:````stRSGridLayout on: shapes```My instance variable is- translator, an `RSLayoutTranslator` to set the position based on the bounding box of each shape.I collaborate with- `RSBoundingShape` to get the shape position.- `RSAbstractLine` to get the relation between two bounding shapes.I provide the following methods.- `RSLayout >> #on:`, a shortcut to call `applyOn:`- `RSLayout >> #on:edges:`, similar to on, but using custom links/edges/lines.- `RSLayout >> #userDefinedEdges:`, to set the nodes links/edges/lines for the layout.- `RSLayout >> #applyOn:`, a shortcut to call `executeOnElements:`- `RSLayout >> #executeOnElements:`, to initialize and call the execution of the layout- `RSLayout >> #doInitialize:`, override this method to initialize the layout with a group of shapes.- `RSLayout >> #doExecute:`, override this method and set the position of each element here.- `RSLayout >> #doPost:`, orerride this method to finalize the the layout process.!!RSAbstractBoxedLayout commentStamp: '' prior: 0!I define a layouts with horizontal and vertical gap spaces between elements.### Variables- horizontalGap, the horizontal gap space between shapes in the layout.- verticalGap, the vertical gap space between shapes in the layout.- gapSize, will modify both, horizontal and vertical gaps!!RSAbstractFlowLayout commentStamp: '' prior: 58189705!I contain gap distance size between each element, in vertical and horizontal axis.### Variables- horizontalGap, the horizontal distance size between elements in the layout- verticalGap, the vertical distance size between elements in the layout- gapSize, a number used to change both values, vertical and horizontal!!RSFlowLayout commentStamp: '' prior: 58668400!A RSFlowLayout arrange shapes in a rectangle including space (gapSize) between them, ideally it give you a square if all elements have an equal height and width.I work with RSAlignment !!RSHorizontalFlowLayout commentStamp: '' prior: 58769876!A RSHorizontalFlowLayout is a FlowLayout horizontaly arranged, right queued at default.!!RSAbstractGridLayout commentStamp: '' prior: 58197937!Abstract class for grid layouts.My subclasses are `RSCellLayout`, `RSGridLayout` and `RSVerticalCellLayout`.My instance variables are:- gapSize the space between each element- lineItemsCount: a number or block to compute the number of desired elements per row.!!RSCellLayout commentStamp: '' prior: 58462173!`RSCellLayout` places shapes keeping their order from left to right.Use `lineItemsCount:` to set the number of items per line.Note with elements of different size each line will have different size also.!!RSGridLayout commentStamp: '' prior: 58705383!Elements of each column are centered along the same vertical line. And elements of each row are centered along the same horizontal line.I have vertical and horizontal alignments. The alignment uses class `RSLocation` in the selected rectangle!!RSVerticalCellLayout commentStamp: '' prior: 0!RSVerticalGridLayout places shapes as a grid. Shapes keeps their order, from top to down, and then left to right.!!RSAbstractLineLayout commentStamp: '' prior: 58217643!I represent an abstract line layout for arranging elements in a line-based format.My subclasses define specific line layout algorithms, such as horizontal or vertical arrangements.Usage:- Create an instance of a subclass, such as RSVerticalLineLayout or RSHorizontalLineLayout.- Set layout-specific properties, such as spacing or alignment, if supported by the subclass.- Call #on: to perform the layout calculations and update the positions of the elements.!!RSAngleLineLayout commentStamp: '' prior: 58289340!This layout uses an angle to describe a line where the elements would be placed!!RSHorizontalLineLayout commentStamp: '' prior: 58772081!A RSHorizontalLineLayout locates all the elements horizontally.You can use label alignment to align labels based on baseline of each font.!!RSVerticalLineLayout commentStamp: '' prior: 59517577!A RSVerticalLineLayout locates all the elements vertically.!!RSCircleLayout commentStamp: '' prior: 58494728!RSCircleLayout is a layout algorithm that arranges shapes in a circle around a center point. The objects are placed evenly around the circle, with a specified distance from the center.To use RSCircleLayout, create an instance of the class and specify the center point and radius of the circle using the center and radius instance variables. Then, use `on:` method with the shapes you want to layout.RSCircleLayout supports customizable attributes such as angle offsets, and radial offsets. These attributes can be set using the corresponding instance variables.For more information, see the class methods and instance variables of RSCircleLayout.!!RSEquidistantCircleLayout commentStamp: '' prior: 58658162!`RSEquidistantCircleLayout` is a circle layout in which elements are equidistant from each other: the layout maintains the same distance between elements.!!RSWeightedCircleLayout commentStamp: '' prior: 59522801!RSWeightedCircleLayout is a circle layout that gives more space to big elements and fewer space to small elements.!!RSCircularAroundAVertexLayout commentStamp: '' prior: 58495752!This layout finds the shape with most connexions then it uses a circular(`RSEquidistantCircleLayout`) layout with the rest.Then the layout moves the shape with most connexions into the center.Users can select the center element using `centerIndex:`, if the center element is index in the collection of objects is not defined, then would be computed using the element with more connections!!RSClusteringLayout commentStamp: '' prior: 58514056!Creates a layout of all connected shapes, all connected shapes are going to have `forEachLayout`.Then the clusters will have perform `clustersLayout`.In general I have 2 layouts, one for clusters another of elements inside each cluster.!!RSConditionalLayout commentStamp: '' prior: 58550366!`RSConditionalLayout` applies two layouts on a set of shapes using a condition*Responsibility*: Shapes matching a given condition use a particular layout, else another layout is applied *Collaborators*: Shapes and layouts*Variables*:- `if`: one-arg block or symbol to be applied on a shape. Must return a boolean when applied. - `thenLayout`: a layout used for the shapes that matches the condition- `thenLayout `: a layout used for the shapes that do not match the condition!!Trait method!modOf: arg1 	self traitConflict! !!Trait method!modOf: arg1 put: arg2 	self traitConflict! !!Trait method!modOf: arg1 put: arg2 	self traitConflict! !!Trait method!modOf: arg1 	self traitConflict! !!Trait method!modOf: arg1 put: arg2 	self traitConflict! !!Trait method!modOf: arg1 	self traitConflict! !!RSLineDrivenLayout commentStamp: '' prior: 58927304!This class implements a layout algorithm that arranges objects based on their connections, using lines to guide their positioning.My subclasses are `RSAbstractGraphLayout` and `RSForceBasedLayout`I define utility methods to find the lines/edges connections used in my subclasses!!RSAbstractGraphLayout commentStamp: '' prior: 58191616!It offers methods for initializing the layout, performing layout computations, and updating the positions of nodes and edges based on the chosen algorithm.!!RSAbstractCompactTreeLayout commentStamp: '' prior: 58158837!I describe a compact layout of information, I visit the graph and put each level in a dictionary to access the children of each node!!RSRadialTreeLayout commentStamp: '' prior: 59105945!The `RSRadialTreeLayout` class implements a layout algorithm for arranging nodes in a radial tree structure. It places nodes in a hierarchical structure with a single root node at the center and branches radiating outwards from it.Radial tree layouts are useful for visualizing hierarchical relationships, such as organizational charts or family trees, where the focus is on the relationships between the nodes rather than the precise positions of the nodes.!!RSAbstractRegularTreeLayout commentStamp: '' prior: 58233699!Abstract class of regular tree layouts defines utility methods for naviagate in the graphin a tree style.Description:The `RSAbstractRegularTreeLayout` class is an abstract base class that provides common functionality for regular tree layout algorithms in Roassal. Regular tree layouts arrange nodes in a tree-like structure where each level of the tree is aligned horizontally or verticallyYou can use it verticalReversed or horizontalReversed!!RSAbstractHorizontalTreeLayout commentStamp: '' prior: 58201075!The `RSAbstractHorizontalTreeLayout` class is an abstract base class that provides common functionality for horizontal tree layout algorithms in Roassal. Horizontal tree layouts arrange nodes in a tree-like structure where each level of the tree is aligned vertically.Instances of `RSAbstractHorizontalTreeLayout` can be used with `RSHorizontalTreeLayout`!!RSHorizontalDominanceTreeLayout commentStamp: '' prior: 58769675!Dominance analysis from graph theory allows one to locate subordinated elements in a rooted dependency graph. It identifies the nesting structure for a dependency graph as a dominance horizontal tree!!RSHorizontalTreeLayout commentStamp: '' prior: 58776643!Regular Hoorizontal tree layout, similar to `RSTreeLayout` but horizontal direction!!RSAbstractVerticalTreeLayout commentStamp: '' prior: 58265763!The `RSAbstractVerticalTreeLayout` class is an abstract base class that provides common functionality for vertical tree layout algorithms in Roassal. Vertical tree layouts arrange nodes in a tree-like structure where each level of the tree is aligned horizontally.Instances of `RSAbstractVerticalTreeLayout` can be used with `RSVerticalTree`!!RSDominanceTreeLayout commentStamp: '' prior: 58599060!Dominance analysis from graph theory allows one to locate subordinated elements in a rooted dependency graph. It identifies the nesting structure for a dependency graph as a dominance vertical tree!!Trait method!modOf: arg1 	self traitConflict! !!Trait method!modOf: arg1 put: arg2 	self traitConflict! !!Trait method!modOf: arg1 put: arg2 	self traitConflict! !!Trait method!modOf: arg1 	self traitConflict! !!Trait method!modOf: arg1 put: arg2 	self traitConflict! !!Trait method!modOf: arg1 	self traitConflict! !!RSTreeLayout commentStamp: '' prior: 59468566!The `RSTreeLayout` class implements a layout algorithm for arranging nodes in a tree structure. It places nodes in a hierarchical structure with a single root node at the top and child nodes arranged below their parents.Also known as RSVerticalTreeLayout!!RSClusterTreeLayout commentStamp: '' prior: 58498822!The `RSClusterTreeLayout` class implements a layout algorithm for arranging nodes in a cluster tree structure. It organizes nodes into hierarchical clusters where each cluster represents a subset of nodes. Clusters can be nested within each other, forming a tree-like structure.Cluster tree layouts are useful for visualizing hierarchical relationships and grouping related nodes together.!!RSClusterRadialTreeLayout commentStamp: '' prior: 0!This class combines a cluster tree layout and Radial tree layout to undestand big groups!!RSSugiyamaLayout commentStamp: '' prior: 59251174!The SugiyamaLayout class implements the Sugiyama algorithm, a popular graph layout algorithm used to create hierarchical layouts of directed acyclic graphs (DAGs). This algorithm organizes nodes into multiple layers and minimizes the number of edge crossings, resulting in a visually appealing and easy-to-understand representation of the input graph.Based on Coffman-Graham-Layering. Di Battista Book, page 275, chapter, 9.2.1!!RSForceBasedLayout commentStamp: '' prior: 58671399!I am a layout that uses forces in each elements, I have create a light representation of one element.On a given graph or network. It uses the force-directed layout approach to position the nodesThe class provides methods to configure the layout parameters, such as the force constants,The force-based layout algorithm works by simulating a physical system, where nodes aretreated as particles that repel each other due to electrical charges and are attractedto each other by springs. By iteratively applying these forces, the algorithm moves thenodes towards an equilibrium state, resulting in an aesthetically pleasing layout.The RSForceBasedLayout class provides a flexible and efficient implementation of theforce-directed layout algorithm, allowing users to apply it to a variety of graph structures.# CollaboratorsI work with `RSMockShape` and `RSMockLine`. I work for optimization I work with `RSQuadTreeForce`!!RSNoLayout commentStamp: '' prior: 58990284!RSNoLayout represents a no-layout strategy.This class is used when no specific layout is required for visualizing objects in Roassal.It serves as a placeholder for situations where the user wants to display objects without applying any layout algorithms.!!RSRectanglePackLayout commentStamp: '' prior: 59116000!A layout that packs elements according to their bounding box. Check #gap and #preferredAngle!!RSSimpleForceBasedLayout commentStamp: '' prior: 0!Because class `RSForceBasedLayout` is hard to configure, this object provides a nice default behavior to work with force layout without many configurations!!RSLocation commentStamp: '' prior: 58949788!<keyClass>`RSLocation` locates shapes with respect to other shapes. Shapes can be positioned in a sticky fashion or not. Being sticky means whether the base shapes "drag" the sitcky shapes when dragged. `RSLocation` iteratively builds constraint for moving and positioning a shape on top of another one.*Responsibility*: locate permanently or not some shapes with respect to other shapes.*Collaborators*: closely interact with `RSShape`, `RSExtentChangedEvent`, and `RSPositionChangedEvent`*Variables*:- `offset`: offset between the positioned shape and the base shape- `orientation`: a value that could be -1, 0, 1 indicating the orientation of the location- `direction`: a point indicating the direction of the lcoation!!RSTWalkBasedRegularTreeLayout methodsFor: 'algorithm' prior: 59368173!addChildSpacing: children	^ children inject: 0 @ 0 into: [ :aPoint :child |		  | x newPoint y |		  x := aPoint x + (self shiftOf: child).		  y := x + aPoint y + (self changeOf: child).		  newPoint := Point x: x y: y.		  self modOf: child update: [ :mod | mod + newPoint y ].		  newPoint ]! !!RSTWalkBasedRegularTreeLayout methodsFor: 'algorithm' prior: 59380976!firstWalk: v	self		is: v		ifLeaf: [ self setExtremesOfLeaf: v ]		ifNotLeaf: [ :children |			| leftMostChild rightMostChild chain bound |			leftMostChild := children first.			rightMostChild := children last.			"Recur down on v's leftmost child."			self firstWalk: leftMostChild.			"Create siblings in contour minimal vertical coordinate and index list."			bound := self depthBoundOf: (self elOf: leftMostChild).			chain := (2 to: children size)				         inject: (self updateIYL: bound at: 1 rest: nil)				         into: [ :ih :i |					         | child |					         child := children at: i.					         self firstWalk: child.					         bound := self depthBoundOf: (self erOf: child).					         "/Store lowest vertical coordinate while extreme nodes still point in current subtree."					         self						         separate: v						         children: children						         at: i						         rest: ih.					         "Update data about the widths"					         self updateIYL: bound at: i rest: ih ].			self				positionRoot: v				leftMostChild: leftMostChild				rightMostChild: rightMostChild.			self				setExtremesOfNonLeaf: v				leftMostChild: leftMostChild				rightMostChild: rightMostChild ]! !!RSTWalkBasedRegularTreeLayout methodsFor: 'initialization' prior: 59375250!initialize: elements associationEdges: associations	| hierarchy roots fathers rootNode leaves |	hierarchy := IdentityDictionary new.	roots := IdentitySet withAll: elements.	leaves := IdentitySet withAll: elements.	fathers := IdentityDictionary new.	associations do: [ :anAssociation |		| children child father multipleParents fathersOfChild |		father := anAssociation key.		child := anAssociation value.		multipleParents := false.		roots remove: child ifAbsent: [ multipleParents := true ].		leaves			remove: father			ifAbsent: [ "is it okay to try to remove father more than one time"			 ].		fathersOfChild := fathers			                  at: child			                  ifAbsentPut: [ OrderedCollection new ].		fathersOfChild add: father.		children := hierarchy			            at: father			            ifAbsentPut: [			            self childrenOf: father put: OrderedCollection new ].		multipleParents ifFalse: [ children add: child ] ].	rootNode := roots size > 1		        ifTrue: [			        roots collect: [ :each |				        self assert: (fathers includesKey: each) not				        "fathers at: each put: { rootBox }" ].			        RSComposite new				        in: [ :aRootShape |					        self childrenOf: aRootShape put: roots asArray ];				        yourself ]		        ifFalse: [ roots anyOne ].	leaves do: [ :each |		self			assert: (self childrenOf: each) isNil;			childrenOf: each put: Array empty;			initializeForShape: each fathers: fathers ].	^ self initializeForShape: rootNode fathers: fathers! !!RSTWalkBasedRegularTreeLayout methodsFor: 'initialization' prior: 59382302!initializeForShape: aShape fathers: fathers	| depth |	self		modOf: aShape put: 0;		changeOf: aShape put: 0;		shiftOf: aShape put: 0;		prelimOf: aShape put: 0;		mselOf: aShape put: 0;		mserOf: aShape put: 0;		threadOf: aShape put: nil;		rthreadOf: aShape put: nil;		elOf: aShape put: nil;		erOf: aShape put: nil.	depth := fathers		         at: aShape		         ifPresent: [ :parents |			         | level |			         parents				         reject: [ :each | self hasBeenInitializedOf: each ]				         thenDo: [ :each |				         self initializeForShape: each fathers: fathers ].			         level := (parents collect: [ :each | self levelOf: each ])				                  max.			         self levelOf: aShape put: level + 1.			         (parents collect: [ :aShapeParent |				          (self depthBoundOf: aShapeParent)				          + (self depthGapAmong: aShapeParent and: aShape) ]) max ]		         ifAbsent: [ self levelOf: aShape put: 0 ].	self		depthOf: aShape put: depth;		completedInitializationOf: aShape.	^ aShape! !!RSTWalkBasedRegularTreeLayout methodsFor: 'algorithm' prior: 59373253!moveSubtree: children at: i other: si distance: dist	| child intermediateChildren siChild ratio |	child := children at: i.	self		modOf: child update: [ :mod | mod + dist ];		mselOf: child update: [ :msel | msel + dist ];		mserOf: child update: [ :mser | mser + dist ].	self assert: i > si.	(intermediateChildren := i - si) > 1 ifFalse: [ ^ self ].	ratio := dist / intermediateChildren.	siChild := children at: si + 1.	self		shiftOf: siChild update: [ :shift | shift + ratio ];		shiftOf: child update: [ :shift | shift - ratio ];		changeOf: child update: [ :change | change - dist + ratio ]! !!RSTWalkBasedRegularTreeLayout methodsFor: 'algorithm' prior: 59367556!secondWalk: aShape depth: n breadth: m	| mNext children depth breadth position |	mNext := m + (self modOf: aShape).	depth := n + (self depthOf: aShape).	breadth := (self prelimOf: aShape) + mNext.	position := self		            positionOfShape: aShape		            atDepth: depth		            atBreadth: breadth.	self positionOf: aShape put: position.	children := self childrenOf: aShape.	self addChildSpacing: children.	"Recur over my onw children."	children do: [ :aChild |		self secondWalk: aChild depth: n breadth: mNext ]! !!RSTWalkBasedRegularTreeLayout methodsFor: 'algorithm' prior: 59378842!separate: v children: children at: i rest: aValueLink	| sr cl mssr mscl ih |	"Right contour node of left siblings and its sum of modfiers."	sr := children at: i - 1.	mssr := self modOf: sr.	"Left contour node of current subtree and its sum of modfiers."	cl := children at: i.	mscl := self modOf: cl.	"Looping"	ih := aValueLink.	[ sr isNotNil and: [ cl isNotNil ] ] whileTrue: [		| dist sy cy |		(self depthBoundOf: sr) > (self lowYofIYL: ih) ifTrue: [			ih := ih nextLink ].		"How far to the left of the right side of sr is the left side of cl?"		dist := mssr + (self prelimOf: sr) + (self breadthMeasureOf: sr)		        + (self breadthGapAmong: sr and: cl) - mscl		        - (self prelimOf: cl).		dist > 0 ifTrue: [			mscl := mscl + dist.			self				moveSubtree: children				at: i				other: (self indexOfIYL: ih)				distance: dist ].		"Advance highest node(s) and sum(s) of modifiers (Coordinate system increases downwards)"		sy := self depthBoundOf: sr.		cy := self depthBoundOf: cl.		sy <= cy ifTrue: [			sr := self nextRightContour: sr.			sr ifNotNil: [ mssr := mssr + (self modOf: sr) ] ].		sy >= cy ifTrue: [			cl := self nextLeftContour: cl.			cl ifNotNil: [ mscl := mscl + (self modOf: cl) ] ] ].	"Set threads and update extreme nodes."	(sr isNil and: [ cl isNotNil ])		ifTrue: [ "the current subtree must be taller than the left siblings."			self				setLeftThread: v				leftMostChild: children first				currentChild: (children at: i)				child: cl				acc: mscl ]		ifFalse: [ "the left siblings must be taller than the current subtree."			(sr isNotNil and: [ cl isNil ]) ifTrue: [				self					setRightThread: v					previousChild: (children at: i - 1)					currentChild: (children at: i)					child: sr					acc: mssr ] ]! !!RSTWalkBasedRegularTreeLayout methodsFor: 'algorithm' prior: 59370392!updateIYL: minY at: i rest: aValueLink	| ih |	"Remove siblings that are hidden by the new subtree."	ih := aValueLink.	[ ih isNotNil and: [ minY >= (self lowYofIYL: ih) ] ] whileTrue: [		ih := ih nextLink ].	"Prepend the new subtree"	^ ValueLink new		  value: i -> minY;		  nextLink: ih;		  yourself! !!RSAlignment class methodsFor: 'examples'!exampleAlignBottom	| canvas boxes |	canvas := RSCanvas new.	boxes := (1 to: 5) collect: [ :v | 		RSBox new 			color: Color gray translucent;			size: v * 5 ] as: RSGroup.	RSHorizontalLineLayout new alignBottom; on: boxes.	"align := self new.	align shapes: boxes.	align bottom."	canvas addAll: boxes.	^ canvas open! !!RSAlignment class methodsFor: 'examples'!exampleAlignCenter	| canvas boxes |	canvas := RSCanvas new.	boxes := (1 to: 5) collect: [ :v | RSBox new size: v * 5 ] as: RSGroup.	RSVerticalLineLayout new alignCenter; on: boxes.		"align := self new.	align shapes: boxes.	align center."	canvas addAll: boxes.	^ canvas open! !!RSAlignment class methodsFor: 'examples'!exampleAlignLabel	| canvas labels |	canvas := RSCanvas new.	labels := (1 to: 5) collect: [ :v | 		RSLabel new			text: v;			fontSize: v * 5 ] as: RSGroup.	RSHorizontalLineLayout new alignLabel; on: labels.		"align := self new.	align shapes: labels.	align label."	canvas addAll: labels.	"note that each label, have different encompassing rectangle"	canvas showEncompassingRectangles.	^ canvas open! !!RSAlignment class methodsFor: 'examples'!exampleAlignMiddle	| canvas boxes |	canvas := RSCanvas new.	boxes := (1 to: 5) collect: [ :v | 		RSBox new 			color: Color gray translucent;			size: v * 5 ] as: RSGroup.	RSHorizontalLineLayout new alignMiddle; on: boxes.	"align := self new.	align shapes: boxes.	align middle."	canvas addAll: boxes.	^ canvas open! !!RSAlignment class methodsFor: 'examples'!exampleAlignRight	| canvas boxes |	canvas := RSCanvas new.	boxes := (1 to: 5) collect: [ :v | RSBox new size: v * 5 ] as: RSGroup.	RSVerticalLineLayout new alignRight; on: boxes.		"align := self new.	align shapes: boxes.	align right."	canvas addAll: boxes.	^ canvas open! !!RSAlignment methodsFor: 'alignment' prior: 58281240!alignFromLabelUsing: aRSLabel	| topY yb |	topY := aRSLabel encompassingRectangle top.	yb := aRSLabel textExtents y_bearing.	shapes do: [ :s |		s translateTo: s position x @ (topY + (s extent y / 2.0) + s textExtents y_bearing-yb).	]! !!RSAlignment methodsFor: 'alignment' prior: 58283240!alignFromMiddleUsing: aShape	| midY |	midY := aShape position y.	shapes do: [ :s |		s translateTo: s position x @ midY	]! !!RSAlignment methodsFor: 'public' prior: 58279623!bottom	"Align all the shapes on the bottoms of the shapes"	self hasShape ifFalse: [ ^ self ].	self alignFromBottomUsing: self bottomMostShape! !!RSAlignment methodsFor: 'accessing - computed' prior: 58280079!bottomMostShape	fixedShape ifNotNil: [ ^ fixedShape ].	^ shapes inject: shapes first into: [ :maxS :s |			maxS encompassingRectangle bottom <= s encompassingRectangle bottom					ifTrue: [ s ] ifFalse: [ maxS ] ]! !!RSAlignment methodsFor: 'public' prior: 58281529!center	"Center all the shapes along their X coordinate"	self hasShape ifFalse: [ ^ self ].	self alignFromCenterUsing: self centerMostShape! !!RSAlignment methodsFor: 'accessing - computed' prior: 58283431!centerMostShape	fixedShape ifNotNil: [ ^ fixedShape ].	^ shapes inject: shapes first into: [ :maxS :s |			maxS encompassingRectangle floatCenter <= s encompassingRectangle floatCenter					ifTrue: [ s ] ifFalse: [ maxS ] ]! !!RSAlignment methodsFor: 'public' prior: 58283707!left	self hasShape ifFalse: [ ^ self ].	self alignFromLeftUsing: self leftMostShape! !!RSAlignment methodsFor: 'accessing - computed' prior: 58280905!leftMostShape	"Return the shape that is the located the most on the left hand side"	fixedShape ifNotNil: [ ^ fixedShape ].	^ shapes inject: shapes first into: [ :maxS :s |			maxS encompassingRectangle left >= s encompassingRectangle left					ifTrue: [ s ] ifFalse: [ maxS ] ]! !!RSAlignment methodsFor: 'public' prior: 58284193!middle	"Center all the shapes along their Y coordinate"	self hasShape ifFalse: [ ^ self ].	self alignFromMiddleUsing: self centerMostShape! !!RSAlignment methodsFor: 'public'!none	"just empty alignment, because sometimes, shapes are in the position"! !!RSAlignment methodsFor: 'public' prior: 58280494!right	self hasShape ifFalse: [ ^ self ].	self alignFromRightUsing: self rightMostShape! !!RSAlignment methodsFor: 'accessing - computed' prior: 58283857!rightMostShape	"Return the shape that is the located the most on the right hand side"	fixedShape ifNotNil: [ ^ fixedShape ].	^ shapes inject: shapes first into: [ :maxS :s |			maxS encompassingRectangle right <= s encompassingRectangle right					ifTrue: [ s ] ifFalse: [ maxS ] ]! !!RSAlignment methodsFor: 'public' prior: 58281953!top	self hasShape ifFalse: [ ^ self ].	self alignFromTopUsing: self topMostShape! !!RSAlignment methodsFor: 'accessing - computed' prior: 58279365!topMostShape	fixedShape ifNotNil: [ ^ fixedShape ].	^ shapes inject: shapes first into: [ :maxS :s |			maxS encompassingRectangle top >= s encompassingRectangle top					ifTrue: [ s ] ifFalse: [ maxS ] ]! !!RSResize class methodsFor: 'examples'!example	| values canvas colorPallete boxes |	values := #(35 26 5 18 17 60 36 13 16 28 29 3 8 0 3 2 14 12 13 17 1 9 3 3 4 1 1 1 2 1 1 61).	canvas := RSCanvas  new.	colorPallete := NSScale category20c.	boxes := RSBox models: values.	boxes size: #yourself.	boxes color: colorPallete.	canvas addAll: boxes.	"before this all of them have different sizes"	self new shapes: boxes; sameSize.		RSHorizontalLineLayout new gapSize: 0; on: boxes.	canvas @ RSCanvasController.	^ canvas open! !!RSResize methodsFor: 'accessing - computed' prior: 59134044!biggestExtent	fixedShape ifNotNil: [ ^ fixedShape extent ].	^ shapes inject: 0 @ 0 into: [ :maxExtent :e |			maxExtent max: e extent ]! !!RSResize methodsFor: 'accessing - computed' prior: 59133830!biggestShape	^ shapes inject: shapes anyOne into: [ :biggestShape :e |			biggestShape extent < e extent				ifTrue: [ e ] ifFalse: [ biggestShape ] ]! !!RSResize methodsFor: 'accessing - computed' prior: 59133231!highestShape	^ shapes inject: shapes anyOne into: [ :highestShape :e |			highestShape extent y < e extent y				ifTrue: [ e ] ifFalse: [ highestShape ] ]! !!RSResize methodsFor: 'public - configuration' prior: 59132729!useHighestShape	self fixedShape: self highestShape! !!RSResize methodsFor: 'accessing - computed' prior: 59133610!widestShape	^ shapes inject: shapes anyOne into: [ :widestElement :e |			widestElement extent x < e extent x				ifTrue: [ e ] ifFalse: [ widestElement ] ]! !!Rectangle methodsFor: '*Roassal3-Layouts' prior: 60067443!areasOverlapingOutside: aRectangle	"Answer an Array of maximized Rectangles comprising (overlaped by each other) the parts of the receiver not	intersecting aRectangle."	"Make sure the intersection is non-empty"	| areas o c |	(self intersects: aRectangle) ifFalse: [ ^ Array with: self ].	areas := OrderedCollection new.	o := self topLeft.	c := self bottomRight.	aRectangle topLeft y > o y		ifTrue:			[ areas addLast: (o corner: c x @ aRectangle topLeft y) ].	aRectangle bottomRight y < c y		ifTrue:			[ areas addLast: (o x @ aRectangle bottomRight y corner: c) ].	aRectangle topLeft x > o x		ifTrue:			[ areas addLast: (o corner: aRectangle topLeft x @ c y) ].	aRectangle bottomRight x < c x		ifTrue:			[ areas addLast: (aRectangle bottomRight x @ o y corner: c) ].	^ areas! !!RSAbstractBoxedLayout class methodsFor: 'testing'!isAbstract	^ self name = #RSAbstractBoxedLayout! !!RSAbstractBoxedLayout methodsFor: 'configuration'!defaultGapSize	^ 5! !!RSAbstractBoxedLayout methodsFor: 'accessing'!gapSize	^ gapSize! !!RSAbstractBoxedLayout methodsFor: 'accessing'!gapSize: aSizeInPixels	gapSize := aSizeInPixels.	self horizontalGap: gapSize.	self verticalGap: gapSize.! !!RSAbstractBoxedLayout methodsFor: 'accessing'!horizontalGap	^ horizontalGap! !!RSAbstractBoxedLayout methodsFor: 'accessing'!horizontalGap: aNumber	horizontalGap := aNumber! !!RSAbstractBoxedLayout methodsFor: 'initialization'!initialize	super initialize.	self gapSize: self defaultGapSize! !!RSAbstractBoxedLayout methodsFor: 'accessing'!verticalGap	^ verticalGap! !!RSAbstractBoxedLayout methodsFor: 'accessing'!verticalGap: aNumber	verticalGap := aNumber! !!RSAbstractFlowLayout class methodsFor: 'instance creation' prior: 58191498!withMaxWidth: anInteger	^ self new		maxWidth: anInteger;		yourself! !!RSAbstractFlowLayout class methodsFor: 'instance creation' prior: 58191187!withMaxWidth: anInteger withGap: anotherInteger	^ self new		maxWidth: anInteger;		gapSize: anotherInteger;		yourself! !!RSAbstractFlowLayout methodsFor: 'accessing'!alignment	^ alignment! !!RSAbstractFlowLayout methodsFor: 'accessing'!alignment: anObject	alignment := anObject! !!RSAbstractFlowLayout methodsFor: 'configuration' prior: 58190322!defaultMaxWidth	^ [ :shapes |		(shapes size < 4) 			ifTrue: [ 				(((shapes collect: [ :each | each width * each height]) * 2) sum ) + (shapes size * (gapSize squared)) ]			ifFalse: [			((((shapes collect: [ :each | each width * each height]) * 2) sum) + (shapes size * (gapSize squared))) sqrt ceiling truncated.			]		]! !!RSAbstractFlowLayout methodsFor: 'hook' prior: 58190901!doExecute: shapes	| lines align mocks |	shapes ifEmpty: [ ^ self ].	mocks := RSMockShape shapes: shapes.	lines := self linesFor: mocks.	align := RSAlignment new.	lines do: [ :line |		align shapes: line.		alignment value: align.		 ].	mocks do: [:mock | mock applyToRealElement ]! !!RSAbstractFlowLayout methodsFor: 'initialization' prior: 58189970!initialize	super initialize.	self maxWidth: self defaultMaxWidth! !!RSAbstractFlowLayout methodsFor: 'hook' prior: 58190206!linesFor: elements	^ self subclassResponsibility! !!RSFlowLayout class methodsFor: 'examples'!exampleLabel		| words r wordShapes c |	words := (String loremIpsum: 100) substrings.	r := Random new.	wordShapes := words collect: [ :w | 		RSLabel new			fontSize: (r nextInteger: 30);			text: w ] as: RSGroup.	c := RSCanvas new.	c addAll: wordShapes.	self new alignLabel; on: wordShapes.	c @ RSCanvasController.	^ c open! !!RSFlowLayout methodsFor: 'alignment' prior: 58670373!alignBottom	self alignment: #bottom! !!RSFlowLayout methodsFor: 'alignment' prior: 58668616!alignLabel	"Allow to align labels along their baseline"	self alignment: #label! !!RSFlowLayout methodsFor: 'alignment' prior: 58669135!alignMiddle	self alignment: #middle! !!RSFlowLayout methodsFor: 'alignment' prior: 58670546!alignTop	self alignment: #top! !!RSFlowLayout methodsFor: 'initialization' prior: 58669397!initialize	super initialize.	self alignTop! !!RSFlowLayout methodsFor: 'hook' prior: 58669491!linesFor: shapes	| x y maxLastLineHeight nextElement maxWidthFloat lines currentLine hgap vgap |	hgap := self horizontalGap.	vgap := self verticalGap.	x := y := maxLastLineHeight := 0.	maxWidthFloat := self maxWidth rsValue: shapes.	lines := OrderedCollection new.	currentLine := OrderedCollection new.	shapes doWithIndex: [ :shape :index |		shape translateTo: (x @ y) + (shape extent / 2.0).		currentLine add: shape.		x := x + shape width + hgap.		maxLastLineHeight := maxLastLineHeight max: shape height.		nextElement := shapes at: (index + 1 min: shapes size).		(x + nextElement width) > maxWidthFloat ifTrue: [			lines add: currentLine.			x := 0.			y := y + maxLastLineHeight + vgap.			currentLine := OrderedCollection new.			maxLastLineHeight := 0.		].	].	currentLine ifNotEmpty: [ lines add: currentLine ].	^ lines! !!RSHorizontalFlowLayout class methodsFor: 'examples'!exampleLabel		| string characterShapes c |	string := 'KISSItemSameStar'.	characterShapes := RSLabel models: string.	c := RSCanvas new.	c addAll: characterShapes.		self new maxWidth: characterShapes first height * 4; alignCenter; gapSize: 0; on: characterShapes.		c @ RSCanvasController.	c showEncompassingRectangles.	^ c open! !!RSHorizontalFlowLayout methodsFor: 'alignment' prior: 58771443!alignCenter	self alignment: #center! !!RSHorizontalFlowLayout methodsFor: 'alignment' prior: 58770140!alignLeft	self alignment: #left! !!RSHorizontalFlowLayout methodsFor: 'alignment' prior: 58771348!alignRight	self alignment: #right! !!RSHorizontalFlowLayout methodsFor: 'initialization' prior: 58770030!initialize	super initialize.	self alignLeft! !!RSHorizontalFlowLayout methodsFor: 'hook' prior: 58770228!linesFor: shapes	| hgap vgap y x maxLastLineWidth lines currentLine maxHeight nextElement |	hgap := self horizontalGap.	vgap := self verticalGap.	x := y := maxLastLineWidth := 0.		maxHeight := self maxWidth rsValue: shapes.	lines := OrderedCollection new.	currentLine := OrderedCollection new.	shapes doWithIndex: [ :shape :index |		"maybe we need to use a mock element in all layouts"		shape translateTo: (x @ y) + (shape extent / 2.0).		currentLine add: shape.		y := y + shape height + vgap.		maxLastLineWidth := maxLastLineWidth max: shape width.		nextElement := shapes at: (index + 1 min: shapes size).		(y + nextElement height) > maxHeight ifTrue: [			lines add: currentLine.			y := 0.			x := x + maxLastLineWidth + hgap.			currentLine := OrderedCollection new.			maxLastLineWidth := 0.		].	].	currentLine ifNotEmpty: [ lines add: currentLine ].	^ lines! !!RSAbstractGridLayout class methodsFor: 'public' prior: 58199759!on: aCollectionOfElements withGap: anInteger withLineItemsCount: aBlock	"place the elements in a grid with (aBlock roValue: aCollectionOfElements) as the amount of elements horizontally"	| myLayout |	myLayout := self new gapSize: anInteger;  lineItemsCount: aBlock; yourself.	myLayout applyOn: aCollectionOfElements.	^ aCollectionOfElements! !!RSAbstractGridLayout class methodsFor: 'public' prior: 58200435!on: aCollectionOfElements withLineItemsCount: aBlock	"place the elements in a grid with (aBlock roValue: aCollectionOfElements) as the amount of elements horizontally	For example:	self on: (ROElement forCollection: (1 to: 20)) withLineItemsCount: 5	=> place the 20 elements on a grid 5 x 4	self on: (ROElement forCollection: (1 to: 20)) withLineItemsCount: [ :elements | elements size // 3 ]	=> place the 20 elements on a grid 3 x 7	"	| myLayout |	myLayout := self new lineItemsCount: aBlock; yourself.	myLayout applyOn: aCollectionOfElements.	^ aCollectionOfElements! !!RSAbstractGridLayout class methodsFor: 'instance creation' prior: 58199625!withGap: anInteger	^ self new			gapSize: anInteger;			yourself! !!RSAbstractGridLayout class methodsFor: 'instance creation' prior: 58199432!withGap: anInteger withLineItemsCount: aBlock	^self new		gapSize: anInteger;		lineItemsCount: aBlock;		yourself! !!RSAbstractGridLayout class methodsFor: 'instance creation' prior: 58200294!withLineItemsCount: aBlock	^self new		lineItemsCount: aBlock;		yourself! !!RSAbstractGridLayout methodsFor: 'accessing' prior: 58198858!defaultLineItemsCount	^ [ :elements |			| height width |			(elements size < 3				ifTrue: [ (elements size max: 1) @ 1 ]				ifFalse:					[ height := (elements size * 0.618034) sqrt ceiling truncated.					width := (elements size / height) ceiling truncated.					width @ height ]) x ]! !!RSAbstractGridLayout methodsFor: 'initialization' prior: 58198602!initialize	super initialize.	self lineItemsCount: self defaultLineItemsCount! !!RSAbstractGridLayout methodsFor: 'accessing'!lineItemsCount	^ lineItemsCountBlock! !!RSCellLayout methodsFor: 'accessing'!alignment	^ alignment! !!RSCellLayout methodsFor: 'accessing'!alignment: anObject	alignment := anObject! !!RSCellLayout methodsFor: 'hook' prior: 58463234!doExecute: shapes	| pointer lineItemCount lineItemSize maxLastLineHeight originalGapLeft 	 originalGapTop vgap hgap line align |	originalGapLeft := 0.	originalGapTop := 0.	pointer := originalGapLeft @ originalGapTop.	lineItemSize := self lineItemsCountBlock rsValue: shapes.	lineItemCount := 0.	maxLastLineHeight := 0.	vgap := self verticalGap.	hgap := self horizontalGap.		line := OrderedCollection new.	align := RSAlignment new.	shapes do: [ :shape |		line add: shape.		translator translateTopLeftOf: shape to: pointer.		pointer := pointer x + shape width + hgap @ pointer y.		lineItemCount := lineItemCount + 1.		maxLastLineHeight := maxLastLineHeight max: shape height.		lineItemCount >= lineItemSize ifTrue: [			align shapes: line.			alignment value: align.			line := OrderedCollection new.			pointer := originalGapLeft @ (pointer y + vgap + maxLastLineHeight).			maxLastLineHeight := 0.			lineItemCount := 0 ] ].	line size < lineItemSize ifFalse: [ ^ self ].	align shapes: line.	alignment value: align! !!RSCellLayout methodsFor: 'initialization' prior: 58463137!initialize	super initialize.	self alignment: #none! !!RSGridLayout methodsFor: 'alignment'!alignBottom	self verticalAlignment: #bottom! !!RSGridLayout methodsFor: 'alignment'!alignCenter	self horizontalAlignment: #center! !!RSGridLayout methodsFor: 'alignment'!alignLeft	self horizontalAlignment: #left! !!RSGridLayout methodsFor: 'alignment'!alignMiddle	self verticalAlignment: #middle! !!RSGridLayout methodsFor: 'alignment'!alignRight	self horizontalAlignment: #right! !!RSGridLayout methodsFor: 'alignment'!alignTop	self verticalAlignment: #top! !!RSGridLayout methodsFor: 'hook' prior: 58705664!doExecute: shapes	| lineItemSize pointer columnCount rowCount maxHeight columnsWidths rowHeights location hgap vgap |	lineItemSize := self lineItemsCountBlock rsValue: shapes.	"We compute the size of the grid"	columnCount := 1.	rowCount := 1.	maxHeight := 0.	columnsWidths := OrderedCollection new.	rowHeights := OrderedCollection new.	hgap := self horizontalGap.	vgap := self verticalGap.		shapes do: [ :shape |		columnsWidths size < columnCount			ifTrue: [ columnsWidths add: 0 ].		columnsWidths at: columnCount			put: ((columnsWidths at: columnCount) max: shape extent x).		maxHeight := maxHeight max: shape extent y.		columnCount := columnCount + 1.		columnCount > lineItemSize ifTrue: [			columnCount := 1.			rowHeights add: maxHeight.			maxHeight := 0 ]	].	rowHeights add: maxHeight.	"We do the translation"	columnCount := 1.	rowCount := 1.	pointer := ((columnsWidths first / 2) @ (rowHeights first / 2)).	location := RSLocation new inner.	verticalAlignment value: location.	horizontalAlignment value: location.		shapes do: [ :shape | | width height |		width := columnsWidths at: columnCount.		height := rowHeights at: rowCount.		location move: shape on: (Rectangle floatCenter: pointer extent: width @ height).		pointer := (width/2 + hgap) @ 0 + pointer.				columnCount := columnCount + 1.		columnCount > lineItemSize ifTrue: [			columnCount := 1.			pointer := columnsWidths first / 2 @ (height / 2 + vgap + pointer y).			rowCount := rowCount + 1.			rowCount <= rowHeights size				ifTrue: [ pointer := pointer + (0 @ ((rowHeights at: rowCount) / 2)) ]		] ifFalse: [			columnCount := columnCount min: columnsWidths size.			pointer := pointer + (((columnsWidths at: columnCount ) / 2) @ 0) ].	]! !!RSGridLayout methodsFor: 'accessing'!horizontalAlignment	^ horizontalAlignment! !!RSGridLayout methodsFor: 'accessing'!horizontalAlignment: anObject	horizontalAlignment := anObject! !!RSGridLayout methodsFor: 'initialization'!initialize	super initialize.	self alignMiddle; alignCenter.! !!RSGridLayout methodsFor: 'accessing'!verticalAlignment	^ verticalAlignment! !!RSGridLayout methodsFor: 'accessing'!verticalAlignment: anObject	verticalAlignment := anObject! !!RSVerticalCellLayout methodsFor: 'accessing'!alignment	^ alignment! !!RSVerticalCellLayout methodsFor: 'accessing'!alignment: anObject	alignment := anObject! !!RSVerticalCellLayout methodsFor: 'hook'!doExecute: shapes	| pointer lineItemCount lineItemSize maxLastLineWidth originalGapLeft originalGapTop vgap hgap align line mocks|		mocks := RSMockShape shapes: shapes.	originalGapLeft := 0.	originalGapTop := 0.	pointer := originalGapLeft @ originalGapTop.	lineItemSize := self lineItemsCountBlock rsValue: mocks.	lineItemCount := 0.	maxLastLineWidth := 0.	vgap := self verticalGap.	hgap := self horizontalGap.	align := RSAlignment new.	line := OrderedCollection new.	mocks do: [ :shape |		translator translateTopLeftOf: shape to: pointer.		line add: shape.		pointer := pointer x @ (pointer y + shape height + vgap).		lineItemCount := lineItemCount + 1.		maxLastLineWidth := maxLastLineWidth max: shape width.		lineItemCount >= lineItemSize ifTrue: [			align shapes: line.			alignment value: align.			line do: [:mock | mock applyToRealElement ].			line removeAll.			pointer := (pointer x + hgap + maxLastLineWidth) @ originalGapLeft.			maxLastLineWidth := 0.			lineItemCount := 0 ]	].	line ifEmpty: [ ^ self ].	align shapes: line.	alignment value: align.	line do: [:mock | mock applyToRealElement ].! !!RSVerticalCellLayout methodsFor: 'initialization'!initialize	super initialize.	self alignment: #none! !!RSAbstractLineLayout class methodsFor: 'instance creation' prior: 58220165!withGap: anInteger	^ self new		gapSize: anInteger;		yourself! !!RSAbstractLineLayout methodsFor: 'alignment'!alignNone	self alignment: #none! !!RSAbstractLineLayout methodsFor: 'hook' prior: 58218922!deltaFor: anRSShape	^ self subclassResponsibility! !!RSAbstractLineLayout methodsFor: 'hook' prior: 58219516!doExecute: shapes	| pointer delta |	pointer := self positionOriginalPointer: shapes.	shapes do: [ :shape |		delta := self deltaFor: shape.		translator translateTopLeftOf: shape to: pointer - delta.		pointer := self			movePointer: pointer			accordingToFigure: shape ]! !!RSAbstractLineLayout methodsFor: 'initialization' prior: 58218579!initialize	super initialize.	self alignNone! !!RSAbstractLineLayout methodsFor: 'hook' prior: 58218701!movePointer: pointer accordingToFigure: anRSShape	^ self subclassResponsibility! !!RSAbstractLineLayout methodsFor: 'hook' prior: 58219031!positionOriginalPointer: aCollectionOfShapes	^ self subclassResponsibility! !!RSAngleLineLayout methodsFor: 'accessing' prior: 58289718!angle: anAngleInDegrees	angle := anAngleInDegrees! !!RSAngleLineLayout methodsFor: 'accessing'!angleByDegrees: aFloat	self angle: aFloat degreesToRadians	! !!RSAngleLineLayout methodsFor: 'hook' prior: 58289519!defaultAngle	^ 0! !!RSAngleLineLayout methodsFor: 'defaults'!defaultPosition	^ 0 @ 0	! !!RSAngleLineLayout methodsFor: 'hook'!deltaFor: anRSShape	^ 0@0! !!RSAngleLineLayout methodsFor: 'initialization' prior: 58289602!initialize	super initialize.	self 		angle: self defaultAngle;		originalPointer: self defaultPosition	! !!RSAngleLineLayout methodsFor: 'hook'!movePointer: pointer accordingToFigure: anRSShape	| x y vector normal unit gap |	x := angle cos.	y := angle sin.	vector := x @ y * anRSShape extent.	normal := vector normal.	unit := vector / (vector r max: 1).	gap := unit * self gapSize.	^ pointer + vector + gap.! !!RSAngleLineLayout methodsFor: 'accessing'!originalPointer	^ originalPointer! !!RSAngleLineLayout methodsFor: 'accessing'!originalPointer: anObject	originalPointer := anObject! !!RSAngleLineLayout methodsFor: 'hook'!positionOriginalPointer: shapes 	^ originalPointer! !!RSHorizontalLineLayout class methodsFor: 'examples'!example1	| c |	c := self canvasExample.	self new		alignMiddle;		gapSize: 30;		on: c nodes.	^ c open! !!RSHorizontalLineLayout class methodsFor: 'examples'!exampleLabel	| c |	c := RSCanvas new.	c addAll: (#(This is very important) collect: [ :string | | label |		label := RSLabel new			text: string;			color: Color black;			yourself.		string == #This			ifTrue: [ label bold; color: Color blue; fontSize: 20 ].		string == #important			ifTrue: [ label bold; color: Color red; fontSize: 30 ].		label		] ).	c @ RSCanvasController.	self new		alignLabel;		gapSize: 3;		on: c nodes.	^ c open! !!RSHorizontalLineLayout methodsFor: 'alignment' prior: 58773486!alignBottom	self alignment: #bottom! !!RSHorizontalLineLayout methodsFor: 'alignment' prior: 58772204!alignLabel	"Align shapes along the label baseline. It is here assumed that shapes are labels"	self alignment: #label! !!RSHorizontalLineLayout methodsFor: 'alignment' prior: 58772383!alignMiddle	"Make the element middle"	self alignment: #middle! !!RSHorizontalLineLayout methodsFor: 'alignment' prior: 58773583!alignTop	self alignment: #top! !!RSHorizontalLineLayout methodsFor: 'hook' prior: 58772785!deltaFor: anRSShape	| delta |	delta := 0.	alignment == #bottom ifTrue: [ delta := anRSShape height ].	alignment == #middle ifTrue: [ delta := anRSShape height / 2.0 ].	alignment == #label		ifTrue: [ delta := anRSShape textExtents y_bearing negated ].	^ 0 @ delta! !!RSHorizontalLineLayout methodsFor: 'hook' prior: 58772615!movePointer: pointer accordingToFigure: anRSShape	^ (pointer x + anRSShape width + self horizontalGap) @ pointer y! !!RSHorizontalLineLayout methodsFor: 'hook' prior: 58773115!positionOriginalPointer: aCollectionOfShapes	| maxHeight delta |	delta := 0.	alignment == #bottom ifTrue: [		maxHeight := aCollectionOfShapes maxValue: #height.		delta := maxHeight ].	alignment == #middle ifTrue: [		maxHeight := aCollectionOfShapes maxValue: #height.		delta := maxHeight / 2.0 ].	^ (0) @ ((0) + delta)! !!RSVerticalLineLayout class methodsFor: 'examples'!example1	| c |	c := self canvasExample.	self on: c nodes.	c zoomToFit.	^ c open! !!RSVerticalLineLayout class methodsFor: 'examples'!example2	| c |	c := self canvasExample.	self new		alignRight;		on: c nodes.	c zoomToFit.	^ c open! !!RSVerticalLineLayout methodsFor: 'alignment' prior: 59518771!alignCenter	"Make the element centered"	self alignment: #center! !!RSVerticalLineLayout methodsFor: 'alignment' prior: 59517806!alignLeft	self alignment: #left! !!RSVerticalLineLayout methodsFor: 'alignment' prior: 59518678!alignRight	self alignment: #right! !!RSVerticalLineLayout methodsFor: 'hook' prior: 59518067!deltaFor: anRSShape	| delta |	delta := 0.	alignment == #right ifTrue: [ delta := anRSShape width ].	alignment == #center ifTrue: [ delta := anRSShape width / 2.0 ].	^delta @ 0! !!RSVerticalLineLayout methodsFor: 'hook' prior: 59517892!movePointer: pointer accordingToFigure: anRSShape	^ pointer x @ (pointer y + anRSShape height + self verticalGap)! !!RSVerticalLineLayout methodsFor: 'hook' prior: 59518316!positionOriginalPointer: aCollectionOfShapes	| maxWidth delta |	delta := 0.	alignment == #right ifTrue: [		maxWidth := aCollectionOfShapes maxValue: #width.		delta := maxWidth ].	alignment == #center ifTrue: [		maxWidth := aCollectionOfShapes maxValue: #width.		delta := maxWidth / 2.0 ].	^ ((0) + delta) @ (0)! !!RSAbstractCircleLayout methodsFor: 'accessing'!angleIncrement	^ angleIncrement! !!RSAbstractCircleLayout methodsFor: 'accessing'!angleIncrement: aNumberInRadian	angleIncrement := aNumberInRadian! !!RSAbstractCircleLayout methodsFor: 'accessing'!center	^ self centerPoint! !!RSAbstractCircleLayout methodsFor: 'accessing'!center: aPoint	self centerPoint: aPoint! !!RSAbstractCircleLayout methodsFor: 'accessing'!centerPoint	^ centerPoint! !!RSAbstractCircleLayout methodsFor: 'accessing'!centerPoint: aPoint	centerPoint := aPoint! !!RSAbstractCircleLayout methodsFor: 'hook'!computeCenter: aNumber	"returns the defined center point"	^ centerPoint ifNil: [ aNumber @ aNumber ]! !!RSAbstractCircleLayout methodsFor: 'hook' prior: 58155786!computeIncrementalAngleFor: elements	"Return the value _in radian_ of the incremental angle"	^ angleIncrement = 0		ifTrue: [ 2 * Float pi / elements size ]		ifFalse: [ angleIncrement ]! !!RSAbstractCircleLayout methodsFor: 'hook' prior: 58158398!computeRadiusFor: elements	"Return the radius of the circle. If none has been set (i.e., initialRadius = 0), then it is computed as the scale factor times the number of elements"	^ layoutRadius = 0		ifTrue: [ elements size * self scaleFactor ]		ifFalse: [ layoutRadius ]! !!RSAbstractCircleLayout methodsFor: 'accessing' prior: 58158052!initialIncrementalAngle	"Return the initial incremental angle"	^ self angleIncrement! !!RSAbstractCircleLayout methodsFor: 'accessing' prior: 58155643!initialIncrementalAngle: aNumberInRadian	self angleIncrement: aNumberInRadian! !!RSAbstractCircleLayout methodsFor: 'accessing' prior: 58157913!initialRadius	"Return the radius in pixels of the circle"	^ layoutRadius! !!RSAbstractCircleLayout methodsFor: 'accessing' prior: 58157593!initialRadius: aNumber	"Set the radius of the circle"	layoutRadius := aNumber! !!RSAbstractCircleLayout methodsFor: 'initialization' prior: 58156864!initialize	"Initialize a newly created instance. This method must answer the receiver."	super initialize.	self		scaleBy: 11;		"Represent the initial angle to place the elements"		initialAngle: 0;		"Distance of the circle. If it is 0 when entering doExecute, then it is computed"		initialRadius: 0;		"0 means that it is computed, and not set by the user"		angleIncrement: 0! !!RSAbstractCircleLayout methodsFor: 'accessing' prior: 58156338!radius: aNumber	"	Set the radius in pixels of the layout	"	^ self initialRadius: aNumber! !!RSEquidistantCircleLayout methodsFor: 'hook' prior: 58658657!computeSeparationFor: elements	"Compute the separation between each element, this separation will always be the same"	| sep |	sep := ((Float twoPi * (self computeRadiusFor: elements)) - (self weightSum: elements))/	(elements size).	^ sep! !!RSEquidistantCircleLayout methodsFor: 'hook' prior: 58658960!doExecute: shapes	| angle rad center angleInc separation |	rad := self computeRadiusFor: shapes.	center := self computeCenter: rad.	angle := self initialAngle.	separation := self computeSeparationFor: shapes.	shapes do: [ :each |		| point height |		"First, the angle is increased only by the angle given by the element radius (height/2),		then the point is set, and then it's increased by the rest of the total increment"		"This is to consider both last and next elements weights"		height := each height.		angle := angle + (height/(2*rad)).		point := center + (Point r: rad theta: angle).		angleInc := (height / 2 + separation)/rad.		angle := angle + angleInc.		translator translate: each to: point.	]! !!RSWeightedCircleLayout methodsFor: 'hook' prior: 59523252!doExecute: elements	| angle rad center angleInc weightSum size |	rad := self computeRadiusFor: elements.	center := self computeCenter: rad.	angleInc := self computeIncrementalAngleFor: elements.	angle := self initialAngle.	weightSum := self weightSum: elements.	size := elements size.	elements do: [ :each |		| point fctr |		"The factor weighs the angleIncrement"		"The angle is increased by half of the total increment,		then the point is set, and then it's increased by the other half"		"This is to consider both last and next elements weights"		fctr := size * each height / weightSum.		angle := angle + (angleInc * (fctr/2)).		point := center + (Point r: rad theta: angle).		angle := angle + (angleInc*(fctr/2)).		translator translate: each to: point ]! !!RSCircleLayout class methodsFor: 'examples'!example1	| aLayout objects |	aLayout := self new.	aLayout center: 200@200.	aLayout radius: 100.	objects := RSBox models: (1 to: 10).	aLayout on: objects.	^ RSCanvas new		addAll: objects;		@ RSCanvasController;		open! !!RSCircleLayout class methodsFor: 'examples'!example2	| nodes canvas shapes |	nodes := (1 to: 5).	canvas := RSCanvas new.	shapes := RSCircle models: nodes.	shapes size: 30.	canvas addAll: shapes.	self new radius: 20; on: shapes.	canvas @ RSCanvasController.	^ canvas open! !!RSCircleLayout class methodsFor: 'instance creation' prior: 58495325!scaleBy: aNumber	^self new scaleBy: aNumber! !!RSCircleLayout methodsFor: 'hook' prior: 58494863!doExecute: shapes	| angle rad angleInc center |	rad := self computeRadiusFor: shapes.	angleInc := self computeIncrementalAngleFor: shapes.	angle := self initialAngle.	center := self computeCenter: rad.		shapes do: [ :shape |		| point |		point := center + (Point r: rad theta: angle).		angle := angle + angleInc.		translator translateTopLeftOf: shape to: point.	]! !!RSCircularAroundAVertexLayout methodsFor: 'accessing'!centerIndex	^ centerIndex! !!RSCircularAroundAVertexLayout methodsFor: 'accessing'!centerIndex: aNumber	"if center index is nil the would be computed"	centerIndex := aNumber! !!RSCircularAroundAVertexLayout methodsFor: 'hook' prior: 58496278!doExecute: shapes	| centerShape circleLayout rad |	centerShape := self findCenterIn: shapes.	shapes remove: centerShape.	(circleLayout := RSEquidistantCircleLayout new)		initialAngle: initialAngle;		scaleFactor: scaleFactor;		angleIncrement: angleIncrement;		initialRadius: layoutRadius;		centerPoint: centerPoint;		on: shapes.	rad := circleLayout computeRadiusFor: shapes.	centerShape position: (circleLayout computeCenter: rad)! !!RSCircularAroundAVertexLayout methodsFor: 'utilities' prior: 58495973!findCenterIn: aCollection	| max currentSize center |	centerIndex ifNotNil: [ ^ aCollection at: centerIndex ].	max := 0.	center := nil.	aCollection do: [ :each |		currentSize := each connectedLines size.		currentSize > max ifTrue: [			max := currentSize.			center := each ] ].	^ center! !!RSClusteringLayout methodsFor: 'hook' prior: 58516333!doExecute: shapes	"Performs the layout"	"A collection of collections"	| clusters |	clusters := self getClusterFor: shapes.	clusters do: [ :group | forEachLayout on: group ].	clustersLayout on: clusters! !!RSClusteringLayout methodsFor: 'hook' prior: 58515084!getClusterFor: shapes	| result resultWithGroups |	result := OrderedCollection new.	shapes do: [ :s | | t |		t := s allRecursiveConnectedShapes.		(result includes: t) 			ifFalse: [ result add: t ]	].	resultWithGroups := result		collect: [ :coll |(coll asArray sortedAs: #asString) asGroup ]		as: RSGroup.	^ resultWithGroups! !!RSConditionalLayout methodsFor: 'hook' prior: 58552408!doExecute: shapes	"Performs the layout"	| thenShapes elseShapes |	thenShapes := (shapes select: if) asGroup.	elseShapes := (shapes reject: if) asGroup.	thenLayout on: thenShapes.	elseLayout on: elseShapes.	RSLocation new		left;		outer;		offset: -20 @ 0;		move: thenShapes on: elseShapes! !!RSLayout class methodsFor: 'documentation'!addDocumentSectionHierarchy: aBuilder	aBuilder newLine.	aBuilder header: [ :builder | builder text: 'Hierarchy' ] withLevel: 2.	SpDocumentHierarchyBuilder new		fromClass: RSLayout;		builder: aBuilder;		filter: [ :eachClass | eachClass package packageName beginsWith: 'Roassal3-' ];		buildFor: self! !!RSLayout class methodsFor: 'examples'!basicExample	| canvas |	canvas := self canvasExample.	self on: canvas nodes.	^ canvas open! !!RSLayout class methodsFor: 'documentation'!buildMicroDownUsing: aBuilder withComment: aString	super buildMicroDownUsing: aBuilder withComment: aString.	self addDocumentSectionHierarchy: aBuilder! !!RSLayout class methodsFor: 'examples' prior: 58870789!canvasExample	| canvas |	canvas := RSCanvas new.	self canvasExampleIn: canvas.	canvas @ RSCanvasController.	^ canvas! !!RSLayout class methodsFor: 'examples'!canvasExampleIn: canvas	self canvasExampleIn: canvas models: Collection withAllSubclasses! !!RSLayout class methodsFor: 'examples'!canvasExampleIn: canvas models: aCollection	| shapes colorPalette |	self cartensianLinesIn: canvas.	shapes := RSBox models: aCollection.	canvas addAll: shapes.	colorPalette := NSScale category20c.	shapes do: [ :shape |		shape color: (colorPalette scale: shape model)		].	shapes		@ RSPopup new;		@ RSDraggable new.	RSLineBuilder arrowedLine		shapes: shapes;		withBorderAttachPoint;		connectFrom: #superclass.	RSNormalizer size		shapes: shapes;		normalize: #linesOfCode! !!RSLayout class methodsFor: 'examples'!cartensianLinesIn: canvas	| lineX lineY zeroLabel |	lineX := RSArrowedLine new		color: Color black;		startPoint: 0@0;		endPoint: 300@0;		yourself.	lineY := lineX copy		startPoint: 0@0;		endPoint: 0 @ 300;		yourself.	zeroLabel := RSLabel new		text: '0@0';		addInteraction: (RSPopup themeText: 'Origin in a box of 300@300');		position: 0@0;		color: Color black;		yourself.	canvas		addShape: lineX;		addShape: lineY;		addShape: zeroLabel! !!RSLayout methodsFor: 'hook'!userDefinedLines: aCollectionOfLines	"Do nothing"! !!RSAbstractCompactTreeLayout class methodsFor: 'testing' prior: 58175698!horizontalGap: anInt verticalGap: another	| new |	new := self new.	new horizontalGap: anInt.	new verticalGap: another.	^ new! !!RSAbstractCompactTreeLayout class methodsFor: 'testing' prior: 58175005!isAbstract	^ self name = #RSAbstractCompactTreeLayout! !!RSAbstractCompactTreeLayout methodsFor: 'private' prior: 58158905!childrenFor: aNode	^ sonsDictionary isEmpty		ifTrue: [ super childrenFor: aNode ]		ifFalse: [ sonsDictionary at: aNode ifAbsent: [ ^ OrderedCollection new ] ]! !!RSAbstractCompactTreeLayout methodsFor: 'algorithm' prior: 58160309!computePosition: aNode"compute the position of the given node and of his sons recursively"	self subclassResponsibility! !!RSAbstractCompactTreeLayout methodsFor: 'algorithm' prior: 58164193!followLeftContour: aNode toLayer: anInteger	"return the last node in the left contour begining at anode"	(self layerOf: aNode) = anInteger ifTrue: [ ^ aNode ].	(self layerOf: aNode) > anInteger ifTrue: [ ^ nil ].	(self leftContourOf: aNode)		ifNil: [			(self pointerOf: aNode) ifNil: [ ^ nil ] ifNotNil: [				^ self					  followLeftContour: (self pointerOf: aNode)					  toLayer: anInteger ] ]		ifNotNil: [			^ self				  followLeftContour: (self leftContourOf: aNode)				  toLayer: anInteger ]! !!RSAbstractCompactTreeLayout methodsFor: 'algorithm' prior: 58160749!followRightContour: aNode toLayer: anInteger	"return the node in the right contour begining at anode in layer anInteger"	(self layerOf: aNode) = anInteger ifTrue: [ ^ aNode ].	(self layerOf: aNode) > anInteger ifTrue: [ ^ nil ].	(self rightContourOf: aNode)		ifNil: [			(self pointerOf: aNode) ifNil: [ ^ nil ] ifNotNil: [				^ self					  followRightContour: (self pointerOf: aNode)					  toLayer: anInteger ] ]		ifNotNil: [			^ self				  followRightContour: (self rightContourOf: aNode)				  toLayer: anInteger ]! !!RSAbstractCompactTreeLayout methodsFor: 'algorithm' prior: 58162697!getAbcissaOf: aNode inSubtreeFromLayer: anInteger	| node x |	(anInteger < 0) ifTrue: [^ self getAbcissaOf: aNode inSubtreeFromLayer: 0 ].	((self layerOf: aNode) = anInteger ) ifTrue: [ ^ self xOf: aNode ].	((self layerOf: aNode) < anInteger ) ifTrue: [ ^ nil ].	x := (self xOf: aNode) + (self modOf: aNode).	node := self fatherOf: aNode.	[(self layerOf: node) = anInteger  ] whileFalse: [ x := x + (self modOf: node).									node := self fatherOf: node ].	^ x! !!RSAbstractCompactTreeLayout methodsFor: 'initialize-release' prior: 58160508!initialLayout: aLayout	initialLayout := aLayout! !!RSAbstractCompactTreeLayout methodsFor: 'initialization' prior: 58162403!initialize	super initialize.	verticalGap := 20.	horizontalGap := 30.	sonsDictionary := Dictionary new! !!RSAbstractCompactTreeLayout methodsFor: 'initialize-release' prior: 58159715!initialize: aNode whoseFatherIs: another	self fatherOf: aNode put: another.	another		ifNil: [ self layerOf: aNode put: 0 ]		ifNotNil: [ self layerOf: aNode put: (self layerOf: another) + 1 ].	(self childrenFor: aNode) do: [ :e |		self initialize: e whoseFatherIs: aNode ]! !!RSAbstractCompactTreeLayout methodsFor: 'algorithm' prior: 58159138!leftSiblingOf: aNode	"return the left sibling of the given node "	| children |	(self fatherOf: aNode) ifNil: [ "has no sibling" ^ nil ] ifNotNil: [		children := self childrenFor: (self fatherOf: aNode).		children first = aNode			ifTrue: [ "as no left sibling" ^ nil ]			ifFalse: [ ^ children at: (children indexOf: aNode) - 1 ] ]! !!RSAbstractCompactTreeLayout methodsFor: 'initialize-release' prior: 58164909!root: aNode	root := aNode! !!RSRadialTreeLayout methodsFor: 'algorithm' prior: 59112136!compareContourOf: aNode with: another	"return the number of radians the subtree induced by aNode must be displaced to be separated by a predefined distance (horizontalGap) from the one induced by anotherNode"	| difference max nodeA nodeB |	nodeB := aNode.	"the right one"	nodeA := another.	"the left one"	max := aNode = another		ifTrue: [ 0 ]		ifFalse: [ horizontalGap / (self layerOf: nodeB) / 2 - ((self xOf: nodeB) - (self getAbcissaOf: nodeA inSubtreeFromLayer: (self layerOf: aNode) - 1)) ].	nodeB := self followLeftContour: nodeB toLayer: (self layerOf: nodeB) + 1.	nodeA := self followRightContour: nodeA toLayer: (self layerOf: nodeA) + 1.	[ nodeB isNil not & nodeA isNil not ]		whileTrue: [			difference := horizontalGap / (self layerOf: nodeA)				-					((self getAbcissaOf: nodeB inSubtreeFromLayer: (self layerOf: aNode) - 1)						- (self getAbcissaOf: nodeA inSubtreeFromLayer: (self layerOf: aNode) - 1)).			max := max max: difference.			nodeB := self followLeftContour: nodeB toLayer: (self layerOf: nodeB) + 1.			nodeA := self followRightContour: nodeA toLayer: (self layerOf: nodeA) + 1 ].	^ max! !!RSRadialTreeLayout methodsFor: 'hook' prior: 59108304!computeGap: aNode	" compute the vertical gap needed for drawing the radial tree "	| gap maxAbcissa i abc nodeL nodeR layer |	gap := 0.	maxAbcissa := 0.	layer := 1.	i := 1.	[	nodeL := self followLeftContour: aNode toLayer: i.	nodeR := self followRightContour: aNode toLayer: i.	nodeL isNil not & nodeR isNil not ] whileTrue: [		abc := (self getAbcissaOf: nodeR inSubtreeFromLayer: 0)		       - (self getAbcissaOf: nodeL inSubtreeFromLayer: 0)		       + (horizontalGap / layer / 2) / layer.		maxAbcissa := maxAbcissa max: abc.		i := i + 1 ].	gap := (maxAbcissa / 2 / Float pi) floor + 1.	(verticalGap isNil or: [ gap > verticalGap ]) ifTrue: [		self verticalGap: gap ]! !!RSRadialTreeLayout methodsFor: 'algorithm' prior: 59106087!computePosition: aNode	"compute the position of the given node and of his sons recursively"	| children neighbor nodeA |	children := self childrenFor: aNode.	neighbor := self leftSiblingOf: aNode.	children isEmpty ifTrue: [		 neighbor			ifNil: [ self xOf: aNode put: 0.				self modOf: aNode put: 0 ]			ifNotNil: [ self					xOf: aNode					put: (self xOf: neighbor) + (horizontalGap / (self layerOf: aNode) / 2).				self modOf: aNode put: (self modOf: neighbor).				self					pointerOf: aNode					put: (self followRightContour: neighbor toLayer: (self layerOf: aNode) + 1) ] ]	ifFalse: [		self leftContourOf: aNode put: children first.		self rightContourOf: aNode put: children last.		children do: [ :e | self computePosition: e ].		self			xOf: aNode			put:				((self xOf: (self leftContourOf: aNode))					+ (self xOf: (self rightContourOf: aNode))					+ (self modOf: (self rightContourOf: aNode))) / 2.		self modOf: aNode put: 0.		neighbor			ifNotNil:				[ self modOf: aNode put: (self compareContourOf: aNode with: neighbor).				nodeA := self					followLeftContour: (self fatherOf: aNode)					toLayer: (self layerOf: aNode).				[ (self					followLeftContour: nodeA					toLayer: (self layerOf: nodeA) + 1) isNil ]					whileFalse: [ nodeA := self							followLeftContour: nodeA							toLayer: (self layerOf: nodeA) + 1 ].				self					pointerOf: nodeA					put: (self followLeftContour: aNode toLayer: (self layerOf: nodeA) + 1).				nodeA := self					followRightContour: aNode					toLayer: (self layerOf: aNode) + 1.				nodeA ifNil: [ ^ self ].				[ (self					followRightContour: nodeA					toLayer: (self layerOf: nodeA) + 1) isNil ]					whileFalse: [ nodeA := self							followRightContour: nodeA							toLayer: (self layerOf: nodeA) + 1 ].				self					pointerOf: nodeA					put: (self followRightContour: neighbor toLayer: (self layerOf: nodeA) + 1) ] ]! !!RSRadialTreeLayout methodsFor: 'hook' prior: 59111005!doExecute: nodeElements	| rootNodes xOffset maximumRadius |	initialLayout ifNotNil: [		initialLayout new executeOnElements: nodeElements ].	rootNodes := self rootNodesFor: nodeElements.	rootNodes		do: [ :e | self initialize: e whoseFatherIs: nil ];		do: [ :e |			self computePosition: e.			self step ];		do: [ :e | self computeGap: e ];		do: [ :e | self toRadialTree: e withMod: 0 ].	xOffset := 0.	rootNodes do: [ :e |		maximumRadius := self radialDraw: e.		"Shifting all the subgroups"		self shiftTree: e by: maximumRadius + xOffset @ maximumRadius.		xOffset := xOffset + (2 * maximumRadius) + 10 ]! !!RSRadialTreeLayout methodsFor: 'private' prior: 59109122!layoutLayer: aCollection radius: oldRadius from: aFromAngle to: aToAngle	| delta childRadius maximumRadius myRadius fromAngle toAngle |	"Initialize with default value"	maximumRadius := oldRadius.	aCollection isEmpty ifFalse: [		myRadius := oldRadius + self gap + (self maximumRadius: aCollection).		childRadius := oldRadius + self gap		               + (self maximumDiameter: aCollection). "This is a purely optical tweak"		(aCollection size = 1 and: [ aToAngle - aFromAngle = (2 * Float pi) ])			ifTrue: [				delta := 0.4 * Float pi.				fromAngle := 0.8 * Float pi.				toAngle := fromAngle + delta ]			ifFalse: [				delta := aToAngle - aFromAngle / aCollection size.				fromAngle := aFromAngle.				toAngle := aFromAngle + delta ].		aCollection do: [ :child |			translator				translateTopLeftOf: child				to: (Point r: myRadius theta: toAngle - (delta / 2.0)).			maximumRadius := maximumRadius max: (self					                  layoutLayer: (self childrenFor: child)					                  radius: childRadius					                  from: fromAngle					                  to: toAngle).			fromAngle := toAngle.			toAngle := toAngle + delta ] ].	^ maximumRadius! !!RSRadialTreeLayout methodsFor: 'private' prior: 59108048!moveAllElementsToTopLeft: elements	| pos min |	pos := elements collect: #position.	min := pos inject: 0 @ 0 into: [ :minimum :p | minimum min: p ].	elements do: [ :e | e translateBy: min negated ]! !!RSRadialTreeLayout methodsFor: 'algorithm' prior: 59111691!radialDraw: aNode	"draw the subtree induced by the given node"	| children r max |	r := (self rOf: aNode).	translator translateTopLeftOf: aNode to: (Point r: r theta: (self thetaOf: aNode)).	"aNode translateTo: (Point radius: (aNode r) theta: (aNode theta))."	children := self childrenFor: aNode.	max := 0.	children do: [ :e | max := max max: (self radialDraw: e) ].	^ r + max! !!RSRadialTreeLayout methodsFor: 'hook' prior: 59113322!rotateSubtreeFrom: aNode by: aFloat	aNode theta: aNode theta + aFloat.	(self childrenFor: aNode) do: [ :e |		self rotateSubtreeFrom: e by: aFloat ]! !!RSRadialTreeLayout methodsFor: 'algorithm' prior: 59110444!toRadialTree: aNode withMod: aFloat	"compute polar coordinates of the subtree induced by anode from its cartesian coordinates "	| children |	self rOf: aNode put: (self layerOf: aNode) * verticalGap.	(self rOf: aNode) = 0		ifTrue: [ self thetaOf: aNode put: 0 ]		ifFalse: [			self				thetaOf: aNode				put:				(self xOf: aNode) + aFloat + (self modOf: aNode) / verticalGap ].	children := self childrenFor: aNode.	children do: [ :e |		self toRadialTree: e withMod: (self modOf: aNode) + aFloat ]! !!RSAbstractGraphLayout class methodsFor: 'constants' prior: 58197441!horizontalGap	^3.0! !!RSAbstractGraphLayout class methodsFor: 'public' prior: 58197528!on: elements edges: edges	"Do the layout of the elements tacking into account the provided edges"	^ self new		userDefinedLines: edges;		applyOn: elements! !!RSAbstractGraphLayout class methodsFor: 'constants' prior: 58197872!verticalGap	^20.0! !!RSAbstractGraphLayout methodsFor: 'private'!allChildrenFor: aNode	| scan scanTop |	scan := OrderedCollection withAll: (self childrenFor: aNode).	scanTop := 1.	[scanTop > scan size]		whileFalse: [scan addAll: (self childrenFor:  (scan at: scanTop)).			scanTop := scanTop + 1].	^ scan! !!RSAbstractGraphLayout methodsFor: 'private' prior: 58191678!childrenFor: aNode	^ self cachedChildren		at: aNode		ifAbsentPut: [ | nodes |			nodes := OrderedCollection new.			self edgesDo: [:edge |				(edge from == aNode and: [edge to ~= aNode]) ifTrue: [					(nodes includes: edge from)						ifFalse: [nodes add: edge to ]				]			].			self sortCollection: nodes.			nodes]! !!RSAbstractGraphLayout methodsFor: 'private' prior: 58194997!childrenFor: aNode except: aNodeCollection	^ (self childrenFor: aNode)		reject: [:each | aNodeCollection includes: each]	"we are explicitly not using the default Collection>>difference: behavior here because we want to preserve the order of the collection"! !!RSAbstractGraphLayout methodsFor: 'hook' prior: 58194416!doInitialize: elements	super doInitialize: elements.	self clear.	"self greedyCycleRemoval: elements"! !!RSAbstractGraphLayout methodsFor: 'private' prior: 58197264!maximumDiameter: aCollection	^ aCollection		inject: 0		into: [:max :node | max max: (node radius * 2) ]! !!RSAbstractGraphLayout methodsFor: 'private' prior: 58195672!nestingLevelFor: aNodeFigure	| parents parentsNesting |	parents := self parentsFor: aNodeFigure.	parentsNesting := parents		collect: [:eachParent | self nestingLevelFor: eachParent].	^parentsNesting isEmpty		ifTrue: [0]		ifFalse: [parentsNesting max + 1]! !!RSAbstractGraphLayout methodsFor: 'hook' prior: 58194760!on: el edges: edgs	"Do the layout of the elements tacking into account the provided edges"	self userDefinedLines ifNil: [ self userDefinedLines: edgs ].	^ self applyOn: el! !!RSAbstractGraphLayout methodsFor: 'private' prior: 58193705!rootNodesFor: aCollection	^ aCollection select: [:node |		(self parentsFor: node) isEmpty ]! !!RSAbstractGraphLayout methodsFor: 'hook'!rootNodesFromCycles: shapes	| graph groups  |	graph := RSDSMGraph new: shapes size.	shapes doWithIndex: [ :shape :index1 |		shape outgoingShapes do: [ :otherShape | | index2 |			index2 := shapes indexOf: otherShape.			"added only when index2 is valid"			index2 == 0 ifFalse: [ graph addEdge: index1 to: index2 ].			 ].		 ].	groups := graph computeSCCs.	"this takes all cycles and put them as roots"	"a cycle is detected when group size is more than 1"	^ (groups flatCollect: [ :group | 		group size > 1			ifTrue: [ group collect: [ :i | shapes at: i ] ]			ifFalse: [#()]		] as: Set) asOrderedCollection.! !!RSAbstractGraphLayout methodsFor: 'hook'!sortCollection: nodes	self childrenSortBlock		ifNotNil: [ :block | nodes sort: block ]! !!RSAbstractGraphLayout methodsFor: 'private' prior: 58193124!validateCachedParents	self shouldValidateCycles ifFalse: [ ^ self ].	self cachedParents keysDo: [ :node |		self validateCycleFor: node path: Set new ]! !!RSAbstractGraphLayout methodsFor: 'private' prior: 58196357!validateCycleFor: node path: aSet	(aSet includes: node)		ifTrue: [ self error: 'cycle with: ', aSet asString ].	aSet add: node.	(self parentsFor: node) do: [ :parent| self validateCycleFor: parent path: aSet ]! !!RSAbstractHorizontalTreeLayout methodsFor: 'private - hook' prior: 58201869!layout: aNodeCollection atPoint: aPoint atLayer: aNumber	| treeSize childrenPosition x y middleOfTree |	aNodeCollection isEmpty ifTrue: [ ^ 0 ].	x := aPoint x.	y := aPoint y.	alreadyLayoutedNodes addAll: aNodeCollection.	self atLayer: aNumber add: aNodeCollection.	aNodeCollection do: [ :each |		childrenPosition := x + each width + self horizontalGap.		treeSize := each height			max: (self layout: (self computeChildrenFor: each) atPoint: childrenPosition @ y atLayer: aNumber + 1).		middleOfTree := y + (treeSize / 2.0) - (each height / 2.0).		translator translateTopLeftOf: each to: (x @ middleOfTree).		y := y + treeSize + self verticalGap.		self step ].	^ y - aPoint y - self verticalGap! !!RSAbstractHorizontalTreeLayout methodsFor: 'private' prior: 58201146!rearrangeByLayers: aGraph	| cursor layerDepthSize |	cursor := self leftGap.	nodesByLayer do: [ :eachSetOfNodes |		layerDepthSize := eachSetOfNodes inject: 0 into: [ :max :eachNode |			translator translateTopLeftOf: eachNode to: (cursor @ eachNode encompassingRectangle top).			max max: eachNode width ].		cursor := cursor + layerDepthSize + self horizontalGap ]! !!RSAbstractRegularTreeLayout methodsFor: 'private - hook'!computeChildrenFor: aNode	^ self subclassResponsibility! !!RSAbstractRegularTreeLayout methodsFor: 'hook' prior: 58235980!doExecute: shapes	| rootNodes |	alreadyLayoutedNodes := Set new.	rootNodes := self rootNodesFor: shapes.	self validateCachedParents.	(rootNodes isEmpty and: [ shapes isNotEmpty ])		ifTrue: [ rootNodes := self rootNodesFromCycles: shapes ].	self sortCollection: rootNodes.	nodesByLayer := OrderedCollection new.	self		layout: rootNodes		atPoint: self leftGap @ self topGap		atLayer: 1.	self isLayered ifTrue: [		self rearrangeByLayers: shapes ]! !!RSAbstractRegularTreeLayout methodsFor: 'hook' prior: 58234281!doInitialize: shapes	self clear! !!RSAbstractRegularTreeLayout methodsFor: 'hook' prior: 58237241!doPost: elements	shouldBeHorizontallyReversed ifTrue: [ self horizontallyReverse: elements ].	shouldBeVerticallyReversed ifTrue: [ self verticallyReverse: elements ]! !!RSAbstractRegularTreeLayout methodsFor: 'public' prior: 58233769!horizontallyReverse	shouldBeHorizontallyReversed := true! !!RSAbstractRegularTreeLayout methodsFor: 'reversing' prior: 58234385!horizontallyReverse: shapes	"Horizontally reverse the elements, as well as the attachpoints"	| g largeur |	g := shapes asGroup.	largeur := g extent x.	shapes		do: [ :el | el translateTo: (largeur - el position x) @ el position y ]! !!RSAbstractRegularTreeLayout methodsFor: 'initialization' prior: 58234860!initialize	super initialize.	topGap := 5.	leftGap := 5.	isLayered := false.	shouldBeHorizontallyReversed := false.	shouldBeVerticallyReversed := false! !!RSAbstractRegularTreeLayout methodsFor: 'accessing' prior: 58235331!shouldBeHorizontallyReversed	"Return if the layout is horizontally reversed"	^ shouldBeHorizontallyReversed! !!RSAbstractRegularTreeLayout methodsFor: 'public' prior: 58236634!verticallyReverse	"Reverse the edge extremities"	shouldBeVerticallyReversed := true! !!RSAbstractVerticalTreeLayout methodsFor: 'private - hook' prior: 58266531!layout: aNodeCollection atPoint: aPoint atLayer: aNumber	| treeSize childrenPosition x y middleOfTree |	aNodeCollection isEmpty ifTrue: [ ^ 0 ].	x := aPoint x.	y := aPoint y.	alreadyLayoutedNodes addAll: aNodeCollection.	self atLayer: aNumber add: aNodeCollection.	aNodeCollection do: [ :each |		| children |				childrenPosition := y + each height + self verticalGap.		children := self computeChildrenFor: each.					treeSize := self			layout: children			atPoint: x @ childrenPosition			atLayer: aNumber + 1.		treeSize < each width ifTrue: [			self translate: children by: (each width - treeSize) / 2.0 @ 0.			treeSize := each width. ].		middleOfTree := x + (treeSize / 2.0) - (each width / 2.0).		translator translateTopLeftOf: each to: middleOfTree @ y.		x := x + treeSize + self horizontalGap.		self step ].	^ x - aPoint x - self horizontalGap! !!RSAbstractVerticalTreeLayout methodsFor: 'private' prior: 58265832!rearrangeByLayers: aGraph	| cursor layerDepthSize |	cursor := self topGap.	nodesByLayer do: [:eachSetOfNodes |		layerDepthSize := eachSetOfNodes inject: 0 into: [ :max :eachNode |			translator translateTopLeftOf: eachNode to: (eachNode position x @ cursor).			max max: eachNode height ].		cursor := cursor + layerDepthSize + self verticalGap ]! !!RSAbstractVerticalTreeLayout methodsFor: 'private - hook' prior: 58267473!translate: aNodeCollection by: delta	aNodeCollection ifEmpty: [ ^ self ].	aNodeCollection do: [ :each |		each translateBy: delta.		self translate: (self childrenFor: each) by: delta]! !!RSVanDerPloegTreeLayout methodsFor: 'private - hook' prior: 59500622!layout: rootNodes atPoint: aPoint atLayer: aLayer	^ self layout: root depth: aPoint y breadth: aPoint x! !!RSClusterRadialTreeLayout class methodsFor: 'examples'!exampleWithNumber	| canvas shapes color |	canvas := RSCanvas new.	color := RSColorPalette sequential bupu3.	shapes := (1 to: 100) collect: [ :m |		RSBox new			size: 7;			model: m;			draggable;			withBorder;			color: (color scale: m);			yourself.		 ].	RSLineBuilder line		shapes: shapes;		canvas: canvas;		connectFrom: [ :n | n // 2 ].	canvas edges do: #withBorder.	canvas addAll: shapes.	canvas shapes @ RSHighlightable red.	self on: shapes.	canvas zoomToFit.	^ canvas open! !!RSClusterRadialTreeLayout methodsFor: 'drawing - general'!draw: aNode	self draw: aNode level: 1.! !!RSClusterRadialTreeLayout methodsFor: 'drawing - general'!draw: aNode level: level	| layer allChildren position |	layer := self layerOf: aNode.		position := (Point r: (maxLayer - layer) * verticalGap theta: (maxAbcissa - (self xOf: aNode) / maxAbcissa) * 2 * Float pi).	level > 3 ifTrue: [ 		allChildren := self allChildrenFor: aNode.		allChildren add: aNode.		allChildren do: [ :each | each properties: nil ].		RSClusterTreeLayout new			horizontalGap: horizontalGap * 0.3;			verticalGap: verticalGap * 0.3;			on: allChildren.		allChildren do: [ :each | each translateBy: position ].		^ self		 ].		(self childrenFor: aNode) do: [ :e | self draw: e level: level + 1 ].	translator		translateTopLeftOf: aNode		to: position! !!RSClusterTreeLayout methodsFor: 'hook' prior: 58502380!doExecute: nodeElements	| rootNodes gap |	"Not much to do if there is only one element"	nodeElements size <= 1 ifTrue: [ ^ self ].	rootNodes := self rootNodesFor: nodeElements.	self validateCachedParents.	rootNodes do: [ :e | self initializeNode: e ].	rootNodes do: [ :e | self computePosition: e ].	maxLayer := (rootNodes collect: [ :e | self layerOf: e ]) max.	(rootNodes size > 1) ifTrue: [ maxLayer := maxLayer + 1 ].	maxAbcissa := (self xOf: externalLayer last) + horizontalGap .	gap := maxAbcissa / 2 / Float pi / maxLayer.	verticalGap := verticalGap max: gap.	rootNodes do: [ :e | self draw: e ]! !!RSClusterTreeLayout methodsFor: 'drawing - general' prior: 58499404!draw: aNode	(self childrenFor: aNode) do: [ :e | self draw: e ].	translator		translateTopLeftOf: aNode		to: (Point r: (maxLayer - (self layerOf: aNode)) * verticalGap theta: (maxAbcissa - (self xOf: aNode) / maxAbcissa) * 2 * Float pi )! !!RSClusterTreeLayout methodsFor: 'initialization' prior: 58499712!initialize	super initialize.	verticalGap := 30.	horizontalGap := 20.	externalLayer := OrderedCollection new! !!RSClusterTreeLayout methodsFor: 'initialize-release' prior: 58501276!initializeNode: aNode	|children|	children := self childrenFor: aNode.	children do: [ :e | self initializeNode: e.						self fatherOf: e put: aNode ].	children isEmpty ifTrue: [ self layerOf: aNode put: 0.							externalLayer add: aNode ]					ifFalse: [ self layerOf: aNode put: ((children collect: [ :e | (self layerOf: e) ]) max + 1).							self leftContourOf: aNode put: children first.							self rightContourOf: aNode put: children last ]! !!RSSugiyamaLayout class methodsFor: 'utilities'!sort: assocA to: assocB	| a b offset |	offset := 0.	a := assocA value.	b := assocB value.	[(a size > offset)		and: [(b size > offset) and: [(a at: a size - offset) = (b at: b size - offset)]]]		whileTrue: [offset := offset + 1].	"Corner cases"	(a size = b size and: [b size = offset]) ifTrue: [ ^ true ].	"[3, 3], [3, 3]"	(a size > offset and: [b size = offset]) ifTrue: [ ^ true ].	"[3, 3, 6], [3, 3]"	(b size > offset and: [a size = offset]) ifTrue: [ ^ false ].	"[3, 3], [3, 3, 6]"	"Normal case"	^ (a at: a size - offset) >= (b at: b size - offset)! !!RSSugiyamaLayout class methodsFor: 'utilities' prior: 59258418!sortBlock	^ [ :assocA :assocB | self sort: assocA to: assocB ]! !!RSSugiyamaLayout methodsFor: 'private' prior: 59256934!addDummyNodes	| layer layerNr |	connections := RSIdentityMatrix new.	self edgesDo: [ :edge |		| layerFrom layerTo span fromNode toNode |		"edge hints removeAll."		layerFrom := layerNrs at: edge from.		layerTo := layerNrs at: edge to.		span := layerTo - layerFrom.		"Normal case where nodes are in adjacent layers"		span abs = 1 ifTrue: [ connections at: edge from at: edge to put: true ].		fromNode := edge from.		[ span > 1 or: [ span < -1 ] ] whileTrue: [			span := span > 0				ifTrue: [ span - 1]				ifFalse: [ span + 1].			layerNr := layerTo - span.			layer := layers at: layerNr.			toNode := RSDummyNode on: edge slot: layerFrom - span.			layer add: toNode.			layerNrs at: toNode put: layerNr.			connections at: fromNode at: toNode put: true.			fromNode := toNode ].		(layerFrom - layerTo) abs > 1 ifTrue: [			connections at: fromNode at: edge to put: true ] ]! !!RSSugiyamaLayout methodsFor: 'private' prior: 59252500!assignLabels: aNodeCollection	"Initialize label dictionary"	| label vertices parentLabels |	labels := IdentityDictionary new.	label := 1. "Assign labels to the roots"	(self rootNodesFor: aNodeCollection) do: [ :node |		labels at: node put: label.		label := label + 1 ]. "Assign labels to the rest"	[ labels keys size < aNodeCollection size ] whileTrue: [		vertices := SortedCollection sortBlock: self sortBlock.		aNodeCollection do: [ :node |			(labels includesKey: node) ifFalse: [				parentLabels := ((self parentsWithoutCylesFor: node) collect: [					                 :pn | labels at: pn ifAbsent: [ self maxFloat ] ])					                asSortedCollection.				parentLabels last ~= self maxFloat ifTrue: [					vertices add: node -> parentLabels ] ] ].		labels at: vertices first key put: label.		label := label + 1 ]! !!RSSugiyamaLayout methodsFor: 'private' prior: 59251582!buildLayers: g	| w layerNr u vertices vertex layer done |	w := self maxFloat.	u := OrderedCollection new.	layers := IdentityDictionary new.	layerNrs := IdentityDictionary new. "Assign all nodes to layers"	[ g isEmpty ] whileFalse: [		vertices := g select: [ :e |			            (self parentsWithoutCylesFor: e) allSatisfy: [ :node |				            u includes: node ] ].		vertex := vertices detectMax: [ :e | labels at: e ].		done := false.		layerNr := 1.		[ done ] whileFalse: [			layer := layers at: layerNr ifAbsentPut: [ OrderedCollection new ].			(layer size >= w or: [				 (self parentsWithoutCylesFor: vertex) anySatisfy: [ :n |					 (layerNrs at: n) >= layerNr ] ])				ifTrue: [ layerNr := layerNr + 1 ]				ifFalse: [ done := true ] ].		layer add: vertex.		layerNrs at: vertex put: layerNr.		u add: vertex.		g remove: vertex ]! !!RSSugiyamaLayout methodsFor: 'accessing' prior: 59251233!childrenWithoutCyclesFor: aRSComposite	childrenWithoutCycles ifNil: [ childrenWithoutCycles := IdentityDictionary new ].	^ childrenWithoutCycles at: aRSComposite ifAbsentPut: [ (self childrenFor: aRSComposite) copy ]! !!RSSugiyamaLayout methodsFor: 'hook' prior: 59256566!doExecute: aNodeCollection	"Coffman-Graham-Layering. Di Battista Book, page 275, chapter, 9.2.1"	self removeCycles: aNodeCollection.	self assignLabels: aNodeCollection.	self buildLayers: aNodeCollection copy.	self addDummyNodes.	self reduceCrossing.	self layoutAt: self verticalGap @ self horizontalGap! !!RSSugiyamaLayout methodsFor: 'private' prior: 59254109!layoutAt: aPoint	| treeWidth layerKeys layer layerWidth horizontalPosition verticalPosition layerHeight |	treeWidth := layers values		             inject: self maxFloat negated		             into: [ :max :e |			             max max:				             (e sumNumbers: #width)				             + ((e size - 1) * self horizontalGap) ].	verticalPosition := self horizontalGap. "For visual reasons NOT: self class verticalGap"	layerKeys := layers keys asSortedCollection.	layerKeys do: [ :aKey |		layer := layers at: aKey.		layerWidth := (layer sum: #width)		              + ((layer size - 1) * self horizontalGap).		layerHeight := (layer detectMax: #height) height.		horizontalPosition := treeWidth / 2.0 + aPoint x		                      - (layerWidth / 2.0).		layer do: [ :node |			translator				translateTopLeftOf: node				to: horizontalPosition @ verticalPosition.			horizontalPosition := horizontalPosition + node width			                      + self horizontalGap ].		verticalPosition := verticalPosition + layerHeight		                    + self verticalGap ]! !!RSSugiyamaLayout methodsFor: 'real sugiyama' prior: 59257893!parentsWithoutCylesFor: aRSComposite	parentWithoutCycles ifNil: [ parentWithoutCycles := IdentityDictionary new ].	^ parentWithoutCycles at: aRSComposite ifAbsentPut: [ (self parentsFor: aRSComposite) copy ]! !!RSSugiyamaLayout methodsFor: 'real sugiyama' prior: 59255254!recursiveRemoveCyclesFrom: aNode	(visited includes: aNode) ifTrue: [ ^ self ].	visited add: aNode.	stack push: aNode.	(self childrenFor: aNode) do: [ :e |		(stack includes: e) ifTrue: [			self removeCycleFrom: aNode to: e		] ifFalse: [			self recursiveRemoveCyclesFrom: e.		]	].	stack pop! !!RSSugiyamaLayout methodsFor: 'private' prior: 59256025!reduceCrossing	"Crossing reduction"	| layer2 u v c1 c2 layer1 done |	2 to: layers keys size do: [ :index |		layer1 := layers at: index - 1.		layer2 := layers at: index.		done := false.		[ done ] whileFalse: [			done := true.			2 to: layer2 size do: [ :i |				u := layer2 at: i - 1.				v := layer2 at: i.				c1 := self cl: layer1 u: u v: v.				c2 := self cl: layer1 u: v v: u.				c1 > c2 ifTrue: [					layer2 rsSwapElement: u withElement: v.					done := false ] ] ] ]! !!RSSugiyamaLayout methodsFor: 'real sugiyama' prior: 59258167!removeCycleFrom: aRSComposite to: aRSComposite2	(self childrenWithoutCyclesFor: aRSComposite) remove: aRSComposite2.	(self parentsWithoutCylesFor: aRSComposite2) remove: aRSComposite! !!RSSugiyamaLayout methodsFor: 'real sugiyama' prior: 59255663!removeCycles: aCollection	| roots |	roots := self rootNodesFor: aCollection.	visited := Set new.	stack := Stack new.	roots do: [ :root | self recursiveRemoveCyclesFrom: root ]! !!RSSugiyamaLayout methodsFor: 'private' prior: 59255902!sortBlock	^ self class sortBlock! !!RSForceBasedLayout methodsFor: 'algorithm' prior: 58679257!accumulate: aQuad	| centerCharge |	centerCharge := 0@0.	aQuad charge: 0; centerOfCharge: 0@0.	aQuad isLeaf ifFalse: [		aQuad subQuadsDo: [ :aSubQuad |			self accumulate: aSubQuad.			aQuad charge: aQuad charge + aSubQuad charge.			centerCharge := centerCharge + (aSubQuad charge * aSubQuad centerOfCharge)] ].	aQuad soleChild ifNotNil: [ :soleChild |		| k |		aQuad isLeaf ifFalse: [			soleChild translateTo: soleChild position + (random next @ random next) - 0.5 ].		k := alpha * soleChild charge.		aQuad charge: aQuad charge + k.		centerCharge := centerCharge + (k * soleChild position) ].	aQuad charge = 0 ifTrue: [ ^ self ].	aQuad centerOfCharge: centerCharge / aQuad charge! !!RSForceBasedLayout methodsFor: 'adding-removing' prior: 58676693!addLines: realLines	| newMockLines |	newMockLines := realLines		collect: [ :e | self newMockLineFor: e ]		thenReject: [:e | e isNil ].	lines class = Array ifTrue: [ lines := OrderedCollection new ].	lines addAll: newMockLines! !!RSForceBasedLayout methodsFor: 'adding-removing' prior: 58674382!addNodes: realElements	| newMockElements |	newMockElements := (realElements collect: [ :e | self newMockElementFor: e ]).	nodes class = Array ifTrue: [ nodes := nodes asOrderedCollection ].	nodes addAll: newMockElements! !!RSForceBasedLayout methodsFor: 'accessing' prior: 58675933!autoRepulse: aBoolean	autoRepulse := aBoolean! !!RSForceBasedLayout methodsFor: 'hook' prior: 58678158!calculateAutoRepulse	lines do: [ :line | self calculateAutoRepulseFor: line ].	nodes do: [ :node | | e |		e := node extent.		e := e x max: e y.		node charge: e * -2 ]! !!RSForceBasedLayout methodsFor: 'hook' prior: 58677466!calculateAutoRepulseFor: line	| e1 e2 n |	e1 := line from extent.	e2 := line to extent.	e1 := e1 x max: e1 y.	e2 := e2 x max: e2 y.	n := (e1 + e2) * 0.7.	line length: n! !!RSForceBasedLayout methodsFor: 'accessing' prior: 58681902!center: aPoint	"gravity moves elements to that point"	center := aPoint! !!RSForceBasedLayout methodsFor: 'hook' prior: 58677057!doExecute: nodeShapes	nodeShapes do: [ :n | n updateLinesOFF ].	self nodes: nodeShapes.	self start.	self shouldUseProgressBar		ifTrue: [ self runLayoutInJob ]		ifFalse: [ self runLayoutSimply ].	alpha := 0.	nodes do: [ :e | translator translateTopLeftOf: e to: e position ].	nodeShapes do: [ :n | n updateLinesON. n connectedLines do: #update ]! !!RSForceBasedLayout methodsFor: 'initialization' prior: 58681033!initialize	super initialize.	random := Random seed: 42.	self		autoRepulse: false;		iterations: 0;		edges: #();		nodes: #();		initialLayout: RSGridLayout new;		gravity: 0.1;		friction: 0.9;		theta: 0.8;		strength: 1;		length: 20;		charge: -30;		center: 0@0;		useProgressBar! !!RSForceBasedLayout methodsFor: 'adding-removing' prior: 58680874!removeNode: aRealNode	| node |	node := self mockElementAt: aRealNode.	nodes remove: node! !!RSForceBasedLayout methodsFor: 'algorithm' prior: 58680193!repulse: aNode from: aQuad	aQuad soleChild = aNode ifFalse: [		| d |		d := aQuad centerOfCharge - aNode position.		(d closeTo: 0@0) ifFalse: [			| dn p k |			dn := 1 / d r.			p := aNode oldPosition.			aQuad rectangle width * dn < theta				ifTrue: [					k := aQuad charge * dn * dn.					aNode oldPosition: p - (d * k).					^ self ].			(aQuad soleChild notNil and: [ dn < 1e9 ])				ifTrue: [					k := aQuad soleChild charge * dn * dn * alpha.					aNode oldPosition: p - (d * k).] ] ].	(aQuad charge closeTo: 0) ifFalse: [		aQuad subQuadsDo: [ :aSubQuad | self repulse: aNode from: aSubQuad ] ]! !!RSForceBasedLayout methodsFor: 'hook' prior: 58673232!runLayoutIn: job	"Central method"	iterations isZero ifTrue: [		[alpha := alpha * 0.99.		alpha > 0.005 ] whileTrue: [			self step.			job currentValue: 1 - alpha ] ]	ifFalse: [		iterations timesRepeat: [			alpha := alpha * 0.99.			self step.		job currentValue: 1 - alpha ] ]! !!RSForceBasedLayout methodsFor: 'hook' prior: 58671907!runLayoutInJob	[ :job |		job			title: 'Laying out elements';			min: 1 - alpha;			max: 1.		self runLayoutIn: job ] asJob run! !!RSForceBasedLayout methodsFor: 'hook' prior: 58676398!runLayoutSimply	self runLayoutIn: Job new! !!RSForceBasedLayout methodsFor: 'hook' prior: 58682491!start	"mandatory for animations"	initialLayout on: nodes.	nodes := nodes collect: [ :node | self newMockElementFor: node ].	lines := lines		collect: [ :e | self newMockLineFor: e ]		thenReject: [:e | e isNil ].	self autoRepulse ifTrue: [		self calculateAutoRepulse.		 ].	alpha ifNil: [ alpha :=  0.1 ]! !!RSForceBasedLayout methodsFor: 'hook' prior: 58672453!step	nodes ifEmpty: [ ^ self ].	self stepEdgeForces.	self stepGravityForce.	self stepNodeRepulsion.	self stepFriction.	nodes do: [ :node | node applyToRealElement ]! !!RSForceBasedLayout methodsFor: 'events' prior: 58673576!stepEdgeForces	"Apply forces of edges."	lines do: [ :each |		| from to fp tp len k pd |		from := each from.		to := each to.		fp := from position.		tp := to position.		pd := tp - fp.		len := tp distanceTo: fp.		(len closeTo: 0) ifFalse: [			len := alpha * (each strength) * (len - (each length)) / len.			pd := pd * len.			k := from weight / (from weight + to weight).			to translateTo: tp - (pd * k).			k := 1 - k.			from translateTo: fp + (pd * k).]	]! !!RSForceBasedLayout methodsFor: 'events' prior: 58675194!stepFriction	"Apply friction. This is the last to do in a step, after new positions have been defined."	nodes do: [ :each |		| current new old |		current := each position.		old := each oldPosition.		new := current - ((old - current) * friction).		each translateTo: new.		each oldPosition: current ]! !!RSForceBasedLayout methodsFor: 'events' prior: 58678992!stepGravityForce	"Apply gravity"	| k |	k := alpha * gravity.	(k closeTo: 0) ifTrue: [ ^ self ].	nodes do: [ :each |		| pos |		pos := each position.		each translateTo: pos + (k * (center - pos)) ]! !!RSForceBasedLayout methodsFor: 'events' prior: 58675559!stepNodeRepulsion	"Handle fixed nodes. Do this after all forces in a step were already applied."	quadtree := RSQuadTreeForce withAll: nodes.	self accumulate: quadtree.	nodes		do: [ :each |			each isFixed				ifTrue: [ each translateTo: each fixPosition ]				ifFalse: [ self repulse: each from: quadtree ] ]! !!RSRectangleForceLayout methodsFor: 'initialization' prior: 59114076!initialize	super initialize.	enclosingThreshold := 50.	enclosingForce := 0.3! !!RSRectangleForceLayout methodsFor: 'events' prior: 59113962!step	self stepRectangleForces.	super step! !!RSRectangleForceLayout methodsFor: 'events' prior: 59114219!stepRectangleForces	"Apply a repulsion force to elements that are close to the enclosing rectangle."	| k |	k := enclosingForce * alpha.	(k closeTo: 0) ifTrue: [ ^ self ].	nodes do: [ :each |		| eachRect diff |		eachRect := each encompassingRectangle.		"horizontal"		(diff := eachRect left - enclosingRectangle left) < enclosingThreshold ifTrue: [			each translateTo: each position + (k * (enclosingThreshold - diff)@0) ].		(diff := enclosingRectangle right - eachRect right) < enclosingThreshold ifTrue: [			each translateTo: each position - (k * (enclosingThreshold - diff)@0) ].		"vertical"		(diff := eachRect top - enclosingRectangle top) < enclosingThreshold ifTrue: [			each translateTo: each position + (0@(k * (enclosingThreshold - diff))) ].		(diff := enclosingRectangle bottom - eachRect bottom) < enclosingThreshold ifTrue: [			each translateTo: each position - (0@(k * (enclosingThreshold - diff))) ].		]! !!RSLineDrivenLayout class methodsFor: 'instance creation' prior: 58929727!withEdges: aCollection	^self new userDefinedLines: aCollection! !!RSLineDrivenLayout methodsFor: 'accessing' prior: 58929227!edges: aCollection	"Set the list of edges that should be considered for the layout.	If none is specified (i.e., if this method is not called), then the	edges are infered."	lines := aCollection! !!RSLineDrivenLayout methodsFor: 'iterator' prior: 58928149!edgesDo: aBlock	"Iterates over all the edges of the receiver."	lines ifNil: [ ^ self ].	lines do: aBlock! !!RSLineDrivenLayout methodsFor: 'hook' prior: 58928415!executeOnElements: elements	"Execute the layout, myself, on the elements"	self userDefinedLines		ifNil: [ self setEdgesFromElements: elements ]		ifNotNil: [ | flat |			flat := OrderedCollection new.			self userDefinedLines				do: [ :each |					each isCollection						ifTrue: [ flat addAll: each ]						ifFalse: [ flat add: each ] ].			self edges: flat ].	super executeOnElements: elements! !!RSLineDrivenLayout methodsFor: 'accessing' prior: 58928984!setEdgesFromElements: shapes	shapes isEmpty ifTrue: [ ^ self ].	^ self edges:		((shapes flatCollect: #incomingLines)			select: [ :anEdge |shapes includes: anEdge from])! !!RSLineDrivenLayout methodsFor: 'private'!userDefinedLines	^ userDefinedLines! !!RSLineDrivenLayout methodsFor: 'hook'!userDefinedLines: aCollectionOfLines	"useful to tell to the layout which edges have to be used for the layout"	userDefinedLines := aCollectionOfLines! !!RSRectanglePackLayout class methodsFor: 'examples'!example1	<noTest>	| numberOfBoxes random shapes canvas |		numberOfBoxes := 900.	random := Random seed: 42.	shapes := RSGroup new.	numberOfBoxes timesRepeat: [ 		shapes add: (RSBox new width: (random nextInteger: 40); height: (random nextInteger: 40)) ].	canvas := RSCanvas new.	canvas addAll: shapes.	self new useProgressBar; on: shapes.	canvas @ RSCanvasController.	^ canvas open! !!RSRectanglePackLayout class methodsFor: 'examples'!example2	| nodes canvas shapes |	nodes := (1 to: 20) asArray shuffleBy: (Random seed: 42).	canvas := RSCanvas new.	shapes := RSCircle models: nodes.	shapes size: 30.	canvas addAll: shapes.	RSNormalizer size	    shapes: shapes;	    normalize.	self on: shapes.	canvas zoomToFit.	^ canvas open! !!RSRectanglePackLayout methodsFor: 'space-calculation' prior: 59116779!bestSpaceFor: anElement	| elementsPadedBox suitableSpaces |	elementsPadedBox := anElement encompassingRectangle extendBy: padding * 2.	suitableSpaces := freeSpace select: [ :space |		elementsPadedBox width <= space width and:			[ elementsPadedBox height <= space height ] ].	^ suitableSpaces		fold: [ :best :current |			| bestExt currentExt |			((currentExt := self extentByInserting: elementsPadedBox into: current) <			(bestExt := self extentByInserting: elementsPadedBox into: best) or: [				currentExt = bestExt and: [					current halfPerimeter < best halfPerimeter ] ])						ifTrue: [ current ]						ifFalse: [ best ] ]! !!RSRectanglePackLayout methodsFor: 'hook' prior: 59119257!doExecute: shapes	| sortedShapes maxSpace |	bounds := 0@0.	maxSpace := shapes		inject: 0@0		into: [ :sum :el | sum + el extent ].	padding := maxSpace / shapes size * gap / 2.	maxSpace :=(1 + gap) * maxSpace.	freeSpace := Set with: (0@0 corner: maxSpace).	sortedShapes := SortedCollection sortBlock:  [ :larger :smaller |		larger  encompassingRectangle halfPerimeter >		smaller encompassingRectangle halfPerimeter ].	sortedShapes addAll: shapes.	sortedShapes size <= 2 ifTrue: [		^ RSHorizontalLineLayout on: sortedShapes ].	self shouldUseProgressBar		ifTrue: [			sortedShapes				do: [ :element | self packIn: element ]				displayingProgress: 'Laying out elements' ]		ifFalse: [			sortedShapes				do: [ :element | self packIn: element ] ]! !!RSRectanglePackLayout methodsFor: 'space-calculation' prior: 59120123!extentByInserting: aRectangle into: aSpace	| futureCorner preferredAngleInDegrees |	futureCorner := aSpace origin + aRectangle extent.	preferredAngleInDegrees := preferredAngle radiansToDegrees.	^ (((futureCorner max: bounds) degrees - preferredAngleInDegrees) abs / preferredAngleInDegrees + 1)! !!RSRectanglePackLayout methodsFor: 'execution' prior: 59120581!packIn: anElement	translator translateTopLeftOf: anElement to: (self bestSpaceFor: anElement) origin + padding.	bounds := bounds max: anElement encompassingRectangle bottomRight + padding.	self recalculateFreeSpacesWith: anElement! !!RSRectanglePackLayout methodsFor: 'space-calculation' prior: 59118088!recalculateFreeSpacesWith: anElement	| rectangle |	rectangle := anElement encompassingRectangle expandBy: padding.	freeSpace := freeSpace inject: Set new into: [ :set :space |		 set			addAll: (space areasOverlapingOutside: rectangle);			yourself ].	"remove subspaces"	freeSpace := freeSpace reject: [ :subspace |		freeSpace anySatisfy: [ :space |			space ~~ subspace and: [				space containsRect: subspace ] ] ]! !!RSSimpleForceBasedLayout methodsFor: 'hook' prior: 59241914!doExecute: shapes	| layout es |	shapes do: [ :n | n updateLinesOFF ].	layout := RSForceBasedLayout new.	layout nodes: shapes.	es := shapes flatCollect: #outgoingLines.	layout edges: es.	layout start.	shapes do: [ :node |		layout			mockElementAt: node			ifPresent: [ :mock |				mock					charge: node width * -10;					weight: node width] ].	es do: [ :edge |		layout			mockLineAt: edge			ifPresent: [ :mock |				mock					strength: 1;					length: (edge from width + edge to width) ] ].	layout runLayoutSimply.	shapes do: [ :n | n updateLinesON. n connectedLines do: #update ]! !!RSLocation class methodsFor: 'examples'!example1	| canvas box1 box2 label |	canvas := RSCanvas new.	box1 := RSBox new size: 50; color: Color gray translucent.	box2 := RSBox new size: 30; color: Color gray translucent.	box1 @ RSDraggable.	box2 @ RSDraggable.	canvas add: box1; add: box2.	box1 translateBy: 150 @ -40.	label := RSLabel new text: 'Move the mouse above me'.	canvas add: label.	self new 		above;		stick: label on: box1.	^ canvas open! !!RSLocation class methodsFor: 'examples'!example2	| canvas group baseShape redShape |	canvas := RSCanvas new.	group := RSGroup new.	group add: (RSLabel new text: 'Base shape, drag me').	baseShape := group asShape adjustToChildren.	baseShape color: #lightBlue.	baseShape @ RSDraggable.	canvas add: baseShape.	redShape := RSBox new extent: 60 @ 30; color: #red.	canvas add: redShape.	self new		bottom;		outer;		right;		offset: 20@0;		stick: redShape on: baseShape.	"Try changing stick:on: by move:on. Replacing bottom by top"	^ canvas open! !!RSLocation methodsFor: 'public - positioning shorcuts' prior: 58953977!above	self top; outer! !!RSLocation methodsFor: 'public - positioning shorcuts' prior: 58953138!below	self bottom; outer! !!RSLocation methodsFor: 'public - modifiers' prior: 58953225!border	self orientation: 0@0! !!RSLocation methodsFor: 'public - positioning' prior: 58952059!bottom	"Locate the shape at the bottom of the base shape.For example:```Smalltalkc := RSCanvas new.g := RSGroup new.g add: (RSLabel new text: 'Base shape').baseShape := g asShape adjustToChildren.baseShape color: #lightBlue.baseShape @ RSDraggable.c add: baseShape.redShape := RSBox new extent: 60 @ 30; color: #red.c add: redShape.RSLocation new	bottom;	outer;	right;	move: redShape on: baseShape.c```	"	fixedY := #bottom.	direction := direction x @ -1! !!RSLocation methodsFor: 'private' prior: 58953538!computePosition: movableShape on: fixedShape	^ movableShape extent / 2 * orientation * direction + (self parentPosition: fixedShape) + offset! !!RSLocation methodsFor: 'public - modifiers' prior: 58953742!inner	self orientation: 1@1! !!RSLocation methodsFor: 'public - positioning shorcuts'!insideCornerLeft	self orientation: 1 @ -1; top; left! !!RSLocation methodsFor: 'public - positioning shorcuts'!insideCornerRight	self orientation: 1 @ -1; top; right! !!RSLocation methodsFor: 'public - executing' prior: 58954175!move: movableShape on: baseShape	"Utility method"	movableShape translateTo: (self computePosition: movableShape on: baseShape)! !!RSLocation methodsFor: 'public - modifiers' prior: 58954442!offset: aNumber	"Let an offset between the positioned shape and the base shape.For example```Smalltalkc := RSCanvas new.g := RSGroup new.g add: (RSLabel new text: 'Base shape').baseShape := g asShape adjustToChildren.baseShape color: #lightBlue.baseShape @ RSDraggable.c add: baseShape.redShape := RSBox new extent: 60 @ 30; color: #red.c add: redShape.RSLocation new	bottom;	outer;	right;	offset: 20;	move: redShape on: baseShape.c```"	offset := aNumber asPoint! !!RSLocation methodsFor: 'public - modifiers'!orientation: aPoint	"check users of method orientation"	orientation := aPoint! !!RSLocation methodsFor: 'public - modifiers' prior: 58953464!outer	self orientation: -1 @ -1! !!RSLocation methodsFor: 'private' prior: 58954980!parentPosition: fixedShape	| rec |	rec := fixedShape.	rec isRectangle ifFalse:  [ rec := rec encompassingRectangle ] .	^ (fixedX value: rec)@ (fixedY value: rec)! !!RSLocation methodsFor: 'public - positioning' prior: 58952601!right	"Locate the shape on the right of the base shape.For example:```Smalltalkc := RSCanvas new.g := RSGroup new.g add: (RSLabel new text: 'Base shape').baseShape := g asShape adjustToChildren.baseShape color: #lightBlue.baseShape @ RSDraggable.c add: baseShape.redShape := RSBox new extent: 60 @ 30; color: #red.c add: redShape.RSLocation new	above;	right;	move: redShape on: baseShape.c```"	fixedX := #right.	direction := -1 @ direction y! !!RSLocation methodsFor: 'public - executing' prior: 58955728!stick: movableShape on: baseShape	| block |	block := [ self move: movableShape on: baseShape ].	block value.	baseShape		when: RSExtentChangedEvent do: block for: self;		when: RSPositionChangedEvent do: block for: self! !!RSDraggableForceInteraction methodsFor: 'hooks' prior: 58611231!onShape: aShape	aShape removeInteractionIfPresent: RSDraggable.	aShape		when: RSMouseDragStart do: [ :evt |			layout				mockElementAt: evt shape				ifPresent: [ :mock | mock isFixed: true ] ]			for: self;		when: RSMouseDragging do: [ :evt |			| d |			d := evt shape parent camera distanceFromPixelToSpace: evt step.			evt shape translateBy: d.			layout				mockElementAt: evt shape				ifPresent: [ :mock | mock fixPosition: evt shape position ].			evt shape signalUpdate ]			for: self;		when: RSMouseDragEnd do:[:evt |			layout				mockElementAt: evt shape				ifPresent: [ :mock | mock isFixed: false ] ]			for: self! !!RSHierarchyPackerInteraction methodsFor: 'private' prior: 58724219!fill: group with: aShape	group add: aShape.	aShape outgoingLines do: [ :ed |		self fill: group with: ed to ]! !!RSHierarchyPackerInteraction methodsFor: 'initialization' prior: 58723791!initialize	super initialize.	rectanglePackLayout := RSRectanglePackLayout new		doNotUseProgressBar;		yourself! !!RSHierarchyPackerInteraction methodsFor: 'private' prior: 58723112!onShape: aCanvas	| layout connectedAsGroups connected isolated all |	layout := RSTreeLayout new		edges: aCanvas edges.	connectedAsGroups := aCanvas nodes.	connected := connectedAsGroups select: #hasEdges.	isolated := connectedAsGroups reject: #hasEdges.	connectedAsGroups := (layout rootNodesFor: connected) collect: [ :e |		| group |		group :=  RSGroup new.		self fill: group with: e.		group ].	all := connectedAsGroups, isolated.	aCanvas when: RSExtentChangedEvent do: [		rectanglePackLayout			preferredAngle: aCanvas extent angle;			on: all.		aCanvas zoomToFit; signalUpdate ]	for: self! !!RSForceLayoutSteppingInteraction methodsFor: 'hooks' prior: 58693624!addEventsTo: shape	| mock |	shape		when: RSMouseDragStart do: [ :evt |			mock := layout mockElementAt: evt shape.			mock isFixed: true.			self startForceAnimation: evt canvas ]		for: self;		when: RSMouseDragging do: [ :evt |			mock fixPosition: evt shape position ]		for: self;		when: RSMouseDragEnd do:[:evt |			mock isFixed: false.			mock := nil.			self startSimpleAnimation: evt canvas ]		for: self! !!RSForceLayoutSteppingInteraction methodsFor: 'hooks' prior: 58692867!configureLayoutOn: aCanvas	self hasDraggable ifTrue: [		aCanvas nodes @ (RSDraggableForceInteraction new layout: self layout)].	self layout		nodes: aCanvas nodes;		edges: aCanvas edges;		start! !!RSForceLayoutSteppingInteraction methodsFor: 'initialization' prior: 58693408!initialize	super initialize.	self draggable! !!RSForceLayoutSteppingInteraction methodsFor: 'configuration' prior: 58695583!noDraggable	hasDraggable := false! !!RSForceLayoutSteppingInteraction methodsFor: 'hooks' prior: 58693136!onShape: aCanvas	self configureLayoutOn: aCanvas.	aCanvas nodes do: [ :s | self addEventsTo: s ].	self startFirstAnimation: aCanvas.	aCanvas newAnimation onStepDo: [:t| aCanvas zoomToFit ]! !!RSForceLayoutSteppingInteraction methodsFor: 'animation' prior: 58694543!startForceAnimation: aCanvas	animation ifNotNil: #stop.	animation := aCanvas animationFrom: {		"Start smoothly"		aCanvas transitionAnimation			easing: RSEasingInterpolator cubicOut;			duration: 500 milliSeconds;			range: self alphaRange;			onStepDo: [ :t | layout alpha: t; step ].		"Continue on max alpha undefinitely"		aCanvas transitionAnimation			repeat;			onStepDo: [ :t | layout step ] }! !!RSForceLayoutSteppingInteraction methodsFor: 'animation' prior: 58695025!startSimpleAnimation: aCanvas	animation ifNotNil: #stop.	animation := aCanvas newAnimation		easing: RSEasingInterpolator cubicInOut;		range: self alphaRange reversed;		duration: 2 seconds;		onStepDo: [ :t | layout alpha: t; step  ];		yourself! !!RSLayoutBuilder class methodsFor: 'examples'!exampleTidyTree	| canvas notConnected |	canvas := RSCanvas new.	canvas @ RSCanvasController.	notConnected := {self. RSEvent. RSShape }.	RSLayout 		canvasExampleIn: canvas		models: SequenceableCollection withAllSubclasses,			Set withAllSubclasses, notConnected.	self new tidyTree; on: canvas nodes.	^ canvas open.! !!RSLayoutBuilder methodsFor: 'public - layout' prior: 58874645!cell	^ layout := RSCellLayout new! !!RSLayoutBuilder methodsFor: 'public - layout' prior: 58874249!circle	^ layout := RSCircleLayout new! !!RSLayoutBuilder methodsFor: 'public - layout' prior: 58873074!cluster	^ layout := RSClusterTreeLayout new! !!RSLayoutBuilder methodsFor: 'public - layout' prior: 58874351!flow	^ layout := RSFlowLayout new! !!RSLayoutBuilder methodsFor: 'public - layout' prior: 58875479!grid	^ layout := RSGridLayout new! !!RSLayoutBuilder methodsFor: 'public - layout' prior: 58872666!horizontal	^ layout := RSHorizontalLineLayout new! !!RSLayoutBuilder methodsFor: 'public - layout' prior: 58875577!horizontalTree	^ layout := RSHorizontalTreeLayout new! !!RSLayoutBuilder methodsFor: 'initialization' prior: 58873491!initialize	super initialize.	self flow! !!RSLayoutBuilder methodsFor: 'accessing' prior: 58872878!layout	^ layout! !!RSLayoutBuilder methodsFor: 'public - layout' prior: 58875237!radial	^ layout := RSRadialTreeLayout new! !!RSLayoutBuilder methodsFor: 'public - layout' prior: 58874859!rawForce	^ layout := RSForceBasedLayout new useProgressBar! !!RSLayoutBuilder methodsFor: 'public - layout' prior: 58873597!sugiyama	^ layout := RSSugiyamaLayout new! !!RSLayoutBuilder methodsFor: 'public - layout' prior: 58873703!tidyTree	^ layout := RSConditionalLayout new					 ifNotConnectedThen: RSGridLayout new;					 else: (RSClusteringLayout new					    clustersLayout: RSFlowLayout new;					    forEachLayout: RSTreeLayout new)! !!RSLayoutBuilder methodsFor: 'public - layout' prior: 58873182!tree	^ layout := RSTreeLayout new! !!RSLayoutBuilder methodsFor: 'public - layout' prior: 58875127!vertical	^ layout := RSVerticalLineLayout new! !!SequenceableCollection methodsFor: '*Roassal3-Layouts' prior: 62011294!rsSwapElement: u withElement: v	| index1 index2 |	index1 := self indexOf: u.	index2 := self indexOf: v.	self at: index2 put: u.	self at: index1 put: v! !RSLineDrivenLayout removeSelector: #userDefinedEdges:!RSLineDrivenLayout removeSelector: #userDefinedEdges!RSLineDrivenLayout removeSelector: #toPositions:!RSLineDrivenLayout removeSelector: #isEdgeDrivenLayout!RSLineDrivenLayout removeSelector: #fromPositions:!RSLineDrivenLayout removeSelector: #doIncrementallyExecute:!RSLineDrivenLayout removeSelector: #doExecute:!Smalltalk globals removeClassNamed: #AnObsoleteRSEdgeDrivenLayout!RSVerticalGridLayout removeSelector: #doExecute:!Smalltalk globals removeClassNamed: #AnObsoleteRSVerticalGridLayout!RSAbstractGridLayout removeSelector: #gapSize:!RSAbstractGridLayout removeSelector: #gapSize!RSAbstractGridLayout removeSelector: #defaultGapSize!RSLayout removeSelector: #userDefinedEdges:!RSLayout removeSelector: #isEdgeDrivenLayout!RSLayout class removeSelector: #exampleBasic!RSLayout class removeSelector: #example3!RSLayout class removeSelector: #example2!RSLayout class removeSelector: #example1!RSAngleLineLayout removeSelector: #positionOriginalPointer!RSAngleLineLayout removeSelector: #doExecute:!RSCellLayout removeSelector: #leftCentered!RSCellLayout removeSelector: #inCellPosition:!RSCellLayout removeSelector: #centered!RSVerticalLineLayout removeSelector: #initialize!RSClusterLayout class removeSelector: #isDeprecated!Smalltalk globals removeClassNamed: #AnObsoleteRSClusterLayout!RSAbstractFlowLayout removeSelector: #gapSize:!RSAbstractFlowLayout removeSelector: #gapSize!RSAbstractFlowLayout removeSelector: #defaultGapSize!RSTWalkBasedRegularTreeLayoutOnShapeProperties removeSelector: #modOf:put:!RSTWalkBasedRegularTreeLayoutOnShapeProperties removeSelector: #modOf:!RSAbstractHorizontalTreeLayout removeSelector: #computeChildrenFor:!RSAbstractCompactTreeLayout removeSelector: #greedyCycleRemoval:!RSAbstractLineLayout removeSelector: #verticalGap:!RSAbstractLineLayout removeSelector: #verticalGap!RSAbstractLineLayout removeSelector: #horizontalGap:!RSAbstractLineLayout removeSelector: #horizontalGap!RSAbstractLineLayout removeSelector: #gapSize:!RSAbstractLineLayout removeSelector: #gapSize!RSAbstractLineLayout removeSelector: #defaultGapSize!RSAbstractVerticalTreeLayout removeSelector: #computeChildrenFor:!RSHorizontalLineLayout removeSelector: #initialize!"Roassal3-Layouts"!!RSColoredTreePalette methodsFor: 'private' prior: 58523015!allLeavesAccessibleFrom: aRootShape	| c |	c := OrderedCollection new.	self allLeavesAccessibleFrom: aRootShape in: c.	^ c size! !!RSColoredTreePalette methodsFor: 'private' prior: 58523317!allLeavesAccessibleFrom: aShape in: result	aShape numberOfOutgoingLines = 0		ifTrue: [			result add: self ]		ifFalse: [			 (aShape outgoingLines collect: #to) do: [ :s | self allLeavesAccessibleFrom: s in: result ]			 ]! !!RSColoredTreePalette methodsFor: 'private' prior: 58523938!assignColorToChildren: children low: low high: high	| step hs |	step := high - low / children size.	hs := low to: high count: children size.	children with: hs do: [ :s :h |		self assignColorToRoot: s h: (h min: 360 max: 0)	]! !!RSColoredTreePalette methodsFor: 'private' prior: 58522268!assignColorToRoot: aRootShape h: h	| children span |	aRootShape color: ((Color h: h s: 1 v: 1) alpha: alpha).	children := aRootShape outgoingShapes.	children ifEmpty: [ ^ self ].	span := (self allLeavesAccessibleFrom: aRootShape) * 360 / (totalNumberOfLeaves * 2).	self assignColorToChildren: children low: h - (span / 2) high: h + (span / 2)! !!RSColoredTreePalette methodsFor: 'accessing' prior: 58524312!shapes: someShapes	"Set the shapes (the nodes) that must be colored"	shapes := someShapes.	totalNumberOfLeaves := 0.	(someShapes select: [ :s | s numberOfIncomingLines = 0 ]) do: [ :s |		totalNumberOfLeaves := totalNumberOfLeaves + (self allLeavesAccessibleFrom: s)	]! !!RSGradientPalette class methodsFor: 'gradients' prior: 58699672!burningSpring	^ LinearGradientPaint fromArray:		{0->'4fb576'.		0.30->'44c489'.		0.46->'28a9ae'.		0.59->'28a2b7'.		0.71->'4c7788'.		0.86->'6c4f63'.		1->'432c39' }! !!RSGradientPalette class methodsFor: 'gradients' prior: 58698670!cloudyKnoxville	^ LinearGradientPaint fromArray:		{0->'fdfbfb'.		1->'ebedee' }! !!RSGradientPalette class methodsFor: 'gradients' prior: 58699249!deepBlue	^ LinearGradientPaint fromArray:		{0->'e0c3fc'.		1->'8ec5fc' }! !!RSGradientPalette class methodsFor: 'gradients' prior: 58700321!dustyGrass	^ LinearGradientPaint fromArray:		{0->'d4fc79'.		1->'96e6a1' }! !!RSGradientPalette class methodsFor: 'gradients' prior: 58700747!fabledSunset	^ LinearGradientPaint fromArray:		{0->'231557'.		0.29->'44107A'.		0.67->'FF1361'.		1->'FFF800' }! !!RSGradientPalette class methodsFor: 'palette' prior: 58702072!gradient21	^ NSScale ordinal range:(		#('warmFlame'			'nightFade'			'youngPassion'			'sunnyMorning'			'rainyAshville'			'winterNeva'			'dustyGrass'			'temptingAzure'			'heavyRain'			'deepBlue'			'cloudyKnoxville'			'malibuBeach'			'trueSunset'			'morpheusDen'			'nearMoon'			'happyFisher'			'sweetPeriod'			'burningSpring'			'redSalvation'			'northMiracle'			'fabledSunset') collect: [ :selector | self perform: selector asSymbol ] );		yourself! !!RSGradientPalette class methodsFor: 'gradients' prior: 58700463!happyFisher	^ LinearGradientPaint fromArray:		{0->'89f7fe'.		1->'66a6ff' }! !!RSGradientPalette class methodsFor: 'gradients' prior: 58699389!heavyRain	^ LinearGradientPaint fromArray:		{0->'cfd9df'.		1->'e2ebf0' }! !!RSGradientPalette class methodsFor: 'gradients' prior: 58702609!malibuBeach	^ LinearGradientPaint fromArray:		{0->'4facfe'.		1->'00f2fe' }! !!RSGradientPalette class methodsFor: 'gradients' prior: 58698962!morpheusDen	^ LinearGradientPaint fromArray:		{0->'30cfd0'.		1->'330867' }! !!RSGradientPalette class methodsFor: 'gradients' prior: 58701214!nearMoon	^ LinearGradientPaint fromArray:		{0->'5ee7df'.		1->'b490ca' }! !!RSGradientPalette class methodsFor: 'gradients' prior: 58700606!nightFade	^ LinearGradientPaint fromArray:		{0->'a18cd1'.		1->'fbc2eb' }! !!RSGradientPalette class methodsFor: 'gradients' prior: 58698526!northMiracle	^ LinearGradientPaint fromArray:		{0->'00dbde'.		1->'fc00ff' }! !!RSGradientPalette class methodsFor: 'gradients' prior: 58700176!rainyAshville	^ LinearGradientPaint fromArray:		{0->'fbc2eb'.		1->'a6c1ee' }! !!RSGradientPalette class methodsFor: 'gradients' prior: 58702752!redSalvation	^ LinearGradientPaint fromArray:		{0->'f43b47'.		1->'453a94' }! !!RSGradientPalette class methodsFor: 'view' prior: 58701349!roassalCanvas	<example>	| canvas gradients |	canvas := RSCanvas new.	gradients := self class methods select: [ :met | met category = #gradients ].	canvas addAll: (gradients collect: [ :met |		| paint |		paint := met selector value: self.		paint start: 0@ -15; stop: 0@15.		RSEllipse new			model: met selector;			popup;			paint: paint;			radius: 30.		]).	RSGridLayout on: canvas nodes.	canvas @ RSCanvasController.	canvas open! !!RSGradientPalette class methodsFor: 'gradients' prior: 58699105!sunnyMorning	^ LinearGradientPaint fromArray:		{0->'f6d365'.		1->'fda085' }! !!RSGradientPalette class methodsFor: 'gradients' prior: 58699907!sweetPeriod	^ LinearGradientPaint fromArray:		{0->'3f51b1'.		0.13->'5a55ae'.		0.25->'7b5fac'.		0.38->'8f6aae'.		0.50->'a86aa4'.		0.62->'cc6b8e'.		0.75->'f18271'.		0.87->'f3a469'.		1->'f7c978' }! !!RSGradientPalette class methodsFor: 'gradients' prior: 58698817!temptingAzure	^ LinearGradientPaint fromArray:		{0->'84fab0'.		1->'8fd3f4' }! !!RSGradientPalette class methodsFor: 'gradients' prior: 58699530!trueSunset	^ LinearGradientPaint fromArray:		{0->'fa709a'.		1->'fee140' }! !!RSGradientPalette class methodsFor: 'gradients' prior: 58700927!warmFlame	^ LinearGradientPaint fromArray:		{0-> 'ff9a9e'.		1->'fad0c4' }! !!RSGradientPalette class methodsFor: 'gradients' prior: 58701072!winterNeva	^ LinearGradientPaint fromArray:		{0->'a1c4fd'.		1->'c2e9fb' }! !!LinearGradientPaint methodsFor: '*Roassal3-Colors' prior: 30962808!asScale	| sc |	sc := NSScale linear.	sc domain: (colorRamp collect: #key).	sc range: (colorRamp collect: #value).	^ sc! !!RSColorPalette methodsFor: 'instance creation' prior: 58520897!fromTriplet: array	^ NSScale ordinal		range: (array collect: [ :arr |			Color				r: arr first				g: arr second				b: arr third				range: 255 ]);		yourself! !"Roassal3-Colors"!!RSLegend methodsFor: 'hooks' prior: 58886560!basicRenderIn: aCanvas	| legend |	legend := self createLegend.	location move: legend on: aCanvas shapes.	aCanvas addShape: legend! !!RSLegend methodsFor: 'public' prior: 58887832!beFixedWithTitle: aString	isFixed := true.	^ menuShape := self defaultTitle copy		text: aString;		yourself! !!RSLegend methodsFor: 'public - specific' prior: 58885590!boxHeightIcon	| box marker arrow icon |	box := RSBox new		border: (RSBorder new color: Color black; width: 2);		extent: 15@15;		color: Color white;		yourself.	marker := RSShapeFactory arrow		size: 10;		color: Color black;		yourself.	arrow := RSLine new		startPoint: 0@0;		endPoint: 0 @ box height;		color: Color black;		marker: marker;		yourself.	icon := { arrow. box }.	RSHorizontalLineLayout new gapSize: 5; on: icon.	^ icon asGroup asShape! !!RSLegend methodsFor: 'public - specific' prior: 58880775!boxText: aString icon: aShape	| group row |	group := { aShape. self defaultLabel copy text: aString }.	RSHorizontalLineLayout new gapSize: 5; on: group.	row := group asGroup asShape.	row padding: (Margin fromPoint: 0@5).	shapes add: row.	^ row! !!RSLegend methodsFor: 'public - specific' prior: 58888001!boxWidthIcon	| box marker arrow icon |	box := RSBox new		border: (RSBorder new color: Color black; width: 2);		extent: 25@15;		color: Color white;		yourself.	marker := RSShapeFactory arrow		size: 10;		color: Color black;		yourself.	arrow := RSLine new		startPoint: 0@0;		endPoint: box width @ 0;		color: Color black;		marker: marker;		yourself.	icon := { box. arrow }.	RSVerticalLineLayout new gapSize: 5; on: icon.	^ icon asGroup asShape! !!RSLegend methodsFor: 'public - specific' prior: 58879524!customText: anObject shape: aShape	| shape |	"general propuse, you can add and define anything in aShape to be a legend"	shape := aShape copy text: anObject.	shapes add: shape.	^ shape! !!RSLegend methodsFor: 'initialization' prior: 58885380!initialize	super initialize.	self reset! !!RSLegend methodsFor: 'utilities' prior: 58881081!key	^ #legendLabels! !!RSLegend methodsFor: 'layout' prior: 58888508!layout	^ layout! !!RSLegend methodsFor: 'private' prior: 58882064!legendLabelsIn: aCanvas	^ aCanvas propertyAt: self key ifAbsentPut: [		aCanvas when: RSExtentChangedEvent send: #updateLegendLabels: to: self.		RSGroup new: 5 ]! !!RSLegend methodsFor: 'public' prior: 58886480!onDemand	^ self onDemand: 'Help'! !!RSLegend methodsFor: 'public - specific' prior: 58883133!polymetricWidth: labelWidth height: labelHeight box: labelBox	"very very specific shape"	| box s marker line g l1 l2 l3 line1 line2 defaultLabel |	box := RSBox new		size: 100.	marker := RSShapeFactory triangle		color: Color black;		size: 5.	line := RSLine new		marker: marker;		yourself.	g := RSGroup new.	defaultLabel := self defaultLabel.	l1 := defaultLabel copy text: labelWidth.	l2 := defaultLabel copy text: labelHeight.	l3 := defaultLabel copy text: labelBox.	l1 position: 0@70.	l3 scaleBy: 90/ l3 width.	l2 position: l2 width / 2 negated - 60 @ 0.	line1 := line copy startPoint:  -50@60; endPoint: 50@60.	line2 := line copy startPoint: -60@ -50; endPoint: -60@ 50.	g addAll: {box. l1. l2. l3. line1. line2 }.	s := RSComposite new		shapes: g.	self shapes add: s.	^ s! !!RSLegend methodsFor: 'hooks' prior: 58881148!renderFixedOn: aCanvas	| legend legendLabels originalShapes flag |	shapes addFirst: menuShape.	originalShapes := shapes copy.	legend := self createLegend.	legend isFixed: true.	aCanvas addShape: legend.	legendLabels := self legendLabelsIn: aCanvas.	legendLabels add: legend.	self updateLegendLabels: aCanvas.	flag := true.	legend when: RSMouseClick do: [ :evt |		legend remove.		legendLabels remove: legend.		shapes := flag			ifTrue: [ { menuShape } ]			ifFalse: [ originalShapes ].		flag := flag not.		legend := self createLegend.		legend isFixed: true.		legend announcer: evt shape announcer.		aCanvas addShape: legend.		legendLabels add: legend.		self updateLegendLabels: aCanvas.		evt signalUpdate ]	for: self! !!RSLegend methodsFor: 'hooks' prior: 58884050!renderIn: aCanvas	self isOnDemand		ifTrue: [ self renderOnDemandIn: aCanvas ]		ifFalse: [			self isFixed				ifTrue: [ self renderFixedOn: aCanvas ]				ifFalse: [self basicRenderIn: aCanvas ] ]! !!RSLegend methodsFor: 'hooks' prior: 58880120!renderOnDemandIn: aCanvas	| i legendLabels |	menuShape isFixed: true.	aCanvas addShape: menuShape.	i := RSAnimatedPopup new.	i shapeBuilder: [ self createLegend ].	menuShape @ i.	legendLabels := self legendLabelsIn: aCanvas.	legendLabels add: menuShape.	self updateLegendLabels: aCanvas! !!RSLegend methodsFor: 'initialization' prior: 58884308!reset	legendBlock := [ :l | l draggable ].	shapes := RSGroup new.	location := RSLocation new below.	layout := RSLayoutBuilder new.	layout vertical gapSize: 0.	isFixed := false.	isOnDemand := false.	defaults := Dictionary new! !!RSLegend methodsFor: 'public' prior: 58887205!text: aString withBoxColor: color	^ self text: aString withShape: (self shape: self defaultBox withColor: color)! !!RSLegend methodsFor: 'public' prior: 58880463!text: aString withCircleColor: color	^ self text: aString withShape: (self shape: self defaultCircle withColor: color)! !!RSLegend methodsFor: 'public - specific' prior: 58884604!text: aString withFadingRamp: ramp	| gradient s |	"very specific shape"	gradient := LinearGradientPaint fromArray: ramp.	gradient start: -20@0; stop: 20@0.	s := RSBox new		extent: 40@20;		paint: gradient;		yourself.	^ self text: aString withShape: s! !!RSLegend methodsFor: 'private' prior: 58884913!updateLegendLabels: evt	| legendLabels |	legendLabels := self legendLabelsIn: evt canvas.	RSHorizontalLineLayout on: legendLabels.	RSLocation new		inner; top; right;		offset: -5 @ 5;		move: legendLabels on: evt canvas basicRectangle! !!RSLegend methodsFor: 'public' prior: 58882614!withFrame	"Set a frame around the legend"	self legendDo: [ :l |		l			border: RSBorder new;			color: (Color white alpha: 0.8);			padding: 10.		]! !"Roassal3-Legend"!!RSUMLPackageBuilder methodsFor: 'accessing' prior: 59477929!packages	^packages! !!RSUMLPackageBuilder methodsFor: 'hooks' prior: 59477610!renderIn: aCanvas	super renderIn: aCanvas.	self layout on: shapes! !!RSUMLAbstractBuilder class methodsFor: 'testing' prior: 59472291!isAbstract	^self name = #RSUMLAbstractBuilder! !!RSUMLAbstractBuilder methodsFor: 'private' prior: 59471593!defaultContainer	^ RSCanvas new		addInteraction: RSCanvasController new;		yourself! !!RSUMLAbstractBuilder methodsFor: 'accessing' prior: 59471742!modelDescriptor: aRSClassDescriptor	modelDescriptor := aRSClassDescriptor.	renderer ifNotNil: [ renderer modelDescriptor: modelDescriptor ]! !!RSBasicUMLClassRenderer methodsFor: 'hooks' prior: 58346889!addLines: group title: title	| line rec offset |	line := self classInnerLine.	rec := group encompassingRectangle.	offset := 2.5.	group size > 2 ifTrue: [		group add: (line copy			startPoint: (rec origin x + offset) @ title height;			endPoint: (rec corner x - offset) @ title height) ].	group size > 4 ifTrue: [		group add: (line copy			startPoint: (rec origin x + offset) @ (title height + group third height);			endPoint: (rec corner x - offset) @ (title height + group third height)) ]! !!RSBasicUMLClassRenderer methodsFor: 'initialization' prior: 58347462!initialize	super initialize.	popup := RSPopup new model: #yourself.	popup shapeBuilder: (RSAdaptativePopup new		smallBuilder: popup shapeBuilder;		bigBuilder: self;		yourself)! !!RSBasicUMLClassRenderer methodsFor: 'hooks' prior: 58348011!shapeFor: aClass	| shapes box title vars methods |	title := self titleFor: aClass.	vars := self varsFor: aClass.	methods := self methodsFor: aClass.	shapes := self groupFor: { vars. methods }.	shapes addFirst: title.	box := self classBoxShapeFor: aClass.	self applyLayoutOn: shapes.	self adjustTitle: title on: shapes.	self createEllipsisIfNecessaryOn: shapes.	shapes addFirst: box.	self adjustBox: box on: shapes.	self addLines: shapes title: title.	^ RSComposite new		draggable;		addInteraction: popup;		model: aClass;		shapes: shapes;		yourself! !!RSAdaptativePopup methodsFor: 'accessing' prior: 58269416!smallBuilder: aRSSimplePopupBuilder	smallBuilder := aRSSimplePopupBuilder! !!RSAbstractUMLPackageRenderer class methodsFor: 'testing' prior: 58263422!isAbstract	^self name = #RSAbstractUMLPackageRenderer! !!RSAbstractUMLPackageRenderer methodsFor: 'hooks' prior: 58263122!classFor: aClass	| box className |	className := self classNameFor: aClass.	box := self classBoxFor: aClass and: className.	^ RSComposite new		model: aClass;		shapes: { box. className };		popup;		browseable;		yourself! !!RSAbstractUMLPackageRenderer methodsFor: 'hooks' prior: 58262329!classesFor: aPackage	| classes shapes |	classes := modelDescriptor classes rsValue: aPackage.	shapes := classes collect: [ :cls | self classFor: cls ].	RSFlowLayout on: shapes.	^ RSComposite new		shapes: shapes;		yourself! !!RSAbstractUMLPackageRenderer methodsFor: 'accessing' prior: 58262108!defaultLayout	| defaultLayout |	defaultLayout := RSLayoutBuilder new.	defaultLayout vertical		verticalGap: 100;		horizontalGap: 50.	^defaultLayout! !!RSAbstractUMLPackageRenderer methodsFor: 'hooks' prior: 58260591!packageBoxFor: title and: classes	| boxTitle boxClasses rect cradius |	RSVerticalLineLayout new gapSize: 0; on: { title. classes }.	title translateBy: 10@ -5.	rect := classes encompassingRectangle.	cradius := RSCornerRadius new		radius: 5;		yourself.	boxTitle := RSBox new		position: title position;		extent: title extent + 10;		cornerRadius: cradius;		border: self border;		color: self packageColor;		yourself.	boxClasses := RSBox new		position: rect floatCenter;		extent: rect extent+10;		cornerRadius: cradius;		border: self border;		color: self packageColor;		yourself.	^ RSComposite new		addAll: { boxTitle. boxClasses };		yourself! !!RSUMLAbstractModelDescriptor class methodsFor: 'testing' prior: 59472725!isAbstract	^self name = #RSUMLAbstractModelDescriptor! !!RSUMLAbstractModelDescriptor methodsFor: 'public' prior: 59472612!forPharo	self subclassResponsibility! !!RSUMLAbstractModelDescriptor methodsFor: 'initialization' prior: 59472500!initialize	super initialize.	self forPharo! !!RSTorchUMLClassRenderer methodsFor: 'layout' prior: 59448563!applyMLayoutOn: shapes	RSFlowLayout new		gapSize: 2;		maxWidth: self currentMaxWidth;		on: shapes! !!RSTorchUMLClassRenderer methodsFor: 'hooks' prior: 59449604!classNameBoxFor: aClass	^ RSBox new		color: self titleBoxColor;		yourself! !!RSTorchUMLClassRenderer methodsFor: 'hooks' prior: 59448372!methodsFor: aClass	^ (super methodsFor: aClass)		padding: ( Margin		 	left: 0			right: 0			top: 5			bottom: 5);		yourself! !!RSTorchUMLClassRenderer methodsFor: 'hooks' prior: 59449898!shapeFor: aClass	| shapes box title vars methods boxTitle |	title := self titleFor: aClass.	vars := self varsFor: aClass.	methods := self methodsFor: aClass.	shapes := self groupFor: { vars. methods }.	shapes addFirst: title.	box := self classBoxShapeFor: aClass.	boxTitle := self classNameBoxFor: aClass.	self applyLayoutOn: shapes.	self adjustTitle: title on: shapes.	shapes addFirst: boxTitle.	shapes addLast: box.	self adjustBox: box on: shapes.	boxTitle		position: box position x @ title position y ;		extent: (box width @ title height).	^ RSComposite new		popup;		draggable;		model: aClass;		shapes: shapes;		yourself! !!RSTorchUMLClassRenderer methodsFor: 'hooks' prior: 59450925!varFor: model	^ RSShapeFactory triangle		model: model;		popup;		size: 20;		yourself! !!RSAbstractUMLClassRenderer class methodsFor: 'testing' prior: 58260236!isAbstract	^self name = #RSAbstractUMLClassRenderer! !!RSAbstractUMLClassRenderer methodsFor: 'hooks' prior: 58255228!adjustBox: box on: shapes	| rect |	rect := shapes encompassingRectangle.	box		extent: rect extent + self classBoxPadding;		position: rect floatCenter! !!RSAbstractUMLClassRenderer methodsFor: 'hooks' prior: 58255054!adjustTitle: title on: shapes	title position: shapes encompassingRectangle floatCenter x @ title position y! !!RSAbstractUMLClassRenderer methodsFor: 'accessing' prior: 58256447!aggregationShape	| shape |	shape := self compositionShape.	shape markerEnd shape color: Color white.	^ shape! !!RSAbstractUMLClassRenderer methodsFor: 'layout' prior: 58254917!applyLayoutOn: shapes	RSVerticalLineLayout new gapSize: 1.5; on: shapes! !!RSAbstractUMLClassRenderer methodsFor: 'hooks' prior: 58255568!classBoxShapeFor: aClass	^ RSBox new		paint: self boxColor;		border: self boxBorder;		yourself! !!RSAbstractUMLClassRenderer methodsFor: 'accessing' prior: 58258213!compositionShape	| m |	m := RSShapeFactory diamond extent: 10@15.	m border: self border; color: self border color.	m := m asMarker.	m offset: 15 / 2.0.	^ RSLine new		markerEnd: m;		border: self border;		yourself! !!RSAbstractUMLClassRenderer methodsFor: 'hooks' prior: 58257174!createEllipsisIfNecessaryOn: aGroup	| rect ellipsis |	self needsEllipsis ifFalse: [ ^ self ].	ellipsis := self ellipsisShape.	rect := aGroup encompassingRectangle.	ellipsis position: rect bottomCenter + (0@10).	aGroup add: ellipsis! !!RSAbstractUMLClassRenderer methodsFor: 'defaults' prior: 58255947!defaultEdgeBuilder	| offset |	offset := -2.5.	^ RSLineBuilder orthoVertical		attachPoint: (RSVerticalAttachPoint new			startOffset: 11 - offset;			endOffset: offset;			yourself);		border: self border;		markerStart: self marker;		yourself! !!RSAbstractUMLClassRenderer methodsFor: 'defaults' prior: 58258827!defaultLayout	| defaultLayout |	defaultLayout := RSLayoutBuilder new.	defaultLayout tree		verticalGap: 50;		horizontalGap: 50.	^ defaultLayout! !!RSAbstractUMLClassRenderer methodsFor: 'defaults' prior: 58256961!defaultMarker	^ RSMarker new		shape: (RSShapeFactory triangle			color: Color white;			border: self border;			size: 20;			yourself);		yourself! !!RSAbstractUMLClassRenderer methodsFor: 'hooks' prior: 58254630!groupFor: shapes	^ RSGroup streamContents: [ :stream |		shapes do: [ :s | s hasChildren ifTrue: [ stream << s ] ] ]! !!RSAbstractUMLClassRenderer methodsFor: 'accessing' prior: 58254509!marker	^ marker ifNil: [ marker := self defaultMarker ]! !!RSAbstractUMLClassRenderer methodsFor: 'accessing' prior: 58254817!marker: aMarker	marker := aMarker! !!RSAbstractUMLClassRenderer methodsFor: 'hooks' prior: 58257480!methodsFor: model	| shapes methods |	methods := currentClassMethods := modelDescriptor methods rsValue: model.	currentClassMethods size > modelDescriptor methodsLimit		ifTrue: [ methods := currentClassMethods			copyFrom: 1			to: modelDescriptor methodsLimit ].	shapes := methods collect: [ :met | self methodFor: met ].	self applyMLayoutOn: shapes.	^ RSComposite new		shapes: shapes;		yourself! !!RSAbstractUMLClassRenderer methodsFor: 'testing' prior: 58256261!needsEllipsis	^ currentClassMethods isNotNil		and:  [ currentClassMethods size > modelDescriptor methodsLimit ]! !!RSAbstractUMLClassRenderer methodsFor: 'public' prior: 58259251!renderAssociation: aCollection shape: aRSLine	aCollection ifNil: [ ^ self ].	(RSLineBuilder new: aRSLine)		withBorderAttachPoint;		shapes: edgeBuilder fromShapes;		useAssociations: aCollection! !!RSAbstractUMLClassRenderer methodsFor: 'public' prior: 58254243!renderAssociations	self renderAssociation: self modelDescriptor compositions shape: self compositionShape.	self renderAssociation: self modelDescriptor aggregations shape: self aggregationShape! !!RSAbstractUMLClassRenderer methodsFor: 'hooks' prior: 58259514!titleFor: model	| label |	label := RSLabel new		color: self textColor;		text: (modelDescriptor classname rsValue: model);		yourself.	(modelDescriptor isAbstract rsValue: model) ifTrue: [		label italic ].	label fontSize: label fontSize.	^ { label } asGroup asShape padding: 0@ 5; yourself! !!RSAbstractUMLClassRenderer methodsFor: 'hooks' prior: 58256625!varsFor: model	| vars shapes |	vars := modelDescriptor instVars rsValue: model.	shapes := vars collect: [ :m | self varFor: m ].	self applyVLayoutOn: shapes.	^ RSComposite new		shapes: shapes;		padding: (Margin left: 0 right: 0 top: 3  bottom: 8 );		yourself! !!RSUMLClassBuilder methodsFor: 'accessing' prior: 59473240!classes: aColletionOfClasses	classes := aColletionOfClasses! !!RSUMLClassBuilder methodsFor: 'hooks' prior: 59472938!renderIn: aCanvas	super renderIn: aCanvas.	self renderer edgeBuilder		canvas: aCanvas;		shapes: shapes;		connectFrom: modelDescriptor superclass.	self layout on: shapes.	self renderer renderAssociations.	renderer setUpCanvas: aCanvas! !!RSUMLClassDescriptor methodsFor: 'public' prior: 59476355!forPharo	self		classname: #name;		instVars: [:cls | cls instVarNames sorted ];		methods: [ :cls | cls methods sorted: CompiledMethod sortBlock ];		isAbstract: #isAbstract;		superclass: #superclass;		methodSelector: #selector;		instVarSelector: #yourself;		methodsLimit: SmallInteger maxVal! !!RSAbstractUMLRenderer class methodsFor: 'testing' prior: 58265661!isAbstract	^self name = #RSAbstractUMLRenderer! !!RSAbstractUMLRenderer methodsFor: 'accessing' prior: 58263609!border	^ border ifNil: [ border := self defaultBorder ]! !!RSAbstractUMLRenderer methodsFor: 'accessing' prior: 58264024!boxColor	^ boxColor ifNil: [ boxColor := self defaultBoxColor ]! !!RSAbstractUMLRenderer methodsFor: 'defaults' prior: 58264411!defaultBoxBorder	^ RSBorder new		width: 5;		joinMiter;		color: '666EA0';		yourself! !Smalltalk globals removeClassNamed: #AnObsoleteManifestRoassal3UML!"Roassal3-UML"!!RSSunburstAttachPoint class methodsFor: 'public' prior: 59259303!centroid: aRSPieSlice offset: anInteger	| radius angle |	radius := aRSPieSlice innerRadius isZero		ifTrue: [ 0 ]		ifFalse: [ aRSPieSlice middleRadius ].	radius := radius + anInteger.	angle := aRSPieSlice middleAngle degreesToRadians.	^ (angle cos @ (angle sin negated) * radius) + aRSPieSlice position! !!RSLineBuilder class methodsFor: '*Roassal3-Sunburst' prior: 58917734!sunburstBezier	^ self bezier		controlPointsController: RSSunburstCPController new;		yourself! !!RSSunburstExtentLayout methodsFor: 'hook' prior: 59264855!setCenterRadius: shape	shape externalRadius: (self radiusForDepth: 1)! !!RSSunburstExtentLayout methodsFor: 'hook' prior: 59265293!setNormalRadius: shape	| r1 r2 off depth |	depth := shape propertyAt: #depth.	off := self radialSpacing * (depth -1 ).	r1 := (self radiusForDepth: depth -1) + off.	r2 := (self radiusForDepth: depth) + off.	shape		innerRadius: r1;		externalRadius: r2! !!RSAbstractSunburstLayout methodsFor: 'hook' prior: 58241893!doExecute: shapes	| virtual |	shapes isEmpty ifTrue: [ ^  self ].	firstNode := true.	shapes size = 1 ifTrue: [		^ self layoutSunburst: shapes first ].	virtual := RSPieSlice new.	virtual schildren: shapes.	shapes do: [ :shape | shape sparent: virtual ].	virtual sparent: nil.	virtual depth: 0.	self layoutSunburst: virtual.	shapes do: [ :shape | shape sparent: nil ]! !!RSAbstractSunburstLayout methodsFor: 'initialization' prior: 58240429!initialize	super initialize.	self		hasCenter: true;		radialSpacing: 5! !!RSAbstractSunburstLayout methodsFor: 'hook' prior: 58240933!layoutSunburst: shape	self		setRadius: shape;		setChildrenAngles: shape! !!RSAbstractSunburstLayout methodsFor: 'accessing' prior: 58241605!radialSpacing	^ radialSpacing! !!RSAbstractSunburstLayout methodsFor: 'hook' prior: 58241070!setChildrenAngles: shape	| children parentAngle angleOffset parentWeight |	children := shape schildren.	parentAngle := shape alphaAngle.	parentWeight := builder weightOf: shape.	angleOffset := (shape betaAngle - shape alphaAngle) / parentWeight.	children doWithIndex: [ :child :index |		| a b |		a := parentAngle.		b := angleOffset * (builder weightOf: child) + a.		child			alphaAngle: a;			betaAngle: b.		self layoutSunburst: child.		parentAngle := b. ]! !!RSAbstractSunburstLayout methodsFor: 'hook' prior: 58240564!setRadius: shape	firstNode		ifTrue: [			self hasCenter				ifTrue: [ self setCenterRadius: shape ].			shape betaAngle: 360. ]		ifFalse: [ self setNormalRadius: shape ].	firstNode := false! !!RSSunburstBuilder methodsFor: 'initialization' prior: 59260592!initialize	super initialize.	self extentStrategy extent: 500@500.	self leafWeight: 1.	self sliceColor: NSScale category20c.	sliceShape := RSPieSlice new.	maxLevel := 0! !!RSSunburstBuilder methodsFor: 'hooks' prior: 59261362!shapeFor: anObject	| slice |	slice := self sliceShape copy		model: anObject;		yourself.	slice color: (color rsValue: slice).	^ slice! !!RSSunburstConstantWidthLayout methodsFor: 'initialization' prior: 59263553!initialize	super initialize.	self arcWidth: 50.	self centerWidth: 50! !!RSSunburstConstantWidthLayout methodsFor: 'hook' prior: 59263691!setCenterRadius: shape	shape externalRadius: self centerWidth! !!RSSunburstConstantWidthLayout methodsFor: 'hook' prior: 59263913!setNormalRadius: shape	| r1 r2 off depth |	depth := shape propertyAt: #depth.	off := self radialSpacing * (depth-1).	r1 := ((depth - 2) * arcWidth) + off.	r2 := ((depth -1 )* arcWidth ) + off.	shape		innerRadius: r1 + self centerWidth;		externalRadius: r2 + self centerWidth! !!RSSunburstFadeInteraction methodsFor: 'initialization' prior: 59266445!highlightShapesFor: shape	| parents |	parents := self pathFor: shape.	^ builder shapes		reject: [ :s | parents includes: s]! !!RSSunburstFadeInteraction methodsFor: 'initialization' prior: 59266199!initialize	super initialize.	self highlightColor: [ :shape | shape color alpha: 0.15 ]! !!RSSunburstFadeInteraction methodsFor: 'initialization' prior: 59265712!onShape: aShape	aShape		when: RSMouseEnter do: [ :evt |			still := true.			self doHighlight: evt shape.			evt signalUpdate ]		for: self;		when: RSMouseLeave do: [ :evt |			still := false.			evt canvas newAnimation				duration: 300 milliSeconds;				onStepDo: [ :t | evt signalUpdate ];				when: RSAnimationLoopEvent do: [ :e |					still ifFalse: [ self doUnhighlight: evt shape. ].					]				for: self.			evt signalUpdate ]		for: self! !!RSSunburstFadeInteraction methodsFor: 'initialization' prior: 59266646!pathFor: shape	| list current |	list := OrderedCollection new.	current := shape.	[ current notNil ] whileTrue: [		list add: current.		current := current sparent ].	^ list! !!RSObjectWithProperty methodsFor: '*Roassal3-Sunburst'!allSChildren	| allChildren index |	index := 1.	allChildren := OrderedCollection withAll: self schildren.	[ index <= allChildren size ] whileTrue: [		allChildren addAll: ((allChildren at: index) schildren ifNil: [#()]).		index := index + 1 ].	^ allChildren! !!RSObjectWithProperty methodsFor: '*Roassal3-Sunburst' prior: 59005468!schildren: aGroupOfShapes	"children is used by tree builders usefull to relationate hierarchy visualizations"	self propertyAt: #schildren put: aGroupOfShapes.	aGroupOfShapes do: [ :s | s sparent: self ]! !!RSObjectWithProperty methodsFor: '*Roassal3-Sunburst'!withAllSChildren	^ self allSChildren		add: self;		yourself! !!RSSunburstCPController methodsFor: 'hooks' prior: 59262649!controlPointsFor: aLine	| cp1 cp2 cp3 cp4 from to width1 width2 |	from := aLine from.	to := aLine to.	width1 := (from externalRadius - from innerRadius)/2.	from innerRadius isZero ifTrue: [ width1 := 0 ].	cp1 := RSSunburstAttachPoint centroid: from offset: width1 negated.	cp2 := RSSunburstAttachPoint centroid: from offset: width1.	width2 := (to externalRadius - to innerRadius)/2.	cp3 := to centroid: (width1 * 2 + width2) negated.	cp4 := to centroid: width2 negated.	^ Array		with: cp1		with: cp2		with: cp3		with: cp4! !"Roassal3-Sunburst"!!RSFlameGraph methodsFor: 'private' prior: 58665682!doLayout	"Establish the position and extent of each rectangle of the graph."	| virtual roots |	roots := self rootNodes.	roots isEmpty ifTrue: [ ^ self ].	roots size = 1		ifTrue: [			roots first width: graphWidth.			self layoutFlameGraph: roots first ]		ifFalse: [			virtual := self shapeFor: nil.			virtual width: graphWidth.			virtual schildren: roots.			roots do: [ :shape | shape sparent: virtual ].			virtual sparent: nil.			virtual depth: 0.			self layoutFlameGraph: virtual.			roots do: [ :shape | shape sparent: nil ]	 ]! !!RSFlameGraph methodsFor: 'accessing' prior: 58668089!gap: aPoint	"Set the gap between the rectangles.	The x value represents the horizontal gap between siblings.	The y value represents the vertical gap between parents and children."	gap := aPoint! !!RSFlameGraph methodsFor: 'initialization' prior: 58666788!initialize	super initialize.	boxShape := RSBox new.	self		graphWidth: 500;		boxHeight: 20;		gap: 1 asPoint! !!RSFlameGraph methodsFor: 'rendering' prior: 58666283!renderIn: aCanvas	super renderIn: aCanvas.	self doLayout! !!RSFlameGraph methodsFor: 'rendering' prior: 58667104!setupHorizontallyOn: shape	| children parentX parentWidth parentWeight ratio gap2 |	parentX := shape encompassingRectangle origin x.	parentWidth := shape width.	parentWeight := self weightOf: shape.	children := shape schildren.	gap2 := self gap x.	ratio := parentWidth / parentWeight.	children do: [ :child |		| a b |		a := parentX.		b := ratio * (self weightOf: child).		parentX := a + b.		b > gap2 ifTrue: [ b := b - gap2.].		child			position: (a+(b / 2)) @ child position y ;			width: b.		self layoutFlameGraph: child ]! !!RSFlameGraph methodsFor: 'rendering' prior: 58666541!setupVerticallyOn: aShape	| depth y |	depth := aShape propertyAt: #depth.	y := depth * (boxHeight + gap y).	aShape		position: (aShape position x @ y negated);		height: boxHeight! !"Roassal3-FlameGraph"!!RSPieTitleInteraction methodsFor: 'initialization' prior: 59040378!initialize	super initialize.	labelBuilder := RSMultilineLabelBuilder new.	labelBuilder layout alignCenter! !!RSPieTitleInteraction methodsFor: 'hooks' prior: 59040209!onShape: aCanvas	| label |	label := labelBuilder shapeFor: self labelText.	aCanvas add: label! !!RSShowProgressLabelDecorator methodsFor: 'initialization' prior: 59236811!initialize	super initialize.	labelShape := RSLabel new.	highlight := RSHighlightable new.	highlight		highlightColor: [ :shape | shape color adjustBrightness: 0.08 ];		when: RSHighlightEvent do: [ :evt | self updateLabel: evt shape ] for: self;		when: RSUnHighlightEvent do: [ :evt | self updateLabel: nil ] for: self! !!RSShowProgressLabelDecorator methodsFor: 'rendering' prior: 59237189!render	| canvas |	progressLabel := self labelShape copy.	progressLabel text: ''.	canvas := builder container.	canvas add: progressLabel.	builder shapes @ highlight! !!RSRotatedPieLabelDecorator methodsFor: 'rendering' prior: 59143828!createLines	lines := builder objects collect: [ :obj |		RSPolyline new			dashArray: #( 4 );			yourself ]! !!RSRotatedPieLabelDecorator methodsFor: 'rendering' prior: 59142331!render	| container |	self createLabels.	self createLines.	container := self builder container.	container		addAll: lines;		addAll: labels.	builder shapes when: RSMouseClick do: [ animation toggle ] for: self.	self createAnimation.	self stepShapes: 0! !!RSRotatedPieLabelDecorator methodsFor: 'rendering' prior: 59143038!stepShapes: t	builder shapes doWithIndex: [ :shape :index |		  | a b label ang ext x p1 p2 p3 line |		  a := shape propertyAt: #a ifAbsentPut: [ shape alphaAngle ].		  b := shape propertyAt: #b ifAbsentPut: [ shape betaAngle ].		  shape			  alphaAngle: a + t;			  betaAngle: b + t.		  label := labels at: index.		  ang := shape alphaAngle + shape betaAngle / 2 % 360.		  ext := label extent x / 2 @ 0.		  x := -250.		  (ang between: 90 and: 270) ifFalse: [			  ext := ext negated.			  x := x negated ].		  p1 := shape centroid: 0.		  p2 := shape centroid: 50.		  p3 := x @ p2 y.		  line := lines at: index.		  line shape controlPoints: {				  p1.				  p2.				  p3 }.		  label position: p3 - ext ]! !!RSPieLabeledInteraction methodsFor: 'initialization' prior: 59034959!initialize	super initialize.	self labelShape: RSLabel new.	self labelColor: Color black.	offset := 0.	rotated := false! !!RSPieLabeledInteraction methodsFor: 'hooks' prior: 59034731!onShape: aShape	| label parent |	label := self shapeFor: aShape.	aShape propertyAt: self labelKey put: label.	parent := aShape parent.	parent add: label! !!RSPieLabeledInteraction methodsFor: 'accessing' prior: 59036255!rotated	rotated := true! !!RSPie methodsFor: 'accessing - computed' prior: 59031727!alphaAngleFor: aShape	values ifNil: [ self slice: #yourself ].	^ (sumValues at: aShape index) * 360 / totalSum! !!RSPie methodsFor: 'accessing - computed' prior: 59033272!betaAngleFor: aShape	^ ((sumValues at: aShape index) + (values at: aShape index )) * 360 / totalSum! !!RSPie methodsFor: 'initialization' prior: 59032083!initialize	super initialize.	self sliceColor: [ :slice |		slice index even			ifTrue: [ Color lightGray ]			ifFalse: [ Color gray ] ].	sliceShape := RSPieSlice new		segmentSpacing: 0;		cornerRadii: 0;		innerRadius: 0;		externalRadius: 120! !!RSPie methodsFor: 'public' prior: 59033482!slice: aBlockOrASymbol	"Set the way we give a pie share for each element."	| tempSum |	values := objects collect: [:m | aBlockOrASymbol value: m value ] as: Array.	sumValues := Array new: objects size.	tempSum := 0.	values doWithIndex: [ :v :i |		sumValues at: i put: tempSum.		tempSum := tempSum + v		 ].	totalSum := tempSum! !!RSPie methodsFor: 'accessing' prior: 59032684!sliceColor: anObject	"a block or object that can anwser rsValue:"	sliceColor := anObject! !"Roassal3-Pie"!!NSInterpolator methodsFor: '*Roassal3-Inspector'!canvasForInspector	| canvas theme boxes pos rect line cp label loc s | 	canvas := RSCanvas new.	theme := Smalltalk ui theme.	canvas color: theme backgroundColor.	s := NSScale linear domain: #(1 100); range: #(0 420).	boxes := (0 to: 99) collect: [ :i |		RSBox new			size: 40;			x: (s scale: (i / 10) asInteger) * 10 + 64;			y: (s scale: (i % 10) asInteger) * 10 + 64;			color: (theme caretColor alpha: 0.2);			resetBBox;			yourself ] as: RSGroup.	rect := boxes encompassingRectangle.	pos := NSScale linear		domain: { 0@0. 1@1 };		range: { 0 @ rect height. rect width@ 0 }.	line := RSPolyline new		border: (RSBorder new			width: 4;			paint: ((LinearGradientPaint fromArray: {"sweetPeriod"					0->'3f51b1'.					0.13->'5a55ae'.					0.25->'7b5fac'.					0.38->'8f6aae'.					0.50->'a86aa4'.					0.62->'cc6b8e'.					0.75->'f18271'.					0.87->'f3a469'.					1->'f7c978'				})				start: rect bottomLeft;				stop: rect topRight;				yourself)).	canvas addShape: line.	cp := OrderedCollection new.	canvas newAnimation		duration: 5 seconds;		onStepDo: [ :t |			cp add: t.			line controlPoints: (cp collect: [:value |				pos scale: value @ (self interpolate: value) ]).			canvas signalUpdate].	canvas addAll: boxes.	label := [ :text |		RSLabel new			color: theme textColor;			size: 20;			text: text;			yourself ].	canvas addShape: (label value: '1').	loc := RSLocation new outer.	loc top; right;		move: canvas shapes last on: rect.	canvas addShape: (label value: '0').	loc bottom; left;		move: canvas shapes last on: rect.	canvas addShape: (label value: 'Y').	loc top; left;		move: canvas shapes last on: rect.	canvas addShape: (label value: 'X').	loc bottom; right;		move: canvas shapes last on: rect.	canvas @ RSCanvasController.	^ canvas! !!NSInterpolator methodsFor: '*Roassal3-Inspector' prior: 51978055!inspectorCanvas	<inspectorPresentationOrder: 90 title: 'Canvas'>	^ SpRoassal3InspectorPresenter new		canvas: self canvasForInspector;		yourself! !!RSRNode methodsFor: '*Roassal3-Inspector' prior: 59089246!addMenu: canvas	canvas addAll: ((1 to: self height) collect: [ :each |		RSLabel new			color: 'black';			isFixed: true;			model: each;			yourself.		 ]).	RSHorizontalLineLayout on: canvas fixedShapes.	canvas fixedShapes when: RSMouseClick do: [ :evt |		canvas shapes do: [ :node |			(node propertyAt: #level) = evt shape model				ifTrue: [ node					color: (node propertyAt: #originalColor);					border: (RSBorder new color: 'black'). ]				ifFalse: [ node noPaint; noBorder ] ].		canvas signalUpdate		]	for: self! !!RSRNode methodsFor: '*Roassal3-Inspector' prior: 59091437!addWithChildren: canvas	| circle label |	circle := RSEllipse new		size: 20;		color: (self isBalanced			ifTrue: [ Color blue translucent]			ifFalse: [ Color red ]);		yourself.	label := RSLabel new		text: (self isLeaf			ifTrue: [ contents model asString ]			ifFalse: [ '[]' ]);		color: Color black;		yourself.	canvas add: ({ circle. label } asShape		model: self;		popupText: [ :node | node height asString ];		yourself).	self childrenDo: [ :child | child addWithChildren: canvas ]! !!RSRNode methodsFor: '*Roassal3-Inspector' prior: 59092532!addWithChildren: canvas level: level palette: palette	| color |	color := (palette scale: level) alpha: 0.7.	canvas add: (RSBox new		model: self;		fromRectangle: rectangle;		color: color;		propertyAt: #level put: level;		propertyAt: #originalColor put: color;		yourself).	self childrenDo: [ :child | child addWithChildren: canvas level: level + 1 palette: palette ]! !!RSRNode methodsFor: '*Roassal3-Inspector' prior: 59087031!addWithChildren: canvas level: level palette: palette parent: parent	| color box |	color := (palette scale: level) alpha: 0.7.	box := RSBox new		model: self;		fromRectangle: rectangle;		noPaint;		propertyAt: #parent put: parent;		propertyAt: #level put: level;		propertyAt: #originalColor put: color;		yourself.	self isLeaf ifTrue: [ box color: 'black' ].	canvas add: box.	self childrenDo: [ :child |		child			addWithChildren: canvas			level: level + 1			palette: palette			parent: box ]! !!RSRNode methodsFor: '*Roassal3-Inspector' prior: 59095977!asRSCanvasForQueries	| canvas box point log zet |	canvas := self newCanvas.	zet := self. "arc warden"	canvas addAll: (zet collect: [:value |		RSBox new			fromRectangle: (self bbox: value);			color: Color black;			yourself		]).	box := RSBox new		extent: 100@100;		color: ((Color colorFrom: '#3399FF') alpha: 0.2);		border: (RSBorder new color: Color black);		yourself.	point := RSShapeFactory plus.	point size: 10.	point color: Color red.	log := RSComposite new.	log isFixed: true.	log when: RSExtentChangedEvent do: [ :evt |		RSLocation new inner bottom; top; left; offset: 10@10;		move: log on: (0@0 corner: canvas extent) ]	for: self.	canvas addAll: {box. point. log}.	canvas when: RSMouseMove do: [ :evt |		box position: evt position.		point position: evt position.		self updateLog: log rectangle: box encompassingRectangle.		evt signalUpdate.		 ] for: self.	^ canvas! !!RSRNode methodsFor: '*Roassal3-Inspector' prior: 59092190!asRSCanvasTree	| canvas palette |	palette := NSScale category20.	canvas := self newCanvas.	self addWithChildren: canvas.	RSLineBuilder line		withVerticalAttachPoint;		shapes: canvas nodes;		connectToAll: [ :node | node children ].	RSTreeLayout on: canvas nodes.	^ canvas! !!RSRNode methodsFor: '*Roassal3-Inspector' prior: 59088501!asRSCanvasWithParentPath	| canvas palette leafs |	palette := NSScale category20.	canvas := self newCanvas.	self addWithChildren: canvas level: 1 palette: palette parent: nil.	leafs := canvas shapes select: [ :node | node model isLeaf ].	leafs		pushFront;		addInteraction: self parentHighlightable;		addInteraction: (RSPopup text: [:node | | shape parents |			shape := (canvas shapeFromModel: node).			parents := OrderedCollection new.			self parentsFor: shape list: parents.			'Parents size: ' ,parents size asString.			]).	^ canvas! !!RSRNode methodsFor: '*Roassal3-Inspector' prior: 59084787!newCanvas	^ RSCanvas new		addInteraction: RSCanvasController;		in: [ :canvas | canvas inspectorContext interactionsToBeRegistered first noPushFront ];		yourself! !!RSRNode methodsFor: '*Roassal3-Inspector' prior: 59099276!parentHighlightable	^ RSHighlightable new		when: RSHighlightEvent do: [ :evt |			| parents |			parents := OrderedCollection new.			self parentsFor: evt shape list: parents.			parents do: [ :each |				each color: (each propertyAt: #originalColor).				 ].			evt signalUpdate.		] for: self;		when: RSUnHighlightEvent do: [ :evt |			| parents |			parents := OrderedCollection new.			self parentsFor: evt shape list: parents.			parents do: #noPaint.			evt signalUpdate.		] for: self;		yourself! !!RSRNode methodsFor: '*Roassal3-Inspector' prior: 59100275!parentsFor: shape list: list	shape ifNil: [ ^ self ].	shape model isLeaf ifFalse: [ list add: shape ].	self parentsFor: (shape propertyAt: #parent) list: list! !!RSRNode methodsFor: '*Roassal3-Inspector' prior: 59097483!queryResult: aRect	| link node nodesVisited nodesInPointVisited nodesInPoint nodesInRectangle |	nodesInPoint := OrderedCollection new.	nodesInRectangle := OrderedCollection new.	nodesVisited := 0.	link := MetaLink new		arguments: #(context);		selector: #value:;		metaObject: [ :context | nodesVisited := nodesVisited + 1 ];		yourself.	node := (self class >> #nodesWithPoint:list:) ast.	node link: link.	[ self nodesWithPoint: aRect floatCenter list: nodesInPoint] ensure: [ link uninstall ].	nodesInPointVisited := nodesVisited.	nodesVisited := 0.	node := (self class >> #nodesIntersetcsRectangle:list:) ast.	node link: link.	[ self nodesIntersetcsRectangle: aRect list: nodesInRectangle  ] ensure: [ link uninstall ].	^ String streamContents: [ :stream |		stream			<<  'Nodes in point: ';			<< nodesInPoint size asString; cr;			<< 'Queries: ';			<< nodesInPointVisited asString; cr;			<< 'Nodes in rectangle: ';			<< nodesInRectangle size asString; cr;			<< 'Queries: ';			<< nodesVisited asString ]! !!RSRNode methodsFor: '*Roassal3-Inspector' prior: 59085013!updateLog: log rectangle: aRect	| builder |	builder := RSMultilineLabelBuilder new.	builder labelShape color: Color black.	log children do: #remove.	log add: (builder shapeFor: (self queryResult: aRect) ).	log adjustToChildren! !!RSSelectionPresentationInteraction methodsFor: 'hooks' prior: 59174372!addInteractionToCanvas: aShape	| canvas key |	canvas := aShape canvas.	canvas ifNil: [ ^ self ].	key := #canvasInspectorSelection.	(canvas hasProperty: key) ifTrue: [ ^ self ].	canvas when: RSScaleChangedEvent send: #updateShadow: to: self.	canvas when: RSMouseClick send: #removeShadowFromCanvas: to: self.	canvas propertyAt: key put: true! !!RSSelectionPresentationInteraction methodsFor: 'visitor' prior: 59176132!createShadowFor: aShape	^ (aShape		inspectorShadowFor: self padding / (self scaleFrom: aShape)		color: self shadowColor)		model: nil;		propertyAt: self key put: aShape;		yourself! !!RSSelectionPresentationInteraction methodsFor: 'initialization' prior: 59173374!initialize	super initialize.	self padding: 10.	self usePushFront! !!RSSelectionPresentationInteraction methodsFor: 'visitor' prior: 59172043!privateShadowFor: aShape	^ aShape class = RSBitmap ifTrue: [		RSBox new	] ifFalse: [		aShape copy			border: nil;			properties: nil;			yourself ]! !!RSSelectionPresentationInteraction methodsFor: 'hooks' prior: 59175245!putShadowOn: aShape	| shadow |	shadow := self createShadowFor: aShape.	(aShape parent notNil or: [ aShape canvas ]) ifNil: [ ^ self ].	self shouldPushFront ifTrue: [ aShape pushFront ].	aShape parent addShape: shadow before: aShape.	aShape canvas propertyAt: self key put: shadow.	self updateShadowPosition: aShape canvas! !!RSSelectionPresentationInteraction methodsFor: 'hooks' prior: 59173658!removeShadowOn: aShape	"Nothing to do if there is no canvas"	aShape canvas ifNil: [ ^ self ].	aShape canvas		propertyAt: self key		ifPresent: [ :shadow |			shadow remove.			aShape canvas removeKey: self key. ]! !!RSSelectionPresentationInteraction methodsFor: 'hooks' prior: 59175751!selection: evt	"evt can be a RSShape or RSEvent"	| aShape |	aShape := evt shape.	self presentation		ifNotNil: [ self presentation value: (SpWrappedItem new selectedItem: aShape model) ].	self		removeShadowOn: aShape;		putShadowOn: aShape.	aShape canvas		ifNotNil: [ aShape canvas signalUpdate ]! !!RSSelectionPresentationInteraction methodsFor: 'hooks' prior: 59172648!updateShadow: evt	| shadow shape |	(evt canvas hasProperty: self key) ifFalse: [ ^ self ].	shadow := evt canvas propertyAt: self key.	shape := shadow propertyAt: self key.	self		removeShadowOn: shape;		putShadowOn: shape.	evt canvas canvas signalUpdate! !!RSContextInteraction methodsFor: 'initialization' prior: 58554478!initialize	super initialize.	interactions := self defaultInteractions! !!RSInspectableInteraction methodsFor: 'hooks' prior: 58813021!deselectIfNecessary	"Nothing to unselect"	selectedShape ifNil: [ ^ self ].	highlightable doUnhighlight: selectedShape! !!RSInspectableInteraction methodsFor: 'initialization' prior: 58813368!initialize	super initialize.	highlightable := RSHighlightable new! !!RSInspectableInteraction methodsFor: 'hooks' prior: 58813498!inspectShape: aShape	| oldInspectorWindow canvasMorph |	self deselectIfNecessary.	selectedShape := aShape.	highlightable doHighlight: selectedShape.	oldInspectorWindow := inspectorWindow.	inspectorWindow := inspectShapeBlock rsValue: aShape model.	inspectorWindow setLabel: aShape model asString.	canvasMorph := aShape canvas morph.	canvasMorph root activate.	"If there is a previous inspector window, then we use the same position and extent"	oldInspectorWindow ifNil: [ ^ self ].	inspectorWindow		position: oldInspectorWindow position;		extent: oldInspectorWindow extent.	oldInspectorWindow delete.	oldInspectorWindow := nil! !!RSInspectableInteraction methodsFor: 'hooks' prior: 58813205!onShape: aShape	aShape		when: RSMouseLeftClick		do: [ :evt | self inspectShape: aShape ]		for: self! !!RSAbstractContextInteraction methodsFor: 'initialization' prior: 58180455!initialize	super initialize.	self propagateToChildren: true! !!RSAbstractContextInteraction methodsFor: 'hooks' prior: 58179989!onShape: aShape	aShape removeInteractionIfPresent: self class.	self interactionsToBeRegistered do: [ :i |		i presentation: self presentation.		aShape addInteraction: i ].	self propagateToChildren ifFalse: [ ^ self ].	aShape children ifNil: [ ^ self ].	aShape children do: [ :child | child addInteraction: self ].	aShape		when: RSShapeAddedEvent		do: [ :evt | evt shape @ self ]		for: self! !!RSCanvas methodsFor: '*Roassal3-Inspector'!asPresenter	^ SpRoassal3InspectorPresenter new		canvas: self;		yourself! !!RSCanvas methodsFor: '*Roassal3-Inspector' prior: 58418815!inspectorShapes	<inspectorPresentationOrder: 100 title: 'Shapes'>	^ SpTablePresenter new		items: self shapes, self fixedShapes;		addColumn: (SpStringTableColumn			title: 'Shape'			evaluated: [ :each | each asString ] );		addColumn: (SpStringTableColumn			title: 'Model'			evaluated: [ :each | each model asString ] );		addColumn: (SpStringTableColumn			title: 'Paint'			evaluated: [ :each | each paint asString ] );		addColumn: (SpStringTableColumn			title: 'Border'			evaluated: [ :each | each border asString ] )! !!RSChessBackgroundInteraction methodsFor: 'hooks' prior: 58490913!onShape: aCanvas	aCanvas when: RSExtentChangedEvent send: #updateExtent: to: self! !!RSChessBackgroundInteraction methodsFor: 'hooks' prior: 58491965!removeBoxes: evt	evt canvas		propertyAt: self class name		ifPresent: [ :boxes | boxes do: #remove ]! !!RSChessBackgroundInteraction methodsFor: 'hooks' prior: 58491067!updateExtent: evt	| extent side counter even camera canvas boxes color theme |	theme := Smalltalk ui theme.	canvas := evt canvas.	canvas color: theme backgroundColor.	color := theme caretColor alpha: 0.2.	boxes := nil.	extent := canvas extent.	camera := canvas camera.	self removeBoxes: evt.	canvas zoomToFit.	side := 20.	boxes := RSGroup new.	counter := 0.	(side / 2) to: extent x by: 20 do: [ :j |		even := counter even.		(side / 2) to: extent y by: 20 do: [ :k |			| box |			even ifTrue: [				box := RSBox new					color: color;					size: side / camera scale;					position: (camera fromPixelToSpace: j@k).				boxes add: box.				canvas addShape: box.			 ].			even := even not.		].		counter := counter + 1 ].	boxes pushBack.	canvas		propertyAt: self class name		put: boxes.	canvas signalUpdate! !!NSOrdinalScale methodsFor: '*Roassal3-Inspector' prior: 51994752!inspectorColors	<inspectorPresentationOrder: 0 title: 'Colors'>	| canvas |	canvas := RSCanvas new.	canvas addAll: (self range collect: [ :color |		RSEllipse new			model: color;			color: color;			size: 15;			yourself ]).	RSVerticalLineLayout new gapSize: 0; on: canvas nodes.	canvas @ RSCanvasController simple.	^ SpRoassal3InspectorPresenter new		canvas: canvas;		yourself! !!NSOrdinalScale methodsFor: '*Roassal3-Inspector' prior: 51993337!inspectorColorsContext: context	context		evaluator: false;		active: (self range allSatisfy: #isColor)! !!RSAbstractLine methodsFor: '*Roassal3-Inspector' prior: 58207695!inspectorShadowFor: padding color: aColor	^ self copy		properties: nil;		border: (RSBorder new			color: aColor;			width: self border width + padding;			capRound;			joinRound;			yourself);		yourself! !!RSAbstractContainerBuilder methodsFor: '*Roassal3-Inspector'!asPresenter	self build.	^ self container asPresenter! !!SpRoassal3InspectorPresenter methodsFor: 'accessing' prior: 66241446!canvas: aRSCanvas	canvas := aRSCanvas.	roassalMorph morph: canvas createMorph! !!SpRoassal3InspectorPresenter methodsFor: 'enumerating' prior: 66240360!createToolbarIfNecessary	| context interactions |	context := canvas inspectorContext.	interactions := context inspectorInteractions.	interactions ifEmpty: [ ^ self ].	toolBar := SpBoxLayout newLeftToRight.	interactions do: [ :cls | | i |		i := cls new.		i canvas: canvas.		toolBar add: i newButton withConstraints: [ :constraints |			constraints				width: 20;				height: 20 ]  ].	self layout: (SpBoxLayout newTopToBottom		add: toolBar height: 25;		add: #roassalMorph;		yourself)! !!SpRoassal3InspectorPresenter methodsFor: 'initialization' prior: 66241887!initializePresenters	roassalMorph := self newMorph.	toolBar := self newButton.	toolBar label: 'fooo'! !!SpRoassal3InspectorPresenter methodsFor: 'enumerating' prior: 66241018!whenActivatedDo: aBlock	| context |	self createToolbarIfNecessary.	context := canvas inspectorContext.	context presentation: aBlock.	canvas shapes @ context.	canvas		when: RSShapeAddedEvent		do: [ :evt | evt shape @ context ]		for: self! !NSInterpolator removeSelector: #gtCanvasForInspector!"Roassal3-Inspector"!!RSChartStyler commentStamp: '' prior: 0!A chart styler is responsible to styler a chart and its element, in the future it would be connected to css description!!RSKernelDensity commentStamp: '' prior: 0!`RSKernelDensity` is a class that performs calculations related to density distribution plots (`RSDensityPlot`,`RSViolinPlot`) using the **kernel density estimation (KDE) function**.Resources to understand the calculations and concepts related:- https://youtu.be/qc9elACH8LA- https://mathisonian.github.io/kde/**Responsibility:** calculate density distribution of a dataset.**Collaborators:** `RSKernelFunction` represents the Kernel function (by default a Gaussian function) evaluated in the KDE function.**Public API and Key Messages**- `data: aCollection` to create instances passing aCollection (dataset) as argument.- `evaluateKernel: aNumber` to get the kernel function evaluation of aNumber K(x). - `kde: aNumber` to get the corresponding density (probability)  of an x value. (it sum all the kernels applied over the dataset values).  - `densityCurve`: to apply the `kde` function over a "continuos" set of x values and get the y values, for the domain of the dataset passed.**Instance Variables:**  - `data`: aCollection, the dataset for wich the probability density is estimated.- `bandwidth`: a Float that stores the bandwidth used for the kernel function.- `kernel`: a `RSKernelFunction` that calculates the corresponding kernel (a `RSKernelGaussianFunction` by default) and has an `evaluate: aNumber` message.**Example:**```Smalltalk| kernelDensity anXValue data |data := #(14 15 28 27 32 35).kernelDensity := RSKernelDensity data: data.kernelDensity bandwidth: 4.anXValue := 30.self assert: (kernelDensity kde: anXValue) closeTo: 0.0495.```!!RSDensityPlot commentStamp: '' prior: 0!`RSDensityPlot` is a visual representation of the density distribution of a dataset using a kernel density estimation.**Responsibility:** plots the density distribution, provides options to customize the plot.**Collaborators:** the instance variable kernel density is a `RSKernelDensity` object that calculates the points of the density curve.**Public API and Key Messages**- `data: aCollection` to create instances passing aCollection as argument.- `kernelDensity aRSKernelDensity`: to create instances passing a `RSKernelDensity` object with set attributes like, bandwidth, kernel, etc.- `bandwidth: aFloat` to set the bandwith (h) of the kernel in the kernel density estimation function. By `default 1.0`.**Instance Variables:**- `area`: an `RSPolygon` that represents the area under the density curve.- `curvePoints`: an `OrderedCollection` of  `Point`s that store the result of evaluate the Kernel Density Estimation.- `kernelDensity`: a `RSKernelDensity` object that made the calculation of the Kernel Density Estimation, several parametres are passed to this object to personalize the curve (bandwidth, kernel, etc.).- `title`: aString that stores the title of the chart.- `xlabel`:	aString that stores the label of x axis.- `ylabel`: aString that stores the label of y axis.**Example:**```Smalltalk| densityPlot data |data := #(-25 -25 -25 -25 10 20 30 40 50 50 50 50 ).densityPlot := RSDensityPlot data: data.densityPlot bandwidth: 10.densityPlot xlabel: 'X label'; ylabel: 'Y label'; title: 'Density plot (bandwidth:10)'.densityPlot color: Color green.densityPlot open.```!!RSLinePlot commentStamp: '' prior: 58929838!RSLinePlot is a class to create an y vs x plot.!!RSScatterPlot commentStamp: '' prior: 59144427!<keyClass>`RSScatterPlot` is a scatter plot. Shapes are defined using two components, X and Y. *Responsibility*: create shapes that represent a scatter plot.*Collaborators*: used by `RSChart`*Variables*:- `processBlock`: is either `nil` or refer to a one argument block. This block is used to particularize the shapes.*Example*:```Smalltalkx := OrderedCollection new.y := OrderedCollection new.z := OrderedCollection new.r := Random seed: 42.1 to: 100 do: [ :i |	x add: i + (r nextInteger: 10).	y add: i + (r nextInteger: 10).	z add: i + (r nextInteger: 10).].c := RSChart new.p := RSScatterPlot new x: x y: y.p color: Color blue translucent.c addPlot: p. c addDecoration: (RSHorizontalTick new doNotUseNiceLabel asFloat: 3).c addDecoration: RSVerticalTick new.c build.shapes := p ellipses.shapes models: z.RSNormalizer size	shapes: shapes;	from: 2;	to: 10;	normalize: #yourself.RSNormalizer color	shapes: shapes;	normalize: #yourself.c canvas```!!RSKiviat methodsFor: 'accessing' prior: 58831332!addRow: aList	values add: aList! !!RSKiviat methodsFor: 'adding' prior: 58831093!addRows: aCollection	values addAll: aCollection! !!RSKiviat methodsFor: 'accessing' prior: 58833400!axisNames: aCollection	axisNames := aCollection! !!RSKiviat methodsFor: 'accessing - computed' prior: 58832905!computePointsFor: aCollection	| delta current divisor |	divisor := axisNames ifEmpty: [ 1 ] ifNotEmpty: [ axisNames size ].	delta := Float twoPi / divisor.	current := Float halfPi negated.	^ aCollection collectWithIndex: [ :value :index | | indexScale point newRadius |		indexScale := scales scale: index.		newRadius := (indexScale scale: value).		point := current cos @ current sin * newRadius.		current := current + delta.		point ]! !!RSKiviat methodsFor: 'private' prior: 58835706!computeScaleFor: array	| min max |	min := minValue		ifNotNil: [ minValue 	]		ifNil: [ (array ifEmpty: 0 ifNotEmpty: [ values first min ]) min: 0 ].	max := maxValue		ifNotNil: [ maxValue ]		ifNil: [ array ifEmpty: 1 ifNotEmpty: [ values first max ] ].	^ NSScale linear domain: { min. max }; range: { 0. radius }! !!RSKiviat methodsFor: 'private' prior: 58827673!computeScales	scales := NSScale ordinal.	values size = 1 ifTrue: [		scales range: { self computeScaleFor: values first }	] ifFalse: [		scales range: (axisNames collectWithIndex: [ :each :index |			| column |			column := values collect: [ :array | array at: index ].			self computeScaleFor: column.			 ]).	]! !!RSKiviat methodsFor: 'creation' prior: 58828927!createBorderFor: aRSPolygon	^ RSBorder new		color: aRSPolygon color muchDarker;		yourself! !!RSKiviat methodsFor: 'creation' prior: 58827198!createShapePointFor: aPoint in: aRSPolygon	^ RSEllipse new		color: aRSPolygon color muchDarker;		position: aPoint;		size: 10;		yourself! !!RSKiviat methodsFor: 'creation' prior: 58828112!createValuePolygon: array	| polygon points shapePoints |	points := self computePointsFor: array.	polygon := self polygonShape copy		points: points;		color: (palette scale: array);		yourself.	self shouldUsePolygonBorder		ifTrue: [ polygon border: (self createBorderFor: polygon) ].	self shouldUseDots ifTrue: [		shapePoints := points collect: [:point | self createShapePointFor: point in: polygon ].		shapePoints with: array do: [ :s :value | s model: value ].		self shouldUsePolygonFillColor ifFalse: [ polygon noPaint ].		^ ({ polygon }, shapePoints) asShape ].	self shouldUsePolygonFillColor ifFalse: [ polygon noPaint ].	^ polygon! !!RSKiviat methodsFor: 'accessing - defaults' prior: 58828824!defaultContainer	^ RSCanvas new @ RSCanvasController! !!RSKiviat methodsFor: 'defaults' prior: 58830201!defaultPalette	^ NSScale ordinal range: (NSScale category20 range collect: [:color| color translucent ])! !!RSKiviat methodsFor: 'utilities' prior: 58831684!fixLabelPosition: label angle: angle	| positions gap |	label position: angle cos @ angle sin * radius.	gap := self labelGapSize.	positions := Dictionary newFromPairs:		{ 0. 0.5@0.		Float halfPi negated. 0@ -0.5.		Float pi. -0.5@ 0.		Float pi + Float halfPi. 0@ 0.5}.	positions at: angle		ifPresent: [:fix | label translateBy: label extent * fix+ (gap * fix sign) ]		ifAbsent: [			gap := angle cos @ angle sin * gap.			(angle between: Float halfPi negated and: 0)				ifTrue: [ ^ label translateBy: label baseRectangle bottomLeft negated+gap ].			(angle between: 0 and: Float halfPi)				ifTrue: [ ^ label translateBy: label baseRectangle topLeft negated+gap ].			(angle between: Float halfPi and: Float pi)				ifTrue: [ ^ label translateBy: label baseRectangle topRight negated+gap ].			label translateBy: label baseRectangle bottomRight negated + gap ]! !!RSKiviat methodsFor: 'initialization' prior: 58834760!initialize	super initialize.	values := OrderedCollection new.	polygonShape := RSPolygon new.	self		palette: self defaultPalette;		radius: 200;		labelGapSize: 5;		noPolygonBorder;		useEllipse;		usePolygonFillColor;		noDots! !!RSKiviat methodsFor: 'hooks' prior: 58829066!renderAxisIn: aCanvas	| delta current deltaRadius divisor |	divisor := axisNames ifEmpty: [ 1 ] ifNotEmpty: [ axisNames size ].	delta := Float twoPi / divisor.	current := Float halfPi negated.	axis := RSGroup new.	labels := axisNames collect: [ :name | | label |		label := self createAxisName: name.		self fixLabelPosition: label angle: current.		axis add: (self createAxisLine: name angle: current).		current := current + delta.		label ].	deltaRadius := self tickStep. "should we use nice label generator for ticks?"	backgroundShapes := (deltaRadius to: radius by: deltaRadius)		collect: [ :each | shouldUseEllipse			ifTrue: [ self createEllipseFor: each ]			ifFalse: [ self createPolygonFor: each ] ].	aCanvas addAll: backgroundShapes.	backgroundShapes last		color: self backgroundColor; "should I draw rings insteadof one one ellipse"		pushBack.	aCanvas addAll: axis.	aCanvas addAll: labels! !!RSKiviat methodsFor: 'hooks' prior: 58834466!renderValuesIn: aCanvas	self computeScales.	polygonShapes := values collect: [ :array | self createValuePolygon: array ].	aCanvas addAll: polygonShapes! !!RSTopHorizontalTick methodsFor: 'rendering' prior: 59446831!createTickLineFor: aNumber	| value y |	value := xScale scale: aNumber.	y := chart extent y negated.	^ self newLineTick		startPoint: value @ y;		endPoint: value @ (y - self configuration tickSize);		yourself! !!RSChartStyler methodsFor: 'initialization'!initialize	super initialize.	self		textColor: Color black;		tickColor: Color black;		spineColor: Color black! !!RSChartStyler methodsFor: 'accessing'!spineColor	^ spineColor! !!RSChartStyler methodsFor: 'accessing'!spineColor: anObject	spineColor := anObject! !!RSChartStyler methodsFor: 'accessing'!textColor	^ textColor! !!RSChartStyler methodsFor: 'accessing'!textColor: anObject	textColor := anObject! !!RSChartStyler methodsFor: 'accessing'!textFont	^ textFont! !!RSChartStyler methodsFor: 'accessing'!textFont: anObject	textFont := anObject! !!RSChartStyler methodsFor: 'accessing'!textSize	^ textSize! !!RSChartStyler methodsFor: 'accessing'!textSize: anObject	textSize := anObject! !!RSChartStyler methodsFor: 'accessing'!tickColor	^ tickColor! !!RSChartStyler methodsFor: 'accessing'!tickColor: anObject	tickColor := anObject! !!RSKernelDensity class methodsFor: 'instance creation'!bandwidth: aNumber	^ self gaussian bandwidth: aNumber.! !!RSKernelDensity class methodsFor: 'instance creation'!data: aCollection	| kernelDensity |	kernelDensity := self gaussian.	kernelDensity data: aCollection.	^ kernelDensity! !!RSKernelDensity class methodsFor: 'instance creation'!gaussian	| kernelDensity |	kernelDensity := self new.	kernelDensity kernel: RSKernelGaussianFunction new.	^ kernelDensity! !!RSKernelDensity class methodsFor: 'instance creation'!kernel: anRSKernelFunction	| kernelDensity |	kernelDensity := self new.	kernelDensity kernel: anRSKernelFunction. 	^ kernelDensity! !!RSKernelDensity class methodsFor: 'instance creation'!kernel: anRSKernelFunction data: aCollection	| kernelDensity |	kernelDensity := self new.	kernelDensity kernel: anRSKernelFunction.	kernelDensity data: aCollection.	^ kernelDensity! !!RSKernelDensity methodsFor: 'accessing'!bandwidth	^ bandwidth! !!RSKernelDensity methodsFor: 'accessing'!bandwidth: aNumber	bandwidth := aNumber! !!RSKernelDensity methodsFor: 'accessing'!data	^ data.! !!RSKernelDensity methodsFor: 'accessing'!data: aCollection	self assert: (aCollection allSatisfy: [ :each | each isNumber ]) 		description: 'data: should receive only a collection of numbers'.	data := aCollection! !!RSKernelDensity methodsFor: 'accessing'!defaultBandwidth	^ 1.0.! !!RSKernelDensity methodsFor: 'accessing'!defaultKernel	^ RSKernelGaussianFunction new.! !!RSKernelDensity methodsFor: 'rendering'!densityCurve	| curvePoints xi yi maxData minData epsilon step minXDomain maxXDomain maxY |	maxData := data max.	minData := data min.	curvePoints := OrderedCollection new.	epsilon := 0.0001.	step := 0.05.	maxY := 0.		"Calculate left side"	xi := minData.	yi := self kde: xi.	curvePoints add: xi@yi.	maxY := yi max: maxY.	[ yi > epsilon ] whileTrue: [		xi := xi - step.		yi := self kde: xi. 		curvePoints addFirst: xi@yi.		maxY := yi max: maxY.	].	minXDomain := xi.	"Calculate middle"	xi := minData + step.	yi := self kde: xi.	maxY := yi max: maxY.	curvePoints add: xi@yi.	[ xi < maxData ] whileTrue: [		xi := xi + step.		yi := self kde: xi. 		curvePoints add: xi@yi.		maxY := yi max: maxY.	].			"Calculate right side"	[ yi > epsilon ] whileTrue: [		xi := xi + step.		yi := self kde: xi. 		curvePoints add: xi@yi.		maxY := yi max: maxY.	].	maxXDomain := xi.	maxY := yi max: maxY.	^ curvePoints.! !!RSKernelDensity methodsFor: 'accessing'!densityCurveSample: aCollection	^ aCollection collect: [ :value | (self kde: value) ]! !!RSKernelDensity methodsFor: 'accessing'!evaluateKernel: aNumber	^ kernel evaluate: aNumber.! !!RSKernelDensity methodsFor: 'initialization'!initialize	super initialize.	self bandwidth: self defaultBandwidth.	self kernel: self defaultKernel.! !!RSKernelDensity methodsFor: 'accessing'!kde: aNumber	| sum h |	sum := 0.	h := bandwidth.	data 		do: [ :xi |			sum := sum + (self evaluateKernel: ((aNumber - xi)/h))		 ].	^ sum / ((data size) * h)! !!RSKernelDensity methodsFor: 'accessing'!kernel	^ kernel! !!RSKernelDensity methodsFor: 'accessing'!kernel: anRSKernelFunction	self assert: (anRSKernelFunction isKindOf: RSKernelFunction) 		description: 'Error: The argument passed to kernel is not an RSKernelFunction.'.	kernel := anRSKernelFunction! !!RSKernelFunction class methodsFor: 'instance creation'!gaussian	^ RSKernelGaussianFunction new.! !!RSKernelFunction methodsFor: 'accessing'!evaluate: aNumber	^ self subclassResponsibility.! !!RSKernelGaussianFunction methodsFor: 'accessing'!evaluate: aNumber	^ ((0-((aNumber squared)/2))) exp / ((2 * (Float pi)) sqrt).! !!RSTickConfiguration methodsFor: 'public' prior: 59443930!createLabelFor: aValue	^ RSLabel new		fontSize: self fontSize;		text: (self labelConversion rsValue: aValue);		rotateByDegrees: self labelRotation;		yourself! !!RSTickConfiguration methodsFor: 'initialization' prior: 59442962!initialize	super initialize.	self numberOfTicks: 5;		fontSize: RSLabel defaultFontSize;		labelRotation: 0;		shouldHaveLabels: true;		shouldUseNiceLabel: true;		labelConversion: [ :value | value asFloat round: 3 ];		tickSize: 3! !!RSTickConfiguration methodsFor: 'accessing'!updateTickConfiguration: anEvent	| canvas |	canvas := anEvent canvas.	self fontSize: (canvas extent) / (canvas defaultExtent).! !!RSChartExtents methodsFor: 'accessing' prior: 58477557!padding	^ padding ifNil: [ padding := 0@0 ]! !!RSSimpleChartPopupBuilder methodsFor: 'public' prior: 59241736!for: aRSLinePlot color: aColor	self for: aRSLinePlot icon: (RSEllipse new		size: 10;		color: aColor;		yourself)! !!RSSimpleChartPopupBuilder methodsFor: 'public' prior: 59240718!for: aRSLinePlot text: aString color: aColor	self		for: aRSLinePlot text: aString;		for: aRSLinePlot color: aColor! !!RSSimpleChartPopupBuilder methodsFor: 'initialization' prior: 59240909!initialize	super initialize.	labels := Dictionary new.	icons := Dictionary new! !!RSSimpleChartPopupBuilder methodsFor: 'hooks' prior: 59241185!rowShapeFor: aRSLinePlot point: aPoint	| group |	group := RSGroup new.	icons at: aRSLinePlot ifPresent: [ :icon |		group add: icon copy ].	labels at: aRSLinePlot ifPresent: [ :label |		group add: (RSLabel new text: label) ].	group add: (RSLabel new text: aPoint y).	RSHorizontalLineLayout new gapSize: 5; alignMiddle; on: group.	^ group asShape! !!RSAbstractBarPlot methodsFor: 'initialization' prior: 58144004!initialize	super initialize.	self		gapRatio: 0.1;		barOffset: 0! !!RSAbstractBarPlot methodsFor: 'rendering' prior: 58143361!renderIn: canvas	| index |	self checkAssertion.	index := 1.	bars := xValues collect: [ :xt |		| yt bar |		yt := yValues at: index.		bar := self createBarFor: xt@yt index: index.		index := index + 1.		bar ] as: RSGroup.	canvas addAll: bars! !!RSLineChartPopupBuilder methodsFor: 'hooks' prior: 58927091!rowShapeFor: aRSLinePlot	| valuePoint |	valuePoint := self valuePointFor: aRSLinePlot.	valuePoint ifNil: [ ^ nil ].	^ self rowShapeFor: aRSLinePlot point: valuePoint! !!RSLineChartPopupBuilder methodsFor: 'hooks' prior: 58926662!shapeFor: aRSChart	| plots |	plots := aRSChart plots select: #isLinePlot.	plots := plots		collect: [ :plot | self rowShapeFor: plot ]		as: RSGroup.	plots := plots reject: #isNil.	plots ifEmpty: [ ^ RSBox new size: 0 ].	RSVerticalLineLayout new gapSize: 0; on: plots.	^ plots asShape		padding: 10;		color: (Color white alpha: 0.8);		withBorder;		yourself! !!RSChartTitleDecoration methodsFor: 'initialization' prior: 58489885!initialize	super initialize.	self fontSize: 15.		location		offset: 0@ -2;		above; center! !!RSVerticalRightTick methodsFor: 'rendering' prior: 59520671!createTickLineFor: aNumber	| scaledNumber x |	scaledNumber := yScale scale: aNumber.	x := chart extent x.	^ self newLineTick		startPoint: x @ scaledNumber;		endPoint: (x + self configuration tickSize) @ scaledNumber;		yourself! !!RSVerticalRightTick methodsFor: 'rendering'!updateChartMaxAndMinValues: aChart	aChart		minValueY: self ticksData first;		maxValueY: self ticksData last! !!RSBinSizeBinning methodsFor: 'hooks' prior: 58352750!createBinsFor: aCollection	| interval |	interval := aCollection first to: aCollection last by: size.	^ interval last < aCollection last		ifTrue: [ interval , { aCollection last } ]		ifFalse: [ interval ]! !!RSSimpleMarkerPopupBuilder methodsFor: 'hooks' prior: 59242663!shapeFor: aRSChart	| line box x |	line := RSLine new dashArray: #(3).	box := aRSChart spine globalEncompassingRectangle.	x := position x.	line		startPoint: x @ box top;		endPoint: x @ box bottom.	^ line! !!RSDefaultBinning methodsFor: 'initialization' prior: 58579487!initialize	super initialize.	self numberOfBins: self defaultNumberOfBins! !!RSBarPlot methodsFor: 'rendering' prior: 58342386!beforeRenderingIn: aChart	| barScale |	super beforeRenderingIn: aChart.	xScale class = NSOrdinalScale ifTrue: [ ^ self ].	barScale := NSOrdinalScale new		domain: xValues;		rangeBands: xScale range padding: gapRatio.	aChart xScale: barScale! !!RSBarPlot methodsFor: 'accessing' prior: 58341499!bottom: aCollection	self		assert: xValues size = aCollection size		description: 'Invalid size'.	bottom := aCollection! !!RSBarPlot methodsFor: 'hooks' prior: 58341863!computeRectagleFor: aPoint index: index	| origin corner sizeOffset offset zero |	zero := 0.	bottom ifNotNil: [ zero := bottom at: index ].	origin := self scalePoint: aPoint + (0@ zero).	corner := origin x @ (yScale scale: zero ).	sizeOffset := (self barSize / 2.0) @ 0.	offset := self barOffset @ 0.	^ Rectangle		origin: origin + offset - sizeOffset		corner: corner + offset + sizeOffset! !!RSChart methodsFor: 'adding' prior: 58469905!addDecoration: aDecoration	"Add a decoration to the chartFor example:```Smalltalkx := -3.14 to: 3.14 by: 0.1.y := x sin.c := RSChart new.c addPlot: (RSLinePlot new x: x y: y).c addDecoration: (RSHorizontalTick new).c addDecoration: (RSVerticalTick new).c```"	elements add: aDecoration.	aDecoration chart: self.	aDecoration styler: self styler.	^ aDecoration! !!RSChart methodsFor: 'adding' prior: 58476161!addPlot: aPlot	"Add a plot to the chart.For example:```Smalltalkx := -3.14 to: 3.14 by: 0.1.y := x sin.c := RSChart new.c addPlot: (RSLinePlot new x: x y: y).c```	"	elements add: aPlot.	aPlot chart: self.	aPlot styler: self styler.	^ aPlot! !!RSChart methodsFor: 'public - plots' prior: 58470298!barHeights: aCollectionY	| res |	self addPlot: (res := RSBarPlot new		x: (1 to: aCollectionY size)		y: aCollectionY).	^ res! !!RSChart methodsFor: 'public - plots' prior: 58471553!barWidths: aCollectionX	| res |	self addPlot: (res := RSHorizontalBarPlot new		x: aCollectionX		y: (1 to: aCollectionX size)).	^ res! !!RSChart methodsFor: 'color' prior: 58472447!colorFor: aRSPlot	"Return a color for the given plot. Colors are defined as in #defaultPlotColors"	^ colorPalette scale: aRSPlot! !!RSChart methodsFor: 'accessing - defaults' prior: 58467613!defaultContainer	^ RSCanvas new		"when: RSExtentChangedEvent send:#updateChart: to: self;"		addInteraction: (RSCanvasController new			in: [ :controller |				controller zoomToFitInteraction useZoomToFitOnExtentChanged.				controller configuration	maxScale: 20.				 ];			yourself);		yourself! !!RSChart methodsFor: 'initialization'!defaultStyler	^ RSChartStyler new! !!RSChart methodsFor: 'accessing' prior: 58473436!horizontalTick	^ elements detect: [ :element | element isHorizontalTick ] ifNone: [ nil ]! !!RSChart methodsFor: 'initialization' prior: 58475306!initialize	super initialize.	styler := self defaultStyler.	elements := OrderedCollection new.	self extent: 200 @ 200.	self initializeDecorations.	colorPalette := self defaultPlotColors! !!RSChart methodsFor: 'initialization' prior: 58475520!initializeDecorations	self spineDecoration: RSChartSpineDecoration new.	self addDecoration: RSHorizontalTick new.	self addDecoration: RSVerticalTick new! !!RSChart methodsFor: 'inspector' prior: 58471891!inspectorCanvas	<inspectorPresentationOrder: 90 title: 'Canvas'>	self build.	^ SpRoassal3InspectorPresenter new		canvas: self canvas;		yourself! !!RSChart methodsFor: 'inspector' prior: 58468317!inspectorCanvasContext: aContext  aContext withoutEvaluator! !!RSChart methodsFor: 'accessing - extension' prior: 58472639!maxValueX	^ self chartExtents maxValueX		ifNil: [ | res |			self chartExtents maxValueX: (res := (self plots collect: #maxValueX) max).			res ]		ifNotNil: [:res | res ]! !!RSChart methodsFor: 'accessing - extension' prior: 58467117!maxValueY	^ self chartExtents maxValueY		ifNil: [ | res |			self chartExtents maxValueY: (res := (self plots collect: #maxValueY) max).			res ]		ifNotNil: [:res | res ]! !!RSChart methodsFor: 'accessing - extension' prior: 58473588!minValueX	^ self chartExtents minValueX		ifNil: [ | res |			self chartExtents minValueX: (res := (self plots collect: #minValueX) min).			res ]		ifNotNil: [:res | res ]! !!RSChart methodsFor: 'public - configuration' prior: 58469639!mustInclude0inX	"Make sure that the 0 value is in the chart"	((self minValueX to: self maxValueX) includes: 0) ifTrue: [ ^ self ].	self maxValueX > 0		ifTrue: [ self minValueX: 0 ]		ifFalse: [ self maxValueX: 0 ]! !!RSChart methodsFor: 'public - configuration' prior: 58471099!mustInclude0inY	"Make sure that the 0 value is in the chart"	(self minValueY <= 0 and: [ 0 <= self maxValueY ]) ifTrue: [ ^ self ].	self maxValueY > 0		ifTrue: [ self minValueY: 0 ]		ifFalse: [ self maxValueY: 0 ]! !!RSChart methodsFor: 'removing'!removeAllTicks	"Remove both horizontal and vertical ticks"	self removeHorizontalTicks.	self removeVerticalTicks! !!RSChart methodsFor: 'removing'!removeHorizontalTicks	"Remove horizontal ticks from the chart"	elements remove: self horizontalTick! !!RSChart methodsFor: 'removing'!removeVerticalTicks	"Remove vertical ticks from the chart"	elements remove: self verticalTick! !!RSChart methodsFor: 'accessing' prior: 58473905!spineDecoration: aRSChartSpineDecoration	spineDecoration ifNotNil: [		elements remove: spineDecoration.		spineDecoration chart: nil ].	spineDecoration := aRSChartSpineDecoration.	elements addFirst: spineDecoration.	spineDecoration chart: self! !!RSChart methodsFor: 'accessing'!styler	^ styler! !!RSChart methodsFor: 'accessing'!styler: anRSChartStyler	styler := anRSChartStyler.	elements do: [ :each | each styler: styler ]! !!RSChart methodsFor: 'accessing' prior: 58476427!title: aTitle	"Set the title of a chart. For example:```Smalltalkc := RSChart new.c addPlot: (RSLinePlot new x: (1 to: 200) y: (1 to: 200) sqrt).c title: 'Square root'.c```	"	^ self addDecoration: (RSChartTitleDecoration new title: aTitle)! !!RSChart methodsFor: 'accessing - defaults'!updateChart: anEvent	| canvas camera |	camera := anEvent camera.	canvas := anEvent canvas.	self extent: canvas extent.	self update.	canvas zoomToFit.! !!RSChart methodsFor: 'accessing' prior: 58473087!verticalTick	^ elements detect: [ :element | element isVerticalTick ] ifNone: [ nil ]! !!RSChart methodsFor: 'decoration' prior: 58471370!xlabelTop: aTitle	"Set a label on the horizontal top axis"	^ self addDecoration: (RSXLabelDecoration new title: aTitle; above)! !!RSXMarkerDecoration methodsFor: 'public - configuration'!sumUpTo: ratio	self assert: (ratio between: 0 and: 1).	getRelevantValueBlock := [ :aPlot | | total |		total := aPlot definedValuesY sum.		(1 to: aPlot definedValuesY size) detect: [ :i |			(aPlot definedValuesY first: i) sum >= (ratio * total) ] ]! !!RSAbstractMarkerDecoration methodsFor: 'public - shape' prior: 59321258!color: aColor	super color: aColor.	markerColor := aColor! !!RSAbstractMarkerDecoration methodsFor: 'rendering' prior: 58221589!getValueToBeMarkedFromPlot: p	^ getRelevantValueBlock rsValue: p! !!RSAbstractMarkerDecoration methodsFor: 'initialization' prior: 58221259!initialize	super initialize.	"Per default, mark the max value"	self max.	markerColor := self color ifNil: [ self defaultMarkerColor ] ifNotNil: [ self color ]! !!RSAbstractMarkerDecoration methodsFor: 'rendering' prior: 58220849!renderIn: canvas	lines := chart plots collect: [ :p | | line |		line := self createMarkerLineFromPlot: p.		line			dashArray: self defaultDashStyle;			color: markerColor.		self addShape: line.		line	] as: RSGroup! !!RSAbstractTick methodsFor: 'rendering' prior: 58245377!beforeRenderingIn: aChart	self createXScale.	self createYScale.	self updateChartMaxAndMinValues: aChart.	"We need to recalculate the scales because in the above method,	updateChartMaxAndMinValues:, we change the dimensions of the chart. And now we need to	recalculate the scales to be consistent with the dimensions."	self createXScale.	self createYScale! !!RSAbstractTick methodsFor: 'rendering' prior: 58247545!createLabelFor: aValue index: index	"Create a label and returns it."	| tick lbl |	tick := self ticks at: index.	lbl := self configuration createLabelFor: aValue.	lbl color: self styler textColor.	self labelLocation move: lbl on: tick.	^ lbl! !!RSAbstractTick methodsFor: 'accessing - defaults' prior: 58249311!defaultConfiguration	^ RSTickConfiguration new! !!RSAbstractTick methodsFor: 'public' prior: 58243375!doNotUseNiceLabel	self configuration shouldUseNiceLabel: false! !!RSAbstractTick methodsFor: 'accessing' prior: 58242773!fontSize: fontSizeToSet	"Set the font size used by the labels associated to ticks""For example:-=-=-=-=-=-=-=-=-=x := (-10 to: 10).y := x * x.c := RSChart new.d := RSLinePlot new x: x y: y.c addPlot: d.c extent: 400 @ 400.c addDecoration: (RSVerticalTick new fontSize: 20).c addDecoration: (RSHorizontalTick new fontSize: 20).c-=-=-=-=-=-=-=-=-="	self configuration fontSize: fontSizeToSet! !!RSAbstractTick methodsFor: 'public' prior: 58244227!fromNames: aCollectionOfStrings	| size |	size := aCollectionOfStrings size.	self assert: size > 0 description: 'aCollectionOfStrings can not be empty'.	size isZero ifTrue: [ size := 1 ].	self numberOfTicks: size.	self labelConversion: [ :x |		x isZero ifTrue: [ '' ]			ifFalse: [ aCollectionOfStrings at: x asInteger ] ]! !!RSAbstractTick methodsFor: 'public' prior: 58248002!labelConversion: oneArgBlock	"This method is used to convert numerical values into a label. This is useful to particularlize labels on the X or Y axes. The parameter block accepts one argument, which is a numerical value. The block should return a string or any other object. When displayed, the message asString will be sent to it.	For example:-=-=-=-=-=-=-=-=-=x := #(-2 -1 0 1 2).y := #(5 10 12 14 20).c := RSChart new.d := RSLinePlot new x: x y: y.c addPlot: d.c addDecoration: (RSVerticalTick new).c addDecoration: (RSHorizontalTick new							numberOfTicks: x size;							labelConversion: [ :val | Date today addDays: val ] ).c mustInclude0inY.c-=-=-=-=-=-=-=-=-=	"	self configuration labelConversion: oneArgBlock! !!RSAbstractTick methodsFor: 'accessing' prior: 58247864!labelLocation	^ labelLocation ifNil: [ labelLocation := self defaultLabelLocation ]! !!RSAbstractTick methodsFor: 'instance creation'!newLineTick	^ self shape copy		color: self styler tickColor;		yourself! !!RSAbstractTick methodsFor: 'accessing' prior: 58245927!numberOfTicks: aNumber	"Set the number of ticks to be used. Can be used with doNotUseNiceLabels or not.For example:```Smalltalkx := (-3.14 to: 3.14 count: 20).y := x sin.c := RSChart new.d := RSLinePlot new x: x y: y.c addPlot: d.c addDecoration: (RSVerticalTick new).c addDecoration: (RSHorizontalTick new numberOfTicks: 10; asFloat: 2).c```Smalltalk	"	self configuration numberOfTicks: aNumber! !!RSAbstractTick methodsFor: 'rendering' prior: 58246395!renderIn: canvas	| ticksData |	ticksData := self ticksData.	ticks := ticksData collect: [ :value | self createTickLineFor: value ].	canvas addAll: ticks.	self configuration shouldHaveLabels ifFalse: [		labels := #().		 ^ self ].	labels := ticksData collectWithIndex: [ :value :index |		self createLabelFor: value index: index ].	canvas addAll: labels! !!RSAbstractTick methodsFor: 'public'!scaleToUse	^ self isHorizontalTick		ifTrue: [ xScale ]		ifFalse: [ yScale ]! !!RSAbstractTick methodsFor: 'public' prior: 58248991!ticksData	| scaleToUse |	scaleToUse := self scaleToUse.	^ self configuration shouldUseNiceLabel		ifTrue: [ scaleToUse niceTicks: self configuration numberOfTicks ]		ifFalse: [ scaleToUse ticks: self configuration numberOfTicks ]! !!RSAbstractTick methodsFor: 'rendering'!updateChartMaxAndMinValues: aChart	self subclassResponsibility! !!RSAbstractTick methodsFor: 'public' prior: 58247014!useNiceLabel	self configuration shouldUseNiceLabel: true! !!RSHorizontalTick methodsFor: 'rendering' prior: 58774177!createTickLineFor: aNumber	| value zeroY |	value := xScale scale: aNumber.	zeroY := chart spineDecoration zeroPoint y.	zeroY := zeroY - chart extent y.	^ self newLineTick		startPoint: value @ zeroY;		endPoint: value @ (zeroY + self configuration tickSize);		yourself! !!RSHorizontalTick methodsFor: 'rendering'!updateChartMaxAndMinValues: aChart	aChart		minValueX: self ticksData first;		maxValueX: self ticksData last! !!RSHorizontalTick methodsFor: 'public' prior: 58774585!useDiagonalLabel	self labelRotation: -45.	self labelLocation outer; bottom; left; offset: (self configuration fontSize * 0.5 @ 0)! !!RSHorizontalTick methodsFor: 'public' prior: 58775057!useVerticalLabel	self labelRotation: -90! !!RSYLabelDecoration methodsFor: 'accessing' prior: 59539526!left	self location		offset: -5 @ 0;		left;		outer;		middle! !!RSYLabelDecoration methodsFor: 'accessing' prior: 59539280!right	self location		offset: 5 @ 0;		right;		outer;		middle! !!RSChartPopupDecoration methodsFor: 'initialization' prior: 58478492!initialize	super initialize.	"this composite is created once when the mouse enter into the box shape"	self shapeBuilder: [ :obj | RSComposite new ]! !!RSChartPopupDecoration methodsFor: 'hooks' prior: 58478881!releasePopup: popup	popup remove.	chart container propertyAt: #popupMarkers ifPresent: [ :old | old remove ]! !!RSChartPopupDecoration methodsFor: 'hooks' prior: 58479487!translatePopup: popup event: evt	self		updatePopup: popup event: evt;		updateMarkers: evt.	super translatePopup: popup event: evt! !!RSChartPopupDecoration methodsFor: 'hooks' prior: 58479889!updatePopup: popup event: evt	"we recreate the popup content each time, since the popup should show the nodes change"	| builder rect |	popup children do: #remove. "we recreate the popup content each time, since the popup should show the nodes change"	builder := self chartPopupBuilder.	rect := evt shape globalEncompassingRectangle.	builder position: evt position - rect origin.	popup addShape: (builder shapeFor: self chart).	popup adjustToChildren! !!SequenceableCollection methodsFor: '*Roassal3-Chart' prior: 62018416!rsHistogram	| c plot |	c := RSChart new.	plot := RSHistogramPlot new x: self.	c addPlot: plot.	^ c! !!RSHorizontalBarPlot methodsFor: 'rendering' prior: 58768688!beforeRenderingIn: aChart	| barScale |	super beforeRenderingIn: aChart.	yScale class = NSOrdinalScale ifTrue: [ ^ self ].	barScale := NSOrdinalScale new		domain: yValues;		rangeBands: yScale range padding: gapRatio.	aChart yScale: barScale! !!RSHorizontalBarPlot methodsFor: 'hooks' prior: 58768082!computeRectagleFor: aPoint index: index	| origin corner sizeOffset offset zero |	zero := 0.	left ifNotNil: [ zero := left at: index ].	origin := self scalePoint: aPoint+(zero@0) .	corner := (xScale scale: zero) @ origin y.	sizeOffset := 0@(self barSize/ 2.0).	offset := 0@self barOffset.	^ Rectangle		origin: origin + offset - sizeOffset		corner: corner + offset + sizeOffset! !!RSHorizontalBarPlot methodsFor: 'accessing' prior: 58767907!left: aCollection	self		assert: yValues size = aCollection size		description: 'Invalid size'.	left := aCollection! !!RSZoomTickDecoration methodsFor: 'accessing' prior: 59541743!boxScale	| spine |	spine := chart spine encompassingRectangle.	^ NSScale linear		domain: { spine origin. spine corner };		range: { visibleRectangle origin. visibleRectangle corner}! !!RSZoomTickDecoration methodsFor: 'accessing' prior: 59543572!computeVisibleRectangle: eventRectangle	| rect spine scale |	"spine the the chart box"	spine := chart spine encompassingRectangle.	rect := (eventRectangle origin max: spine origin)		corner: (eventRectangle corner min: spine corner).	scale := self boxScale.	^ (scale scale: rect origin) corner: (scale scale: rect corner)! !!RSZoomTickDecoration methodsFor: 'rendering' prior: 59541108!renderIn: canvas	canvas addInteraction: self elasticBox.	resetLabel := self createResetLabel.	canvas add: resetLabel.	currentShapes := #().	self resetZoom: canvas! !!RSZoomTickDecoration methodsFor: 'rendering' prior: 59545248!renderPlots	| visibleShapes scale |	visibleShapes := chart plots flatCollect: [ :plot | plot createdShapes		select: [ :s | s encompassingRectangle intersects: visibleRectangle ] ].	scale := chart spine extent/visibleRectangle extent.	"I use a composite shape because the composite can scale the selected shapes,	but more important we can clip the selected shapes"	visibleShapes := RSComposite new		fromRectangle: visibleRectangle;		clipChildren: true;		addAll: (visibleShapes collect: [:s | | copy |			"it is necessary to create a copy of the current shape because we will modify its position"			copy := s copy.			copy matrix: s matrix copy.			copy translateBy: visibleRectangle floatCenter negated.			copy ]);		scaleBy: scale;		translateBy: chart spine encompassingRectangle floatCenter - visibleRectangle floatCenter;		yourself.	currentShapes add: visibleShapes! !!RSZoomTickDecoration methodsFor: 'rendering' prior: 59543371!renderPlotsAndTicksIn: canvas	currentShapes := OrderedCollection new.	self renderPlots.	self renderTicks.	canvas addAll: currentShapes! !!RSZoomTickDecoration methodsFor: 'rendering' prior: 59541632!renderTicks	self renderYAxis.	self renderXAxis! !!RSZoomTickDecoration methodsFor: 'rendering' prior: 59542621!renderXAxis	| horizontalTick tickShapes newChart scale |	horizontalTick := chart horizontalTick.	horizontalTick ifNil: [ ^ self ].	"should be a copy to not lose created shapes from original horizontal tick"	scale := horizontalTick xScale.	"scale inspect."	newChart := RSChart new chartExtents: chart chartExtents.	newChart		minValueX: (scale invert: visibleRectangle origin x);		maxValueX: (scale invert: visibleRectangle corner x).	horizontalTick := horizontalTick copy.	horizontalTick xScale: nil.	horizontalTick chart: newChart.	tickShapes := RSGroup new.	horizontalTick		beforeRenderingIn: newChart;		renderIn: tickShapes.	currentShapes addAll: tickShapes! !!RSZoomTickDecoration methodsFor: 'rendering' prior: 59541991!renderYAxis	| verticalTick tickShapes ymin ymax scale |	verticalTick := chart verticalTick.	verticalTick ifNil: [ ^ self ].	ymin := visibleRectangle origin y.	ymax := visibleRectangle corner y.	tickShapes := verticalTick createdShapes		select: [ :s |s position y between: ymin and: ymax ]		thenCollect: [:s | | copy |			copy := s copy.			s isLine ifFalse: [ copy matrix: s matrix copy ].			copy ].	scale := self boxScale.	tickShapes do: [ :each | each translateTo: each position x @ (scale invert: each position) y ].	currentShapes addAll: tickShapes! !!RSZoomTickDecoration methodsFor: 'events' prior: 59544435!resetZoom: evt	| canvas |	canvas := evt canvas.	visibleRectangle := self chart spine encompassingRectangle.	currentShapes do: #remove.	currentShapes := self chartElements flatCollect: [ :element | element createdShapes ].	canvas addAll: currentShapes.	resetLabel pushFront.	evt signalUpdate! !!RSZoomTickDecoration methodsFor: 'events' prior: 59546190!updateSelection: evt	visibleRectangle := self computeVisibleRectangle: evt shape encompassingRectangle.	currentShapes do: #remove.	self renderPlotsAndTicksIn: evt canvas.	resetLabel pushFront! !!RSBoxPlot methodsFor: 'accessing' prior: 58389279!barScale	^ xScale! !!RSBoxPlot methodsFor: 'rendering' prior: 58395572!beforeRenderingIn: aChart	| barScale |	super beforeRenderingIn: aChart.	xScale class = NSOrdinalScale ifTrue: [ ^ self ].	barScale := NSOrdinalScale new		domain: xValues;		rangeBands: xScale range padding: gapRatio.	aChart xScale: barScale! !!RSBoxPlot methodsFor: 'private' prior: 58393216!computeBoxAndWhiskerExtent: aCollection	"Converts a 2D collection of data points into the poisition of the 1 and 3 quartile, the whiskers, and outlieing points.	Returns an array with the following:	1. An array of the lower outlying data	2. The y value of the bottom whisker	3. The y value of the bottom of the box	4. The y value of the median	5. The y value of the top of the box	6. The y value of the top whisker	7. An array of the upper outlying data	"	boxAndWhisker := aCollection collect: [ :i |		|iSort quartile1 quartile3 minVal maxVal bottomWhiskerExtent topWhiskerExtent iqr bottomOutliers topOutliers |		iSort := i asSortedCollection .		minVal := iSort min.		maxVal := iSort max.		quartile1 := self quantile: 0.25 for: iSort.		quartile3 := self quantile: 0.75 for: iSort.		iqr := quartile3 - quartile1 .		bottomWhiskerExtent := quartile1 - (iqr * 1.5).		bottomWhiskerExtent <= minVal			ifTrue: [ bottomWhiskerExtent := minVal. bottomOutliers := Array new ]			ifFalse: [ bottomOutliers := i select: [ :j | j < bottomWhiskerExtent  ] ].		topWhiskerExtent := quartile3 + (iqr * 1.5).		topWhiskerExtent >= maxVal			ifTrue: [ topWhiskerExtent := maxVal. topOutliers := Array new ]			ifFalse: [ topOutliers := i select: [ :j | j > topWhiskerExtent  ] ].		{ bottomOutliers . bottomWhiskerExtent . quartile1. iSort median. quartile3. topWhiskerExtent . topOutliers  }	]! !!RSBoxPlot methodsFor: 'rendering' prior: 58394924!computeOutliersFor: points at: xValue	"Translates a collection of points to the plot coordinates and returns a collection of RSEllipse"	"xValue has already been converted into the xscale but points are still in the original data scale"	^points collect: [ :i |		| newPoint |		newPoint := xValue @ (yScale scale: i).		RSEllipse new				radius: 2;				color: self computeColor;				translateTo: newPoint .	]! !!RSBoxPlot methodsFor: 'rendering' prior: 58389349!computeRectagleAndLinesFor: index   "Convert the box and whisker extents to their positions in the plot using the scale"	| lowerOutliers upperOutliers boxAndWhis origin sizeOffset offset zero aPoint topLeft bottomRight bottomWhiskerExtent topWhiskerExtent corner center |	boxAndWhis := boxAndWhisker at: index.	aPoint := (xValues at: index) @ (boxAndWhis at: 5).	zero := boxAndWhis at: 3.	"origin is the top left of the rectangle"	origin := self scalePoint: aPoint.	corner := origin x @ (yScale scale: zero ).	sizeOffset := (self barSize / 2.0) @ 0.	offset := self barOffset @ 0.	topLeft := origin + offset - sizeOffset.	bottomRight := corner + offset + sizeOffset.	center := (topLeft x + bottomRight x) / 2.	"These are a collection of RSEllipse for the outlying points of the dataset"	lowerOutliers := self computeOutliersFor: (boxAndWhis at: 1) at: center.	upperOutliers := self computeOutliersFor: (boxAndWhis at: 7) at: center.	bottomWhiskerExtent := center @ (yScale scale: (boxAndWhis at: 2)).	topWhiskerExtent := center @ (yScale scale: (boxAndWhis at: 6)).	^{ 	self shape copy		model: (self modelFor: aPoint);		color: self computeColor;		fromRectangle: (Rectangle origin: topLeft corner: bottomRight );		yourself.		RSLine new			startPoint: (topLeft x  @ (yScale scale: (boxAndWhis at: 4)));			endPoint: (bottomRight x @(yScale scale: (boxAndWhis at: 4))).		RSLine new			startPoint: center @ corner y;			endPoint: bottomWhiskerExtent .		RSLine new			startPoint: center @ origin y;			endPoint: topWhiskerExtent},		lowerOutliers,		upperOutliers! !!RSBoxPlot methodsFor: 'rendering' prior: 58391130!definedValuesY	"Return the list Y values that are defined"	| res |	res := yValues flatCollect: [ :i | i].	^ res, {0}! !!RSBoxPlot methodsFor: 'initialization' prior: 58391606!initialize	super initialize.	self		gapRatio: 0.1;		barOffset: 0! !!RSBoxPlot methodsFor: 'math functions' prior: 58391730!quantile: aProbability for: aSortedCollection	"returns the expected quantile only, if I use my standard initialization method"	^ self quantile: aProbability for: aSortedCollection withProbs: self modeBased! !!RSBoxPlot methodsFor: 'math functions' prior: 58391995!quantile: aProbability for: aSortedCollection withProbs: anArray	| a b c d p f |	a := anArray at: 1.	b := anArray at: 2.	c := anArray at: 3.	d := anArray at: 4.	p := (aSortedCollection size + b) * aProbability + a.	p := p < 1		ifTrue: [ 1 ]		ifFalse: [ p min: aSortedCollection size ].	^ p truncated = p		ifTrue: [ aSortedCollection at: p asInteger ]		ifFalse: [ (f := aSortedCollection at: p floor)				+ (((aSortedCollection at: p ceiling) - f) * (p fractionPart * d + c)) ]! !!RSBoxPlot methodsFor: 'rendering' prior: 58392536!renderIn: canvas	| index |	self checkAssertion.	index := 1.	bars := xValues flatCollect: [ :xt |		| bar |		bar := self computeRectagleAndLinesFor: index.		index := index + 1.		bar ] as: RSGroup.	canvas addAll: bars! !!RSBoxPlot methodsFor: 'public' prior: 58392947!x: aCollection y: aCollection2	xValues := aCollection.	yValues := aCollection2.	self computeBoxAndWhiskerExtent: aCollection2! !!RSTimeLinePlot methodsFor: 'accessing' prior: 59446310!bars	^ bars! !!RSTimeLinePlot methodsFor: 'rendering' prior: 59446379!beforeRenderingIn: aChart	| barScale |	super beforeRenderingIn: aChart.	yScale class = NSOrdinalScale ifTrue: [ ^ self ].	barScale := NSOrdinalScale new		domain: (aChart minValueY to: aChart maxValueY);		rangeBands: yScale range padding: gapRatio.	aChart yScale: barScale! !!RSTimeLinePlot methodsFor: 'accessing' prior: 59445882!entries: aCollection at: aNumber	"example:	self entries: { 0 2 4 8}.	"	self		assert: aCollection size even		description: 'You only can use collection of even sizes'.	self		x: aCollection		y: (Array new: aCollection size withAll: aNumber)! !!RSTimeLinePlot methodsFor: 'initialization' prior: 59445464!initialize	super initialize.	self gapRatio: 0.1! !!RSTimeLinePlot methodsFor: 'rendering' prior: 59444563!renderIn: canvas	bars := RSGroup new.	1 to: xValues size by: 2 do: [ :index |		| x1 y1 x2 y2 origin corner rectangle sizeOffset |		x1 := xValues at: index.		y1 := yValues at: index.		x2 := xValues at: index+1.		y2 := yValues at: index+1.		origin := self scalePoint: x1 @ y1.		corner := self scalePoint: x2 @ y2.		sizeOffset := 0@ self barSize / 2.0.		rectangle := Rectangle			origin: origin-sizeOffset			corner: corner+sizeOffset.		bars add: (self shape copy			model: (x1 -> x2);			color: self computeColor;			fromRectangle: rectangle;			yourself)		].	canvas addAll: bars! !!RSAbstractPlot methodsFor: 'adding' prior: 58224615!addedIn: aRSChart	aRSChart addPlot: self! !!RSAbstractPlot methodsFor: 'public' prior: 58225077!computeColor	"Return the color used by the chart element. The color is computed from the chart and from the colorBlock variable"	^ self color ifNil: [ chart colorFor: self ]! !!RSAbstractPlot methodsFor: 'accessing'!x	^ xValues! !!RSAbstractPlot methodsFor: 'accessing'!y	^ yValues! !!RSAbstractPlot methodsFor: 'public' prior: 58226955!y: aCollection	"Define a plot with only a Y coordinate. The X coordinate is the index of the data point.	For example:-=-=-=-=-=-=-=-=-=x := (-3.14 to: 3.14 by: 0.01).c := RSChart new.p := RSLinePlot new.p y: x sin * 0.22.c addPlot: p.p := RSLinePlot new.p y: x cos * 0.18.c addPlot: p.c addDecoration: RSHorizontalTick new.c addDecoration: (RSVerticalTick new asFloat).c-=-=-=-=-=-=-=-=-=	"	self x: (1 to: aCollection size) y: aCollection! !!RSDensityPlot class methodsFor: 'accessing'!data: aCollection	| densityPlot |	densityPlot := self new.	densityPlot data: aCollection.	^ densityPlot! !!RSDensityPlot class methodsFor: 'examples'!exampleBasicDensityPlot	| densityPlot data |	data := #(14 15 28 27 32 35).	densityPlot := self data: data.	densityPlot bandwidth: 4.	^ densityPlot open.! !!RSDensityPlot class methodsFor: 'examples'!exampleBasicDensityPlot2	| densityPlot data |	data := #(5 5 5 45 45 45).	densityPlot := self data: data.	densityPlot bandwidth: 4.	^ densityPlot open.! !!RSDensityPlot class methodsFor: 'examples'!exampleBasicDensityPlot3	| densityPlot data |	data := #(10 10 10 10).	densityPlot := self data: data.	densityPlot bandwidth: 4.	^ densityPlot open.! !!RSDensityPlot class methodsFor: 'examples'!exampleBasicDensityPlot4	| densityPlot data |	data := #(-25 -25 -25 -25 10 20 30 40 50 50 50 50 ).	densityPlot := self data: data.	densityPlot bandwidth: 10.	^ densityPlot open.! !!RSDensityPlot class methodsFor: 'examples'!exampleDensityPlotCreateWithKernelDesity	| densityPlot data kernelDensity |	data := #(-25 -25 -25 -25 10 20 30 40 50 50 50 50 ).	kernelDensity := RSKernelDensity data: data.	kernelDensity bandwidth: 10.	densityPlot := self kernelDensity: kernelDensity.	densityPlot shape		color: Color blue translucent;		border: (RSBorder new 			color: Color red; 			width: 2;			dashArray: #(2 4)).	^ densityPlot open.! !!RSDensityPlot class methodsFor: 'examples'!exampleDensityPlotWithLabels	| densityPlot data |	data := #(-25 -25 -25 -25 10 20 30 40 50 50 50 50 ).	densityPlot := self data: data.	densityPlot bandwidth: 10.	densityPlot xlabel: 'X label'; ylabel: 'Y label'; title: 'Density plot (bandwidth:10)'.	^ densityPlot open.! !!RSDensityPlot class methodsFor: 'accessing'!kernelDensity: anRSKernelDensity	| densityPlot |	densityPlot := self new.	densityPlot kernelDensity: anRSKernelDensity.	^ densityPlot! !!RSDensityPlot methodsFor: 'accessing'!area	^ area! !!RSDensityPlot methodsFor: 'accessing'!areaColor	^ self computeColor.! !!RSDensityPlot methodsFor: 'accessing'!bandwidth	^ kernelDensity bandwidth.	! !!RSDensityPlot methodsFor: 'accessing'!bandwidth: aNumber	kernelDensity bandwidth: aNumber.	self computeCurvePoints.	! !!RSDensityPlot methodsFor: 'private'!computeCurvePoints	| ys yMax |	curvePoints := kernelDensity densityCurve.	xValues := { curvePoints first x. curvePoints last x. }.	ys := curvePoints collect: [ :point | point y ].	yMax := ys max.	yValues := {0. yMax. }.! !!RSDensityPlot methodsFor: 'accessing'!createdShapes	^ { area }! !!RSDensityPlot methodsFor: 'accessing'!data	^ kernelDensity data.! !!RSDensityPlot methodsFor: 'accessing'!data: aCollection	kernelDensity data: aCollection.	self computeCurvePoints.! !!RSDensityPlot methodsFor: 'defaults'!defaultAreaColor	^ area color.	! !!RSDensityPlot methodsFor: 'defaults'!defaultKernelDensity	^ RSKernelDensity new.! !!RSDensityPlot methodsFor: 'defaults'!defaultLineColor	^ Color r:117 g:107 b:177 range: 255.! !!RSDensityPlot methodsFor: 'initialization'!defaultShape 	^ RSPolygon new		noPaint.! !!RSDensityPlot methodsFor: 'initialization'!initialize	super initialize.	kernelDensity := self defaultKernelDensity.! !!RSDensityPlot methodsFor: 'accessing'!kde: aNumber	^ kernelDensity kde: aNumber.! !!RSDensityPlot methodsFor: 'accessing'!kernel	^ kernelDensity kernel.! !!RSDensityPlot methodsFor: 'accessing'!kernel: anRSKernelFunction	kernelDensity kernel: anRSKernelFunction.	self computeCurvePoints.! !!RSDensityPlot methodsFor: 'accessing'!kernelDensity	^ kernelDensity.! !!RSDensityPlot methodsFor: 'accessing'!kernelDensity: anRSKernelDensity	kernelDensity := anRSKernelDensity.	self computeCurvePoints.! !!RSDensityPlot methodsFor: 'opening'!open	chart := RSChart new.	chart add: self.	chart		extent: 250 @ 200;		add: RSHorizontalTick new;		add: RSVerticalTick new;		ylabel: self ylabel;		xlabel: self xlabel;		title: self title.	^ chart open! !!RSDensityPlot methodsFor: 'rendering'!renderIn: canvas	| curve firstPoint lastPoint closingPointStart closingPointEnd |	area := self shape copy.	area color: self computeColor.	firstPoint := curvePoints first.	lastPoint := curvePoints last.	closingPointStart := firstPoint x @ 0.	closingPointEnd := lastPoint x @ 0.	curve := curvePoints copy.	curve addFirst: closingPointStart.	curve add: closingPointEnd.	lastPoint := curve last.	area points: (curve collect: [ :aPoint | self scalePoint: aPoint ]).	canvas add: area.! !!RSDensityPlot methodsFor: 'accessing'!title	^ title.! !!RSDensityPlot methodsFor: 'accessing'!title: aString	title := aString.! !!RSDensityPlot methodsFor: 'accessing'!xlabel	^ xlabel! !!RSDensityPlot methodsFor: 'accessing'!xlabel: aString	xlabel := aString! !!RSDensityPlot methodsFor: 'accessing'!ylabel	^ ylabel! !!RSDensityPlot methodsFor: 'accessing'!ylabel: aString	ylabel := aString! !!RSLinePlot class methodsFor: 'instance creation'!example1	| p |	p := (self y: #(1 2 3 4)) format: 'or--'.	^ p open.! !!RSLinePlot class methodsFor: 'instance creation'!y: aCollection	| linePlot |	linePlot := self new.	linePlot y: aCollection.	^ linePlot! !!RSLinePlot methodsFor: 'building'!buildChart	| chartPlot |	chartPlot := RSChart new.	chartPlot add: self.	chartPlot		ylabel: self ylabel;		xlabel: self xlabel;		extent: 250 @ 200;		padding: 15 @ 10.	^ chartPlot! !!RSLinePlot methodsFor: 'initialization' prior: 58931377!defaultShape	^ RSPolyline new color: nil! !!RSLinePlot methodsFor: 'constants'!marker	^ self shape markers at: 1! !!RSLinePlot methodsFor: 'instance creation'!open	^ self buildChart open! !!RSLinePlot methodsFor: 'rendering' prior: 58931789!renderIn: canvas	| controlPoints |	self checkAssertion.	controlPoints := OrderedCollection new.	(1 to: xValues size) do: [ :i |			| xt yt |			xt := xValues at: i.			yt := yValues at: i.			(self isPointWellDefined: xt @ yt)				ifTrue: [ controlPoints add: (self scalePoint: xt @ yt) ] ].	canvas add: (line := self shape copy		color: self computeColor;		controlPoints: controlPoints;		yourself)! !!RSLinePlot methodsFor: 'accessing'!xlabel	^ xlabel! !!RSLinePlot methodsFor: 'decoration'!xlabel: aString	xlabel := aString! !!RSLinePlot methodsFor: 'accessing'!ylabel	^ ylabel! !!RSLinePlot methodsFor: 'decoration'!ylabel: aString	ylabel := aString! !!RSScatterPlot methodsFor: 'rendering' prior: 59145478!renderIn: canvas	| newPoint color |	color := self computeColor.	self checkAssertion.	ellipses := (1 to: xValues size)		collect: [ :notUsed |			self shape copy				radius: 2;				color: color ] as: RSGroup.	xValues doWithIndex: [ :xt :i |		| yt et |		et := ellipses at: i.		yt := yValues at: i.		newPoint := self scalePoint: xt @ yt.		(self isPointWellDefined: newPoint)			ifTrue: [				et model: xt @ yt.				et translateTo: newPoint.				canvas add: et ] ]! !!RSXLabelDecoration methodsFor: 'public - positioning shorcuts' prior: 59537229!above	self location		offset: 0@ -5;		above;		center! !!RSXLabelDecoration methodsFor: 'public - positioning shorcuts' prior: 59536988!below	self location		offset: 0@5;		below;		center! !!RSXLabelDecoration methodsFor: 'initialization' prior: 59537107!initialize	super initialize.	self below! !!RSPopupDecoration methodsFor: 'initialization' prior: 59054854!initialize	super initialize.	popup := RSChartPopupDecoration new		chartPopupBuilder: RSSimpleChartPopupBuilder new;		markersPopupBuilder: RSSimpleMarkerPopupBuilder new;		yourself! !!RSPopupDecoration methodsFor: 'rendering' prior: 59054436!renderIn: canvas	| box |	box := chart spine.	popup chart: chart.	box addInteraction: popup! !!RSVerticalTick methodsFor: 'rendering' prior: 59521928!createTickLineFor: aNumber	| scaledNumber zeroX |	scaledNumber := yScale scale: aNumber.	zeroX := chart spineDecoration zeroPoint x.	^ self newLineTick		startPoint: zeroX @ scaledNumber;		endPoint: zeroX - self configuration tickSize @ scaledNumber;		yourself! !!RSVerticalTick methodsFor: 'rendering'!updateChartMaxAndMinValues: aChart	aChart		minValueY: self ticksData first;		maxValueY: self ticksData last! !!RSHistogramPlot methodsFor: 'accessing' prior: 58763657!binningStrategy: aBinningStrategy	binningStrategy := aBinningStrategy.	self computeXYValues! !!RSHistogramPlot methodsFor: 'accessing' prior: 58763043!bins: aCollection	self assert: aCollection isCollection description: 'you must provide a collection'.	self binningStrategy: (RSFixedBinning new		bins: aCollection;		yourself)! !!RSHistogramPlot methodsFor: 'private' prior: 58762752!computeBins	^ binningStrategy createBinsFor: x! !!RSHistogramPlot methodsFor: 'private' prior: 58763875!computeXYValues	| prev |	x ifNil: [ ^ self ].	bins := self computeBins.	xValues := bins.	prev := bins first.	yValues := bins allButLast collectWithIndex: [ :val1 :index |		| val2 condition |		val2 := bins at: index + 1.		condition := index + 1 = bins size			ifTrue: [ [ :value | value between: val1 and: val2 ] ]			ifFalse: [ [ :value | val1 <= value and: [ value < val2 ] ] ].		(x select: condition ) size.	]! !!RSHistogramPlot methodsFor: 'initialization' prior: 58762477!initialize	super initialize.	self binningStrategy: RSDefaultBinning new! !!RSHistogramPlot methodsFor: 'accessing' prior: 58762608!numberOfBins: aNumber	self binningStrategy numberOfBins: aNumber.	self computeXYValues! !!RSHistogramPlot methodsFor: 'rendering' prior: 58761716!renderIn: canvas	bars := yValues collectWithIndex: [ :yVal :index |		| rect xVal xVal2 |		xVal := xValues at: index.		xVal2 := xValues at: index +1.		rect := Rectangle			origin: (self scalePoint: xVal @ yVal)			corner: (self scalePoint: xVal2 @ 0).		self shape copy			model: (xVal->xVal2) -> yVal;			color: self computeColor;			fromRectangle: rect;			yourself ].	bars := bars asGroup.	canvas addAll: bars! !!RSHistogramPlot methodsFor: 'accessing' prior: 58763537!x: aCollection	x := aCollection sorted.	self computeXYValues! !!RSHorizontalTopTick methodsFor: 'rendering' prior: 58775606!createTickLineFor: aNumber	| value y |	value := xScale scale: aNumber.	y := chart extent y negated.	^ self newLineTick		startPoint: value @ y;		endPoint: value @ (y - self configuration tickSize);		yourself! !!RSHorizontalTopTick methodsFor: 'rendering'!updateChartMaxAndMinValues: aChart	aChart		minValueX: self ticksData first;		maxValueX: self ticksData last! !!RSChartSpineDecoration methodsFor: 'initialization' prior: 58481695!defaultShape	^ RSBox new		noPaint;		border: (RSBorder new joinMiter);		yourself! !!RSChartSpineDecoration methodsFor: 'rendering' prior: 58481225!renderIn: canvas	box := self shape copy		borderColor: self styler spineColor;		extent: chart extent.	box translateTo: (chart extent x / 2) @ (chart extent y negated / 2).	canvas add: box! !!RSLineSpineDecoration methodsFor: 'rendering' prior: 58944522!renderIn: canvas	| x y plot zeroPoint |	axisX := self shape copy.	plot := chart plots anyOne.	zeroPoint := self zeroPoint.	x := zeroPoint x.	y := zeroPoint y.	axisX startPoint: 0@ y; endPoint: chart extent x @ y.	axisY := self shape copy.	axisY startPoint: x @ chart extent y; endPoint: x @ 0.	box := { axisX. axisY } asShape.	box translateTo: (chart extent x / 2) @ (chart extent y negated / 2).	canvas add: box! !!RSLineSpineDecoration methodsFor: 'accessing' prior: 58945107!zeroPoint	| plot x y |	plot := chart plots first.	y := (0 between: chart minValueY and: chart maxValueY)		ifTrue: [ (plot yScale scale: 0) + chart extent y ]		ifFalse: [ chart extent y ].	x := (0 between: chart minValueX and: chart maxValueX)		ifTrue: [ (plot xScale scale: 0) ]		ifFalse: [ 0 ].	^ x @ y! !!RSAbstractLabelDecoration methodsFor: 'rendering' prior: 58203317!createLabel	"Utility method to create a label"	^ self shape copy		text: title;		color: self styler textColor;		yourself! !!RSAbstractLabelDecoration methodsFor: 'initialization' prior: 58203484!initialize	super initialize.	location := RSLocation new! !!RSAbstractBinning methodsFor: 'hooks' prior: 58145139!createBinsFor: aCollection	| size |	size := self computeNumberOfBinsFor: aCollection.	"an adjust"	size := size + 1.	^ aCollection first to: aCollection last count: size! !!RSAbstractChartPlot methodsFor: 'private - adding'!addedIn: anRSChart	self subclassResponsibility! !!RSAbstractChartPlot methodsFor: 'rendering' prior: 58150711!createYScale	| padding |	yScale ifNil: [ yScale := NSScale linear ].	yScale class = NSOrdinalScale ifTrue: [ ^ self ].	padding := chart padding y.	yScale		domain:			{chart minValueY.			chart maxValueY};		range:			{0 - padding.			chart extent y negated + padding }! !!RSAbstractChartPlot methodsFor: 'initialization'!defaultStyler	^ RSChartStyler new! !!RSAbstractChartPlot methodsFor: 'initialization' prior: 58150070!initialize	super initialize.	shape := self defaultShape.	styler := self defaultStyler! !!RSAbstractChartPlot methodsFor: 'accessing'!styler	^ styler! !!RSAbstractChartPlot methodsFor: 'accessing'!styler: anObject	styler := anObject! !!RSDoubleBarPlot methodsFor: 'hooks' prior: 58600121!computeSecondRectagleFor: aPoint index: index	| origin corner sizeOffset offset zero |	zero := 0.	left ifNotNil: [ zero := left at: index ].	origin := (x2Scale scale: aPoint x) @ (yScale scale: aPoint y).	corner := (x2Scale scale: zero) @ origin y.	sizeOffset := 0@(self barSize * 0.3).	offset := 0@ self barOffset.	^ Rectangle		origin: origin + offset - sizeOffset		corner: corner + offset + sizeOffset! !!RSDoubleBarPlot methodsFor: 'rendering' prior: 58599338!renderIn: canvas	| index |	super renderIn: canvas.	index := 1.	bars2 := x2Values collect: [ :xt |		| yt bar |		yt := yValues at: index.		bar := self createBar2For: xt@yt index: index.		index := index + 1.		bar ] as: RSGroup.	canvas addAll: bars2! !!RSDoubleBarPlot methodsFor: 'accessing' prior: 58599924!x1: x1 x2: x2 y: y	self assert: x1 size = y size description: 'The two collections must have the same size'.	self x: x1 y: y.	x2Values := x2! !RSAbstractTick removeSelector: #defaultNiceLabel!RSAbstractTick removeSelector: #createNiceLabelIn:!RSChart removeSelector: #niceGenerator!RSHorizontalTick removeSelector: #createNiceLabelIn:!RSNiceStepSizeGenerator removeSelector: #stepSize:q:!RSNiceStepSizeGenerator removeSelector: #setQ:base:!RSNiceStepSizeGenerator removeSelector: #reset!RSNiceStepSizeGenerator removeSelector: #qvar!RSNiceStepSizeGenerator removeSelector: #qat:!RSNiceStepSizeGenerator removeSelector: #offsets:q:!RSNiceStepSizeGenerator removeSelector: #next!RSNiceStepSizeGenerator removeSelector: #logB:!RSNiceStepSizeGenerator removeSelector: #initialize!RSNiceStepSizeGenerator removeSelector: #base!Smalltalk globals removeClassNamed: #AnObsoleteRSNiceStepSizeGenerator!RSNiceStep removeSelector: #stepSize:!RSNiceStep removeSelector: #stepSize!RSNiceStep removeSelector: #offset:!RSNiceStep removeSelector: #offset!RSNiceStep removeSelector: #j:!RSNiceStep removeSelector: #j!RSNiceStep removeSelector: #i:!RSNiceStep removeSelector: #i!Smalltalk globals removeClassNamed: #AnObsoleteRSNiceStep!RSNiceLabel removeSelector: #ticks!RSNiceLabel removeSelector: #step:!RSNiceLabel removeSelector: #step!RSNiceLabel removeSelector: #score:!RSNiceLabel removeSelector: #score!RSNiceLabel removeSelector: #printOn:!RSNiceLabel removeSelector: #numberOfTicks!RSNiceLabel removeSelector: #min:!RSNiceLabel removeSelector: #min!RSNiceLabel removeSelector: #max:!RSNiceLabel removeSelector: #max!RSNiceLabel removeSelector: #initialize!Smalltalk globals removeClassNamed: #AnObsoleteRSNiceLabel!RSLabelGenerator removeSelector: #w:c:d:l:!RSLabelGenerator removeSelector: #vMin:max:step:!RSLabelGenerator removeSelector: #simplicityMax!RSLabelGenerator removeSelector: #simplicity:max:step:!RSLabelGenerator removeSelector: #setLooseFlag:!RSLabelGenerator removeSelector: #searchMin:max:desired:!RSLabelGenerator removeSelector: #nice:!RSLabelGenerator removeSelector: #legibility:max:step:!RSLabelGenerator removeSelector: #initialize!RSLabelGenerator removeSelector: #flooredMod:n:!RSLabelGenerator removeSelector: #epsilon!RSLabelGenerator removeSelector: #densityMax:m:!RSLabelGenerator removeSelector: #density:m:dmin:dmax:lmin:lmax:!RSLabelGenerator removeSelector: #coverageMin:max:span:!RSLabelGenerator removeSelector: #coverageMin:max:lmin:lmax:!RSLabelGenerator class removeSelector: #nice:!Smalltalk globals removeClassNamed: #AnObsoleteRSLabelGenerator!RSVerticalTick removeSelector: #createNiceLabelIn:!"Roassal3-Chart"!!RSDSM methodsFor: 'hooks - labels' prior: 58568755!addLabels: aRSCanvas	self addLabelsLeft: aRSCanvas.	self addLabelsTop: aRSCanvas! !!RSDSM methodsFor: 'hooks - labels' prior: 58567082!addLabelsIfNecessary: aRSCanvas	self wantsLabels ifFalse: [ ^ self ].	self addLabels: aRSCanvas! !!RSDSM methodsFor: 'hooks - labels' prior: 58563265!addLabelsLeft: aRSCanvas	| column |	column := self columnAt: 1.	aRSCanvas addAll: (labelsY := column collect: [ :s | self createLabelShapeY: s ])! !!RSDSM methodsFor: 'hooks - labels' prior: 58565220!addLabelsTop: aRSCanvas	| row |	row := self rowAt: 1.	aRSCanvas addAll: (labelsX := row collect: [ :s | self createLabelShapeX: s ])! !!RSDSM methodsFor: 'hooks - labels' prior: 58569555!createLabelShapeX: aRSBox	| label model |	model := shouldFeedX		ifTrue: [ aRSBox model key ]		ifFalse: [ aRSBox model value ].	label := self labelShapeX shapeFor: model.	label model: model.	label rotateByDegrees: self rotation.	RSLocation new		outer;		top;		right;		offset: label width negated @ 0;		move: label on: aRSBox.	^ label! !!RSDSM methodsFor: 'hooks - labels' prior: 58566133!createLabelShapeY: aRSBox	| label model |	model := shouldFeedX		ifTrue: [ aRSBox model value ]		ifFalse: [ aRSBox model key ].	label := self labelShapeY shapeFor: model.	label model: model.	RSLocation new		outer;		left;		offset: -10 @0;		move: label on: aRSBox.	^ label! !!RSDSM methodsFor: 'hooks' prior: 58567369!createShapeX: anObjectX y: anObjectY position: position list: list	| box |	box := self createShape: (shouldFeedX		ifTrue: [ anObjectX -> anObjectY ]		ifFalse: [ anObjectY -> anObjectX ]).	box propertyAt: #matrixIndex put: position.	self setUpShape: box.	list add: box.	^ box! !!RSDSM methodsFor: 'hooks' prior: 58563904!createShapes	| group |	group := RSGroup new.	matrix := Array2D rows: objectsX size columns: objectsY size.	objectsY doWithIndex: [ :anObjectY :k |		objectsX doWithIndex: [ :anObjectX :j |			matrix				at: j				at: k				put: (self					createShapeX: anObjectX					y: anObjectY					position: j@k					list: group)		]	].	^ group! !!RSDSM methodsFor: 'accessing - defaults' prior: 58563149!defaultContainer	^ super defaultContainer @ RSCanvasController! !!RSDSM methodsFor: 'initialization' prior: 58563537!defaultShape	^ RSBox new		size: 15;		border: (RSBorder new color: 'white');		@ self highlightable;		yourself! !!RSDSM methodsFor: 'highlighting' prior: 58567703!highlight: evt	| position |	shape := evt shape.	position := shape propertyAt: #matrixIndex.	self highlightRectangle: (self columnAt: position x) key: #columnRect.	self highlightRectangle: (self rowAt: position y) key: #rowRect! !!RSDSM methodsFor: 'highlighting' prior: 58568088!highlightRectangle: aGroupOfShapes key: key	| canvas rectangle box |	canvas := aGroupOfShapes anyOne canvas.	rectangle := 1 asMargin expandRectangle: aGroupOfShapes asGroup encompassingRectangle.	box := RSBox new		noPaint;		border: (RSBorder new color: 'black');		fromRectangle: rectangle;		yourself.	canvas addShape: box.	canvas propertyAt: key put: box! !!RSDSM methodsFor: 'initialization' prior: 58568891!initialize	super initialize.	shape := self defaultShape.	self		rotation: 45;		showLabels;		setShouldFeedX;		color: [ :tuple | self computeColor: tuple ];		dependency: #yourself;		objects: #()! !!RSDSM methodsFor: 'accessing' prior: 58565681!objects: someObjects	self		objectsX: someObjects;		objectsY: someObjects! !!RSDSM methodsFor: 'hooks' prior: 58564371!renderIn: aCanvas	shapes := self createShapes.	aCanvas addAll: shapes.	self layoutShapes: shapes.	self addLabelsIfNecessary: aCanvas! !!RSDSM methodsFor: 'hooks' prior: 58566982!setUpShape: box	box announcer: shape announcer! !!RSDSM methodsFor: 'accessing - computed' prior: 58562780!shapeAt: aPoint	^ matrix at: aPoint y at: aPoint x! !!RSDSM methodsFor: 'highlighting' prior: 58564647!unhighlight: evt	self unhighlight: evt key: #columnRect.	self unhighlight: evt key: #rowRect! !!RSDSM methodsFor: 'highlighting' prior: 58562882!unhighlight: evt key: key	| canvas |	canvas := evt canvas.	canvas propertyAt: key ifPresent: [ :s |		s remove.		canvas removeKey: key ]! !!RSDSMStronglyConnected methodsFor: 'rendering' prior: 58575291!createGraph	| graph selectedColor |	objectsX = objectsY ifFalse: [ ^ self error: 'we should have the same data in X and Y' ].	graph := RSDSMGraph new: objectsX size.	selectedColor := self selectedColor.	objectsX doWithIndex: [ :a :k |		objectsX doWithIndex: [ :b :j |			shouldFeedX ifTrue: [				(self isAssocDependent: a -> b)					ifTrue: [ graph addEdge: k to: j ]			] ifFalse: [				(self isAssocDependent: b -> a)					ifTrue: [ graph addEdge: k to: j ]			]		] ].	^ graph! !!RSDSMStronglyConnected methodsFor: 'accessing' prior: 58575845!palette	^ palette ifNil: [ palette := NSScale category20 ]! !!RSDSMStronglyConnected methodsFor: 'rendering' prior: 58573994!renderBoxes: aRSCanvas groups: aCollection	aRSCanvas addAll: (aCollection		select: [ :group | group size > 1 ]		thenCollect: [ :group | self boxFor: group ])! !!RSDSMStronglyConnected methodsFor: 'hooks' prior: 58573651!renderIn: aCanvas	| graph groups |	graph := self createGraph.	groups := graph computeSCCs.	"this method changes the model"	self sortGroups: groups.	graph := self createGraph.	groups := graph computeSCCs.	super renderIn: aCanvas.	self renderBoxes: aCanvas groups: groups! !!RSDSMStronglyConnected methodsFor: 'rendering' prior: 58575141!shapesFrom: group	^ group collect: [ :each | self shapeAt: each @ each ] as: RSGroup! !!RSDSMStronglyConnected methodsFor: 'sorting' prior: 58574689!sortGroups: aCollection	| newModel |	aCollection sort: [ :a :b | a size > b size ].	newModel := aCollection		flatCollect: [ :each | each collect: [ :index | objectsX at: index ] ]		as: objectsX class.	objectsX := newModel.	objectsY := newModel! !"Roassal3-DSM"!!RSWorldMenu class methodsFor: 'loading' prior: 59524469!loadFullVersion	"TODO do not discard changes"	(UIManager default confirm: 'Do you want to load the last version of Roassal3?')		ifFalse: [ ^ self ].	[Metacello new		baseline: 'Roassal3';		repository: 'github://ObjectProfile/Roassal3';		load: 'Full' ] on: MCMergeOrLoadWarning do: [:warning | warning load ].	self loadExporters.! !!RSWorldMenu class methodsFor: 'menu' prior: 59525506!menu00RoassalOn: aBuilder	<worldMenu>	(aBuilder item: #Roassal3)		parent: #Tools;		label: 'Roassal3';		icon: self roassalIcon;		help: 'A visualization engine';		order: 777.	(aBuilder item: #Roassal3Help)		parent: #Roassal3;		label: 'Help';		icon: (self iconNamed: #glamorousHelp);		help: 'Need help?';		order: 1.	(aBuilder item: #Roassal3Load)		parent: #Roassal3;		label: 'Load...';		icon: (self iconNamed: #smallLoadProject);		help: 'Load roassal projects';		order: 2! !!RSWorldMenu class methodsFor: 'menu' prior: 59525139!menu01ReportABugOn: aBuilder	<worldMenu>	(aBuilder item: #Roassal3Bug)		parent: #Roassal3Help;		order: 1;		label: 'Report a Bug';		icon: (self iconNamed: #smallDebug);		help: 'Will open the github page to report an issue';		action: [ WebBrowser openOn: 'https://github.com/ObjectProfile/Roassal3/issues/new' ]! !!RSWorldMenu class methodsFor: 'menu' prior: 59527062!menu02GithubOn: aBuilder	<worldMenu>	(aBuilder item: #Roassal3Git)		parent: #Roassal3Help;		order: 2;		label: 'Github';		help: 'Open Roassal3 git hubpage';		icon: (self iconNamed: #github);		action: [ WebBrowser openOn: 'https://github.com/ObjectProfile/Roassal3/' ]! !!RSWorldMenu class methodsFor: 'menu' prior: 59527902!menu03DiscordOn: aBuilder	<worldMenu>	(aBuilder item: #Roassal3Chat)		parent: #Roassal3Help;		order: 3;		label: 'Chat with us';		help: 'Will open discord web to chat with us in Pharo server';		icon: self discord;		action: [ WebBrowser openOn: 'https://discord.gg/YTEaAu6' ]! !!RSWorldMenu class methodsFor: 'menu' prior: 59525899!menu04DocumentationOn: aBuilder	<worldMenu>	(aBuilder item: #Roassal3Documentation)		parent: #Roassal3Help;		order: 4;		label: 'Online documentation';		help: 'Will open the webpage https://github.com/ObjectProfile/Roassal3Documentation';		icon: (self iconNamed: #smallHelp);		action: [ WebBrowser openOn: 'https://github.com/ObjectProfile/Roassal3Documentation' ]! !!RSWorldMenu class methodsFor: 'menu'!menu05PluginsOn: aBuilder	<worldMenu>	(aBuilder item: #Roassal3Exporters)		parent: #Roassal3Load;		order: 6;		label: 'Load exporters';		help: 'To export roassal canvas in PNG, PDF, SVG';		icon: self roassalIcon;		action: [ self loadExporters ]! !!RSWorldMenu class methodsFor: 'menu'!menu06LoadFullVersionOn: aBuilder	<worldMenu>	(aBuilder item: #Roassal3LoadFullVersion)		parent: #Roassal3Load;		order: 5;		label: 'Load full version';		help: 'Load full version of Roassal including examples';		icon: self roassalIcon;		action: [ self loadFullVersion ]! !!RSWorldMenu class methodsFor: 'menu' prior: 59524868!menu11SelfOn: aBuilder	<worldMenu>	(aBuilder item: #Roassal3Self)		parent: #Roassal3;		order: 11;		label: 'This menu';		help: 'Open RSWorldMenu';		icon: (self iconNamed: #smallExport);		action: [ self class browse ]! !RSWorldMenu class removeSelector: #menu07LoadFullVersionOn:!RSWorldMenu class removeSelector: #menu06PluginsOn:!RSWorldMenu class removeSelector: #loadFullStableVersion!RSWorldMenu class removeSelector: #areExamplesAlreadyLoaded!"Roassal3-Menu"!!RSGridLayout class methodsFor: '*Roassal3-Spec'!horizontalAlignmentOptions	^ #(left center right)! !!SpRoassalPresenter methodsFor: 'initialization' prior: 66243470!initialize	super initialize.	script := [ :aCanvas | ] asValueHolder.	script whenChangedDo: [ :s | self refresh ]! !!SpRoassalPresenter methodsFor: 'public' prior: 66242510!refresh	self changed: #applyScript with: #()! !!SpRoassalPresenter methodsFor: 'accessing' prior: 66244192!whenPresenterResized: aBlock	self announcer 		when: PresenterResized 		do: [ :ann | aBlock cull: ann extent ]		 for: self! !"Roassal3-Spec"!!SpMorphicRoassalAdapter class methodsFor: 'class initialization' prior: 65789664!initialize	"we need to reset the cached adapter bindigns"	SpNullApplication reset! !!SpMorphicRoassalAdapter methodsFor: 'scripting actions' prior: 65789426!freeCanvas	| temp |	temp := self buildWidget.	canvas := temp roassalCanvas.	widget canvas: canvas.	canvas morph: widget.	canvas extent: widget extent! !Smalltalk globals removeClassNamed: #AnObsoleteManifestRoassal3SpecMorphic!"Roassal3-Spec-Morphic"!!RSMapBrowserToolMorph class methodsFor: 'testing' prior: 58961402!shouldBeActivatedInContext: aBrowserContext	^ aBrowserContext isClassSelected		and: [ aBrowserContext lastSelectedClass inheritsFrom: BaselineOf ]! !!RSMapBrowserToolMorph methodsFor: 'building' prior: 58960884!build	| canvas morph |	canvas := self buildBaselineMap.	morph := canvas createMorph.	morph onAnnouncement: MorphDeleted		do: [ self containerTab owner ifNotNil: [ self containerTab delete]].	self addMorph: morph fullFrame: LayoutFrame identity! !!RSMapBrowserToolMorph methodsFor: 'building' prior: 58961196!buildBaselineMap	^ RSBaselineMapSettings classMapBuilderOrDefault new		baseline: self targetClass;		context: context;		build;		canvas! !!RSBaselineModel methodsFor: 'private' prior: 58345826!browse	class ifNil: [ ^ nil ].	^ class browse! !!RSBaselineModel methodsFor: 'inspector' prior: 58346101!inspectionBaselineMap: builder	<inspectorPresentationOrder: 10 title: 'Dependencies Map'>	| canvas |	canvas := RSBaselineMapSettings classMapBuilder new		in: [ :map |			self baselineClass				ifNotNil: [ map baseline: self baselineClass ] ];		build;		canvas.	^ SpRoassal3InspectorPresenter new		canvas: canvas;		yourself! !!RSThemedMapBuilder methodsFor: 'accessing - defaults' prior: 59438601!defaultContainer	| theme |	theme := self theme.	^ RSCanvas new		color: theme backgroundColor;		when: RSThemeChangedEvent send: #themeChanged: to: self;		addInteraction: (RSCanvasController new			in: [:i | i configuration useBasicZoom ];			yourself);		yourself! !!RSThemedMapBuilder methodsFor: 'highlighting' prior: 59439504!highlight: evt	| box lines boxes |	box := evt shape.	lines := box outgoingLines.	self highlightLines: lines.	boxes := (lines collect: #to) asOrderedCollection.	boxes add: box.	self highlightBoxes: boxes.	evt canvas propertyAt: #highlightedLines put: lines! !!RSThemedMapBuilder methodsFor: 'highlighting' prior: 59439106!highlightAnt: antBorder	| animation canvas |	canvas := self container.	antBorder dashArray: #(7 3).	animation := canvas newAnimation		repeat;		from: 0;		to: antBorder dashArray sum negated;		duration: 1 second;		onStepDo: [ :t |			antBorder dashOffset: t.			canvas signalUpdate ].	canvas propertyAt: #ant put: animation! !!RSThemedMapBuilder methodsFor: 'highlighting' prior: 59436056!highlightBoxes: boxes	| canvas color |	canvas := self canvas.	color := TestResult defaultColorBackGroundForPassingTest.	boxes do: [ :box | | shadow |		shadow := self shadowFor: box.		shadow color: color.		box when: RSPositionChangedEvent do: [ :evt | shadow position: evt newPosition ] for: self.		box propertyAt: #shadow put: shadow.		canvas addShape: shadow.		shadow pushBack ].	canvas propertyAt: #highlightedBoxes put: boxes! !!RSThemedMapBuilder methodsFor: 'highlighting' prior: 59436748!highlightLines: lines	| canvas antBorder color |	lines ifEmpty: [ ^ self ].	canvas := self container.	antBorder := RSBorder new		width: 2;		yourself.	color := self theme dangerTextColor.	lines do: [ :line | | border |		border := line border.		line propertyAt: #oldBorder put: border.		line border: antBorder.		line color: color.		 ].	self highlightAnt: antBorder! !!RSThemedMapBuilder methodsFor: 'instance creation' prior: 59438009!newBorderFor: aModel	aModel baselineClass ifNotNil: [ ^ nil ].	^ RSBorder new		color: self theme textColor;		width: 2;		dashArray: #(4);		yourself! !!RSThemedMapBuilder methodsFor: 'instance creation' prior: 59440148!newLabelFor: model	| label |	label := super newLabelFor: model.	model name = baseline name		ifTrue: [ label fontSize: label fontSize * 1.5; bold ].	^ label! !!RSThemedMapBuilder methodsFor: 'events' prior: 59435521!showMenu: evt	| menu newContext tool class |	context ifNil: [ ^ self ].	class := evt shape model baselineClass.	class ifNil: [ ^ self] .	newContext := context copy.	tool := ClyFullBrowserMorph on: ClyNavigationEnvironment currentImage.	tool prepareInitialStateBy: [ :b | b selectClass: class ].	newContext tool: tool.		menu := CmdContextMenuActivation			buildContextMenuFor: evt canvas morph			inContext: newContext.	menu popUpInWorld: self currentWorld! !!RSThemedMapBuilder methodsFor: 'accessing - defaults' prior: 59436556!themeChanged: evt	evt canvas shapes copy do: #remove.	evt canvas color: self theme backgroundColor.	self renderIn: evt canvas! !!RSThemedMapBuilder methodsFor: 'highlighting' prior: 59437189!unhighlight: evt	evt canvas		propertyAt: #ant ifPresent: [ :anime | anime stop ];		propertyAt: #highlightedLines ifPresent: [ :lines | self unhighlightLines: lines ];		propertyAt: #highlightedBoxes ifPresent: [ :boxes | self unhighlightBoxes: boxes ]! !!RSThemedMapBuilder methodsFor: 'highlighting' prior: 59437608!unhighlightBoxes: boxes	boxes do: [ :box |		box propertyAt: #shadow ifPresent: [ :shadow | shadow remove ] ]! !!RSThemedMapBuilder methodsFor: 'highlighting' prior: 59437784!unhighlightLines: lines	lines do: [ :line |		line border: (line propertyAt: #oldBorder).		line color: line border color.		line removeKey: #oldBorder ]! !!RSMapBuilder methodsFor: 'hooks' prior: 58965202!adjustWidth: aMaxNumber	shapes do: [ :shape |		shape children first width: aMaxNumber.		shape adjustToChildren ]! !!RSMapBuilder methodsFor: 'accessing' prior: 58963971!baseline: aBaselineClass	baseline := aBaselineClass.	self computeModels! !!RSMapBuilder methodsFor: 'hooks - model' prior: 58966248!computeModels	| todo rootModel |	models := OrderedCollection new.	rootModel := self newModelFor: baseline.	rootModel level: 1.	todo := LinkedList with: rootModel.	self findModels: todo! !!RSMapBuilder methodsFor: 'hooks - model' prior: 58963542!findDependencies: aBMBaselineModel todoList: todoList	| dependencies newModels |	dependencies := nil.	[		dependencies := self dependenciesFrom: aBMBaselineModel.		newModels := dependencies collect: [ :each |			self newModelFromDependency: each level: aBMBaselineModel level ].		todoList addAll: newModels.	] onErrorDo: [ :ex | dependencies := #() ].	^ dependencies! !!RSMapBuilder methodsFor: 'hooks - model' prior: 58965377!findModels: todoList	| model |	todoList ifEmpty: [ ^ self ].	model := todoList removeFirst.	(models includes: model) ifFalse: [		models add: model.		model dependencies: (self findDependencies: model todoList: todoList).	].	self findModels: todoList! !!RSMapBuilder methodsFor: 'instance creation' prior: 58964438!newBox	^ RSBox new		yourself! !!RSMapBuilder methodsFor: 'instance creation' prior: 58966103!newLabelFor: model	^ RSLabel new		text: model name;		color: Color black;		yourself! !!RSMapBuilder methodsFor: 'hooks - model' prior: 58962853!newModelFromDependency: aString level: level	| class |	class := Smalltalk globals at: aString asSymbol		ifPresent: [ :cls | cls ]		ifAbsent: [ nil ].	^ self newModel		name: aString;		baselineClass: class;		level: level + 1;		yourself! !!RSMapBuilder methodsFor: 'instance creation' prior: 58964107!newShapeFor: model	| label box |	label := self newLabelFor: model.	box := self newBox		extent: label extent + 10;		border: (self newBorderFor: model);		cornerRadius: self cornerRadius;		yourself.	^ ({ box. label } asShapeFor: model)		draggable;		yourself! !!RSMapBuilder methodsFor: 'hooks' prior: 58964649!renderIn: aCanvas	| modelsByGroup |	models ifNil: [ ^ self ].	modelsByGroup := self groupsOfBaselines.	modelsByGroup keysAndValuesDo: [ :level :layerGroup |		self renderLayer: layerGroup level: level in: aCanvas ].	self renderLinesOn: aCanvas.	self layoutOn: aCanvas! !!RSMapBuilder methodsFor: 'hooks' prior: 58965784!renderLayer: layerGroup level: key in: aCanvas	| max |	max := 0.	shapes := layerGroup collect: [ :model | | shape |		shape := self newShapeFor: model.		max := max max: shape width.		shape ] as: RSGroup.	self adjustWidth: max.	aCanvas addAll: shapes! !!RSMapBuilder methodsFor: 'hooks' prior: 58963265!renderLinesOn: aCanvas	self newLineBuilder		canvas: aCanvas;		connectToAll: [ :model |			model dependencies collect: [ :depName |				models detect: [ :each | each name = depName ]				 ] ].	aCanvas lines pushBack! !!BaselineOf methodsFor: '*Roassal3-BaselineMap' prior: 18149319!inspectionBaselineMap	<inspectorPresentationOrder: 10 title: 'Dependencies Map'>	| canvas |	canvas := RSBaselineMapSettings classMapBuilder new		baseline: self class;		build;		canvas.	^ SpRoassal3InspectorPresenter new		canvas: canvas;		yourself! !!RSVerticalMapBuilder methodsFor: 'elementary operations' prior: 59519515!layoutOn: aCanvas	^ RSTreeLayout new		horizontalGap: 5;		verticalGap: 5;		on: aCanvas nodes;		yourself! !!RSVerticalMapBuilder methodsFor: 'hooks' prior: 59518982!renderIn: aCanvas	super renderIn: aCanvas.	self updateWithPreOrder: aCanvas! !!RSVerticalMapBuilder methodsFor: 'hooks' prior: 59520204!updateWidth: groupOfShapes layout: layout	groupOfShapes do: [ :shape |		| children |		children := layout childrenFor: shape.		children ifNotEmpty: [			| width |			self updateWidth: children layout: layout.			width := children asGroup width.			shape children first width: width.			shape width: width ].		 ]! !!RSVerticalMapBuilder methodsFor: 'hooks' prior: 59519208!updateWithPreOrder: aCanvas	| layout |	layout := self layoutOn: aCanvas nodes.	self updateWidth: (layout rootNodesFor: aCanvas nodes) layout: layout! !"Roassal3-BaselineMap"!!RSSVGPathLine commentStamp: '' prior: 0!I represent path a complex line from one point to another with an svg path.Here an example:```RSBasicShapeExamples new example16BasicLinePath inspect```- `svgPath:`. Use a block with one argument, this block should return a String```svgLine := RSSVGPathLine new.svgLine svgPath: [:line | 'M0 0 L200 100L400 0 Z' ].svgLine color: Color blue.svgLine borderColor: Color black.canvas := RSCanvas new.canvas add: svgLine.canvas```this block is executed each time you need to redraw the line. As you can see this string is hardcoded, the idea is to use the `line` to create the string with the svg path commands.But this is only a basic way to draw a custom line. If you will need an special line then you should create a subclass of `RSAbstractLine` then add a methods in `RSAthensRenderer` using the visitor pattern.!!RSBimetricLine commentStamp: '' prior: 0!I am a line with different sizes in each side.Here is how to use it, from Roassal code```| view e1 e2 box l |	view := RSView new.	box := RSShapeBuilder box 		size: 100;		draggable.	e1 := box element.	e1 color: Color blue.	e2 := box element.	e2 translateTo: 400@0.	l := RSSingleEdgeBuilder bimetricLine		widthFrom: 50;		widthTo: 10;		paint: Color red;		border: nil;		withBorderAttachPoint;		from: e1;		to: e2;		edge.	view addAll: { e1. e2. l}.	view @ RSControlsView. 	view open```!!RSAreaPlot commentStamp: '' prior: 0!TODO!!RSSVGPath commentStamp: '' prior: 0!TODO!!RSSegmentsVisitor commentStamp: '' prior: 0!This class iterates over a RSSVGPath path segments!!RSBlockSegmentsVisitor commentStamp: '' prior: 0!I use block for each segmentThis class is just for examples and demos. For a better visitor for each segment try to create a new subclass of RSSegmentsVisitor!!RSBimetricEdgeBuilder commentStamp: '' prior: 0!I am an edge builder for bimetric lines!!RSMultiBezierEdgeBuilder commentStamp: '' prior: 0!I am a special edge builder with some especial contruction with #linePath and #multiBezierMy instances provide a new edges that you can connect with ancestors between modelsHere is an example:-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=v := RSView new.classes := Collection withAllSubclasses.es := RSShapeBuilder circle elementsOn: classes.v addAll: es.es @ RSPopup @ RSDraggable.eb := RSEdgeBuilder line.eb color: Color gray.eb view: v.eb elements: es.eb withBorderAttachPoint."eb following: #superclass."eb connectFrom: #superclass.RSNormalizer size	elements: es;	to: 20;	normalize: #numberOfMethods.	RSNormalizer color	elements: es;	normalize: #numberOfMethods.RSClusterLayout on: es.eb2 := RSMultiBezierEdgeBuilder multiBezier.eb2 borderColor: (Color blue alpha: 0.5).eb2 view: v.eb2 elements: es.eb2 withBorderAttachPoint.eb2 following: #superclass.eb2 connectToAll: #dependentClasses.v @ RSControlsView.v  -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=!!RSShapeFactory class methodsFor: '*Roassal3-SVG'!svgPath	^ RSSVGPath new! !!RSBimetricLine methodsFor: 'initialization'!initialize	super initialize.	widthFrom := widthTo := 0.	self initializeSVG! !!RSBimetricLine methodsFor: 'initialization'!initializeSVG	self		svgPath: [ :aLine |			| e w1 w2 dist z sourcePoint targetPoint |			sourcePoint := aLine startPoint.			targetPoint := aLine endPoint.			e := 0.001.			w1 := aLine widthTo max: e.			w2 := aLine widthFrom max: e.			dist := sourcePoint distanceTo: targetPoint.			dist := dist max: e.			z := (w1 + w2) * 2.			z > dist				ifTrue: [ w1 := w1 * dist / z.					w2 := w2 * dist / z ].			[ :builder |			| first side |			first := true.			side := [ :vector :end :size |			| left right u unit middle l r |			u := vector normal.			unit := vector / (vector r max: e).			middle := end - (unit * size).			left := (middle - (u * size)) asFloatPoint.			l := (end - (u * size)) asFloatPoint.			right := (middle + (u * size)) asFloatPoint.			r := (end + (u * size)) asFloatPoint.			first				ifTrue: [ builder moveTo: left ]				ifFalse: [ builder lineTo: left ].			builder				curveVia: l to: end;				curveVia: r to: right ].			builder absolute.			side				value: targetPoint - sourcePoint				value: targetPoint				value: w1 / 2.			first := false.			side				value: sourcePoint - targetPoint				value: sourcePoint				value: w2 / 2.			builder close ] ]! !!RSBimetricLine methodsFor: 'accessing'!widthFrom	^ widthFrom! !!RSBimetricLine methodsFor: 'accessing'!widthFrom: aNumber	widthFrom := aNumber! !!RSBimetricLine methodsFor: 'accessing'!widthTo	^ widthTo! !!RSBimetricLine methodsFor: 'accessing'!widthTo: aNumber	widthTo := aNumber! !!RSSVGPathLine class methodsFor: 'examples'!basicExample	| line a b |	line := self new.	a := RSCircle new		radius: 5;		color: 'blue';		draggable;		yourself.	b := RSEllipse new		radius: 5 ;		color: 'red';		draggable;		position: 100@100;		yourself.	line from: a; to: b.	line svgPath: [ :aLine | | from to |		from := aLine from position.		to := aLine to position.		'M ', from x asString, ' ', from y asString,		'L ', to x asString, ' ', to y asString,		'L' , from x asString, ' ', to y asString, ' Z'		 ].	line color: Color green; borderColor: Color black.	RSCanvas new		addAll: { a. b. line };		open! !!RSSVGPathLine methodsFor: 'visiting'!buildPathOn: visitor	visitor buildSVGLinePath: self! !!RSSVGPathLine methodsFor: 'accessing'!color	^ self paint! !!RSSVGPathLine methodsFor: 'accessing'!color: aColor	self paint: aColor! !!RSSVGPathLine methodsFor: 'initialization'!initialize	super initialize.	self svgPath: [:line |'']! !!RSSVGPathLine methodsFor: 'accessing'!svgPath	^svgPath! !!RSSVGPathLine methodsFor: 'accessing'!svgPath: aBlock	"aBlock return a string and recives 1 argument, the svg line"	svgPath := aBlock! !!AthensCubicSegment methodsFor: '*Roassal3-SVG'!durationFor: aPoint	| d |	d := to distanceTo: aPoint.	^ 1 / (d*0.5)! !!AthensCubicSegment methodsFor: '*Roassal3-SVG'!pointsWithStart: aPoint duration: duration	| c b a |	c := 3 * (via1 - aPoint).	b := 3 * (via2 - via1) - c.	a := to - aPoint - c - b.	^ (0 to: 1 by: duration) collect: [ :t |		a * (t raisedTo: 3) + (b * (t * t)) + (c * t) + aPoint.		]! !!AthensCubicSegment methodsFor: '*Roassal3-SVG'!visitWith: visitor	visitor visitCubicSegment: self! !!AthensLineSegment methodsFor: '*Roassal3-SVG'!consumeShapes: shapes current: opoint delta: delta	| vector u unit angle w2 curPoint dist sum |	shapes ifEmpty: [ ^ self ].	vector := point - opoint.	u := vector normal.	angle := vector angle.	unit := vector / (vector r max: 1).	dist := opoint distanceTo: point.	sum := 0.	shapes copy do: [ :s |		w2 := s width / 2.		sum := sum + w2.		sum > dist ifTrue: [ ^ self ].		curPoint := opoint + delta + (unit * sum).		shapes remove: s.		s translateTo: curPoint - (u * (s height/2) ).		sum := sum + w2.		s rotateByRadians: angle.	]! !!AthensLineSegment methodsFor: '*Roassal3-SVG'!durationFor: aPoint	| d |	d := aPoint distanceTo: point.	^ 1 / (d*0.5)! !!AthensLineSegment methodsFor: '*Roassal3-SVG'!pointsWithStart: aPoint duration: duration	^ (0 to: 1 by: duration) collect: [ :t |		aPoint interpolateTo: point at: t ]! !!RSAreaPlot methodsFor: 'rendering'!addPointAt: index in: s	| xval y1val y2val |	index > xValues size ifTrue: [ ^ self ].	s << (index = 1		ifTrue: [ 'M' ]		ifFalse: [ 'L' ]).	xval := xValues at: index.	y1val := yValues at: index.	s << (self pointFor: xval@y1val).	self addPointAt: index + 1 in: s.	y2Values isNumber ifTrue: [		index = 1 ifTrue: [			s << 'L'.			y2val := y2Values.			s << (self pointFor: xValues last @ y2val).			s << 'L'.			s << (self pointFor: xValues first @ y2val).			s << 'Z'. ]	] ifFalse: [		s << 'L'.		y2val := y2Values at: index.		s << (self pointFor: xval@y2val).		index = 1 ifTrue: [ s << 'Z' ].	 ]! !!RSAreaPlot methodsFor: 'accessing'!area	^ area! !!RSAreaPlot methodsFor: 'rendering'!computePath	^ String streamContents: [ :s |		self addPointAt: 1 in: s ]! !!RSAreaPlot methodsFor: 'accessing'!createdShapes	^ {area}! !!RSAreaPlot methodsFor: 'initialization'!defaultShape	^ RSSVGPath new noPaint! !!RSAreaPlot methodsFor: 'rendering'!definedValuesY	| temp|	temp := y2Values.	temp isNumber ifTrue: [ temp := { temp } ].	^ yValues , temp select: [ :v | v isNaN not and: [ v isInfinite not ] ]! !!RSAreaPlot methodsFor: 'rendering'!pointFor: aPoint	| spoint |	spoint := (xScale scale: aPoint x) @ (yScale scale: aPoint y).	self		assert: (self isPointWellDefined: spoint)		description: 'can not use invalid point to plot the graph'.	^ spoint x asFloat printString,' ',spoint y asFloat printString! !!RSAreaPlot methodsFor: 'rendering'!renderIn: canvas	canvas add: (area := self shape copy		color: self computeColor;		svgPath: self computePath;		yourself)! !!RSAreaPlot methodsFor: 'public'!x: aCollection1 y1: aCollection2 y2: aCollection3OrNumber	"collections should have the same size"	xValues := aCollection1.	yValues := aCollection2.	y2Values := aCollection3OrNumber! !!RSAreaPlot methodsFor: 'public'!x: aCollection y: aCollection2	self shouldNotImplement! !!RSAreaPlot methodsFor: 'public'!y: aCollection	self shouldNotImplement! !!RSSVGPath methodsFor: 'visiting'!buildPathOn: visitor	visitor buildSVGPath: self! !!RSSVGPath methodsFor: 'private'!centerSegment: segment absolute: absolute position: position	"maybe we can have an iterator with polymorphic objects"	| key args |	key := segment first.	args := segment second.	key = #absolute ifTrue: [ ^ true ].	key = #relative ifTrue: [ ^ false ].	(key = #ellipticalArc:xrot:large:sweep:to:relative:) ifTrue: [		absolute ifTrue: [			args at: 5 put: args fifth - position.			args at: 6 put: false ].		^ absolute ].	key = #vLineTo: ifTrue: [		absolute ifTrue: [ args at: 1 put: args first - position y ].		^ absolute].	key = #hLineTo: ifTrue: [		absolute ifTrue: [ args at: 1 put: args first - position x ].		^ absolute].	absolute ifTrue: [		args doWithIndex: [ :point :index |			args at: index put: point - position ] ].	^ absolute! !!RSSVGPath methodsFor: 'private'!centerSegments	| rect absolute position |	rect := self segmentsRectangle.	position := rect floatCenter.	absolute := true.	segments do: [ :segment |		absolute := self			centerSegment: segment			absolute: absolute			position: position  ].	polygons do: [ :polygon |		polygon doWithIndex: [ :point :index |			polygon at: index put: point - position ] ].	rect := self segmentsRectangle.	self position: position.	baseRectangle := Rectangle floatCenter: 0@0 extent: rect extent! !!RSSVGPath methodsFor: 'private'!computePolygons	| subPath absolute position point |	polygons := OrderedCollection new.	subPath := OrderedCollection new.	absolute := true.	position := 0@0.	point := [:da | position := absolute		ifTrue:[ da ]		ifFalse: [ position + da ].		subPath add: position ].	segments do: [ :segment | | key args |		key := segment first.		args := segment second.		key = #absolute ifTrue: [ absolute := true ].		key = #relative ifTrue: [ absolute := false ].		key = #moveTo: ifTrue: [			subPath ifNotEmpty: [				polygons add: subPath ].			subPath:= OrderedCollection new.			point value: args first ].		key = #close ifTrue: [			position := subPath first ].		key = #curveVia:and:to: ifTrue: [			point value: args third ].		key = #curveVia:to: ifTrue: [			point value: args second ].		key = #lineTo: ifTrue: [			point value: args first ].		key = #reflectedCurveVia:to: ifTrue: [			point value: args second ].		key = #ellipticalArc:xrot:large:sweep:to:relative: ifTrue: [			point value: args fifth ].		key = #hLineTo: ifTrue: [			position := absolute				ifTrue: [ args first @ position y ]				ifFalse: [ position + (args first @ 0) ].			subPath add: position ].		key = #vLineTo: ifTrue: [			position := absolute				ifTrue: [ position x @ args first ]				ifFalse: [ position + (0 @ args first) ].			subPath add: position ].		].	polygons add: subPath! !!RSSVGPath methodsFor: 'private'!computeSegments	| pathData |	pathData := ASPathConverter new stream: svgPath readStream.	segments := pathData convertPathData! !!RSSVGPath methodsFor: 'accessing'!extent: newExtent	| min max s extent |	segments ifNil: [ ^ self ].	extent := baseRectangle extent.	extent = newExtent		ifTrue: [ ^ self ].	min := self position - (extent / 2).	max := self position + (extent / 2).	s := newExtent / (max - min).	segments do: [ :segment | | args |		args := segment second.		args doWithIndex: [ :point :index |			args at: index put: (point isPoint				ifTrue: [ point * s ]				ifFalse: [ point * s x ] ) ] ].	polygons do: [ :polygon|		polygon doWithIndex: [ :point :index |			polygon at: index put: point * s ]  ].	super extent: newExtent! !!RSSVGPath methodsFor: 'testing'!includesPoint: aPoint	| invertedPoint |	invertedPoint := matrix rsInverseTransform: aPoint.	^ (self baseRectangle containsPoint: invertedPoint)		ifFalse: [ false ]		ifTrue: [ | apt |			apt := AthensPolygonTester new.			polygons anySatisfy: [ :eachPolygon |				(apt polygon: eachPolygon) includesPoint: invertedPoint]]! !!RSSVGPath methodsFor: 'accessing'!segments	^ segments! !!RSSVGPath methodsFor: 'private'!segments: aCollection	segments := aCollection! !!RSSVGPath methodsFor: 'private'!segmentsRectangle	| allPoints |	allPoints := polygons flatCollect: [:poly | poly ].	^ Rectangle encompassing: allPoints! !!RSSVGPath methodsFor: 'accessing'!svgPath	^ svgPath! !!RSSVGPath methodsFor: 'accessing'!svgPath: aString	svgPath := aString.	self computeSegments.	self computePolygons.	self centerSegments.	self resetPath! !!RSAthensRenderer methodsFor: '*Roassal3-SVG'!buildSVGLinePath: line	| string |	string := line svgPath value: line.	string isString ifTrue: [ | converter |		converter := ASPathConverter new stream: string readStream.		converter convertPathData do: [ :each |			builder				perform: each first				withArguments: each second ]	] ifFalse: [		string value: builder.	]! !!RSAthensRenderer methodsFor: '*Roassal3-SVG'!buildSVGPath: svg	svg segments ifNil: [ ^ self ].	svg segments		do: [ :each | builder perform: each first withArguments: each second ]! !!AthensPathSegment methodsFor: '*Roassal3-SVG'!durationFor: aPoint	^ self subclassResponsibility! !!AthensPathSegment methodsFor: '*Roassal3-SVG'!pointsWithStart: aPoint	^ self pointsWithStart: aPoint duration: (self durationFor: aPoint)! !!AthensPathSegment methodsFor: '*Roassal3-SVG'!pointsWithStart: aPoint duration: duration	^ self subclassResponsibility! !!RSBlockSegmentsVisitor methodsFor: 'accessing'!closeBlock: aBlockClosure	closeBlock := aBlockClosure! !!RSBlockSegmentsVisitor methodsFor: 'accessing'!curveViaAndToBlock: aBlockClosure	curveViaAndToBlock := aBlockClosure! !!RSBlockSegmentsVisitor methodsFor: 'accessing'!lineToBlock: aBlockClosure	lineToBlock := aBlockClosure! !!RSBlockSegmentsVisitor methodsFor: 'accessing'!moveToBlock: aBlockClosure	moveToBlock := aBlockClosure! !!RSBlockSegmentsVisitor methodsFor: 'public'!simplePoints: aBlock	| current first simplePoints |	current := first := nil.	simplePoints := [ :segment |		aBlock value: segment value: current.		current := segment endPoint.		 ].	self		moveToBlock: [ :segment | current := first := segment point ];		lineToBlock: simplePoints;		curveViaAndToBlock: simplePoints;		closeBlock: [:s |			current = first ifFalse: [				simplePoints value: (AthensLineSegment new point: first) ] ]! !!RSBlockSegmentsVisitor methodsFor: 'visiting'!visitCloseSegment: aSegment	closeBlock value: aSegment! !!RSBlockSegmentsVisitor methodsFor: 'visiting'!visitCubicSegment: aSegment	curveViaAndToBlock value: aSegment! !!RSBlockSegmentsVisitor methodsFor: 'visiting'!visitLineSegment: aSegment	lineToBlock value: aSegment! !!RSBlockSegmentsVisitor methodsFor: 'visiting'!visitMoveSegment: aSegment	moveToBlock value: aSegment! !!RSBlockSegmentsVisitor methodsFor: 'visiting'!visitQuadSegment: aSegment	lineToBlock value: aSegment! !!RSSegmentsVisitor methodsFor: 'visiting'!visitBoundingShape: aRSSVGPath	| b segment |	b := AthensSimplePathBuilder new.	aRSSVGPath segments do: [ :each |		b perform: each first withArguments: each second ].	segment := b pathStart.	[ segment notNil ] whileTrue: [		segment visitWith: self.		segment := segment next ]! !!RSSegmentsVisitor methodsFor: 'visiting'!visitCloseSegment: aSegment! !!RSSegmentsVisitor methodsFor: 'visiting'!visitCubicSegment: aSegment! !!RSSegmentsVisitor methodsFor: 'visiting'!visitLineSegment: aSegment! !!RSSegmentsVisitor methodsFor: 'visiting'!visitMoveSegment: aSegment! !!RSSegmentsVisitor methodsFor: 'visiting'!visitQuadSegment: aSegment! !!RSBimetricEdgeBuilder methodsFor: 'private - utility'!edgeFrom: source to: target	| edge |	edge := super edgeFrom: source to: target.	edge		widthFrom: (widthFrom rsValue: edge model);		widthTo: (widthTo rsValue: edge model).	^ edge! !!RSBimetricEdgeBuilder methodsFor: 'accessing'!widthFrom	^ widthFrom! !!RSBimetricEdgeBuilder methodsFor: 'accessing'!widthFrom: anObject	widthFrom := anObject! !!RSBimetricEdgeBuilder methodsFor: 'accessing'!widthTo	^ widthTo! !!RSBimetricEdgeBuilder methodsFor: 'accessing'!widthTo: anObject	widthTo := anObject! !!RSLineBuilder class methodsFor: '*Roassal3-SVG'!bimetricLine	^ RSBimetricEdgeBuilder new: RSBimetricLine new! !!RSMultiBezierEdgeBuilder class methodsFor: 'instance creation'!multiBezier	^ self new: RSSVGPathLine new! !!RSMultiBezierEdgeBuilder methodsFor: 'private'!applyTensionOn: points	| n dp p1 ten |	n := points size - 1.	p1 := points first.	dp := points last - p1.	ten := self tension.	2 to: n do: [ :i| | p t |		p := points at: i.		t := (i -1)/n.		points at: i put: (1 - ten) * (p1 + (t * dp)) + (ten * p)]! !!RSMultiBezierEdgeBuilder methodsFor: 'private'!commonAncestor: edge with: selector	| a b aNodes bNodes sharedNode remove |	a := edge from.	b := edge to.	a == b ifTrue: [ ^ a ].	aNodes := self followersOf: a with: selector.	bNodes := self followersOf: b with: selector.	a := aNodes removeLast.	b := bNodes removeLast.	sharedNode := nil.	remove := [ :list | list		ifEmpty: [ nil ]		ifNotEmpty: [ list removeLast ] ].	[ a == b ] whileTrue: [		sharedNode := a.		sharedNode ifNil: [ ^ nil ].		a := remove value: aNodes.		b := remove value: bNodes. ].	^ sharedNode! !!RSMultiBezierEdgeBuilder methodsFor: 'private'!commonShapes: edge with: selector	"obtaint a list of points from the elements in the view based on a selector"	| from to ancestor shapes search index |	from := edge from.	to := edge to.	ancestor := self commonAncestor: edge with: selector.	ancestor ifNil: [		shapes := (self followersOf: from with: selector),			(self followersOf: to with: selector) reverse.		^ shapes ].	search := [ :model | canvas shapeFromModel: (selector rsValue: model) ].	shapes := OrderedCollection new.	shapes add: from.	[ from == ancestor ] whileFalse: [		from := search value: from model.		shapes add: from ].	index := shapes size.	[ to == ancestor ] whileFalse: [		shapes add: to afterIndex: index.		to := search value: to model ].	shapes do: [ :e | (e connectedLines includes: edge)		ifFalse: [ e addConnectedLine: edge ] ].	^ shapes! !!RSMultiBezierEdgeBuilder methodsFor: 'private'!followersOf: element with: selector	| t followers |	followers := OrderedCollection new.	t := element.	[ t notNil ] whileTrue: [		followers add: t.		t := canvas shapeFromModel: (selector rsValue: t model) ].	^ followers! !!RSMultiBezierEdgeBuilder methodsFor: 'public - line path'!following: selector	self shape svgPath: [ :line | [:builder |		| points commonShapes att a b |		att := line properties.		a := line startPoint.		b := line endPoint.		commonShapes := att			at: #commom			ifAbsentPut: [ self commonShapes: line with: selector ].		points := commonShapes collect: [ :e | e position asFloatPoint ].		points removeFirst; removeLast; addFirst: a; addLast: b.		self applyTensionOn: points.		builder absolute; moveTo: points first.		2 to: points size - 2 do: [ :i | | p1 p2 |			p1 := points at: i.			p2 := points at: i +1.			builder				curveVia: p1				to: (p1 + p2)/2 ].		builder			curveVia:( points at: points size -1)			to: points last ] ]! !!RSMultiBezierEdgeBuilder methodsFor: 'public - line path'!tension	^ tension ifNil: [ tension := 0.7 ]! !!RSMultiBezierEdgeBuilder methodsFor: 'public - line path'!tension: aNumberOrBlock	"tension should evaluate it and return a value between 0 and 1.	0 means straight lines	1 means a curve line"	tension := aNumberOrBlock! !!AthensCloseSegment methodsFor: '*Roassal3-SVG'!visitWith: visitor	visitor visitCloseSegment:  self! !"Roassal3-SVG"!!RSAbstractExamples commentStamp: '' prior: 0!I am the root class of all the examples of Roassal3. Examples contained in a subclass of myself are automatically run by the the test: TSExamplesTest>>testExamplesThe goal is to make the examples part of the tests.If you wish to add examples to Roassal3, then you need to subclass me.!!RSAnimationExamples commentStamp: '' prior: 0!I have examples for animation!!RSBasicAnimationExamples commentStamp: '' prior: 0!I have basic animation examples!!RSBasicShapeExamples commentStamp: '' prior: 0!I have the basic examples for shapes!!RSDSMExample commentStamp: '' prior: 0!RTDSMExample new installTitle: 'EvolutionDSM' 		code:'	| b option data labels input other |	option := #(collab gtinspector).	option := TRPlatform current dialogChooseFrom: option values: option.	option ifNil: [ ^ nil ].		data := RTTabTable new 		input: (RTDSMExample perform: option)		usingDelimiter: Character tab.	labels := data removeFirstRow.	input := Dictionary new.	other := Set new.	data values do: [ :line| | item timeline  | 		item := input at: (line second) ifAbsentPut: [ Dictionary new ].		other add: line third.		timeline := item at: line third ifAbsentPut: [ OrderedCollection new ].		timeline add: line first -> line fourth asNumber. ].	b := RTEvolutionDSM new.	b objectsY: input keys.	b objectsX: other.	b timeline: [ :assoc | (input at: assoc key) at: assoc value ifAbsent: [ nil ] ].	b labelShape		height: 30;		color: Color blue.	b shape shape allShapes first size: 100.	b shape shape allShapes second		size: 100;		values: [ :assoc| 			assoc timeline 				ifNil:  [ nil ]				ifNotNil: [ :ob | ob collect: #value ] ].	b selectElement: [ :e| e model score notNil ].	b score: [ :assoc | assoc score ].	^ b 	'!!RSHighlightableExamples commentStamp: '' prior: 0!Basic examples about highlighting!!RSInspectableExample commentStamp: '' prior: 0!I have examples of different ways to inspect views an objects in roassal3!!RSLayoutExamples commentStamp: '' prior: 0!I use the RSShapeBuilder!!RSRenderTreeExamples commentStamp: '' prior: 0!This class is used to customize the render collection of roassalcheck RSAbstractRenderCollection!!RSShapeExamples commentStamp: '' prior: 0!I use the RSShapeBuilder!!RSExpandingBoxes commentStamp: '' prior: 0!This is a simple example suggested by Nicolas Anquetil!!RSSearchInCanvasInteraction class methodsFor: '*Roassal3-Examples'!exampleCollection	| c shapes lb |	c := RSCanvas new.	shapes := Collection withAllSubclasses		collect: [ :n | RSEllipse new size: 20; model: n ]		as: RSGroup.	c addAll: shapes.	shapes @ RSPopup.	lb := RSLineBuilder line.	lb canvas: c.	lb connectFrom: #superclass.	RSTreeLayout on: shapes.	c @ RSCanvasController.	^ c open		setLabel: 'Press `s` to start the search';		yourself! !!RSSearchInCanvasInteraction class methodsFor: '*Roassal3-Examples'!exampleCollection2	| c classes g elements high con search |	c := RSCanvas new.	classes := Collection withAllSubclasses.	elements := classes collect: [ :cls |		g := RSGroup new			add: (RSLabel new text: cls name);			add: (RSEllipse new size: (cls numberOfMethods + 5) sqrt; color: Color blue );			yourself.		RSVerticalLineLayout new alignCenter; on: g.		g asShapeFor: cls ] as: RSGroup.	c addAll: elements.	high := RSHighlightable red.	elements @ high.	RSGridLayout new		lineItemsCount: 5;		on: elements.	con := RSCanvasController new.	con addInteraction: (search := self new		colorToHighlight: Color blue translucent;		yourself).	c @ con.	^ c open		setLabel: 'Press `s` to start the search';		yourself! !!RSLayout class methodsFor: '*Roassal3-Examples'!example1	^ RSGridLayout basicExample! !!RSLayout class methodsFor: '*Roassal3-Examples'!example2	^ RSTreeLayout basicExample! !!RSLayout class methodsFor: '*Roassal3-Examples'!example3	^ RSVerticalLineLayout basicExample! !!RSZoomLevelText class methodsFor: '*Roassal3-Examples'!exampleSimpleUML	| builder |	builder := RSUMLClassBuilder new.	builder classes: RSAttachPoint withAllSubclasses.	builder renderer: RSDarkUMLClassRenderer new.	builder build.	builder canvas @ self.	^ builder canvas open! !!RSAbstractExamples methodsFor: 'accessing'!label	^ self className! !!RSAbstractExamples methodsFor: 'accessing'!order	^ 100! !!RSAnimationExamples methodsFor: 'examples'!example01BoxWindmill	<script: 'self new example01BoxWindmill open'>	| canvas shapes extent points frameCount border |	canvas := RSCanvas new.	canvas aaNone.	canvas color: Color black.	extent := 1920@1080.	points := (0 to: extent x by: 50) flatCollect: [ :x |		(0 to: extent y by: 50) collect: [ :y | (x@y)- (extent/2) ] ].	border := RSBorder new		color: (Color gray alpha: 0.5);		yourself.	shapes := points collect: [ :p |		RSBox new			extent: 140@40;			model: p;			color: Color white;			border: border;			yourself  ].	canvas addAll: shapes.	frameCount := 0.	canvas newAnimation repeat;		onStepDo: [ :t |			shapes do: [ :s |				s matrix					loadIdentity;					translateBy: s model;					rotateByRadians: (s model x + s model y + frameCount) degreesToRadians * 1.95  ].			frameCount := frameCount + 1. ].	"canvas @ RSGraphCanvasMonitorInteraction."	^ canvas! !!RSAnimationExamples methodsFor: 'examples'!example02BoxesLineCircles	<script: 'self new example02BoxesLineCircles open'>	| c extent r shapes position alpha update updateLine lineX line |	c := RSCanvas new.	r := Random new.	shapes := (1 to: 12) collect: [ :i |		          RSBox new			          model: r next;			          noPaint;			          border: (RSBorder new					           width: 4;					           color: Color black);			          yourself ].	c addAll: shapes.	RSNormalizer size		from: 30;		to: 100;		shapes: shapes;		normalize: #yourself.	lineX := 0.	line := RSLine new		        color: Color red;		        width: 8;		        yourself;		        startPoint: 1 @ 0;		        endPoint: 0 @ 0;		        yourself.	c add: line.	position := nil.	updateLine := [	              line		              startPoint: lineX @ position from y;		              endPoint: lineX @ position to y ].	c		when: RSMouseMove		do: [ :ev |			lineX := ev position x.			updateLine value ]		for: self.	update := [	          extent := c extent.	          position := NSScale linear range: {			                      (extent / -2).			                      (extent / 2) }.	          updateLine value.	          shapes do: [ :e |		          e translateTo: (position scale: r next @ r next) ] ].	update value.	c when: RSExtentChangedEvent do: update for: self.	"shadow"	alpha := NSScale linear		         domain: #( 1 4 );		         range: #( 0.4 0.05 ).	shapes do: [ :e |		| ant |		ant := e.		1 to: 4 do: [ :i |			| s |			s := RSBox new				     noPaint;				     position: e position;				     extent: e extent;				     border: (RSBorder new						      width: 6;						      color: (e border color alpha: (alpha scale: i)));				     yourself.			ant				when: RSPositionChangedEvent				do: [ :evt | s translateTo: evt oldPosition ]				for: self.			ant := s.			c add: s ] ].	c newAnimation		repeat;		onStepDo: [ :t |			| round empty |			round := RSCornerRadius new radius: 100.			empty := RSCornerRadius new.			shapes do: [ :shape |					| delta newX |					delta := shape propertyAt: #delta ifAbsentPut: [ 5 ].					newX := shape position x + delta.					(newX between: position from x and: position to x) ifFalse: [							delta := delta negated.							newX := shape position x + delta ].					shape translateTo: newX @ shape position y.					shape propertyAt: #delta put: delta ].			c nodes copy do: [ :shape |					| corner |					corner := shape position x > lineX						          ifTrue: [ round ]						          ifFalse: [ empty ].					shape cornerRadius: corner ] ].	^ c! !!RSAnimationExamples methodsFor: 'examples'!example03Atom	<script: 'self new example03Atom open'>	| shapes canvas border extent speed frame |	canvas := RSCanvas new.	border := RSBorder new width: 4.	extent := 450 @ 110.	shapes := {		          (40 @ 40).		          extent.		          extent.		          extent.		          extent } collectWithIndex: [ :m :index |		          | ellipse |		          ellipse := RSEllipse new			                     border: border;			                     extent: m;			                     noPaint;			                     yourself.		          ellipse matrix rotateByRadians: index * Float pi / 4.		          index = 1 ifTrue: [ ellipse color: Color black ].		          ellipse ].	canvas addAll: shapes.	shapes := (1 to: 4) collect: [ :m |		          RSEllipse new			          border: border;			          color: Color black;			          extent: 20 asPoint;			          yourself ].	canvas addAll: shapes.	frame := 0.	canvas newAnimation repeat onStepDo: [ :t |		frame := frame + 1.		speed := frame / 50.		shapes doWithIndex: [ :shape :index |			| ang |			ang := speed + (index * 90).			shape matrix				loadIdentity;				rotateByRadians: index * Float pi / 4;				translateBy: extent / 2 * (ang cos @ ang sin) ] ].	canvas		when: RSExtentChangedEvent		do: [ :evt | canvas zoomToFit ]		for: self.	^ canvas! !!RSAnimationExamples methodsFor: 'examples'!example05ElasticEllipses	<script: 'self new example05ElasticEllipses open'>	| canvas random mouseClick |	canvas := RSCanvas new.	random := Random new.	mouseClick := [	              | c1 c2 color |	              canvas nodes copy do: #remove.	              c1 := Color		                    r: random next		                    g: random next		                    b: random next.	              c2 := Color		                    r: random next		                    g: random next		                    b: random next.	              color := NSScale linear range: {			                       c1.			                       c2 }.	              1 to: 10000 do: [ :i |		              | shape radius ang overlapped |		              shape := RSEllipse new.		              shape radius: random next * 30 + 2.		              radius := random next * 250.		              ang := random next * Float pi * 2.		              shape position: radius * (ang cos @ ang sin).		              overlapped := canvas nodes anySatisfy: [ :other |			                            (other position distanceTo:				                             shape position)			                            < (shape radius + other radius * 1.4) ].		              overlapped ifFalse: [			              canvas add: shape.			              shape propertyAt: #radius put: shape radius.			              shape color:				              (color scale:					               (shape position distanceTo: 0 @ 0) / 250) ] ].	              canvas newAnimation		              easing: RSEasingInterpolator elasticOut;		              onStepDo: [ :t |			              canvas nodes do: [ :shape |					              | scale |					              scale := NSScale linear range: {								                       1.								                       (shape propertyAt: #radius) }.					              shape radius: (scale scale: t) ] ] ].	mouseClick value.	canvas		when: RSExtentChangedEvent		do: [ :evt | canvas zoomToFit ]		for: self;		when: RSMouseClick do: mouseClick for: self.	^ canvas! !!RSAnimationExamples methodsFor: 'lines'!example06LinePatterns	<script: 'self new example06LinePatterns open'>	| canvas step frame border dot bar radius data update ap |	canvas := RSCanvas new.	step := 0.	frame := 0.	bar := 200.	radius := 150.	data := (1 to: 360 by: 3) collect: #degreesToRadians.	canvas add: (RSBox new			 noPaint;			 size: 640;			 yourself).	border := RSBorder new		          color: (Color colorFrom: '00004A');		          width: 2.	dot := [	       RSBox new		       size: 5;		       border: border;		       yourself ].	ap := RSCenteredAttachPoint new.	update := [	          canvas nodes copy do: #remove.	          canvas addAll: (data collect: [ :radian |			           | matrix line d1 d2 |			           "lines do not handle matrix"			           matrix := AthensAffineTransform new.			           matrix				           translateBy: radius * (radian cos @ radian sin);				           rotateByRadians:					           radian + (radian * step * 5) + (frame * 0.02).			           d1 := dot value.			           d2 := dot value.			           d1 position: (matrix transform: bar / 2 @ 0).			           d2 position:				           (matrix transform: bar / -2 * radian cos @ 0).			           d2 size: 6 * radian cos.			           canvas				           add: d1;				           add: d2.			           line := RSLine new.			           line border: border.			           line from: d1.			           line to: d2.			           line attachPoint: ap.			           line ]) ].	canvas newAnimation repeat onStepDo: [ :t |		frame := frame + 1.		update value ].	canvas		when: RSExtentChangedEvent		do: [ :evt | canvas zoomToFit ]		for: self;		when: RSMouseClick do: [			step := step + 1.			step > 20 ifTrue: [ step := 0 ] ]		for: self.	^ canvas! !!RSAnimationExamples methodsFor: 'examples'!example07CircleParty	<script: 'self new example07CircleParty open'>	| canvas x x2 speed speed2 random shape color |	canvas := RSCanvas new.	x := 1. x2 := 2.	speed := 5. speed2 := 10.	random := Random new.	color := NSScale ordinal rangeFrom: {		(Color colorFrom: 'B4FA05') alpha: 0.7.		'FF7C7C'.		(Color colorFrom: 'EA323E') alpha: 0.5.		'BDEA5C'.		(Color colorFrom: 'CB1D34') alpha: 0.3.		'E0CC14'}.	canvas color: Color black.	shape := [ :m |		RSEllipse new			border: (RSBorder new				width: 25;				color: (Color					r: (random rsNext: 0 and: 40)					g: (random rsNext: 100 and: 200)					b: (random rsNext: 100 and: 255));				yourself);			color: (color scale: m);			position: m key;			size: m value;			yourself		].	canvas newAnimation repeat onStepDo: [:t |		canvas nodes copy do: #remove.		color dictionary keysAndValuesRemove: [:a :b| true ].		(x between: 0 and: 1000) ifFalse: [ speed := speed negated ].		x2 >= x ifTrue: [			speed2 := speed2 negated.			x2 > 20 ifTrue: [ x2 := x2 - 20 ] ].		x2 <= 0 ifTrue: [ speed2 := speed2 negated ].		x := x + speed.		x2 := x2 + speed2.		canvas add: (shape value: 0@0 -> x).		canvas add: (shape value: 0@0 -> x2).		canvas add: (shape value: -300 asPoint -> x).		canvas add: (shape value: -300 asPoint -> x2).		canvas add: (shape value: 300 asPoint -> x).		canvas add: (shape value: 300 asPoint -> x2).		].	canvas camera scale: 0.5.	^ canvas! !!RSAnimationExamples methodsFor: 'examples'!example08ArcTree	<script: 'self new example08ArcTree open'>	| canvas newArc alpha beta |	canvas := RSCanvas new.	newArc := nil.	newArc := [ :point :size :iteration |	          | arc |	          arc := RSPieSlice new		                 color: Color black;		                 index: iteration;		                 innerRadius: size * 0.9;		                 externalRadius: size;		                 yourself.	          arc position: point.	          canvas add: arc.	          iteration > 1 ifTrue: [		          newArc			          value: point + (0 - size @ (size / 2 - (size * 0.01)))			          value: size / 2			          value: iteration - 1.		          newArc			          value: point + (size @ (size / 2 - (size * 0.01)))			          value: size / 2			          value: iteration - 1 ] ].	newArc value: 0 @ 0 value: 100 value: 5.	alpha := NSScale linear range: #( 90 0 ).	beta := NSScale linear range: #( 90 180 ).	canvas showEncompassingRectangles.	canvas animationFrom: ((1 to: 5) reverse collect: [ :i |			 | shapes |			 shapes := canvas nodes select: [ :e | e index = i ].			 canvas transitionAnimation				 duration: 1 seconds;				 easing: RSEasingInterpolator bounceOut;				 onStepDo: [ :t |					 shapes do: [ :e |							 e								 alphaAngle: (alpha scale: t);								 betaAngle: (beta scale: t);								 resetPath ] ] ]).	canvas		when: RSExtentChangedEvent		do: [			canvas				zoomToFit;				signalUpdate ]		for: self.	^ canvas! !!RSAnimationExamples methodsFor: 'perlin'!example09PerlinParticles	<script:	'self new example09PerlinParticles  open setLabel: ''Particles!!!!!! :V'''>	| canvas label particle random frame perlin color |	canvas := RSCanvas new.	random := Random new.	frame := 0.	perlin := NSPerlinNoise new.	label := RSLabel new		         color: Color black;		         text: 'Drag to draw. type ''c'' to clear the view'.	canvas addShape: label.	canvas newAnimation		delay: 2 seconds;		from: Color black;		to: Color transparent;		on: label set: #color:;		when: RSAnimationEndEvent do: [			canvas shouldClearBackground: false.			label remove ]		for: self.	color := RSGradientPalette fabledSunset asScale.	color domain: color domain reverse.	particle := [ :m |	            | ang vel att lifeSpan decay passedLife weightRange update shape |	            shape := RSEllipse new		                     withBorder;		                     position: m key;		                     yourself.	            att := shape properties.	            ang := random next * Float pi * 2.	            vel := random next * 5 * (ang cos @ ang sin).	            lifeSpan := random rsNext: 30 and: 90.	            decay := random rsNext: 0.75 and: 0.9.	            passedLife := 0.	            weightRange := random rsNext: 3 and: 50.	            att at: #dead put: false.	            "in this case use a class"	            update := [	                      | radius rn acc mag pos dir rand alpha |	                      att at: #dead put: passedLife >= lifeSpan.	                      passedLife := passedLife + 1.	                      acc := lifeSpan - passedLife / lifeSpan.	                      alpha := acc max: 0.4.	                      shape border color: (Color black alpha: alpha).	                      shape color: (color scale: acc asFloat).	                      radius := acc * weightRange.	                      pos := shape position.	                      rn := 4 * Float pi	                            * ((perlin noise: 0.02 and: 0.02) - 0.5).	                      mag := (perlin		                              noise: pos y + frame * 0.01		                              and: pos x + frame * 0.01) abs.	                      dir := rn cos @ rn sin.	                      ang := random next * Float pi * 2.	                      rand := ang cos @ ang sin * 0.5.	                      acc := dir * mag + rand.	                      vel := vel + acc * decay.	                      vel := vel normalized * 3.	                      shape size: radius.	                      shape translateBy: vel ].	            att at: #update put: update.	            shape ].	canvas newAnimation		repeat;		onStepDo: [ :t |			frame := frame + 30.			canvas nodes copy do: [ :e |					(e propertyAt: #update) value.					(e propertyAt: #dead) ifTrue: [ e remove ] ].			canvas signalUpdate ].	canvas		when: RSMouseDragging do: [ :evt |			1 to: 10 do: [ :i |					| p |					p := particle value: evt position -> (i + canvas nodes size).					canvas add: p ].			canvas signalUpdate ]		for: self;		when: RSKeyUp do: [ :evt |			evt keyName = 'C' ifTrue: [					canvas shouldClearBackground: true.					canvas nodes copy do: #remove.					canvas signalUpdate.					canvas newAnimation						duration: 200 milliSeconds;						when: RSAnimationEndEvent						do: [ canvas shouldClearBackground: false ] ] ]		for: self.	^ canvas! !!RSAnimationExamples methodsFor: 'perlin'!example09b	<script: 'self new example09b  open setLabel: ''Particles!!!!!! :V'''>	| canvas label particle random frame perlin changeHue hIndex hExtent h |	canvas := RSCanvas new.	canvas color: Color black.	random := Random new.	frame := 0.	perlin := NSPerlinNoise new.	label := RSLabel new		         color: Color white;		         text: 'Drag to draw. type ''c'' to clear the view.'.	canvas addShape: label.	canvas newAnimation		delay: 2 seconds;		from: Color black;		to: Color transparent;		on: label set: #color:;		when: RSAnimationEndEvent do: [			canvas shouldClearBackground: false.			label remove ]		for: self.	hIndex := 4.	changeHue := [	             hIndex := hIndex + 1.	             hIndex > 4 ifTrue: [ hIndex := 0 ].	             hExtent := NSScale linear		                        domain: #( 0 1 2 3 4 );		                        range: {				                        (220 @ 100).				                        (55 @ 0).				                        (100 @ 20).				                        (180 @ 110).				                        (255 @ 150) };		                        scale: hIndex.	             hExtent := hExtent * 360 / 255.	             h := hExtent y ].	changeHue value.	particle := [ :m |	            | ang vel att lifeSpan decay passedLife update sizeMult shape |	            shape := RSEllipse new		                     position: m key;		                     yourself.	            att := shape properties.	            ang := random next * Float pi * 2.	            vel := random next * 5 * (ang cos @ ang sin).	            lifeSpan := random rsNext: 30 and: 90.	            decay := random rsNext: 0.75 and: 0.9.	            passedLife := 0.	            h := h + 0.5.	            h > hExtent x ifTrue: [ h := hExtent y + h - hExtent x ].	            shape color: ((Color h: h s: 1 v: 1) alpha: 0.2).	            sizeMult := ((frame * 0.02) sin max: 0.05) min: 0.5.	            att at: #dead put: false.	            "in this case use a class"	            update := [	                      | radius rn acc mag pos dir rand |	                      att at: #dead put: passedLife >= lifeSpan.	                      passedLife := passedLife + 1.	                      acc := lifeSpan - passedLife.	                      radius := acc * sizeMult.	                      pos := shape position.	                      rn := 4 * Float pi	                            * ((perlin noise: 0.02 and: 0.02) - 0.5).	                      mag := (perlin		                              noise: pos y + frame * 0.01		                              and: pos x + frame * 0.01) abs.	                      dir := rn cos @ rn sin.	                      ang := random next * Float pi * 2.	                      rand := ang cos @ ang sin * 0.5.	                      acc := dir * mag + rand.	                      vel := vel + acc * decay.	                      vel := vel normalized * 3.	                      shape size: radius.	                      shape translateBy: vel ].	            att at: #update put: update.	            shape ].	canvas newAnimation		repeat;		onStepDo: [ :t |			frame := frame + 30.			canvas nodes copy do: [ :e |					(e propertyAt: #update) value.					(e propertyAt: #dead) ifTrue: [ e remove ] ].			canvas signalUpdate ].	canvas		when: RSMouseDragging do: [ :evt |			1 to: 10 do: [ :i |					| p |					p := particle value: evt position -> (i + canvas nodes size).					canvas add: p ].			canvas signalUpdate ]		for: self;		when: RSKeyUp do: [ :evt |			evt keyName = 'C'				ifTrue: [					canvas shouldClearBackground: true.					canvas nodes copy do: #remove.					canvas signalUpdate.					canvas newAnimation						duration: 200 milliSeconds;						when: RSAnimationEndEvent						do: [ canvas shouldClearBackground: false ] ]				ifFalse: changeHue ]		for: self.	^ canvas! !!RSAnimationExamples methodsFor: 'perlin'!example10Arcs	<script: 'self new example10Arcs open setLabel: ''Arc animation'''>	| canvas beta shapes theta step size |	theta := 0.	step := 12.	size := 21.	canvas := RSCanvas new.	canvas color: Color black.	beta := NSScale linear		        domain: #( -1 1 );		        range: #( 180 360 ).	shapes := (1 to: size) collect: [ :m |		          RSPieSlice new			          model: m;			          innerRadius: m * step;			          externalRadius: m * step + 5;			          alphaAngle: 180;			          yourself ].	canvas addAll: shapes.	canvas newAnimation repeat onStepDo: [ :t |		theta := theta + 0.0523.		shapes do: [ :shape |			| m offset |			m := shape model.			offset := Float pi * 2 / size * m.			shape				color: (Color h: theta * 2 + (m * 10) s: 1 l: 0.5);				betaAngle: (beta scale: (theta + offset) sin) ] ].	canvas		when: RSExtentChangedEvent		do: [			| s sc e |			s := size * step + 5 * 2.			e := canvas extent.			sc := e x / s.			canvas camera scale: sc.			canvas newAnimation				from: 0 @ 0;				to: 0 @ (e y / sc) / 2;				on: canvas camera set: #translateTo: ]		for: self.	^ canvas! !!RSAnimationExamples methodsFor: 'examples'!example11C	<script: 'self new example11C open setLabel: ''C!!!!!!'''>	| canvas shapes step theta |	canvas := RSCanvas new.	canvas color: Color black.	step := 15.	theta := 0.	shapes := (1 to: 16) collect: [ :m |		          RSPieSlice new			          model: m;			          innerRadius: m * step + 7;			          externalRadius: m * step + 10;			          yourself ].	canvas addAll: shapes.	canvas newAnimation repeat onStepDo: [ :t |		theta := theta + 0.4.		shapes do: [ :shape |			| m |			m := shape model.			shape				alphaAngle: 30 + (theta * m);				betaAngle: 300 + (theta * m);				color: (Color h: theta * m s: 1 l: 0.5) ] ].	canvas when: RSExtentChangedEvent do: [ canvas zoomToFit ] for: self.	^ canvas! !!RSAnimationExamples methodsFor: 'examples'!example12Sky	<script: 'self new example12Sky open setLabel: ''Star trails'''>	<noTest>	| canvas client image ext dots random frame box colors |	canvas := RSCanvas new.	random := Random new.	ext := 2200 @ 2200.	box := RSBox new		extent: ext;		position: 0 @ ext y / 2 negated;		paint:			(LinearGradientPaint new				colorRamp:					{(0 -> Color black).					(1 -> Color blue muchDarker)};				start: ext / 2 negated;				stop: ext / 2).	canvas addShape: box.	colors := NSScale linear		domain: #(5 15);		range: {'6A6569' . 'white'}.	dots := (1 to: 800) collect: [ :n |		| e |		e := RSEllipse new			propertyAt: #a put: (random rsNext: 0 and: 350);			propertyAt: #r put: (random rsNext: 3500 and: 6000);			size: (random rsNext: 5 and: 15);			yourself.		e color: ((colors scale: e width) alpha: (random rsNext: 0.1 and: 0.8)).		e ].	canvas addAll: dots.	frame := 0.	canvas shouldClearBackground: false.	(canvas newAnimation duration: 5 seconds;onStepDo: [ :t| ])		when: RSAnimationEndEvent do: [ box remove ].	canvas newAnimation repeat		onStepDo: [ :t |			frame := frame + 0.1.			dots				do: [ :e |					| ang radius |					ang := ((e propertyAt: #a) + frame) degreesToRadians.					radius := e propertyAt: #r.					e position: ang cos @ ang sin negated * radius + (2500 @ 3000) ] ].	(client := ZnEasy client)		url:			'http://www.transparentpng.com/download/mountain/68IzPF-mountain-clipart-png-photos.png';		accept: ZnMimeType imagePng;		signalProgress: true;		get.	image := ImageReadWriter formFromStream: client entity readStream.	canvas addShape: (RSBitmap new form: image).	canvas		when: RSExtentChangedEvent		do: [ | e s |			e := canvas extent.			s := e x / 2200.			"2200 x 800 = image extent"			canvas camera				scale: s;				translateTo: 0 @ (e y / s - 800) / 2 negated ].	^ canvas! !!RSAnimationExamples methodsFor: 'perlin'!example13ArcNoise	<script:	'self new example13ArcNoise open setLabel: ''Arcs with Perlin noise'''>	| frame canvas perlin radius line points yscale |	frame := 0.	canvas := RSCanvas new.	canvas color: Color black.	perlin := NSPerlinNoise new.	radius := NSScale linear		          domain: #( 1 20 );		          range: #( 50 250 ).	canvas addAll: ((1 to: 20) collect: [ :n |			 | r |			 r := radius scale: n.			 RSPieSlice new				 color: Color white;				 externalRadius: r;				 alphaAngle: 0;				 innerRadius: r - 5;				 yourself ]).	canvas addShape: (RSBox new			 color: (Color white alpha: 0.4);			 cornerRadius: 7;			 extent: 140 @ 80;			 position: 70 @ 40;			 isFixed: true).	points := OrderedCollection new.	yscale := NSScale linear		          domain: #( 0 360 );		          range: #( 80 5 ).	line := RSPolyline new		        border: (RSBorder new				         width: 2;				         paint: ((LinearGradientPaint fromArray: {								           (0 -> 'red').								           (0.5 -> 'yellow').								           (1 -> 'green') })						          start: 0 @ 0;						          stop: 0 @ 80;						          yourself);				         yourself);		        isFixed: true;		        yourself.	canvas addShape: line.	canvas newAnimation		repeat;		onStepDo: [ :t |			| last temp |			frame := frame + 0.2.			canvas nodes do: [ :arc |					temp := frame * 0.025 + (arc externalRadius * 0.0005).					arc betaAngle: 360 * (perlin noise: temp and: 0.01) abs.					arc color: (Color h: arc betaAngle s: 0.5 v: 1) ].			last := canvas nodes last.			points add: (yscale scale: last betaAngle).			points size > 140 ifTrue: [ points removeFirst ].			line controlPoints: (points collectWithIndex: [ :y :x | x @ y ]) ].	canvas when: RSExtentChangedEvent do: [ canvas zoomToFit ] for: self.	^ canvas! !!RSAnimationExamples methodsFor: 'perlin'!example14Retina	<script: 'self new example14Retina open setLabel: ''Retina (~o.o)~'''>	| random canvas perlin side angle circleSize ringSize label minR updateValues offset rad val radius |	canvas := RSCanvas new.	canvas color: Color black.	minR := 0.08.	side := 900.	perlin := NSPerlinNoise new.	circleSize := ringSize := 100.	random := Random new.	angle := NSScale linear		         domain: {				         1.				         circleSize };		         range: { 0. 360 }.	label := RSLabel new		         fontName: 'Source Sans Pro';		         text: 'Now begin!!';		         color: Color white;		         fontSize: 40.	canvas addShape: label.	canvas newAnimation		delay: 2 seconds;		from: 40;		to: 12;		on: label set: #fontSize:.	(canvas newAnimation		 delay: 2 seconds;		 from: Color white;		 to: Color transparent;		 on: label set: #color:)		when: RSAnimationEndEvent		do: [			label remove.			canvas shouldClearBackground: false ]		for: self.	updateValues := [	                offset := random rsNext: 90.	                rad := random		                       rsNext: minR * side		                       and: 1 / 2 sqrt * side.	                val := rad / side * 100.	                radius := rad / (side / 2) - minR	                          * (perlin noise: val and: 0) abs * side / 6 ].	updateValues value.	canvas addAll: ((1 to: circleSize) collect: [ :m |			 RSEllipse new				 noPaint;				 withBorder;				 yourself ]).	canvas newAnimation		delay: 4 seconds;		loops: ringSize;		duration: 200 milliSeconds;		when: RSAnimationLoopEvent do: [ :evt |			updateValues value.			canvas nodes doWithIndex: [ :e :index |					| theta |					theta := angle scale: index.					e border color: (Color								 h: theta + offset								 s: 1								 v: 1								 alpha: 0.7).					theta := theta degreesToRadians.					e size: radius.					e position: theta cos @ theta sin * rad ] ]		for: self.	canvas		when: RSExtentChangedEvent		do: [ canvas camera zoomToFit: canvas extent extent: side @ side ]		for: self.	^ canvas! !!RSAnimationExamples methodsFor: 'examples'!example15SpaceDandy	<script: 'self new example15SpaceDandy open setLabel: ''Space :D'''>	| random extent diagonal rotation init drawDist canvas shapes |	random := Random new.	extent := 800 @ 600.	diagonal := (extent x * extent x + (extent y * extent y)) sqrt / 2.	rotation := 0.	init := [ :e |	        | n |	        e properties		        at: #l put: 1;		        at: #n put: (n := random rsNext: 1 and: extent x / 2);		        at: #r put: (random rsNext: Float pi * 2);		        at: #off put: (random rsNext: 90);		        at: #o		        put:			        (random rsNext: 1 and: (random rsNext: 1 and: extent x / n)) ].	drawDist := [ :att |	            | n o |	            n := att at: #n.	            o := att at: #o.	            (n / o) arcTan * extent x / (Float pi / 2) ].	canvas := RSCanvas new.	canvas color: Color black.	shapes := (1 to: 500) collect: [ :m |		          RSEllipse new			          color: Color white;			          yourself ].	shapes do: [ :e | init value: e ].	canvas addAll: shapes.	canvas addShape: (RSLabel new			 paint: ((LinearGradientPaint fromArray: {							   (0 -> 'yellow').							   (0.35 -> 'orange').							   (0.25 -> Color white darker).							   (0.35 -> 'orange').							   (1 -> 'white') })					  start: 0 @ -150;					  stop: 0 @ 130;					  yourself);			 fontSize: 150;			 fontName: 'Brushcrazy DEMO';			 withBorder;			 bold;			 text: 'Pharo';			 yourself).	canvas newAnimation		repeat;		duration: 5 seconds;		when: RSAnimationLoopEvent		do: [ :e |			canvas shouldClearBackground: e animation currentLoop odd ]		for: self.	canvas newAnimation repeat onStepDo: [ :t |		rotation := rotation - 0.002.		shapes do: [ :e |			| l o r d off |			l := (e propertyAt: #l) + 1.			e propertyAt: #l put: l.			r := (e propertyAt: #r) + rotation.			o := e propertyAt: #o.			off := e propertyAt: #off.			d := drawDist value: e properties.			e color:				((Color					  h: (e properties at: #r) radiansToDegrees + off					  s: 1					  v: 0.5) alpha: d / diagonal).			e size: extent x / o / 8.			e position: r cos @ r sin * d.			e propertyAt: #o put: o - 0.07.			(drawDist value: e properties) > diagonal ifTrue: [ init value: e ] ] ].	canvas		when: RSExtentChangedEvent		do: [ canvas camera zoomToFit: canvas extent extent: extent ]		for: self.	^ canvas! !!RSAnimationExamples methodsFor: 'examples'!example16Gris	<script: 'self new example16Gris open setLabel: ''Roassal :V'''>	| c label shape border r mini animation g |	c := RSCanvas new.	r := Random new.	border := RSBorder new.	label := RSLabel new		         fontName: 'Marker Felt';		         text: 'Roassal';		         noPaint;		         border: border;		         fontSize: 30.	c addShape: label.	c addAll:		({ 0.6. 0.64. 1.05. 1.20. 1.7 } collectWithIndex: [ :m :i |			 | s |			 s := RSEllipse new				      noPaint;				      radius: m * label width;				      border: border;				      yourself.			 i = 5 ifTrue: [ s border: (RSBorder new width: 1.5) ].			 i = 4 ifTrue: [ s border: (RSBorder new dashArray: #( 4 )) ].			 s ]).	c newAnimation repeat		from: 0;		to: 8;		duration: 200 milliSeconds;		on: c nodes fourth border set: #dashOffset:.	mini := [ :m |	        | s |	        s := RSEllipse new		             noPaint;		             radius: m * 5;		             border: (RSBorder new width: 0.5);		             yourself.	        m = 1 ifTrue: [ s paint: Color black ].	        m = 2 ifTrue: [ s radius: m * 6 ].	        s ].	animation := [ :s :seconds :target :dir |	             | ang |	             ang := r next * Float pi * 2.	             c newAnimation repeat		             duration: seconds asSeconds;		             from: ang;		             to: ang + (Float pi * 2 * dir);		             onStepDo: [ :t |			             s translateTo: t cos @ t sin * target radius ] ].	c addAll: ({			 (3 -> 3).			 (4 -> 2) } collect: [ :m |			 | s |			 s := RSComposite new				      shapes: ((1 to: m value) collect: [ :k | mini value: k ]);				      yourself.			 animation				 value: s				 value: m key * 6				 value: (c nodes at: m key)				 value: 1.			 s ]).	g := (1 to: 4) collect: [ :m | mini value: m ] as: RSGroup.	g first radius: 10.	g second radius: 15.	g third radius: 18.	g fourth radius: 25.	g add: ((mini value: 1) radius: 3).	shape := RSComposite new		         shapes: g;		         yourself.	c add: shape.	animation		value: shape		value: 30		value: c nodes fifth		value: -1.	animation		value: shape shapes fifth		value: 10		value: shape shapes fourth		value: 1.	c when: RSExtentChangedEvent do: [ c zoomToFit ] for: self.	^ c! !!RSAnimationExamples methodsFor: 'examples'!example17Flor	<script: 'self new example17Flor open setLabel: ''Animation test'''>	| c frame angleSp alphaS hueS dia1 dia2 |	c := RSCanvas new.	frame := 0.	angleSp := 0.	hueS := NSScale linear		        domain: #( 50 200 );		        range: #( 250 360 ).	alphaS := NSScale linear		          domain: #( 50 200 );		          range: #( 0.3 1 ).	dia1 := NSScale linear		        domain: #( 50 180 );		        range: #( 90 1 ).	dia2 := NSScale linear		        domain: #( -1 1 );		        range: #( 5 20 ).	(0 to: 350 by: 60) do: [ :i |		(50 to: 170 by: 10) do: [ :m |			| color |			color := Color				         h: (hueS scale: m)				         s: 0.8				         v: 1				         alpha: (alphaS scale: m).			c addShape: (RSEllipse new					 color: color;					 model: i -> m;					 yourself) ] ].	c newAnimation repeat onStepDo: [ :t |		frame := frame + 1.		angleSp := frame / 250.0 * (Float pi * 2).		c shapes do: [ :s |			| angle i m dist diameter |			i := s model key.			m := s model value.			angle := (i + (angleSp sin * m)) degreesToRadians.			s position: m * (angle cos @ angle sin).			dist := s position distanceTo: 0 @ 0.			diameter := dia2 scale: (dia1 scale: dist) sin.			s extent: diameter asPoint ].		c signalUpdate ].	c		when: RSExtentChangedEvent		do: [ c camera zoomToFit: c extent extent: 500 asPoint ]		for: self.	^ c! !!RSAnimationExamples methodsFor: 'perlin'!example18Rainbow	<script: 'self new example18Rainbow open setLabel: ''Worms'''>	| canvas random shape mode color frame border |	canvas := RSCanvas new.	canvas shouldClearBackground: false.	canvas color: Color black.	random := Random new.	border := RSBorder new		          width: 0.5;		          yourself.	shape := [	         | e att xs ys |	         e := RSEllipse new.	         e border: border.	         att := e properties.	         xs := random rsNext: -3 and: 3.	         ys := (xs between: -1 and: 1)		               ifTrue: [			               random next > 0.5				               ifTrue: [ random rsNext: 1 and: 3 ]				               ifFalse: [ random rsNext: -3 and: -1 ] ]		               ifFalse: [ random rsNext: 3 and: -3 ].	         att		         at: #s put: 0;		         at: #t put: 0;		         at: #degX put: random next;		         at: #degY put: random next;		         at: #xs put: xs;		         at: #ys put: ys;		         at: #hue put: random next * 360;		         at: #hue2 put: 4.	         e ].	mode := 1.	frame := 0.	color := NSScale ordinal		         domain: #( 0 1 2 );		         range: {				         [ Color black ].				         [ :e | Color h: (e propertyAt: #hue) s: 0.7 v: 1 ].				         [ :e |				         frame even					         ifTrue: [ Color black ]					         ifFalse: [ Color h: (e propertyAt: #hue) s: 1 v: 1 ] ] }.	canvas newAnimation repeat onStepDo: [ :k |		| shapes |		canvas add: shape value.		frame := frame + 1.		shapes := canvas shapes copy.		shapes do: [ :e |			| att t s degX degY xs ys hue hue2 |			att := e properties.			t := att at: #t.			s := att at: #s.			degX := att at: #degX.			degY := att at: #degY.			xs := att at: #xs.			ys := att at: #ys.			hue := att at: #hue.			hue2 := att at: #hue2.			e color: ((color scale: mode) rsValue: e).			e border color: (Color h: 360 - (att at: #hue) s: 1 v: 1).			e size: s.			t := t + 0.02.			s := s + 0.2.			e translateBy: xs @ ys + (degX cos @ degY cos) * t.			degX := degX + (random rsNext: 0.1 and: 0.8).			degY := degY + (random rsNext: 0.1 and: 0.8).			hue := hue + hue2.			(hue > 360 or: [ hue < 0 ]) ifTrue: [ hue2 := hue2 negated ].			att				at: #t put: t;				at: #s put: s;				at: #degX put: degX;				at: #degY put: degY;				at: #hue put: hue;				at: #hue2 put: hue2.			((Rectangle center: 0 @ 0 extent: canvas extent + 200)				 containsPoint: e position) ifFalse: [ e remove ] ] ].	canvas		when: RSExtentChangedEvent		do: [ canvas camera zoomToFit: canvas extent extent: canvas extent ]		for: self;		when: RSMouseClick do: [			mode := mode + 1.			mode > 2 ifTrue: [ mode := 0 ] ]		for: self.	^ canvas! !!RSAnimationExamples methodsFor: 'examples'!example19Stars	<script: 'self new example19Stars open setLabel: ''Stars'''>	| canvas color random stars |	canvas := RSCanvas new.	random := Random new.	color := NSScale linear		         domain: #( 0 10 );		         range: #( 'black' 'blue' ).	canvas addAll: ((1 to: 100) collect: [ :m |			 RSBox new				 size: 39;				 color: (color scale: m - 1 // 10);				 yourself ]).	RSGridLayout new		lineItemsCount: 10;		gapSize: 1;		on: canvas nodes.	stars := (1 to: 5) collect: [ :m |		         RSShapeFactory star			         withBorder;			         size: (random rsNext: 10 and: 100);			         position:				         (random rsNext: 50 and: 300)				         @ (random rsNext: 50 and: 300);			         color: Color white;			         yourself ].	canvas addAll: stars.	canvas newAnimation repeat		to: 360;		onStepDo: [ :t |			stars do: [ :star |					| position |					position := star position.					star matrix loadIdentity.					star translateTo: position.					star rotateByDegrees: t ] ].	canvas when: RSExtentChangedEvent do: [ canvas zoomToFit ] for: self.	^ canvas! !!RSAnimationExamples methodsFor: 'examples'!example20CircleWaves	<script: 'self new example20CircleWaves open setLabel: ''Waves'''>	| canvas shapes frame |	canvas := RSCanvas new.	frame := 0.	shapes := #( '15c108' '8d0402' '0002ab' ) collect: [ :m |		          RSPolygon new			          noPaint;			          border: (RSBorder new					           color: ((Color colorFrom: m) alpha: 0.5);					           width: 10;					           yourself);			          yourself ].	canvas addAll: shapes.	canvas newAnimation repeat onStepDo: [ :transition |		frame := frame + 0.02.		shapes doWithIndex: [ :poly :index |			| points |			points := RSPolygon				          generateUnitNgonPoints: 150				          rotation: 0				          angle: [ :a :i | a ]				          radius: [ :a :i |					          | t |					          t := frame.					          200 + ((a * 8 - (index * 2 * Float pi / 3) + t) cos					           * (1 + (a - t) cos / 2 raisedTo: 3) * 32) ].			poly				privatePoints: points;				resetPath ] ].	canvas		when: RSExtentChangedEvent		do: [ canvas camera zoomToFit: canvas extent extent: 500 @ 500 ]		for: self.	^ canvas! !!RSAnimationExamples methodsFor: 'lines'!example21Lines	<script: 'self new example21Lines open setLabel: ''.=.= Lines =.=.'''>	| canvas frame radius hueOffset angleSp shapes soffset size mult shape |	canvas := RSCanvas new.	canvas color: Color black.	frame := 0.	radius := 200.	hueOffset := 0.	angleSp := 0.	"<globals>"	soffset := nil.	size := nil.	mult := 0.	"</globals>"	shape := [ :array |	         array collect: [ :m |		         | com ang a line |		         com := RSComposite new.		         com model: m + soffset.		         ang := m degreesToRadians.		         a := Float halfPi + ang.		         com propertyAt: #offset put: a * size.		         line := RSLine new			                 width: 1.5;			                 yourself.		         com add: line.		         com translateTo: ang cos @ ang sin * radius * mult.		         com matrix rotateByRadians: a.		         com ] ].	soffset := 0.	size := 12.	mult := 1.	shapes := shape value: (0 to: 359 by: 12).	canvas addAll: shapes.	soffset := 180.	size := 8.	mult := 0.5.	shapes := shape value: (0 to: 359 by: 5).	canvas addAll: shapes.	soffset := 120.	size := 4.	mult := 0.5 @ 0.75.	shapes := shape value: (0 to: 359 by: 5).	canvas addAll: shapes. "	"	soffset := 240.	size := 4.	mult := 0.75 @ 0.5.	shapes := shape value: (0 to: 359 by: 5).	canvas addAll: shapes.	shapes := canvas nodes.	canvas addShape: (RSLabel new			 text: 'Roassal';			 fontSize: 30;			 border: (RSBorder new color: Color white);			 color: nil).	canvas newAnimation repeat onStepDo: [ :t |		frame := frame + 1.		angleSp := frame / 300 * Float twoPi.		hueOffset := hueOffset + 1.		shapes do: [ :s |			| pos line |			pos := (angleSp negated + (s propertyAt: #offset)) cos * 30.			line := s shapes first.			line color: (Color h: s model + hueOffset s: 0.6 v: 1).			line endPoint: 0 @ pos ] ].	canvas		when: RSExtentChangedEvent		do: [ canvas camera zoomToFit: canvas extent extent: 500 asPoint ]		for: self.	^ canvas! !!RSAnimationExamples methodsFor: 'lines'!example22Lines	<script: 'self new example22Lines open setLabel: ''Line patterns'''>	| canvas radius bar step frame label border |	canvas := RSCanvas new.	canvas color: (Color colorFrom: 'EEEEEE').	radius := 200.	bar := 180.	step := 1.	frame := 0.	border := RSBorder new		          color: Color lightGray;		          yourself.	canvas addAll: ((0 to: 360 by: 0.5) collect: [ :i |			 RSComposite new				 model: i;				 add: (RSLine new						  border: border;						  startPoint: bar negated / 2 @ 0;						  endPoint: bar / 2 @ 0;						  yourself);				 yourself ]).	canvas newAnimation repeat onStepDo: [ :t |		frame := frame + 4.		canvas nodes do: [ :s |			| radian |			radian := s model degreesToRadians.			s matrix				loadIdentity;				translation: radius * (radian cos @ radian sin);				rotateByRadians:					radian + (frame * (radian * step * 0.5) sin * 0.05) ] ].	label := RSLabel new		         text: 'Pharo';		         fontName: 'Brushcrazy DEMO';		         fontSize: 50;		         noPaint;		         bold;		         border: (RSBorder new				          paint: Color black;				          dashArray: #( 4 )).	canvas addShape: label.	canvas newAnimation repeat		from: 0;		to: 8;		on: label border set: #dashOffset:.	canvas		when: RSMouseClick		do: [			step := step + 0.5.			step > 11 ifTrue: [ step := 1 ] ]		for: self.	canvas		when: RSExtentChangedEvent		do: [ canvas camera zoomToFit: canvas extent extent: 640 @ 640 ]		for: self.	^ canvas! !!RSAnimationExamples methodsFor: 'perlin'!example23PerlinNoise	<script: 'self new example23PerlinNoise open setLabel: ''Perlin Noise'''>	"inpired by wangyasai Twitter: @yasai_wang"	| canvas random c1 c2 c3 size perlin noiseScale rec |	canvas := RSCanvas new.	rec := Rectangle floatCenter: 0@0 extent: self currentWorld extent.	random := Random new.	size := 200.	noiseScale := 300.	canvas shouldClearBackground: false.	perlin := NSPerlinNoise2 new.	canvas color: (Color colorFrom: '150832').	c1 := '45217C'. c2 := '0799F2'. c3 := 'white'.	canvas addAll: ((1 to: size) collect: [ :i |		| newcircle |		newcircle := [ :col | RSEllipse new			position: (random next* rec width)@(random next * rec height) + rec origin;			size: 0.1 + (i/size);			color: ((Color colorFrom: col) alpha: i*(250 / 255)/ size);			yourself ].		RSComposite new			model: i;			add: (newcircle value: c1);			add: (newcircle value: c2);			add: (newcircle value: c3);			yourself.			 ] ).	canvas newAnimation repeat onStepDo: [ :t | | speed |		speed := 0.4.		canvas nodes do: [ :c |			c shapes do: [ :e |				| angle p dir vel pval |				p := e position.				pval := perlin					noise: p x / noiseScale					and: p y / noiseScale.				pval := (pval + 1) / 2.				angle := Float twoPi * noiseScale * pval.				dir := angle cos @ angle sin.				vel := dir * speed.				p := p + vel.				(rec containsPoint: p) ifFalse: [					p := (random next * rec width )@(random next * rec height) + rec origin ].				e translateTo: p.				].			].		].	^ canvas! !!RSAnimationExamples methodsFor: 'perlin'!example24RoassalPerlinNoise	<script:	'self new example24RoassalPerlinNoise open extent: 800@500; setLabel: ''Roassal'''>	| canvas density rect maxLife size perlin r color noiseScale sc1 sc2 |	canvas := RSCanvas new.	canvas color: Color black.	canvas shouldClearBackground: false.	r := Random new.	perlin := NSPerlinNoise2 new.	density := 800.	maxLife := 10.	noiseScale := 800.	rect := Rectangle floatCenter: 0 @ 0 extent: self currentWorld extent.	size := rect width * rect height / density.	color := NSScale ordinal rangeFrom: { '6E39CC'. '0799F2'. 'white' }.	sc1 := NSScale linear		       domain: {				       1.				       size };		       range: #( 5 1 ).	sc2 := NSScale linear		       domain: {				       1.				       size };		       range: #( 1 2 ).	canvas addAll: ((1 to: size) collect: [ :i |			 RSEllipse new				 size: (sc2 scale: i);				 model: i;				 propertyAt: #flip put: (r next * 2) asInteger * 2 - 1;				 propertyAt: #life put: r next * maxLife;				 propertyAt: #color put: (color scale: (r next * 3) asInteger);				 position:					 r next * rect width @ (r next * rect height) + rect origin;				 yourself ]).	canvas newAnimation repeat onStepDo: [ :t |		canvas nodes do: [ :e |			| life att p flip iterations respawn case fadeRatio colorCase c |			att := e properties.			flip := att at: #flip.			life := att at: #life.			c := att at: #color.			life := life - 0.06667.			respawn := [			           e position:				           r next * rect width @ (r next * rect height)				           + rect origin.			           life := maxLife ].			life < 0 ifTrue: respawn.			att at: #life put: life.			p := e position - rect origin.			iterations := sc1 scale: e model.			1 to: iterations do: [ :i |				| angle dir |				angle := Float twoPi * noiseScale * flip				         * (perlin snoise: p x / noiseScale and: p y / noiseScale).				dir := angle cos @ angle sin * 1.2.				p := p + dir ].			case := p / rect extent.			case := (case x + case y / 2 * 3) asInteger.			p := p + rect origin.			e position: p.			(rect containsPoint: p) ifFalse: respawn.			fadeRatio := life * 5 min: 1.			fadeRatio := fadeRatio min: maxLife - life * 5 / maxLife.			colorCase := NSScale ordinal				             domain: #( 0 1 2 );				             range: {						             [ Color gray: life / maxLife ].						             [ c ].						             [						             Color							             r: c blue * 255 + 10							             g: c green * 255 - 20							             b: c red * 255 - 5							             range: 255 ] }.			c := (colorCase scale: case) value.			e color: (c alpha: fadeRatio) ] ].	canvas		when: RSExtentChangedEvent		do: [ canvas camera zoomToFit: canvas extent rectangle: rect ]		for: self.	^ canvas	"morph := v canvas morph.	morph extent: 800@500.	v2 := RSView new.	v2 color: Color black.	v2 addShape: (TSLabel new		text: 'Roassal3';		fontName: 'Impact';		fontSize: 150;		border: (TSBorder new color: Color white trans)).	v2 animation repeat onStepDo: [ :t| | paint |		morph drawOnMockCanvas.		paint := AthensCairoPatternSurfacePaint createForSurface: morph surface.		paint origin: ( -100@ -300) .		v2 shapes first paint: paint.		v2 signalUpdate ].	v2 when: TSExtentChangedEvent do: [ v zoomToFit ].	v2 open extent: 800@500; setLabel: 'Roassal'."! !!RSAnimationExamples methodsFor: 'examples'!example25AnimationCircle	<script:	'self new example25AnimationCircle open setLabel: ''Animation Test'''>	| canvas radius shapes update points lines sc1 sc2 |	canvas := RSCanvas new.	radius := 50.	lines := 1.	canvas addShape: (RSEllipse new			 color: Color black;			 radius: radius).	shapes := (1 to: 10) collect: [ :i |		          | e |		          e := RSEllipse new			               model: i;			               index: i;			               size: 5;			               color: Color white;			               yourself.		          i = 1 ifTrue: [ e color: Color red ].		          i = 2 ifTrue: [ e color: Color green ].		          e ].	points := [ :r :i |	          | a b slice |	          slice := Float twoPi / (lines * 2).	          a := i - 1 * slice + Float halfPi.	          b := a + Float pi.	          a := a cos @ a sin * r.	          b := b cos @ b sin * r.	          a -> b ].	update := [	          lines := lines + 1.	          lines > 10 ifTrue: [ lines := 2 ].	          canvas nodes copy do: #remove.	          canvas lines copy do: #remove.	          shapes do: [ :e | e model: e index - 1 / (lines * 2) ].	          1 to: lines do: [ :i |		          | ab |		          ab := points value: radius value: i.		          canvas add: (RSLine new				           width: 0.1;				           color: Color white;				           startPoint: ab key;				           endPoint: ab value;				           yourself).		          canvas add: (shapes at: i) ] ].	update value.	sc1 := NSScale linear range: {			       0.			       Float twoPi }.	sc2 := NSScale linear domain: #( -1 1 ).	shapes do: [ :e |		| animation |		animation := canvas newAnimation repeat			             duration: 2 seconds;			             onStepDo: [ :t |				             | val |				             val := e model + t % 1.				             val := (sc1 scale: val) cos.				             canvas edges size >= e index ifTrue: [						             | ab |						             ab := points value: radius - 2.5 value: e index.						             e position: (sc2									              range: {											              ab key.											              ab value };									              scale: val) ] ].		e index = 1 ifTrue: [			animation when: RSAnimationLoopEvent do: update for: self ] ].	canvas @ RSCanvasController.	^ canvas! !!RSAnimationExamples methodsFor: 'lines'!example26Bezier	<script: 'self new example26Bezier open setLabel: ''Bezier Test'''>	| canvas size theta sc borderWhite cpController |	canvas := RSCanvas new.	size := 50.	theta := 0.	canvas color: Color black.	sc := NSScale linear		      domain: #( -1 1 );		      range: #( 0 80 ).	cpController := RSBlockCPController new		                block: [ :line |			                | x1 |			                x1 := sc scale: (theta + (line model * 5)) sin.			                Array				                with: x1 @ 0				                with: 100 @ -100				                with: 100 @ 50				                with: 200 @ -120 ];		                yourself.	borderWhite := RSBorder new		               color: Color white;		               yourself.	canvas addAll: ((1 to: size) collectWithIndex: [ :m :index |			 | com offset line |			 com := RSComposite new.			 offset := Float twoPi / size * index.			 com matrix rotateByRadians: offset.			 line := RSBezier new				         color: Color white;				         model: offset;				         width: 2;				         controlPointsController: cpController;				         paint: (Color						          h: 360 / size * index						          s: 1						          v: 1						          alpha: 0.5);				         yourself.			 line markerEnd: ((RSShapeFactory triangle					   extent: 10 @ 20;					   color: line paint;					   border: borderWhite;					   yourself) asMarker					  offset: -10;					  yourself).			 com add: line.			 com ]).	canvas newAnimation repeat onStepDo: [ :t |		theta := theta + 0.0523.		canvas nodes do: [ :com | com shapes first update ] ].	canvas		when: RSExtentChangedEvent		do: [ canvas camera zoomToFit: canvas extent extent: 500 @ 500 ]		for: self.	^ canvas! !!RSAnimationExamples methodsFor: 'examples'!example27RSLocate	<script:	'self new example27RSLocate open setLabel: ''RSLocation methods'''>	| canvas newBox updateText fixedElement movableElement buttons labeled locate label grad1 grad2 color |	canvas := RSCanvas new.	locate := RSLocation new.	color := RSColorPalette qualitative paired3.	newBox := [ :m |	          RSBox new		          size: 200;		          color: (color scale: m);		          yourself ].	label := RSLabel new.	updateText := [	              label text:		              'Offset:'		              , (locate offset x printShowingDecimalPlaces: 1) , '@'		              , (locate offset y printShowingDecimalPlaces: 1) ].	updateText value.	fixedElement := newBox value: 1.	"movableElement := newBox value: 2."	movableElement := RSComposite new		                  add: (RSLabel new				                   text: 'foo';				                   rotateByDegrees: -45;				                   yourself);		                  adjustToChildren;		                  color: (color scale: 2);		                  yourself.	"movableElement size: 40."	movableElement		when: RSMouseClick		do: [			canvas newAnimation				scale: (NSScale linear						 domain: #( 0 0.5 1 );						 range: {								 (0 @ 0).								 (20 @ 20).								 (0 @ 0) });				onStepDo: [ :t |					locate offset: t.					locate move: movableElement on: fixedElement.					updateText value.					label signalUpdate ] ]		for: self.	canvas		add: fixedElement;		add: movableElement;		add: label.	grad2 := (LinearGradientPaint fromArray: {				          (0 -> 'white').				          (0.25 -> 'black').				          (1 -> 'lightGray') })		         start: 0 @ -15;		         stop: 0 @ 15.	grad1 := (LinearGradientPaint fromArray: {				          (0 -> 'lightGray').				          (0.25 -> 'black').				          (1 -> 'gray') })		         start: 0 @ -15;		         stop: 0 @ 15.	labeled := RSLabeled new.	labeled shapeBuilder: [ :m |		RSLabel new			text: m asString;			color: Color white ].	labeled location middle.	buttons := #( outer border inner left center right top middle bottom )		           collect: [ :t |			           RSBox new				           border: (RSBorder new color: Color lightGray);				           cornerRadius: 5;				           extent: 60 @ 30;				           paint: grad1;				           model: t;				           addInteraction: labeled;				           when: RSMouseEnter do: [ :evt |					           evt shape						           paint: grad2;						           signalUpdate ]				           for: self;				           when: RSMouseLeave do: [ :evt |					           evt shape						           paint: grad1;						           signalUpdate ]				           for: self;				           when: RSMouseClick do: [ :evt |					           | p |					           evt shape model value: locate.					           p := movableElement position.					           locate move: movableElement on: fixedElement.					           canvas newAnimation						           from: p;						           duration: 500 milliSeconds;						           to: movableElement position;						           on: movableElement shape set: #position: ]				           for: self ]		           as: RSGroup.	RSGridLayout new		lineItemsCount: 3;		on: buttons.	RSVerticalLineLayout new		alignCenter;		gapSize: 30;		on: (RSGroup with: canvas nodes with: buttons).	canvas addAll: buttons.	canvas		when: RSExtentChangedEvent		do: [			canvas camera zoomToFit: canvas extent * 0.7.			canvas signalUpdate ]		for: self.	^ canvas! !!RSAnimationExamples methodsFor: 'perlin'!example28AlteredWorld	"base on Gerard Ferrandez source code"	"https://codepen.io/ge1doot/details/GQobbq/"	<script:	'self new example28AlteredWorld open setLabel: ''Altered World :V'''>	| canvas extent px perlin r period length |	canvas := RSCanvas new.	r := Random new.	extent := 500 @ 500.	period := 0.01.	length := 400.	canvas shouldClearBackground: false.	canvas color: Color black.	px := 0.	perlin := NSPerlinNoise3 new octaves: 5.	canvas addAll: ((1 to: extent y / 6) collect: [ :m |			 RSPolyline new				 width: 0.5;				 yourself ]).	canvas newAnimation		loops: extent x;		duration: 50 milliSeconds;		when: RSAnimationLoopEvent do: [			canvas lines do: [ :e |					| x y n points m |					x := px.					y := extent y * r next.					n := perlin noise: x * period and: y * period.					e color:							((Color h: -210 + (n * 600) s: 1 l: 8 * n * n * n) alpha: 0.05).					points := OrderedCollection new.					points add: x @ y.					m := 0.					[ m < length and: [ y between: 0 and: extent y ] ] whileTrue: [							n := perlin noise: x * period and: y * period.							x := x + (n * 14) cos.							y := y + (n * 14) sin.							points add: x @ y.							m := m + 1 ].					e shape controlPoints: points ].			canvas signalUpdate.			px := px + 1 ]		for: self.	canvas		when: RSExtentChangedEvent		do: [			canvas camera				zoomToFit: canvas extent				rectangle: (Rectangle floatCenter: extent / 2 extent: extent) ]		for: self.	^ canvas! !!RSAnimationExamples methodsFor: 'examples'!example29Tick	<script: 'self new example29Tick open setLabel: ''Can you hear it?'''>	| c slice animation ios g |	c := RSCanvas new.	c color: Color black.	slice := Float twoPi / 16.	ios := (1 to: 16) collect: [ :i |		       i even			       ifTrue: [ 'I' ]			       ifFalse: [ 'O' ] ].	g := ios collect: [ :m |		     RSLabel new			     color: Color gray;			     text: m;			     yourself ].	g doWithIndex: [ :s :i |		| ang |		ang := i * slice.		s matrix rotateByRadians: ang + Float halfPi.		s position: ang cos @ ang sin * 30 ].	c add: (RSComposite new			 shapes: g;			 yourself).	c addAll: ('TICK' asArray collectWithIndex: [ :m :i |			 | s |			 s := RSLabel new				      color: Color white;				      text: m asString;				      yourself.			 s position: 0 @ (-60 + (i * 15)).			 s ]).	(c nodes at: 3) remove.	animation := [ :a :b :k |	             c transitionAnimation		             duration: 700 milliSeconds;		             easing: RSEasingInterpolator bounceOut;		             from: a;		             to: b;		             onStepDo: [ :t |			             | s |			             c nodes first matrix				             loadIdentity;				             rotateByRadians: t.			             s := c nodes first shapes.			             (s at: k key) color: Color lightGray.			             (s at: k value) color: Color white ] ].	(c animationFrom: {			 (animation value: 0 value: slice value: 10 -> 11).			 (animation value: slice value: slice * 2 value: 11 -> 10) })		repeat.	c		when: RSExtentChangedEvent		do: [ c camera zoomToFit: c extent extent: 120 asPoint ]		for: self.	^ c! !!RSAnimationExamples methodsFor: 'perlin'!example30Perlin	<script: 'self new example30Perlin open setLabel: ''Perlin :V'''>	| canvas random frame scIterations scRadius rect extent maxLife perlin noiseScale respawnTop |	random := Random new.	canvas := RSCanvas new.	canvas shouldClearBackground: false.	extent := 500 @ 500.	rect := Rectangle floatCenter: extent / 2 extent: extent.	maxLife := 10.	perlin := NSPerlinNoise3 new octaves: 3.	noiseScale := 80.	canvas color: Color black.	scIterations := NSScale linear		                domain: #( 0 100 );		                range: #( 5 1 ).	scRadius := NSScale linear		            domain: #( 0 100 );		            range: #( 1 3 ).	frame := 0.	respawnTop := [ :e |	              e		              propertyAt: #life put: random next * maxLife;		              position: random next @ 0 * extent ].	canvas addAll: ((1 to: 100) collect: [ :n |			 | e c1 c2 |			 c1 := c2 := Color white.			 (random next * 3) asInteger = 1 ifTrue: [				 c1 := Color purple.				 c2 := Color cyan ].			 e := RSEllipse new.			 e size: (scRadius scale: n).			 e properties				 at: #c1 put: c1;				 at: #c2 put: c2;				 at: #iterations put: (scIterations scale: n).			 respawnTop value: e.			 e ]).	canvas newAnimation repeat onStepDo: [ :t |		frame := frame + 1.		canvas nodes do: [ :e |			| life p heading vel color alpha |			life := e propertyAt: #life.			e propertyAt: #life put: (life := life - 0.01666).			life < 0 ifTrue: [ respawnTop value: e ].			p := e position.			vel := 0 @ 0.			1 to: (e propertyAt: #iterations) do: [ :k |				| transition angle |				transition := p x / extent x.				angle := (perlin noise: p x / noiseScale and: p y / noiseScale)				         * transition * Float twoPi * noiseScale.				vel := angle cos @ angle sin * 0.2.				p := p + vel ].			(rect containsPoint: p) ifFalse: [ respawnTop value: e ].			e position: p.			heading := vel angle / Float twoPi.			heading < 0 ifTrue: [ heading := heading negated ].			color := NSScale linear				         range: {						         (e propertyAt: #c1).						         (e propertyAt: #c2) };				         scale: heading.			alpha := life * 5 / maxLife min: 1.			alpha := maxLife - life * 5 / maxLife min: alpha.			e color: (color alpha: alpha) ] ].	canvas		when: RSExtentChangedEvent		do: [ canvas camera zoomToFit: canvas extent rectangle: rect ]		for: self.	^ canvas! !!RSAnimationExamples methodsFor: 'examples'!example31RoundRectagles	"example inspired in paper.js"	<script:	'self new example31RoundRectagles open setLabel: ''Round Rectangles'''>	| canvas mouse extent frame scale color |	canvas := RSCanvas new.	extent := 500 @ 500.	mouse := 0 @ 0.	scale := [ :i | 1 - (i / 25) * 10 ].	color := RSColorPalette sequential blues9.	canvas addAll: ((1 to: 25) collect: [ :n |			 RSBox new				 size: 25 * (scale value: n);				 cornerRadius: 6 * (scale value: n);				 color: (color scale: n);				 yourself ]).	canvas		when: RSExtentChangedEvent		do: [ canvas camera zoomToFit: canvas extent extent: extent ]		for: self.	canvas		when: RSMouseMove		do: [ :evt | mouse := evt position ]		for: self.	frame := 0.	canvas newAnimation repeat onStepDo: [ :t |		frame := frame + 1.		canvas nodes doWithIndex: [ :e :index |			| pos angle |			pos := e position + (mouse - e position / (index + 5)).			angle := e propertyAt: #angle ifAbsentPut: [ 0 ].			angle := angle + ((frame + index / 10) sin * 7).			e propertyAt: #angle put: angle.			e matrix				loadIdentity;				translation: pos;				rotateByDegrees: angle ] ].	^ canvas! !!RSAnimationExamples methodsFor: 'examples'!example32SimpleClock	<script:	'self new example32SimpleClock open setLabel: ''4 gradient corners'''>	| canvas extent half linear color label roassal clock location |	canvas := RSCanvas new.	extent := 800 @ 600.	half := extent / 2.	linear := [ :val :a :b |	          (LinearGradientPaint fromArray: val)		          start: a * half;		          stop: b * half ].	color := NSScale ordinal range: {			         (linear				          value: {						          (0 -> '7D66E9').						          (1 -> 'E664AC') }				          value: -1 @ 1				          value: 1 @ -1).			         (linear				          value: {						          (0 -> '71C1E2').						          (0.9 -> Color transparent) }				          value: -1 @ -1				          value: 0 @ 1).			         (linear				          value: {						          (0 -> 'EDB259').						          (0.9 -> Color transparent) }				          value: 1 @ 1				          value: 0 @ -1) }.	canvas addAll: ((1 to: 3) collect: [ :i |			 RSBox new				 draggable;				 extent: extent;				 color: (color scale: i);				 yourself ]).	label := [ :t |	         RSLabel new		         fontSize: 40;		         color: Color white;		         text: t;		         yourself ].	roassal := label value: 'Roassal3 2019'.	clock := label value: Time now print24.	clock fontSize: 100.	canvas add: roassal.	canvas add: clock.	canvas newAnimation		duration: 500 milliSeconds;		repeat;		when: RSAnimationLoopEvent		do: [ clock text: Time now print24 ]		for: self.	location := RSLocation new		            inner;		            bottom;		            offset: 0 @ -15.	location move: roassal on: canvas nodes.	canvas addShape:		(RSBitmap new form: PolymorphSystemSettings pharoLogoForm).	location		top;		offset: 0 @ 15.	location move: canvas shapes last on: canvas nodes.	canvas @ RSCanvasController.	^ canvas! !!RSAnimationExamples methodsFor: 'examples'!example33AnimatedLayout	<script:	'self new example33AnimatedLayout open setLabel: ''Layouts'''>	| c objects layout update labels shapes color |	c := RSCanvas new.	objects := 1 to: 100.	color := RSColorPalette sequential ylorrd9.	shapes := objects collect: [ :m |		          RSBox new			          border: RSBorder new;			          color: (color scale: m);			          size: 10;			          model: m;			          yourself ].	c addAll: shapes.	RSLineBuilder line		canvas: c;		objects: objects;		connectFrom: [ :value | value // 2 ] to: #yourself.	layout := RSLayoutBuilder new.	update := [ :sel |	          layout perform: sel asSymbol.	          layout on: shapes ].	update value: #tree.	RSZoomToFitCanvasInteraction new animatedZoomToFit: c.	labels := #( 'grid' 'tree' 'cell' 'horizontalTree' 'cluster'	             'circle' 'radial' 'sugiyama' ).	labels := labels collect: [ :sel |		          RSLabel new			          isFixed: true;			          text: sel capitalized;			          when: RSMouseLeave do: [ :evt |				          evt shape					          color: Color black;					          normal;					          signalUpdate ]			          for: self;			          when: RSMouseEnter do: [ :evt |				          evt shape					          color: Color blue;					          underline;					          signalUpdate ]			          for: self;			          when: RSMouseClick do: [ :evt |				          | pos1 pos2 |				          pos1 := shapes collect: #position.				          update value: sel.				          pos2 := shapes collect: #position.				          c newAnimation onStepDo: [ :t |					          shapes doWithIndex: [ :e :i |						          e translateTo:							          ((pos1 at: i) interpolateTo: (pos2 at: i) at: t) ].					          c zoomToFit ] ]			          for: self ].	c addAll: labels.	RSHorizontalLineLayout on: labels.	^ c! !!RSAnimationExamples methodsFor: 'examples'!example34ForceLayout	<script: 'self new example34ForceLayout open'>	| c classes layout |	c := RSCanvas new.	classes := Collection withAllSubclasses collect: [ :cls | | e |		e := RSEllipse new			draggable;			model: cls;			color: Color purple translucent;			size: 10;			yourself.		cls = Collection ifTrue: [ e color: Color red ].		e		 ].	RSLineBuilder line		canvas: c;		shapes: classes;		color: (Color purple alpha: 0.2);		connectFrom: #superclass to: #yourself.	c addAll: classes.	layout := RSForceBasedLayout new		nodes: classes;		edges: c lines;		start;		yourself.	c newAnimation repeat onStepDo: [ :t |		layout step ].	^ c! !!RSAnimationExamples methodsFor: 'examples'!example35Roassal	<script: 'self new example35Roassal open'>	| canvas points paint fscale timeSize text |	canvas := RSCanvas new.	text := 'Roassal3'.	points := RSPolygon generateUnitNgonPoints: 3 rotation: Float pi.	canvas addShape: (RSPolygon new			 cornerRadii: 5;			 color: Color red;			 points: points;			 size: 300;			 position: 0 @ 0).	canvas addShape: (RSPolygon new			 cornerRadii: 5;			 border: (RSBorder new					  color: Color white;					  width: 5);			 noPaint;			 points: points;			 position: 0 @ -3;			 size: 280).	timeSize := 500.	fscale := NSScale linear range: #( 130 80 ).	paint := LinearGradientPaint new		         colorRamp: { (0 -> Color white) };		         start: 0 @ -100;		         stop: 0 @ 100.	text doWithIndex: [ :char :index |		| lbl |		lbl := RSLabel new			       text: char;			       bold;			       fontName: 'Marker Felt';			       position: 0 @ -40;			       border: (RSBorder new					        color: Color white;					        width: 3);			       paint: paint;			       fontSize: 130.		canvas newAnimation			duration: timeSize milliSeconds;			delay: (index - 1 * timeSize) milliSeconds;			onStepDo: [ :t |				lbl isInACanvas ifFalse: [ canvas addShape: lbl ].				lbl fontSize: (fscale scale: t).				paint colorRamp: {							(0 -> Color white).							(t -> Color white).							(t + 0.001 -> Color transparent).							(1 -> Color transparent) } ];			when: RSAnimationEndEvent do: [ lbl remove ] for: self ].	canvas newAnimation		duration: (timeSize * text size) milliSeconds;		when: RSAnimationEndEvent do: [			canvas addShape: (RSLabel new						 text: text;						 bold;						 position: 5 @ -50;						 fontName: 'Marker Felt';						 color: Color white;						 fontSize: 30).			canvas newAnimation				easing: RSEasingInterpolator elasticOut;				from: -1;				to: 0;				onStepDo: [ :t | canvas shapes last matrix shy: t ] ]		for: self.	canvas		when: RSExtentChangedEvent		do: [		canvas camera zoomToFit: canvas extent * 0.8 extent: 300 @ 300 ]		for: self.	^ canvas! !!RSAnimationExamples methodsFor: 'examples'!example36Title	<script: 'self new example36Title open setLabel: ''Basic Animation'''>	| c t1 t2 s line1 line2 line3 line4 title desc r1 r2 pad mid marker sum lineAnime p lblbase |	c := RSCanvas new.	t1 := 'Roassal3'.	t2 := 'It is a new agile visualization enginefor Pharo 8 and Pharo 9.'.	lblbase := RSLabel new		           color: Color white;		           fontSize: 30;		           fontName: 'Marker Felt';		           withBorder;		           yourself.	s := [ :m | lblbase copy text: m ].	desc := t2 lines collect: [ :m | s value: m ] as: RSGroup.	RSVerticalLineLayout new		gapSize: 0;		on: desc.	desc := desc asShape.	lblbase fontSize: 25.	title := s value: t1.	RSLocation new		outer;		right;		top;		offset: title width / -2 @ -20;		move: title on: desc.	r1 := title encompassingRectangle.	r2 := desc encompassingRectangle.	pad := 15.	mid := r2 origin + r1 corner / 2.	marker := RSPieSlice new		          color: Color black;		          externalRadius: 5;		          alphaAngle: -90;		          betaAngle: -90.	line1 := RSPolyline new		         cornerRadii: 30;		         markerEnd: marker;		         controlPoints: {				         mid.				         (r1 corner x + (pad * 2) @ mid y).				         (r1 topRight + (pad * 2 @ pad negated)).				         (r1 origin - pad asPoint) }.	line2 := RSPolyline new		         markerEnd: marker;		         cornerRadii: 50;		         controlPoints: {				         mid.				         (r2 origin x - (pad * 2) @ mid y).				         (r2 bottomLeft + (pad negated * 2 @ pad)).				         (r1 corner x @ r2 corner y + (pad @ pad)) }.	line3 := RSPolyline new		         cornerRadii: 30;		         controlPoints: {				         (r1 rightCenter + (pad * 3 @ 0)).				         (r1 topRight + (3 @ -2 * pad)).				         (r1 topCenter + (0 @ -2 * pad)) }.	line4 := RSPolyline new		         cornerRadii: 50;		         controlPoints: {				         (r2 leftCenter + (-3 @ 0 * pad)).				         (r2 bottomLeft + (-3 @ 2 * pad)).				         (r2 bottomCenter + (0 @ 2 * pad)) }.	c addShape: line1.	c addShape: line2.	c addShape: line3.	c addShape: line4.	c camera zoomToFit: c extent * 0.8 rectangle: c encompassingRectangle.	sum := [ :line |	       | cp |	       cp := line controlPoints.	       (cp first x - cp second x) abs	       + (cp second y - cp third y) abs	       + (cp third x - cp fourth x) abs ].	lineAnime := [ :line :lbl :pscale :array |	             line border dashArray: array.	             c newAnimation		             from: 0;		             to: (sum value: line);		             onStepDo: [ :t | array at: 1 put: t ].	             c newAnimation		             duration: 1 second;		             when: RSAnimationEndEvent do: [ c add: lbl ] for: self.	             c newAnimation		             delay: 1 second;		             duration: 1 second;		             from: 0.05;		             to: 1;		             onStepDo: [ :t |			             lbl matrix				             loadIdentity;				             translation: (pscale scale: t);				             scaleBy: t @ 1 ] ].	p := title position.	lineAnime		value: line1		value: title		value: (NSScale linear range: {					 (p x + (title width / 2) @ p y).					 p })		value: { 0. 1000 }.	p := desc position.	lineAnime		value: line2		value: desc		value: (NSScale linear range: {					 (p x - (desc width / 2) @ p y).					 p })		value: { 0. 1000 }.	c newAnimation		delay: 2 seconds;		duration: 1 second;		from: 0;		to: 360;		onStepDo: [ :t | marker betaAngle: t - 90 ].	^ c	"TODO add animation to line3 and line4, hide and remove with animation these elements"! !!RSAnimationExamples methodsFor: 'examples'!example37RectangleForceLayout	<script: 'self new example37RectangleForceLayout open'>	| canvas classes layout color |	canvas := RSCanvas new.	color := NSScale category20.	classes := Collection withAllSubclasses		           collect: [ :cls |			           RSBox new				           model: cls;				           color: (color scale: cls);				           size: 10;				           yourself ]		           as: RSGroup.	RSLineBuilder line		canvas: canvas;		shapes: classes;		color: (Color blue alpha: 0.5);		connectFrom: #superclass to: #yourself.	canvas addAll: classes.	layout := RSRectangleForceLayout new		          nodes: classes;		          edges: canvas edges;		          start;		          yourself.	canvas @ RSSimpleCanvasMonitorInteraction.	canvas newAnimation repeat onStepDo: [ :t | layout step ].	"Apply forces from the window borders to the elements."	canvas		when: RSExtentChangedEvent		do: [ :evt |			| camera origin corner |			camera := canvas canvas camera.			origin := camera fromPixelToSpace: 0 @ 0.			corner := camera fromPixelToSpace: canvas canvas extent.			layout enclosingRectangle: (origin corner: corner) ]		for: self.	classes @ (RSDraggableForceInteraction new layout: layout).	canvas camera scale: 2.	^ canvas! !!RSAnimationExamples methodsFor: 'perlin'!example38PerlinRose	<script:	'self new example38PerlinRose open extent: 800@600; setLabel: ''Rose'''>	| canvas offset offsetInc inc m s tau perlin border |	canvas := RSCanvas new.	offset := 0 @ 0. "Perlin offset"	offsetInc := 0.006. "Perlin offset increment"	inc := 1. "Perlin increment"	m := 1.005. "size multiplier"	s := 1. "Start size of perlin ring"	tau := 6.2831855. "It is the circle constant relating the circumference of a circle to its linear dimension"	canvas color: Color black.	perlin := NSPerlinNoise3 new.	perlin octaves: 3.	canvas shouldClearBackground: false.	border := RSBorder new		          color: (Color blue alpha: 0.1);		          yourself.	canvas addAll: ((1 to: 10) collect: [ :i |			 RSPolygon new noPaint				 border: border;				 yourself ]).	canvas newAnimation		loops: 1000;		duration: 50 milliSeconds;		when: RSAnimationLoopEvent		do: [ :evt | "Create a series of perlin rings from big to small"			s < 2000				ifTrue: [					canvas nodes do: [ :e |							| nPoints points |							nPoints := 2 * Float pi * s.							nPoints := nPoints min: 500.							points := (1 to: nPoints) collect: [ :i |									          | a p n |									          a := i / nPoints * tau.									          p := a cos @ a sin.									          n := (perlin										                noise: offset x + (p x * inc)										                and: offset y + (p y * inc)) * s.									          p * n ].							e points: points.							offset := offset + offsetInc.							s := s * m ] ]				ifFalse: [ evt animation stop ].			canvas signalUpdate ]		for: self.	^ canvas! !!RSAnimationExamples methodsFor: 'perlin'!example39Duna	<script: 'self new example39Duna  open extent: 1000@700; position: World center - (1000@700 / 2)'>	| canvas extent num color noiseScale perlin c particles |	canvas := RSCanvas new.	extent := 1000@700.	canvas shouldClearBackground: false.	num := 1000.	color := Color purple.	noiseScale := 400. "<<<-- change this"	perlin := NSPerlinNoise3 new.	perlin octaves: 2."<<<-- also this :D"	c := NSScale linear		domain: { 0. num/2 };		range: { color alpha: 0.8. color alpha: 0 }.	particles := (1 to: num) collect: [ :n |		RSEllipse new			size: 1;			isFixed: true;			position: n @ extent y;			color: (c scale: (n - (num / 2)) abs);			yourself ].	canvas addAll: particles.	canvas newAnimation repeat; onStepDo: [ :t |		particles do: [ :particle |			| p dir vel  |			p := particle position.			dir := Float twoPi * (perlin				noise: p x / noiseScale				and: p y / noiseScale).			vel := dir sin @ dir cos * 0.5.			particle translateBy: vel.			 ].		 ].	^ canvas! !!RSAnimationExamples methodsFor: 'examples'!example40Circles	<script: 'self new example40Circles open'>	| canvas max min gscale alpha scale circleSize vertexSize updateMouse center getSize color frameCount |	canvas := RSCanvas new.	canvas color: Color black.	max := 2500.	min := 100.	gscale := NSScale linear range: {			          (max @ 20).			          (min @ 3) }.	alpha := NSScale linear		         domain: {				         min.				         max };		         range: { 0.6. 0.12 }.	scale := 300.	updateMouse := [ :pos |	               | offset size |	               offset := pos abs.	               gscale domain: {			               (0 @ 0).			               (canvas extent / 2) }.	               size := gscale scale: offset.	               circleSize := size x.	               vertexSize := size y ].	center := [ :theta :time |	          | dir distance |	          dir := theta cos @ theta sin.	          distance := 0.6	                      +	                      (0.2 * (theta * 6 + (theta * 8 + time) cos) cos).	          dir * distance * scale ].	getSize := [ :theta :time |	           | offset |	           offset := 0.2 + (0.12 * (theta * 9 - (time * 2)) cos).	           scale * offset ].	color := [ :theta :time |	         | th |	         th := 8 * theta + (time * 2).	         Color		         r: 0.6 + (0.4 * th cos)		         g: 0.6 + (0.4 * (th - (Float pi / 3)) cos)		         b: 0.6 + (0.4 * (th - (Float pi * 2 / 3)) cos)		         alpha: (alpha scale: circleSize) ].	canvas		when: RSMouseMove		do: [ :evt | updateMouse value: evt position ]		for: self.	updateMouse value: 0 @ 0.	frameCount := 0.	canvas newAnimation		repeat;		onStepDo: [ :t |			frameCount := frameCount + 1.			canvas shapes copy do: #remove.			1 to: circleSize do: [ :ci |					| time thetaC c circleCenter cSize points |					time := frameCount / 20.					thetaC := ci * Float twoPi / circleSize.					circleCenter := center value: thetaC value: time.					cSize := getSize value: thetaC value: time.					c := color value: thetaC value: time.					points := (1 to: vertexSize) collect: [ :vi |							          | thetaV |							          thetaV := vi * Float twoPi / vertexSize.							          thetaV cos @ thetaV sin * cSize + circleCenter ].					canvas add: (RSPolygon new								 noPaint;								 border: (RSBorder new color: c);								 points: points;								 yourself) ] ].	^ canvas! !!RSAnimationExamples methodsFor: 'perlin'!example41River	<script:	'self new example41River open setLabel: ''River''; extent: 900@200.'>	| extent half c r back rect perlin cScale alphaS inc setParticles |	extent := 900 @ 200.	half := extent / 2.	c := RSCanvas new.	c shouldClearBackground: false.	c color: Color black.	r := Random new.	back := RSBox new		        color: Color black translucent;		        extent: extent;		        yourself.	rect := back encompassingRectangle.	perlin := NSPerlinNoise3 new octaves: 3.	cScale := NSScale linear		          domain: {				          half negated y.				          half y };		          range: #( 255 0 ).	alphaS := NSScale linear		          domain: {				          half negated x.				          half x };		          range: #( 0.05 0.4 ).	inc := 0.	setParticles := [	                c nodes copy do: #remove.	                c add: back.	                c addAll: ((1 to: 3000) collect: [ :i |			                 | box |			                 box := RSBox new				                        size: 1;				                        position: r next @ r next * extent - half.			                 box				                 color: (Color						                  r: 40						                  g: (cScale scale: box position y)						                  b: 255						                  range: 255);				                 propertyAt: #update put: [					                 | theta p |					                 p := box position.					                 theta := (perlin						                           noise: p x * 0.006 + inc						                           and: p y * 0.004 + inc) * Float twoPi.					                 p := p + (theta cos @ theta sin * 2).					                 p x < rect origin x ifTrue: [							                 p := rect corner x @ p y ].					                 p x > rect corner x ifTrue: [							                 p := rect origin x @ p y ].					                 p y < rect origin y ifTrue: [							                 p := p x @ rect corner y ].					                 p y > rect corner y ifTrue: [							                 p := p x @ rect origin y ].					                 box translateTo: p ].			                 box ]) ].	setParticles value.	c		when: RSMouseClick do: setParticles for: self;		when: RSMouseMove do: [ :evt |			| alpha |			alpha := alphaS scale: evt position x.			back color: (Color black alpha: alpha) ]		for: self.	c newAnimation repeat onStepDo: [ :t |		inc := inc + 0.008.		c shapes do: [ :node | (node propertyAt: #update) value ] ].	^ c! !!RSAnimationExamples methodsFor: 'lines'!example42OneLine	<script: 'self new example42OneLine open extent: 1112@834; setLabel: ''One line'''>	| canvas line ang1 ang2 radio x1 y1 x2 y2 |	canvas := RSCanvas new shouldClearBackground: false.	canvas color: Color black.	canvas add: (line := RSLine new).	ang1 := 0. ang2 := 0.radio := 200.	canvas newAnimation repeat onStepDo: [ :t | | nx ny |		line color: (Color h: ang2 radiansToDegrees s: 1 v: 1 alpha: 0.1).		nx := ang2 sin * radio.		ny := ang2 cos * radio.		x1 := nx - (ang1 sin * radio).		y1 := ny - (ang1 cos * radio).		x2 := nx + (ang1 sin * radio).		y2 := ny + (ang1 cos * radio).		line startPoint: x1@y1; endPoint: x2@y2.		ang1 := ang1 + (Float pi / 33).		ang1 > Float twoPi ifTrue: [ ang1 := 0 ].		ang2 := ang2 + (Float pi / 360).		ang2 > Float twoPi ifTrue: [ ang2 := 0 ].		].	^ canvas! !!RSAnimationExamples methodsFor: 'lines'!example43Waves	<script: 'self new example43Waves open		position: 0@20;		color: Color transparent;		setLabel: ''Waves'';		extent: 1600@1000'>	| canvas frame size extent perlin paint height points |	canvas := RSCanvas new.	canvas color: Color transparent.	frame := 0.	size := 100.	extent := 1600@1000.	perlin := NSPerlinNoise2 new.	paint := NSScale linear domain: { 0. size }.	height := NSScale linear range: { extent y* 0.3. extent y* 0.6}.	canvas newAnimation repeat		onStepDo: [ :t |			canvas lines copy do: #remove.			0 to: size do: [ :i | | color |				color := paint scale: i.				color := Color gray: color.				points := (-10 to: extent x + 11 by: 20) collect: [ :x | | y n |					n := perlin noise: x*0.004 y: i * 0.03 z: frame * 0.05.					n := (n + 1) / 2.					y := height scale: n.					x @ y. ].				canvas add: (RSPolyline new					isFixed: true;					width: 2;					borderColor: color;					controlPoints: points;					yourself)				].			frame := frame + 1. ].	^ canvas! !!RSAnimationExamples methodsFor: 'perlin'!example44A	<script: 'self new example44A open'>	"|c|	c := RSCanvas new.c add: (RSLabel new	border: (RSBorder new color: Color black);	paint: Color red;	text: 'A';	fontSize: 100;	yourself).c svgExporter export"	| canvas r path perlin visitor frame |	canvas := RSCanvas new.	r := Random new.	path := RSSVGPath new.	perlin := NSPerlinNoise3 new octaves: 5.	"generated with https://github.com/ObjectProfile/Roassal3Exporters"	path svgPath: 'M 27.063543 -48.93775 L 22.938543 -35.594001 L 49.204165 -35.594001 L 45.063541 -48.93775 C 43.469791 -53.820562 41.958072 -58.687749 40.532291 -63.531498 C 39.114323 -68.375248 37.692448 -73.328372 36.266667 -78.390872 L 35.735417 -78.390872 C 34.399479 -73.328372 33.020573 -68.375248 31.594792 -63.531498 C 30.176824 -58.687749 28.665105 -53.820562 27.063543 -48.93775 Z M 0.407295 -0.000254728 L 30.001042 -87.468996 L 42.532291 -87.468996 L 72.126038 -0.000254728 L 60.266664 -0.000254728 L 52.00104 -26.672127 L 20.126043 -26.672127 L 11.735419 -0.000254728 Z M 72.532288 -0.000254728'.	visitor := RSBlockSegmentsVisitor new.	visitor simplePoints:[ :segment :current |		canvas addAll: ((segment pointsWithStart: current) collect: [:p |			(RSEllipse new				size: (r next * 1.5 +0.5);				position: p;				color: Color black;				yourself) ]).		].	path accept: visitor.	frame := 0.	canvas newAnimation repeat; onStepDo: [ :t |		canvas nodes doWithIndex: [ :each :i |			| n |			n := (perlin noise: (each position + frame)* 0.01)- 0.5.			each translateBy: n.			].		frame := frame + 1.		canvas signalUpdate.		].	canvas zoomToFit.	^ canvas! !!RSAnimationExamples methodsFor: 'perlin'!example45Beziers	<script: 'self new example45Beziers open'>	| c allPoints graphs color |	c := RSCanvas new.	allPoints := {		             ('2 Points' -> {			              (0 @ 0).			              (100 @ -100) }).		             ('3 Points' -> {			              (0 @ 0).			              (50 @ -100).			              (100 @ 0) }).		             ('4 Points' -> {			              (0 @ 0).			              (50 @ 0).			              (50 @ -100).			              (100 @ -100) }).		             ('curve like y = 1/t' -> {			              (0 @ 0).			              (0 @ -70).			              (30 @ -100).			              (100 @ -100) }).		             ('Zig Zag' -> {			              (0 @ 0).			              (100 @ -50).			              (0 @ -50).			              (100 @ -100) }).		             ('Loop' -> {			              (0 @ 0).			              (100 @ -50).			              (0 @ -100).			              (50 @ 0) }).		             ('Non smooth bezier' -> {			              (0 @ 0).			              (100 @ -100).			              (0 @ -100).			              (100 @ 0) }).		             ('More than 4' -> {			              (0 @ 0).			              (50 @ -100).			              (100 @ 0).			              (150 @ -100).			              (200 @ 0).			              (250 @ -100) }) }.	color := NSScale category20.	graphs := allPoints collect: [ :assoc |		          | comp dots points bezier label button icon lines labelT |		          comp := RSComposite new.		          points := assoc value.		          dots := (1 to: points size)			                  collect: [ :i |				                  RSEllipse new					                  model: i;					                  size: 5;					                  withBorder;					                  position: (points at: i);					                  draggable;					                  noPaint;					                  yourself ]			                  as: RSGroup.		          dots @ RSLabeled.		          lines := (2 to: dots size) collect: [ :index |			                   RSLine new				                   withBorderAttachPoint;				                   from: (dots at: index - 1);				                   to: (dots at: index);				                   yourself ].		          comp addAll: lines.		          comp addAll: dots.		          bezier := points size > 4			                    ifTrue: [				                    RSPolyline new					                    in: [ :poly |						                    dots do: [ :dot |								                    dot addConnectedLine: poly ] ];					                    controlPointsController:						                    (RSBlockCPController new block: [ :line |								                     (0 to: 1 by: 0.05) collect: [ :t |										                     | n r |										                     r := 0 @ 0.										                     n := dots size - 1.										                     dots doWithIndex: [ :dot :k |												                     | point bez i |												                     point := dot position.												                     i := k - 1.												                     bez := n factorial												                            /													                            (i factorial													                             * (n - i) factorial)												                            * (t raisedTo: i)												                            * (1 - t raisedTo: n - i).												                     r := point * bez + r ].										                     r ] ]) ]			                    ifFalse: [				                    RSBezier new controlPointsController:					                    (RSCustomCPController new models: dots) ].		          bezier color: Color red.		          comp add: bezier.		          comp			          adjustToChildren;			          padding: 10;			          withBorder.		          label := RSLabel text: assoc key.		          RSLocation new			          above;			          offset: 0 @ -30;			          move: label on: dots.		          comp add: label.		          labelT := RSLabel text: 'T='.		          RSLocation new			          below;			          offset: 0 @ 10;			          move: labelT on: dots.		          comp add: labelT.		          icon := RSBitmap new form: (self iconNamed: #smallDoIt).		          button := { icon } asShape.		          button			          when: RSMouseEnter do: [				          button					          color: Color lightGray;					          signalUpdate ]			          for: self;			          when: RSMouseLeave do: [				          button					          color: nil;					          signalUpdate ]			          for: self;			          when: RSMouseClick do: [				          comp					          propertyAt: #anime					          ifPresent: [ :anime |						          anime toggle.						          icon							          form: (self iconNamed: (anime isPaused											            ifTrue: [ #smallDoIt ]											            ifFalse: [ #protocolPrivate ]));							          signalUpdate ]					          ifAbsent: [						          | anime newShapes |						          icon							          form: (self iconNamed: #protocolPrivate);							          signalUpdate.						          newShapes := RSGroup new.						          anime := comp newAnimation							                   duration: 5 seconds;							                   onStepDo: [ :t |								                   | currentLines |								                   newShapes do: #remove.								                   labelT text:										                   'T=' , (t printShowingDecimalPlaces: 3).								                   newShapes removeAll.								                   currentLines := lines.								                   [ currentLines notEmpty ] whileTrue: [										                   | newLines lcolor |										                   lcolor := color scale: currentLines size.										                   newLines := (2 to: currentLines size)											                               collect: [ :i |												                               | l1 l2 |												                               l1 := currentLines at:														                                     i - 1.												                               l2 := currentLines at: i.												                               RSLine new													                               startPoint:														                               (l1 startPoint															                                interpolateTo:																                                l1 endPoint															                                at: t);													                               endPoint:														                               (l2 startPoint															                                interpolateTo:																                                l2 endPoint															                                at: t);													                               color: lcolor;													                               yourself ].										                   currentLines size = 1 ifTrue: [											                   | l1 |											                   l1 := currentLines first.											                   newShapes add: (RSEllipse new													                    color: Color red;													                    size: 5;													                    position:														                    (l1 startPoint															                     interpolateTo: l1 endPoint															                     at: t);													                    yourself) ].										                   newShapes addAll: newLines.										                   currentLines := newLines ].								                   comp addAll: newShapes.								                   comp signalUpdate ];							                   when: RSAnimationEndEvent do: [ :evt |							                   comp removeKey: #anime.							                   newShapes do: #remove.							                   icon form: (self iconNamed: #smallDoIt) ].						          comp propertyAt: #anime put: anime ] ]			          for: self.		          RSLocation new			          outer;			          left;			          offset: -5 @ 0;			          move: button on: label.		          comp add: button.		          comp ].	RSGridLayout new		lineItemsCount: 4;		gapSize: 50;		on: graphs.	c addAll: graphs.	c @ RSCanvasController.	^ c! !!RSAnimationExamples methodsFor: 'perlin'!example46Lines	<script: 'self new example46Lines open'>	| c r line duration easing palette dots newDots rect |	c := RSCanvas new.	r := 50.	{		(-60 @ 0).		(0 @ 0).		(60 @ 0).		(0 @ 0) } doWithIndex: [ :p :i |		c add: (RSEllipse new				 color: Color black;				 model: i;				 position: p;				 yourself) ].	RSLineBuilder line		canvas: c;		useAssociations: {				(1 -> 2).				(3 -> 4).				(2 -> 4) }.	line := RSLine new.	c add: line.	duration := 10 seconds.	easing := RSEasingInterpolator sinOut.	c newAnimation		repeat;		easing: easing;		duration: duration;		from: 0;		to: Float twoPi negated;		onStepDo: [ :t |			c nodes second position: t cos @ t sin * r + (-60 @ 0) ].	c newAnimation		repeat;		easing: easing;		duration: duration;		from: 0;		to: Float twoPi;		onStepDo: [ :t |			c nodes fourth position: t cos @ t sin * r + (60 @ 0) ].	palette := NSScale ordinal range: (Color wheel: 20).	dots := (1 to: 20)		        collect: [ :i |			        RSEllipse new				        color: (palette scale: i);				        border: (RSBorder new color: Color black);				        yourself ]		        as: RSGroup.	c addAll: dots.	newDots := RSGroup new.	c newAnimation		repeat;		duration: duration;		onStepDo: [ :t |			| from to vector u unit middle left right stepDots |			from := c nodes second position.			to := c nodes fourth position.			vector := to - from.			u := vector normal.			unit := vector / (vector r max: 1).			middle := from + (vector * 0.5).			left := middle - (u * 800).			right := middle + (u * 800).			dots doWithIndex: [ :dot :i |					dot position: middle + (i - 10 * 25 * u) ].			stepDots := dots collect: [ :d |					            RSEllipse new						            size: 3;						            color: d color;						            position: d position;						            yourself ].			c addAll: stepDots.			stepDots pushBack.			newDots addAll: stepDots.			line startPoint: left.			line endPoint: right ];		when: RSAnimationLoopEvent do: [ :evt |			newDots do: #remove.			newDots removeAll ]		for: self.	rect := 300.	c camera		zoomToFit: 500 asPoint		rectangle: (rect negated asPoint corner: rect asPoint).	^ c! !!RSAnimationExamples methodsFor: 'accessing'!order	^ 1000! !!RSBasicAnimationExamples methodsFor: 'examples'!example01Basic	<script: 'self new example01Basic open'>	| c b |	c := RSCanvas new.	b := RSBox new		     extent: 100 @ 100;		     border: (RSBorder new color: 'black').	c addShape: b.	c newAnimation		easing: RSEasingInterpolator bounce;		from: -100 @ -100;		to: 100 @ 100;		on: b set: #position:.	c newAnimation		from: Color red;		to: Color blue;		on: b set: #color:.	c newAnimation		from: 0;		to: 10;		on: b border set: 'width:'.	c		when: RSMouseClick do: [ c animations do: #pause ] for: self;		when: RSMouseDoubleClick		do: [ c animations do: #continue ]		for: self.	c shouldClearBackground: false.	^ c! !!RSBasicAnimationExamples methodsFor: 'examples'!example02Sequential	<script: 'self new example02Sequential open'>	| c b animation |	c := RSCanvas new.	b := RSBox new		     extent: 100 @ 100;		     withBorder.	c addShape: b.	animation := c animationFrom: {			             (c transitionAnimation				              from: -100 @ -200;				              to: 100 @ 130;				              on: b set: #position:).			             (c transitionAnimation				              from: Color red;				              to: Color blue;				              on: b set: #color:).			             (c transitionAnimation				              from: 0;				              to: 10;				              on: b border set: 'width:') }.	animation loops: 2.	c		when: RSMouseClick do: [ c animations do: #pause ] for: self;		when: RSMouseDoubleClick		do: [ c animations do: #continue ]		for: self.	^ c! !!RSBasicAnimationExamples methodsFor: 'examples'!example03Ramp	<script: 'self new example03Ramp open'>	| c b |	c := RSCanvas new.	b := RSBox new		     extent: 100 @ 100;		     withBorder.	c addShape: b.	c newAnimation		ramp: {				(0 -> (0 @ 0)).				(0.25 -> (200 @ 180)).				(0.75 -> (-200 @ -80)).				(1 -> (200 @ 0)) };		on: b set: #position:.	c		when: RSMouseClick do: [ c animations do: #pause ] for: self;		when: RSMouseDoubleClick		do: [ c animations do: #continue ]		for: self.	^ c! !!RSBasicAnimationExamples methodsFor: 'lines'!example04DashAnimation	<script: 'self new example04DashAnimation open'>	| c box paint form border animation |	c := RSCanvas new.	form := self iconNamed: #eyedropper.	paint := AthensCairoPatternSurfacePaint createForSurface:		         (AthensCairoSurface fromForm: form).	paint origin: (form extent / 2) negated.	border := RSBorder new		          color: Color purple;		          dashArray: #( 4 ).	box := RSBox new		       paint: paint;		       extent: form extent;		       border: border;		       scaleBy: 3.	c addShape: box.	animation := c newAnimation		             repeat;		             from: 0;		             to: 8;		             on: border set: #dashOffset:.	box		when: RSMouseClick		do: [ :a |			animation isPaused				ifTrue: [ animation continue ]				ifFalse: [ animation pause ] ]		for: self.	^ c! !!RSBasicAnimationExamples methodsFor: 'lines'!example05LoopEvent	<script: 'self new example05LoopEvent open'>	| canvas box |	canvas := RSCanvas new.	canvas shouldClearBackground: false.	box := RSComposite new		       add: (RSLabel new text: '0');		       adjustToChildren;		       yourself.	(canvas animationFrom: { canvas transitionAnimation })		loops: 3;		when: RSAnimationLoopEvent do: [ :evt |			box children first text: evt currentLoop.			box position: 0 @ evt currentLoop * 50.			canvas signalUpdate ]		for: self.	canvas add: box.	^ canvas! !!RSBasicAnimationExamples methodsFor: 'lines'!example06Parallel	<script: 'self new example06Parallel open'>	| canvas box1 box2 animation updateWithAngle |	canvas := RSCanvas new.	canvas shouldClearBackground: false.	box1 := RSBox new		        size: 50;		        color: (Color red alpha: 0.02).	box2 := RSBox new		        size: 50;		        color: (Color blue alpha: 0.02).	updateWithAngle := [ :ang :box |	                   | p |	                   p := ang degreesToRadians.	                   p := p cos @ p sin negated * 100.	                   box position: p ].	animation := canvas parallelAnimation.	animation addAll: {			(canvas transitionAnimation				 from: 90;				 to: -90;				 onStepDo: updateWithAngle with: box1).			(canvas transitionAnimation				 from: 90;				 to: 270;				 onStepDo: updateWithAngle with: box2) }.	(canvas animationFrom: {			 (canvas transitionAnimation				  from: 0 @ 100;				  to: 0 @ -100;				  onStepDo: [ :p |					  box1 position: p.					  box2 position: p ]).			 animation }) loops: 2.	canvas		add: box1;		add: box2.	canvas		when: RSMouseClick		do: [ :evt | canvas animations do: #toggle ]		for: self.	^ canvas! !!RSBasicAnimationExamples methodsFor: 'lines'!example07CornerRadius	<script: 'self new example07CornerRadius open'>	| c paint b from to |	c := RSCanvas new.	paint := LinearGradientPaint fromArray:		{ 0->Color red.		1->Color black }.	paint start: -100 asPoint; stop: 100 asPoint.	b := RSBox new		size: 200;		paint: paint;		cornerRadius: 0;		border: (RSBorder new width: 3).	c add: b.	from := RSCornerRadius new topLeft: 200; bottomRight: 200.	to := RSCornerRadius new topRight: 200; bottomLeft: 200.	c newAnimation		repeat;		duration: 4 seconds;		scale: (NSScale linear			domain: #(0 0.5 1);			range: #(0 1 0));		onStepDo: [:t |			b cornerRadius: (from interpolateTo: to at: t).			c signalUpdate.			].	^ c! !!RSBasicAnimationExamples methodsFor: 'lines'!example08Markers	<script: 'self new example08Markers open'>	| canvas line radius marker red |	canvas := RSCanvas new.	line := RSLine new.	radius := 100.	canvas add: line.	marker := RSBox new size: 20; withBorder; noPaint; asMarker.	line markerEnd: marker.	canvas newAnimation		duration: 20 seconds;		repeat;		from: 0;		to: Float twoPi;		onStepDo: [ :a | | b |			b := a + Float pi.			line startPoint: (a cos @ a sin) * radius.			line endPoint: (b cos @ b sin )* radius ].	canvas newAnimation		duration: 20 seconds;		repeat;		from: 1;		to: 0;		onStepDo: [ :ratio | marker offsetRatio: ratio ].	canvas newAnimation		duration: 1 seconds;		repeat;		scale: (NSScale linear			domain: #(0 0.5 1);			range: #(-30 30 -30) );		onStepDo: [ :offset | marker offset: offset asPoint ].	red := RSLine new yourself.	red marker: (RSBox new size: 5; asMarker).	red color: Color red.	canvas add: red.	canvas newAnimation repeat;		onStepDo: [			| vector unit |			vector := line endPoint - line startPoint.			unit := vector / (vector r max: 1).			red startPoint: line endPoint - (vector * marker offsetRatio).			red endPoint: red startPoint - (unit * marker offset).			 ].	^ canvas! !!RSBasicAnimationExamples methodsFor: 'lines'!example09Easing	<script: 'self new example09Easing open'>	| canvas radius numberOfCircles circles innerRadius |	numberOfCircles := 8.	radius := 100.	innerRadius := 30.	circles := (1 to: numberOfCircles) collect: [ :each |		RSCircle new radius: 0; withBorder; noPaint ].	canvas := RSCanvas new.	canvas aaBest.	canvas addAnimation: (RSSequentialAnimation new		add: (RSTransitionAnimation new			duration: 2 seconds;			easing: RSEasingInterpolator elasticOut;			onStepDo: [:t |				circles doWithIndex: [ :circle :index |					circle radius: t * radius.					circle position: innerRadius * (index even asInteger * 2 -1) @ 0 ].			];			yourself);		add: (RSTransitionAnimation new			duration: 2 seconds;			easing: RSEasingInterpolator backOut;			onStepDo: [ :t |				circles doWithIndex: [ :circle :index | | angle toAngle fromAngle |					toAngle := (index - 1) /numberOfCircles * Float twoPi.					fromAngle := Float pi * index even asInteger.					angle := fromAngle interpolateTo: toAngle at: t.					circle position: (angle cos @ (angle sin) ) * innerRadius.				]			];			yourself);		yourself		).	canvas addAll: circles.	^ canvas! !!RSBasicAnimationExamples methodsFor: 'lines'!example10Scales	<script: 'self new example10Scales open'>	| c data width scale numbers totalLine lineWidth currentLevelLine labelShape background triangle level icons accept |	c := RSCanvas new.	width := 250.	lineWidth := 20.	data := {		        (5 -> #userFemale).		        (15 -> #checkboxSelected).		        (30 -> #komitter).		        (60 -> #user).		        (100 -> #smallScreenshot).		        (150 -> #smallFullscreen).		        (200 -> #github).		        (500 -> #glamorousBug).		        (750 -> #tools).		        (1000 -> #komitterNewSlice) }.	numbers := OrderedCollection with: 0.	numbers addAll: (data collect: #key).	scale := NSScale linear		         domain: numbers;		         range: (0 to: width count: data size + 1).	totalLine := RSLine new		             width: lineWidth;		             color: Color veryVeryLightGray;		             startPoint:			             (scale scale: numbers min) @ lineWidth negated;		             endPoint:			             (scale scale: numbers max) @ lineWidth negated;		             yourself.	labelShape := RSLabel new		              fontSize: 7;		              bold;		              color: Color white;		              borderColor: Color black;		              borderWidth: 0.3;		              yourself.	c add: totalLine.	background := RSPolygon new		              points: {				              (-10 @ -10).				              (10 @ -10).				              (10 @ 10).				              (-10 @ 10) };		              color: Color veryLightGray;		              borderColor: Color black;		              yourself.	triangle := RSPolygon new		            points: {				            (0 @ 0).				            (0 @ 3).				            (-3 @ 3) };		            color: Color veryLightGray;		            borderColor: Color black;		            yourself.	accept := RSBitmap newFrom: #glamorousAccept.	RSLocation new		orientation: 1 @ -1;		top;		right;		move: triangle on: background;		inner;		top;		right;		move: accept on: background.	icons := data		         collect: [ :assoc |			         | icon xpos label |			         icon := RSBitmap newFrom: assoc value.			         xpos := scale scale: assoc key.			         icon := {				                 background copy.				                 icon } asShapeFor: assoc key.			         icon addShape: triangle copy.			         label := labelShape copy				                  text: assoc key asString;				                  yourself.			         label position:				         xpos - (label width / 2) - 0.5 @ lineWidth negated.			         icon position: xpos - (icon width / 2) @ 5.			         c addAll: {					         label.					         icon }.			         icon ]		         as: OrderedCollection.	currentLevelLine := RSLine new		                    color: Color green;		                    width: lineWidth;		                    startPoint: totalLine startPoint;		                    endPoint: totalLine startPoint;		                    yourself.	c add: currentLevelLine.	level := { labelShape copy } asShape		         color: Color blue translucent;		         borderColor: Color black;		         yourself.	c add: level.	c newAnimation		from: 0;		to: 1000;		easing: RSEasingInterpolator cubicIn;		duration: 30 seconds;		onStepDo: [ :t |			| posx icon |			posx := scale scale: t.			currentLevelLine endPoint: posx @ lineWidth negated.			level children first text: t asInteger asString.			level				adjustToChildren;				padding: 3.			level position: currentLevelLine endPoint.			icon := icons first.			icon model <= t asInteger ifTrue: [				icon addShape: accept copy.				icon shapes first color: Color black translucent.				icons removeFirst ].			c signalUpdate ].	c		when: RSExtentChangedEvent		do: [			c				zoomToFit;				signalUpdate ]		for: self.	^ c! !!RSBasicAnimationExamples methodsFor: 'accessing'!order	^ 10! !!RSBasicShapeExamples methodsFor: 'boxes and ellipses'!example01BasicBoxes	<script: 'self new example01BasicBoxes open'>	| c |	c := RSCanvas new.	c addShape: (RSBox new		extent: 100@100;		yourself).	c addShape: (RSBox new		position: 100@100;		color: Color blue;		extent: 100@100;		yourself).	^ c! !!RSBasicShapeExamples methodsFor: 'boxes and ellipses'!example02BasicEllipses	<script: 'self new example02BasicEllipses open'>	| c |	c := RSCanvas new.	c addShape: (RSEllipse new		extent: 100@100;		yourself).	c addShape: (RSEllipse new		position: 100@100;		color: Color red;		extent: 100@100;		yourself).	^ c! !!RSBasicShapeExamples methodsFor: 'composite'!example03BasicComposite	<script: 'self new example03BasicComposite open'>	| c com |	c := RSCanvas new.	com := RSComposite new.	com add: (RSBox new		color: (Color gray alpha: 0.4);		extent: 100@100;		yourself).	com add: (RSBox new		position: 100@100;		color: (Color red alpha: 0.4);		extent: 100@100;		yourself).	c addShape: com.	c addShape: (RSEllipse new		color: (Color gray alpha: 0.4);		extent: 100@100;		yourself).	c addShape: (RSEllipse new		position: 100@100;		color: (Color red alpha: 0.4);		extent: 100@100;		yourself).	^ c! !!RSBasicShapeExamples methodsFor: 'composite'!example04BasicComposite	<script: 'self new example04BasicComposite open'>	| c com |	c := RSCanvas new.	com := RSComposite new.	com add: (RSBox new		color: (Color yellow alpha: 0.5);		position: -50 @ 0;		extent: 50@100;		yourself).	com add: (RSBox new		position: 0 @ 0;		color: (Color red alpha: 0.5);		extent: 50@100;		yourself).	com position: 100@100.	c addShape: com.	c addShape: (RSEllipse new		color: (Color gray alpha: 0.5);		extent: 100@100;		yourself).	c addShape: (RSEllipse new		color: (Color gray alpha: 0.5);		extent: 20@20;		yourself).	^ c! !!RSBasicShapeExamples methodsFor: 'boxes and ellipses'!example05BasicGroup	<script: 'self new example05BasicGroup inspect'>	| g |	g := RSGroup new.	g add: (RSBox new		color: (Color yellow alpha: 0.5);		position: -50 @ 0;		extent: 50@100;		yourself).	g add: (RSBox new		position: 0 @ 0;		color: (Color red alpha: 0.5);		extent: 50@100;		yourself).	g add: (RSEllipse new		color: (Color gray alpha: 0.5);		extent: 100@100;		yourself).	g add: (RSEllipse new		color: (Color gray alpha: 0.5);		extent: 20@20;		yourself).	^ g! !!RSBasicShapeExamples methodsFor: 'labels'!example06BasicLabels	<script: 'self new example06BasicLabels open'>	| c label |	c := RSCanvas new.	1 to: 12 do: [ :m |		| angle theta p|		angle := (m * 360 / 12) degreesToRadians.		theta := angle cos @ angle sin.		p := theta * 100.		label := RSLabel new			color: (Color purple alpha: 0.5);			fontName: 'Source Sans Pro';			fontSize: 20;			text: (Month nameOfMonth: m);			yourself.		angle := angle radiansToDegrees.		angle := angle + ((angle between: 90 and: 270)			ifTrue: [ 180 ]			ifFalse: [ 0 ] ).		label rotateByDegrees: angle.		label position: p + ((label textWidth/2) * theta).		m even			ifTrue: [ label bold ]			ifFalse: [ label italic ].		c addShape: label.		].	c addShape: (RSEllipse new		color: nil;		withBorder;		radius: 90).	^ c! !!RSBasicShapeExamples methodsFor: 'events'!example07EventsMouseMoveDrag	<script: 'self new example07EventsMouseMoveDrag open'>	| c ellipse update |	c := RSCanvas new.	ellipse := RSEllipse new		           radius: 40;		           border: (RSBorder new color: 'black');		           yourself.	c addShape: ellipse.	update := [ :evt :color |	          ellipse		          color: color;		          position: evt position;		          signalUpdate ].	c		when: RSMouseDragging		do: [ :evt | update value: evt value: (Color colorFrom: '12A288') ]		for: self;		when: RSMouseMove		do: [ :evt | update value: evt value: (Color colorFrom: 'AB2567') ]		for: self.	c shouldClearBackground: false.	^ c! !!RSBasicShapeExamples methodsFor: 'boxes and ellipses'!example08EllipseBorder	<script: 'self new example08EllipseBorder open'>	| c y r |	c := RSCanvas new.	r := Random new.	c color: (Color colorFrom: '325A64').	1 to: 500 do: [ :x|		y := 255 + (x sin * 255).		c addShape: (RSEllipse new			color: Color transparent;			border: (RSBorder new				width: x/ 50;				color: (Color					r: r next * 255					g: r next * 200					b: 255					range: y) );			position: (x*2@y)-250;			extent: (y/10)@( x * 75/ 499 ) ).		 ].	"m := c morph.	PolymorphSystemSettings setDesktopLogoWith: m.	m position: 0@World menubar height.	m extent: World extent- (0@World menubar height)."	^ c! !!RSBasicShapeExamples methodsFor: 'events'!example09MouseStep	<script: 'self new example09MouseStep open'>	| c e prev dif |	c := RSCanvas new.	c color: Color black.	e := RSEllipse new		     border: (RSBorder new color: Color white);		     radius: 0.	c addShape: e.	prev := 0.	c		when: RSMouseMove		do: [ :evt |			dif := (evt position x - prev) abs.			prev := evt position x.			e				color: (Color						 r: 0						 g: dif						 b: 0						 range: 255);				position: evt position;				size: dif.			c signalUpdate ]		for: self.	c shouldClearBackground: false.	^ c! !!RSBasicShapeExamples methodsFor: 'events'!example10EllipseMouseMove	<script: 'self new example10EllipseMouseMove open'>	| c border circleResolution angle a b radius p |	c := RSCanvas new.	c color: Color white.	border := RSBorder new color: (Color colorFrom: '002800').	b := 1.	radius := 200.	c		when: RSMouseMove		do: [ :evt |			circleResolution := b.			circleResolution isZero ifTrue: [ circleResolution := 0.1 ].			angle := Float twoPi / circleResolution.			p := evt position abs.			a := 175 * p x / c extent x.			b := 200 * p y / c extent y.			c shapes copy do: #remove.			0 to: circleResolution do: [ :i |				c addShape: (RSEllipse new						 color: Color transparent;						 rotateByDegrees: 45;						 border: border;						 extent: (angle * i) cos @ (angle * i) sin * radius + a) ].			c signalUpdate ]		for: self.	^ c! !!RSBasicShapeExamples methodsFor: 'events'!example11ScaleMouseDistance	<script: 'self new example11ScaleMouseDistance open'>	| c easing canvasExtent boxSize zindex maxDist scale border |	c := RSCanvas new.	c color: Color white.	easing := 0 @ 0.	boxSize := 50.	canvasExtent := 500 asPoint.	maxDist := 0 @ 0 distanceTo: canvasExtent.	scale := NSScale linear		         domain: {				         0.				         maxDist };		         rangeRound: #( 80 0 ).	border := RSBorder new color: Color black.	c		when: RSExtentChangedEvent		do: [			c shapes copy do: #remove.			canvasExtent := c extent.			maxDist := 0 @ 0 distanceTo: canvasExtent.			scale := NSScale linear				         domain: {						         0.						         maxDist };				         rangeRound: #( 80 0 ).			0 to: canvasExtent y / boxSize do: [ :y |				0 to: canvasExtent x / boxSize do: [ :x |					c addShape: (RSBox new							 color: Color white;							 position: x @ y * boxSize - (canvasExtent / 2);							 extent: 10 @ 10;							 border: border) ] ] ]		for: self.	c		when: RSMouseMove		do: [ :evt |			easing := easing + (evt position - easing * 1).			c shapes copy do: [ :s |				zindex := scale scale: (easing distanceTo: s position).				s extent: boxSize * (zindex / 100) asPoint ].			c signalUpdate ]		for: self.	c shouldClearBackground: false.	^ c! !!RSBasicShapeExamples methodsFor: 'lines'!example12BasicLine	<script: 'self new example12BasicLine open'>	| c rotate size angle |	c := RSCanvas new.	angle := 0.	size := 0.	rotate := [ :point |	          | cos sin p |	          cos := angle cos.	          sin := angle sin.	          "origin"	          p := point - (size @ size / 2).	          "rotated"	          p x * cos - (p y * sin) @ (p y * cos + (p x * sin)) ].	c		when: RSMouseMove		do: [ :evt |			size := evt position distanceTo: 0 @ 0.			angle := evt position angle + 135 degreesToRadians.			c shapes copy do: #remove.			size := size asInteger.			(0 to: size by: 3) do: [ :k |				| a b |				a := rotate value: k @ 0.				b := rotate value: 0 @ (size - k).				c addShape: (RSLine new						 startPoint: a;						 endPoint: b;						 yourself) ].			c signalUpdate ]		for: self.	^ c! !!RSBasicShapeExamples methodsFor: 'bitmap'!example14BasicBitmap	<script: 'self new example14BasicBitmap open'>	| c |	c := RSCanvas new.	c addShape: (RSBitmap new		form: (self iconNamed: #eyedropper);		extent: 200@350).	^ c! !!RSBasicShapeExamples methodsFor: 'boxes and ellipses'!example15BasicRoundBoxes	<script: 'self new example15BasicRoundBoxes open'>	| c |	c := RSCanvas new.	c addShape: (RSBox new		cornerRadius: 5;		extent: 100@50).	c addShape: (RSBox new		cornerRadius: (RSCornerRadius new top: 20);		position: 100@100;		extent: 100@50;		withBorder).	^ c! !!RSBasicShapeExamples methodsFor: 'border'!example17Borders	<script: 'self new example17Borders open'>	| c |	c := RSCanvas new.	c addShape: (RSLine new		startPoint: -100@ -100;		endPoint: 100@ -100;		width: 50;		capRound;		yourself).	c addShape: (RSLine new		startPoint: -100@ 0;		endPoint: 100@ 0;		width: 50;		capButt;		yourself).	c addShape: (RSLine new		startPoint: -100@ 100;		endPoint: 100@ 100;		width: 50;		capSquare;		yourself).	^ c! !!RSBasicShapeExamples methodsFor: 'arcs'!example18BasicPieSlice	<script: 'self new example18BasicPieSlice open'>	| c |	c := RSCanvas new.	"empty"	c addShape: RSPieSlice new.	"circle"	c addShape: (RSPieSlice new		innerRadius: 0;		externalRadius: 100;		alphaAngle: 0;		betaAngle: 360).	^ c! !!RSBasicShapeExamples methodsFor: 'arcs'!example19PieSlice	<script: 'self new example19PieSlice open'>	| c |	c := RSCanvas new.	"slice"	c addShape: (RSPieSlice new		externalRadius: 100;		innerRadius: 50;		alphaAngle: 30;		betaAngle: 90;		segmentSpacing: 5).	^ c! !!RSBasicShapeExamples methodsFor: 'arcs'!example20Donut	<script: 'self new example20Donut open'>	| c |	c := RSCanvas new.	"donut"	c addShape: (RSPieSlice new		withBorder;		externalRadius: 100;		innerRadius: 50;		alphaAngle: 0;		betaAngle: 360).	^ c! !!RSBasicShapeExamples methodsFor: 'arcs'!example21CornerRadii	<script: 'self new example21CornerRadii open'>	| c |	c := RSCanvas new.	"corner radii"	c addShape: (RSPieSlice new		externalRadius: 100;		innerRadius: 50;		alphaAngle: 0;		betaAngle: 90;		cornerRadii: 20).	^ c! !!RSBasicShapeExamples methodsFor: 'arcs'!example22BasicPieSlice	<script: 'self new example22BasicPieSlice open'>	| c |	c := RSCanvas new.	"slice"	c addShape: (RSPieSlice new		externalRadius: 100;		alphaAngle: 30;		betaAngle: 90).	^ c! !!RSBasicShapeExamples methodsFor: 'boxes and ellipses'!example23FixedShape	<script: 'self new example23FixedShape open'>	| c box |	c := RSCanvas new.	box := RSBox new		extent: 100@100;		position: 200 asPoint;		color: Color blue;		yourself.	box isFixed: true.	c addShape: box.	box := RSBox new		extent: 100@100;		yourself.	c addShape: box.	box setAsFixed.	^ c! !!RSBasicShapeExamples methodsFor: 'lines'!example24Polyline	<script: 'self new example24Polyline open'>	| c |	c := RSCanvas new.	c addShape: (RSPolyline new		width: 30;		joinRound;"joinBevel; joinMiter"		color: Color blue;		controlPoints: { 50@300. 150@300. 150@200. 250@200. 250@100. 350@100};		basicTranslateBy: -150 @ -150;		yourself).	^ c! !!RSBasicShapeExamples methodsFor: 'labels'!example25LabelWithBorder	<script: 'self new example25LabelWithBorder open'>	| c |	c := RSCanvas new.	c addShape: (RSLabel new		fontSize: 60;		fontName: 'Source Sans Pro';		"fontName: 'Brushcrazy DEMO';"		border: (RSBorder new			color: Color red;			dashArray: #(4) );		text: 'Roassal Pharo').	^ c! !!RSBasicShapeExamples methodsFor: 'polygons'!example26Polygon	<script: 'self new example26Polygon open'>	| c |	c := RSCanvas new.	c addShape: (RSPolygon new			 points: {					 (100 @ 10).					 (40 @ 198).					 (190 @ 78).					 (10 @ 78).					 (160 @ 198) };			 yourself).	c shapes first translateTo: 0 @ 0.	c showEncompassingRectangles.	c shapes first		when: RSMouseDragging		do: [ :evt |			evt shape				translateBy: evt step;				signalUpdate ]		for: self.	^ c! !!RSBasicShapeExamples methodsFor: 'lines'!example27Markers	<script: 'self new example27Markers open'>	| c arrow axes circle dataLine |	c := RSCanvas new.	arrow := RSPolygon new		points: { -10@0. 0@ -10. 10@0 };		color: Color black;		size: 10.	circle := RSEllipse new		radius: 2.5;		color: Color red.	axes := RSPolyline new		controlPoints: { 10@10. 10@90. 90@90 }.	dataLine := RSPolyline new		controlPoints: { 15@80. 29@50. 43@60. 57@30. 71@40. 85@15 }.	axes markerEnd: (axes markerStart: arrow).	dataLine marker: circle.	axes model: 'Axes'.	axes popup.	dataLine model: 'Series'.	dataLine popup.	c addShape: axes.	c addShape: dataLine.	c camera zoomToFit: 250@250.	^ c! !!RSBasicShapeExamples methodsFor: 'lines'!example29PolylineRadius	<script: 'self new example29PolylineRadius open '>	| c |	c := RSCanvas new.	c addShape: (RSPolyline new		border: (RSBorder new width: 10);		cornerRadii: 50;		controlPoints: { 5@30. 15@30. 15@20. 25@20. 25@10. 35@10} * 50).	c zoomToFit.	^ c! !!RSBasicShapeExamples methodsFor: 'polygons'!example30PolygonWithRadius	<script: 'self new example30PolygonWithRadius open'>	| c |	c := RSCanvas new.	c addShape: (RSPolygon new			 cornerRadii: 10;			 points: {					 (100 @ 10).					 (40 @ 198).					 (190 @ 78).					 (10 @ 78).					 (160 @ 198) };			 yourself).	c shapes first translateTo: 0 @ 0.	c showEncompassingRectangles.	c shapes first		when: RSMouseDragging		do: [ :evt |			evt shape				translateBy: evt step;				signalUpdate ]		for: self.	^ c! !!RSBasicShapeExamples methodsFor: 'boxes and ellipses'!example31BorderAttachPointWithOffset	<script: 'self new example31BorderAttachPointWithOffset open'>	| c s1 s2|	c := RSCanvas new.	s1 := RSEllipse new		size: 30;		yourself.	s2 := RSBox new		size: 50;		yourself.	s2 translateTo: 200@200.	c add: s1; add: s2.	c add: (RSLine new		attachPoint: (RSBorderAttachPoint new			startOffset: 5;			endOffset: 10;			yourself);		from: s1;		to: s2;		yourself).	c nodes @ RSDraggable.	c @ RSCanvasController.	^ c! !!RSBasicShapeExamples methodsFor: 'events'!example32RotateShapeByMouse	<script: 'self new example32RotateShapeByMouse open'>	| c s |	c := RSCanvas new.	s := RSLabel new		text: 'Dehaka';		draggable;		yourself.	c add: s.	s @ RSRotated.	^ c! !!RSBasicShapeExamples methodsFor: 'lines'!example33EdgesBetweenChildren	<script: 'self new example33EdgesBetweenChildren open'>	| c b1 b2 e1 com1 com2 |	c := RSCanvas new.	com1 := RSComposite new.	com1 paint: Color blue translucent.	b1 := RSBox new size: 10.	com1 add: b1.	com1 adjustToChildren.	b1 position: 20@20.	com1 position: 200@0.	com2 := RSComposite new.	com2 paint: Color blue translucent.	b2 := RSBox new size: 10.	com2 add: b2.	com2 adjustToChildren.	b2 position: 50@0.	com2 position: -100@0.	com1 draggable.	com2 draggable.	e1 := RSLine new from: b1; to: b2.	c addAll: { com1. com2. e1 }.	^ c! !!RSBasicShapeExamples methodsFor: 'composite'!example34PaletteVisualization	<script: 'self new example34PaletteVisualization open'>	| c colors shapes compo label composites paletteObject |	"Try		RSColorPalette qualitative		RSColorPalette sequential	"	paletteObject := RSColorPalette diverging.	c := RSCanvas new.	composites := OrderedCollection new.	paletteObject class selectors do: [ :selector |		colors := paletteObject perform: selector.		shapes := RSGroup new.		shapes addAll: (colors range collect: [ :aColor | RSBox new size: 20; color: aColor ]).		RSHorizontalLineLayout on: shapes.		compo := RSComposite new.		compo shapes: shapes.		c add: compo.		composites add: compo.		label := RSLabel new text: selector.		c add: label.		RSLocation new			left; outer; stick: label on: compo.	].	RSVerticalLineLayout on: composites.	c @ RSCanvasController.	^ c! !!RSBasicShapeExamples methodsFor: 'events'!example35KeyEvents	<script:	'self new example35KeyEvents open setLabel: ''Use the keyboard'''>	| c print down up |	c := RSCanvas new.	down := RSLabel new		        model: 'DOWN';		        text: ''.	up := RSLabel new		      model: 'UP';		      text: '';		      position: 0 @ 30.	c addAll: {			down.			up }.	print := [ :evt :s |	         s text:		         s model , ': ' , evt keyName , ', value: '		         , evt keyValue asString.	         evt signalUpdate ].	c		when: RSKeyDown		do: [ :evt | print value: evt value: down ]		for: self;		when: RSKeyUp do: [ :evt | print value: evt value: up ] for: self.	^ c! !!RSBasicShapeExamples methodsFor: 'polygons'!example36PolygonAndCanvas	<script: 'self new example36PolygonAndCanvas open setLabel: ''Zoom in or Zoom out'''>	| coords canvas int |	coords := {(13.3540698 @ 52.5346676).	(13.3531445 @ 52.5339734).	(13.347075 @ 52.530959).	(13.343642 @ 52.531777).	(13.3392352 @ 52.5329414).	(13.33869 @ 52.531065).	(13.337552 @ 52.526725).	(13.3278908 @ 52.5276262).	(13.327312 @ 52.524392).	(13.3268118 @ 52.5234332).	(13.326025 @ 52.523974).	(13.31646 @ 52.499445).	(13.330889 @ 52.500452).	(13.331878 @ 52.500556).	(13.33527 @ 52.499405).	(13.334371 @ 52.498542).	(13.335189 @ 52.498098).	(13.33451 @ 52.497572).	(13.33469 @ 52.495098).	(13.336883 @ 52.494522).	(13.33899 @ 52.494246).	(13.345728 @ 52.494409).	(13.345127 @ 52.492168).	(13.3453118 @ 52.4866845).	(13.3497232 @ 52.4870749).	(13.3507406 @ 52.4862916).	(13.3527267 @ 52.4846656).	(13.3529346 @ 52.4841626).	(13.381439 @ 52.4848815).	(13.3846565 @ 52.4848903).	(13.3860099 @ 52.4846622).	(13.386044 @ 52.483165).	(13.386408 @ 52.483036).	(13.386736 @ 52.483048).	(13.386892 @ 52.483063).	(13.3540698 @ 52.5346676)}.	canvas := RSCanvas new.	canvas addShape: (RSPolygon new		points: coords;		color: Color black).	int := RSCanvasController new.	int configuration		minScale: 1000;		maxScale: 10000.	canvas @ int.	^ canvas! !!RSBasicShapeExamples methodsFor: 'polygons'!example37AngleDirection	<script: 'self new example37AngleDirection open setLabel: ''Angle direction in RSPieSlice'''>	| canvas slice magic |	canvas := RSCanvas new.	slice := RSPieSlice new.	slice		innerRadius: 100;		externalRadius: 150;		alphaAngle: 15;		betaAngle: 180.	canvas add: slice.	canvas add: (RSLine new		startPoint: 0@ -200;		endPoint: 0 @ 200;		dashed;		markerStartEnd: (RSShapeFactory arrow			size: 10);		yourself).	canvas add: (RSLine new		startPoint: -200@ 0;		endPoint: 200 @ 0;		dashed;		markerStartEnd: (RSShapeFactory arrow			size: 10);		yourself).	canvas add: (RSLabel new		text: '0@0';		position: 20@10;		yourself).	magic := 160*0.551784.	canvas add: (RSBezier new		width: 3;		dashed;		markerEnd: (RSShapeFactory arrow			size: 20;			color: Color black);		controlPoints:			{160@0.			160@ magic negated.			magic@ -160.			0@ -160  };		yourself		).	canvas add: (RSLabel new		text: 'Angle direction';		color: 'blue';		position: 180@ -130;		yourself).	^ canvas! !!RSBasicShapeExamples methodsFor: 'shapes'!example38Interaction	<script: 'self new example38Interaction open'>	| c1 c2 com canvas |	c1 := RSEllipse new		      extent: 100 @ 50;		      withBorder;		      model: 'Click to remove';		      popup;		      color: Color red translucent;		      yourself.	c2 := RSEllipse new		      extent: 50 @ 100;		      withBorder;		      color: Color blue translucent;		      yourself.	com := {		       c1.		       c2 } asShape		       model: 'Draggable';		       popup;		       @ RSDraggable new noValidateChildrenEvents;		       padding: 10;		       color: Color gray translucent;		       yourself.	c1		when: RSMouseClick		do: [ :evt |			c1 remove.			com removeInteractionIfPresent: RSDraggable.			com model: 'Not draggable anymore'.			evt signalUpdate ]		for: self.	canvas := RSCanvas new.	canvas add: (RSEllipse new			 color: Color red;			 model: 'Reference';			 popup;			 size: 10;			 yourself).	canvas add: com.	canvas @ RSCanvasController.	^ canvas! !!RSBasicShapeExamples methodsFor: 'shapes'!example39YikigeiAnimated	<script: 'self new example39YikigeiAnimated open'>	| c size circles posOffset negOffset |	c := RSCanvas new.	size := 200.	c addAll: (circles := #( magenta yellow red cyan ) collect: [ :sel |			            c add: (RSEllipse new					             size: size;					             color: ((Color perform: sel) alpha: 0.4);					             yourself) ]).	c		when: RSMouseMove		do: [ :evt |			posOffset := evt position distanceTo: 0 @ 0.			negOffset := posOffset negated.			circles first position: posOffset @ 0.			circles second position: 0 @ posOffset.			circles third position: negOffset @ 0.			circles fourth position: 0 @ negOffset.			c signalUpdate ]		for: self.	^ c! !!RSBasicShapeExamples methodsFor: 'shapes'!example40ColorScale	<script: 'self new example40ColorScale open'>	| color canvas popup shapes |	color := NSScale linear	    domain: { 1. 200. 400 };	    range: #(white gray red).	canvas := RSCanvas new.	popup := RSPopup text: [ :cls |	    cls name, String crlf,	    'Nro Methods: ', cls numberOfMethods asString, String crlf,	    'Lines of Code: ', cls linesOfCode asString ].	shapes := Collection withAllSubclasses collect: [ :cls |	    RSBox new	        model: cls;	        @ popup;	        draggable;	        color:( color scale: cls numberOfMethods );	        size: cls linesOfCode sqrt + 10;	        yourself	     ].	canvas addAll: shapes.	RSLineBuilder orthoVertical	    withVerticalAttachPoint;	    shapes: shapes;	    connectFrom: #superclass.	RSTreeLayout on: shapes.	canvas @ RSCanvasController.	^ canvas! !!RSBasicShapeExamples methodsFor: 'lines'!example41PopupAndMarkers	<script: 'self new example41PopupAndMarkers open'>	| line marker canvas |	line := RSLine new.	line startPoint: 300@300; endPoint: 500@300.	marker := RSShapeFactory star size: 40.	line markerEnd: marker.	line @ RSPopup new.	line model: 'Magic stick'.	canvas := RSCanvas new add: line; yourself.	canvas zoomToFit.	^ canvas! !!RSBasicShapeExamples methodsFor: 'lines'!example42GhostDraggable	<script: 'self new example42GhostDraggable open'>	| canvas b1 b2 |	canvas := RSCanvas new.	canvas add: (b1:=RSBox new		color: Color green translucent;		size: 100;		yourself).	canvas add: (b2:=RSBox new		size: 100;		position: 150 asPoint;		color: Color purple translucent;		yourself).	canvas shapes addInteraction: RSGhostDraggable new.	canvas add: (RSLine new		from: b1;		to: b2;		yourself).	^ canvas! !!RSBasicShapeExamples methodsFor: 'lines'!example43ShortestAttachPoint	<script: 'self new example43ShortestAttachPoint open'>	| canvas numbers marker |	canvas := RSCanvas new.	numbers := (1 to: 10) shuffled collect: [ :n |		({ RSLabel text: n } asGroup asShapeFor: n)			color: Color white;			withBorder;			padding: 10;			yourself ] as: RSGroup.	numbers @ RSDraggable new.	canvas addAll: numbers.	marker := (RSShapeFactory arrow		size: 10;		asMarker)		offset: 5;		yourself.	RSLineBuilder line		attachPoint: (RSShortestVerticalAttachPoint new			"endOffset: 5;"			yourself);		canvas: canvas;		markerEnd: marker;		color: Color gray translucent;		fromShapes: (numbers select: [:each | each model even]);		toShapes: numbers;		connectTo: [ :n | n + 1 ].	RSLineBuilder line		attachPoint: (RSShortestHorizontalAttachPoint new			"endOffset: 5;"			yourself);		canvas: canvas;		markerEnd: marker;		color: Color gray translucent;		fromShapes: (numbers select: [:each | each model odd]);		toShapes: numbers;		connectTo: [ :n | n + 1 ].	RSSimpleForceBasedLayout on: numbers.	canvas @ RSCanvasController simple.	^ canvas! !!RSBasicShapeExamples methodsFor: 'lines'!example44AA	<script: 'self new example44AA open'>	| canvas |	canvas := RSCanvas new.	canvas		add: (RSBox new				 size: 30;				 color: 'blue';				 yourself);		add: (RSLine new				 width: 0.5;				 startPoint: 0 @ 0;				 endPoint: 50 asPoint;				 color: 'black';				 yourself);		add: (RSEllipse new				 extent: 40 @ 50;				 color: 'gray';				 yourself);		add: (RSLabel new				 text: 'AA enabled';				 color: 'black';				 yourself).	RSGridLayout on: canvas shapes.	canvas zoomToFit.	canvas newAnimation		repeat;		onStepDo: [ :t |			canvas shapes last text: (canvas hasAntialiasing						 ifTrue: [ 'AA enabled' ]						 ifFalse: [ 'AA disabled' ]).			canvas signalUpdate ];		when: RSAnimationLoopEvent do: [ :evt |			canvas hasAntialiasing				ifTrue: [ canvas disableAntialiasing ]				ifFalse: [ canvas enableAntialiasing ].			canvas signalUpdate ]		for: self.	^ canvas! !!RSBasicShapeExamples methodsFor: 'accessing'!order	^ 0! !!RSDSMExample class methodsFor: 'example-data'!collab	^ 'time	n1	n2 	weight2005	Lea	Lucas	4.02005	Lucas	Lea	4.02005	Nathan	Nathan	1.02005	Lucas	Lucas	1.02005	Lea	Lea	1.02005	Louise	Louise	2.02006	Lucas	Nathan	2.02006	Nathan	Louise	2.02006	Lucas	Lea	8.02006	Louise	Nathan	2.02006	Louise	Lucas	2.02006	Lea	Lucas	8.02006	Nathan	Lucas	2.02006	Lucas	Louise	2.02006	Lucas	Lucas	3.02006	Emma	Emma	1.02006	Louise	Louise	1.02007	Lucas	Camille	4.02007	Lucas	Enzo	2.02007	Lea	Nathan	2.02007	Nathan	Camille	4.02007	Enzo	Lucas	2.02007	Emma	Lea	2.02007	Louise	Camille	4.02007	Lea	Camille	2.02007	Lucas	Emma	2.02007	Camille	Lea	2.02007	Enzo	Lea	2.02007	Chloe	Louise	2.02007	Chloe	Camille	2.02007	Louise	Nathan	8.02007	Lea	Lucas	8.02007	Nathan	Chloe	2.02007	Lucas	Chloe	2.02007	Chloe	Lucas	2.02007	Camille	Chloe	2.02007	Nathan	Lucas	8.02007	Emma	Lucas	2.02007	Chloe	Nathan	2.02007	Louise	Lea	2.02007	Camille	Nathan	4.02007	Nathan	Louise	8.02007	Lucas	Louise	8.02007	Lucas	Nathan	8.02007	Chloe	Lea	2.02007	Lea	Louise	2.02007	Lea	Emma	2.02007	Nathan	Lea	2.02007	Lea	Chloe	2.02007	Louise	Lucas	8.02007	Camille	Lucas	4.02007	Lea	Enzo	2.02007	Louise	Chloe	2.02007	Camille	Louise	4.02007	Lucas	Lea	8.02007	Hugo	Hugo	2.02007	Louise	Louise	1.02007	Sarah	Sarah	1.02007	Camille	Camille	1.02007	Enzo	Enzo	1.02007	Emma	Emma	1.02007	Chloe	Chloe	1.02008	Louise	Camille	2.02008	Emma	Lucas	2.02008	Camille	Louise	2.02008	Lucas	Gabriel	2.02008	Lucas	Camille	4.02008	Camille	Nathan	4.02008	Nathan	Louise	4.02008	Lucas	Louise	4.02008	Lucas	Nathan	6.02008	Louise	Lucas	4.02008	Camille	Lea	2.02008	Camille	Lucas	4.02008	Nathan	Lucas	6.02008	Nathan	Lea	2.02008	Lucas	Lea	2.02008	Nathan	Camille	4.02008	Emma	Enzo	2.02008	Gabriel	Lucas	2.02008	Louise	Nathan	4.02008	Lea	Camille	2.02008	Lea	Lucas	2.02008	Lea	Louise	2.02008	Lea	Nathan	2.02008	Enzo	Emma	2.02008	Lucas	Emma	2.02008	Louise	Lea	2.02008	Camille	Camille	1.02008	Emma	Emma	3.02008	Sarah	Sarah	1.02008	Gabriel	Gabriel	2.02008	Hugo	Hugo	1.02008	Louise	Louise	1.02009	Hugo	Lucas	4.02009	Lucas	Sarah	2.02009	Lucas	Lea	2.02009	Louise	Hugo	2.02009	Louise	Camille	4.02009	Hugo	Louise	2.02009	Enzo	Hugo	4.02009	Gabriel	Nathan	4.02009	Enzo	Louise	2.02009	Lea	Lucas	2.02009	Sarah	Lucas	2.02009	Camille	Nathan	4.02009	Camille	Hugo	2.02009	Enzo	Camille	2.02009	Louise	Gabriel	10.02009	Camille	Lucas	6.02009	Emma	Enzo	2.02009	Enzo	Lucas	2.02009	Camille	Enzo	2.02009	Gabriel	Louise	10.02009	Lucas	Camille	6.02009	Sarah	Louise	2.02009	Nathan	Louise	6.02009	Nathan	Camille	4.02009	Nathan	Lea	2.02009	Camille	Lea	2.02009	Gabriel	Lucas	10.02009	Nathan	Gabriel	4.02009	Louise	Nathan	6.02009	Louise	Sarah	2.02009	Nathan	Lucas	8.02009	Enzo	Emma	2.02009	Louise	Enzo	2.02009	Camille	Sarah	2.02009	Lea	Camille	2.02009	Hugo	Camille	2.02009	Enzo	Sarah	4.02009	Lucas	Hugo	4.02009	Sarah	Camille	2.02009	Camille	Louise	4.02009	Hugo	Enzo	4.02009	Sarah	Enzo	4.02009	Lucas	Louise	14.02009	Lucas	Enzo	2.02009	Lucas	Gabriel	10.02009	Lea	Nathan	2.02009	Lucas	Nathan	8.02009	Lea	Louise	2.02009	Louise	Lea	2.02009	Sarah	Hugo	2.02009	Hugo	Sarah	2.02009	Louise	Lucas	14.02009	Sarah	Sarah	1.02009	Camille	Camille	1.02009	Hugo	Hugo	1.02009	Gabriel	Gabriel	2.02009	Emma	Emma	4.02010	Nathan	Lea	2.02010	Sarah	Lucas	4.02010	Lea	Nathan	2.02010	Camille	Sarah	2.02010	Gabriel	Lucas	10.02010	Louise	Lea	2.02010	Hugo	Lucas	6.02010	Nathan	Camille	4.02010	Enzo	Louise	2.02010	Nathan	Lucas	6.02010	Camille	Hugo	2.02010	Lucas	Nathan	6.02010	Lucas	Hugo	6.02010	Lucas	Camille	6.02010	Louise	Gabriel	12.02010	Louise	Camille	4.02010	Sarah	Louise	4.02010	Hugo	Louise	2.02010	Lucas	Sarah	4.02010	Gabriel	Sarah	2.02010	Camille	Louise	4.02010	Nathan	Gabriel	2.02010	Camille	Lucas	6.02010	Nathan	Louise	4.02010	Lucas	Lea	2.02010	Enzo	Camille	2.02010	Enzo	Lucas	2.02010	Lucas	Enzo	2.02010	Lucas	Gabriel	10.02010	Hugo	Enzo	2.02010	Sarah	Gabriel	2.02010	Louise	Hugo	2.02010	Lea	Lucas	2.02010	Camille	Nathan	4.02010	Sarah	Enzo	2.02010	Gabriel	Louise	12.02010	Camille	Enzo	2.02010	Lucas	Louise	14.02010	Louise	Lucas	14.02010	Enzo	Sarah	2.02010	Hugo	Sarah	2.02010	Enzo	Hugo	2.02010	Louise	Sarah	4.02010	Sarah	Hugo	2.02010	Lea	Louise	2.02010	Camille	Lea	2.02010	Sarah	Camille	2.02010	Lea	Camille	2.02010	Hugo	Camille	2.02010	Louise	Enzo	2.02010	Gabriel	Nathan	2.02010	Louise	Nathan	4.02010	Enzo	Enzo	1.02010	Emma	Emma	1.02010	Chloe	Chloe	1.02010	Camille	Camille	1.02010	Hugo	Hugo	1.0'! !!RSDSMExample class methodsFor: 'example-data'!gtinspector	^ 'time	n1	n2 	weight51	GTExample	AndreiChis	151	GTExample	StefanReichhart	347	GTExample	StefanReichhart	1546	GTExample	StefanReichhart	1049	GTExample	StefanReichhart	5852	GTExample	StefanReichhart	548	GTExample	StefanReichhart	1949	GTExampleFinder	StefanReichhart	1248	GTExampleFinder	StefanReichhart	647	GTExampleFinder	StefanReichhart	246	GTExampleFinder	StefanReichhart	449	GTExampleResult	StefanReichhart	148	GTExampleResult	StefanReichhart	1452	GTExampleResult	StefanReichhart	146	GTExampleResult	StefanReichhart	249	GTExampleProcessor	StefanReichhart	948	GTExampleProcessor	StefanReichhart	847	GTExampleProcessor	StefanReichhart	740	GTInspectorMethodListFilter	AndreiChis	1249	GTExampleProxy	StefanReichhart	348	GTExampleProxy	StefanReichhart	1647	GTExampleProxy	StefanReichhart	546	GTExampleProxy	StefanReichhart	240	GTInspectorTagFilter	AndreiChis	1141	GTInspectorTagFilter	AndreiChis	251	GTExampleOrganizer	AndreiChis	347	GTExampleOrganizer	StefanReichhart	546	GTExampleOrganizer	StefanReichhart	149	GTExampleOrganizer	StefanReichhart	2148	GTExampleOrganizer	StefanReichhart	20	GTInspector	TudorGirba	140	GTInspector	AndreiChis	140	GTInspector	EstebanLorenzano	136	GTInspector	AndreiChis	344	GTInspector	TudorGirba	131	GTInspector	TudorGirba	238	GTInspector	AndreiChis	338	GTInspector	SvenVanCaekenberghe	141	GTInspector	AndreiChis	649	GTExampleNautilus	StefanReichhart	252	GTExampleNautilus	StefanReichhart	551	GTExampleNautilus	JurajKubelka	2'! !!RSDSMExample methodsFor: 'sources'!example01Numbers	<script: 'self new example01Numbers open'>	| dsm |	dsm := RSDSM new.	dsm objects: (1 to: 10).	dsm dependency: [ :aValue | aValue // 2 ].	^ dsm! !!RSDSMExample methodsFor: 'sources'!example02Numbers	<script: 'self new example02Numbers open'>	| dsm |	dsm := RSDSM new.	dsm objectsX: (1 to: 10).	dsm objectsY: (1 to: 10 by: 2).	dsm dependency: [ :aValue | aValue // 2 ].	^ dsm! !!RSDSMExample methodsFor: 'sources'!example03Classes	<script: 'self new example03Classes open'>	| dsm |	dsm := RSDSM new.	dsm objects: RSShape withAllSubclasses.	dsm setShouldFeedY.	dsm dependency: #dependentClasses.	dsm shape popup.	^ dsm! !!RSDSMExample methodsFor: 'sources'!example04Token	<script: 'self new example04Token open'>	| packageRegExp packages getKeywordsFromClass rawKeywords top10Keywords dsm |	packageRegExp := { 'Roassal3-*'  }.	packages := RPackageOrganizer default packages select: [ :p |		packageRegExp anySatisfy: [ :r | r match: p packageName ] ].	getKeywordsFromClass := [ :cls |		(cls name cutCamelCase, ((((cls methods collect: #selector) flatCollect: [:k |			k substrings: ':' ] ) flatCollect: #cutCamelCase))) collect: #asLowercase ].	rawKeywords := (packages flatCollect: #definedClasses) flatCollect: getKeywordsFromClass.	top10Keywords := (((rawKeywords groupedBy: #yourself) associations sorted: [ :a :b |		a value size > b value size ]) first: 70) collect: #key.	dsm := RSDSM new.	dsm objectsX: top10Keywords.	dsm objectsY: packages.	dsm setShouldFeedY.	dsm labelShapeY textBlock: #packageName.	dsm dependency: [ :pak | pak definedClasses flatCollect: getKeywordsFromClass ].	^ dsm! !!RSDSMExample methodsFor: 'sources'!example05TopLabelRotation	<script: 'self new example05TopLabelRotation open'>	| dsm v keys |	v := Dictionary new		at: #A put: #(B C);		at: #B put: #(A C);		at: #C put: #(A);		yourself.	keys := #(9 A B C D).	dsm := RSDSM new.	dsm objects: keys.	dsm setShouldFeedY.	dsm rotation: 0.	dsm dependency: [ :k  | v at: k ifAbsent: #() ].	^ dsm! !!RSDSMExample methodsFor: 'sources'!example06StronglyConnected	<script: 'self new example06StronglyConnected open'>	| dsm v keys |	v := Dictionary new		at: #A put: #(B C);		at: #B put: #(A C);		at: #C put: #(A);		yourself.	keys := #(9 A B C D).	dsm := RSDSMStronglyConnected new.	dsm objects: keys.	dsm setShouldFeedY.	dsm dependency: [ :k  | v at: k ifAbsent: #() ].	^ dsm! !!RSDSMExample methodsFor: 'sources'!example07StronglyConnectedWithClasses	<script: 'self new example07StronglyConnectedWithClasses open'>	| classes v keys dsm |	classes := Collection withAllSubclasses.	v := Dictionary new.	classes		do: [ :c | v at: c name put: (c dependentClasses collect: #name) ]		displayingProgress: [:c | 'Processing: ', c name ]		every: 500.	keys := v keys.	dsm := RSDSMStronglyConnected new.	dsm objects: keys.	dsm setShouldFeedY.	dsm shape @ (RSPopup text: [ :association |		association key,		((dsm isAssocDependent: association)			ifTrue: [ ' depends on ' ]			ifFalse: [ ' does not depend on' ]) , association value ]).	dsm dependency: [ :k | v at: k ifAbsent: #() ].	^ dsm! !!RSHighlightableExamples methodsFor: 'examples'!example01Basic	<script: 'self new example01Basic open'>	| canvas shapes color |	canvas := RSCanvas new.	color := RSColorPalette sequential bupu3.	shapes := (1 to: 20) collect: [ :m |		RSBox new			size: 10;			model: m;			draggable;			withBorder;			color: (color scale: m);			yourself.		 ].	RSLineBuilder line		shapes: shapes;		canvas: canvas;		connectFrom: [ :n | n // 2 ].	canvas edges do: #withBorder.	canvas addAll: shapes.	canvas shapes @ RSHighlightable red.	RSClusterTreeLayout on: shapes.	canvas zoomToFit.	^ canvas! !!RSHighlightableExamples methodsFor: 'examples'!example02ElementEdges	<script: 'self new example02ElementEdges open'>	| canvas shapes interaction color |	canvas := RSCanvas new.	interaction := RSHighlightable red		withLines;		yourself.	color := RSColorPalette diverging rdylbu3.	shapes := (1 to: 20) collect: [ :i |		RSBox new			size: 10;			model: i;			draggable;			withBorder;			color: (color scale: i) ;			yourself ].	RSLineBuilder line		shapes: shapes;		canvas: canvas;		connectFrom: [ :n | n // 2 ].	canvas addAll: shapes.	canvas edges do: #withBorder.	canvas edges @ RSHighlightable red.	canvas nodes @ interaction.	RSClusterTreeLayout on: shapes.	canvas zoomToFit.	^ canvas! !!RSHighlightableExamples methodsFor: 'examples - animated'!example03Interactive	<script: 'self new example03Interactive open'>	| canvas shapes interaction update color |	canvas := RSCanvas new.	color := RSColorPalette diverging rdylbu3.	shapes := (1 to: 20) collect: [ :i |		          RSBox new			          size: 10;			          model: i;			          draggable;			          withBorder;			          color: (color scale: i);			          yourself ].	RSLineBuilder line		shapes: shapes;		canvas: canvas;		connectFrom: [ :n | n // 2 ].	canvas edges do: #withBorder.	canvas addAll: shapes.	RSClusterTreeLayout on: shapes.	interaction := RSHighlightable red.	interaction withLines.	update := [ interaction doHighlight: shapes atRandom ].	update value.	canvas newAnimation repeat		when: RSAnimationLoopEvent		do: update		for: self.	canvas zoomToFit.	^ canvas! !!RSHighlightableExamples methodsFor: 'examples - animated'!example04Interactive	<script: 'self new example04Interactive open'>	| canvas shapes interaction bool update color |	canvas := RSCanvas new.	color := RSColorPalette qualitative accent8.	shapes := (1 to: 20) collect: [ :i |		          RSBox new			          size: 10;			          model: i;			          popup;			          draggable;			          withBorder;			          color: (color scale: i);			          yourself ].	RSLineBuilder line		shapes: shapes;		canvas: canvas;		connectFrom: [ :n | n // 2 ].	canvas addAll: shapes.	RSClusterTreeLayout on: shapes.	interaction := RSHighlightable red.	bool := true.	update := [	          interaction doHighlightShapes:		          (shapes select: [ :e | bool = e model even ]).	          bool := bool not ].	update value.	canvas newAnimation repeat		when: RSAnimationLoopEvent		do: update		for: self.	canvas zoomToFit.	^ canvas! !!RSHighlightableExamples methodsFor: 'examples'!example05Border	<script: 'self new example05Border open'>	| canvas shapes interaction color |	canvas := RSCanvas new.	color := RSColorPalette sequential blues9.	shapes := (1 to: 20) collect: [ :i |		RSBox new			size: 10;			model: i;			popup;			draggable;			withBorder;			color: (color scale: i) ;			yourself ].	RSLineBuilder line		shapes: shapes;		canvas: canvas;		connectFrom: [ :n | n // 2 ].	interaction := RSHighlightable new.	interaction highlightBorder: (RSBorder new width: 2).	canvas addAll: shapes.	canvas nodes @ interaction.	RSClusterTreeLayout on: shapes.	canvas zoomToFit.	^ canvas! !!RSHighlightableExamples methodsFor: 'examples'!example06IterateNext	<script: 'self new example06IterateNext open'>	| canvas numbers edges layout legendBuilder highlightableForBoxes highlightableForLabels selectedNumber highlightBlock unhighlightAllBlock |	canvas := RSCanvas new.	legendBuilder := RSLegend new container: canvas.	"Create the view with numbers as elements."	numbers := (1 to: 10)		           collect: [ :i |			           RSBox new				           model: i;				           size: 30;				           labeled;				           yourself ]		           as: RSGroup.	edges := RSLineBuilder line		         shapes: numbers;		         connectFrom: [ :i | i // 2 ].	canvas		addAll: edges;		addAll: numbers.	layout := RSForceBasedLayout new		          length: 80;		          charge: -300;		          nodes: numbers;		          edges: edges;		          start;		          yourself.	canvas newAnimation repeat onStepDo: [ :t | layout step ].	numbers @ (RSDraggableForceInteraction new layout: layout).	"Set up highlighting interactions"	highlightableForBoxes := RSHighlightable red.	highlightableForLabels := RSHighlightable new		                          propertyKey: #exampleKey;		                          when: RSHighlightEvent		                          do: [ :evt | evt shape bold ]		                          for: self;		                          when: RSUnHighlightEvent		                          do: [ :evt | evt shape normal ]		                          for: self.	highlightBlock := [ :model |	                  highlightableForBoxes doHighlight:		                  (canvas shapeFromModel: model).	                  highlightableForLabels doHighlight:		                  (legendBuilder shapes shapeFromModel: model).	                  selectedNumber := model ].	unhighlightAllBlock := [	                       highlightableForBoxes		                       unhighlightRecordedShapes: canvas.	                       highlightableForLabels		                       unhighlightRecordedShapes: canvas ].	"Build a legend with all the numbers"	legendBuilder legendDo: [ :l |		l			withBorder;			padding: 5 ].	legendBuilder location		outer;		right;		offset: 70 @ -200.	numbers do: [ :e | (legendBuilder text: e model) model: e model ].	numbers , legendBuilder shapes		when: RSMouseClick		do: [ :evt | highlightBlock value: evt shape model ]		for: self.	legendBuilder build.	"Unhighlight all when clicking on background."	canvas when: RSMouseClick do: unhighlightAllBlock for: self.	"Highlight next number when N key is pressed. Initial is nothing"	selectedNumber := 0.	canvas		when: RSKeyUp		do: [ :evt |			evt keyName = #N ifTrue: [				selectedNumber := selectedNumber \\ numbers size + 1.				highlightBlock value: selectedNumber ] ]		for: self.	^ canvas! !!RSHighlightableExamples methodsFor: 'examples'!example07HighlightButtons	<script: 'self new example07HighlightButtons open'>	| canvas mouseOver selectedButton |	canvas := RSCanvas new.	selectedButton := RSHighlightable red.	mouseOver := RSHighlightable new.	mouseOver highlightColor: [ :shape |		shape model > 5			ifTrue: [ Color purple ]			ifFalse: [ Color blue ] ].	"usefull to combine 2 instances of RSHighlightable"	selectedButton propertyKey: #buttons.	mouseOver highlightShapesButKeep: selectedButton.	canvas addAll: ((1 to: 10) collect: [ :i |			 RSBox new				 model: i;				 @ mouseOver;				 extent: 120 @ 30;				 cornerRadius: 3;				 when: RSMouseClick do: [ :evt |					 mouseOver doUnhighlight: evt shape.					 selectedButton doHighlight: evt shape.					 evt signalUpdate ]				 for: self;				 yourself ]).	selectedButton doHighlight: canvas nodes first.	RSVerticalLineLayout on: canvas nodes.	canvas @ RSCanvasController.	^ canvas! !!RSHighlightableExamples methodsFor: 'examples'!example08DependendMethods	<script: 'self new example08DependendMethods open'>	| packagesRegExp packages canvas popup label padding high arrow allClasses allMethods |	packagesRegExp := { 'Roassal3-Shapes' }.	packages := packagesRegExp flatCollect: [ :regExp |		            RPackageOrganizer default packages select: [ :p |			            regExp match: p packageName ] ].	canvas := RSCanvas new.	popup := RSPopup new.	label := RSLabeled new highlightable.	label shapeBuilder labelShape color: Color black.	padding := 10 asMargin.	high := RSHighlightable new.	arrow := RSShapeFactory arrowedLine		         withBorderAttachPoint;		         color: Color blue.	packages := packages collect: [ :p |		            | classes pkg |		            classes := p definedClasses			                       collect: [ :cls |				                       | methods |				                       methods := cls methods collect: [ :met |					                                  RSBox new						                                  extent: 5 @ met linesOfCode;						                                  @ popup;						                                  @ high;						                                  model: met;						                                  yourself ].				                       RSGridLayout on: methods.				                       RSComposite new					                       model: cls;					                       @ label;					                       @ popup;					                       paint: Color white;					                       children: methods;					                       padding: padding;					                       yourself ]			                       as: RSGroup.		            pkg := (classes asShapeFor: p)			                   paint: Color veryVeryLightGray translucent;			                   @ popup;			                   yourself.		            RSLineBuilder orthoVertical			            withVerticalAttachPoint;			            canvas: pkg;			            shapes: pkg nodes;			            connectFrom: #superclass.		            RSTreeLayout on: pkg nodes edges: pkg edges.		            pkg			            position: 0 @ 0;			            adjustToChildren;			            padding: padding.		            pkg ].	canvas addAll: packages.	RSGridLayout on: canvas shapes.	allClasses := canvas shapes flatCollect: #nodes.	allMethods := allClasses flatCollect: #nodes.	high		when: RSHighlightEvent do: [ :evt |			| methods |			methods := allClasses flatCollect: [ :class |					           (class model thoroughWhichMethodsReferTo:							            evt shape model selector) collect: [ :method |							           method ] ].			methods := methods collect: [ :met |					           arrow copy						           from: evt shape;						           to: (allMethods shapeFromModel: met) ].			canvas addAll: methods.			canvas propertyAt: #methods put: methods ]		for: self;		when: RSUnHighlightEvent do: [ :evt |			(canvas propertyAt: #methods ifAbsent: [ #(  ) ]) do: #remove ]		for: self.	canvas @ RSCanvasController.	^ canvas! !!RSHighlightableExamples methodsFor: 'examples'!example09ArrowedLines	<script: 'self new example09ArrowedLines open'>	| canvas interaction color shapes |	canvas := RSCanvas new.	interaction := RSHighlightable new		highlightBorder: (RSBorder new			width: 2;			yourself);		withLines;		yourself.	color := RSColorPalette diverging rdylbu3.	shapes := (1 to: 20) collect: [ :i |		RSBox new			size: 10;			model: i;			draggable;			withBorder;			color: (color scale: i) ;			yourself ].	RSLineBuilder arrowedLine		withBorderAttachPoint;		canvas: canvas;		shapes: shapes;		connectFrom: [ :n | n // 2 ].	canvas addAll: shapes.	canvas nodes @ interaction.	RSClusterTreeLayout on: shapes.	canvas zoomToFit.	^ canvas! !!RSHighlightableExamples methodsFor: 'elastic'!example10ElasticBox	<script: 'self new example10ElasticBox open'>	| canvas color shapes high elastic |	canvas := RSCanvas new.	color := RSColorPalette diverging rdylbu3.	shapes := (1 to: 20) collect: [ :i |		          RSBox new			          size: 10;			          model: i;			          draggable;			          withBorder;			          color: (color scale: i);			          yourself ].	RSLineBuilder line		shapes: shapes;		canvas: canvas;		connectFrom: [ :n | n // 2 ].	canvas addAll: shapes.	RSClusterTreeLayout on: shapes.	high := RSHighlightable red.	elastic := RSElasticBoxInteraction new.	elastic		when: RSSelectionStartEvent		do: [ :evt | high unhighlightRecordedShapes: evt canvas ]		for: self;		when: RSSelectionChangedEvent		do: [ :evt | high doHighlightShapes: evt selectedShapes ]		for: self.	canvas @ RSCanvasController.	elastic targetShapes: canvas shapes.	canvas @ elastic.	^ canvas! !!RSHighlightableExamples methodsFor: 'elastic'!example11ElasticBoxWithCustomDraggable	<script: 'self new example11ElasticBoxWithCustomDraggable open'>	| canvas color shapes high elastic selectedShapes |	canvas := RSCanvas new.	color := RSColorPalette diverging rdylbu3.	shapes := (1 to: 20) collect: [ :i |		          RSBox new			          size: 10;			          model: i;			          withBorder;			          color: (color scale: i);			          yourself ].	RSLineBuilder line		shapes: shapes;		canvas: canvas;		connectFrom: [ :n | n // 2 ].	canvas addAll: shapes.	RSClusterTreeLayout on: shapes.	high := RSHighlightable red.	selectedShapes := #(  ).	elastic := RSElasticBoxInteraction new.	elastic		when: RSSelectionStartEvent		do: [ :evt | high unhighlightRecordedShapes: evt canvas ]		for: self;		when: RSSelectionChangedEvent		do: [ :evt | high doHighlightShapes: evt selectedShapes ]		for: self;		when: RSSelectionEndEvent		do: [ :evt | selectedShapes := evt selectedShapes ]		for: self.	canvas nodes		when: RSMouseDragging		do: [ :evt |			| d |			d := evt camera distanceFromPixelToSpace: evt step.			(selectedShapes includes: evt shape)				ifTrue: [ selectedShapes translateBy: d ]				ifFalse: [ evt shape translateBy: d ].			evt signalUpdate ]		for: self.	canvas @ RSCanvasController.	elastic targetShapes: canvas nodes.	canvas @ elastic.	^ canvas! !!RSHighlightableExamples methodsFor: 'elastic'!example12ShowingEdges	<script: 'self new example12ShowingEdges open'>	| canvas shapes color interaction cpController|	canvas := RSCanvas new.	color := RSColorPalette sequential bupu3.	shapes := (1 to: 20) collect: [ :m |		RSBox new			size: 10;			model: m;			draggable;			withBorder;			color: (color scale: m);			yourself.		 ].	RSLineBuilder line		canvas: canvas;		shapes: shapes;		connectFrom: [ :n | n // 2 ].	canvas addAll: shapes.	cpController := RSBlockCPController new		block: [ :line |			Array				with: line from position				with: 0 @ 0				with: line to position ];		yourself.	interaction := RSHighlightable		showEdges: [:model | {model + 1. model + 2. model + 3} ]		using: (RSBezier new			color: Color red;			width: 2;			controlPointsController: cpController			yourself	).	canvas nodes @ interaction.	RSClusterTreeLayout on: shapes.	canvas zoomToFit.	^ canvas! !!RSHighlightableExamples methodsFor: 'elastic'!example13Click	<script: 'self new example13Click open'>	| canvas shapes color interaction selectedItems interaction2 |	canvas := RSCanvas new.	color := RSColorPalette sequential bupu3.	shapes := (1 to: 20) collect: [ :m |		          RSBox new			          size: 10;			          model: m;			          draggable;			          withBorder;			          color: (color scale: m);			          yourself ].	RSLineBuilder line		canvas: canvas;		shapes: shapes;		connectFrom: [ :n | n // 2 ].	canvas addAll: shapes.	selectedItems := OrderedCollection new.	interaction := RSHighlightable red withLines.	canvas nodes		when: RSMouseLeftClick		do: [ :evt |			| shape |			shape := evt shape.			(selectedItems includes: shape)				ifTrue: [ selectedItems remove: shape ]				ifFalse: [ selectedItems add: shape ].			interaction doHighlightShapes: selectedItems.			evt signalUpdate ]		for: self.	canvas		when: RSMouseClick		do: [ :evt |			selectedItems removeAll.			interaction unhighlightRecordedShapes: evt.			evt signalUpdate ]		for: self.	interaction2 := RSHighlightable red withLines.	canvas nodes @ interaction2.	RSClusterTreeLayout on: shapes.	canvas zoomToFit.	^ canvas! !!RSInspectableExample methodsFor: 'examples'!example01SimpleExample	<script: 'self new example01SimpleExample open'>	| canvas boxes inspectable highligtable |	canvas := RSCanvas new.	boxes := Collection withAllSubclasses collect: [ :cls |		RSBox new			model: cls;			width: (cls instVarNames size * 5 max: 5);			height: (cls numberOfMethods max: 5);			yourself] as: RSGroup.	canvas addAll: boxes.	RSLineBuilder line		canvas: canvas;		shapes: boxes;		withVerticalAttachPoint;		connectFrom: #superclass.	RSTreeLayout on: boxes.	inspectable := RSInspectableInteraction new.	highligtable := inspectable highlightable.	highligtable highlightColor: Color green.	inspectable inspectShapeBlock: [ :cls |		| builder |		builder := RSUMLClassBuilder new.		builder classes: {cls}.		builder build.		builder canvas open ].	"inspectable inspectElementBlock: [ :cls | GTInspector openOn: cls ]."	boxes @ inspectable.	canvas @ RSCanvasController.	^ canvas! !!RSInspectableExample methodsFor: 'examples'!example02Inspect	<script: 'self new example02Inspect inspect'>	| canvas animation lastSize box color |	canvas := RSCanvas new.	color := NSScale category20c.	box := [ :model |	       RSBox new		       model: model;		       color: (color scale: model);		       size: 20;		       yourself ].	canvas add: (box value: Collection).	lastSize := 0.	animation := nil.	animation := canvas animationFrom:		             { (canvas transitionAnimation repeat			              easing: RSEasingInterpolator backOut;			              onStepDo: [ :t |				              canvas nodes do: [ :shape |						              | att a b |						              att := shape properties.						              a := att at: #old ifAbsentPut: [ shape position ].						              b := att at: #new ifAbsentPut: [ shape position ].						              shape translateTo: (a interpolateTo: b at: t) ].				              canvas zoomToFit ];			              when: RSAnimationLoopEvent do: [				              canvas nodes size = lastSize ifTrue: [						              animation stop.						              self inform: 'Done :V!!!!!!' ].				              lastSize := canvas nodes size.				              canvas nodes do: [ :shape |						              shape outgoingLines ifEmpty: [								              | children |								              children := shape model subclasses collect: [										                          :cls | box value: cls ].								              children do: [ :child |										              child position: shape position ].								              canvas addAll: children ] ].				              canvas edges copy do: #remove.				              canvas nodes do: [ :shape |						              shape propertyAt: #old put: shape position ].				              RSLineBuilder arrowedLine					              canvas: canvas;					              connectFrom: #superclass.				              canvas nodes do: #updateLinesOFF.				              RSClusterTreeLayout on: canvas nodes.				              canvas nodes do: #updateLinesON.				              canvas nodes do: [ :shape |					              shape propertyAt: #new put: shape position ] ]			              for: self) }.	canvas @ RSCanvasController.	^ canvas! !!RSInspectableExample methodsFor: 'examples'!example03Easing	<script: 'self new example03Easing inspect'>	^ RSEasingInterpolator bounceOut! !!RSInspectableExample methodsFor: 'examples'!example04ChagingContext	<script: 'self new example04ChagingContext inspect'>	| c context int |	c := RSCanvas new.	1 to: 100 do: [ :i |		c add: (RSBox new size: 10; model: i) ].	c shapes @ RSDraggable.	RSGridLayout on: c shapes.	c @ RSCanvasController.	"This is the default context for the inspector"	context := RSContextInteraction new.	int := context interactionsToBeRegistered detect: [ :i | i class = RSSelectionPresentationInteraction ].	int		padding: 5;		shadowColor: (Color red alpha: 0.1).	c inspectorContext: context.	^ c! !!RSLayoutExamples methodsFor: 'layouts'!example01LayoutBasic	<script: 'self new example01LayoutBasic open'>	| canvas shapes |	canvas := RSCanvas new.	shapes := (1 to: 20) collect: [ :m |		RSBox new			size: m;			position: (1 to: m) sum asPoint -150;			draggable;			color: (m even				ifTrue: Color red				ifFalse: Color blue);			yourself ].	shapes do: [ :s | s color: (s color alpha: 0.5) ].	canvas addAll: shapes.	RSGridLayout on: shapes.	^ canvas! !!RSLayoutExamples methodsFor: 'layouts'!example02Grid	<script: 'self new example02Grid open'>	| canvas shapes |	canvas := RSCanvas new.	shapes := Collection withAllSubclasses collect: [ :cls |		RSBox new			size: cls numberOfMethods;			draggable;			yourself ].	canvas addAll: shapes.	RSGridLayout on: shapes.	^ canvas! !!RSLayoutExamples methodsFor: 'layouts'!example03LayoutColorFadingBasic	<script: 'self new example03LayoutColorFadingBasic open'>	| canvas shapes color |	canvas := RSCanvas new.	color := NSScale linear		domain: #(1 20);		range: {Color red. Color green}.	shapes := (1 to: 20) collect: [ :m |		RSBox new			size: m;			position: (1 to: m) sum asPoint -150;			draggable;			color: (color scale: m);			yourself ].	canvas addAll: shapes.	RSGridLayout on: shapes.	^ canvas! !!RSLayoutExamples methodsFor: 'layouts'!example04LayoutColorFadingBasic2	<script: 'self new example04LayoutColorFadingBasic2 open'>	| canvas shapes color |	canvas := RSCanvas new.	color := NSScale linear		domain: #(1 10 20);		range: { Color red. Color green. Color blue }";		interpolate: TSColorHSVAInterpolator".	shapes := (1 to: 20) collect: [ :m |		RSBox new			size: m;			position: (1 to: m) sum asPoint -150;			draggable;			color: (color scale: m);			yourself ].	canvas addAll: shapes.	RSGridLayout on: shapes.	^ canvas! !!RSLayoutExamples methodsFor: 'layouts'!example05LayoutBasicWithColorFading	<script: 'self new example05LayoutBasicWithColorFading open'>	| canvas shapes minAndMax color |	canvas := RSCanvas new.	minAndMax := Collection withAllSubclasses inject: { 10000 . 0 } into: [ :res :cls | {res first min: cls numberOfMethods . res second max: cls numberOfMethods}].	color := NSScale linear		domain: minAndMax;		range: { Color green . Color red }.	shapes := Collection withAllSubclasses collect: [ :cls |		RSBox new			size: cls numberOfMethods;			draggable;			color: (color scale: cls numberOfMethods);			yourself ].	canvas addAll: shapes.	RSGridLayout on: shapes.	canvas @ RSDraggableCanvasInteraction.	^ canvas! !!RSLayoutExamples methodsFor: 'layouts'!example06TreeLayout	<script: 'self new example06TreeLayout open'>	| c shapes eb |	c := RSCanvas new.	shapes := Collection withAllSubclasses collect: [ :cls |		RSEllipse new			model: cls;			draggable;			size: 5;			yourself		 ].	c addAll: shapes.	RSNormalizer color		from: (Color gray alpha: 0.5);		to: (Color red alpha: 0.5);		shapes: shapes;		normalize: #numberOfMethods.	RSNormalizer size		shapes: shapes;		normalize: #numberOfMethods.	eb := RSLineBuilder line.	eb canvas: c.	eb connectFrom: #superclass.	RSTreeLayout on: shapes.	shapes do: [ :e | e translateBy: 0 @ 0 ].	c @ RSCanvasController.	^ c! !!RSLayoutExamples methodsFor: 'lines'!example07ForceBasedLayout	<script: 'self new example07ForceBasedLayout open'>	| c shapes eb |	c := RSCanvas new.	shapes := RSShape withAllSubclasses collect: [ :cls |		RSEllipse new			popup;			draggable;			model: cls;			size: 5;			yourself ].	c addAll: shapes.	RSNormalizer size		shapes: c nodes;		normalize: #numberOfMethods.	RSNormalizer color		from: (Color green alpha: 0.5);		to: (Color red alpha: 0.5);		shapes: c nodes;		normalize: #numberOfMethods.	eb := RSLineBuilder line.	eb		canvas: c;		moveBehind;		connectFrom: #superclass.	RSForceBasedLayout new		doNotUseProgressBar;		charge: -350;		on: c nodes.	c @ RSCanvasController.	c zoomToFit.	^ c! !!RSLayoutExamples methodsFor: 'lines'!example08HorizontalTree	<script: 'self new example08HorizontalTree open setLabel: ''Horizontal Tree'''>	| c shapes |	c := RSCanvas new.	shapes := String withAllSubclasses collect: [ :cls | | box lbl |		lbl := RSLabel new			text: cls;			yourself.		box := RSBox new			withBorder;			cornerRadius: (RSCornerRadius new right: 10);			extent: lbl extent + 10.		RSComposite new			draggable;			model: cls;			shapes: (RSGroup with: box with: lbl );			yourself ].	c addAll: shapes.	c @ RSCanvasController.	RSLineBuilder orthoHorizontal		markerEnd: (RSMarker new			offset: 2;			shape: (RSShapeFactory triangle				color: Color black;				size: 5;				yourself));		attachPoint: RSHorizontalAttachPoint new;		canvas: c;		shapes: c nodes;		connectFrom: #superclass.	RSHorizontalTreeLayout new on: c nodes.	^ c! !!RSLayoutExamples methodsFor: 'lines'!example09BorderAttachPoint	<script: 'self new example09BorderAttachPoint open setLabel: ''TSShape withAllSubclasses'''>	| c shapes |	c := RSCanvas new.	shapes := RSShape withAllSubclasses collect: [ :cls |		RSShapeFactory square size: 30; draggable; model: cls; yourself ].	c addAll: shapes.	RSLineBuilder arrowedLine		withBorderAttachPoint;		canvas: c;		connectFrom: #superclass.	RSForceBasedLayout new		charge: -500;		on: c nodes.	c @ RSCanvasController.	^ c! !!RSLayoutExamples methodsFor: 'lines'!example10Locate	<script: 'self new example10Locate open'>	| canvas newshape e1 e2 color |	canvas := RSCanvas new.	color := RSColorPalette sequential blues3.	newshape := [ :m |		RSBox new			draggable;			color: (color scale: m) ;			size: 100;			yourself].	e1 := newshape value: 1.	e2 := newshape value: 2.	e2 size: 20.	RSLocation new		offset: 1@ -1;		inner;		bottom;		left;		stick: e2 on: e1.	canvas addAll:{e1. e2}.	canvas @ RSCanvasController.	^ canvas! !!RSLayoutExamples methodsFor: 'lines'!example11PaddingInComposite	<script: 'self new example11PaddingInComposite open'>	| canvas shapes |	canvas := RSCanvas new.	shapes := Collection withAllSubclasses collect: [ :cls | | methods |		methods := cls methods collect: [:met | RSBox new color: Color black; size: 5; yourself ].		RSGridLayout on: methods.		RSComposite new			model: cls;			popup;			shapes: methods;			padding: (Margin				left: 50				right: 5				top: 20				bottom: 5);			color: Color blue translucent;			yourself  ].	RSGridLayout on: shapes.	canvas addAll: shapes.	canvas @ RSCanvasController.	^ canvas! !!RSLayoutExamples methodsFor: 'animations'!example12AnimatedForceBasedLayout	<script: 'self new example12AnimatedForceBasedLayout open'>	| c |	c := RSCanvas new.	c addAll: ((1 to: 100) collect: [:i | RSEllipse new size: 10; model: i]).	RSLineBuilder line		canvas: c;		connectFrom: [ :v | v // 2 ].	c @ RSForceLayoutSteppingInteraction.	^ c! !!RSLayoutExamples methodsFor: 'animations'!example13VisualizeQuatree	<script: 'self new example13VisualizeQuatree open'>	| canvas shapes stepping edges newBox boxes createBoxes colors newLabel |	canvas := RSCanvas new.	shapes := (1 to: 50) collect: [ :n |		          RSBox new			          size: 30;			          labeled;			          model: n;			          yourself ].	edges := RSLineBuilder line		         shapes: shapes;		         connectFrom: [ :i | i // 2 ].	canvas		addAll: edges;		addAll: shapes.	stepping := RSForceLayoutSteppingInteraction new.	stepping layout		length: 80;		charge: -300.	canvas @ RSCanvasController.	canvas @ stepping.	colors := RSColorPalette sequential pubu9.	newBox := [ :quad :index |	          RSBox new		          border: (RSBorder new				           color: Color lightGray translucent;				           width: 0.5);		          extent: quad rectangle extent;		          position: quad rectangle floatCenter;		          color: ((colors scale: index) alpha: 0.5);		          yourself ].	newLabel := [ :quad :index |	            RSLabel new		            text: (quad charge printShowingDecimalPlaces: 1);		            position: quad rectangle floatCenter;		            yourself ].	boxes := #(  ).	createBoxes := nil.	createBoxes := [ :quad :lvl |	               | box label |	               box := newBox value: quad value: lvl.	               label := newLabel value: quad value: lvl.	               quad subQuadsDo: [ :subQuad |		               createBoxes value: subQuad value: lvl + 1 ].	               boxes add: box.	               boxes add: label ].	canvas newAnimation		repeat;		duration: 500 milliSeconds;		when: RSAnimationLoopEvent do: [ :v |			boxes do: #remove.			boxes := RSGroup new.			createBoxes value: stepping layout currentQuadtree value: 0.			canvas addAll: boxes.			boxes pushBack ]		for: self.	^ canvas! !!RSLayoutExamples methodsFor: 'lines'!example15SimpleClassHierarchy	<script: 'self new example15SimpleClassHierarchy open'>	| c methods |	c := RSCanvas new.	GoferOperation withAllSubclassesDo: [ :cls |		| composite label |		methods := cls methods collect: [ :m | RSBox new color: Color red; size: 5; model: m; yourself ] as: RSGroup.		methods @ (RSPopup text: #selector).		RSGridLayout on: methods.		composite := RSComposite new.		label := RSLabel new text: cls name; color: 'black'; yourself.		RSLocation new above; move: label on: methods.		composite shapes:  methods, { label }.		composite color: Color lightGray.		composite model: cls.		composite @ RSAnimatedPopup; @ (RSDraggable new noValidateChildrenEvents).		composite padding: 10.		c add: composite ].	RSLineBuilder line		canvas: c;		withVerticalAttachPoint;		color: Color blue;		connectFrom: #superclass.	RSTreeLayout on: c nodes.	"Making sure we have zooming"	c @ RSCanvasController.	^ c! !!RSLayoutExamples methodsFor: 'lines'!example16SimpleClassHierarchy	<script: 'self new example16SimpleClassHierarchy open'>	| c |	c := RSCanvas new.	Collection withAllSubclassesDo: [ :cls |		| box |		box := RSBox new.		box model: cls.		box height: (cls numberOfMethods max: 5).		box width: ((cls instVarNames size * 4) max: 5).		box @ RSPopup @ RSDraggable.		c add: box.		 ].	RSLineBuilder line		canvas: c;		withVerticalAttachPoint;		color: Color blue;		connectFrom: #superclass.	RSTreeLayout on: c nodes.	c @ RSCanvasController.	^ c! !!RSLayoutExamples methodsFor: 'animations'!example17ForceBasedLayout	<script: 'self new example17ForceBasedLayout open'>	| canvas shapes stepping edges  layout |	canvas := RSCanvas new.	shapes := (1 to: 10) collect: [ :m |		RSBox new			size: 30;			draggable;			labeled;			model: m;			yourself ].	edges := RSLineBuilder line		shapes: shapes;		connectFrom: [ :i | i // 2 ].	canvas		addAll: edges;		addAll: shapes.	stepping := RSForceLayoutSteppingInteraction new.	(layout := stepping layout)		length: 80;		charge: -300.	canvas @ stepping.	canvas edges do: [ :edge |		(layout mockLineAt: edge)			length: (edge model key + edge model value) * 10 ].	canvas @ RSCanvasController.	^ canvas! !!RSLayoutExamples methodsFor: 'layouts'!example18ClusterTree	<script: 'self new example18ClusterTree open'>	| canvas shapes |	canvas := RSCanvas new.	canvas addAll: (#(linear sqrt log) collect: [ :scale |		| group |		group := RSGroup new.		shapes := Morph withAllSubclasses collect: [ :cls |			RSEllipse new				size: 5;				draggable;				color: Color red;				model: cls;				yourself ].		group addAll: shapes.		RSLineBuilder line			color: Color blue translucent;			canvas: group;			shapes: shapes;			connectFrom: #superclass.		RSNormalizer size			scale: (NSScale perform: scale);			from: 1;			to: 30;			shapes: shapes;			normalize: #numberOfMethods.		RSNormalizer color			scale: (NSScale perform: scale);			from: Color blue;			to: Color red;			shapes: shapes;			normalize: #numberOfMethods.		RSClusterTreeLayout on: shapes.		RSComposite new			color: Color veryLightGray translucent;			model: scale;			labeled;			draggable;			shapes: group;			yourself.		]).	RSGridLayout new gapSize: 20; on: canvas nodes.	canvas @ RSCanvasController.	^ canvas! !!RSLayoutExamples methodsFor: 'layouts'!example19AutomaticLayoutWhenWindowIsResized	<script: 'self new example19AutomaticLayoutWhenWindowIsResized open'>	| classes shapes c eb |	classes := { 'Roassal3-Layouts'. 'Roassal3' }		flatCollect: [:pkgname | (RPackage organizer			packageNamed: pkgname) definedClasses ].	shapes := RSGroup new.	classes do: [ :cls | shapes add: (RSEllipse new model: cls) ].	c := RSCanvas new.	c addAll: shapes.	eb := RSLineBuilder orthoVertical.	eb canvas: c.	eb connectFrom: #superclass.	RSNormalizer size		shapes: shapes;		normalize: [ :cls | cls numberOfMethods + 5 ].	RSTreeLayout on: shapes.	^ c @ RSCanvasController @ RSHierarchyPackerInteraction! !!RSLayoutExamples methodsFor: 'layouts'!example20FlowLayout	<script: 'self new example20FlowLayout open extent: 700@500'>	| words labels canvas menuAnimation high newLabel |	words := (String loremIpsum: 100) substrings.	labels := words collectWithIndex: [ :word :index |		          RSLabel new			          text: word;			          fontSize: 10 + (index % 10 * 2);			          underline;			          yourself ].	RSFlowLayout on: labels.	canvas := RSCanvas new.	canvas addAll: labels.	menuAnimation := [ :s :d |	                 | p |	                 p := s propertyAt: #opos ifAbsentPut: [ s position ].	                 canvas newAnimation		                 duration: 200 milliSeconds;		                 from: s position;		                 to: p + d;		                 on: s set: #position: ].	high := RSHighlightable new.	high		when: RSHighlightEvent do: [ :evt |			evt shape				color: Color blue;				underline.			menuAnimation value: evt shape value: -5 @ 0 ]		for: self;		when: RSUnHighlightEvent do: [ :evt |			evt shape				color: Color gray;				normal.			menuAnimation value: evt shape value: 0 ]		for: self.	newLabel := [ :s |	            canvas add: (RSLabel new			             text: s;			             isFixed: true;			             @ high;			             yourself) ].	{		'FlowTop'.		RSFlowLayout new alignTop.		'FlowMiddle'.		RSFlowLayout new alignMiddle.		'FlowBot'.		RSFlowLayout new alignBottom.		'FlowLabel'.		RSFlowLayout new alignLabel.		'FlowLeft'.		RSHorizontalFlowLayout new alignLeft.		'FlowCenter'.		RSHorizontalFlowLayout new alignCenter.		'FlowRight'.		RSHorizontalFlowLayout new alignRight.		'HorizontalTop'.		RSHorizontalLineLayout new alignTop.		'HorizontalMid'.		RSHorizontalLineLayout new alignMiddle.		'HorizontalBot'.		RSHorizontalLineLayout new alignBottom.		'HorizontalLabel'.		RSHorizontalLineLayout new alignLabel.		'VerticalLeft'.		RSVerticalLineLayout new.		'VerticalCenter'.		RSVerticalLineLayout new alignCenter.		'VerticalRight'.		RSVerticalLineLayout new alignRight } pairsDo: [ :s :layout |		(newLabel value: s)			when: RSMouseClick			do: [ :evt |				| last current |				last := labels collect: #position.				layout on: labels.				current := labels collect: #position.				canvas newAnimation					duration: 1 second;					onStepDo: [ :t |						labels doWithIndex: [ :l :i |								l translateTo:										((last at: i) interpolateTo: (current at: i) at: t) ].						canvas zoomToFit ] ]			for: self ].	{		'Show/Hide Boxes'.		[		canvas shouldShowRectangles			ifTrue: [ canvas hideEncompassingRectangles ]			ifFalse: [ canvas showEncompassingRectangles ] ].		'Show/Hide Underlines'.		[		labels first isUnderlined			ifTrue: [ labels do: #normal ]			ifFalse: [ labels do: #underline ] ] } pairsDo: [ :s :a |		(newLabel value: s)			fontSize: 12;			when: RSMouseClick do: [				a value.				canvas signalUpdate ]			for: self ].	canvas showEncompassingRectangles.	RSVerticalLineLayout new		gapSize: 3;		on: canvas fixedShapes.	canvas fixedShapes translateBy: 7.	canvas @ RSCanvasController.	^ canvas! !!RSLayoutExamples methodsFor: 'layouts'!example21TreeLayoutEllipses	<script: 'self new example21TreeLayoutEllipses open'>	| c shapes eb |	c := RSCanvas new.	shapes := Collection withAllSubclasses collect: [ :cls |		RSEllipse new			model: cls;			draggable;			size: 5;			yourself		 ].	c addAll: shapes.	RSNormalizer color		from: (Color gray alpha: 0.5);		to: (Color red alpha: 0.5);		shapes: shapes;		normalize: #numberOfMethods.	RSNormalizer height		shapes: shapes;		normalize: #numberOfMethods.	RSNormalizer width		shapes: shapes;		normalize: [:cls | cls numberOfVariables].	eb := RSLineBuilder line.	eb withBorderAttachPoint.	eb canvas: c.	eb connectFrom: #superclass.	RSTreeLayout on: shapes.	shapes do: [ :e | e translateBy: 0 @ 0 ].	c @ RSCanvasController.	^ c! !!RSLayoutExamples methodsFor: 'tests'!example22ClassHierarchies	<script: 'RSLayoutExamples new example22ClassHierarchies open'>	| commits edges aCanvas gr aCollection |	aCollection := {		               Collection.		               Magnitude.		               RSObject.		               RBNode }.	gr := 1.61803398875.	commits := Array streamContents: [ :aStream |		           aCollection do: [ :aClass |			           aClass withAllSubclassesDo: [ :aSubClass |				           | label box |				           label := RSLabel new text: aSubClass name.				           aSubClass isAbstract ifTrue: [					           label						           bold;						           italic ].				           box := RSBox new					                  color: Color white;					                  withBorder;					                  cornerRadius: gr * 2;					                  extent: label extent + (gr * 4) asPoint;					                  yourself.				           RSLocation new center stick: label on: box.				           aStream nextPut: (RSComposite new						            model: aSubClass;						            shapes: (Array with: box with: label);						            draggable;						            when: RSMouseLeftClick						            do: [ :ev | aSubClass browse ]						            for: self;						            yourself) ] ] ].	edges := RSLineBuilder horizontalBezier		         shapes: commits;		         withHorizontalAttachPoint;		         connectToAll: [ :aSubClass | aSubClass subclasses ].	edges sort: [ :a :b |		| aName bName |		aName := a from model name.		bName := b from model name.		aName = bName			ifTrue: [ a to model name < b to model name ]			ifFalse: [ aName < bName ] ].	RSHorizontalVanDerPloegTreeLayout new		doNotValidateCycles;		on: commits edges: edges.	aCanvas := RSCanvas new		           addAll: commits , edges;		           yourself.	^ aCanvas		  zoomToFit;		  @ RSCanvasController! !!RSLayoutExamples methodsFor: 'tests'!example23Roassal3CommitsWithTimeGaps	<noTest>	<script: 'RSLayoutExamples new example23Roassal3CommitsWithTimeGaps open'>	| icerepo commits edges dict aCanvas |	icerepo := IceRepository repositories		detect: [ :each | each name = 'Roassal3' ]		ifNone: [ nil ].	dict := Dictionary new.	"if you remove <noTest> you will break ci in githubactions"	"for some reasong icerepo allBranches fails in ci"	icerepo allBranches do: [ :aBranch |		(icerepo newCommitWalk fromBranch: aBranch) commits do: [ :aCommit |			| circle |			circle := RSCircle new				          model: aCommit id asSymbol;				          "radius:						           ((aCommit changesTo: aCommit parent) size / Float pi)							           sqrt;"				          color: Color white;				          draggable;				          addInteraction: (RSPopup new text: [							           String streamContents: [ :aStream |									           aStream										           nextPutAll: aCommit comment;										           cr;										           cr;										           nextPutAll: aCommit shortId;										           nextPutAll: ' -- by ';										           nextPutAll: aCommit author;										           nextPutAll: ' at ';										           nextPutAll: aCommit datetime asLocalStringYMDHM;										           nextPutAll: '.' ] ]);				          withBorder;				          yourself.			circle propertyAt: #gitCommit put: aCommit.			aCommit isMergeCommit ifTrue: [ circle color: circle border color ].			dict at: aCommit id put: circle ] ].	commits := dict values.	edges := RSLineBuilder verticalBezier		         shapes: commits;		         withVerticalAttachPoint;		         connectToAll: [ :aCommitId |			         ((dict at: aCommitId) propertyAt: #gitCommit) ancestorIds ].	edges sort: [ :a :b |		| aTime bTime |		aTime := (a to propertyAt: #gitCommit) datetime.		bTime := (b to propertyAt: #gitCommit) datetime.		aTime > bTime			ifTrue: [ true ]			ifFalse: [				aTime = bTime					ifTrue: [						(a from propertyAt: #gitCommit) datetime						> (b from propertyAt: #gitCommit) datetime ]					ifFalse: [ false ] ] ].	RSVanDerPloegTreeLayout new		doNotValidateCycles;		verticalGap: [ :parent :child :default |			| duration goldenRatio |			goldenRatio := 1.61803398875.			duration := (parent propertyAt: #gitCommit) datetime			            - (child propertyAt: #gitCommit) datetime.			self assert: duration asSeconds >= 0.			((duration asMinutes max: goldenRatio) log: goldenRatio)			* goldenRatio ];		on: commits edges: edges.	aCanvas := RSCanvas new		           addAll: commits , edges;		           yourself.	edges do: [ :each |		self assert: each to encompassingRectangle top			>= each from encompassingRectangle bottom.		(each to propertyAt: #vdpLevel) - (each from propertyAt: #vdpLevel)		> 1 ifTrue: [			each				dashArray: #( 4 );				color: each color translucent;				pushBack ] ].	^ aCanvas		zoomToFit;		@ RSCanvasController! !!RSLayoutExamples methodsFor: 'layouts'!example24SmartHorizontalTree	<script: 'self new example24SmartHorizontalTree open setLabel: ''Horizontal Tree'''>	| c shapes |	c := RSCanvas new.	shapes := String withAllSubclasses collect: [ :cls | | box lbl |		lbl := RSLabel new			text: cls;			yourself.		box := RSBox new			withBorder;			cornerRadius: (RSCornerRadius new right: 10);			extent: lbl extent + 10.		RSComposite new			draggable;			model: cls;			shapes: (RSGroup with: box with: lbl );			yourself ].	c addAll: shapes.	c @ RSCanvasController.	RSLineBuilder orthoHorizontal		controlPointsController: RSSmartHorizontalCPController new;		markerEnd: (RSMarker new			offset: 2;			shape: (RSShapeFactory triangle				color: Color black;				size: 5;				yourself));		attachPoint: RSHorizontalAttachPoint new;		canvas: c;		shapes: c nodes;		connectFrom: #superclass.	RSHorizontalTreeLayout new on: c nodes.	^ c! !!RSLayoutExamples methodsFor: 'layouts'!example25SortBlock	<script: 'self new example25SortBlock open'>	| c shapes |	c := RSCanvas new.	shapes := Dictionary withAllSubclasses collect: [ :cls | | box lbl |		lbl := RSLabel new			text: cls;			color: Color black;			yourself.		box := RSBox new			withBorder;			color: Color veryVeryLightGray;			cornerRadius: (RSCornerRadius new right: 10);			extent: lbl extent + 10.		RSComposite new			draggable;			model: cls;			shapes: (RSGroup with: box with: lbl );			yourself ].	c addAll: shapes.	c @ RSCanvasController.	RSLineBuilder orthoHorizontal		withHorizontalAttachPoint;		shapes: c nodes;		connectFrom: #superclass.	RSHorizontalTreeLayout new		childrenSortBlock: [ :a :b | | sizeA sizeB |			"use a cache"			sizeA := a model withAllSubclasses size.			sizeB := b model withAllSubclasses size.			sizeA = sizeB				ifTrue: [ a model name > b model name ]				ifFalse: [ sizeA > sizeB ] ];		on: c nodes.	^ c! !!RSRenderTreeExamples methodsFor: 'lines'!example01BigVisualization131k	<script: 'self new example01BigVisualization131k open		setLabel: ''131K'' '>	<noTest>	"(2 raisedTo: 17) = 131072 = 131K"	| c b1 b2 |	c := RSCanvas new.	c aaNone.	b2 := nil.	1 to: (2 raisedTo: 17) do: [ :i |		b1 := b2.		b2 := RSBox new.		b2 model: i.		b2 translateTo: (i * 10) @ (i * 10).		b2 @ RSDraggable.		c add: b2.	].	"c renderCollection: RSSequenceableCollection new."	c @ RSDraggableCanvasInteraction new.	c nodes @ RSPopup.	c nodes @ RSHighlightable red.	^ c! !!RSRenderTreeExamples methodsFor: 'lines'!example02BigVisualizationHalfMillion	<script: 'self new example02BigVisualizationHalfMillion open'>	<noTest>	"(2 raisedTo: 19) = 524288 = 0.52 Million"	| c b1 b2 |	c := RSCanvas new.	c aaNone.	b2 := nil.	1 to: (2 raisedTo: 19) do: [ :i |		b1 := b2.		b2 := RSBox new.		b2 model: i.		b2 translateTo: (i * 10) @ (i * 10).		b2 @ RSDraggable.		c add: b2.	].	"c renderCollection: RSBulkLoadRTreeCollection new."	"c @ RSDraggableCanvasInteraction new."	c @ RSCanvasController simple.	c nodes @ RSPopup.	c nodes @ RSHighlightable red.	^ c! !!RSRenderTreeExamples methodsFor: 'lines'!example03RTree	<script: 'self new example03RTree inspect'>	<noTest>	| tree random canvas |	tree := RSRTreeShapeCollection new.	random := Random new.	random seed: 777.	canvas := RSCanvas new.	1 to: 100 do: [ :each | | box |		box := RSBox new.		box size: 10.		box model: each.		box popup.		box position: (random next @ random next) * 1000.		canvas add: box.		tree add: box.	].	canvas @ RSCanvasController.	^ tree! !!RSShapeExamples methodsFor: 'shapes'!example01BasicShape	<script: 'self new example01BasicShape open'>	| canvas shapes |	canvas := RSCanvas new.	shapes := (1 to: 20) collect: [ :m |		RSBox new			size: m;			position: (1 to: m) sum asPoint - 150;			color: (m even				ifTrue: Color red				ifFalse: Color blue);			yourself		 ].	canvas addAll: shapes.	^ canvas! !!RSShapeExamples methodsFor: 'lines'!example02BasicEdge	<script: 'self new example02BasicEdge open'>	| canvas box |	canvas := RSCanvas new.	box := RSBox new		size: 100;		draggable;		position: -100@150;		yourself.	canvas add: box.	canvas add: (		RSLine new			from: box;			to: 0@0;			color: Color red;			yourself).	canvas add: (		RSLine new			startPoint: 100@100;			endPoint: 150@150;			yourself).	^ canvas! !!RSShapeExamples methodsFor: 'lines'!example04LineDashes	<script: 'self new example04LineDashes open'>	| canvas dashes |	canvas := RSCanvas new.	dashes := #(		#()			"no dashes no gaps"		#(4) 			"Dashes and gaps of the same size"		#(4 1)		"Dashes and gaps of different sizes"		#(4 1 2) 	"Dashes and gaps of various sizes with an odd number of values"		#(4 1 2 3)	"Dashes and gaps of various sizes with an even number of values"		) doWithIndex: [ :array :k |		canvas add: (RSLine new			dashArray: array;			from: -15@ (k*2);			to: 15 @(k*2);			yourself) ] .	canvas camera		scale: 10;		position: 0@5.	^ canvas! !!RSShapeExamples methodsFor: 'lines'!example05CapStyles	<script: 'self new example05CapStyles open'>	| canvas dot styles ann |	canvas := RSCanvas new.	dot := [ :position |		RSEllipse new			color: Color darkGray;			position: position;			radius: 5;			yourself	].	styles := #('capButt' 'capRound' 'capSquare').	styles doWithIndex: [ :style :i|		| d1 d2 line |		d1 := dot value: -100@(i*30).		d2 := dot value: 100@(i*30).		line := RSLine new			width: 20;			color: Color lightGray;			from: d1;			to: d2;			yourself.		line perform: style asSymbol.		canvas add: line; add: d1; add: d2.		 ].	canvas nodes first @ RSDraggable.	ann := canvas nodes first announcer.	canvas nodes do: [ :s | s announcer: ann ].	^ canvas! !!RSShapeExamples methodsFor: 'normalizer'!example07NormalizeColor	<script: 'self new example07NormalizeColor open'>	| canvas shapes |	canvas := RSCanvas new.	shapes := Collection withAllSubclasses collect: [ :cls |		          RSBox new			          model: cls;			          draggable;			          "size: cls numberOfMethods;"popup;			          yourself ].	RSNormalizer color		shapes: shapes;		normalize: #numberOfMethods.	RSNormalizer size		shapes: shapes;		normalize: #numberOfMethods.	"scale: NSScale sqrt;"	canvas addAll: shapes.	RSGridLayout on: shapes.	canvas camera position: canvas shapes encompassingRectangle center.	canvas		when: RSExtentChangedEvent		do: [			canvas				zoomToFit;				signalUpdate ]		for: self.	^ canvas! !!RSShapeExamples methodsFor: 'shapes'!example08Labels	<script: 'self new example08Labels open'>	| canvas shapes random |	canvas := RSCanvas new.	random := Random new.	shapes := Collection withAllSubclasses collect: [ :cls |		RSLabel new			draggable;			text: cls;			model: cls;			translateTo: (random rsNext: 300) @ (random rsNext: 300);			yourself ].	canvas addAll: shapes.	RSNormalizer fontSize		shapes: shapes;		to: 30;		normalize: #numberOfMethods.	RSNormalizer color		shapes: shapes;		normalize: #numberOfMethods.	canvas @ RSCanvasController.	^ canvas! !!RSShapeExamples methodsFor: 'lines'!example09Polyline	<script: 'self new example09Polyline open'>	| canvas box box1 line box2 |	canvas := RSCanvas new.	box := [ RSBox new		size: 100;		draggable;		yourself ].	box1 := box value.	box1 translateBy: 150@150.	box2 := box value.	box2 translateBy: -200@200.	canvas add: box1; add: box2.	line := RSPolyline new		color: Color red;		controlPointsController: (			RSCustomCPController new				models: {					box1.					0@0.					[ box1 position x@ box2 position y ].					box2 };				yourself).	canvas add: line.	^ canvas! !!RSShapeExamples methodsFor: 'shapes'!example10Donut	<script: 'self new example10Donut open'>	| data radius color canvas border |	"1800 ellipses"	data := 0 to: 358 by: 2.	canvas := RSCanvas new.	radius := NSScale linear		domain: #(1 10);		range: #(180 240).	color := NSScale linear		domain: #(1 7 10);		range: #('brown' '4682b4' 'brown').	border := RSBorder new color: 'black'.	1 to: 10 do: [ :i |		canvas addAll: (data collect: [ :a |			| d |			d := a degreesToRadians.			RSEllipse new				radius: 4.5;				color: (color scale: i);				border: border;				position: (radius scale: i) * (d cos @ d sin);				yourself ]).		 ].	canvas @ RSCanvasController.	^ canvas! !!RSShapeExamples methodsFor: 'shapes'!example11ClassTree	<script: 'self new example11ClassTree open setLabel: ''Collection withAllSubclasses'''>	| canvas shapes |	canvas := RSCanvas new.	"canvas showEncompassingRectangles."	shapes := Collection withAllSubclasses collect: [ :cls |		| group label s methods|		group := RSGroup new.		methods := cls methods collect: [ :met|			RSBox new				model: met;				popupText: #selector;				size: met linesOfCode;				yourself ].		RSGridLayout on: methods.		s := RSComposite new			color: (Color lightGray alpha: 0.4);			shapes: methods;			yourself.		s extent: s extent + 10.		label := RSLabel new			text: cls;			yourself.		group add: label; add: s.		RSVerticalLineLayout new alignCenter on: group.		RSComposite new			shapes: group;			model: cls;			draggable;			popup;			yourself  ].	canvas addAll: shapes.	RSLineBuilder line		canvas: canvas;		objects: Collection withAllSubclasses;		connectFrom: #superclass.	canvas edges pushBack.	RSTreeLayout on: shapes.	canvas @ RSCanvasController.	^ canvas! !!RSShapeExamples methodsFor: 'shapes'!example12Polygons	<script: 'self new example12Polygons open setLabel: ''Polygon shapes'''>	| canvas color border |	canvas := RSCanvas new.	color:= RSGradientPalette gradient21.	border := RSBorder new paint: Color black; width: 2.	#('diamond' 'square' 'heptagon' 'hexagon'	'octagon' 'pentagon' 'rhomboid' 'star'	'triangle' 'vee' 'plus' 'arrow'	"not polygons" 'box' 'circle') do: [ :selector|		| shape gradient |		gradient := color scale: selector.		gradient			start: -50 asPoint;			stop: 50 asPoint.		shape := (RSShapeFactory perform: selector asSymbol)			size: 100;			model: selector;			popup;			color: gradient;			border: border.		canvas add: shape		 ].	RSGridLayout new gapSize: 50; on: canvas nodes.	canvas @ RSCanvasController.	^ canvas! !!RSShapeExamples methodsFor: 'shapes'!example13Arrow	<script: 'self new example13Arrow open setLabel: ''You can do it'''>	| canvas polygon labels paint |	canvas := RSCanvas new.	paint := (LinearGradientPaint fromArray:			{0 -> 'CC2A49'.			0.25 -> 'F99E4C'.			0.50 -> 'F36F38'.			0.75 -> 'EF4648'.			1 -> '582841'})		start: -125 asPoint;		stop: 125 asPoint.	polygon := RSPolygon new		points:			{100@0. 200@100.			160@100. 160@ 250.			40@ 250. 40@100.			0@ 100			};		cornerRadii: 7.77;		paint: paint;		yourself.	canvas add: polygon.	labels := #('Keep' 'calm' 'and' 'roassal' 'on') collectWithIndex: [ :t :index |		RSLabel new			fontSize: (index = 3 ifTrue: 10 ifFalse: [ 20 ]);			bold;			color: Color white;			text: t asUppercase;			yourself		].	canvas addAll: labels.	RSVerticalLineLayout new alignCenter on: labels.	labels asGroup translateBy: 50@50.	canvas @ RSCanvasController.	^ canvas! !!RSShapeExamples methodsFor: 'shapes'!example14Marker	<script: 'self new example14Marker open'>	| canvas  shapes line arrow |	canvas := RSCanvas new.	shapes := (1 to: 2) collect: [ :n |		RSEllipse new			model: n;			draggable;			size: 100;			yourself ].	arrow := RSShapeFactory triangle		color: Color white;		border: (RSBorder new color: Color red; width: 3);		size: 20;		yourself.	line := RSLine new		markerEnd: (RSMarker new			shape: arrow;			offsetRatio: 0.5;			offset: 10;			yourself);		from: shapes first;		to: shapes second;		yourself.	canvas addAll: shapes.	canvas add: line.	RSFlowLayout on: shapes.	^ canvas! !!RSShapeExamples methodsFor: 'shapes'!example16Bezier	<script: 'self new example16Bezier open'>	| canvas box1 box2 line |	canvas := RSCanvas new.	canvas addShape: (RSBezier new		color: Color red;		controlPoints:			{(0 @ 0).			(100 @ 100).			(200 @ 0).			(300 @ 100)};		yourself).	box1 := RSBox new		draggable;		size: 100;		color: Color blue;		translateTo: 100@ -200;		yourself.	box2 := RSBox new		draggable;		size: 100;		yourself.	canvas		add: box1;		add: box2.	line := RSBezier new		withVerticalAttachPoint;		from: box1;		controlPointsController: RSVerticalCPAPController new;		to: box2;		yourself.	canvas add: line.	^ canvas! !!RSShapeExamples methodsFor: 'shapes'!example17Labeled	<script: 'self new example17Labeled open'>	| canvas e1 e2 s line label |	canvas := RSCanvas new.	s := [ :m |		RSEllipse new			border: RSBorder new;			draggable;			labeled;			size: 20;			model: m;			yourself].	e1 := s value: 'hello'.	e2 := s value: 'world'.	e2 translateTo: 60@80.	label := RSLabeled new.	label location inner; middle.	label shapeBuilder textBlock: 'lining up!!'.	line := RSShapeFactory arrowedLine		addInteraction: label;		color: Color red;		from: e1;		to: e2;		yourself.	canvas add: e1; add: e2; add: line.	canvas @ RSCanvasController.	^ canvas! !!RSShapeExamples methodsFor: 'shapes'!example19Bitmap	<script: 'self new example19Bitmap open'>	| canvas shapes icons |	icons := Smalltalk ui icons icons associations sorted: [ :a :b |		         a key < b key ].	canvas := RSCanvas new.	shapes := icons collect: [ :icon |		          RSBitmap new			          form: icon value;			          model: icon;			          popupText: #key;			          when: RSMouseClick do: [ :evt |				          Clipboard clipboardText: evt shape model key.				          self inform: 'Copied icon name' ]			          for: self ].	canvas addAll: shapes.	RSGridLayout on: shapes.	canvas @ RSCanvasController.	^ canvas! !!RSShapeExamples methodsFor: 'shapes'!example20Highlightable	<script: 'self new example20Highlightable open'>	| canvas shapes labeled |	canvas := RSCanvas new.	labeled := RSLabeled new.	labeled highlightable.	shapes := #('Hello' 'World') collect: [ :m |		RSEllipse new			color: Color blue;			draggable;			addInteraction: labeled;			size: 20;			model: m;			yourself ].	canvas addAll: shapes.	RSHorizontalLineLayout on: shapes.	canvas @ RSCanvasController.	^ canvas! !!RSShapeExamples methodsFor: 'shapes'!example21MenuActivableOnElement	<script: 'self new example21MenuActivableOnElement open'>	| canvas boxes |	canvas := RSCanvas new.	boxes := (1 to: 100) collect: [ :n |		RSComposite new			color: Color blue translucent;			shapes: { RSLabel new text: n; yourself };			size: 30;			yourself ] as: RSGroup.	canvas addAll: boxes.	boxes @ RSHighlightable red.	RSGridLayout on: boxes.	boxes @ (RSMenuActivable new		menuDo: [ :aMenuMorph :anRSBox |			aMenuMorph				add: 'Inspect'				target: anRSBox				selector: #inspect				argument: #() ]).	canvas @ RSCanvasController.	^ canvas! !!RSShapeExamples methodsFor: 'lines'!example22ScaleEvents	<script: 'self new example22ScaleEvents open setLabel: ''Horizontal Tree'''>	"Zooming preserve the size of the red arrow"	| canvas |	canvas := RSCanvas new.	canvas addAll: (ArrayedCollection withAllSubclasses collect: [:cls |		| label box |		label := RSLabel new			text: cls;			yourself.		box := RSBox new			withBorder;			cornerRadius: (RSCornerRadius new right: 10);			extent: label extent + 5.		RSComposite new			draggable;			model: cls;			shapes: {box. label};			yourself]).	canvas @ RSCanvasController.	RSLineBuilder orthoHorizontal		markerEnd: (RSMarker new			offset: 6;			shape: (RSShapeFactory triangle				color: Color red;				size: 10;				yourself));		attachPoint: RSHorizontalAttachPoint new;		canvas: canvas;		shapes: canvas nodes;		connectFrom: #superclass.	canvas edges @ RSKeepBorderWidthRatioInteraction.	canvas edges @ RSKeepMarkersSizeRatioInteraction.	RSHorizontalTreeLayout new on: canvas nodes.	^ canvas! !!RSShapeExamples methodsFor: 'shapes'!example24Highlightable	<script: 'self new example24Highlightable open'>	| canvas shapes interaction |	canvas := RSCanvas new.	interaction := RSLabeled new.	interaction shapeBuilder: [:str |		| g title box |		title := RSLabel new text: str; yourself.		box := RSBox new			withBorder;			extent: title textWidth @ 3;			yourself.		g := { title. box }.		RSVerticalLineLayout new alignCenter; gapSize: 0; on: g.		g asGroup asShape].	interaction highlightable.	interaction target: [ :e | e shapes first ].	shapes := #('Hello' 'World') collect: [:str |		RSEllipse new			color: Color blue;			model: str;			addInteraction: interaction;			draggable;			size: 20;			yourself ].	canvas addAll: shapes.	RSHorizontalLineLayout on: shapes.	canvas @ RSCanvasController.	^ canvas! !!RSShapeExamples methodsFor: 'shapes'!example26AnimatedPopup	<script: 'self new example26AnimatedPopup open'>	| canvas interaction s box |	canvas := RSCanvas new.	interaction := RSAnimatedPopup new.	s := [:model |		RSBox new			size: 100;			model: model;			addInteraction: interaction;			translateTo: 100 asPoint;			isFixed: true;			yourself.		].	box := s value: 'Fixed'.	canvas add: box.	box := s value: 'Not Fixed'.	box color: Color red.	box isFixed: false.	canvas add: box.	^ canvas! !!RSShapeExamples methodsFor: 'shapes'!example27MultilineLabelBasic	<script: 'self new example27MultilineLabelBasic open'>	| canvas shapeBuilder text |	canvas := RSCanvas new.	text := '"tu est loin,trs loin de tous    ces regards vicieuxqui s''alimentent de ta lumire"'.	shapeBuilder := RSMultilineLabelBuilder new.	shapeBuilder labelShape		fontSize: 20;		italic.	canvas add: (shapeBuilder shapeFor: text).	shapeBuilder wrapStrategy: (RSWrapStrategy new wrapMaxWidth: 200).	canvas add: (shapeBuilder shapeFor: text).	shapeBuilder wrapStrategy:		(RSWrapEllipsisStrategy new wrapMaxWidth: 200).	canvas add: (shapeBuilder shapeFor: String loremIpsum).	RSFlowLayout on: canvas nodes.	canvas nodes		when: RSMouseClick		do: [ :evt | evt shape inspect ]		for: self.	canvas showEncompassingRectangles.	^ canvas zoomToFit! !!RSShapeExamples methodsFor: 'shapes'!example28MultilineLabel	<script: 'self new example28MultilineLabel open'>	| canvas shapes |	canvas := RSCanvas new.	shapes := RSShape withAllSubclasses collect: [ :cls |		          | methods |		          methods := cls methods collect: [ :met |			                     RSBox new				                     model: met;				                     size: 20;				                     popup;				                     when: RSMouseClick				                     do: [ :evt | evt shape inspect ]				                     for: self;				                     yourself ].		          RSGridLayout on: methods.		          RSComposite new			          model: cls;			          shapes: methods;			          padding: 10;			          color: (Color purple alpha: 0.3);			          popup;			          yourself ].	RSLineBuilder orthoVertical		withVerticalAttachPoint;		canvas: canvas;		shapes: shapes;		connectFrom: #superclass.	canvas addAll: shapes.	RSTreeLayout on: shapes.	canvas @ RSCanvasController.	^ canvas! !!RSShapeExamples methodsFor: 'lines'!example29AntAnimation	<script:	'self new example29AntAnimation open setLabel: ''Move mouse on one box'''>	| canvas shapes labelInt highInt popupMethod |	canvas := RSCanvas new.	labelInt := RSLabeled new.	labelInt shapeBuilder: [ :model |		RSLabel new			color: Color white;			text: model;			yourself ].	highInt := RSHighlightable withAntAnimation.	popupMethod := RSPopup text: #selector.	shapes := String withAllSubclasses collect: [ :cls |		          | methods |		          methods := cls methods collect: [ :met |			                     RSBox new				                     color: Color green;				                     model: met;				                     addInteraction: popupMethod;				                     size: met linesOfCode ].		          RSGridLayout on: methods.		          RSComposite new			          color: Color white translucent;			          model: cls;			          shapes: methods;			          padding: 10;			          popup;			          addInteraction: labelInt;			          addInteraction: highInt;			          yourself ].	canvas color: PharoDarkTheme new backgroundColor.	canvas addAll: shapes.	RSLineBuilder line		color: Color white;		withVerticalAttachPoint;		canvas: canvas;		connectFrom: #superclass.	canvas edges pushBack.	RSTreeLayout new		verticalGap: 100;		on: shapes.	canvas @ RSCanvasController.	canvas when: RSExtentChangedEvent do: [ canvas zoomToFit ] for: self.	^ canvas! !!RSShapeExamples methodsFor: 'shapes'!example30EdgesToChildren	<script: 'self new example30EdgesToChildren open'>	| canvas color shape parent1 parent2 line |	canvas := RSCanvas new.	color := NSScale category20b.	shape := [ :model |		RSComposite new			color: (color scale: model);			shapes: {				RSEllipse new					color: (color scale: model + 2);					size: 20;					yourself };			draggable;			padding: (Margin				left: 100				right: 10				top: 100				bottom: 10);			yourself. ].	parent1 := shape value: 1.	parent2 := shape value: 2.	parent2 translateTo: 100@100.	line := RSLine new		width: 2;		color: Color red;		from: parent1 shapes first;		to: parent2 shapes first;		yourself.	canvas newAnimation		repeat;		from: 0;		to: 360;		onStepDo: [:t | | p |			p := parent1 position.			parent1 matrix				loadIdentity;				rotateByDegrees: t.			parent1 position: p ].	canvas add: parent1; add: parent2; add: line.	^ canvas! !!RSShapeExamples methodsFor: 'shapes'!example31BasicGrapher	<script: 'self new example31BasicGrapher open'>	| classes canvas line shapes color |	classes := Collection withAllSubclasses.	canvas := RSCanvas new.	line := RSPolyline new		width: 2;		controlPoints: { 0@ -600. 0@0. 600@0 };		markerStartEnd: (RSShapeFactory triangle			size: 20;			color: Color black;			yourself);		yourself.	color := RSColorPalette sequential orrd9.	shapes := classes collect: [ :cls |		RSEllipse new			model: cls;			popup;			browseable;			withBorder;			color: (color scale: cls);			yourself ].	canvas addAll: shapes.	canvas add: line.	RSNormalizer size		from: 5;		to: 20;		shapes: shapes;		normalize: [ :cls | cls instVarNames size ].	RSNormalizer position		from: 0@0;		to: 600@ -600;		shapes: shapes;		normalize: [ :cls | cls numberOfMethods @ cls linesOfCode ].	canvas @ RSCanvasController.	^ canvas! !!RSShapeExamples methodsFor: 'shapes'!example32RSLabeledOnComposite	<script: 'self new example32RSLabeledOnComposite open'>	| canvas shapes labeled |	canvas := RSCanvas new.	labeled := RSLabeled new.	labeled location middle.	shapes := (1 to: 20) collect: [:n|		RSBox new			withBorder;			model: n;			@ labeled;			popup; draggable;			size: 50;			yourself		] as: RSGroup.	RSGridLayout on: shapes.	canvas add: shapes asShape.	shapes translateBy: 0@0.	canvas nodes first		scaleBy: 0.5@ 1;		rotateByDegrees: 45.	canvas @ RSCanvasController.	^ canvas! !!RSShapeExamples methodsFor: 'shapes'!example33ColorScaling	<script: 'self new example33ColorScaling open'>	| c classes scale numberOfMethods |	c := RSCanvas new.	classes := RSObject withAllSubclasses.	numberOfMethods := classes collect: #numberOfMethods.	scale := NSScale linear		domain: { numberOfMethods min. numberOfMethods max};		range: { 'red'. 'blue' }.	c addAll: (classes collect: [ :cls |		| b |		b := RSEllipse new.		b size: cls linesOfCode sqrt.		b color: (scale scale: cls numberOfMethods).		b model: cls.		b @ RSPopup.		b ]).	RSFlowLayout on: c shapes.	c @ RSCanvasController.	^ c! !!RSShapeExamples methodsFor: 'shapes'!example34MorphicPopup	<script: 'self new example34MorphicPopup open'>	| c |	c := RSCanvas new.	Collection withAllSubclassesDo: [ :cls |		c add: (RSBox new			model: cls;			size: 10;			yourself) ].	RSGridLayout on: c nodes.	c @ RSCanvasController.	c nodes @ (RSMorphicPopupInteraction new		"morphBuilder: [:model | ('Class: ', model asString) asStringMorph ]") .	^ c! !!RSShapeExamples methodsFor: 'lines'!example35Lines	<script: 'self new example35Lines open'>	| c circle box dragMeLabel |	c := RSCanvas new.	circle := RSEllipse new		color: Color green;		size: 10.	box := RSBox new		color: Color red;		size: 10.	c		add: circle;		add: box.	dragMeLabel := RSLabel new text: 'Drag me'.	c add: dragMeLabel.	RSLocation new		above;		center;		stick: dragMeLabel on: box.	c		add:			(RSLine new				color: Color veryVeryLightGray;				from: 0 @ -1000;				to: 0 @ 1000).	c		add:			(RSLine new				color: Color veryVeryLightGray;				from: -1000 @ 0;				to: 1000 @ 0).	box translateBy: 50 @ 50.	box @ RSDraggable.	c		add:			(RSLine new				color: Color blue;				from: box;				to: circle).	^ c! !!RSShapeExamples methodsFor: 'shapes'!example36ShapePosition	<script: 'self new example36ShapePosition open'>	| c circle box labelBox dragMeLabel |	c := RSCanvas new.	circle := RSEllipse new size: 10.	box := RSBox new		       color: Color red;		       size: 10.	c		add: circle;		add: box.	c add: (RSLine new			 color: Color veryVeryLightGray;			 from: 0 @ -1000;			 to: 0 @ 1000).	c add: (RSLine new			 color: Color veryVeryLightGray;			 from: -1000 @ 0;			 to: 1000 @ 0).	labelBox := RSLabel new text: 'Box'.	c add: labelBox.	labelBox setAsFixed.	labelBox translateBy: 100 @ 50.	box @ RSDraggable.	box		when: RSMouseDragging		do: [ :evt |			labelBox text:				'Box position = ' , evt position asIntegerPoint asString ]		for: self.	dragMeLabel := RSLabel new text: 'Drag me'.	c add: dragMeLabel.	RSLocation new		above;		center;		stick: dragMeLabel on: box.	box translateTo: 50 @ 50.	^ c! !!RSShapeExamples methodsFor: 'shapes'!example37PunchCard	<script: 'self new example37PunchCard open'>	| card |	card := RSPunchCardBuilder new.	card objects: String withAllSubclasses.	card addMetric: [:cls | cls numberOfMethods] name: 'NOM'.	card addMetric: [:cls | cls linesOfCode ] name: 'NLC'.	card addMetric: [:cls | cls numberOfVariables] name: 'NOV'.	^ card build! !!RSShapeExamples methodsFor: 'shapes'!example38Transformable	<script: 'self new example38Transformable open'>	| c |	c := RSCanvas new.	c add: (RSBox new		size: 200;		withBorder).	c add: (RSBox new		size: 100;		cornerRadius: 20;		withBorder).	c add: (RSEllipse new		extent: 200@60;		withBorder).	c add: (RSLabel new		fontSize: 100;		text: 'Kaguya Sama';		yourself).	c add: (RSBitmap new		form: (self iconNamed: #pharoBig);		yourself).	c add: (RSShapeFactory star		size: 200;		color: 'purple').	c add: (self example31BasicGrapher asShape		rotateByDegrees: 15;		color: Color lightGray translucent).	c add: (RSBox new		size: 50;		color: Color black).	c add: (RSLine new		withBorderAttachPoint;		from: c nodes first;		to: c nodes last).	RSGridLayout new		gapSize: 50;		on: c nodes.	c nodes do: [ :s | s model: s ].	c nodes		@ (RSDraggable new noValidateChildrenEvents);		@ (RSPopup text: [ :m | m class name ] ).	c nodes allButLast @ RSTransformable.	c @ RSCanvasController.	^ c! !!RSShapeExamples methodsFor: 'shapes'!example39RoassalPackages	<noTest>	<script: 'self new example39RoassalPackages open'>	| packagesRegExp packages canvas color labeled boxes stepping |	packagesRegExp := { 'Roassal3*' }.	packages := packagesRegExp flatCollect: [ :regExp |	    RPackageOrganizer default packages	        select: [ :p | regExp match: p packageName ] ].	canvas := RSCanvas new.	color := NSScale category20c.	labeled := RSLabeled new.	labeled shapeBuilder textBlock: #name.	boxes := packages collect: [ :pkg |	    RSBox new	        model: pkg;	        color: (color scale: pkg);	        @labeled;	        size: pkg linesOfCode sqrt;	        yourself  ].	canvas addAll: boxes.	canvas nodes @ (RSPopup text: #name).	RSLineBuilder arrowedLine	    withBorderAttachPoint;	    canvas: canvas;	    connectFrom: #yourself toAll: #dependentPackages.	stepping := RSForceLayoutSteppingInteraction new.	stepping layout	    length: 300;	    charge: -300.	canvas @ stepping.	canvas @ RSCanvasController.	^ canvas! !!RSShapeExamples methodsFor: 'lines'!example40LabelingLine	<script: 'self new example40LabelingLine open'>	| c shapeA shapeB line interactionLabel |	c := RSCanvas new.	shapeA := RSLabel model: 'A'.	shapeB := RSLabel model: 'B'.	c add: shapeA.	c add: shapeB.	shapeB translateBy: 100 @ 50.	shapeA @ RSDraggable.	shapeB @ RSDraggable.	line := RSLine new		        from: shapeA;		        to: shapeB.	line attachPoint: RSBorderAttachPoint new.	c add: line.	interactionLabel := RSLabeled new text: [ :notUsed |		                    line from model , ' -> ' , line to model ].	interactionLabel shapeBuilder labelShape		fontSize: 5;		color: #red.	interactionLabel location		inner;		middle.	line @ interactionLabel.	c @ RSCanvasController.	^ c! !!RSShapeExamples methodsFor: 'shapes'!example41Butterfly	<script: 'self new example41Butterfly open'>	| model from to popup canvas com box g column c1 c2 c3 eb h |	model := RSCanvas >> #zoomToFit.	from := model senders collect: #compiledMethod.	to := model implementors collect: #compiledMethod.	popup := RSPopup text: [ :m | m selector ].	canvas := RSCanvas new.	box := [ :method |	    com := RSComposite new	        model: method;	        add: (RSLabel new text: '<<',method methodClass name,'>>'; fontSize: 8);	        add: (RSLabel new text: method selector);	        @ popup;	        yourself.	    RSVerticalLineLayout new	        gapSize: 0;	        alignCenter;	        on: com children.	    com adjustToChildren.	    com padding: 10; withBorder.	    com ].	column := [ :col : align |	    g := col collect: [ :m |	        (box value: m)	            scaleBy:((1 / col size) max: 0.2);	            yourself.	         ] as: RSGroup.	    RSVerticalLineLayout new	          perform: align;	        gapSize: 2;	        on: g.	    g ].	c1 := column value: from value: #alignRight.	c2 := box value: model.	c3 := column value: to value: #alignLeft.	RSHorizontalLineLayout new	    gapSize: 30;	    alignMiddle;	    on: { c1. c2. c3 }.	eb := RSLineBuilder horizontalBezier	    color: Color lightGray;	     controlPointsController: (RSBlockCPController new	        block: [:ed | | f t ap |	            ap := ed attachPoint.	            f := ap startingPointOf: ed.	            t := ap endingPointOf: ed.	            Array	                with: f	                with: t x @ f y	                with: f x @ t y	                with: t. ]);	    canvas: canvas;	    withHorizontalAttachPoint;	    width: 0.5;	    yourself.	eb useElementAssociations: (c1 collect: [:c | c -> c2 ]), (c3 collect: [:c | c2-> c ]).	h := RSHighlightable new.	h withLines.	h highlightBorder: RSBorder new.	canvas addAll: c1; add: c2; addAll: c3.	canvas nodes @ h.	canvas @ RSCanvasController.	^ canvas! !!RSShapeExamples methodsFor: 'shapes'!example42DirectedBezier	<script: 'self new example42DirectedBezier open'>	| c shapes |	c := RSCanvas new.	shapes := {-200@ -50. 200@100. -200@ 150. 200@300 } collect: [:p |		RSEllipse new			withBorder;			color: Color white;			size: 150;			position: p;			yourself] as: RSGroup.	shapes doWithIndex: [:s :i | s model: i ].	shapes @ RSDraggable.	c addAll: shapes.	RSLineBuilder directedBezier		canvas: c;		shapes: shapes;		useAssociations: { 1 -> 2 }.	RSLineBuilder arrowedDirectedBezier		canvas: c;		shapes: shapes;		useAssociations: { 4 -> 3}.	c @ RSCanvasController.	^ c! !!RSShapeExamples methodsFor: 'shapes'!example43KeepLabelSize	<script: 'self new example43KeepLabelSize open		setLabel: #''Use the wheel'' '>	| canvas labels |	canvas := RSCanvas new.	labels := RSLabel models: String withAllSubclasses.	RSNormalizer fontSize		shapes: labels;		normalize: [ :cls |			(cls linesOfCode > 0				ifTrue: [ cls linesOfCode ln ]				ifFalse: [ 0 ]) + 5 ].	RSLineBuilder line		color: Color red;		canvas: canvas;		shapes: labels;		connectFrom: #superclass.	canvas addAll: labels.	RSTreeLayout on: labels.	labels @ RSKeepFontSizeRatioInteraction.	canvas @ RSCanvasController.	^ canvas! !!RSShapeExamples methodsFor: 'shapes'!example44Donna	<script: 'self new example44Donna open'>	| text canvas horizontal vertical groups count |	text := 'La donna  mobileQual piuma al ventoMuta d''accentoE di pensieroSempre un amabileLeggiadro visoIn pianto o in riso menzogneroLa donna  mobileQual piuma al ventoMuta d''accentoE di pensierE di pensierE di pensier sempre miseroChi a lei s''affidaChi le confidaMal cauto il corePur mai non sentesiFelice appienoChi su quel senoNon liba amoreLa donna  mobileQual piuma al ventoMuta d''accentoE di pensierE di pensierE di pensier'.	count := 0.	vertical := RSVerticalLineLayout new gapSize: 0.	horizontal := RSHorizontalLineLayout new alignLabel.	groups := (text splitOn: String cr,String cr) collect: [ :p |		| lines |		lines := p lines collect: [ :line |			| words |			words := (line splitOn: ' ') collect: [ :word |				RSLabel new					text: word;					ifNotNil: [ :lbl |						word = 'donna'							ifTrue: [ lbl bold; fontSize: 14 ].						word = 'misero'							ifTrue: [ lbl fontSize: 20; color: 'red' ].						word = 'pensier'							ifTrue: [								lbl italic; underline; color: 'blue'; fontSize: (count*4)+10.								count := count+1.  ]						 ];					yourself				].			horizontal on: words.			words asGroup asShape			 ].		vertical on: lines.		lines asGroup asShape.		].	canvas := RSCanvas new.	canvas addAll: groups.	RSHorizontalFlowLayout new		gapSize: 30;		on: groups.	canvas @ RSCanvasController.	^ canvas! !!RSShapeExamples methodsFor: 'shapes'!example45CompositeDragResize	<script: 'self new example45CompositeDragResize open'>	| c nodes |	c := RSCanvas new.	nodes := RSComposite models: Array withAllSubclasses,{RSRiceBinning} forEach: [ :compCls :cls|		compCls addAll: (RSComposite models: cls methods forEach: [:compMet :met|			compMet addAll: (RSBox models: (1 to: 4)).			RSGridLayout on: compMet children.			compMet color: Color red translucent.			compMet ]).		compCls children do: [ :child | child padding: 10 ].		RSGridLayout on: compCls children.		compCls color: Color blue translucent.		compCls		 ].	nodes do: [ :n | n padding: 10 ].	RSGridLayout on: nodes.	c addAll: nodes.	c allChildren do: [ :node | node @ RSDraggable ].	c @ RSResizeParentWhenChildMoves.	c @ RSCanvasController.	^ c! !!RSShapeExamples methodsFor: 'shapes'!example46Popups	<script: 'self new example46Popups open'>	| c shapes color |	c := RSCanvas new.	color := NSScale linear		from: Color gray;		to: Color blue.	shapes := Collection withAllSubclasses collect: [ :cls |		| computedColor |		computedColor := color scale: cls numberOfMethods.		RSBox new			model: cls;			draggable;			@ (RSPopup new in: [ :popup |				| sb |				sb := popup shapeBuilder.				sb boxBuilder					color: computedColor;					border: (RSBorder new color: Color black; width: 2).				sb labelBuilder labelShape color: Color white.				popup]);			color: computedColor;			size: cls linesOfCode sqrt + 10;			yourself ].	c addAll: shapes.	RSLineBuilder orthoVertical		withVerticalAttachPoint;		shapes: shapes;		connectFrom: #superclass.	RSTreeLayout on: shapes.	c @ RSCanvasController.	^ c! !!RSShapeExamples methodsFor: 'shapes'!example47CompositeClipChildren	<script: 'self new example47CompositeClipChildren open'>	| boxes containers c |	containers := {		              RSShape.		              String.		              RSEvent } collect: [ :rootCls |		              | container |		              container := RSComposite new.		              boxes := RSBox			                       models: rootCls withAllSubclasses			                       forEach: [ :box :cls |			                       box size: cls linesOfCode sqrt + 5 ].		              container addAll: boxes.		              RSLineBuilder line			              canvas: container;			              withVerticalAttachPoint;			              shapes: boxes;			              connectFrom: #superclass.		              RSTreeLayout on: boxes.		              container			              model: rootCls;			              adjustToChildren;			              padding: 10;			              labeled;			              border: (RSBorder new					               color: Color black;					               joinMiter);			              clipChildren: true;			              when: RSMouseDragging do: [ :evt |				              | d |				              d := evt camera distanceFromPixelToSpace: evt step.				              evt shape nodes do: [ :child | child translateBy: d ].				              evt signalUpdate ] yourself			              for: self ].	c := RSCanvas new.	c addAll: containers.	c nodes @ (RSPopup text: 'drag me!!').	RSFlowLayout on: containers.	c @ RSCanvasController.	^ c! !!RSShapeExamples methodsFor: 'shapes'!example48GhostDraggable	<script: 'self new example48GhostDraggable open'>	| c lb |	c := RSCanvas new.	c addAll: (RSPolygon			 models: String withAllSubclasses			 forEach: [ :s :o | s points: RSShapeFactory star points; size: 30 ]).	c shapes @ RSGhostDraggable.	c shapes @ RSHighlightable red withLines.	lb := RSLineBuilder line.	lb shapes: c shapes.	lb connectToAll: #dependentClasses.	RSGridLayout on: c nodes.	c nodes translateBy: 100 asPoint.	RSSimpleForceBasedLayout on: (c nodes copyFrom: 1 to: 4).	^ c @ RSCanvasController simple! !!RSShapeExamples methodsFor: 'accessing'!order	^ 20! !!RSExpandingBoxes methodsFor: 'events'!close: shape	shape children copy do: #remove.	self update! !!RSExpandingBoxes methodsFor: 'initialization'!initialize	super initialize.	canvas := RSCanvas new.	color := NSScale category20b.	base := RSComposite new.	base popup.	base when: RSMouseClick do: [ :evt | self processEvent: evt ].	border := RSBorder new! !!RSExpandingBoxes methodsFor: 'helpers'!nodeFor: cls	| com |	com := base copy.	com model: cls.	cls subclasses ifNotEmpty: [ com border: border ].	com announcer: base announcer.	com color: (color scale: cls) translucent.	^ com! !!RSExpandingBoxes methodsFor: 'events'!open: shape	| children |	children := shape model subclasses		collect: [ :cls | self nodeFor: cls ].	shape addAll: children.	self update! !!RSExpandingBoxes methodsFor: 'events'!processEvent: evt	| shape |	shape := evt shape.	shape children		ifEmpty: [ self open: shape]		ifNotEmpty: [ self close: shape ]! !!RSExpandingBoxes methodsFor: 'updating'!relayout: shape	shape propertyAt: #original put: shape encompassingRectangle.	shape shapes do: [ :s | self relayout: s ].	RSGridLayout on: shape shapes.	shape adjustToChildren.	shape padding: 10! !!RSExpandingBoxes methodsFor: 'running'!run	<script: 'self new run'>	canvas add: (self nodeFor: Collection).	self update.	canvas open! !!RSExpandingBoxes methodsFor: 'updating'!saveCurrent: shape	shape children do: [ :s | self saveCurrent: s ].	shape propertyAt: #current put: shape encompassingRectangle! !!RSExpandingBoxes methodsFor: 'updating'!scale: shape at: t	| rect1 rect2 |	shape children do: [ :s | self scale: s at: t ].	rect1 := shape propertyAt: #original ifAbsent: [ ^ self].	rect2 := shape propertyAt: #current.	shape translateTo: (rect1 floatCenter interpolateTo: rect2 floatCenter at: t).	shape extent: (rect1 extent interpolateTo: rect2 extent at: t)! !!RSExpandingBoxes methodsFor: 'updating'!update	| first |	first := canvas shapes first.	self relayout: first.	self saveCurrent: first.	canvas newAnimation		onStepDo: [ :t |			self scale: first at: t.			self zoomCanvans.			canvas signalUpdate.			 ]! !!RSExpandingBoxes methodsFor: 'updating'!zoomCanvans	canvas zoomToFit	canvas camera scale: 1! !!RSBezier class methodsFor: '*Roassal3-Examples'!exampleBezier	| bezier |	bezier := self new.	bezier controlPoints: {0@0. 100@ -50.  0@ -100. 50@ 0}.	^ Smalltalk tools inspector inspect: bezier! !!RSBezier class methodsFor: '*Roassal3-Examples'!exampleControlPointsController	| bezier controller points |	bezier := self new.	points := {0@0. 100@ -50.  0@ -100. 50@ 0} collect: [:point |		RSCircle new			radius: 5;			position: point;			draggable;			yourself ].	controller := RSCustomCPController new		models: points;		yourself.	bezier controlPointsController: controller.	^ RSCanvas new		add: bezier;		addAll: points;		open! !!RSScrollBarsCanvasInteraction class methodsFor: '*Roassal3-Examples'!example	| canvas |	canvas := self canvasExample.	canvas @ RSDraggableCanvasInteraction.	canvas @ RSKeyNavigationCanvasInteraction.	canvas @ self.	^ canvas open! !!RSScrollBarsCanvasInteraction class methodsFor: '*Roassal3-Examples'!exampleOriginTopLeft	| canvas |	canvas := self canvasExample.	canvas originTopLeft.	canvas @ RSDraggableCanvasInteraction.	canvas @ RSKeyNavigationCanvasInteraction.	canvas @ self.	^ canvas open! !!RSZoomableCanvasInteraction class methodsFor: '*Roassal3-Examples'!example	| canvas |	canvas := self canvasExample.	canvas @ self.	canvas @ RSDraggableCanvasInteraction.	canvas @ RSKeyNavigationCanvasInteraction.	canvas @ RSScrollBarsCanvasInteraction.	canvas @ RSZoomToFitCanvasInteraction.	^ canvas open! !!RSCanvas class methodsFor: '*Roassal3-Examples'!exampleSimple	| canvas |	canvas := self new.	canvas color: Color black.	"add some shapes here"	^ canvas open! !!RSCanvas class methodsFor: '*Roassal3-Examples'!exampleSpec	| canvas spec |	canvas := self new.	canvas color: Color black.	spec := SpMorphPresenter new.	spec morph: canvas createMorph.	^ spec open! !!RSEquidistantCircleLayout class methodsFor: '*Roassal3-Examples'!example1	| v elements |	v := RSCanvas new.	elements := RSCircle models: (1 to: 15).	elements do: [ :each | each color: Color red; size: each model * 4 ].	v addAll: elements.	self on: elements.	v @ RSCanvasController.	^ v open! !!RSClusteringLayout class methodsFor: '*Roassal3-Examples'!exampleMondrian	| m nodes class |	class := Smalltalk globals		at: #RSMondrian		ifAbsent: [ ^ RSCanvas new open ].	m := class new.	m nodes: Collection allSubclasses.	m line connectFrom: #superclass.	m normalizeSize: #numberOfLinesOfCode.	m build.	nodes := m canvas nodes.	RSConditionalLayout new		ifNotConnectedThen: RSGridLayout new;		else: (self new					clustersLayout: RSFlowLayout new;					forEachLayout: RSTreeLayout new);		on: nodes.	^ m canvas open! !!RSClusteringLayout class methodsFor: '*Roassal3-Examples'!exampleNumbers	| m nodes class |	class := Smalltalk globals		at: #RSMondrian		ifAbsent: [ ^ RSCanvas new open ].	m := class new.	m nodes: (10 to: 50).	m line connectFrom: [ :nb | nb // 2 ].	m build.	nodes := m canvas nodes.	RSConditionalLayout new		ifNotConnectedThen: RSGridLayout new;		else: (self new					clustersLayout: RSFlowLayout new;					forEachLayout: RSTreeLayout new);		on: nodes.	^ m canvas open! !!RSCanvasController class methodsFor: '*Roassal3-Examples'!exampleNoLegend	| canvas int |	canvas := RSCanvas new.	int := self new.	int noLegend.	canvas addAll: (RSLabel models: ('Nessun dorma!! Nessun dorma!! Tu pure, oh Principessa' splitOn: ' ')).	RSVerticalLineLayout on: canvas nodes.	canvas addInteraction: int.	^ canvas open! !!RSGhostDraggable class methodsFor: '*Roassal3-Examples'!example	| canvas |	canvas := self canvasExample.	canvas nodes @ self.	^ canvas open		setLabel: 'Drag and find the ghost'! !!RSGhostDraggable class methodsFor: '*Roassal3-Examples'!exampleChangeColor	| canvas int |	canvas := self canvasExample.	int := self new.	int color: Color red.	canvas nodes @ int.	^ canvas open		setLabel: 'Drag and find the ghost'! !!RSDraggable class methodsFor: '*Roassal3-Examples'!example	| canvas |	canvas := self canvasExample.	canvas originTopLeft.	canvas nodes @ self.	"	canvas nodes addInteraction: RSDraggable.	canvas nodes @ RSDraggable new.	canvas nodes first @ RSDraggable.	"	^ canvas open		setLabel: 'Drag boxes'! !!RSBitmap class methodsFor: '*Roassal3-Examples'!example	| image |	image := self new.	image form: (self iconNamed: #pharo).	^ Smalltalk tools inspector inspect: image! !!RPackage methodsFor: '*Roassal3-Examples'!dependentPackagesWithOccurences	"	Return the list of packages that I depend on. The result may includes several times the same packages. This reflects the number of dependencies.	(RPackageOrganizer default packageNamed: 'Athens-Cairo') dependentPackagesWithOccurences	"	^ (self definedClasses flatCollect: #dependentClassesWithOccurences as: Bag) collect: #package! !!RPackage methodsFor: '*Roassal3-Examples'!numberOfDependenciesToward: anotherPackage	"	Return the number of dependencies between mysefl and the package provided as argument	(RPackageOrganizer default packageNamed: 'Athens-Cairo') numberOfDependenciesToward: (RPackageOrganizer default packageNamed: 'Text-Core')	"	^ (self dependentPackagesWithOccurences select: [ :p | p == anotherPackage ]) size! !!RSDraggableCanvasInteraction class methodsFor: '*Roassal3-Examples'!example	| canvas interaction |	canvas := self canvasExample.	"canvas @ RSDraggableCanvasInteraction."	interaction := self new.	interaction hasDraggableAnimation: false.	canvas @ interaction.	"or"	"canvas addInteraction RSDraggableCanvasInteraction new"	^ canvas open! !!RSDraggableCanvasInteraction class methodsFor: '*Roassal3-Examples'!exampleOriginTopLeft	| canvas |	canvas := self canvasExample.	canvas originTopLeft.	canvas @ self.	^ canvas open! !!RSSelfLoopCPController class methodsFor: '*Roassal3-Examples'!example	| canvas links models arrow |	canvas := RSCanvas new.	models := 1 to: 10.	canvas addAll: (RSComposite models: models forEach: [:c :m |		c addAll: {			RSBox new				extent: 20 asPoint;				color: Color veryVeryLightGray;				border: (RSBorder new color: Color black).			(RSLabel model: m) color: Color black}.		c]).	canvas nodes @ RSDraggable.	links := models collect: [ :n | (n // 2)->n ] as: OrderedCollection.	links addFirst: 3 -> 3.	arrow := RSShapeFactory arrow.	arrow size: 10.	links do: [ :assoc | | from to line |		from := canvas shapeFromModel: assoc key.		to := canvas shapeFromModel: assoc value.		(from notNil and: [ to notNil ]) ifTrue: [			line := RSBezier new				markerEnd: arrow;				attachPoint: (RSBorderAttachPoint new endOffset: 5);				controlPointsController: (self new);				from: from;				to: to.			line color: Color black.			canvas add: line ]	].	(Smalltalk globals at: #RSTreeLayout) on: canvas nodes.	canvas zoomToFit.	^ canvas open! !!String methodsFor: '*Roassal3-Examples'!cutCamelCase	"Breaks apart words written in camel case.	It's not simply using piecesCutWhere: because we want	to also deal with abbreviations and thus we need to	decide based on three characters, not just on two:	 ('FOOBar') piecesCutWhereCamelCase asArray = #('FOO' 'Bar').	('FOOBar12AndSomething') piecesCutWhereCamelCase asArray = #('FOO' 'Bar' '12' 'And' 'Something')	"	| start previous current next pieces |	self isEmpty ifTrue: [^self].	start := 1.	pieces := OrderedCollection new.	3 to: self size do: [ :index |		previous := self at: index - 2.		current := self at: index - 1.		next := self at: index.		((previous isLowercase and: [current isUppercase]) or: [			(previous isUppercase and: [current isUppercase and: [next isLowercase ]]) or: [				(previous isDigit not and: [current isDigit]) or: [					previous isDigit and: [current isDigit not]		]]]) ifTrue: [			pieces add: (self copyFrom: start to: index - 2).			start := index - 1].	].	pieces addAll: ((self copyFrom: start to: self size) piecesCutWhere: [:a :b |		(a isDigit and: [b isDigit not]) or: [a isDigit not and: [b isDigit ]]]).	^ pieces! !!RSBox class methodsFor: '*Roassal3-Examples'!example	| box |	box := self new.	box extent: 100 asPoint.	box cornerRadius: 10.	box color: Color blue muchDarker.	^ Smalltalk tools inspector inspect: box! !!RSPolyline class methodsFor: '*Roassal3-Examples'!exampleArrowedPolyline	| line |	line := self new.	line controlPoints: {0@0. 100@0. 0@ -100 }.	line markerEnd: (RSShapeFactory arrow size: 10).	line color: Color purple.	^ RSCanvas new		add: line;		open! !!RSPolyline class methodsFor: '*Roassal3-Examples'!examplePolyline	| line |	line := self new.	line controlPoints: {0@0. 100@ -50.  0@ -100. 50@ 0}.	^ Smalltalk tools inspector inspect: line! !!RSLabeled class methodsFor: '*Roassal3-Examples'!exampleBoxes	| c shapes |	c := RSCanvas new.	shapes := RSGroup new.	1 to: 3 do: [ :v |		shapes add: (RSBox new model: v) ].	shapes @ (self new text: [ :m | 'Value = ', m asString ]).	RSNormalizer size		shapes: shapes;		from: 20; to: 40;		normalize: [ :aModel | aModel ].	c addAll: shapes.	RSVerticalLineLayout new gapSize: 30; on: shapes.	c @ RSCanvasController.	^ c open! !!RSLabeled class methodsFor: '*Roassal3-Examples'!exampleLabeledHighlightable	| c shapes |	c := RSCanvas new.	shapes := (1 to: 10) collect: [ :v | RSBox new model: v; size: 30 ] as: RSGroup.	c addAll: shapes.	shapes @ self new highlightable.	RSNormalizer size shapes: shapes; normalize: #yourself.	RSGridLayout on: shapes.	c @ RSCanvasController.	^ c open! !!RSVerticalCellLayout class methodsFor: '*Roassal3-Examples'!example1	| c shapes |	c := RSCanvas new.	shapes := RSLabel models: (1 to: 9).	c addAll: shapes.	self on: shapes.	c @ RSCanvasController.	^ c open! !!RSHighlightable class methodsFor: '*Roassal3-Examples'!example	| canvas |	canvas := self canvasExample.	canvas nodes @ self blue.	^ canvas open		setLabel: 'Move mouse over shapes';		yourself! !!RSHighlightable class methodsFor: '*Roassal3-Examples'!exampleBorder	| c shapes interaction |	c := RSCanvas new.	shapes := (1 to: 30) collect: [ :v | RSBox new border: (RSBorder new color: Color red; width: 3); model: v ] as: RSGroup.	c addAll: shapes.	shapes @ RSPopup.	RSNormalizer size		shapes: shapes;		normalize: #yourself.	interaction := self new.	interaction highlightColor: Color blue.	interaction highlightBorder: (RSBorder new color: Color black; width: 3).	shapes @ interaction.	RSGridLayout on: shapes.	c @ RSCanvasController.	^ c open! !!RSHighlightable class methodsFor: '*Roassal3-Examples'!exampleGrid	| c shapes interaction |	c := RSCanvas new.	shapes := (1 to: 30) collect: [ :v | RSBox new  size: 20; model: v ] as: RSGroup.	c addAll: shapes.	shapes @ RSPopup.	interaction := self new.	interaction highlightBorder: (RSBorder new width: 3; color: Color pink).	shapes @ interaction.	RSGridLayout on: shapes.	c @ RSCanvasController.	^ c open! !!RSHighlightable class methodsFor: '*Roassal3-Examples'!exampleGrid2	| c shapes interaction |	c := RSCanvas new.	shapes := (1 to: 30) collect: [ :v | RSBox new  size: 20; model: v ] as: RSGroup.	c addAll: shapes.	shapes @ RSPopup.	interaction := self new.	interaction highlightBorder: (RSBorder new width: 3; color: Color pink).	shapes @ interaction.	RSGridLayout on: shapes.	c @ RSCanvasController.	^ c open! !!RSHighlightable class methodsFor: '*Roassal3-Examples'!exampleInteractive	| classes c shapes buttonReset selectedShapes highlightable lbl buttonInspect g |	classes := Collection withAllSubclasses.	c := RSCanvas new.	selectedShapes := RSGroup new.	highlightable := self new.	lbl := RSLabel new.	shapes := classes		          collect: [ :cls | RSBox new model: cls ]		          as: RSGroup.	c addAll: shapes.	RSNormalizer size		shapes: shapes;		normalize: #numberOfMethods.	RSFlowLayout on: shapes.	shapes @ RSPopup.	buttonReset := RSLabel text: 'Reset'.	c add: buttonReset.	buttonReset setAsFixed.	buttonReset @ self red.	buttonReset		when: RSMouseClick		do: [ :evt |			selectedShapes do: [ :s |				highlightable restore: s selector: #color ].			selectedShapes := RSGroup new.			lbl text: ''.			c signalUpdate ]		for: self.	buttonInspect := RSLabel text: 'Inspect'.	c add: buttonInspect.	buttonInspect setAsFixed.	buttonInspect @ self red.	buttonInspect		when: RSMouseClick		do: [ :evt | selectedShapes inspect ]		for: self.	c add: lbl.	lbl setAsFixed.	lbl translateTo: 90 @ 30.	g := {		     buttonReset.		     buttonInspect } asGroup.	RSHorizontalLineLayout on: g.	g translateTo: g extent / 2 + (10 @ 10).	shapes		when: RSMouseClick		do: [ :evt |			(selectedShapes includes: evt shape) ifFalse: [				selectedShapes add: evt shape ].			highlightable record: evt shape selector: #color value: Color red.			lbl text: selectedShapes size asString , ' selected shapes'.			c signalUpdate ]		for: self.	c @ RSCanvasController.	^ c openOnce! !!RSHighlightable class methodsFor: '*Roassal3-Examples'!exampleNumbers	| c shapes lb int |	c := RSCanvas new.	shapes := (1 to: 10) collect: [ :v | RSEllipse new size: 20; model: v ] as: RSGroup.	c addAll: shapes.	shapes @ RSPopup new; @ RSDraggable new.	RSCircleLayout on: shapes.	lb := RSLineBuilder arrowedLineWithOffset: 0.5.	lb canvas: c.	lb connectTo: [ :v | 1 ].	int := self new withEdges highlightColor: Color red.	shapes @ int.	c @ RSCanvasController.	^ c open! !!RSHighlightable class methodsFor: '*Roassal3-Examples'!exampleTree	| c shapes interaction |	c := RSCanvas new.	shapes := (1 to: 30) collect: [ :v | RSEllipse new  model: v; size: 10 ] as: RSGroup.	c addAll: shapes.	shapes @ RSPopup.	RSEdgeBuilder line		canvas: c;		withBorderAttachPoint;		connectFrom: [ :v | v // 2 ].	interaction := self new.	interaction highlightBorder: (RSBorder new color: Color black; width: 3).	interaction withEdges.	shapes @ interaction.	RSTreeLayout on: shapes.	c @ RSCanvasController.	^ c open! !!RSControlConfiguration class methodsFor: '*Roassal3-Examples'!example1	| c controller |	c := RSCanvas new.	controller := RSCanvasController new.	controller configuration: (self new maxScale: 10).	c @ controller.	^ c open! !!RSControlConfiguration class methodsFor: '*Roassal3-Examples'!example2	| canvas shapes int |	canvas := RSCanvas new.	shapes := RSLabel models: #('hello' 'world' 'from' 'Roassal3').	canvas addAll: shapes.	RSVerticalLineLayout on: shapes.	int := RSCanvasController new.	int configuration		minScale: 1;		maxScale: 3.	canvas @ int.	^ canvas open! !!CompiledMethod methodsFor: '*Roassal3-Examples'!dependentMethods	"Return the list of methods defined in my class for which I may invoke"	"(self >> #dependentMethods) dependentMethods"	^ self messages		select: [ :k | self methodClass methodDict includesKey: k ]		thenCollect: [ :k | self methodClass >> k ]! !!CompiledMethod methodsFor: '*Roassal3-Examples'!numberOfLinesOfCode	^ self linesOfCode! !!RSKeepCanvasPositionCanvasInteraction class methodsFor: '*Roassal3-Examples'!example	| canvas window |	canvas := self canvasExample.	"this interaction is visible when the component changes it extent"	canvas @ self.	canvas @ RSDraggableCanvasInteraction.	window := canvas open.	window setLabel: 'Drag me'.	[	(Delay forSeconds: 5) wait.	window extent: 300@300 ] fork.	^ window! !!RSScrollWheelCanvasInteraction class methodsFor: '*Roassal3-Examples'!example	| canvas |	canvas := self canvasExample.	canvas @ self.	canvas @ RSDraggableCanvasInteraction.	canvas @ RSKeyNavigationCanvasInteraction.	canvas @ RSScrollBarsCanvasInteraction.	canvas		when: RSExtentChangedEvent		do: [ :evt |			canvas				zoomToFit;				signalUpdate ]		for: self.	^ canvas open		  setLabel: 'Use mouse wheel';		  yourself! !!RSLine class methodsFor: '*Roassal3-Examples'!exampleFMT	| line |	line := self new.	line startPoint: 0@0.	line endPoint: 200@100.	line color: Color black.	line width: 1.	line format: '--^'.	line markerEnd shape size: 20.	^ RSCanvas new		add: line;		zoomToFit;		open! !!RSLine class methodsFor: '*Roassal3-Examples'!exampleLine	| line |	line := self new.	line startPoint: 0@0.	line endPoint: 200@100.	line color: Color black.	line width: 10.	line capRound.	^ RSCanvas new		add: line;		open! !!RSZoomToFitCanvasInteraction class methodsFor: '*Roassal3-Examples'!example	| canvas interaction |	canvas := self canvasExample.	canvas originTopLeft.	interaction := self new.	interaction useZoomToFitOnStart; useZoomToFitOnExtentChanged.	canvas @ interaction.	canvas @ RSKeyNavigationCanvasInteraction.	canvas @ RSDraggableCanvasInteraction.	canvas @ RSScrollBarsCanvasInteraction.	^ canvas open		setLabel: 'Resize the window';		yourself! !!RSWeightedCircleLayout class methodsFor: '*Roassal3-Examples'!example1	| v elements |	v := RSCanvas new.	elements := RSCircle models: (1 to: 15).	elements do: [ :each | each size: each model * 4; color: Color red ].	v addAll: elements.	self on: elements.	v @ RSCanvasController.	^ v open! !!RSBlink class methodsFor: '*Roassal3-Examples'!example	| canvas shapes |	canvas := RSCanvas new.	shapes := RSCircle models: (1 to: 9).	shapes size: 30.	canvas addAll: shapes.	RSGridLayout on: shapes.	shapes when: RSMouseClick do: [ :evt | evt shape @ self ] for: self.	shapes fifth @ self.	canvas zoomToFit.	^ canvas open		  setLabel: 'Click one ellipse';		  yourself! !!RSCellLayout class methodsFor: '*Roassal3-Examples'!example1	| c shapes |	c := RSCanvas new.	shapes := RSLabel models: (3 to: 11).	c addAll: shapes.	self on: shapes.	c @ RSCanvasController.	^ c open! !!RSCellLayout class methodsFor: '*Roassal3-Examples'!example2	| c shapes |	c := RSCanvas new.	"each component has different extent. But each line of the layout contains 10 shapes maximun"	shapes := RSComposite 		boxesForModels: SequenceableCollection withAllSubclasses.	c addAll: shapes.	self new		lineItemsCount: 5;		on: shapes.	c @ RSCanvasController.	^ c open! !!RSCellLayout class methodsFor: '*Roassal3-Examples'!example3	| c shapes |	c := RSCanvas new.	"each component has different extent. But each line of the layout contains 10 shapes maximun"	shapes := RSComposite 		boxesForModels: ((1 to: 9) collect: [:i | 'X']).	c addAll: shapes.	self new		lineItemsCount: 3;		horizontalGap: 2;		verticalGap: 10;		on: shapes.	c @ RSCanvasController.	^ c open! !!RSSVGPathLine class methodsFor: '*Roassal3-Examples'!exampleArc	| canvas line |	canvas := RSCanvas new.	line := self new.	line borderColor: Color black.	line paint: Color lightGray.	line svgPath: [ :theLine | [ :pathBuilder |		| radius center startAngle deltaAngle |		radius := 60.		startAngle := 45 degreesToRadians.		deltaAngle := 90 degreesToRadians.		center := 0@0.		pathBuilder			moveTo: (startAngle cos @ startAngle sin) * radius + center;			arcCenterX: center x			centerY: center y			radius: radius			startAngle: startAngle			endAngle: startAngle + deltaAngle		 ] ].	canvas add: line.	^ canvas open! !!RSMenuActivable class methodsFor: '*Roassal3-Examples'!example	| m |		m := RSCanvas new.	m addAll: ((1 to: 10) collect: [:each | | label |		label := RSLabel new			text: each asString;			yourself.		{ label } asShape			padding: 5;			model: each;			color: Color white;			borderColor: Color black;			yourself		]).	RSGridLayout on: m nodes.	m @ RSCanvasController.	m nodes @ (self new		menuDo: [ :menu :shape |			menu				add: 'Inspect'				target: shape model				selector: #inspect ]).	^ m open! !!RSArrowedLine class methodsFor: '*Roassal3-Examples'!exampleArrow	| arrow |	arrow := self new.	^ Smalltalk tools inspector inspect: arrow! !!Class methodsFor: '*Roassal3-Examples'!numberOfLinesOfCode	"A convenient and homogeneous method to return the number of lines of code"	^ self linesOfCode! !!RSKeyNavigationCanvasInteraction class methodsFor: '*Roassal3-Examples'!example	| canvas |	canvas := self canvasExample.	canvas @ self.	canvas zoomToFit.	^ canvas open		setLabel: 'Use key arrows';		yourself! !!RSKeyNavigationCanvasInteraction class methodsFor: '*Roassal3-Examples'!exampleNoHorizontalScroll	| canvas interaction |	canvas := self canvasExample.	interaction := self new.	interaction hasHorizontalScrolling: false.	canvas @ interaction.	canvas zoomToFit.	^ canvas open		setLabel: 'No horizontal scroll';		yourself! !!RSKeyNavigationCanvasInteraction class methodsFor: '*Roassal3-Examples'!exampleNoVerticalScroll	| canvas interaction |	canvas := self canvasExample.	interaction := self new.	interaction hasVerticalScrolling: false.	canvas @ interaction.	canvas zoomToFit.	^ canvas open		setLabel: 'No vertical scroll';		yourself! !!RSConditionalLayout class methodsFor: '*Roassal3-Examples'!exampleCollection	| classes shapes c eb |	classes := Collection allSubclasses.	shapes := classes collect: [ :class | RSBox new size: 10; model: class ] as: RSGroup.	c := RSCanvas new.	c addAll: shapes.	eb := RSEdgeBuilder orthoVertical.	eb canvas: c.	eb withVerticalAttachPoint.	eb shapes: shapes.	eb connectFrom: #superclass.	"RSTreeLayout on: shapes."	self new		ifNotConnectedThen: RSGridLayout new;		else: RSTreeLayout new;		on: shapes.	c @ RSCanvasController.	^ c open! !!RSConditionalLayout class methodsFor: '*Roassal3-Examples'!exampleCollection2	| classes shapes c eb |	classes := Collection allSubclasses.	shapes := classes collect: [ :class | RSBox new size: 10; model: class ] as: RSGroup.	c := RSCanvas new.	c addAll: shapes.	eb := RSEdgeBuilder orthoVertical.	eb canvas: c.	eb withVerticalAttachPoint.	eb shapes: shapes.	eb connectFrom: #superclass.	"RSTreeLayout on: shapes."	self new		ifConnectedThen: RSTreeLayout new;		else: RSGridLayout new;		on: shapes.	c @ RSCanvasController.	^ c open! !"Roassal3-Examples"!!RSLegendExamples commentStamp: '' prior: 0!I have basic examples of legend builder!!RSLegendExamples methodsFor: 'examples'!canvasExample	| canvas classes |	canvas := RSCanvas new.	classes := RSShape withAllSubclasses collect: [ :cls |		RSBox new			draggable;			popup;			model: cls;			height: cls numberOfMethods;			width: (cls instVarNames size + 1) * 5 ] as: RSGroup.	canvas addAll: classes.	RSLineBuilder line		withVerticalAttachPoint;		width: 0.5;		canvas: canvas;		capRound;		shapes: classes;		connectFrom: #superclass.	RSNormalizer color		from: Color black;		to: Color red;		shapes: classes;		normalize: #numberOfMethods.	RSTreeLayout on: classes.	^ canvas! !!RSLegendExamples methodsFor: 'examples'!example01Basic	<script: 'self new example01Basic open'>	| b |	b := RSLegend new.	b text: 'Circle = classes, size = number of methods; gray links = inheritance;'.	b text: 'Blue links = dependencies; layout = force based layout on the inheritance links'.	b build.	self assert: b shapes size = 2.	self assert: b container shapes size = 1.	b canvas @ RSCanvasController.	^ b canvas! !!RSLegendExamples methodsFor: 'examples'!example02Border	<script: 'self new example02Border open'>	| b |	b := RSLegend new.	b text: 'Circle = classes, size = number of methods; gray links = inheritance;'.	b text: 'Blue links = dependencies; layout = force based layout on the inheritance links'.	b legendDo: [ :l |		l			withBorder;			padding: 50 ].	b build.	b canvas @ RSCanvasController.	^ b canvas! !!RSLegendExamples methodsFor: 'examples'!example03Vertical	<script: 'self new example03Vertical open'>	| b |	b := RSLegend new.	b		title: 'Mid Heros';		text: 'Invoker';		text: 'Shadow Fiend';		text: 'Tinker';		text: 'Meepo'.	b layout vertical gapSize: 20.	b legendDo: [ :l |		l			withBorder;			padding: (Margin left: 50 right: 10 top: 10  bottom: 50) ].	b build.	b canvas @ RSCanvasController.	^ b canvas! !!RSLegendExamples methodsFor: 'examples'!example04Horizontal	<script: 'self new example04Horizontal open'>	| b |	b := RSLegend new.	b		text: 'Invoker';		text: 'Shadow Fiend';		text: 'Tinker';		text: 'Meepo'.	b legendDo: [ :l |		l			withBorder;			padding: 10 ].	b layout horizontal gapSize: 20.	b build.	b canvas @ RSCanvasController.	^ b canvas! !!RSLegendExamples methodsFor: 'examples'!example05Colors	<script: 'self new example05Colors open'>	| b color |	b := RSLegend new.	color := NSScale category20.	b		title: 'Mid Heros';		text: 'Invoker' withCircleColor: color;		text: 'Shadow Fiend' withCircleColor: color;		text: 'Tinker' withCircleColor: color;		text: 'Meepo' withCircleColor: Color black.	b legendDo: [ :l |		l			withBorder;			padding: 20 ].	b build.	b canvas @ RSCanvasController.	^ b canvas! !!RSLegendExamples methodsFor: 'examples'!example06BoxColors	<script: 'self new example06BoxColors open'>	| b color |	b := RSLegend new.	color := NSScale category20.	b		text: 'Invoker' withBoxColor: color;		text: 'Shadow Fiend' withBoxColor: color;		text: 'Tinker' withBoxColor: color;		text: 'Meepo' withBoxColor: color.	b legendDo: [ :l |		l			withBorder;			padding: 20 ].	b layout horizontal gapSize: 30.	b build.	b canvas @ RSCanvasController.	^ b canvas! !!RSLegendExamples methodsFor: 'examples'!example07BoxFading	<script: 'self new example07BoxFading open'>	| b |	b := RSLegend new.	b title: 'Legend'.	b text: 'Number of lines of code' withFadingRamp: {0->'black'. 1->'red'}.	b legendDo: [:l | l withBorder; padding: 10 ].	b build.	b canvas @ RSCanvasController.	^ b canvas! !!RSLegendExamples methodsFor: 'examples'!example08Polygons	<script: 'self new example08Polygons open'>	| b |	b := RSLegend new.	b title: 'Polygons'.	#(diamond triangle star pentagon octagon) do: [ :selector |		b text: selector withShape: ((RSShapeFactory perform: selector) size: 15) ].	b build.	b canvas @ RSCanvasController.	^ b canvas! !!RSLegendExamples methodsFor: 'examples'!example09Lines	<script: 'self new example09Lines open'>	| b |	b := RSLegend new.	b title: 'Line with markers'.	#(diamond triangle star pentagon octagon arrow) do: [ :selector |		| line marker |		marker := (RSShapeFactory perform: selector) size: 10.		line := RSLine new markerEnd: marker;			startPoint: 0@0;			endPoint: 20@0;			yourself.		b text: selector withShape: line.		 ].	b build.	b canvas @ RSCanvasController.	^ b canvas! !!RSLegendExamples methodsFor: 'examples'!example10Location	<script: 'self new example10Location open setLabel: ''TSShape withAllSubclasses'''>	| canvas classes b |	canvas := RSCanvas new.	classes := RSShape withAllSubclasses collect: [ :cls |		RSBox new			draggable;			popup;			model: cls;			height: cls numberOfMethods;			width: (cls instVarNames size + 1) * 5 ] as: RSGroup.	canvas addAll: classes.	RSLineBuilder line		withVerticalAttachPoint;		width: 0.1;		canvas: canvas;		shapes: classes;		connectFrom: #superclass.	RSNormalizer color		from: Color black;		to: Color red;		shapes: classes;		normalize: #numberOfMethods.	RSTreeLayout on: classes.	b := RSLegend new.	b container: canvas.	b title: 'System complexity view'.	b text: 'Number of lines of code' withFadingRamp: { 0->'black'. 1->'red'}.	b		polymetricWidth: 'number of methods'			height: 'lines of code'			box: 'a Pharo class'.	b legendDo: [ :s |		s			draggable;			border:(RSBorder new				color: Color red;				dashArray: #(4));			scaleBy: 0.5;			padding: 15 ].	b location right middle.	b build.	canvas @ RSCanvasController.	^ canvas! !!RSLegendExamples methodsFor: 'examples'!example11OnDemand	<script: 'self new example11OnDemand open setLabel: ''RSShape withAllSubclasses'''>	| b canvas |	canvas := self canvasExample.	b := RSLegend new.	b container: canvas.	b title: 'System complexity view'.	b text: 'Number of lines of code' withFadingRamp: { 0->'black'. 1->'red'}.	b		polymetricWidth: 'Number of attributes'			height: 'Number of methods'			box: 'a Roassal class'.	b legendDo: [ :s |		s			draggable;			border:(RSBorder new				color: Color red;				dashArray: #(4));			scaleBy: 0.75;			padding: 15 ].	b location right middle.	b onDemand: 'Legend'; build.	canvas @ RSCanvasController.	^ canvas! !!RSLegendExamples methodsFor: 'examples'!example12OnPopup	<script: 'self new example12OnPopup open'>	| canvas shapes interaction popup |	canvas := RSCanvas new.	shapes := GoferOperation withAllSubclasses collect: [ :cls |		| boxes |		boxes := RSBox models: cls methods forEach: [:box :met |			box size: met linesOfCode*0.5+2; color: Color lightGray			].		RSGridLayout on: boxes.		(boxes asShapeFor: cls)			color: Color white;			withBorder;			padding: 5.		] as: RSGroup.	RSLineBuilder orthoVertical		withVerticalAttachPoint;		canvas: canvas;		shapes: shapes;		connectFrom: #superclass.	interaction := RSLabeled new.	interaction shapeBuilder labelShape fontSize: 5.	popup := RSPopup new.	popup shapeBuilder: [ :cls |"move this content to a class method"		| composite lb colors |		composite := RSComposite new.		colors := NSScale category20c.		lb := RSLegend new.		lb container: composite.		lb title: cls name.		cls methods			do: [ :met | lb text: met selector withCircleColor: (colors scale: met selector) ].		lb build.		composite adjustToChildren.		composite			color: Color white;			withBorder;			padding: 5;			yourself.		 ].	shapes @ interaction; @ popup; @ RSDraggable.	RSTreeLayout on: shapes.	canvas addAll: shapes.	canvas @ RSCanvasController.	^ canvas! !!RSLegendExamples methodsFor: 'examples'!example13LinesOfCode	<script: 'self new example13LinesOfCode open'>	| canvas |	canvas := self canvasExample.	RSLegend new		container: canvas;		boxWidthText: 'Instance variables';		boxHeightText: 'Number of methods';		legendDo: [ :s |			s				color: (Color white alpha: 0.85);				border:(RSBorder new					color: Color gray;					dashArray: #(1));				scaleBy: 1.5;				padding: 10 ];		beFixedWithTitle: 'Legend';		build.	canvas @ RSCanvasController simple.	^ canvas! !"Roassal3-Legend-Examples"!!RSBarChartExample commentStamp: '' prior: 0!I have examples of barcharts!!RSBoxPlotExample commentStamp: '' prior: 0!Example plots making use of RSBoxPlot.!!RSChartExample commentStamp: '' prior: 0!I have basic examples for RSChart and some of their decorators!!RSHistogramExample commentStamp: '' prior: 0!Examples of RSHistogramPlot!!RSKiviatExample commentStamp: '' prior: 0!examples from RSKiviat!!RSTimelineExample commentStamp: '' prior: 0!Examples related to timeline!!RSBarChartExample methodsFor: 'examples'!example01TwoBars	<script: 'self new example01TwoBars open'>	| c p p2 x y size |	x := 0.0 to: 2 count: 10.	y := (x raisedTo: 2) - 2.	c := RSChart new.	p := RSBarPlot new x: x y: y.	size := 6.	p barSize: size.	p barOffset: size / 2.	p2 := RSBarPlot new x: x y: y + 0.5.	p2 barSize: size.	p2 barOffset: size / -2.	c addPlot: p.	c addPlot: p2.	c horizontalTick doNotUseNiceLabel;			 numberOfTicks: x size - 1;			 asFloat: 5;			 useVerticalLabel.	c build.	p bars @ RSPopup.	p2 bars		when: RSMouseEnter		do: [ :evt |			| color |			color := Color random.			p2 bars do: [ :shape | shape color: color ].			evt signalUpdate ]		for: self.	^ c canvas! !!RSBarChartExample methodsFor: 'examples'!example02TwoHorizontalBars	<script: 'self new example02TwoHorizontalBars open'>	| c p p2 x y size lb |	x := 0.0 to: 2 count: 10.	y := (x raisedTo: 2) - 2.	c := RSChart new.	p := RSHorizontalBarPlot new x: y y: x.	size := 5.	p barSize: size.	p barOffset: size / 2.	p2 := RSHorizontalBarPlot new x: y +0.5 y: x.	p2 barSize: size.	p2 barOffset: size / -2.	c addPlot: p.	c addPlot: p2.	c build.	p bars , p2 bars @ RSPopup.	lb := RSLegend new.	lb container: c canvas.	lb text: 'Series1' withBoxColor: p computeColor.	lb text: 'Series2' withBoxColor: p2 computeColor.	lb legendDo: [ :shape | shape withBorder; padding: 10; scaleBy: 0.5 ].	lb location		inner; bottom; right; offset: -10.	lb build.	^ c canvas! !!RSBarChartExample methodsFor: 'examples'!example03TilePaint	<script: 'self new example03TilePaint open'>	| data x paintBlock c lb size labels |	data := {		{  10. 9 }.		{ 20. 15 }.		{ 11. 7 }.		{ 30. 25 } }.	x := 1 to: 2.	paintBlock := [ :aColor |		| tileCanvas e morph paint |		tileCanvas := RSCanvas new.		e := 10@10.		tileCanvas add: (RSBox new color: aColor; extent: e; yourself).		tileCanvas add: (RSEllipse new			color: Color black;			extent: e / 4;			position: e / 4;			yourself).		tileCanvas add: (RSEllipse new			color: Color black;			extent: e / 4;			position: e / -4;			yourself).		morph := tileCanvas createMorph.		morph extent: e*(1@0.75).		morph drawOnMockCanvas.		paint := AthensCairoPatternSurfacePaint createForSurface: morph surface.		paint repeat.		paint ].	c := RSChart new.	c extent: 300@ 200.	lb := RSLegend new.	lb container: c canvas.	size := 25.	lb title: 'Nerd?'.	lb text: 'Not nerd' withBoxColor: Color gray.	lb text: 'Nerd' withBoxColor: (paintBlock value: Color gray).	lb text: ' '.	labels := #('<5' '5-10' '10-20' '>20').	lb title: 'Study Time'.	data doWithIndex: [ :serie :index |		| plot color |		c addPlot: (plot := RSBarPlot new x: x y: serie).		color := plot computeColor.		index even			ifTrue: [ plot color: (paintBlock value: color) ].		plot barSize: size .		plot barOffset: ((index-(data size +1/ 2)) * size).		lb text: (labels at: index) withBoxColor: color.		].	c horizontalTick fromNames: #(Math Science); labelRotation: 0.	c verticalTick numberOfTicks: 5.	c ylabel: 'Number of students'.	c xlabel: 'Class'.	c build.	lb legendDo: [ :shape | shape scaleBy: 0.6 ].	lb location right; middle; offset: 10@0.	lb build.	^ c canvas! !!RSBarChartExample methodsFor: 'examples'!example04VerticalStack	<script: 'self new example04VerticalStack open'>	| c menMeans womenMeans lb |	c := RSChart new.	c extent: 300@200.	menMeans := #(20 35 30 35 27).	womenMeans := #(25 32 34 20 25).	c barHeights: menMeans.	(c barHeights: womenMeans)		bottom: menMeans.	c horizontalTick fromNames: #(Day1 Day2 Day3 Day4 Day5).	c verticalTick integer.	c ylabel: 'Scores'.	c title: 'Scores by group of gender'.	c build.	lb := RSLegend new.	lb layout horizontal.	#(Men Women) doWithIndex: [ :lbl :index |		lb text: lbl withBoxColor: (c plots at:index) computeColor ].	lb container: c canvas.	lb build.	^ c canvas! !!RSBarChartExample methodsFor: 'examples'!example05HorizontalStack	<script: 'self new example05HorizontalStack open'>	| c menMeans womenMeans lb |	c := RSChart new.	c extent: 300@200.	menMeans := #(20 35 30 35 27).	womenMeans := #(25 32 34 20 25).	c barWidths: menMeans.	(c barWidths: womenMeans)		left: menMeans.	c horizontalTick integer.	c verticalTick fromNames: #(Day1 Day2 Day3 Day4 Day5).	c xlabel: 'Scores'.	c title: 'Scores by group of gender'.	c build.	lb := RSLegend new.	lb layout horizontal.	#(Men Women) doWithIndex: [ :lbl :index |		lb text: lbl withBoxColor: (c plots at:index) computeColor ].	lb container: c canvas.	lb build.	^ c canvas! !!RSBarChartExample methodsFor: 'examples'!example06BarAnimation	<script: 'self new example06BarAnimation open'>	| canvas bars |	canvas := self example01TwoBars.	bars := canvas shapes select: [ :shape | shape class = RSBox ].	bars allButFirst doWithIndex: [ :shape :index |		| rectangle from to |		rectangle := shape encompassingRectangle.		shape height: 0.		shape model > 0 ifTrue: [			from := rectangle corner y.			to := rectangle origin y ]		ifFalse: [			to := rectangle corner y.			from := rectangle origin y			].		canvas newAnimation			easing: RSEasingInterpolator circleOut;			delay: (index * 200) milliSeconds;			duration: 1 second;			from: from;			to: to;			onStepDo: [ :t |				shape fromRectangle:					(shape model > 0						ifTrue: [ rectangle origin x @ t corner: rectangle corner ]						ifFalse: [ rectangle origin corner: rectangle corner x @ t ]). ].		 ].	^ canvas! !!RSBarChartExample methodsFor: 'examples'!example07DoubleBar	<script: 'self new example07DoubleBar open'>	| c classes x1 x2 y plot title |	c := RSChart new.	classes := RSShape withAllSubclasses asOrderedCollection sorted: [		           :a		           :b | a name < b name ].	x1 := classes collect: #numberOfMethods.	x2 := classes collect: #numberOfVariables.	y := 1 to: classes size.	c addPlot: (plot := RSDoubleBarPlot new			         x1: x1 x2: x2 y: y;			         yourself).	c horizontalTick numberOfTicks: 10.	c addDecoration: (RSHorizontalTopTick new			 values: x2;			 numberOfTicks: 10).	c xlabel: 'Number Of Methods'.	c xlabelTop: 'Number Of Variables'.	c verticalTick fromNames: (classes collect: #name).	c addDecoration: (RSVerticalRightTick new			 values: (1 to: classes size);			 numberOfTicks: 10;			 fromNames: (classes collect: #linesOfCode)).	c ylabel: 'Classes'.	c ylabelRight: 'Number of lines Of code'.	title := c title: 'RSShape withAllSubclasses'.	title shape		bold;		noPaint;		withBorder.	c build.	plot bars , plot bars2 @ RSPopup.	title label		addInteraction: (RSPopup text: 'Click to inspect');		when: RSMouseClick do: [ :evt | classes inspect ] for: self.	^ c canvas! !!RSBoxPlotExample methodsFor: 'examples'!example01	"A simple boxplot"	<script: 'self new example01 open'>	| c p y |	y := { { 1. 2. 3. 4. 5. } .			 { 5. 6. 7. 5. 10. }  .			 { 12. 12. 13. 14. 15. 24. }  }.	c := RSChart new.	p := RSBoxPlot new y: y.	c addPlot: p.	c horizontalTick numberOfTicks: y size.	c xlabel: 'X Axis'.	c verticalTick numberOfTicks: 10;		asFloat.	c ylabel: 'Y Axis'.	c title: 'Box Plot'.	^ c! !!RSBoxPlotExample methodsFor: 'examples'!example02	"This is a grouped boxplot, comparing different datasets with the same x axis"	<script: 'self new example02 open'>	| c p p2 p3 y y2 y3 size x |	x := { 'Day1'. 'Day2'. 'Day3' }.	y := { { 1. 2. 3. 4. 5. } .			 { 5. 6. 7. 5. 10. }  .			 { 12. 12. 13. 14. 15. 24. }  }.	y2 := { { 1. 2. 2. 2. 3. 4. 3. 5. 12. } .			 { 1. 12. 7. 10. 11. 11. 15. 10. }  .			 { 12. 12. 13. 15. 18. 20. 21. 24. }  }.	y3 := { { 1. 2. 3. 3. 3. 5. 3. 5. 5. 7. 8. 5. 6. 10. 11. } .			 { 12. 7. 10. 11. 11. 13. 10. 11. 12. 11. 15. 16. }  .			 { 12. 12. 13. 15. 18. 20. 21. 24. 25. 24. 25. 26. 24. 23. 23. 25. 25. }  }.	c := RSChart new.	p := RSBoxPlot new y: y.	"size controls the width of the bars"	size := 12.	p barSize: size.	p barOffset: size * -1.	p2 := RSBoxPlot new y: y2.	p2 barSize: size.	p2 barOffset: 0.	p3 := RSBoxPlot new y: y3.	p3 barSize: size.	p3 barOffset: size.	c addPlot: p.	c addPlot: p2.	c addPlot: p3.	c horizontalTick fromNames: x.	c verticalTick integer.	^ c! !!RSChartExample methodsFor: 'examples'!example01Markers	<script: 'self new example01Markers open'>	| x c p |	x := -3.14 to: 3.14 by: 0.01.	c := RSChart new.	p := RSLinePlot new.	p x: x y: x sin * 0.22 + 0.5.	c addPlot: p.	c verticalTick asFloat.	c addDecoration: RSYMarkerDecoration new average.	c addDecoration: RSYMarkerDecoration new min.	c addDecoration: RSYMarkerDecoration new max.	c addDecoration: RSXMarkerDecoration new max.	c addDecoration: RSXMarkerDecoration new min.	c addDecoration: (RSXMarkerDecoration new value: 0).	^ c! !!RSChartExample methodsFor: 'examples'!example02ScatterPlot	<script: 'self new example02ScatterPlot show'>	| classes c p |	classes := Collection withAllSubclasses.	c := RSChart new.	p := RSScatterPlot new x: (classes collect: #numberOfMethods) y: (classes collect: #linesOfCode).	c addPlot: p.	c xlabel: 'X Axis'.	c ylabel: 'Y Axis'.	c title: 'Hello World'.	^ c! !!RSChartExample methodsFor: 'examples'!example03Plot	<script: 'self new example03Plot show'>	| plt p x |	x := 0.0 to: 2 count: 100.	plt := RSChart new.	p := RSLinePlot new x: x y: (x raisedTo: 2).	plt addPlot: p.	p := RSLinePlot new x: x y: (x raisedTo: 3).	plt addPlot: p.	p := RSLinePlot new x: x y: (x raisedTo: 4).	plt addPlot: p.	plt xlabel: 'X Axis'.	plt ylabel: 'Y Axis'.	plt title: 'Hello World'.	^ plt! !!RSChartExample methodsFor: 'examples'!example04WithTick	<script: 'self new example04WithTick show'>	| x chart |	x := -10.0 to: 20.0 count: 100.	chart := RSChart new		addPlot: (RSScatterPlot new x: x y: (x raisedTo: 3));		addPlot: (RSLinePlot new x: x y: (x raisedTo: 2));		yourself.	chart horizontalTick integer.	chart verticalTick integer.	^ chart! !!RSChartExample methodsFor: 'examples'!example05WithTick	<script: 'self new example05WithTick show'>	| x c |	x := 0.0 to: 14 count: 100.	c := RSChart new.	1 to: 7 do: [ :i |		c addPlot: (RSLinePlot new x: x y: (i * 0.3 + x) sin * (7 - i))	].	c verticalTick integer.	c horizontalTick integer.	^ c! !!RSChartExample methodsFor: 'examples'!example06CustomNumberOfTicks	<script: 'self new example06CustomNumberOfTicks show'>	| x chart |	x := -10.0 to: 20.0 count: 100.	chart := RSChart new		addPlot: (RSScatterPlot new x: x y: (x raisedTo: 3));		addPlot: (RSLinePlot new x: x y: (x raisedTo: 2));		yourself.	chart horizontalTick numberOfTicks: 20;			integer.	chart verticalTick integer			numberOfTicks: 2;			doNotUseNiceLabel.	^ chart! !!RSChartExample methodsFor: 'examples'!example07AdjustingFontSize	<script: 'self new example07AdjustingFontSize open'>	| x y c |	x := -3.14 to: 3.14 by: 0.1.	y := x sin.	c := RSChart new.	c addPlot: (RSLinePlot new x: x y: y).	c addDecoration: (RSChartTitleDecoration new			 title: 'hello';			 fontSize: 40).	c addDecoration: (RSXLabelDecoration new			 title: 'My X Axis';			 fontSize: 12).	c addDecoration: (RSYLabelDecoration new			 title: 'My Y Axis';			 fontSize: 15;			 horizontal).	^ c! !!RSChartExample methodsFor: 'examples'!example08TwoCharts	<script: 'self new example08TwoCharts open'>	| c c1 c2 |	c := RSCanvas new.	c1 := RSChart new.	c1 addPlot: (RSLinePlot new x: (1 to: 10) y: (1 to: 10) sqrt).	c1 title: 'squared root'.	c1 xlabel: 'X'.	c1 ylabel: 'Y'.	c2 := RSChart new.	c2 addPlot: (RSLinePlot new x: (1 to: 10) y: (1 to: 10) squared).	c2 title: '^ 2'.	c2 xlabel: 'X'.	c2 ylabel: 'Y'.	c add: c1 asShape; add: c2 asShape.	RSHorizontalLineLayout on: c shapes.	c @ RSCanvasController.	^ c! !!RSChartExample methodsFor: 'examples'!example09LinearSqrtSymlog	<script: 'self new example09LinearSqrtSymlog open'>	| c x y |	c := RSCanvas new @ RSCanvasController.	x := (-5 to: 500 by: 0.1).	y := x.	c addAll: (#(yLinear ySqrt yLog) collect: [ :sel |		| chart |		chart := RSChart new.		chart addPlot: (RSLinePlot new x: x y: y).		chart verticalTick asFloat.		chart removeHorizontalTicks.		chart perform: sel.		chart title: sel.		chart asShape ]).	RSHorizontalLineLayout on: c shapes.	^ c! !!RSChartExample methodsFor: 'examples'!example10BarPlot	<script: 'self new example10BarPlot open'>	| c p x y |	x := 0.0 to: 2 count: 10.	y := (x raisedTo: 2) - 2.	c := RSChart new.	p := RSBarPlot new x: x y: y.	c addPlot: p.	c horizontalTick doNotUseNiceLabel;		numberOfTicks: x size - 1;		asFloat.	c xlabel: 'X Axis'.	c verticalTick numberOfTicks: 10;		asFloat.	c ylabel: 'Y Axis'.	c title: 'Histogram'.	^ c! !!RSChartExample methodsFor: 'examples'!example11BarplotCombinedWithLine	<script: 'self new example11BarplotCombinedWithLine open'>	| c x y |	x := 0.0 to: 2 count: 10.	y := (x raisedTo: 2) - 2.	c := RSChart new.	c addPlot: (RSBarPlot new x: x y: y).	c addPlot: (RSLinePlot new x: x y: y; color: Color red).	c horizontalTick asFloat.	c verticalTick numberOfTicks: 10;		asFloat.	c xlabel: 'X Axis'.	c ylabel: 'Y Axis'.	c title: 'Bar char'.	^ c! !!RSChartExample methodsFor: 'examples'!example12ScatterPlotAndNormalizer	<script: 'self new example12ScatterPlotAndNormalizer open'>	| x y z r c p |	x := OrderedCollection new.	y := OrderedCollection new.	z := OrderedCollection new.	r := Random seed: 42.	1 to: 100 do: [ :i |		x add: i + (r next * 10 + 1) asInteger.		y add: i + (r next * 10 + 1) asInteger.		z add: i + (r next * 10 + 1) asInteger. ].	c := RSChart new.	p := RSScatterPlot new x: x y: y.	p color: Color blue translucent.	c addPlot: p.	c horizontalTick doNotUseNiceLabel asFloat: 3.	c build.	p ellipses models: z.		RSNormalizer size			shapes: p ellipses;			from: 2;			to: 10;			normalize: #yourself.		RSNormalizer color			shapes: p ellipses;			normalize: #yourself.	p ellipses translucent.	^ c canvas! !!RSChartExample methodsFor: 'examples'!example19PositiveNetagiveBarPlots	<script: 'self new example19PositiveNetagiveBarPlots open'>	| c d d2 |	c := RSChart new.	d := RSBarPlot new.	d color: Color green darker darker darker translucent.	d y: #(4 10 5 9).	c addPlot: d.	d2 := RSBarPlot new.	d2 color: Color red darker darker darker translucent.	d2 y: #(-5 -6 -3 -3).	c addPlot: d2.	c verticalTick integer.	c addDecoration: (RSYLabelDecoration new title: 'Difference'; rotationAngle: -90; offset: -25 @ 0).	c addDecoration: (RSXLabelDecoration new title: 'Evolution').	^ c! !!RSChartExample methodsFor: 'examples'!example20Grid	<script: 'self new example20Grid open'>	| c x y vertical horizontal |	c := RSChart new.	x := 0 to: 10.	y := x raisedTo: 2.	c lineX: x y: y.	vertical := c verticalTick.	vertical shape dashed.	vertical configuration tickSize: c extent x negated.	horizontal := c horizontalTick.	horizontal configuration tickSize: c extent y negated.	c build.	^ c canvas! !!RSChartExample methodsFor: 'examples'!example21Popup	<script: 'self new example21Popup open'>	| x cumsum c  y error popup |	x := 1 to: 100.	cumsum := [:arr | | sum |		sum := 0.		arr collect: [ :v | sum := sum + v. sum ] ].	c := RSChart new.	c extent: 800@400.	popup := RSPopupDecoration new.	c addDecoration: popup.	#(	series1 red	series2 blue) pairsDo: [ :label :color |		| col plot |		y := (x collect: [ :i | 50 atRandom - 25 ]).		y := cumsum value: y.		error := x.		col := color value: Color.		c addPlot: (RSAreaPlot new			x: x y1: y + error y2: y - error;			color: col translucent).		c addPlot: (plot := RSLinePlot new x: x y: y; format: 'o';			color: col;			yourself).		popup chartPopupBuilder			for: plot text: label color: col.		 ].	c build.	^ c canvas! !!RSChartExample methodsFor: 'examples'!example22CustomPopup	<script: 'self new example22CustomPopup open'>	| values names x y popup c value date group |	values := {	'25-nov-2020' -> 772.83.	'24-nov-2020' -> 765.96.	'23-nov-2020' -> 761.55.	'20-nov-2020' -> 758.62.	'19-nov-2020' -> 758.10.	'18-nov-2020' -> 767.05.	'17-nov-2020' -> 767.86.	'16-nov-2020' -> 766.70.	'13-nov-2020' -> 757.43.	'12-nov-2020' -> 757.42.	'11-nov-2020' -> 760.90.	'10-nov-2020' -> 753.75.	'09-nov-2020' -> 759.25.	'06-nov-2020' -> 752.01.	'05-nov-2020' -> 757.16.	'04-nov-2020' -> 758.53.	'03-nov-2020' -> 769.17.	'02-nov-2020' -> 771.92.	'30-oct-2020' -> 770.45.	'29-oct-2020' -> 775.56.	'28-oct-2020' -> 772.05.	'27-oct-2020' -> 779.57.	'26-oct-2020' -> 777.72.	'23-oct-2020' -> 781.41.	'22-oct-2020' -> 784.07.	'21-oct-2020' -> 786.66.	'20-oct-2020' -> 788.27.	'19-oct-2020' -> 795.68.	'16-oct-2020' -> 801.91.	'15-oct-2020' -> 798.56.	'14-oct-2020' -> 797.66.	'13-oct-2020' -> 796.05.	'09-oct-2020' -> 797.25.	'08-oct-2020' -> 795.05.	'07-oct-2020' -> 797.35.	 } reversed.	names := values collect: #key.	x := 1 to: values size.	y := values collect: #value.	popup := RSPopupDecoration new.	c := RSChart new.	c extent: 400@ 150.	c addPlot: (RSAreaPlot new		x: x y1: y y2: 750;		color: ((LinearGradientPaint fromArray: {				0 -> Color green translucent.				0.75 -> Color transparent			 })			start: 0@ -100;			stop: 0@100;			yourself)).	(c lineX: x y: y) color: Color gray.	c horizontalTick fromNames: names; useDiagonalLabel.	c addDecoration: popup.	popup chartPopupBuilder: (RSBlockChartPopupBuilder new		rowShapeBlock: [:plot :point |			value := RSLabel new text: point y; bold.			date := RSLabel new text: (names at: point x).			group := { value. date }.			RSHorizontalLineLayout on: group.			group asShape			 ]).	^ c! !!RSChartExample methodsFor: 'examples'!example23PopupInScatterPlot	<script: 'self new example23PopupInScatterPlot open'>	| chart plot data classes  |	chart := RSChart new.	classes := Collection withAllSubclasses.	data := classes collect: [:cls | cls linesOfCode sqrt ].	plot := RSScatterPlot new y: data.	chart addPlot: plot.	chart padding: 10.	chart build.	plot ellipses with: classes do: [ :e :cls | e model: cls ].	plot ellipses @ (RSPopup themeText: [:model |		model name, String cr, 'LOC: ', model linesOfCode asString]).	^ chart! !!RSChartExample methodsFor: 'examples'!example24SpineLine	<script: 'self new example24SpineLine open'>	| x c y spine |	x := -3.14 to: 3.14 by: 0.01.	y := x sin * 0.22 + 0.2.	c := RSChart new.	c extent: 400@300.	c lineX: x y: y.	c spineDecoration: (spine := RSLineSpineDecoration new).	spine shape format: '^'.	c padding: 10.	^ c! !!RSHistogramExample methodsFor: 'examples'!example01RandomValues	<script: 'self new example01RandomValues open'>	| c p values |	values := self randomValues.	c := RSChart new.	p := RSLinePlot new x:(1 to: values size) y: values.	c addPlot: p.	c horizontalTick doNotUseNiceLabel.	^ c! !!RSHistogramExample methodsFor: 'examples'!example02Histogram	<script: 'self new example02Histogram open'>	| values c plot |	values := self randomValues.	c := RSChart new.	plot := RSHistogramPlot new x: values.	c addPlot: plot.	c title: 'My Chart'.	^ c! !!RSHistogramExample methodsFor: 'examples'!example03Bins	<script: 'self new example03Bins open'>	| values  canvas shapes |	values := self randomValues.	canvas := RSCanvas new.	shapes := #(3 5 10 20) collect: [ :numberOfBins| | g c plot |		g := RSGroup new.		c := RSChart new.		c container: g.		plot := RSHistogramPlot new x: values; numberOfBins: numberOfBins.		c addPlot: plot.		c title: numberOfBins.		c build.		g asShapeFor: numberOfBins.		 ].	canvas addAll: shapes.	RSGridLayout on: canvas shapes.	canvas @ RSCanvasController.	^ canvas! !!RSHistogramExample methodsFor: 'examples'!example04BinningStrat	<script: 'self new example04BinningStrat open'>	| values  canvas shapes |	"Do we need a binning strat?"	values := self randomValues: 0 scale: 20 size: 1000.	canvas := RSCanvas new.	shapes := {		RSDefaultBinning new.		RSRiceBinning new.		RSSturgesBinning new.	 } collect: [ :strat | | g c plot |		g := RSGroup new.		c := RSChart new.		c container: g.		plot := RSHistogramPlot new x: values; binningStrategy: strat.		c addPlot: plot.		c title: strat class name.		c build.		g asShapeFor: strat.		 ].	canvas addAll: shapes.	RSGridLayout on: canvas shapes.	canvas @ RSCanvasController.	^ canvas! !!RSHistogramExample methodsFor: 'examples'!example05Interactions	<script: 'self new example05Interactions open'>	| c p |	c := self example02Histogram.	c build.	p := c plots last.	p bars @ RSPopup new.	^ c canvas! !!RSHistogramExample methodsFor: 'examples'!example06Animations	<script: 'self new example06Animations open'>	| c p |	c := self example02Histogram.	c build.	p := c plots last.	p bars do: [ :shape |		| zeroPoint originalPoint rect|		rect := shape encompassingRectangle.		originalPoint := rect origin.		zeroPoint := rect origin x @ rect corner y.		shape newAnimation			from: zeroPoint;			to: originalPoint;			easing: RSEasingInterpolator elasticOut;			onStepDo: [ :newPoint |				shape					fromRectangle: (newPoint corner: rect corner);					signalUpdate.			].		 ].	p bars		@ (RSHighlightable new highlightBorder: (RSBorder new color: Color black));		@ (RSPopup text: [:assoc |			"TODO create an object to define the model for each bin"			'From: ', (assoc key key round: 3) asString, String cr,			'To: ', (assoc key value round: 3) asString, String cr,			'Size: ', assoc value asString ]).	^ c canvas! !!RSHistogramExample methodsFor: 'examples'!example07Shortcut	<script: 'self new example07Shortcut open'>	^ self randomValues rsHistogram! !!RSHistogramExample methodsFor: 'examples'!example08Strategies	<script: 'self new example08Strategies open'>	| x y canvas shapes |	"Do we need a binning strat?"	x := 1 to: 100.	canvas := RSCanvas new.	shapes := {		RSDefaultBinning new.		RSRiceBinning new.		RSSturgesBinning new.	 } collect: [ :strat | | g c plot |		g := RSGroup new.		c := RSChart new.		c container: g.		y := x collect: [ :v | strat computeNumberOfBinsFor: (Array new: v) ].		plot := RSLinePlot new x: x y: y.		c addPlot: plot.		c verticalTick doNotUseNiceLabel.		c title: strat class name.		c build.		g asShapeFor: strat.		 ].	canvas addAll: shapes.	RSGridLayout on: canvas shapes.	canvas @ RSCanvasController.	^ canvas! !!RSHistogramExample methodsFor: 'examples'!example09BinsCollection	<script: 'self new example09BinsCollection open'>	| values c plot |	values := self randomValues.	c := RSChart new.	plot := RSHistogramPlot new x: values.	plot bins: #(100 150 155 180 200).	c addPlot: plot.	^ c! !!RSHistogramExample methodsFor: 'examples'!example10Objects	<script: 'self new example10Objects open'>	| values c plot classes tick map |	classes := Collection withAllSubclasses.	values := classes collect: #linesOfCode.	map := Dictionary newFromKeys: classes andValues: values.	c := RSChart new.	c padding: 10@10.	c extent: 300@200.	plot := RSHistogramPlot new x: values.	plot bins: (0 to: 1000 by: 20) , {1000. 2000. 3000 }.	tick := c verticalTick.	tick configuration tickSize: -300.	tick color: Color lightGray.	tick shape width: 0.5.	c add: plot.	c build.	plot bars do: [ :bar | | range classesToShow |		range := bar model key.		classesToShow := classes			select: [ :cls | (map at: cls)				between: range key and: range value ].		bar model: classesToShow.		 ].	plot bars @ (RSPopup text: [:classesToShow |		String streamContents: [ :stream |			classesToShow do: [ :cls |				cls printOn: stream.				stream << ' LOC: '.				(map at: cls) printOn: stream ]			separatedBy: [ stream cr ].			]		]).	^ c canvas! !!RSHistogramExample methodsFor: 'computing'!normal: x mean: mean stdDev: std	^ (-0.5 * Float twoPi log - std log -		 ( ((x - mean) raisedTo: 2) / (2 * std * std))) exp! !!RSHistogramExample methodsFor: 'computing'!randomValues	<script: 'self new randomValues inspect'>	^ self randomValues: 170 scale: 10 size: 250! !!RSHistogramExample methodsFor: 'computing'!randomValues: loc scale: scale size: size	| low upp mean stdDev r |	"TODO generate a new method to creatte random values with normal distribution"	low := 0.	upp := 100.	mean := (low + upp) / 2.	stdDev := (upp - low)/4.	r := Random new.	^ ((1 to: size ) collectWithIndex: [ :i :index |		| val sign rval |		rval := r rsNext:0-mean and: upp + mean.		val := self normal: rval mean: mean stdDev: stdDev.		sign := index < (size / 2) ifTrue: [ -1 ] ifFalse: [ 1 ].		loc +(size * val * sign)		 ]) shuffled! !!RSKiviatExample methodsFor: 'examples'!data	^ {		        #( 'Sulfate' 'Nitrate' 'EC' 'OC1' 'OC2' 'OC3' 'OP' 'CO' 'O3' ).		        {			        'Basecase'.			        {				        { 0.88. 0.01. 0.03. 0.03. 0.00. 0.06. 0.01. 0.00. 0.00 }.				        { 0.07. 0.95. 0.04. 0.05. 0.00. 0.02. 0.01. 0.00. 0.00 }.				        { 0.01. 0.02. 0.85. 0.19. 0.05. 0.10. 0.00. 0.00. 0.00 }.				        { 0.02. 0.01. 0.07. 0.01. 0.21. 0.12. 0.98. 0.00. 0.00 }.				        { 0.01. 0.01. 0.02. 0.71. 0.74. 0.70. 0.00. 0.00. 0.00 } } }.		        {			        'With CO'.			        {				        { 0.88. 0.02. 0.02. 0.02. 0.00. 0.05. 0.00. 0.05. 0.00 }.				        { 0.08. 0.94. 0.04. 0.02. 0.00. 0.01. 0.12. 0.04. 0.00 }.				        { 0.01. 0.01. 0.79. 0.10. 0.00. 0.05. 0.00. 0.31. 0.00 }.				        { 0.00. 0.02. 0.03. 0.38. 0.31. 0.31. 0.00. 0.59. 0.00 }.				        { 0.02. 0.02. 0.11. 0.47. 0.69. 0.58. 0.88. 0.00. 0.00 } } }.		        {			        'With O3'.			        {				        { 0.89. 0.01. 0.07. 0.00. 0.00. 0.05. 0.00. 0.00. 0.03 }.				        { 0.07. 0.95. 0.05. 0.04. 0.00. 0.02. 0.12. 0.00. 0.00 }.				        { 0.01. 0.02. 0.86. 0.27. 0.16. 0.19. 0.00. 0.00. 0.00 }.				        { 0.01. 0.03. 0.00. 0.32. 0.29. 0.27. 0.00. 0.00. 0.95 }.				        { 0.02. 0.00. 0.03. 0.37. 0.56. 0.47. 0.87. 0.00. 0.00 } } }.		        {			        'CO & O3'.			        {				        { 0.87. 0.01. 0.08. 0.00. 0.00. 0.04. 0.00. 0.00. 0.01 }.				        { 0.09. 0.95. 0.02. 0.03. 0.00. 0.01. 0.13. 0.06. 0.00 }.				        { 0.01. 0.02. 0.71. 0.24. 0.13. 0.16. 0.00. 0.50. 0.00 }.				        { 0.01. 0.03. 0.00. 0.28. 0.24. 0.23. 0.00. 0.44. 0.88 }.				        { 0.02. 0.00. 0.18. 0.45. 0.64. 0.55. 0.86. 0.00. 0.16 } } } }! !!RSKiviatExample methodsFor: 'examples'!example01Basic	<script: 'self new example01Basic open'>	| kiviat |	kiviat := RSKiviat new.	kiviat addRow: #(1 5 2 2 3).	kiviat axisNames: #('processing cost' 'mechanical properties' 'chemical stability'           'thermal stability' 'device integration').	^ kiviat! !!RSKiviatExample methodsFor: 'examples'!example02PolygonBackground	<script: 'self new example02PolygonBackground open'>	| kiviat |	kiviat := RSKiviat new.	kiviat addRow: #(1 5 2 2 3).	kiviat axisNames: #('processing cost' 'mechanical properties' 'chemical stability'           'thermal stability' 'device integration').	kiviat usePolygon.	^ kiviat! !!RSKiviatExample methodsFor: 'examples'!example03WithBorder	<script: 'self new example03WithBorder open'>	| kiviat |	kiviat := RSKiviat new.	kiviat addRow: #(1 5 2 2 3).	kiviat axisNames: #('processing cost' 'mechanical properties' 'chemical stability'           'thermal stability' 'device integration').	kiviat usePolygonBorder.	kiviat useDots.	^ kiviat! !!RSKiviatExample methodsFor: 'examples'!example04Restaurant	<script: 'self new example04Restaurant open'>	| kiviat |	kiviat := RSKiviat new.	kiviat		addRow: #(4 4 5 4 3);		addRow: #(5 5 4 5 2);		addRow: #(3 4 5 3 5).	kiviat axisNames: #('Food Quality' 'Food Variety' 'Service Quality' 'Ambience' 'Affordability').	kiviat usePolygonBorder.	kiviat useDots.	kiviat noPolygonFillColor.	^ kiviat! !!RSKiviatExample methodsFor: 'examples'!example05RestaurantAnimation	<script: 'self new example05RestaurantAnimation open'>	| kiviat shapes canvas animatedPolygon animations title |	kiviat := self example04Restaurant.	kiviat usePolygonFillColor.	kiviat noDots.	kiviat build.	shapes := kiviat polygonShapes.	shapes do: #remove.	canvas := kiviat canvas.	canvas add: (animatedPolygon := RSPolygon new withBorder).	canvas add: (title := RSLabel new			          text: 'Restaurant: 1';			          fontSize: 15;			          color: 'black';			          position: 0 @ -250).	animations := shapes collectWithIndex: [ :fromShape :index |		              | k toShape |		              k := index + 1.		              k > shapes size ifTrue: [ k := 1 ].		              toShape := shapes at: k.		              canvas transitionAnimation			              duration: 3 seconds;			              easing: RSEasingInterpolator expIn;			              when: RSAnimationEndEvent			              do: [ :evt | title text: 'Restaurant: ' , k asString ]			              for: self;			              onStepDo: [ :t |				              animatedPolygon					              privatePoints: (fromShape points							               with: toShape points							               collect: [ :p1 :p2 | p1 interpolateTo: p2 at: t ]);					              resetPath;					              color:						              (fromShape color							               interpolateTo: toShape color							               at: t);					              position:						              (fromShape position							               interpolateTo: toShape position							               at: t).				              animatedPolygon border color:					              (fromShape border color						               interpolateTo: toShape border color						               at: t).				              canvas signalUpdate ] ].	(canvas animationFrom: animations) repeat.	^ kiviat canvas! !!RSKiviatExample methodsFor: 'examples'!example06Chemistry	<script: 'self new example06Chemistry open'>	| data axisNames canvas kiviat lb |	data := self data.	axisNames := data first.	data := data allButFirst.	canvas := RSCanvas new.	canvas addAll: (data collect: [ :each | | name |		name := each first.		kiviat := RSKiviat new.		kiviat addRows: each second.		kiviat axisNames: axisNames.		kiviat radius: 100.		kiviat usePolygonBorder.		kiviat asShapeFor: name.		 ]).	canvas nodes @ (RSLabeled new		shapeBuilder: [:model |			RSLabel new				color: 'black';				fontSize: 12;				text: model;				yourself]).	RSGridLayout new gapSize: 20; on: canvas nodes.	lb := RSLegend new.	lb container: canvas.	kiviat values doWithIndex: [ :array :index |		lb text: 'Factor ',index asString withBoxColor: (kiviat palette scale: array).	].	lb legendDo: [ :s | s scaleBy: 0.5; withBorder; padding: 10 ].	lb location inner top.	lb build.	canvas @ RSCanvasController.	^ canvas! !!RSTimelineExample methodsFor: 'examples'!createRandomData	| perlin r |	perlin := NSPerlinNoise3 new octaves: 3.	r := Random new.	r seed: 777.	^ (1 to: 25) collect: [:each | | time n |		time := 0.		n := ((perlin noise: each log and: 0) * 100) asInteger.		n odd ifTrue: [ n := n + 1 ]. "n must be even"		(1 to: n) collect: [ :x | | factor |			factor := r next * 30.			time := time + ((perlin noise: x*0.001 and: each log) * factor) asInteger.			].		]! !!RSTimelineExample methodsFor: 'examples'!example01Gantt	<script: 'self new example01Gantt open'>	| chart data names plot |	data := #(		#(0 5 6 8)		#(0 5 8 10)		#(0 10)		#(5 10)		#(5 8)).	names := #(c1 c2 c3 c4 c5).	chart := RSChart new.	data doWithIndex: [ :line :index |		plot := RSTimeLinePlot new.		plot entries: line at: index.		chart addPlot: plot.	].	chart verticalTick fromNames: names.	chart horizontalTick doNotUseNiceLabel;		numberOfTicks: 5;		useDiagonalLabel;		labelConversion: [ :v | Date year: 2021 day: v ].	chart build.	chart plots doWithIndex: [ :p :index |		p bars @ (RSPopup text: [ :assoc |			(names at: index), String cr, assoc asString ]) ].	^ chart canvas! !!RSTimelineExample methodsFor: 'examples'!example02Labeled	<script: 'self new example02Labeled open'>	| chart data names plot |	data := #(		#(0 5 6 8)		#(0 5 8 10)		#(0 10)		#(5 10)		#(5 8)).	names := #(c1 c2 c3 c4 c5).	chart := RSChart new.	data doWithIndex: [ :line :index |		plot := RSTimeLinePlot new.		plot entries: line at: index.		chart addPlot: plot.	].	chart verticalTick fromNames: names.	chart horizontalTick doNotUseNiceLabel;		numberOfTicks: 5;		useDiagonalLabel;		labelConversion: [ :v | Date year: 2021 day: v ].	chart build.	chart plots doWithIndex: [ :p :index |		p bars			@ (RSPopup text: [ :assoc |				(names at: index), String cr, assoc asString ]);			@ (RSLabeled new				text: [ names at: index ];				lowColor: Color black;				highlightable;				locationDo: [ :loc | loc middle ]) ].	^ chart canvas! !!RSTimelineExample methodsFor: 'examples'!example03ZoomInAxis	<script: 'self new example03ZoomInAxis open'>	| data chart names |	chart := RSChart new.	chart extent: 500@200.	chart padding: 10@0.	data := self createRandomData.	names := (1 to: data  size) collect: [ :each | 'Series ', each asString ].	chart addAll: (data collectWithIndex: [ :line :index |		 RSTimeLinePlot new			entries: line at: index;			yourself ]).	chart verticalTick fromNames: names.	chart horizontalTick doNotUseNiceLabel;		numberOfTicks: 10;		useDiagonalLabel;		labelConversion: [ :day | self printDate: day ].	chart add: RSZoomTickDecoration new.	^ chart! !!RSTimelineExample methodsFor: 'examples'!printDate: day	| label |	"use a method, remeber this is an example"	label := lastDay ifNil: [		Date year: Year current year day: day	] ifNotNil: [ | difference |		difference := day - lastDay.		difference < 0 ifTrue: [			Date year: Year current year day: day		] ifFalse: [			difference < 1 "one day" ifTrue: [				label := DateAndTime year: Year current year day: day.				label asDate asString, ', ', label asTime print24 ]			ifFalse: [ Date year: Year current year day: day ]		]	].	lastDay := day.	^ label! !"Roassal3-Chart-Examples"!!RSPieExamples commentStamp: '' prior: 0!I have examples for RSPieBuilder load the package Roassal3-Pie!!RSPieExamples methodsFor: 'data'!esportPrizepool	"source https://www.esportsearnings.com/games"	| arr data |	arr := {		{'Dota' . 2013 . 2874380}.		{'Dota' . 2014 . 10931105}.		{'Dota' . 2015 . 18429613}.		{'Dota' . 2016 . 20770460}.		{'Dota' . 2017 . 24787916}.		{'SC2' . 2013 . 250000}.		{'SC2' . 2014 . 250000}.		{'SC2' . 2015 . 250000}.		{'SC2' . 2016 . 500000}.		{'SC2' . 2017 . 700000}.		{'LOL' . 2013 . 246575}.		{'LOL' . 2014 . 2130000}.		{'LOL' . 2015 . 2130000}.		{'LOL' . 2016 . 5070000}.		{'LOL' . 2017 . 4946969}}.	data := Dictionary new.	arr do: [ :d |		| list |		list := data at: d first ifAbsentPut: [ OrderedCollection new ].		list add: d second -> d third ].	^ data! !!RSPieExamples methodsFor: 'examples'!example01Basic	<script: 'self new example01Basic open'>	| classes pie |	classes :={Dictionary. OrderedCollection. String. Set. Array}.	pie := RSPie new		objects: classes;		slice: #numberOfMethods;		yourself.	pie build.	pie canvas zoomToFit.	^ pie canvas! !!RSPieExamples methodsFor: 'examples'!example02Emphasize	<script: 'self new example02Emphasize open'>	| classes pie |	classes :={Dictionary. OrderedCollection. String. Set. Array}.	pie := RSPie new		objects: classes;		slice: #numberOfMethods;		yourself.	pie build.	pie shapes		select: [ :s | s model numberOfMethods > 100 ]		thenDo: [ :s | s emphasizeWith: 20 ].	pie canvas zoomToFit.	^ pie canvas! !!RSPieExamples methodsFor: 'examples'!example03BasicColors	<script: 'self new example03BasicColors open'>	| classes pie |	classes :={Dictionary. OrderedCollection. String. Set. Array}.	pie := RSPie new		objects: classes;		slice: #numberOfMethods;		yourself.	pie sliceShape		segmentSpacing: 5;		externalRadius: 120.	pie		sliceColor: NSScale category10;		build.	pie canvas zoomToFit.	^ pie canvas! !!RSPieExamples methodsFor: 'examples'!example04SegmentSpacingAnimation	<script: 'self new example04SegmentSpacingAnimation open'>	| pie |	pie := RSPie new		objects: #(3 3 2 2 5 8 14);		yourself.	pie sliceShape		segmentSpacing: 5;		innerRadius: 50;		externalRadius: 200;		withBorder.	pie		sliceColor: NSScale google20;		build.	pie canvas newAnimation		repeat;		easing: RSEasingInterpolator sinIn;		duration: 5 seconds;		from: 0;		to: 180;		onStepDo: [ :t |			pie canvas nodes do: [ :s | | op |				op := 125 - (t degreesToRadians sin abs * 125).				s segmentSpacing: op. ] ].	pie canvas zoomToFit.	^ pie canvas! !!RSPieExamples methodsFor: 'examples'!example05Smash	<script: 'self new example05Smash open'>	| pie r |	r := Random new.	pie := RSPie new		objects: ((1 to: 10) collect: [:e | r next]) sort;		yourself.	pie sliceShape		border: (RSBorder new width: 1.5);		innerRadius: 0;		externalRadius: 200.	pie		sliceColor: NSScale category10;		build.	pie shapes doWithIndex: [ :shape :index | | a b |		a := shape alphaAngle.		b := shape betaAngle.		pie canvas animationFrom: {			(pie canvas transitionAnimation				duration: 2 seconds;				easing: RSEasingInterpolator bounceOut;				onStepDo: [ :t |					shape						alphaAngle: a * t;						betaAngle: b * t ]).			(pie canvas transitionAnimation				delay: (50 * index) milliSeconds;				duration: 750 milliSecond;				easing: RSEasingInterpolator elasticOut;				from: 0;				to: 120;				on: shape shape set: #innerRadius: ) }. ].	pie canvas zoomToFit.	^ pie canvas! !!RSPieExamples methodsFor: 'examples'!example06SmashHSL	<script: 'self new example06SmashHSL open'>	| pie |	pie := RSPie new		objects: (1 to: 360);		yourself.	pie sliceShape		innerRadius: 0;		externalRadius: 200.	pie		sliceColor: [ :shape |  Color h: shape index s: 1 l: 0.5 ];		build.	pie shapes doWithIndex: [ :shape :index | | a b |		shape			alphaAngle: (a := shape model - 1);			betaAngle: (b := shape model + 1).		pie canvas animationFrom: {			(pie canvas transitionAnimation				duration: 2 seconds;				easing: RSEasingInterpolator bounceOut;				onStepDo: [ :t |					shape						alphaAngle: a * t;						betaAngle: b * t ]).			(pie canvas transitionAnimation				delay: (10 * index) milliSeconds;				duration: 2 seconds;				easing: (RSEasingInterpolator elasticOut period: 0.30; amplitude: 0.8) ;				from: 0;				to: 120;				on: shape shape set: #innerRadius: ) }. ].	pie canvas zoomToFit.	^ pie canvas! !!RSPieExamples methodsFor: 'examples'!example07Dendi	<script: 'self new example07Dendi open'>	| pie r |	r := Random new.	pie := RSPie new		objects: ((1 to: 10) collect: [:e | r next]) sort;		yourself.	pie sliceShape		border: (RSBorder new width: 1.5);		externalRadius: 200.	pie		sliceColor: NSScale category20b;		build.	pie shapes do: [ :shape | | a b |		a := shape alphaAngle.		b := shape betaAngle.		pie canvas animationFrom: {			(pie canvas transitionAnimation				easing: RSEasingInterpolator bounce;				onStepDo: [ :t |					shape						alphaAngle: a * t;						betaAngle: b * t ]).			(pie canvas transitionAnimation				delay: 3 seconds;				easing: RSEasingInterpolator  bounce;				onStepDo: [:t |					shape						alphaAngle: a + ((360 - a) * t);						betaAngle: b + ((360 - b) * t) ] ) }. ].	^ pie canvas! !!RSPieExamples methodsFor: 'examples'!example08CornerRadii	<script: 'self new example08CornerRadii open'>	| pie |	pie := RSPie new		objects: #(1 1 2 3 4 8 14 21);		yourself.	pie sliceShape		border: (RSBorder new width: 1.5);		externalRadius: 220;		innerRadius: 220/3;		cornerRadii: 30.	pie		sliceColor: NSScale category20c;		build.	^ pie canvas! !!RSPieExamples methodsFor: 'examples'!example09TickAnimation	<script: 'self new example09TickAnimation open'>	| pie |	pie := RSPie new.	pie objects: (0 to: 360).	pie sliceShape		externalRadius: 200;		innerRadius: 150.	pie build.	pie shapes do: [ :s | s		alphaAngle: s model;		betaAngle: s model + 2 ].	pie canvas newAnimation		repeat;		from: 0;		to: 500;		easing: RSEasingInterpolator elasticOut;		onStepDo: [ :t |			pie shapes do: [ :s |				s color: (Color h: s model  + t s: 1 l: 0.5) ] ].	^ pie canvas! !!RSPieExamples methodsFor: 'examples'!example10CornerRadiiAnimation	<script: 'self new example10CornerRadiiAnimation open'>	| pie |	pie := RSPie new.	pie objects: #(1 1 2 3 4 8 14 21).	pie sliceShape		segmentSpacing: 1;		border: (RSBorder new width: 1.5; color: Color gray);		externalRadius: 220;		innerRadius: 70.	pie		sliceColor: nil;		build.	pie		sliceColor: NSScale paired12;		build.	pie canvas newAnimation repeat		onStepDo: [ :k |			pie shapes do: [ :shape |				| t |				t := 1 - ((k - 0.5) abs * 2).				shape cornerRadii: (220-70)/2 * t ]			 ].	^ pie canvas! !!RSPieExamples methodsFor: 'examples'!example11OpenningAnimation	<script: 'self new example11OpenningAnimation open'>	| pie bounce inout outin reset colors |	pie := RSPie new.	pie objects: #( 1 1 2 3 4 8 14 21 ) reverse.	pie sliceShape		segmentSpacing: 1;		border: (RSBorder new				 width: 1.5;				 color: Color gray);		externalRadius: 220;		innerRadius: 70.	colors := NSScale category20.	pie		sliceColor: [ :slice | colors scale: slice model ];		build.	reset := [	         pie shapes do: #remove.	         pie build.	         pie canvas signalUpdate ].	bounce := pie canvas transitionAnimation		          from: 0;		          to: 360;		          easing: RSEasingInterpolator bounceOut;		          onStepDo: [ :t |			          pie shapes do: [ :shape |					          | beta |					          beta := shape propertyAt: #beta.					          (t between: shape alphaAngle and: beta) ifTrue: [							          shape betaAngle: t ].					          t >= beta ifTrue: [ shape betaAngle: beta ].					          t < shape alphaAngle ifTrue: [							          shape betaAngle: shape alphaAngle ] ] ].	bounce		when: RSAnimationStartEvent		do: [			pie shapes do: [ :shape |				shape propertyAt: #beta put: shape betaAngle.				shape betaAngle: shape alphaAngle ] ]		for: self.	bounce when: RSAnimationEndEvent do: reset for: self.	inout := pie canvas transitionAnimation		         delay: 1 second;		         easing: RSEasingInterpolator backOut;		         onStepDo: [ :t |			         pie shapes do: [ :shape |					         shape innerRadius: 70 * t.					         shape externalRadius: 220 * t ] ].	inout when: RSAnimationEndEvent do: reset for: self.	outin := pie canvas transitionAnimation		         delay: 1 second;		         easing: RSEasingInterpolator elasticOut;		         onStepDo: [ :t |			         pie shapes do: [ :shape |					         | p a b att |					         att := shape properties.					         p := att at: #position ifAbsentPut: [							              | angle |							              angle := shape alphaAngle + shape betaAngle / 2							                       + 180.							              angle := angle degreesToRadians.							              NSScale linear range: {										              (300 * (angle cos @ angle sin negated)).										              (0 @ 0) } ].					         a := att at: #alpha ifAbsentPut: [							              NSScale linear range: {										              (shape alphaAngle + 180).										              shape alphaAngle } ].					         b := att at: #beta ifAbsentPut: [							              NSScale linear								              from: shape betaAngle + 180;								              to: shape betaAngle;								              yourself ].					         shape position: (p scale: t).					         shape alphaAngle: (a scale: t).					         shape betaAngle: (b scale: t) ] ].	"It is not necessary rebuild all the arc, you can reuse them	but I did not try this animation event, for that reason I use it"	outin when: RSAnimationEndEvent do: reset for: self.	(pie canvas animationFrom: {			 bounce.			 inout.			 outin }) repeat.	^ pie canvas! !!RSPieExamples methodsFor: 'examples'!example12RainbowPie	<script:	'self new example12RainbowPie open setLabel: ''Roassal3 :V'' '>	| pie frame n d update |	n := 48.	d := 100.	frame := 0.	pie := RSPie new		       objects: (1 to: n);		       slice: [ :v | 1 ].	pie sliceShape		innerRadius: 75;		segmentSpacing: 1.	pie		sliceColor: [ :slice |			| f r g b i |			i := slice model.			f := i / n * Float pi * 2.			r := (f + 0) sin * 127 + 128.			g := (f + 2) sin * 127 + 128.			b := (f + 4) sin * 127 + 128.			Color				r: r				g: g				b: b				range: 256 ];		build.	update := [ :tran |	          frame := frame + 1.	          pie shapes do: [ :shape |		          | t |		          t := frame / 50.0.		          shape externalRadius:			          300 + ((t + (shape model / n * Float pi * 4)) sin * d).		          shape arcRadiusAuto ] ].	update value: 0.	pie canvas newAnimation repeat onStepDo: update.	pie canvas		when: RSExtentChangedEvent		do: [ :evt | pie canvas zoomToFit ]		for: self.	^ pie canvas! !!RSPieExamples methodsFor: 'examples'!example13BasicColorNormalize	<script: 'self new example13BasicColorNormalize open'>	| classes pie  |	classes :=RSEvent withAllSubclasses.	pie := RSPie new		objects: classes;		slice: #numberOfMethods;		yourself.	pie sliceShape		segmentSpacing: 1;		innerRadius: 30;		externalRadius: 120.	pie build.	RSNormalizer color		from: Color cyan;		to: Color red;		shapes: pie shapes;		normalize: #numberOfMethods.	pie canvas zoomToFit.	^ pie canvas! !!RSPieExamples methodsFor: 'examples'!example14Pyramid	<script: 'self new example14Pyramid open setLabel: ''Pyramid'''>	| b data |	data := {	{ 0.7. 'Sky'. Color lightBlue }.	{0.2. 'Sunny side of pyramid'. Color yellow darker }.	{ 0.05. 'Shady side of pyramid'. Color yellow muchDarker} }.	b := RSPie new.	b		objects: data;		slice: #first.	b sliceShape externalRadius: 200.	b sliceColor: [:slice | slice model third];		build.	b shapes @ (RSPopup text: #second).	b shapes do: [ :shape | shape shiftAngles: -40 ].	^ b canvas! !!RSPieExamples methodsFor: 'examples'!example15Clockwise	<script: 'self new example15Clockwise open'>	| b r  |	b := RSPie new.	r := Random new.	b objects: ((1 to: 10) collect: [:e | r next]) sort.	b sliceShape externalRadius: 200.	b		sliceColor: NSScale sky8;		build.	b shapes do: [ :shape |		shape			alphaAngle: (b betaAngleFor: shape) negated + 90;			betaAngle: (b alphaAngleFor: shape) negated + 90.		 ].	^ b canvas! !!RSPieExamples methodsFor: 'examples'!example16MyDay	<script: 'self new example16MyDay open'>	| pie data color canvas pieLabel pieTitle |	data := {		{ 'sleep'. 'I dream with my gf 8hrs'. 8 }.		{ 'eat'. 'Sometimes I cook for 4hrs'. 3 }.		{ 'work with smalltalk'. 'with Roassal & Carlone 8hrs'. 8 }.		{ 'draw and play dota'. 'I draw with manga style and play dota in leyend level 4hrs'. 5} }.	color := NSScale ordinal		rangeFrom: { 'ae579c'. 'f28d1b'. 'e21454'. '4cbcec' }.	canvas := RSCanvas new.	pie := RSPie new		container: canvas;		objects: data;		slice: #third.	canvas color: '1a1b3a'.	pie sliceShape		externalRadius: 200;		innerRadius: 140;		segmentSpacing: 1.	pie sliceColor: color.	pieLabel := RSPieLabeledInteraction new.	pieLabel labelShape		fontSize: 16;		fontName: 'Source Code Pro'.	pieLabel		labelColor: color;		labelText: [ :obj | (obj third * 100 / pie totalSum) rounded asString, '%' ];		rotated;		offset: 60.	pieTitle := RSPieTitleInteraction new.	pieTitle labelShape		fontSize: 30;		color: Color white.	pieTitle labelText: 'Milton''s', String cr, 'Day'.	pie build.	pie shapes @ (RSPopup text: [ :obj |		obj first capitalized, '. ', obj third asString, ' hrs' ] ).	pie shapes @ pieLabel.	pie canvas @ pieTitle.	^ canvas! !!RSPieExamples methodsFor: 'examples'!example17PieLabels	<script:	'self new example17PieLabels open setLabel: ''Bolivia population by age'''>	| data pie pieLabel |	"source https://www.indexmundi.com/bolivia/age_structure.html"	data := {		        ('<=14' -> 3547498).		        ('15-24' -> 2168047).		        ('25-54' -> 4174931).		        ('55-64' -> 657007).		        ('>=65' -> 590751) }.	pie := RSPie new		       objects: data;		       slice: #value.	pie sliceShape		externalRadius: 240;		innerRadius: 170;		segmentSpacing: 0.4.	pie sliceColor: NSScale category20.	pieLabel := RSPieLabeledInteraction new.	pieLabel labelShape fontSize: 13.	pieLabel labelText: [ :obj |		obj key , (obj value * 100 / pie totalSum) rounded asString , ' %' ].	pie build.	pie canvas		when: RSExtentChangedEvent		do: [ pie canvas zoomToFit ]		for: self.	pie shapes @ pieLabel.	^ pie canvas! !!RSPieExamples methodsFor: 'examples'!example18ManyPies	<script:	'self new example18ManyPies open setLabel: ''Prizepool in esports :V'''>	| data pie color canvas shapes pieLabel pieTitle |	data := self esportPrizepool.	color := NSScale google20.	pie := RSPie new.	canvas := pie container.	pie sliceShape		externalRadius: 200;		innerRadius: 100;		segmentSpacing: 0.5.	pie sliceColor: [ :shape | color scale: shape index ].	pieLabel := RSPieLabeledInteraction new.	pieLabel		labelText: #key;		rotated.	pieTitle := RSPieTitleInteraction new.	pieTitle labelShape		bold;		fontSize: 20.	shapes := data keys		          collect: [ :key |			          | composite sum |			          composite := RSComposite new.			          pie				          objects: (data at: key);				          slice: #value.			          pie				          container: composite;				          build.			          sum := pie totalSum.			          pie shapes @ (RSPopup text: [ :obj |				           obj value asStringWithCommas , '$, '				           , (obj value * 100 / sum) rounded asString , '%' ]).			          pie shapes @ pieLabel.			          pieTitle labelText: key.			          composite @ pieTitle.			          composite adjustToChildren.			          composite ]		          as: RSGroup.	shapes do: [ :e |		e scaleBy: 0.5 @ 1.		e matrix shy: 0.25 ].	canvas addAll: shapes.	shapes @ RSDraggable new noValidateChildrenEvents.	canvas showEncompassingRectangles.	RSGridLayout on: canvas nodes.	canvas when: RSExtentChangedEvent do: [ canvas zoomToFit ] for: self.	canvas @ RSCanvasController.	^ canvas! !!RSPieExamples methodsFor: 'examples'!example19Buttons	<script: 'self new example19Buttons open setLabel: ''Arc buttons'''>	| canvas shapes pie move |	canvas := RSCanvas new.	shapes := Collection withAllSubclasses collect: [ :cls |		          RSBox new			          size: cls numberOfMethods;			          draggable;			          popup;			          model: cls;			          yourself ].	RSNormalizer color		shapes: shapes;		normalize: #numberOfMethods.	canvas addAll: shapes.	RSGridLayout on: shapes.	canvas camera position: canvas shapes encompassingRectangle center.	canvas		when: RSExtentChangedEvent		do: [			canvas				zoomToFit;				signalUpdate ]		for: self.	canvas @ RSCanvasController.	pie := RSPie new.	pie		container: canvas;		objects: {				(-1 @ 0).				(-1 @ 1).				(0 @ 1).				(1 @ 1).				(1 @ 0).				(1 @ -1).				(0 @ -1).				(-1 @ -1) };		slice: [ :ob | 1 ].	pie sliceShape		innerRadius: 10;		externalRadius: 40;		border: (RSBorder new color: Color lightGray).	pie		sliceColor: ((RadialGradientPaint fromArray: {						  (0 -> 'E5EFF0').						  (0.6 -> 'D9D9D9').						  (1 -> 'A0ABAD') })				 center: 0 asPoint;				 focalPoint: 0 asPoint;				 radius: 40);		build.	move := 0 @ 0.	pie canvas newAnimation		repeat;		onStepDo: [ :t | canvas camera translateBy: move ].	pie shapes do: [ :shape |		shape			position: 50 asPoint;			shiftAngles: 45 / -2;			setAsFixed;			when: RSMouseEnter do: [				move := shape model.				canvas newAnimation					duration: 1 second;					easing: RSEasingInterpolator backOut;					from: 40;					to: 50;					on: shape shape set: #externalRadius: ]			for: self;			when: RSMouseLeave do: [				move := 0 @ 0.				canvas newAnimation					duration: 1 second;					easing: RSEasingInterpolator backOut;					from: 50;					to: 40;					on: shape shape set: #externalRadius: ]			for: self ].	^ canvas! !!RSPieExamples methodsFor: 'examples'!example20AddingRemoving	<script:	'self new example20AddingRemoving open setLabel: ''Click in arcs or labels'''>	| pie objects canvas color shapes updatePie labels removed updateLabel update pieClick |	objects := String withAllSubclasses.	removed := OrderedCollection new.	pie := RSPie new.	canvas := pie canvas.	pie		objects: objects;		slice: #linesOfCode.	color := NSScale category10.	labels := RSGroup new.	shapes := nil.	updatePie := nil.	updateLabel := nil.	update := nil.	canvas addShape: (RSBox new			 extent: 100 @ 200;			 noPaint;			 withBorder;			 position: 300 @ 100;			 yourself).	pie sliceShape		innerRadius: 70;		externalRadius: 220.	pie		sliceColor: [ :slice | color scale: slice model ];		build.	pieClick := [	            pie shapes		            when: RSMouseClick		            do: [ :evt |			            objects remove: evt shape model.			            removed add: evt shape model.			            update value ]		            for: self ].	pieClick value.	updatePie := [	             shapes := pie shapes.	             shapes do: #remove.	             pie		             slice: #linesOfCode;		             build.	             pieClick value.	             pie shapes do: [ :shape |		             | x y |		             x := shape alphaAngle.		             y := shape betaAngle.		             shapes			             detect: [ :e1 | e1 model = shape model ]			             ifFound: [ :e1 |				             canvas newAnimation					             easing: RSEasingInterpolator quad;					             onStepDo: [ :t |						             shape							             alphaAngle: (e1 alphaAngle interpolateTo: x at: t);							             betaAngle: (e1 betaAngle interpolateTo: y at: t);							             signalUpdate ] ] ].	             pie shapes size > shapes size ifTrue: [		             | shape x |		             shape := pie shapes last.		             x := shape alphaAngle.		             canvas newAnimation			             easing: RSEasingInterpolator quad;			             onStepDo: [ :t |				             shape					             alphaAngle: (shape betaAngle interpolateTo: x at: t);					             signalUpdate ] ] ].	updateLabel := [	               labels do: #remove.	               canvas addAll:		               (labels := removed collectWithIndex: [ :m :index |			                          RSLabel new				                          fontName: 'Source Sans Pro';				                          model: m;				                          text: m;				                          position: index * (0 @ 30) + (300 @ 0);				                          when: RSMouseClick do: [ :evt |					                          | model |					                          model := evt shape model.					                          objects add: model.					                          removed remove: model.					                          update value ];				                          yourself ]) ].	update := [	          updatePie value.	          updateLabel value ].	canvas zoomToFit.	canvas when: RSExtentChangedEvent do: [ canvas zoomToFit ] for: self.	^ canvas! !!RSPieExamples methodsFor: 'examples'!example21ProgressLabel	<script: 'self new example21ProgressLabel open setLabel: ''Roassal3 packages by linesOfCode'''>	| data org pie scale |	org := RPackage organizer.	data := (org packageNames		select: [ :s | 'Roassal3*' match: s  ]		thenCollect: [ :s | org packageNamed: s ])		sorted: [:a :b | a linesOfCode < b linesOfCode ].	pie := RSPie new		objects: data;		slice: #linesOfCode.	scale := NSScale eva10.	pie sliceShape		innerRadius: 50;		segmentSpacing: 0.5;		externalRadius: 100.	pie		sliceColor: scale;		build.	RSShowProgressLabelDecorator on: pie.	pie shapes @ (RSPopup text: #name).	pie canvas zoomToFit.	^ pie canvas! !!RSPieExamples methodsFor: 'examples'!example22RotatedAnimation	<script:	'self new example22RotatedAnimation open setLabel: ''Roassal3 packages by #linesOfCode'''>	| data org pie pieLabel animation canvas |	org := RPackage organizer.	data := (org packageNames		         select: [ :s | '*Roassal3*' match: s ]		         thenCollect: [ :s | org packageNamed: s ]) sorted: [ :a :b |		        a linesOfCode < b linesOfCode ].	pie := RSPie new		       objects: data;		       slice: #linesOfCode.	canvas := pie canvas.	animation := nil.	pie sliceColor: NSScale category20b.	pie sliceShape		innerRadius: 70;		segmentSpacing: 0.5;		externalRadius: 220;		when: RSMouseClick do: [ [ animation toggle ] ] for: self.	pieLabel := RSPieLabeledInteraction new.	pieLabel labelText: #name.	pie build.	pie shapes	@ (RSPopup text: [ :obj | obj linesOfCode asString , 'LOC' ]).	pie shapes @ pieLabel.	animation := canvas newAnimation		             from: 0;		             to: 360;		             repeat;		             duration: 15 seconds;		             onStepDo: [ :t |			             pie shapes do: [ :shape |					             | att a b l ext ang |					             att := shape properties.					             a := att at: #a ifAbsentPut: [ shape alphaAngle ].					             b := att at: #b ifAbsentPut: [ shape betaAngle ].					             shape alphaAngle: a + t.					             shape betaAngle: b + t.					             l := shape propertyAt: pieLabel labelKey.					             ang := shape alphaAngle + shape betaAngle / 2 % 360.					             ext := l extent x / 2 @ 0.					             (ang between: 90 and: 270) ifFalse: [							             ext := ext negated ].					             l position: (shape centroid: 80) - ext ] ].	canvas add: (RSLabel new text: pie totalSum asString , ' LOC').	canvas @ RSCanvasController.	^ canvas! !!RSPieExamples methodsFor: 'examples'!example23RotatedAnimation	<script: 'self new example23RotatedAnimation open setLabel: ''Roassal3 packages by size in the file system'''>	<noTest>	| data pie pieLabel animation canvas lines directorySize |	"data := (IceRepository registry detect: [ :each | each includesPackageNamed: 'Roassal3' ] ifNone: [ self error: 'Please add a clone of this project to Iceberg to access to the resources' ]) location directories."	data := './pharo-local/iceberg/ObjectProfile/Roassal3/src' asFileReference		directories.	directorySize := nil.	directorySize := [ :d | | sum |		sum := 0.		d children do: [ :child |			sum := sum + (child isDirectory				ifTrue: [ directorySize value: child ]				ifFalse: [ child size ]) ].		sum ].	data := data sort: [ :a :b |		(directorySize value: a) > (directorySize value: b) ].	pie := RSPie new		objects: data;		slice: [:dir | (directorySize value: dir) sqrt ].	canvas := pie canvas.	animation := nil.	pie sliceShape		innerRadius: 70;		segmentSpacing: 0.5;		externalRadius: 220.	pie		sliceColor: NSScale category20b.	pieLabel := RSPieLabeledInteraction new.	pieLabel labelText: #basename.	pie build.	pie shapes		@ (RSPopup text: [ :obj|			obj basename, String cr,			(directorySize value: obj) humanReadableSIByteSize ]);		@ pieLabel;		when: RSMouseClick do: [ animation toggle ].	lines := pie shapes collect: [:s | RSPolyline new		border: (RSBorder new dashArray: #(3));		yourself ].	canvas addAll: lines.	canvas add: (RSLabel new		text: (directorySize value: data first parent) humanReadableSIByteSize;		yourself).	animation := canvas newAnimation		from: 0; to: 360; repeat; duration: 15 seconds;		onStepDo: [ :t |			pie shapes do: [ :shape | | att a b label ext ang x p1 p2 p3 line |				att := shape properties.				a := att at: #a ifAbsentPut: [ shape alphaAngle ].				b := att at: #b ifAbsentPut: [ shape betaAngle ].				shape alphaAngle: a + t.				shape betaAngle: b + t.				label := shape propertyAt: pieLabel labelKey.				ang := ((shape alphaAngle + shape betaAngle)/2) %360.				ext := label extent x/2 @ 0.				x := -250.				(ang between: 90 and: 270) ifFalse: [					ext := ext negated.					x := x negated ].				p1 := shape centroid: 0.				p2 := shape centroid: 80.				p3 := x @ p2 y.				line := lines at: shape index.				line shape					controlPoints: { p1. p2. p3 }.				label position: p3-ext.			]		].	canvas camera zoomToFit: 270 asPoint.	canvas when: RSExtentChangedEvent do: [		canvas camera			zoomToFit: canvas extent * 0.9			extent: 800@600 ].	^ canvas! !!RSPieExamples methodsFor: 'examples'!example24ManyPies	<script: 'self new example24ManyPies open setLabel: ''Usa population by State'''>	| data labels maxSum radius color canvas pie format |	"data processing"	data := self usaPopulation.	labels := data first.	maxSum := 0.	data := (data allButFirst collect: [ :line | | arr sum |		arr :=  Array new: line size.		sum := 0.		2 to: line size do: [ :n | | v |			v := (line at: n) asNumber.			sum := sum + v.			arr at: n put: v ].		arr at: 1 put: line first -> sum.		maxSum := maxSum max: sum.		arr ]) sorted: [:a :b | a first value > b first value ].	"the visualization"	radius := NSScale sqrt domain: { 0. maxSum }; range: #(0 220).	color := NSScale eva10.	canvas := RSCanvas new.	pie := RSPie new.	pie sliceShape segmentSpacing: 0.5.	pie sliceColor: [ :slice | color scale: slice index ].	format := [ :n |		n < 1000000			ifTrue: [ (n / 1000) asInteger asString,'K' ]			ifFalse: [ (n / 1000000) asInteger asString,'M'  ] ].	canvas addAll: (data collect: [:m | | g x |		g := RSGroup new.		x := radius scale: m first value.		pie sliceShape			innerRadius: x * 0.6;			externalRadius: x.		pie			container: g;			objects: m allButFirst;			slice: #yourself;			build.		pie shapes do: [:s |			s @ (RSPopup text: [ :obj | (labels at: s index+1),': ',obj asString ] )].		g add: (RSLabel new			fontSize: 12;			bold;			position: 0@ -6;			text: m first key;			yourself).		g add: (RSLabel new			fontSize: 11;			position: 0@5;			text: (format value: m first value);			yourself).		RSComposite new			shapes: g;			yourself.		]).	RSFlowLayout on: canvas nodes.	canvas @ RSCanvasController.	^ canvas! !!RSPieExamples methodsFor: 'examples'!example25Massiva	<script: 'self new example25Massiva open'>	| pie canvas triangles icons |	pie := RSPie new.	canvas := pie container.	canvas color: '1E2D72'.	pie objects: #(		announcement github class pharo komitterSqueakSourceRemote		calendar database remove smallFind remote).	pie slice: [:m | 1].	pie sliceShape		innerRadius: 130;		externalRadius: 200;		segmentSpacing: 2.	pie sliceColor: (NSScale ordinal		range: #('ECCD36' '9BCC3E' '218E4D' '365EA6' '64ACDC'			'6058A4' '202056' 'EA2230' 'ED6B2F' 'DC417A')).	pie build.	triangles := pie shapes collect: [ :s |		RSShapeFactory triangle			color: s color;			extent: 25@20;			yourself.		 ].	icons := pie shapes collect: [ :s |		RSBitmap new			form: (self iconNamed: s model);			scaleBy: 2;			yourself].	canvas addAll: triangles.	canvas addAll: icons.	canvas newAnimation		repeat;		duration: 10 seconds;		from: 0;		to: 360;		onStepDo: [ :t |			pie shapes doWithIndex: [ :s :i|				| a b triangle icon |				a := s propertyAt: #a ifAbsentPut: [ s alphaAngle ].				b := s propertyAt: #b ifAbsentPut: [ s betaAngle ].				s					alphaAngle: a +t;					betaAngle: b + t.				triangle := triangles at: i.				a := s middleAngle degreesToRadians.				triangle matrix					loadIdentity;					rotateByRadians: a negated - Float halfPi.				triangle position: (a cos @ a sin negated) * (s innerRadius-8).				icon := icons at: i.				icon position: (s centroid: 0) ] ].	canvas add:(RSPolygon new		noPaint;		border: (RSBorder new width: 5; color: Color white; yourself);		points:			{-80 @ -50.			80@ -50.			80@50.			0@50.			-60@80.			-30@50.			-80@ 50};		position: 0@ 15;		cornerRadii: 20;		yourself).	canvas add: (RSLabel new		text: 'Roassal3';		fontSize: 30;		color: Color white).	^ canvas! !!RSPieExamples methodsFor: 'data'!usaPopulation	| str |	str := 'State,Under 5 Years,5 to 13 Years,14 to 17 Years,18 to 24 Years,25 to 44 Years,45 to 64 Years,65 Years and OverAL,310504,552339,259034,450818,1231572,1215966,641667AK,52083,85640,42153,74257,198724,183159,50277AZ,515910,828669,362642,601943,1804762,1523681,862573AR,202070,343207,157204,264160,754420,727124,407205CA,2704659,4499890,2159981,3853788,10604510,8819342,4114496CO,358280,587154,261701,466194,1464939,1290094,511094CT,211637,403658,196918,325110,916955,968967,478007DE,59319,99496,47414,84464,230183,230528,121688DC,36352,50439,25225,75569,193557,140043,70648FL,1140516,1938695,925060,1607297,4782119,4746856,3187797GA,740521,1250460,557860,919876,2846985,2389018,981024HI,87207,134025,64011,124834,356237,331817,190067ID,121746,201192,89702,147606,406247,375173,182150IL,894368,1558919,725973,1311479,3596343,3239173,1575308IN,443089,780199,361393,605863,1724528,1647881,813839IA,201321,345409,165883,306398,750505,788485,444554KS,202529,342134,155822,293114,728166,713663,366706KY,284601,493536,229927,381394,1179637,1134283,565867LA,310716,542341,254916,471275,1162463,1128771,540314ME,71459,133656,69752,112682,331809,397911,199187MD,371787,651923,316873,543470,1556225,1513754,679565MA,383568,701752,341713,665879,1782449,1751508,871098MI,625526,1179503,585169,974480,2628322,2706100,1304322MN,358471,606802,289371,507289,1416063,1391878,650519MS,220813,371502,174405,305964,764203,730133,371598MO,399450,690476,331543,560463,1569626,1554812,805235MT,61114,106088,53156,95232,236297,278241,137312NE,132092,215265,99638,186657,457177,451756,240847NV,199175,325650,142976,212379,769913,653357,296717NH,75297,144235,73826,119114,345109,388250,169978NJ,557421,1011656,478505,769321,2379649,2335168,1150941NM,148323,241326,112801,203097,517154,501604,260051NY,1208495,2141490,1058031,1999120,5355235,5120254,2607672NC,652823,1097890,492964,883397,2575603,2380685,1139052ND,41896,67358,33794,82629,154913,166615,94276OH,743750,1340492,646135,1081734,3019147,3083815,1570837OK,266547,438926,200562,369916,957085,918688,490637OR,243483,424167,199925,338162,1044056,1036269,503998PA,737462,1345341,679201,1203944,3157759,3414001,1910571RI,60934,111408,56198,114502,277779,282321,147646SC,303024,517803,245400,438147,1193112,1186019,596295SD,58566,94438,45305,82869,196738,210178,116100TN,416334,725948,336312,550612,1719433,1646623,819626TX,2027307,3277946,1420518,2454721,7017731,5656528,2472223UT,268916,413034,167685,329585,772024,538978,246202VT,32635,62538,33757,61679,155419,188593,86649VA,522672,887525,413004,768475,2203286,2033550,940577WA,433119,750274,357782,610378,1850983,1762811,783877WV,105435,189649,91074,157989,470749,514505,285067WI,362277,640286,311849,553914,1487457,1522038,750146WY,38253,60890,29314,53980,137338,147279,65614'.	^ str lines collect: [ :line |  line trimBoth splitOn: ',' ]! !"Roassal3-Pie-Examples"!!RSSunburstExamples commentStamp: '' prior: 0!I have basic examples for sunburst!!RSSunburstExamples methodsFor: 'examples'!example01Basic	<script: 'self new example01Basic open'>	| sb |	sb := RSSunburstBuilder new.	sb explore: Collection using: #subclasses.	sb canvas @ RSCanvasController.	^ sb! !!RSSunburstExamples methodsFor: 'examples'!example02MultipleRoots	<script: 'self new example02MultipleRoots open'>	| sb |	sb := RSSunburstBuilder new.	sb strategy hasCenter: false.	sb sliceShape		withBorder;		segmentSpacing: 1.	sb from: { String. RSEvent. RSShape } using:  #subclasses.	sb canvas @ RSCanvasController.	sb build.	sb shapes @ RSPopup.	^ sb canvas! !!RSSunburstExamples methodsFor: 'examples'!example03ConstantStrategy	<script: 'self new example03ConstantStrategy open'>	| sb |	sb := RSSunburstBuilder new.	sb constantWidthStrategy arcWidth: 25.	sb explore: Collection using:  #subclasses.	sb canvas @ RSCanvasController.	sb build.	sb shapes @ RSPopup.	^ sb canvas! !!RSSunburstExamples methodsFor: 'examples'!example04Edges	<script: 'self new example04Edges open'>	| sb |	sb := RSSunburstBuilder new.	sb explore: Collection using:  #subclasses.	sb canvas @ RSCanvasController.	sb build.	sb shapes @ RSPopup.	RSLineBuilder arrowedLine		color: Color black;		attachPoint: RSSunburstAttachPoint new;		canvas: sb canvas;		connectFrom: #superclass.	^ sb canvas! !!RSSunburstExamples methodsFor: 'examples'!example05BezierEdges	<script: 'self new example05BezierEdges open'>	| sb |	sb := RSSunburstBuilder new.	sb sliceShape		withBorder.	sb sliceColor: [:shape | shape model subclasses isEmpty		ifTrue: [ Color purple ]		ifFalse: [ Color lightGray ] ].	sb explore: Collection using:  #subclasses.	sb build.	sb canvas @ RSCanvasController.	sb shapes @ RSPopup.	RSLineBuilder sunburstBezier		width: 2;		color: Color black;		markerEnd: (RSEllipse new			size: 10;			color: Color white;			withBorder;			yourself);		canvas: sb canvas;		connectFrom: #superclass.	^ sb canvas! !!RSSunburstExamples methodsFor: 'examples'!example06Rotation	<script: 'self new example06Rotation open'>	| sb composite canvas controller |	composite := RSComposite new.	sb := RSSunburstBuilder new.	sb strategy extent: 1000@1000.	sb container: composite.	sb sliceShape withBorder.	sb explore: Collection using: #subclasses.	sb build.	sb shapes @ RSPopup.	RSNormalizer color		from: Color veryLightGray translucent;		to: Color gray;		shapes: (sb shapes reject: #isSLeaf);		normalize: #linesOfCode.	RSNormalizer color		from: (Color colorFrom: '9B366C');		to: (Color colorFrom: '563A63');		shapes: (sb shapes select: #isSLeaf);		normalize: #linesOfCode.	composite adjustToChildren.	RSLineBuilder sunburstBezier		width: 1;		markerEnd:			(RSEllipse new				size: 10;				color: Color black;				yourself);		canvas: composite;		connectFrom: #superclass.	canvas := RSCanvas new.	controller := RSCanvasController new.	(controller interactions at: RSDraggableCanvasInteraction) right.	canvas @ controller.	canvas add: composite.	composite @ RSRotated.	^ canvas! !!RSSunburstExamples methodsFor: 'examples'!example07FadeInteraction	<script: 'self new example07FadeInteraction open'>	| sb interaction label |	sb := RSSunburstBuilder new.	sb sliceShape withBorder.	sb explore: Collection using: #subclasses.	sb build.	sb canvas @ RSCanvasController.	interaction := RSSunburstFadeInteraction new builder: sb.	label := RSLabel new.	label text: 'fooo'.	label isFixed: true.	sb shapes		when: RSMouseEnter do: [ :evt |			| path |			path := (interaction pathFor: evt shape) reverse.			path := String streamContents: [ :s |					        path						        do: [ :node | s << node model asString ]						        separatedBy: [ s << '>>' ] ].			label				text: path;				signalUpdate.			label position: label extent / 2 ]		for: self;		when: RSMouseLeave do: [ :evt | label text: '' ] for: self.	sb shapes @ interaction.	sb canvas add: label.	^ sb canvas! !!RSSunburstExamples methodsFor: 'examples'!example08SunburstExplorer	<script: 'self new example08SunburstExplorer open'>	| sb canvas newData color newAnimation first interpolate label |	canvas := RSCanvas new.	color := NSScale category20c.	newData := nil.	newAnimation := [ :from :to |	                canvas newAnimation		                easing: RSEasingInterpolator bounceOut;		                from: from;		                to: to;		                yourself	                "duration: 500 milliSeconds;" ].	interpolate := [ :oldShape :newShape :target |	               (newAnimation		                value: oldShape alphaAngle		                value: newShape alphaAngle) onStepDo: [ :t |		               target alphaAngle: t.		               canvas signalUpdate ].	               (newAnimation		                value: oldShape betaAngle		                value: newShape betaAngle) onStepDo: [ :t |		               target betaAngle: t ].	               (newAnimation		                value: oldShape innerRadius		                value: newShape innerRadius) onStepDo: [ :t |		               target innerRadius: t ].	               (newAnimation		                value: oldShape externalRadius		                value: newShape externalRadius)		               onStepDo: [ :t |			               target externalRadius: t.			               canvas zoomToFit ];		               yourself ].	sb := RSSunburstBuilder new.	sb		container: canvas;		sliceColor: [ :shape | color scale: shape model category ].	sb sliceShape border: (RSBorder new color: Color black).	canvas addShape: (label := RSLabel new			          text: '';			          isFixed: true;			          yourself).	newData := [ :class |	           | lastShapes newShapes oshape |	           lastShapes := canvas shapes copy.	           sb explore: class using: #subclasses.	           sb build.	           sb shapes @ RSPopup.	           label text: class name.	           newShapes := sb shapes.	           first := newShapes first.	           first		           when: RSMouseClick		           do: [ :evt |			           | cls |			           cls := evt shape model superclass.			           cls = Object ifFalse: [ newData value: cls ] ]		           for: self.	           (newShapes allButFirst reject: #isSLeaf)		           when: RSMouseClick		           do: [ :evt | newData value: evt shape model ]		           for: self.	           newShapes size < lastShapes size		           ifTrue: [			           newShapes do: [ :new |				           | old |				           old := lastShapes shapeFromModel: new model.				           old remove.				           interpolate value: old value: new value: new ].			           oshape := lastShapes shapeFromModel: class.			           lastShapes do: [ :old |				           | new |				           new := RSPieSlice new.				           oshape betaAngle < old betaAngle ifTrue: [					           new						           alphaAngle: 360;						           betaAngle: 360 ].				           old depth = 1 ifTrue: [					           new						           alphaAngle: 0;						           betaAngle: 360 ].				           (interpolate value: old value: new value: old)					           when: RSAnimationLoopEvent					           do: [ old remove ] ] ]		           ifFalse: [			           oshape := lastShapes				                     ifEmpty: [ RSPieSlice new ]				                     ifNotEmpty: [				                     newShapes shapeFromModel:					                     lastShapes first model ].			           newShapes do: [ :new |				           | old |				           old := lastShapes shapeFromModel: new model.				           old ifNil: [					           old := RSPieSlice new.					           oshape betaAngle < new betaAngle						           ifTrue: [							           old								           alphaAngle: 360;								           betaAngle: 360 ]						           ifFalse: [							           old								           alphaAngle: 0;								           betaAngle: 0 ] ].				           new depth = 1 ifTrue: [					           old						           alphaAngle: 0;						           betaAngle: 360 ].				           old remove.				           interpolate value: old value: new value: new ] ] ].	canvas		when: RSExtentChangedEvent		do: [			label position:				canvas extent x / 2 @ (canvas extent y - label height) ]		for: self.	newData value: Collection.	^ canvas! !"Roassal3-Sunburst-Examples"!!RSFlameGraphExamples methodsFor: 'examples'!example01FileSystem	<script: 'self new example01FileSystem open'>	| builder colorPalette |	builder := RSFlameGraph new.	builder boxShape		cornerRadius: 0;		border: (RSBorder new			color: Color black translucent;			width: 0.1;			yourself).	builder		graphWidth: 150;		gap: 0.5 asPoint;		boxHeight: 4;		leafWeight: [ :f | f size sqrt ];		explore: FileSystem workingDirectory			nesting: #directories			leaves: #files.	builder build.	builder shapes @ RSDraggable.	builder shapes @ (RSPopup text: [:f | f basenameWithIndicator, String crlf, f humanReadableSize ]).	colorPalette := NSScale google20.	builder shapes do: [ :box |		box color: (colorPalette scale: box model extension) ].	"Add legend for file extensions"	RSLegend new		title: 'Legend';		text: '- Rectangle: file or directory';		text: '- Width: sqrt of file size';		text: '- Color: file extension';		legendDo: [ :l | l scaleBy: 0.5 ];		container: builder canvas;		build.	^ builder canvas		addInteraction: RSCanvasController new;		yourself! !!RSFlameGraphExamples methodsFor: 'examples'!example02FileSystem	<script: 'self new example02FileSystem inspect'>	| builder |	builder := RSFlameGraph new.	builder boxShape		color: Color veryLightGray;		cornerRadius: 2.	builder		graphWidth: 1000;		leafWeight: [ :f | f size ];		explore: FileSystem workingDirectory			nesting: #directories			leaves: #files.	builder build.	builder shapes		@ RSDraggable;		@ (RSPopup text: [:f | f basenameWithIndicator, String crlf, f humanReadableSize ]);		@ (RSHighlightable new highlightBorder: (RSBorder new color: Color black)).	"Add labels to rectangles, when they fit inside."	builder shapes do: [ :shape |		| location labelBuilder label |		location := RSLocation new middle; inner; left; offset: 5@0; yourself.		labelBuilder := RSMultilineLabelBuilder new			wrapStrategy: (RSWrapEllipsisStrategy new wrapMaxWidth: shape width - 10);			yourself.		labelBuilder labelShape color: Color black.		label := labelBuilder shapeFor: shape model basenameWithIndicator.		location stick: label on: shape.		(label width > 25 and: [ (label width+5) < shape width ]) ifTrue: [			builder canvas addShape: label ] ].	^ builder canvas		addInteraction: RSCanvasController new;		yourself! !"Roassal3-FlameGraph-Examples"!!RSDarkUMLClassRenderer commentStamp: '' prior: 0!I am a demo class!!RSUMLExamples commentStamp: '' prior: 0!I have examples of how to manage the uml builder in different cases!!RSDarkUMLClassRenderer methodsFor: 'initialization'!initialize	super initialize.	darkColor := Color r: 0.130 g: 0.130 b: 0.130.	self		boxColor: darkColor;		textColor: Color white.	self marker shape color: darkColor.	self border		width: 2;		color: Color white! !!RSDarkUMLClassRenderer methodsFor: 'initialization'!methodFor: aMethod	| s |	s := super methodFor: aMethod.	aMethod isOverridden ifTrue: [ s color: Color cyan ].	^ s! !!RSDarkUMLClassRenderer methodsFor: 'initialization'!setUpCanvas: aCanvas	aCanvas color: darkColor! !!RSDarkUMLClassRenderer methodsFor: 'initialization'!titleFor: aClass	| shapes |	shapes := RSGroup with: (super titleFor: aClass).	aClass hasAbstractMethods ifTrue: [		shapes addFirst: (RSLabel new			color: Color magenta;			italic;			text: '<<Abstract>>') ].	self applyLayoutOn: shapes.	^ RSComposite new		shapes: shapes;		yourself! !!RSUMLExamples methodsFor: 'examples'!example01Basic	<script: 'self new example01Basic open'>	| builder |	builder := RSUMLClassBuilder new.	builder classes: RSAttachPoint withAllSubclasses.	builder build.	^ builder canvas! !!RSUMLExamples methodsFor: 'examples'!example02ClassDescriptor	<script: 'self new example02ClassDescriptor open'>	| builder |	builder := RSUMLClassBuilder new.	builder classes: RSAbstractLine withAllSubclasses.	builder modelDescriptor methodsLimit: 5.	builder renderer edgeBuilder		cornerRadii: 20.	builder build.	^ builder canvas! !!RSUMLExamples methodsFor: 'examples'!example03DifferentLines	<script: 'self new example03DifferentLines open'>	| builder marker |	builder := RSUMLClassBuilder new.	builder classes: RSAttachPoint withAllSubclasses.	marker := (RSShapeFactory arrow		extent: 20@25;		noPaint;		withBorder) asMarker offset: -7.	builder renderer edgeBuilder: (RSLineBuilder verticalBezier		width: 2;		dashArray: #(4);		capRound;		attachPoint: (RSVerticalAttachPoint new startOffset: 20);		markerStart: marker).	builder build.	^ builder canvas! !!RSUMLExamples methodsFor: 'examples'!example04Nolines	<script: 'self new example04Nolines open'>	| builder |	builder := RSUMLClassBuilder new.	builder classes: RSAttachPoint withAllSubclasses.	builder layout grid.	builder build.	builder canvas edges copy do: #remove.	^ builder canvas! !!RSUMLExamples methodsFor: 'examples'!example05Horizontal	<script: 'self new example05Horizontal open'>	| builder marker |	builder := RSUMLClassBuilder new.	builder classes: RSAttachPoint withAllSubclasses.	marker := (RSShapeFactory arrow		extent: 20@25;		noPaint;		withBorder) asMarker offset: -7.	builder renderer edgeBuilder: (RSLineBuilder horizontalBezier		width: 2;		dashArray: #(4);		capRound;		attachPoint: (RSHorizontalAttachPoint new startOffset: 20);		markerStart: marker).	builder layout horizontalTree		verticalGap: 50;		horizontalGap: 100.	builder build.	^ builder canvas! !!RSUMLExamples methodsFor: 'examples'!example06CustomText	<script: 'self new example06CustomText open'>	| builder |	builder := RSUMLClassBuilder new.	builder classes: RSAttachPoint withAllSubclasses.	builder renderer: RSDarkUMLClassRenderer new.	builder build.	^ builder canvas! !!RSUMLExamples methodsFor: 'examples'!example07TorchRenderer	<script: 'self new example07TorchRenderer open'>	| builder |	builder := RSUMLClassBuilder new.	builder classes: RSEvent withAllSubclasses.	builder renderer: RSTorchUMLClassRenderer new.	builder build.	^ builder canvas! !!RSUMLExamples methodsFor: 'examples'!example08HierarchyPacker	<script: 'self new example08HierarchyPacker open extent: 900@300'>	| builder classes |	builder := RSUMLClassBuilder new.	classes := { 'Roassal3-Layouts'. 'Roassal3' }		flatCollect: [:pkgname | (RPackage organizer			packageNamed: pkgname) definedClasses ].	builder classes: classes.	builder renderer: RSTorchUMLClassRenderer new.	builder build.	builder canvas @ RSHierarchyPackerInteraction.	^ builder canvas! !!RSUMLExamples methodsFor: 'examples'!example09Package	<script: 'self new example09Package open'>	| builder |	builder := RSUMLPackageBuilder new.	builder packages: { self class package}.	builder build.	^ builder canvas! !!RSUMLExamples methodsFor: 'examples'!example10AggregationComposition	<script: 'self new example10AggregationComposition open'>	| builder |	builder := RSUMLClassBuilder new.	builder classes: #(Band Musician Catalog Product Building Room).	builder modelDescriptor		classname: #yourself;		instVars: #();		methods: #();		superclass: nil;		isAbstract: false;		aggregations: { #Musician -> #Band. #Product -> #Catalog };		compositions: { #Room -> #Building }.	builder renderer layout flow gapSize: 30.	builder build.	^ builder canvas! !"Roassal3-UML-Examples"!!RSSpecMenu commentStamp: '' prior: 0!I all some menus in 'Tools-Roassal3' for these examples!!RSBasicSpecExample commentStamp: '' prior: 0!Basic example of how to use SpRoassalPresenter, use it as a reference of how interact with some spec components!!RSColorPaletteChooser commentStamp: '' prior: 0!Basic color chooser, just click on button next to method run.I present color palettes from `RSColorPalette`. if you click over one palette. The code to use that color palette on your application will be selected.Check this example `RSColorPaletteChooser class >> #example1`!!RSEasel commentStamp: '' prior: 0!I am a basic spec example of how to build a roassal visualization with spec.Use the text editor with some roassal code, then click on draw!! This will be updated on the canvas view.Please check my methods:- `RSEasel class >> #defaultLayout`, where the skeleton of the ui is defined.- `RSEasel >> #initializePresenters`, where where the text editor, and the roassal diagram is defined- `RSEasel >> #connectPresenters`, the main logic of the program, and how to draw and redraw things in roassal!!RSExamplesBrowser commentStamp: '' prior: 0!Utility class to review roassal3 examples!!RSIconBrowser commentStamp: '' prior: 0!Used to explore some icons of pharo echo system.If you want an icon you can use```stself iconNamed: #pharo```But what icons are available? this class present them so you can use them in your projects!!RSPieChartExample commentStamp: '' prior: 0!I am a basic example of roassal with spec!!RSSpecMenu class methodsFor: 'menu'!menu07Examples: aBuilder	<worldMenu>	(aBuilder item: #Roassal3Examples)		parent: #Roassal3;		order: 5;		label: 'Examples';		help: 'Check some examples of roassal with spec';		icon: RSWorldMenu roassalIcon.	(aBuilder item: #Roassal3ExamplesBrowser)		parent: #Roassal3Examples;		order: 1;		label: 'Examples Browser';		help: 'Open a browser to jump between examples';		icon: RSWorldMenu roassalIcon;		action: [ RSExamplesBrowser new open ]! !!RSSpecMenu class methodsFor: 'menu'!menu08PalettesOn: aBuilder	<worldMenu>	(aBuilder item: #Roassal3Palettes)		parent: #Roassal3Examples;		order: 7;		label: 'Color palettes';		help: 'Open a color palette chooser';		icon: (self iconNamed: #paint);		action: [ RSColorPaletteChooser new open ]! !!RSSpecMenu class methodsFor: 'menu'!menu09EaselOn: aBuilder	<worldMenu>	(aBuilder item: #Roassal3Easel)		parent: #Roassal3Examples;		order: 7.1;		label: 'Easel';		help: 'Open a basic window to edit a roassal3 script';		icon: (self iconNamed: #haloPaint);		action: [ RSEasel new open ]! !!RSSpecMenu class methodsFor: 'menu'!menu10IconsOn: aBuilder	<worldMenu>	(aBuilder item: #Roassal3Icons)		parent: #Roassal3Examples;		order: 7.2;		label: 'Icons';		help: 'Visit some icons of the pharo system';		icon: (self iconNamed: #versionControl);		action: [ RSIconBrowser new open ]! !!RSSpecMenu class methodsFor: 'menu'!menu11LayoutStudioOn: aBuilder	<worldMenu>	(aBuilder item: #Roassal3LayoutStudio)		parent: #Roassal3Examples;		order: 7.3;		label: 'Layout Studio';		help: 'Edit some layout properties and check the result';		icon: (self iconNamed: #references);		action: [ RSLayoutStudio new open ]! !!RSBasicSpecExample class methodsFor: 'layout'!defaultLayout	<spec: #default>	^ SpBoxLayout newVertical		add: #roassalSpec;		yourself! !!RSBasicSpecExample methodsFor: 'initialization'!initializePresenters	roassalSpec := self newRoassal.	self initializeRoassal3: roassalSpec canvas! !!RSBasicSpecExample methodsFor: 'initialization'!initializeRoassal3: canvas	| slice magic |	slice := RSPieSlice new.	slice		innerRadius: 100;		externalRadius: 150;		alphaAngle: 15;		betaAngle: 180.	slice when: RSMouseEnter do: [ slice color: Color random; signalUpdate  ].	canvas add: slice.	canvas add: (RSLine new		startPoint: 0@ -200;		endPoint: 0 @ 200;		dashed;		markerStartEnd: (RSShapeFactory arrow			size: 10);		yourself).	canvas add: (RSLine new		startPoint: -200@ 0;		endPoint: 200 @ 0;		dashed;		markerStartEnd: (RSShapeFactory arrow			size: 10);		yourself).	canvas add: (RSLabel new		text: '0@0';		position: 20@10;		yourself).	magic := 160*0.551784.	canvas add: (RSBezier new		width: 3;		dashed;		markerEnd: (RSShapeFactory arrow			size: 20;			color: Color black);		controlPoints:			{160@0.			160@ magic negated.			magic@ -160.			0@ -160  };		yourself		).	canvas add: (RSLabel new		text: 'Angle direction';		color: 'blue';		position: 180@ -130;		yourself)! !!RSBasicSpecExample methodsFor: 'initialization'!initializeWindow: w	w		title: 'Basic plot';		initialExtent: 800@500;		centered! !!RSBasicSpecExample methodsFor: 'running'!run	<script: 'self new asWindow open'>! !!RSColorPaletteChooser class methodsFor: 'layout'!defaultLayout	<spec: #default>	^ SpBoxLayout newVertical		add: #buttons withConstraints: [ :c | c height: self toolbarHeight ];		add: #colors;		yourself! !!RSColorPaletteChooser class methodsFor: 'examples'!example1	| canvas palette |	canvas := RSCanvas new.	"we create some shapes"	canvas addAll: (RSBox models: Collection withAllSubclasses).	"Palette copied from this window, just copy and paste from the palette chooser :D"	palette := RSColorPalette diverging brbg11.	"the palette is used based on each shape super class"	canvas nodes do: [ :each |		each color: (palette rsValue: each model superclass).		 ].	"normalize the class size base on each class lines of code"	RSNormalizer size		shapes: canvas nodes;		normalize: #linesOfCode.	"create some links based on super class"	RSLineBuilder line		withVerticalAttachPoint;		shapes: canvas nodes;		connectFrom: #superclass.	"We use a layout once"	RSTreeLayout on: canvas nodes.	"finally some interactions"	canvas @ RSCanvasController.	canvas nodes @ RSPopup; @ RSDraggable.	canvas open! !!RSColorPaletteChooser methodsFor: 'utilities'!boxColorFor: color	| label box |	box := RSBox new		       extent: 150 @ 30;		       color: color;		       yourself.	label := RSLabel new		         noPaint;		         text: color asHexString;		         yourself.	^ {		  box.		  label } asShape		  @ boxColorHighlight;		  model: color;		  when: RSMouseClick		  do: [ :evt | self copyToClipboard: evt shape model ]		  for: self;		  yourself! !!RSColorPaletteChooser methodsFor: 'utilities'!boxesFor: anArray	^ anArray collect: [ :color | self boxColorFor: color ] as: RSGroup! !!RSColorPaletteChooser methodsFor: 'events'!buttonClick: evt	"first we unhighlight the mouse over highlight"	overHighlight doUnhighlight: evt shape.	"then with mark the selection hightlight"	selectedHighlight doHighlight: evt shape.	self currentPalette: evt shape model.	evt signalUpdate! !!RSColorPaletteChooser methodsFor: 'utilities'!buttonFor: m	| label box |	label := RSLabel new		bold;		text: m key;		color: Color white;		yourself.	box := self polygonFor: m value.	^ { box. label } asShape		model: m key;		when: RSMouseClick send: #buttonClick: to: self;		yourself! !!RSColorPaletteChooser methodsFor: 'utilities'!buttonModels	^ {		('Diverging' -> {			(0 @ 0).			(150 @ 0).			(130 @ 30).			(0 @ 30) }).		('Qualitative' -> {			(20 @ 0).			(150 @ 0).			(130 @ 30).			(0 @ 30) }).		('Sequential' -> {			(20 @ 0).			(150 @ 0).			(150 @ 30).			(0 @ 30) }) }! !!RSColorPaletteChooser methodsFor: 'clipboard handling'!clipTextFor: anObject	| method |	anObject isColor		ifTrue: [ ^ anObject asHexString ].	method := anObject.	^ RSColorPalette name, ' ',  currentPalette, ' ', method selector! !!RSColorPaletteChooser methodsFor: 'initialization'!connectPresenters	self currentPalette: #Diverging.	buttons script: [ :canvas |		self renderButtonsOn: canvas ].	colors script: [ :canvas |		self renderColorPaletteOn: canvas ]! !!RSColorPaletteChooser methodsFor: 'accessing'!controllerInteraction	| controls |	controls := RSCanvasController new.	controls noLegend.	controls removeInteractionIfPresent: RSDraggableCanvasInteraction.	controls addInteraction: RSScrollWheelCanvasInteraction new.	controls zoomToFitInteraction		noZoomToFitOnStart;		noZoomToFitOnExtendChanged.	controls keyNavigationInteraction hasHorizontalScrolling: false.	controls configuration		padding: 0@ 10;		maxScale: 1;		minScale: 1.	^ controls! !!RSColorPaletteChooser methodsFor: 'clipboard handling'!copyToClipboard: object	| name |	Clipboard clipboardText: (self clipTextFor: object).	name := 'Palette'.	object isColor ifTrue: [ name := 'Color' ].	self inform: name,' copied to clipboard !!!!!!'! !!RSColorPaletteChooser methodsFor: 'accessing'!currentPalette: newPaletteSelector	currentPalette := newPaletteSelector asLowercase asSymbol.	colors refresh! !!RSColorPaletteChooser methodsFor: 'initialization'!initializeInteractions	selectedHighlight := RSHighlightable new.	"because it is a composite and the first children is the background"	"when the element is selected"	selectedHighlight highlightShapes: [ :e | {e shapes first} ].	selectedHighlight highlightColor: (		(LinearGradientPaint fromArray:			{0->'white'.			0.25->'blue'.			1 ->'lightGray'})			start: 0@ -15;			stop: 0@ 15).	"when the mouse is over the button"	overHighlight := RSHighlightable new.	overHighlight		highlightShapes: [ :e | {e shapes first} ]		butKeep: selectedHighlight.	overHighlight highlightColor: (		(LinearGradientPaint fromArray:			{0->'white'.			0.25->'black'.			1 ->'lightGray'})			start: 0@ -15;			stop: 0@ 15).	"for color boxes"	boxColorHighlight := RSHighlightable new.	boxColorHighlight highlightShapes: [ :s | { s shapes second } ].	boxColorHighlight highlightColor: Color black! !!RSColorPaletteChooser methodsFor: 'initialization'!initializePresenters	self initializeInteractions.	buttons := self newRoassal.	colors := self newRoassal! !!RSColorPaletteChooser methodsFor: 'initialization'!initializeWindow: aWindow	aWindow		title: 'Color Palettes';		initialExtent: 800@500;		centered! !!RSColorPaletteChooser methodsFor: 'utilities'!paletteFor: method	| shapes scale |	scale :=  method selector value: currentPalette.	shapes := self boxesFor: scale range.	shapes add: (RSLabel new		bold;		text: method selector;		yourself).	RSVerticalLineLayout new		alignCenter;		gapSize: 0;		on: shapes.	^ shapes asShape		model: method;		padding: 10;		withBorder;		when: RSMouseClick			do: [ :evt | self copyToClipboard: evt shape model]! !!RSColorPaletteChooser methodsFor: 'utilities'!paletteFor: palette method: method	| shapes |	shapes := self boxesFor: palette range.	shapes add: (RSLabel new			 bold;			 text: method selector;			 yourself).	RSVerticalLineLayout new		alignCenter;		gapSize: 0;		on: shapes.	^ shapes asShape		  model: method;		  padding: 10;		  withBorder;		  when: RSMouseClick		  do: [ :evt | self copyToClipboard: evt shape model ]		  for: self;		  yourself! !!RSColorPaletteChooser methodsFor: 'accessing'!palettes	| colorPalette |	colorPalette := currentPalette value: RSColorPalette.	^ (colorPalette class methods sorted: CompiledMethod sortBlock)		collect: [ :met | self paletteFor: (met selector value: colorPalette) method: met ]! !!RSColorPaletteChooser methodsFor: 'utilities'!polygonFor: points	^ RSPolygon new		withBorder;		cornerRadii: 5;		paint: ((LinearGradientPaint fromArray: {				(0 -> 'lightGray').				(0.25 -> 'black').				(1 -> 'gray') })			start: 0 @ -15;			stop: 0 @ 15);		points: points;		position: 0@0;		yourself! !!RSColorPaletteChooser methodsFor: 'updating'!relayout: evt	| canvas |	canvas := evt canvas.		RSFlowLayout new		maxWidth: canvas extent;		on: canvas shapes.	canvas camera translateTo: canvas extent / -2 + (20@0)! !!RSColorPaletteChooser methodsFor: 'dependencies'!release	self class instVarNames do: [ :n | self instVarNamed: n put: nil ]! !!RSColorPaletteChooser methodsFor: 'rendering'!renderButtonsOn: canvas	| data buttonShapes |	canvas color: '2d5c7f'.	data := self buttonModels.	buttonShapes := data collect: [ :m | self buttonFor: m ].	RSHorizontalLineLayout new		gapSize: -9;		on: buttonShapes.	canvas addAll: buttonShapes.	selectedHighlight doHighlight: buttonShapes first.	canvas nodes @ overHighlight.	canvas when: RSExtentChangedEvent send: #zoomToFit to: canvas! !!RSColorPaletteChooser methodsFor: 'rendering'!renderColorPaletteOn: canvas	canvas color: 'f8f9fc'.	canvas addAll: self palettes.	canvas when: RSExtentChangedEvent send: #relayout: to: self.	canvas @ self controllerInteraction! !!RSColorPaletteChooser methodsFor: 'running'!run	<script: 'self new asWindow open'>! !!RSEasel class methodsFor: 'layout'!defaultLayout	<spec: #default>	^ SpPanedLayout newHorizontal		  positionOfSlider: 45 percent;		  add: (SpBoxLayout newVertical				   add: #label				   withConstraints: [ :c | c height: self toolbarHeight ];				   add: #text;				   add: #button				   withConstraints: [ :c | c height: self toolbarHeight ]);		  add: #diagram;		  yourself! !!RSEasel class methodsFor: 'specs'!open	<script>	self new open! !!RSEasel methodsFor: 'initialization'!configure: canvas	canvas @ RSCanvasController.	canvas color: self theme backgroundColor! !!RSEasel methodsFor: 'initialization'!connectPresenters	label		label: 'Enter code below. Both view and canvas are accessible'.	text		text: self initialCode;		autoAccept: true.	button		label: 'Draw this!!';		"this will update the canvas view with the current value of the text editor"		action: [ diagram refresh ].	"This is the code for the Roassal view.	The block takes both a view and a canvas."	diagram script: [ :canvas |		self configure: canvas.		self textAsBlockClosure value: canvas ]! !!RSEasel methodsFor: 'initialization'!initialCode	^'"[:canvas |...your code... ]"| box icon label |box := RSBox new	size: 100;	draggable;	yourself.icon := RSBitmap new	form: (self iconNamed: #pharo);	yourself.label := RSLabel new	color: ''black'';	text: ''Kaguya'';	yourself.canvas addAll: {icon. box. label}.RSVerticalLineLayout new	alignCenter;	on: canvas shapes.'! !!RSEasel methodsFor: 'initialization'!initializePresenters	label := self newLabel.	text := self newCode.	button := self newButton.	diagram := self newRoassal! !!RSEasel methodsFor: 'initialization'!initializeWindow: w	w		title: 'Roassal3 Spec';		initialExtent: 800@500! !!RSEasel methodsFor: 'dependencies'!release	self class instVarNames do: [ :n | self instVarNamed: n put: nil ]! !!RSEasel methodsFor: 'running'!run	<script: 'self new asWindow open'>! !!RSEasel methodsFor: 'accessing'!textAsBlockClosure	"This could be made more clever with regard to compilation and runtime errors. But for this simple example it should suffice."	^ self class compiler		source: '[:canvas | ' , text text asString , ']';		logged: false;		evaluate! !!RSExamplesBrowser class methodsFor: 'layout'!defaultLayout	| const |	const := [ :constraints |		constraints expand: false;		width: 20 ].	^ SpBoxLayout newHorizontal		add: #leftButton withConstraints: const;		add: (SpPanedLayout newHorizontal			add: (SpBoxLayout newVertical				add: (SpBoxLayout newHorizontal					add: #classesList;					add: #searchButton withConstraints: [:c | c expand: false; width: 25];					yourself) withConstraints: [:c | c expand: false; height: 25];				add: #codeEditor;				yourself);			add: #roassalCanvas;			yourself);		add: #rightButton withConstraints: const;		yourself! !!RSExamplesBrowser methodsFor: 'events'!classChanged: cls	selectedClass := cls.	examples := self computeExamples.	index := index < 0 ifTrue: [ examples size ] ifFalse: [ 1 ].	self updateCanvas! !!RSExamplesBrowser methodsFor: 'private'!classes	^ (RSAbstractExamples withAllSubclasses select: [ :cls |		cls methods anySatisfy: [ :met | met selector beginsWith: 'example' ] ])	sorted: [ :a :b |		| x y |		x := a new order.		y := b new order.		x = y			ifTrue: [ a name < b name ]			ifFalse: [ x < y  ] ]! !!RSExamplesBrowser methodsFor: 'initialization'!compile: text	[		(examples at: index) methodClass compile: text.		self updateCanvas.		codeEditor text: text.		"for some reason after the compile process the code editor does not have the current text		the previous code fixes that"	] onErrorDo: [ :ex | ex traceCr ]! !!RSExamplesBrowser methodsFor: 'private'!computeExamples	selectedClass := self defaultClass.	^ (selectedClass methods		select: [ :met | met selector beginsWith: 'example' ]		) asSortedCollection: [ :a :b | a selector < b selector ]! !!RSExamplesBrowser methodsFor: 'initialization'!connectPresenters	classesList	whenSelectedItemChangedDo: [ :cls | self classChanged: cls ].	codeEditor whenSubmitDo: [ :text | self compile: text.  ].	leftButton action: [ self shiftLeft ].	rightButton action: [ self shiftRight ].	searchButton action: [ self openSpotter ]! !!RSExamplesBrowser methodsFor: 'private'!defaultClass	^ selectedClass ifNil: [ self classes first ]! !!RSExamplesBrowser methodsFor: 'initialization'!initializePresenters	classesList := self newDropList		help: 'Select the example to view';		items: self classes;		display: [ :cls | cls name ];		displayIcon: [ :cls | cls iconNamed: cls systemIconName ];		yourself.	searchButton := self newButton		icon: (self iconNamed: #glamorousSearch);		help: 'Open spotter';		yourself.	leftButton := self newButton		label: '<';		yourself.	roassalCanvas := self instantiate: SpRoassal3InspectorPresenter.	codeEditor := self newCode		withSyntaxHighlight;		withScrollBars;		yourself.	rightButton := self newButton		label: '>';		yourself! !!RSExamplesBrowser methodsFor: 'initialization'!initializeWindow: window	window		initialExtent: 800@500;		title: (examples at: index) fullDisplayString! !!RSExamplesBrowser methodsFor: 'accessing - computed'!nextClass	| classes i |	classes := classesList items.	i := classesList selectedIndex.	i := i + 1.	i > classes size ifTrue: [ i := 1 ].	^ classes at: i! !!RSExamplesBrowser methodsFor: 'events'!openSpotter	"TODO custom search in spotter to look for examples"	StSpotter openWithText: 'Examples'! !!RSExamplesBrowser methodsFor: 'accessing - computed'!previousClass	| classes i |	classes := classesList items.	i := classesList selectedIndex.	i := i - 1.	i < 1 ifTrue: [ i := classes size ].	^ classes at: i! !!RSExamplesBrowser methodsFor: 'running'!run	<script: 'self new open'>! !!RSExamplesBrowser methodsFor: 'events'!shiftLeft	index = 1 ifTrue: [		index := -1.		^ classesList selectItem: self previousClass.	] ifFalse: [ index := index - 1 ].	self updateCanvas! !!RSExamplesBrowser methodsFor: 'events'!shiftRight	index = examples size ifTrue: [		^ classesList selectItem: self nextClass.	] ifFalse: [ index := index + 1].	self updateCanvas! !!RSExamplesBrowser methodsFor: 'updated'!updateCanvas	| current canvas |	current := examples at: index.	self withWindowDo: [ :window | self initializeWindow: window ].	codeEditor text: current sourceCode.	codeEditor beForBehavior: selectedClass.	[		canvas :=  current selector value: selectedClass new.		canvas class = RSCanvas			ifFalse: [ canvas := canvas build; canvas ].		roassalCanvas canvas: canvas.	] onErrorDo: [ :ex | ex traceCr ]! !!RSExamplesBrowser methodsFor: 'initialization'!updatePresenter	index := 1.	self classChanged: self defaultClass! !!RSIconBrowser class methodsFor: 'layout'!defaultLayout	^ SpBoxLayout newVertical		add: #canvas;		yourself! !!RSIconBrowser methodsFor: 'initialization'!connectPresenters	| c icons shapes |	c := canvas canvas.	icons := Smalltalk ui.	icons := icons icons icons associations sorted: [ :a :b |		         a key < b key ].	shapes := icons collect: [ :icon |		          RSBitmap new			          form: icon value;			          model: icon;			          popupText: #key;			          when: RSMouseClick do: [ :evt |				          Clipboard clipboardText: evt shape model key.				          self inform: 'Copied icon name' ]			          for: self ].	c addAll: shapes.	RSRectanglePackLayout on: shapes.	c @ RSCanvasController! !!RSIconBrowser methodsFor: 'initialization'!initializePresenters	canvas := self newRoassal! !!RSIconBrowser methodsFor: 'TOREMOVE'!title	^ 'Icons'! !!RSPieChartExample class methodsFor: 'layout'!defaultLayout	<spec: #default>	^ SpBoxLayout newVertical		add: #droplist withConstraints: [ :c | c height: self toolbarHeight ];		add: (SpBoxLayout newHorizontal			add: #chart withConstraints: [:c | c width: 70];			add: #pie;			yourself);		yourself! !!RSPieChartExample methodsFor: 'initialization'!initializePresenters	| org selectedItem |	droplist := self instantiate: SpDropListPresenter.	org := RPackage organizer.	packages := (org packageNames		             select: [ :s | '*Roassal3*' match: s ]		             thenCollect: [ :s | org packageNamed: s ]) sorted: [		            :a		            :b | a linesOfCode > b linesOfCode ].	totalSum := packages max: #linesOfCode.	droplist		items: packages;		display: [ :i | i name ].	chart := self newRoassal.	pie := self newRoassal.	selectedItem := packages first.	chart script: [ :aCanvas |		aCanvas			when: RSExtentChangedEvent			do: [				aCanvas edges copy do: #remove.				aCanvas nodes copy do: #remove.				self visualizeChart: aCanvas package: selectedItem ]			for: self ].	pie script: [ :view | self visualizePie: view package: selectedItem ].	droplist whenSelectedItemChangedDo: [ :pkg |		selectedItem := pkg.		chart refresh.		pie refresh ]! !!RSPieChartExample methodsFor: 'initialization'!initializeWindow: aWindow	aWindow		title: 'Roassal packages';		initialExtent: 800@500;		centered! !!RSPieChartExample methodsFor: 'running'!run	<script: 'self new asWindow open'>! !!RSPieChartExample methodsFor: 'initialization'!visualizeChart: canvas package: pkg	| generator result ticks scale bscale canvasRect box |	generator := NSNiceLinearTicksGenerator new.	generator setLooseFlag: true.	result := generator searchMin: 0 max: totalSum desired: 10.	ticks := result min to: result max by: result step.	canvasRect := Rectangle		floatCenter: 0@0		extent: canvas extent * 0.9.	scale := NSScale linear		domain: {result min. result max};		range: {canvasRect bottom. canvasRect top }.	bscale := NSScale linear		domain: { 0. totalSum };		range: { 0. canvasRect height }.	box := RSBox new		color: Color lightGray;		extent: 20@ (bscale scale: pkg linesOfCode);		yourself.	box position: -10 @ ((scale scale: 0) - (box height /2 )).	canvas add: box.	canvas addAll: (ticks collect:[:t |		RSLabel new			position: 20@ (scale scale: t);			text: (t >= 1000				ifTrue: [ ((t / 1000) printShowingDecimalPlaces: 1) ,'K' ]				ifFalse: [ t asInteger asString ]);			yourself ]).	canvas add: (RSPolyline new		controlPoints: (ticks collect: [:p | -10 @ (scale scale: p)]);		marker: (RSBox new extent: 10@2; color: Color black);		yourself)! !!RSPieChartExample methodsFor: 'initialization'!visualizePie: canvas package: pkg	| b rect max |	b := RSPie new.	b container: canvas.	b sliceShape		innerRadius: 70;		externalRadius: 150;		segmentSpacing: 0.1.	b sliceColor: NSScale google20.	b		objects:			(pkg definedClasses sorted: [ :x :y |					 x linesOfCode < y linesOfCode ]);		slice: #linesOfCode;		build.	RSRotatedPieLabelDecorator on: b.	b shapes @ (RSPopup text: [ :cls |		 cls name , String cr , cls linesOfCode asString , 'LOC' ]).	canvas addShape: (RSLabel new text: pkg linesOfCode asString , 'LOC').	rect := canvas encompassingRectangle.	max := rect origin x abs max: rect corner x.	canvas		when: RSExtentChangedEvent		do: [			canvas camera				zoomToFit: canvas extent				rectangle: (Rectangle floatCenter: 0 @ 0 extent: max * 2 @ 0).			canvas signalUpdate ]		for: self! !"Roassal3-Spec-Examples"!!RSRenderTreeTest methodsFor: 'accessing' prior: 59127133!createTreeWith: aNumber	| random |	"do not modify this method"	tree := self emptyTree.	random := Random new.	random seed: 777.	1 to: aNumber do: [ :each | | box |		box := RSBox new.		box size: 10.		box model: each.		box popup.		box position: (random next @ random next) * 1000.		tree add: box.	].	^ tree! !!RSRenderTreeTest methodsFor: 'running' prior: 59129969!setUp	super setUp.	tree := self emptyTree! !!RSRenderTreeTest methodsFor: 'tests - adding' prior: 59129860!testAddNil	self should: [tree add: nil] raise: Error! !!RSRenderTreeTest methodsFor: 'tests - adding' prior: 59123557!testAllChildren	| list |	list := tree root withAllChildren.	self assert: list isEmpty.	tree add: RSBox new.	list := tree root withAllChildren.	self assert: list size equals: 1.	self assert: (list allSatisfy: [:each | each class = RSRNode ]) .	tree add: (RSBox new position: 10@10).	list := tree root withAllChildren.	self assert: list size equals: 3! !!RSRenderTreeTest methodsFor: 'tests' prior: 59126753!testBalanced	1 to: 10 do: [ :each | | box |		box := RSBox new.		box size: 10.		box position: each * 10 asPoint.		tree add: box. ].	self assert: tree notEmpty.	self assert: tree size equals: 10.	self assert: tree isBalanced! !!RSRenderTreeTest methodsFor: 'tests' prior: 59122252!testHeight	| b1 b2 b3 b4 |	b1 := RSBox new size: 10.	b2 := RSBox new size: 30; position: 30@30.	b3 := RSBox new size: 10; position: -10@ -10.	b4 := RSBox new size: 10; position: 50@50.	self assert: tree height equals: 0.	tree add: b1.	self assert: tree height equals: 1.	tree add: b2.	self assert: tree height equals: 2.	tree add: b3.	self assert: tree height equals: 3.	tree add: b4.	self assert: tree height equals: 3! !!RSRenderTreeTest methodsFor: 'tests' prior: 59123975!testIsBalanced	| boxes |	self assert: tree isBalanced.	boxes := (1 to: 10) collect: [ :i | RSBox new size: 10. ].	RSGridLayout on: boxes.	self assert: (boxes allSatisfy: [:box |		tree add: box.		tree isBalanced ])! !!RSRenderTreeTest methodsFor: 'tests - adding' prior: 59127507!testOneElement	self assert: tree isEmpty.	tree add: (RSBox new size: 10).	self deny: tree isEmpty.	self assert: tree root contents class equals: RSBox.	self assert: tree size equals: 1! !!RSRenderTreeTest methodsFor: 'tests' prior: 59127751!testOneElementContains	| result |	tree add: (RSBox new size: 10).	result := tree shapesAtPoint: 0@0.	self assert: result notEmpty.	result := tree shapesAtRectangle: (0@0 corner: 100@100).	self assert: result notEmpty! !!RSRenderTreeTest methodsFor: 'tests' prior: 59130069!testOneElementRectangle	| box |	box := RSBox new size: 10.	tree add: box.	self assert: tree rectangle equals: box encompassingRectangle! !!RSRenderTreeTest methodsFor: 'tests - removing' prior: 59125243!testRemoveLeaf1	| leafs size shapes shape |	tree := self tree.	size := tree size.	leafs := self leafs.	shapes := leafs collect: [ :each | each contents ] as: RSGroup.	self assert: leafs notEmpty.	self assert: tree isBalanced.	shape := shapes shapeFromModel: 2.	tree remove: shape.	self assert: tree isBalanced.	self assert: size - 1 equals: tree size.	self assert: (tree shapesAtPoint: (shape position)) isEmpty.	tree remove: (shapes shapeFromModel: 10).	self assert: tree isBalanced.	self assert: size - 2 equals: tree size! !!RSRenderTreeTest methodsFor: 'tests - removing' prior: 59128198!testRemoveLeaf2	| leafs shapes shape size |	tree := self tree.	size := tree size.	leafs := self leafs.	shapes := leafs collect: [ :each | each contents ] as: RSGroup.	"use the inspector to visualize the node position in the tree"	shape := shapes shapeFromModel: 1.	tree remove: shape.	self assert: tree isBalanced.	self assert: tree size + 1  equals: size! !!RSRenderTreeTest methodsFor: 'tests - removing' prior: 59121467!testRemoveLeaf3	| leafs shapes random toRemove size |	tree := self bigTree.	size := tree size.	leafs := self leafs.	shapes := leafs collect: [ :each | each contents ] as: RSGroup.	random := Random new.	random seed: 444.	shapes shuffleBy: random.	toRemove := 1 to: (size / 2) asInteger do: [:index | | shape nodes heights newHeights |		shape := shapes at: index.		tree remove: shape.		self assert: tree size + index equals: size.		nodes := tree root withAllChildren.		heights := nodes collect: [ :node | node height ].		tree root computeHeight.		newHeights := nodes collect: [ :node | node height ].		heights with: newHeights do: [ :old :new |			self assert: old equals: new. ].		self assert: tree isBalanced.]! !!RSRenderTreeTest methodsFor: 'tests - removing' prior: 59122920!testRemoveRootChildren	| box |	tree addAll: { box := RSBox new size: 10. }.	tree remove: box.	self assert: tree isEmpty! !!RSRenderTreeTest methodsFor: 'tests - removing' prior: 59128029!testRemoveZero	| value |	value := false.	tree remove: RSBox new ifAbsent: [ value := true ].	self assert: value! !!RSRenderTreeTest methodsFor: 'tests' prior: 59122740!testSearchPath1	| path |	tree := self emptyTree.	path := tree root searchPath: (RSBox new).	self assert: path isEmpty! !!RSRenderTreeTest methodsFor: 'tests' prior: 59130505!testSearchPath2	| path shape |	tree := self emptyTree.	tree add: (shape := RSBox new model: 1).	path := tree root searchPath: shape.	self assert: path asArray equals: { nil -> tree root }! !!RSRenderTreeTest methodsFor: 'tests' prior: 59129135!testSearchPath3	| nodes path shapes |	tree := self tree.	"tree inspect"	nodes := self leafs.	shapes := nodes collect: [ :node | node contents ] as: RSGroup.	path := tree root searchPath: RSBox new.	self assert: path isEmpty.	path := tree root searchPath: (shapes shapeFromModel: 1).	self assert: path asArray equals:		{ nil-> tree root.		false -> tree root left.		false -> tree root left left }.	path := tree root searchPath: (shapes shapeFromModel: 10).	self assert: path asArray equals:		{ nil-> tree root.		true -> tree root right.		false -> tree root right left.		true -> tree root right left right.		true -> tree root right left right right }! !!RSRenderTreeTest methodsFor: 'tests' prior: 59124250!testSeriousBalance	| random canvas |	random := Random new.	random seed: 777.	canvas := RSCanvas new.	1 to: 100 do: [ :each | | box |		box := RSBox new.		box size: 10.		box model: each.		box popup.		box position: (random next @ random next) * 1000.		canvas add: box.		tree add: box.		self assert: tree height equals: tree root computeHeight.		self assert: tree isTotalBalanced.	]! !!RSRenderTreeTest methodsFor: 'tests - adding' prior: 59128624!testThreeElements	| b1 b2 b3 |	b1 := RSBox new size: 10.	b2 := RSBox new size: 30; position: 30@30.	b3 := RSBox new size: 10; position: -10@ -10.	tree addAll: { b1. b2. b3 }.	self assert: tree notEmpty.	self assert: tree size equals: 3.	self assert: tree root contents equals: nil.	self assert: tree root left notNil.	self assert: tree root right notNil! !!RSRenderTreeTest methodsFor: 'tests' prior: 59125842!testThreeElementsContains	| b1 b2 b3 result |	b1 := RSBox new size: 10.	b2 := RSBox new size: 30; position: 30@30.	b3 := RSBox new size: 10; position: -10@ -10.	tree addAll: { b1. b2. b3 }.	result := tree shapesAtPoint: 0@0.	self assert: result first equals: b1.	result := tree shapesAtPoint: 30@30.	self assert: result first equals: b2.	result := tree shapesAtPoint: -10@ -10.	self assert: result first equals: b3.	result := tree shapesAtRectangle: (0@0 corner: 10@10).	self assert: result first equals: b1.	result := tree shapesAtRectangle: (0@0 corner: 30@30).	self assert: result size equals: 2.	result := tree shapesAtRectangle: (-20@ -20 corner: 30@30).	self assert: result size equals: 3! !!RSRenderTreeTest methodsFor: 'tests - adding' prior: 59123191!testTwoElements	| b1 b2 |	b1 := RSBox new size: 10.	b2 := RSBox new size: 30; position: 30@30.	tree addAll: { b1. b2 }.	self assert: tree notEmpty.	self assert: tree size equals: 2.	self assert: tree root contents equals: nil.	self assert: tree root left notNil.	self assert: tree root right notNil! !!RSRenderTreeTest methodsFor: 'tests' prior: 59124705!testTwoElementsContains	| b1 b2 result |	b1 := RSBox new size: 10.	b2 := RSBox new size: 30; position: 30@30.	tree addAll: { b1. b2 }.	result := tree shapesAtPoint: 0@0.	self assert: result first equals: b1.	result := tree shapesAtPoint: 30@30.	self assert: result first equals: b2.	result := tree shapesAtRectangle: (0@0 corner: 10@10).	self assert: result first equals: b1.	result := tree shapesAtRectangle: (0@0 corner: 30@30).	self assert: result size equals: 2! !!RSRenderTreeTest methodsFor: 'tests - adding' prior: 59120994!testTwoElementsRectangle	| b1 b2 group |	b1 := RSBox new size: 10.	b2 := RSBox new size: 30; position: 30@30.	group := RSGroup new.	group addAll: { b1. b2 }.	tree addAll: group.	self assert: tree rectangle equals: group encompassingRectangle! !!RSMonitorEventsTest methodsFor: 'tests' prior: 58976522!testBasic	| canvas monitor eventClass timeStamp |	canvas := RSCanvas new.	monitor := RSMonitorEvents new.	monitor target: canvas.	eventClass := nil.	timeStamp := nil.	monitor onNewEventDo: [ :evt |		eventClass := evt class.		timeStamp := evt timeStamp.	] for: self.	canvas announce: RSMouseLeftClick new.	self assert: eventClass equals: RSMouseLeftClick.	self assert: timeStamp isNumber.	monitor unRegister.	eventClass := nil.	self assert: eventClass isNil! !!RSMonitorEventsTest methodsFor: 'tests' prior: 58975403!testNoTarget	| monitor |	monitor := RSMonitorEvents new.	self should: [ monitor onNewEventDo: [  ] for: self ] raise: Error! !!RSMonitorEventsTest methodsFor: 'tests' prior: 58975577!testWriteToFile	| canvas monitor events box fileName storage |	canvas := RSCanvas new.	box := RSBox new size: 20; yourself.	monitor := RSMonitorEvents new.	monitor target: box.	events := OrderedCollection new.	monitor onNewEventDo: [:evt | events add: evt className -> evt timeStamp ] for: self.	box announce: (RSPositionChangedEvent new newPosition: 100@100; yourself).	self assert: events isNotEmpty.	fileName := Time microsecondClockValue asString, '.fuel'.	storage := (FLSerializer class canUnderstand: #serializeToByteArray:)		ifTrue: [ FLSerializer serializeToByteArray: events. ]		ifFalse: [			ByteArray				new: 100				streamContents: [ :stream |					| serializer |					serializer := FLSerializer new.					serializer						perform: #onStream: with: stream;						perform: #object: with: events.					#serialize value: serializer ] ].	self assert: storage size > 100! !!RSDSMTest methodsFor: 'tests' prior: 58575952!testColor	| b |	b := RSDSM new.	b objectsX: #(1 2 3 4).	b objectsY: #( 'A' 'B' 'C' ).	b color: [ :tuple | Color random ].	b build! !!RSDSMTest methodsFor: 'tests' prior: 58576138!testDep	| dsm v ts |	dsm := RSDSM new.	dsm hideLabels.	dsm objects: (1 to: 10).	dsm dependency: [ :aValue | aValue // 2 ].	dsm build.	v := dsm canvas.	self assert: v shapes size equals: 100.	ts := v shapes collect: #color as: Set.	self assert: ts size equals: 2! !!RSDSMTest methodsFor: 'tests' prior: 58578376!testExample02	| dsm shapes column5 row5 |	dsm := RSDSM new.	dsm objects: (1 to: 10).	dsm dependency: [ :aValue | aValue // 2 ].	dsm build.	shapes := dsm shapes.	self assert: shapes size equals: 100.	self assert: (dsm shapeAt: 1 @ 1) model equals: 1 -> 1.	self assert: (dsm shapeAt: 3 @ 1) model equals: 1 -> 3.	self assert: (dsm shapeAt: 10 @ 10) model equals: 10 -> 10.	self assert: (dsm shapeAt: 5 @ 2) model equals: 2 -> 5.	column5 := dsm columnAt: 5.	self assert: column5 size equals: 10.	self assert: column5 first model equals: 5 -> 1.	row5 := dsm rowAt: 5.	self assert: row5 size equals: 10.	self assert: row5 first model equals: 1 -> 5.	column5 first announce: (RSMouseEnter new shape: column5 first)! !!RSDSMTest methodsFor: 'tests' prior: 58577278!testLabelShapeColor	| b shapes |	b := RSDSM new.	b objectsX: #(1 2 3 4).	b objectsY: #( 'A' 'B' 'C' ).	b build.	b labelsX do: [ :label |		label color: (label model even			ifTrue: [ Color red ]			ifFalse: [ Color gray ]) ].	shapes := b labelsX.	self assert: shapes first model equals: 1.	self assert: shapes second color equals: Color red! !!RSDSMTest methodsFor: 'tests' prior: 58579158!testLabelShapeHeight	| b |	b := RSDSM new.	b objectsX: #(1 2 3 4).	b objectsY: #( 'A' 'B' 'C' ).	b build.	b labels do: [ :l | l fontSize: 30; color: Color blue ].	self assert: b labelsX first color equals: Color blue! !!RSDSMTest methodsFor: 'tests' prior: 58576461!testLabelsLeftPosition	| b shapes firstColumn |	b := RSDSM new.	b objectsX: (1 to: 3).	b objectsY: #(#a #b #c).	b dependency: [ :aValue | aValue + 1 ].	b build.	shapes := b labelsY.	self assert: shapes isNotEmpty.	firstColumn := b columnAt: 1.	firstColumn with: shapes do: [ :box :label |		self assert: box position y equals: label position y  ]! !!RSDSMTest methodsFor: 'tests' prior: 58577675!testLabelsTopPosition	| b labels firstRow |	b := RSDSM new.	b objectsY: #(#a #b #c).	b objectsX: (1 to: 3).	b rotation: 90.	b shape size: 50.	b dependency: [ :aValue | aValue + 1 ].	b build.	labels := b labelsX.	self assert: labels isNotEmpty.	firstRow := b rowAt: 1.	firstRow with: labels do: [ :box : label |		| x x1 x2 |		x := label encompassingRectangle bottomRight x.		x1 := box encompassingRectangle topLeft x.		x2 := box encompassingRectangle topRight x.		self assert: (x between: x1 and: x2)		 ]! !!RSDSMTest methodsFor: 'tests' prior: 58576866!testUsingXAndY	| b |	b := RSDSM new.	b objectsX: #(1 2 3 4).	b objectsY: #( 'A' 'B' 'C' ).	b build.	self assert: b objectsX size equals: 4.	self assert: b objectsY size equals: 3! !!RSColoredTreePaletteTest methodsFor: 'tests' prior: 58525450!testBasic	| c nodes lb ctp node1 node2 node3 |	c := RSCanvas new.	nodes := RSBox models: (1 to: 10).	c addAll: nodes.	nodes @ RSPopup.	lb := RSLineBuilder orthoVertical.	lb withVerticalAttachPoint.	lb shapes: nodes.	lb connectFrom: [ :nb | nb // 2 ].	RSTreeLayout on: nodes.	node1 := c shapeFromModel: 1. "The root"	node2 := c shapeFromModel: 2. "Right below 1"	node3 := c shapeFromModel: 3. "Right below 1"	self assert: node1 color identityHash equals: node2 color identityHash.	self assert: node3 color identityHash equals: node2 color identityHash.	"Assign the color"	ctp := RSColoredTreePalette new.	ctp shapes: c nodes.	ctp assignColor.	self assert: node3 color ~= node2 color.	self assert: node1 color ~= node2 color! !!RSColoredTreePaletteTest methodsFor: 'tests' prior: 58524817!testLeaves	| c nodes lb ctp node1 node2 node3 |	c := RSCanvas new.	nodes := RSBox models: (1 to: 10).	c addAll: nodes.	nodes @ RSPopup.	lb := RSLineBuilder orthoVertical.	lb withVerticalAttachPoint.	lb shapes: nodes.	lb connectFrom: [ :nb | nb // 2 ].	RSTreeLayout on: nodes.	node1 := c shapeFromModel: 1. "The root"	node2 := c shapeFromModel: 2. "Right below 1"	node3 := c shapeFromModel: 3. "Right below 1"	"Assign the color"	ctp := RSColoredTreePalette new.	ctp shapes: c nodes.	ctp assignColor.	self assert: ctp totalNumberOfLeaves equals: 5! !!RSDependencyTest methodsFor: 'private - asserting' prior: 58580429!assertPackage: p1Name dependOn: p2Name	| p1 p2 |	p1 := self packageNamed: p1Name.	p2 := self packageNamed: p2Name.	self assert: (p1 dependentPackages includes: p2)! !!RSDependencyTest methodsFor: 'private - asserting' prior: 58580187!assertPackage: p1Name doesNotDependOn: p2Name	| p1 p2 |	p1 := self packageNamed: p1Name.	p2 := self packageNamed: p2Name.	self deny: (p1 dependentPackages includes: p2)! !!RSDependencyTest methodsFor: 'testing' prior: 58581454!hasPackage: aString	^ (self packageNamed: aString) notNil! !!RSDependencyTest methodsFor: 'private - accessing' prior: 58581584!packageNamed: aSymbol	^ RPackageOrganizer default packageNamed: aSymbol		ifAbsent: [ nil ]! !!RSDependencyTest methodsFor: 'tests' prior: 58580652!testDependencies	self assertPackage: 'Roassal3' doesNotDependOn: 'Roassal3-Layouts'.	self assertPackage: 'Roassal3' doesNotDependOn: 'Roassal3-Inspector'.	self assertPackage: 'Roassal3' doesNotDependOn: 'Roassal3-Animation'.	self assertPackage: 'Roassal3' doesNotDependOn: 'Roassal3-Builders'.	self assertPackage: 'Roassal3' doesNotDependOn: 'Roassal3-Chart'.	self assertPackage: 'Roassal3' doesNotDependOn: 'Roassal3-Colors'.	self assertPackage: 'Roassal3-Shapes' doesNotDependOn: 'Roassal3-Layouts'.	self assertPackage: 'Roassal3-Animation' dependOn: 'Roassal3'.	"Chart uses RSLocation from Layouts"	self assertPackage: 'Roassal3' dependOn: 'Announcements-Core'! !!RSForceBasedLayoutTest methodsFor: 'running' prior: 58692315!setUp	super setUp.	canvas := RSCanvas new.	boxes := RSBox models: (10 to: 50).	RSLineBuilder line		canvas: canvas;		shapes: boxes;		color: (Color blue alpha: 0.5);		connectFrom: [ :nb | nb // 2 ].	canvas addAll: boxes! !!RSForceBasedLayoutTest methodsFor: 'tests' prior: 58686685!testAddNodesAndEdges	RSForceBasedLayout new		start;		addNodes: boxes;		addLines: canvas edges;		step.	self assert: (boxes collect: #position as: Array) equals: {(204.1381767192054@ -34.65975567128365). (41.6086750973881@ -330.64514821559214). (-437.64121980646655@138.4449837721012). (629.106833418821@ -213.35229450714166). (-171.26791462481438@ -114.27272445604714). (165.05247082344806@ -170.18306072876882). (-143.86418278241095@179.70435711976). (-45.14813741792285@348.1141409355912). (526.169880616215@ -88.70743211410085). (176.3244614439574@ -83.50029028072399). (-332.02040632080855@124.43126055068214). (-68.861761464375@402.1189842427126). (-93.64122655285627@134.0071205210135). (209.0701564771561@46.16793117345678). (-145.88222068511843@ -187.856251669607). (-245.59594460619587@ -998.5852435459608). (69.17634804610802@ -389.22699598484235). (-81.058777229675@ -266.8242152617776). (-239.1677329629107@387.38247425908116). (-298.244019432684@ -478.6636378594302). (554.2864294374763@ -345.0449450754109). (83.77169882312965@307.80828092151535). (154.51065837660113@124.67245322480098). (-97.78774438677755@119.71040238490563). (-114.84373567808449@ -196.79917392925398). (-2630.492471838436@5619.89941797112). (287.8792223887767@22.99051914576157). (69.19603469859378@ -352.6677751569359). (148.3754047315037@ -205.04539909521708). (35.46378454321605@265.52467506793124). (-148.93212453920935@147.7573881438297). (-332.82400226848773@ -126.40573430977705). (-289.8209003737269@ -230.8639904888284). (263.2113898041367@11.242914359614108). (-145.73522573503845@149.16645846308464). (166.65319011541882@ -578.7962139728857). (218.49866543137253@34.42504672803043). (-170.65430176680417@ -392.4494042748909). (300.0018302573603@ -200.09384102093748). (-223.95997500210785@42.27475866338375). (472.45208863125396@1527.2444661739955)}! !!RSForceBasedLayoutTest methodsFor: 'tests' prior: 58684808!testAttributes	RSForceBasedLayout new		length: 100;		charge: -300;		center: 200@200;		on: boxes.	self assertIntegerPosition: boxes equals: {181 @ 36.340 @ 305.8 @ 310.76 @ -59.333 @ -76.263 @ 43.479 @ 117.19 @ 215.203 @ 362.-67 @ 92.80 @ 30.228 @ 128.443 @ 309.293 @ 397.18 @ 410.105 @ 331.-9 @ -7.168 @ -96.337 @ 21.414 @ -12.356 @ 85.235 @ -53.384 @ 150.427 @ 205.112 @ 250.11 @ 112.203 @ 463.257 @ 279.-113 @ 183.-53 @ 195.83 @ 133.146 @ 107.191 @ 221.300 @ 198.501 @ 229.427 @ 411.283 @ 495.385 @ 365.-61 @ 349.83 @ 485.131 @ 426}! !!RSForceBasedLayoutTest methodsFor: 'tests' prior: 58682864!testAutoRepulse	self assert: RSForceBasedLayout new autoRepulse equals: false.	RSForceBasedLayout new		autoRepulse: true;		on: boxes.	self assertIntegerPosition: boxes equals: {0 @ -26.36 @ 49.-40 @ 35.-23 @ -71.49 @ -52.17 @ -55.61 @ 0.-60 @ -37.4 @ 21.-68 @ 2.-10 @ -37.4 @ -11.51 @ 45.21 @ 54.-42 @ 51.-27 @ 26.-38 @ -65.-8 @ -73.49 @ -36.63 @ -46.24 @ -41.21 @ -70.76 @ -5.47 @ -3.-71 @ -26.-51 @ -24.1 @ 36.20 @ 18.-71 @ 17.-52 @ 4.-25 @ -43.-22 @ -25.-8 @ -1.20 @ -9.65 @ 37.50 @ 29.8 @ 63.25 @ 70.-57 @ 49.-32 @ 64.-20 @ 40}! !!RSForceBasedLayoutTest methodsFor: 'tests' prior: 58690442!testBasic	RSForceBasedLayout new		doNotUseProgressBar;		on: boxes.	self assertIntegerPosition: boxes equals: {0 @ -44.53 @ 27.-56 @ 37.-32 @ -87.57 @ -41.39 @ -76.77 @ 5.-69 @ -32.4 @ 72.-91 @ -11.-19 @ -53.5 @ -23.32 @ 21.70 @ 40.-66 @ 55.-36 @ 27.-52 @ -78.-10 @ -89.78 @ -34.68 @ -59.30 @ -56.23 @ -89.59 @ -5.97 @ -1.-63 @ -11.-49 @ -21.-10 @ 87.21 @ 85.-98 @ 8.-78 @ 6.-40 @ -54.-25 @ -31.-4 @ -4.25 @ -15.26 @ 42.11 @ 24.56 @ 57.76 @ 61.-58 @ 76.-45 @ 62.-18 @ 38}! !!RSForceBasedLayoutTest methodsFor: 'tests' prior: 58688600!testBasic02	RSForceBasedLayout on: boxes.	self assertIntegerPosition: boxes equals: {0 @ -44.53 @ 27.-56 @ 37.-32 @ -87.57 @ -41.39 @ -76.77 @ 5.-69 @ -32.4 @ 72.-91 @ -11.-19 @ -53.5 @ -23.32 @ 21.70 @ 40.-66 @ 55.-36 @ 27.-52 @ -78.-10 @ -89.78 @ -34.68 @ -59.30 @ -56.23 @ -89.59 @ -5.97 @ -1.-63 @ -11.-49 @ -21.-10 @ 87.21 @ 85.-98 @ 8.-78 @ 6.-40 @ -54.-25 @ -31.-4 @ -4.25 @ -15.26 @ 42.11 @ 24.56 @ 57.76 @ 61.-58 @ 76.-45 @ 62.-18 @ 38}! !!RSRoassal3Test methodsFor: 'tests' prior: 59139790!testInitializeInRoassal	| pkgs methods violating |	pkgs := RPackage organizer packages select: [ :pkg | 'Roassal3*' match: pkg name ].	methods := pkgs flatCollect: [ :pkg | pkg definedClasses flatCollect: [ :class | class methods ] ].	violating := methods select: [ :method | method selector = #initialize and: [ method protocolName ~= #initialization ] ].	self assert: violating isEmpty description: 'Roassal initialize methods should be categorized in initialization'! !!RSRoassal3Test methodsFor: 'tests' prior: 59140329!testOpen	| v |	v := RSCanvas new open.	self assert: v class == SystemWindow.	v delete! !!RSRoassal3Test methodsFor: 'tests' prior: 59140472!testOpenOnce	| v |	v := RSCanvas new openOnce.	self assert: v class == SystemWindow.	v delete! !!RSRoassal3Test methodsFor: 'tests' prior: 59139206!testRemoveInteractionIfPresent	| box |	box := RSBox new.	self deny: (box announcer handleSubscriberClass: RSPopup).	box popup.	self assert: (box announcer handleSubscriberClass: RSPopup).	box removeInteractionIfPresent: RSPopup.	self deny: (box announcer handleSubscriberClass: RSPopup).	self deny: box hasEventCallback.	box := RSBox new.	box popup.	self assert: (box announcer handleEventClass: RSMouseMove).	box removeInteractionIfPresent: RSMouseMove.	self assert: (box announcer handleEventClass: RSMouseMove)! !!RSRoassal3Test methodsFor: 'tests' prior: 59138741!testSubscriberClass	| box |	box := RSBox new.	self deny: (box announcer handleSubscriberClass: RSPopup).	box popup.	self assert: (box announcer handleSubscriberClass: RSPopup).	"but popup adds a lot of events, RSPopup is not an event"	self deny: (box announcer handleEventClass: RSPopup).	{RSPopup activationEvent}, RSPopup removeEvents do: [ :evt | self assert:  (box announcer handleEventClass: evt). ]! !!RSRoassal3Test methodsFor: 'tests' prior: 59140623!testsRsValue	| myCutomObjectValueProvider posiblesValuesForRoassal model colors |	myCutomObjectValueProvider := NSScale category10.	posiblesValuesForRoassal:= {		Color red.		nil.		Color random.		[ Color random ].		#color.		[ :obj | obj color ].		myCutomObjectValueProvider  }.	model := Morph new.	colors := posiblesValuesForRoassal collect: [ :value |		value rsValue: model ] as: OrderedCollection.	self assert: (colors includes: nil).	colors remove: nil.	colors do: [ :color | self assert: color class equals: Color ]! !!RSSunburstBuilderTest methodsFor: 'tests' prior: 59261916!testBasic	| segment1 segment2 line attachPoint startPoint endPoint |	segment1 := RSPieSlice new		innerRadius: 0;		externalRadius: 100;		alphaAngle: 0;		betaAngle: 360;		yourself.	segment2 := RSPieSlice new		innerRadius: 100;		externalRadius: 150;		alphaAngle: -45;		betaAngle: 45;		yourself.	line := RSLine new		from: segment1;		to: segment2;		yourself.	attachPoint := RSSunburstAttachPoint new.	startPoint := attachPoint basicStartingPointOf: line.	endPoint := attachPoint basicEndingPointOf: line.	self assert: startPoint closeTo: 0@0.	self assert: endPoint closeTo: 125@0! !!RSExamplesTest class methodsFor: 'tests'!validMethods: methods	| result |	result := methods select: [ :met |		(met selector beginsWith: 'example') and: [			(met hasPragmaNamed: 'noTest') not ] ].	result sort: CompiledMethod sortBlock.	^ result! !!RSExamplesTest methodsFor: 'tests' prior: 58661691!executeTest: method in: exampleClass	| res |	res := exampleClass perform: method selector.	self		deny: res = exampleClass		description: '''' , method selector, ''', should return a canvas or view.'! !!RSExamplesTest methodsFor: 'tests'!testClassSideExamples	| methods errors noSystemWindow |	self timeLimit: 10 minutes.	methods := self class validMethods: (RSObject withAllSubclasses		flatCollect: [:cls | cls class methods ]).	methods := self class validMethods: methods.	errors := OrderedCollection new.	noSystemWindow := OrderedCollection new.	methods do:[ :met | | window |		[ window := met selector value: met methodClass soleInstance.		window isDisplayed			ifTrue: [ window delete ]			ifFalse: [ noSystemWindow add: met ]		 ] onErrorDo: [ :error | errors add: met ].		]		displayingProgress: [ :met | met fullDisplayString ]		every: 500.	"class side example should return a window and run without errors"	self assert: errors isEmpty description: 'Some errors in class side examples'.	self assert: noSystemWindow isEmpty description: 'Some errors in class side examples'! !!RSExamplesTest methodsFor: 'tests' prior: 58661948!testExamples	"This tests execute all the examples of Roassal. Introspectively, it looks for subclasses of RSAbstractExamples"	| clazz withErrors sameResult |	self timeLimit: 10 minutes.	clazz := Smalltalk at: #RSAbstractExamples ifAbsent: [ ^ self ].	withErrors := OrderedCollection new.	sameResult := OrderedCollection new.	clazz subclasses do: [ :cls |		| inst methods |		inst := cls new.		methods := self class validMethods: cls methods.		methods			do: [ :met | | res |				[res := inst perform: met selector.				res = inst ifTrue: [ sameResult add: met ]]				on: Error do: [ :ex | | message |					message := String streamContents: [ :stream |						ex signalerContext shortDebugStackOn: stream ].					withErrors add: message -> met ]				 ]			displayingProgress: [ :met | met selector ]			every: 100 ]		displayingProgress: [ :cls | cls asString ]		every: 500.	withErrors ifNotEmpty: [		'>>> Examples with errors: ' traceCr.		withErrors do: [ :report |			report value printString traceCr.			report key traceCr.			'' traceCr.			 ] ].	withErrors := withErrors collect: [ :each | each value ].	self assert: withErrors isEmpty description: 'All examples in roassal should run'.	self assert: sameResult isEmpty description: 'All examples should return a canvas or builder'! !!RSShapeTest methodsFor: 'tests' prior: 59229956!testAllConnectedShapes	| canvas shapes lb node1 node2 node3 node5 node6 |	canvas := RSCanvas new.	shapes := RSLabel models: (1 to: 6).	canvas addAll: shapes.	shapes @ RSDraggable.	lb := RSLineBuilder arrowedLine.	lb withBorderAttachPoint.	lb shapes: shapes.	lb useAssociations: { 1 -> 3 . 3 -> 2 . 3 -> 4 . 5 -> 6. }.	RSForceBasedLayout on: shapes.	node1 := canvas shapeFromModel: 1.	node2 := canvas shapeFromModel: 2.	node3 := canvas shapeFromModel: 3.	node5 := canvas shapeFromModel: 5.	node6 := canvas shapeFromModel: 6.	self assert: (node1 allRecursiveConnectedShapes collect: #model) asSortedCollection asArray equals: (1 to: 4).	self assert: node1 allRecursiveConnectedShapes equals: node2 allRecursiveConnectedShapes.	self assert: node1 allRecursiveConnectedShapes equals: node3 allRecursiveConnectedShapes.	self assert: node2 allRecursiveConnectedShapes equals: node3 allRecursiveConnectedShapes.	self assert: node1 allRecursiveConnectedShapes ~= node5 allRecursiveConnectedShapes.	self assert: node5 allRecursiveConnectedShapes equals: node6 allRecursiveConnectedShapes! !!RSShapeTest methodsFor: 'tests' prior: 59231116!testHasModel	self deny: RSCircle new hasModel.	self assert: (RSShape new model: 52) hasModel.	self assert: (RSLine new model: 52) hasModel.	self deny: RSLine new hasModel! !!RSShapeTest methodsFor: 'tests' prior: 59231341!testIncomingAndOutgoingShapes	| c shapes lb node1 node5 |	c := RSCanvas new.	shapes := RSBox models: (1 to: 10).	c addAll: shapes.	lb := RSLineBuilder line.	lb canvas: c.	lb connectFrom: [ :nb | nb // 2 ].	node1 := c shapeFromModel: 1.	self assert: node1 model equals: 1.	self assert: node1 outgoingLines size equals: 2.	self assert: node1 outgoingShapes size equals: 2.	self assert: node1 outgoingShapes equals: (c shapesFromModels: #(2 3)).	self assert: node1 incomingLines isEmpty.	self assert: node1 incomingShapes isEmpty.	node5 := c shapeFromModel: 5.	self assert: node5 incomingShapes equals: (c shapesFromModels: #(2)).	self assert: node5 outgoingShapes equals: (c shapesFromModels: #(10 11))! !!RSShapeTest methodsFor: 'tests' prior: 59229574!testTranslateMiddleRightTo	| c center lbl |	c := RSCanvas new.	center := RSEllipse new size: 2; color: Color red.	c add: center.	center translateTo: 0 @ 0.	lbl := RSLabel text: 'Middle right corner'.	c add: lbl.	lbl translateMiddleRightTo: 0 @ 0.	self assert: (lbl position x < 0).	self assert: (lbl position y = 0)! !!RSAttachPointTest methodsFor: 'tests' prior: 58336837!testInverted	| ap e1 e2 line |	ap := RSCenteredAttachPoint new.	ap straight.	self deny: ap isInverted.	e1 := RSEllipse new.	e2  := RSEllipse new.	e1 translateTo: 20 asPoint.	line := RSLine new.	line attachPoint: ap.	line from: e1.	line to: e2.	line update.	self assert: e1 position equals: line startPoint.	ap inverted.	line update.	self assert: e1 position equals: line endPoint! !!RSAdjacencyMatrixBuilderTest methodsFor: 'running' prior: 58278325!setUp	super setUp.	empty := RSAdjacencyMatrixBuilder new.	b := RSAdjacencyMatrixBuilder new.	b objects: (1 to: 4).	b connections: { 1 -> 2 . 1 -> 3 . 2 -> 4 }! !!RSAdjacencyMatrixBuilderTest methodsFor: 'tests' prior: 58278558!testConnections01	empty connections: {			(1 -> 2).			(2 -> 3) }.	self assert: empty numberOfConnections equals: 2.	self assert: (empty does: 1 dependsOn: 2).	self deny: (empty does: 2 dependsOn: 1).	self assert: (empty does: 2 dependsOn: 3).	self deny: (empty does: 3 dependsOn: 2).	self deny: (empty does: 1 dependsOn: 42)! !!RSAdjacencyMatrixBuilderTest methodsFor: 'tests' prior: 58277174!testCycle01	self deny: b hasCycle! !!RSAdjacencyMatrixBuilderTest methodsFor: 'tests' prior: 58276096!testCycle02	b := RSAdjacencyMatrixBuilder new.	b objects: (1 to: 3).	b connections: {			(1 -> 2).			(2 -> 3) }.	self deny: b hasCycle.	b connections: {			(1 -> 2).			(2 -> 3).			(3 -> 1) }.	self assert: b hasCycle! !!RSAdjacencyMatrixBuilderTest methodsFor: 'tests' prior: 58275140!testCycle04	b := RSAdjacencyMatrixBuilder new.	b objects: (1 to: 4).	b connections: {			(1 -> 2).			(2 -> 3) }.	self assert: b getAllCycles isEmpty.	b connections: {			(1 -> 2).			(2 -> 3).			(3 -> 1) }.	self assert: b getAllCycles size equals: 1.	b connections: {			(1 -> 2).			(2 -> 1).			(3 -> 4).			(4 -> 3) }.	self assert: b getAllCycles size equals: 2.	self assert: (b getAllCycles includes: (Set withAll: #(1 2))).	self assert: (b getAllCycles includes: (Set withAll: #(3 4))).	b connections: {			(1 -> 2).			(2 -> 1).			(3 -> 4).			(4 -> 3) }.	self assert: b getAllCycles size equals: 2.	self assert: (b getAllCycles includes: (Set withAll: #(1 2))).	self assert: (b getAllCycles includes: (Set withAll: #(3 4)))! !!RSAdjacencyMatrixBuilderTest methodsFor: 'tests' prior: 58276668!testRendering01	| canvas allCells |	canvas := b build.	self assert: canvas class == RSCanvas.	allCells := canvas shapes select: [ :c | c class == RSBox ].	self assert: allCells size equals: 4 * 4.	self assert: allCells first model equals: 1 -> 1.	self assert: allCells first color equals: b nonConnectingColor.	self assert: allCells second model equals: 1 -> 2.	self assert: allCells second color equals: b connectingColor! !!RSAdjacencyMatrixBuilderTest methodsFor: 'tests' prior: 58276391!testSorting02	b := RSAdjacencyMatrixBuilder new.	b objects: (1 to: 4).	b connections: { 2 -> 1 . 2 -> 4 . 4 -> 1 }.	b sortByNumberOfOutgoingConnections.	b build.	self assert: b objects equals: #(3 1 4 2)! !!RSObjectWithPropertyTest methodsFor: 'tests'!testBasic	| b1 b2 b3 |	b1 := RSBox new.	b2 := RSBox new.	b3 := RSBox new.	b1 schildren: {			b2.			b3 }.	self assert: b2 sparent equals: b1.	self assert: b3 sparent equals: b1! !!RSObjectWithPropertyTest methodsFor: 'tests'!testWithAllChildren	| b1 b2 b3 children childrenWithParent schildren b4 |	b1 := RSBox new.	b2 := RSBox new.	b3 := RSBox new.	b4 := RSBox new.	children := {		            b2.		            b3 }.	b1 schildren: children.	b3 schildren: { b4 }.	childrenWithParent := children , { b1. b4 }.	schildren := b1 withAllSChildren.	self assert: schildren size equals: 4.	self assert:		(schildren allSatisfy: [ :s | childrenWithParent includes: s ])! !!RSSequenceableCollectionTest methodsFor: 'running'!setUp	super setUp.	list := RSSequenceableCollection new! !!RSSequenceableCollectionTest methodsFor: 'tests'!testBasic	list isEmpty.	self assert: list size isZero! !!RSSequenceableCollectionTest methodsFor: 'tests'!testIncludes	| result |	list addAll: { RSBox new size: 10. RSBox new position: 50@50; size: 10 asPoint}.	self assert: list size equals: 2.	result := list shapesAtPoint:  -100@ -100.	self assert: result isEmpty.	result := list shapeAtPoint: -100@ -100.	self assert: result isNil! !!RSSequenceableCollectionTest methodsFor: 'tests'!testOneElement	list add: (RSBox new size: 10).	self deny: list isEmpty! !!RSShapeCollectionTest methodsFor: 'tests'!testBasic	| canvas collection |	canvas := RSCanvas new.	collection := canvas shapeCollection.	self assert: collection class equals: canvas defaultShapeCollection class.	self assert: collection isCollection.	self assert: collection isEmpty.	! !!RSShapeCollectionTest methodsFor: 'tests'!testContainsPoint	| canvas collection box shape |	self skip.	canvas := RSCanvas new.	box := RSBox new		size: 100 asPoint;		position: 1000 asPoint;		yourself.	collection := canvas shapeCollection.	canvas add: box.	self assert: collection notEmpty.	shape := canvas shapeWithActionForPosition: 1000 asPoint.	self assert: shape isNil.	shape := collection shapeAtPoint: 1000 asPoint.	self assert: shape equals: box.	shape @ RSDraggable.	shape := canvas shapeWithActionForPosition: 1000 asPoint.	self assert: shape equals: box! !!RSTest methodsFor: 'asserting'!assertIntegerPosition: shapes equals: anArray	self 		assert: (shapes collect: [ :each | each position asIntegerPoint ] as: Array)		equals: anArray! !!RSCameraTest methodsFor: 'tests'!testMatrix	| canvas |	canvas := RSCanvas new.	self assert: canvas camera matrix isIdentity.! !!RSCameraTest methodsFor: 'tests'!testVisibleArea	| canvas |	canvas := RSCanvas new.	canvas extent: 100 asPoint.	self assert: canvas visibleRectangle equals: (-50 asPoint corner: 50 asPoint)! !!RSCameraTest methodsFor: 'tests'!testVisibleAreaTopLeft	| canvas |	canvas := RSCanvas new.	canvas originTopLeft.	canvas extent: 100 asPoint.	self assert: canvas visibleRectangle equals: (0 asPoint corner: 100 asPoint)! !!RSCameraTest methodsFor: 'tests'!testVisibleAreaWTopLeftWithScale	| canvas |	canvas := RSCanvas new.	canvas extent: 100 asPoint.	canvas originTopLeft.	canvas camera scale: 2.	self assert: canvas visibleRectangle equals: (0 asPoint corner: 50 asPoint)! !!RSCameraTest methodsFor: 'tests'!testVisibleAreaWithScale	| canvas |	canvas := RSCanvas new.	canvas extent: 100 asPoint.	canvas camera scale: 2.		self assert: canvas visibleRectangle equals: (-25 asPoint corner: 25 asPoint)! !"Roassal3-Global-Tests"!!RSEasingInterpolatorTest methodsFor: 'tests' prior: 58618652!testAllEasing	"Simply check if no error is raised"	| someX |	someX := (0 to: 1 by: 0.01).	RSEasingInterpolator allSubclassesDo: [ :cls |		someX collect: [ :v | cls new interpolate: v; interpolateOut: v ].	]! !!RSSequentialAnimationTest methodsFor: 'tests' prior: 59183367!testAddingAnimations	self		addingInComposite: canvas sequentialAnimation		duration: 3 second! !!RSSequentialAnimationTest methodsFor: 'tests' prior: 59183526!testDuration	| animation |	animation := RSSequentialAnimation new.	self assert: animation duration equals: 0 seconds.	animation := RSSequentialAnimation new		add: (RSTransitionAnimation new duration: 2 seconds);		yourself.	self assert: animation duration equals: 2 seconds.	self assert: animation allDuration equals: 2 seconds.	animation := RSSequentialAnimation new		loops: 5;		add: (RSTransitionAnimation new duration: 2 seconds; loops: 5);		yourself.	self assert: animation duration equals: 10 seconds.	self assert: animation allDuration equals: 50 seconds.	animation := RSSequentialAnimation new		repeat;		add: (RSTransitionAnimation new duration: 2 seconds;  repeat);		yourself.	self assert: animation duration equals: 2 seconds.	self assert: animation allDuration equals: 2 seconds! !!RSSequentialAnimationTest methodsFor: 'tests' prior: 59183173!testSequentialAnimationCreation	self		createAnimationWith: [ canvas animationFrom: {} ]		animationClass: RSSequentialAnimation! !!RSSequentialAnimationTest methodsFor: 'tests' prior: 59182820!testStep	| value animation |	value := 0.	animation := RSSequentialAnimation new		add: (RSTransitionAnimation new			onStepDo: [ :t| value := value + 1 ]);		yourself.	canvas addAnimation: animation.	self assert: value equals: 0.	canvas playAnimations.	self assert: value equals: 1! !!RSSequentialAnimationTest methodsFor: 'tests' prior: 59182177!testStepEvent	| value loop animation |	value := nil.	loop := 0.	animation := RSSequentialAnimation new		loops: 3;		add: (RSTransitionAnimation new			duration: 100 milliSeconds;			onStepDo: [ :t| value := t ]);		when: RSAnimationLoopEvent do: [ :evt | loop := loop + 1.] for: self.	canvas addAnimation: animation.	self assert: value isNil.	self assert: loop equals: 0.	self assert: animation endTime isNil.	self runAnimation: animation threshold: 500.	self deny: value isNil.	self assert: loop equals: 3.	self deny: animation endTime isNil.	self deny: animation isRunning! !!RSTransitionAnimationTest methodsFor: 'tests' prior: 59467274!testDuration	| animation |	animation := RSTransitionAnimation new duration: 2 seconds.	self assert: animation duration equals: 2 seconds.	self assert: animation allDuration equals: 2 seconds.	animation := RSTransitionAnimation new duration: 2 seconds; loops: 5.	self assert: animation duration equals: 2 seconds.	self assert: animation allDuration equals: 10 seconds.	animation := RSTransitionAnimation new duration: 2 seconds; repeat.	self assert: animation duration equals: 2 seconds.	self assert: animation allDuration equals: 2 seconds! !!RSTransitionAnimationTest methodsFor: 'tests' prior: 59467028!testStep	| value |	value := 0.	canvas newAnimation		onStepDo: [ :t | value := value + 1 ].	self assert: value equals: 0.	canvas playAnimations.	self assert: value equals: 1! !!RSTransitionAnimationTest methodsFor: 'tests' prior: 59466461!testStepEvent	| value loop animation |	value := nil.	loop := 0.	animation := canvas newAnimation		duration: 100 milliSeconds;		loops: 3;		onStepDo: [ :t| value := t ];		when: RSAnimationLoopEvent do: [ :evt | loop := loop + 1.] for: self.	self assert: value isNil.	self assert: loop equals: 0.	self assert: animation endTime isNil.	self runAnimation: animation threshold: 3000.	self deny: value isNil.	self assert: loop equals: 3.	self deny: animation endTime isNil.	self deny: animation isRunning! !!RSTransitionAnimationTest methodsFor: 'tests' prior: 59468080!testStepReset	| animation |	animation := canvas newAnimation		duration: 100 milliSeconds.	self runAnimation: animation threshold: 500.	self deny: animation isRunning.	self assert: animation currentLoop equals: nil.	self assert: canvas animations size equals: 0.	animation reset;		duration: 100 milliSeconds.	canvas addAnimation: animation.	self assert: canvas animations size equals: 1.	self runAnimation: animation threshold: 500! !!RSTransitionAnimationTest methodsFor: 'tests' prior: 59467891!testTransitionAnimationCreation	self		createAnimationWith: [ canvas newAnimation ]		animationClass: RSTransitionAnimation! !!RSPAnimationTest class methodsFor: 'building suites' prior: 59024179!testParameters	| m classesToConsider |	m := ParametrizedTestMatrix new.	classesToConsider := RSAbstractAnimation allSubclasses select: [ :c | c subclasses isEmpty ].	classesToConsider do: [ :cls |		m addCase: { (#animationClass -> cls) }	].	^ m! !!RSPAnimationTest methodsFor: 'tests' prior: 59022671!testBasic	| animation |	animation := self animationClass new.	self assert: animation loops equals: 1.	self deny: animation hasCompleted.	self deny: animation isRunning.	self assert: animation startTime isNil.	self deny: animation isPaused.	animation start.	self assert: animation isRunning.	self deny: animation startTime isNil.	self deny: animation isPaused.	animation pause.	self assert: animation isPaused.	animation continue.	self deny: animation isPaused.	self assert: animation loops equals: 1.	self should: [animation loops: 0 ] raise: Error.	animation loops: 3.	self assert: animation loops equals: 3! !!RSPAnimationTest methodsFor: 'tests' prior: 59023458!testBasicInCanvas	| animation |	animation := self animationClass new.	canvas addAnimation: animation.	self assert: canvas animations size equals: 1.	self assert: animation isRunning.	self assert: animation duration equals: self animationClass defaultDuration! !!RSPAnimationTest methodsFor: 'tests' prior: 59023778!testDelay	| animation |	animation := self animationClass new.	animation delay: 100 milliSeconds.	animation start.	self deny: animation isDelayDone.	(Delay forMilliseconds: 201) wait.	self assert: animation isDelayDone! !!RSPAnimationTest methodsFor: 'tests' prior: 59022376!testError	| c shape ani |	c := RSCanvas new.	shape := RSCircle new color: Color gray.	c add: shape.	ani := c newAnimation				from: -50 @ -50;				to: 100 @ 0.	self should: [ ani on: shape set: #position ] raise: AssertionFailure! !!RSAnimationTest methodsFor: 'tests' prior: 58294709!addingInComposite: compositeAnimation duration: aDuration	compositeAnimation		add: (RSTransitionAnimation new			duration: 1 second);		add: (RSTransitionAnimation new			duration: 2 seconds).	canvas addAnimation: compositeAnimation.	self assert: compositeAnimation isRunning.	self assert: compositeAnimation duration equals: aDuration! !!RSAnimationTest methodsFor: 'tests' prior: 58294423!createAnimationWith: block animationClass: class	| animation |	self assert: canvas animations size equals: 0.	animation := block value.	self assert: canvas animations size equals: 1.	self assert: animation class equals: class! !!RSAnimationTest methodsFor: 'running' prior: 58294019!runAnimation: animation threshold: threshold	| time ended |	ended := false.	animation when: RSAnimationEndEvent do: [ :evt | ended := true ] for: self.	time := Time now asDuration.	[ ended ] whileFalse: [		(Time now asDuration - time) > threshold milliSeconds ifTrue: [			"time up"			self error: 'Time up'.			^ self ].		canvas playAnimations.		]! !!RSAnimationTest methodsFor: 'running' prior: 58295105!setUp	super setUp.	canvas := RSCanvas new! !!RSParallelAnimationTest methodsFor: 'tests' prior: 59029325!testAddingAnimations	self		addingInComposite: canvas parallelAnimation		duration: 2 second! !!RSParallelAnimationTest methodsFor: 'tests' prior: 59029480!testDuration	| animation |	animation := RSParallelAnimation new.	self assert: animation duration equals: 0 seconds.	animation := RSParallelAnimation new		add: (RSTransitionAnimation new duration: 2 seconds);		add: (RSTransitionAnimation new duration: 4 seconds);		yourself.	self assert: animation duration equals: 4 seconds.	self assert: animation allDuration equals: 4 seconds.	animation := RSParallelAnimation new		loops: 5;		add: (RSTransitionAnimation new duration: 2 seconds; loops: 5);		add: (RSTransitionAnimation new duration: 4 seconds);		yourself.	self assert: animation duration equals: 10 seconds.	self assert: animation allDuration equals: 50 seconds.	animation := RSParallelAnimation new		repeat;		add: (RSTransitionAnimation new duration: 2 seconds; repeat);		add: (RSTransitionAnimation new duration: 4 seconds);		yourself.	self assert: animation duration equals: 4 seconds.	self assert: animation allDuration equals: 4 seconds! !!RSParallelAnimationTest methodsFor: 'tests' prior: 59030515!testParallelAnimationCreation	self		createAnimationWith: [ canvas parallelAnimationFrom: {} ]		animationClass: RSParallelAnimation! !!RSParallelAnimationTest methodsFor: 'tests' prior: 59028899!testStep	| value animation |	value := 0.	animation := RSParallelAnimation new		add: (RSTransitionAnimation new			onStepDo: [ :t| value := value + 1 ]);		add: (RSTransitionAnimation new			onStepDo: [ :t| value := value + 1 ]);		yourself.	canvas addAnimation: animation.	self assert: value equals: 0.	canvas playAnimations.	self assert: value equals: 2! !!RSParallelAnimationTest methodsFor: 'tests' prior: 59028260!testStepEvent	| value loop animation |	value := nil.	loop := 0.	animation := RSParallelAnimation new		loops: 3;		add: (RSTransitionAnimation new			duration: 100 milliSeconds;			onStepDo: [ :t| value := t ]);		when: RSAnimationLoopEvent do: [ :evt | loop := loop + 1.] for: self.	canvas addAnimation: animation.	self assert: value isNil.	self assert: loop equals: 0.	self assert: animation endTime isNil.	self runAnimation: animation threshold: 500.	self deny: value isNil.	self assert: loop equals: 3.	self deny: animation endTime isNil.	self deny: animation isRunning! !"Roassal3-Animation-Tests"!!RSLineBuilderTest commentStamp: '' prior: 0!Tests for RSLineBuilder!!RSNormalizerTest methodsFor: 'tests' prior: 59002035!testBasic	| shapes |	shapes := (1 to: 2) collect: [ :n | RSBox new model: n; yourself ].	self assert: shapes size equals: 2.	self assert: shapes first color equals: Color lightGray.	RSNormalizer color		shapes: shapes;		normalize: #yourself.	self assert: shapes first color equals: Color green.	RSNormalizer size		shapes: shapes;		from: 100;		to: 200;		normalize: #yourself.	self assert: shapes first extent equals: 100@100.	self assert: shapes first extent equals: 100@100! !!RSLinesTest methodsFor: 'running' prior: 58946372!testArrowedLine	| line head other |	line := RSArrowedLine new.	line startPoint: 0@0; endPoint: 100@100.	head := line markerEnd.	self assert: head isNotNil.	head := head shape.	self assert: head class equals: RSPolygon.	line color: Color blue.	self assert: line color equals: Color blue.	self assert: head border color equals: Color blue.	line border: (RSBorder new width: 2; color: Color red).	self assert: line border width equals: 2.	self assert: line color equals: Color red.	self assert: head border width equals: 2.	self assert: line color equals: Color red.	other := line copy.	self deny: other equals: line.	self deny: other markerEnd hash equals: line markerEnd hash! !!RSLinesTest methodsFor: 'tests - colors' prior: 58949130!testColorLineAndMarker	| line |	line := RSShapeFactory arrowedLine.	line color: Color blue.	self		assert: line color equals: Color blue;		assert: line markerEnd shape borderColor equals: Color blue! !!RSLinesTest methodsFor: 'running' prior: 58947542!testDrawBezierLine	canvas addShape: (RSBezier new		strokeColor: Color red;		width: 2).	canvas createMorph drawOnMockCanvas! !!RSLinesTest methodsFor: 'running' prior: 58948639!testDrawLine	canvas addShape: (RSLine new		strokeColor: Color red;		width: 2).	canvas createMorph drawOnMockCanvas! !!RSLinesTest methodsFor: 'running' prior: 58948810!testDrawMarkers	| line m |	m := RSPolygon new		points: { -10@0. 0@ -10. 10@0 };		color: Color black;		size: 10.	line := RSLine new		startPoint: 50@50;		endPoint: 250@50.	line markerStart: m.	canvas addShape: line.	canvas createMorph drawOnMockCanvas! !!RSLinesTest methodsFor: 'running'!testEmptyFormat	| line |	line := RSLine new		startPoint: 0@0;		endPoint: 100@0;		yourself.	line format: ''.	self assert: line color equals: Color gray.	self assert: line markerStart isNil.! !!RSLinesTest methodsFor: 'running' prior: 58948137!testFmt	| line |	line := RSLine new		startPoint: 0@0;		endPoint: 100@0;		yourself.	self assert: line border style isNil.	self assert: line markerEnd isNil.	line format: '.^'.	self deny: line border style dashArray isNil.	self deny: line markerEnd isNil.	self deny: line markerStart isNil.	self assert: line markerEnd shape color equals: line color! !!RSLinesTest methodsFor: 'running'!testFormat	| line |	line := RSLine new		startPoint: 0@0;		endPoint: 100@0;		yourself.	line format: 'r-o'.	self assert: line color equals: Color red.	self assert: line markerEnd shape class equals: RSEllipse.	line format: 'gs'.	self assert: line color equals: Color green.	line format: 'bs'.	self assert: line color equals: Color blue.	self assert: line markerEnd shape class equals: RSPolygon! !!RSLinesTest methodsFor: 'running'!testFormatMarker	| line markerShape|	line := RSLine new		startPoint: 0@0;		endPoint: 100@0;		yourself.	line format: 'o'.	markerShape := line markerEnd shape.	self assert: markerShape class equals: RSEllipse.	self assert: markerShape extent equals: line markerSizeScale asPoint.	line format: 's'.	self deny: line markerEnd shape class equals: markerShape! !!RSLinesTest methodsFor: 'running' prior: 58947721!testLineIncludesPoint	| line |	line := RSLine new		startPoint: 0@0;		endPoint: 0@100;		width: 8;		yourself.	self assert: (line includesPoint: 0@0).	self assert: (line includesPoint: 0@100).	self assert: (line includesPoint: 0@50).	self assert: (line includesPoint: 4@50).	self deny: (line includesPoint: 5@50).	self deny: (line includesPoint: 500@500)! !!RSLinesTest methodsFor: 'running' prior: 58947124!testMarkerOffset	| line marker |	line := RSLine new		startPoint: 0@0;		endPoint: 100@0;		yourself.	marker := RSBox new size: 20; withBorder; noPaint; asMarker.	marker offsetRatio: 0.5.	line markerEnd: marker.	self assert: (line includesPoint: 50@ 9).	marker offset: 20.	self deny: (line includesPoint: 50@ 9).	self assert: (line includesPoint: 30@ 9)! !!RSLinesTest methodsFor: 'running' prior: 58945709!testMarkersIncludesPoint	| line marker |	line := RSLine new		startPoint: 0@ 0;		endPoint: 200@0;		yourself.	marker := RSBox new		size: 20;		asMarker.	self assert: (line includesPoint: 0@0).	self assert: (line includesPoint: 100@0).	self assert: (line includesPoint: 200@0).	self deny: (line includesPoint: 210@0).	self deny: (line includesPoint: 210@10).	self deny: (line includesPoint: 210@ -10).	line markerEnd: marker.	self assert: (line includesPoint: 210@0).	self assert: (line includesPoint: 200@9).	self assert: (line includesPoint: 210@ -10).	self deny: (line includesPoint: 210@ -11)! !!RSLinesTest methodsFor: 'running' prior: 58949386!testPolylineIncludesPoint	| line |	line := RSPolyline new.	line width: 10.	line controlPoints: { 0@0. 0@100 }.	self assert: (line includesPoint: 0@0).	self assert: (line includesPoint: 0@100).	self assert: (line includesPoint: 0@50).	self assert: (line includesPoint: 5@50).	self deny: (line includesPoint: 500@500).	self deny: (line includesPoint: 6@50)! !!RSLinesTest methodsFor: 'running'!testStroke	| line |	line := RSLine new		startPoint: 0@0;		endPoint: 100@0;		yourself.	line format: '--'.	self assert: line border dashArray equals: #(4 2).	line format: '-.'.	self assert: line border dashArray equals: #(4 1 1 1).	line format: '.'.	self assert: line border dashArray equals: #(1).! !!RSAthensRendererTest methodsFor: 'tests' prior: 58332996!testArcCorner	| renderer |	renderer := RSAthensRenderer new.	self assert: (renderer		arcCornerTangets: -17.172947580489485@ -71.29423293069038		p1: -58.258908750504766 @ -212.1459392757739		r: 220		rc: 11.316433244555238		cw: true)		equals: (-54.9506649278924@ 200.80455223867077) -> (-46.47771241701749@ 215.03446758248086)! !!RSCompositeTest methodsFor: 'tests' prior: 58548665!testAdjustChildren	| box circle g composite |	box := RSBox new size: 20.	circle := RSEllipse new size: 20.	g := RSGroup new.	g add: box; add: circle.	composite := g asShape.	self assert: composite extent equals: (20 @ 20).	RSVerticalLineLayout on: g.	self assert: composite extent equals: (20 @ 20).	composite adjustToChildren.	self assert: composite extent equals: (20 @ 45)! !!RSCompositeTest methodsFor: 'tests' prior: 58547617!testAdjustChildrenTwice	| box circle composite  |	box := RSBox new size: 20.	box position: 100@100.	circle := RSEllipse new size: 20.	circle position: 50@50.	composite := RSComposite new.	composite addAll: { box. circle }.	self assert: composite extent equals: composite defaultExtent.	self assert: composite position equals: 0@0.	composite adjustToChildren.	self assert: composite extent equals: 70@70.	self assert: composite position equals: 75@75.	self assert: box extent equals: 20@20.	self assert: box position equals: 25@25.	self assert: circle extent equals: 20@20.	self assert: circle position equals: -25@ -25.	composite adjustToChildren.	self assert: composite extent equals: 70@70.	self assert: composite position equals: 75@75! !!RSCompositeTest methodsFor: 'tests' prior: 58547240!testEdgesCanvasAndComposite01	"basic case in a canvas"	| c b1 b2 e1 |	c := RSCanvas new.	b1 := RSBox new position: 0 @ 0.	b2 := RSBox new position: 100 @ 100.	e1 := RSLine new from: b1; to: b2.	c addAll: { b1. b2. e1 }.	self assert: e1 startPoint equals: b1 position.	self assert: e1 endPoint equals: b2 position! !!RSCompositeTest methodsFor: 'tests' prior: 58545278!testEdgesCanvasAndComposite02	"basic example in composite"	| c b1 b2 e1 |	c := RSComposite new.	b1 := RSBox new position: 0@0.	b2 := RSBox new position: 100@100.	e1 := RSLine new from: b1; to: b2.	c shapes: { b1. b2. e1 }.	self assert: e1 startPoint equals: b1 position.	self assert: e1 endPoint equals: b2 position! !!RSCompositeTest methodsFor: 'tests' prior: 58546727!testEdgesCanvasAndComposite03	"from box to child"	| c b1 b2 e1 com |	c := RSCanvas new.	com := RSComposite new.	b1 := RSBox new size: 10; position: 0@0.	com add: b1.	com adjustToChildren.	b1 position: 50@50.	com position: 200@0.	b2 := RSBox new size: 10; position: 100@100.	e1 := RSLine new from: b1; to: b2.	c addAll: { com. b2. e1 }.	self assert: e1 startPoint equals: com position + b1 position.	self assert: e1 endPoint equals: b2 position! !!RSCompositeTest methodsFor: 'tests' prior: 58549110!testEdgesCanvasAndComposite04	"from child to child"	| c b1 b2 e1 com1 com2 |	c := RSCanvas new.	com1 := RSComposite new.	b1 := RSBox new size: 10; position: 0@0.	com1 add: b1.	com1 adjustToChildren.	b1 position: 50@50.	com1 position: 200@0.	com2 := RSComposite new.	b2 := RSBox new size: 10.	com2 add: b2.	com2 adjustToChildren.	com2 position: -100@0.	b2 position: 100@100.	e1 := RSLine new from: b1; to: b2.	c addAll: { com1. com2. e1 }.	self assert: e1 startPoint equals: com1 position + b1 position.	self assert: e1 endPoint equals: com2 position + b2 position! !!RSCompositeTest methodsFor: 'tests' prior: 58546158!testEdgesCanvasAndComposite05	"from child to box, where the edge is with the child"	| c b1 b2 e1 com |	c := RSCanvas new.	com := RSComposite new.	b1 := RSBox new size: 10; position: 50@50.	com add: b1.	b2 := RSBox new size: 10; position: 100@100.	e1 := RSLine new from: b1; to: b2.	com add: e1.	com adjustToChildren.	com position: 200@0.	c addAll: { com. b2. }.	self assert: e1 startPoint equals: b1 position.	"but b2 is not in the space of com"	self assert: e1 endPoint equals: b2 position! !!RSCompositeTest methodsFor: 'tests' prior: 58548430!testHasChildren	| b |	b := RSComposite new.	self deny: b hasChildren.	b shapes: {}.	self deny: b hasChildren.	b shapes: {RSBox new. RSEllipse new}.	self assert: b hasChildren! !!RSCompositeTest methodsFor: 'tests' prior: 58550038!testPaddingOkay	"No error should be raised"	RSComposite new		shapes: (RSGroup new add: RSBox new; yourself);		padding: 5.	RSComposite new		shapes: (RSGroup new add: RSBox new; add: RSBox new; yourself);		padding: 5.	RSComposite new		shapes: (RSGroup new);		padding: 5! !!RSCompositeTest methodsFor: 'tests' prior: 58545658!testPositionInCanvas	| box composite canvas |	canvas := RSCanvas new.	box := RSBox new		size: 100;		yourself.	composite := RSComposite new		shapes: { box };		position: 100@100;		yourself.	canvas add: composite.	box translateTo: 10@10.	self assert: composite position equals: 100@100.	self assert: composite positionInCanvas equals: 100@100.	self assert: box position equals: 10@10.	self assert: box positionInCanvas equals: 110@110! !!RSBoundingTest methodsFor: 'running' prior: 58385529!testDrawBitmap	canvas addShape: (RSBitmap new		form: (ColorForm extent: 100@100 depth: 32)).	canvas createMorph drawOnMockCanvas! !!RSBoundingTest methodsFor: 'running' prior: 58383967!testDrawBorder	canvas addShape: (RSEllipse new		radius: 100;		withBorder;		yourself).	canvas createMorph drawOnMockCanvas! !!RSBoundingTest methodsFor: 'running' prior: 58386224!testDrawBoxCornerRadius	canvas addShape: (RSBox new		extent: 100@100;		cornerRadius: 5;		yourself).	canvas createMorph drawOnMockCanvas! !!RSBoundingTest methodsFor: 'running' prior: 58384148!testDrawPolygon	canvas addShape: (RSPolygon new).	canvas addShape: (RSPolygon new		points: { 200@10. 250@190. 160@210 };		yourself).	canvas addShape: (RSPolygon new		cornerRadii: 20;		points: { 200@10. 250@190. 160@210 };		yourself).	self assert: canvas shapes second points equals: {(-5@ -100). (45@80). (-45@100)}.	canvas createMorph drawOnMockCanvas! !!RSBoundingTest methodsFor: 'running' prior: 58384565!testDrawRing	| r |	r := RSPieSlice new.	"empty"	canvas addShape: r.	"circle"	canvas addShape: (RSPieSlice new		innerRadius: 0;		externalRadius: 100;		alphaAngle: 0;		betaAngle: 360).	"slice"	canvas addShape: (RSPieSlice new		externalRadius: 100;		alphaAngle: 30;		betaAngle: 90;		segmentSpacing: 5).	"donut"	canvas addShape: (RSPieSlice new		externalRadius: 100;		innerRadius: 50;		alphaAngle: 0;		betaAngle: 360).	"corner radii"	canvas addShape: (RSPieSlice new		externalRadius: 100;		innerRadius: 50;		alphaAngle: 0;		betaAngle: 45;		cornerRadii: 20).	"same radius"	canvas addShape: (RSPieSlice new		externalRadius: 100;		innerRadius: 100;		alphaAngle: 0;		betaAngle: 45;		cornerRadii: 20).	canvas createMorph drawOnMockCanvas! !!RSBoundingTest methodsFor: 'tests' prior: 58383652!testFromRectangle	| box |	box := RSBox new.	self assert: box position equals: 0 @ 0.	self assert: box extent > (0 @ 0).	box fromRectangle: (10 @ 10 corner: 50 @ 40).	self assert: box position equals: 30 @ 25.	self assert: box extent equals: 40 @ 30! !!RSBoundingTest methodsFor: 'tests' prior: 58385383!testPosition	| b |	b := RSBox new.	self assert: b position equals: 0@0.	b position: 0@0! !!RSBoundingTest methodsFor: 'tests' prior: 58383398!testTranslateTopLeftTo	| b |	b := RSBox new size: 10.	b translateTopLeftTo: 0 @ 0.	self assert: b position equals: 5 @ 5.	b translateTopLeftTo: 10 @ 50.	self assert: b position equals: 15 @ 55! !!RSCanvasTest methodsFor: 'tests - shapes ordering' prior: 58455977!testAddShapeBefore	| shape1 shape2 |	shape1 := RSBox new size: 20.	shape2 := RSEllipse new size: 10.	canvas add: shape2.	canvas addShape: shape1 before: shape2.	self assert: canvas shapes asArray equals: { shape1 . shape2 }! !!RSCanvasTest methodsFor: 'tests' prior: 58456258!testAntialiasing	| morph |	canvas aaBest.	morph := canvas createMorph.	morph drawOnMockCanvas.	canvas aaNone.	morph drawOnMockCanvas.	self deny: canvas hasAntialiasing.	canvas enableAntialiasing.	canvas aaGray.	canvas aaFast.	canvas aaDefault! !!RSCanvasTest methodsFor: 'tests - composite' prior: 58454557!testAsForm	| form |	canvas add: RSBox new.	form := canvas asForm.	self assert: form isForm! !!RSCanvasTest methodsFor: 'tests - converting' prior: 58455168!testAsShapeModel	| c compositeShape |	c :=RSCanvas new.	c addAll: (RSBox models: (1 to: 20)).	RSGridLayout on: c shapes.	compositeShape := c asShapeModel: 'Hello'.	self assert: compositeShape class equals: RSComposite.	self assert: compositeShape model equals: 'Hello'.	self assert: compositeShape children size equals: 20! !!RSCanvasTest methodsFor: 'tests - coordinates'!testBasicCoordinates	canvas := RSCanvas new.	self assert: canvas originMode class equals: RSCamera originCenterMiddle class.		canvas originTopLeft.	self assert: canvas originMode class equals: RSCamera originTopLeft class.	self deny: canvas originMode class equals: RSCamera originCenterMiddle class.		canvas originCenterMiddle.	self assert: canvas originMode class equals: RSCamera originCenterMiddle class.! !!RSCanvasTest methodsFor: 'tests' prior: 58455551!testDeepNodes	| c compo box |	c := RSCanvas new.	compo := RSComposite new.	box := RSBox new.	compo addShape: box.	compo adjustToChildren.	c add: compo.	self assert: c numberOfNodes equals: 1.	self assert: c numberOfDeepNodes equals: 2.	self assert: c deepNodes size equals: 2.	self assert: (c deepNodes includesAll: {				 box.				 compo })! !!RSCanvasTest methodsFor: 'running' prior: 58458020!testDrawCanvas	canvas addShape: (RSBox new		extent: 100@100;		yourself).	canvas addShape: (RSEllipse new		position: 100@100;		extent: 100@100;		yourself).	canvas createMorph drawOnMockCanvas! !!RSCanvasTest methodsFor: 'running' prior: 58461897!testDrawCanvasWithGroup	| g |	g := RSComposite new.	g add: (RSBox new		extent: 100@100;		yourself).	g add: (RSEllipse new		position: 100@100;		extent: 100@100;		yourself).	canvas addShape: g.	canvas createMorph drawOnMockCanvas! !!RSCanvasTest methodsFor: 'running' prior: 58456774!testDrawFixed	| box |	box := RSBox new		extent: 100@100;		yourself.	box isFixed: true.	canvas addShape: box.	box := RSBox new		extent: 100@100;		yourself.	canvas addShape: box.	self deny: box isFixed.	box setAsFixed.	self assert: box isFixed.	self assert: canvas numberOfShapes equals: 0.	self assert: canvas numberOfFixedShapes equals: 2.	canvas createMorph drawOnMockCanvas! !!RSCanvasTest methodsFor: 'tests' prior: 58456562!testEncompassingRectangle	| rect |	rect := canvas encompassingRectangle.	self assert: rect equals: (Rectangle center: 0@0 extent: RSCamera minimumExtent)! !!RSCanvasTest methodsFor: 'events' prior: 58453871!testEvent	| box |	box := RSBox new.	box when: RSMouseClick do: [ :evt |  ] for: self! !!RSCanvasTest methodsFor: 'tests' prior: 58458520!testEventKnowsItsCanvas	| evt t |	evt := RSEvent new.	t := false.	canvas when: RSEvent do: [ :ex | t := true ] for: self.	canvas announce: evt.	self assert: evt canvas equals: canvas.	self assert: t! !!RSCanvasTest methodsFor: 'tests' prior: 58458269!testEventKnowsItsCanvas02	| evt shape |	shape := RSBox new size: 20.	canvas add: shape.	evt := RSShapeAddedEvent new shape: shape.	canvas announce: evt.	self assert: evt canvas equals: canvas! !!RSCanvasTest methodsFor: 'events' prior: 58450881!testLowLevelEvent	| box |	box := RSBox new size: 30.	box when: RSMouseDragging do: [ :evt | box ] for: self.	canvas addShape: box.	self assert: canvas extent equals: 500 asPoint.	self		assert: (canvas shapeWithAction: RSMouseDragging forPositionInPixels: 250 @ 250)		identicalTo: box! !!RSCanvasTest methodsFor: 'tests - opening' prior: 58459989!testMultipleOpenOnce	| c1 c2 win1 win2 |	c1 := RSCanvas new.	win1 := c1 openOnce.	c2 := RSCanvas new.	win2 := c2 openOnce.	[		self deny: win1 isDisplayed.		self assert: win2 isDisplayed	] ensure: [ win1 delete. win2 delete. ]! !!RSCanvasTest methodsFor: 'tests - composite' prior: 58460292!testNestedShape	| shape innerShape |	shape := RSComposite new.	canvas addShape: shape.	innerShape := RSBox new.	shape add: innerShape.	self assert: shape canvas equals: canvas.	self assert: innerShape parent equals: shape.	self assert: innerShape canvas equals: canvas! !!RSCanvasTest methodsFor: 'tests - composite' prior: 58458779!testNestedShapeNotAddedToACanvas	| shape innerShape |	shape := RSComposite new.	innerShape := RSBox new.	shape add: innerShape.	self assert: shape canvas isNil.	self assert: innerShape parent equals: shape.	self assert: innerShape canvas isNil! !!RSCanvasTest methodsFor: 'running' prior: 58461299!testNodesShapesAndEdges	| n1 n2 n3 eb nodes |	n1 := RSEllipse new size: 10; model: 1.	n2 := RSEllipse new size: 10; model: 2.	n3 := RSEllipse new size: 10; model: 3.	nodes := Array with: n1 with: n2 with: n3.	canvas addAll: nodes.	eb := RSLineBuilder line.	eb canvas: canvas.	eb useAssociations: (Array with: (1 -> 2) with: (2 -> 3) with: (3 -> 1)).	self assert: canvas shapes size equals: 6.	self assert: (canvas shapes includesAll: nodes).	self assert: canvas nodes equals: nodes asGroup.	self assert: canvas edges size equals: 3! !!RSCanvasTest methodsFor: 'tests - opening' prior: 58460634!testOpen	| c win |	c := RSCanvas new.	win := c open.	self assert: win class equals: SystemWindow.	win delete! !!RSCanvasTest methodsFor: 'tests - opening' prior: 58460809!testOpenOnce	| c win morph |	c := RSCanvas new.	win := c openOnce.	self assert: win class equals: SystemWindow.	morph := win findDeeplyA: RSAthensMorph.	self assert: morph class equals: RSAthensMorph.	self assert: morph canvas equals: c.	win delete! !!RSCanvasTest methodsFor: 'tests - shapes ordering' prior: 58459103!testPush	| c blueBox redBox |	c := RSCanvas new.	blueBox := RSBox new		          size: 80;		          color: #blue.	redBox := RSBox new		          size: 80;		          color: #red.	c		add: blueBox;		add: redBox.	blueBox translateBy: 40 @ 20.	"red is in front of blue"	self assert: c shapes asArray equals: { blueBox . redBox }.	redBox pushBack.	self assert: c shapes asArray equals: { redBox . blueBox }.	blueBox pushBack.	self assert: c shapes asArray equals: { blueBox . redBox }.	c pushBack: redBox.	self assert: c shapes asArray equals: { redBox . blueBox }! !!RSCanvasTest methodsFor: 'tests - shapes ordering' prior: 58454017!testPushBackEdges	| c blueBox redBox l |	c := RSCanvas new.	blueBox := RSBox new		          size: 80;		          color: #blue.	redBox := RSBox new		          size: 80;		          color: #red.	c		add: blueBox;		add: redBox.	blueBox translateBy: 40 @ 20.	l := RSLine new from: blueBox; to: redBox.	c add: l.	self assert: c shapes asArray equals: { blueBox . redBox . l }.	c pushBackEdges.	self assert: c shapes asArray equals: { l . blueBox . redBox }! !!RSCanvasTest methodsFor: 'tests - shapes ordering' prior: 58451642!testPushFront	| c blueBox redBox |	c := RSCanvas new.	blueBox := RSBox new		          size: 80;		          color: #blue.	redBox := RSBox new		          size: 80;		          color: #red.	c		add: blueBox;		add: redBox.	blueBox translateBy: 40 @ 20.	"red is in front of blue"	self assert: c shapes asArray equals: { blueBox . redBox }.	blueBox pushFront.	self assert: c shapes asArray equals: { redBox . blueBox }.	redBox pushFront.	self assert: c shapes asArray equals: { blueBox . redBox }.	c pushFront: blueBox.	self assert: c shapes asArray equals: { redBox . blueBox }.	c pushBack: blueBox.	self assert: c shapes asArray equals: { blueBox . redBox }! !!RSCanvasTest methodsFor: 'tests - shapes ordering' prior: 58459763!testRemovingShapes	| e |	e := RSEllipse new.	canvas addShape: e.	self assert: canvas shapes size equals: 1.	e remove.	self assert: canvas shapes size equals: 0! !!RSCanvasTest methodsFor: 'tests' prior: 58451212!testShapeFromModel	| shapes |	shapes := (1 to: 3) collect: [ :m | RSBox new model: m; yourself ].	canvas addAll: shapes.	self assert: (canvas shapeFromModel: 1) equals: shapes first.	self assert: (canvas shapeFromModel: 2) equals: shapes second.	self assert: (canvas shapeFromModel: 3) equals: shapes third.	self assert: (canvas shapeFromModel: 4) isNil! !!RSCanvasTest methodsFor: 'tests - composite' prior: 58452390!testShapeFromModelAndComposite	| compo |	compo := RSComposite new.	compo add: (RSBox new size: 20; model: 42).	compo model: 41.	canvas add: compo.	self assert: canvas numberOfShapes equals: 1.	self assert: (canvas shapeFromModel: 41) equals: compo.	self assert: (canvas shapeFromModel: 42) isNil.	self assert: (canvas deepShapeFromModel: 41) equals: compo.	self assert: (canvas deepShapeFromModel: 42) equals: compo children first.	self assert: (canvas deepShapeFromModel: 43) isNil! !!RSCanvasTest methodsFor: 'tests - composite' prior: 58452954!testShapeFromModelAndComposite2	| compo compo2 compo3 |	compo := RSComposite new.	compo add: (RSBox new size: 20; model: 42).	compo model: 41.	canvas add: compo.	compo2 := RSComposite new.	compo2 add: (RSBox new size: 20; model: 42).	compo2 model: 41.	canvas add: compo2.	compo3 := RSComposite new.	compo3 add: (RSBox new size: 20; model: 2).	compo3 model: 1.	canvas add: compo3.	self assert: canvas numberOfShapes equals: 3.	self assert: (canvas shapesFromModel: 41) asArray equals: { compo . compo2 }.	self assert: (canvas shapesFromModel: 42) isEmpty.	self assert: (canvas deepShapesFromModel: 41) asArray equals: { compo . compo2 }.	self assert: (canvas deepShapesFromModel: 42) asArray equals: { compo children first . compo2 children first }.	self assert: (canvas deepShapesFromModel: 2) asArray equals: { compo3 children first }! !!RSCanvasTest methodsFor: 'tests - composite' prior: 58457230!testShapeFromModelAndComposite3	| compo compo2 compo3 |	compo := RSComposite new.	compo add: (RSBox new size: 20; model: 42).	compo model: 41.	canvas add: compo.	compo2 := RSComposite new.	compo2 add: (RSBox new size: 20; model: 42).	compo2 model: 41.	canvas add: compo2.	compo3 := RSComposite new.	compo3 add: (RSBox new size: 20; model: 2).	compo3 model: 1.	canvas add: compo3.	self assert: canvas numberOfShapes equals: 3.	self assert: (canvas shapesFromModels: #(41 1)) asArray equals: { compo . compo2 . compo3 }.	self assert: (canvas shapesFromModels: #(42)) isEmpty.	self assert: (canvas deepShapesFromModels: #(41 42)) asArray equals: { compo . compo children first  . compo2 . compo2 children first }! !!RSCanvasTest methodsFor: 'tests - shapes ordering' prior: 58454722!testVisibleArea	| box smallSize bigSize |	smallSize := 100.	bigSize := 500.	box := RSBox new.	box size: smallSize asPoint.	box position: box extent / 2.	canvas add: box.	canvas extent: bigSize asPoint.	canvas visibleArea: (0 asPoint corner: smallSize asPoint).	self assert: canvas position equals: bigSize asPoint / -2.	self assert: canvas camera scale equals: bigSize / smallSize! !!RSLabelTest methodsFor: 'tests' prior: 58859990!testBuilding	| l |	l := RSLabel text: 'Hello'.	self assert: l class equals: RSLabel.	self assert: l text equals: 'Hello'! !!RSLabelTest methodsFor: 'tests' prior: 58858665!testBuilding2	| l |	l := RSLabel text: 'Hello' model: 42.	self assert: l class equals: RSLabel.	self assert: l text equals: 'Hello'.	self assert: l model equals: 42! !!RSLabelTest methodsFor: 'tests' prior: 58859264!testCairoCachedMetricProvider	| label provider |	label := RSLabel new.	label text: ''.	provider := RSCairoCachedMetricsProvider new.	label metricsProvider: provider.	self assert: label extent class equals: Point.	self assert: (provider extentsOf: label) class equals: RSTextExtents! !!RSLabelTest methodsFor: 'tests' prior: 58857678!testCairoFitMetricsProvider	| label h |	label := RSLabel new.	label text: '.'.	h := label height.	label metricsProvider: (RSCairoFitMetricsProvider new).	self assert: h > label height! !!RSLabelTest methodsFor: 'tests' prior: 58857917!testDrawBorderLabel	|  |	canvas addShape: (RSLabel new		withBorder;		color: (Color purple alpha: 0.5);		fontName: 'Source Sans Pro';		position: -50 @ 0;		text: 'Hello world!!';		yourself).	canvas createMorph drawOnMockCanvas! !!RSLabelTest methodsFor: 'tests' prior: 58860166!testDrawLabel	canvas addShape: (RSLabel new		color: (Color purple alpha: 0.5);		position: -50 @ 0;		text: 'Hello world!!';		yourself).	canvas createMorph drawOnMockCanvas! !!RSLabelTest methodsFor: 'tests' prior: 58859604!testHasChildren	| b |	b := RSLabel new.	self deny: b hasChildren! !!RSLabelTest methodsFor: 'tests' prior: 58858200!testModelWithoutText	| l |	l := RSLabel new.	self assert: l text isNil.	self assert: l model isNil.	l model: 42.	self assert: l model equals: 42.	self assert: l text equals: '42'! !!RSLabelTest methodsFor: 'tests' prior: 58859817!testSameSize	| l1 l2 |	l1 := RSLabel model: 123.	l2 := RSLabel new text: 123.	self assert: l1 extent equals: l2 extent! !!RSLabelTest methodsFor: 'tests' prior: 58858437!testUnderlineStruckout	| label |	label := RSLabel new.	self assert: label isNormal.	label underline.	label bold.	self assert: label isBold.	self assert: label isUnderlined! !!RSLabelTest methodsFor: 'tests' prior: 58858887!testWhiteSpace	| normalLabel labelWithSpace labelWithLargeSpace |	normalLabel := RSLabel new text: 'test'.	labelWithSpace := RSLabel new text: ' test'.	labelWithLargeSpace := RSLabel new text: '    test'.	self assert: normalLabel width < labelWithSpace width.	self assert: labelWithSpace width < labelWithLargeSpace width! !!RSGroupTest methodsFor: 'tests' prior: 58720382!testAddShape	| g |	g := RSGroup new.	g add: RSBox new! !!RSGroupTest methodsFor: 'tests' prior: 58719353!testCache01	| shapes shape |	shapes := (1 to: 5) collect: [:n | RSBox new model: n; yourself ] as: RSGroup.	self assert: shapes class equals: RSGroup.	self assert: shapes shapeFromModelCache isEmpty.	shape := shapes shapeFromModel: 2.	self assert: shape class equals: RSBox.	self assert: shape model equals: 2.	self deny: shapes shapeFromModelCache isEmpty! !!RSGroupTest methodsFor: 'tests' prior: 58718565!testCache02	| shapes s sps |	shapes := #(1 1) collect: [:n | RSBox new model: n; yourself] as: RSGroup.	s := shapes shapeFromModel: 1.	self assert: s class equals: RSBox.	self assert: s model equals: 1.	sps := shapes shapesFromModel: 1.	self assert: sps class equals: RSGroup.	self assert: sps size equals: 2! !!RSGroupTest methodsFor: 'tests' prior: 58717986!testCache03	| shapes shape |	shapes := #(1 1) collect: [:n | RSBox new model: n; yourself] as: RSGroup.	shapes shapesFromModel: 1.	shape := shapes shapeFromModel: 1.	self assert: shape class equals: RSBox.	self assert: shape model equals: 1! !!RSGroupTest methodsFor: 'tests' prior: 58720055!testCache04	| es |	es := #(1) collect: [:n | RSBox new model: n; yourself] as: RSGroup.	self assert: (es shapesFromModel: 1) size equals: 1.	es addAll: (#(1) collect: [:n | RSBox new model: n; yourself] as: RSGroup).	self assert: (es shapesFromModel: 1) size equals: 2! !!RSGroupTest methodsFor: 'tests' prior: 58720913!testDrawGroup	| g c com |	c := RSCanvas new.	g := RSGroup new.	g add: RSBox new.	com := RSComposite new		shapes: g.	c addShape: com.	self assert: c numberOfShapes equals: 1.	c createMorph drawOnMockCanvas! !!RSGroupTest methodsFor: 'tests' prior: 58721176!testModels	| g |	g := RSGroup new.	g add: RSBox new.	g add: RSBox new.	g add: RSBox new.	self assert: (g allSatisfy: [ :s | s model isNil ]).	g models: #('hello' 'world' 'bonjour').	self assert: (g collect: [ :s | s model ]) asArray equals: #('hello' 'world' 'bonjour')! !!RSGroupTest methodsFor: 'tests' prior: 58720659!testNodesAndLines	| g |	g := RSGroup new.	g addAll: (RSCircle models: (1 to: 10)).	g addAll: (RSLine models: (1 to: 5)).	self assert: g nodes size equals: 10.	self assert: g lines size equals: 5! !!RSGroupTest methodsFor: 'tests' prior: 58718287!testShapeFromModel	| group |	group := (1 to: 5) collect: [:n | RSBox new model: n; yourself] as: RSGroup.	self assert: (group shapeFromModel: 1) equals: group first.	self assert: (group shapeFromModel: 5) equals: group last! !!RSGroupTest methodsFor: 'tests' prior: 58718935!testTranslateTopLeftTo	| g |	g := RSBox models: #(1 2).	RSHorizontalLineLayout on: g.	self assert: (g collect: #position as: Array) equals: {(5.0@5.0). (20.0@5.0)}.	self assert: g position equals: 12 @ 5.	g translateTopLeftTo: 40 @ 42.	self assert: (g collect: #position as: Array) equals: {(45.0@47.0). (60.0@47.0)}.	self assert: g position equals: 52 @ 47! !!RSGroupTest methodsFor: 'tests' prior: 58719772!testTranslucent	| g |	g := RSGroup new.	g add: RSBox new.	g add: RSBox new.	g add: RSBox new.	self assert: (g allSatisfy: [ :s | s color alpha = 1 ]).	g translucent.	self assert: (g allSatisfy: [ :s | s color alpha < 1 ])! !!RSCircleTest methodsFor: 'tests' prior: 58495421!testCenter	| center circle |	center := 100 asPoint.	circle := RSCircle new		radius: 10;		center: center;		yourself.	self assert: circle center equals: center! !!RSPBoundingTest class methodsFor: 'building suites' prior: 59025292!testParameters	| m classesToConsider |	m := ParametrizedTestMatrix new.	classesToConsider := RSBoundingShape allSubclasses select: [ :c | c isAbstract not ].	classesToConsider do: [ :cls |		m addCase: { (#shapeClass -> cls) }	].	^ m! !!RSPBoundingTest methodsFor: 'tests' prior: 59024679!testDraw	canvas addShape: (self shapeClass new extent: 50 @ 50).	canvas createMorph drawOnMockCanvas! !!RSPBoundingTest methodsFor: 'tests' prior: 59024487!testDrawBorder	canvas addShape: (self shapeClass new		extent: 100 @ 100;		withBorder;		yourself).	canvas createMorph drawOnMockCanvas! !!RSPBoundingTest methodsFor: 'tests' prior: 59024835!testPosition	| b |	b := self shapeClass new.	self assert: b position equals: 0@0.	b position: 0@0! !!RSLineBuilderTest methodsFor: 'running'!setUp	super setUp.	canvas := RSCanvas new.	shapes := (1 to: 10) collect: [ :n | RSBox new model: n; size: 5; yourself ] as: RSGroup.	canvas addAll: shapes.	b := RSLineBuilder line! !!RSLineBuilderTest methodsFor: 'tests'!testAllowRepetitionAndUseAssociations	| eb |	canvas := RSCanvas new.	canvas addAll: ((1 to: 3) collect: [ :n | RSBox new model: n; yourself] ).	eb := RSLineBuilder line.	eb canvas: canvas.	eb color: (Color red alpha: 0.5).	eb noRepetition.	eb useAssociations: (Array with: 1 -> 2 with: 2 -> 3 with: 1 -> 2).	(Smalltalk globals at: #RSGridLayout)  on: canvas nodes.	self assert: canvas numberOfEdges equals: 2! !!RSLineBuilderTest methodsFor: 'tests'!testBorder	| numberOfLines |	b canvas: canvas.	b connectFrom: [ :vv | vv // 2 ].	numberOfLines := canvas lines size.	self assert: numberOfLines > 0.	self assert: (canvas edges collect: #border) asSet size equals: 1! !!RSLineBuilderTest methodsFor: 'tests'!testConnectFrom	| e |	b canvas: canvas.	b objects: #(1 2).	b connectFrom: [ :v | v - 1 ].	self assert: canvas numberOfEdges equals: 1.	e := canvas lines anyOne.	self assert: e from model equals: 1.	self assert: e to model equals: 2! !!RSLineBuilderTest methodsFor: 'tests'!testConnectFromAll	| c es |	c := RSCanvas new.	es := (1 to: 2) collect: [ :m | RSEllipse new size: 20; model: m; yourself ].	c addAll: es.	self assert: c lines size equals: 0.	RSLineBuilder line		canvas: c;		objects: (1 to: 2);		connectFromAll: (Array with: 1) to: 2.	(Smalltalk globals at: #RSTreeLayout) on: es.	self assert: c lines size equals: 1.	self assert: c lines first from position equals: (15.0@15.0).	self assert: c lines first to position equals: (15.0@55.0)! !!RSLineBuilderTest methodsFor: 'tests'!testConnectTo	| e |	b canvas: canvas.	b objects: #(1 2).	b connectTo: [ :v | v - 1 ].	self assert: canvas numberOfEdges equals: 1.	e := canvas edges anyOne.	self assert: e from model equals: 2.	self assert: e to model equals: 1! !!RSLineBuilderTest methodsFor: 'tests'!testConnectToAll	| eFrom eTo |	b canvas: canvas.	b objects: #(1 2 3).	b connectToAll: [ :v | Array with: v - 1 with: v - 2 ].	self assert: canvas numberOfEdges equals: 3.	eFrom := (canvas edges collect: [ :edge | edge from model ]) sorted asArray.	eTo := (canvas edges collect: [ :edge | edge to model ]) sorted asArray.	self assert: eFrom equals: #(2 3 3).	self assert: eTo equals: #(1 1 2)! !!RSLineBuilderTest methodsFor: 'tests'!testDefault	self assert: canvas numberOfEdges equals: 0! !!RSLineBuilderTest methodsFor: 'tests'!testElements	| es |	b := RSLineBuilder line.	b canvas: canvas.	self assert: b fromShapes equals: canvas nodes.	es := (1 to: 4) collect: [:n | RSBox new model: n; yourself] as: RSGroup.	b shapes: es.	self assert: b fromShapes equals: es! !!RSLineBuilderTest methodsFor: 'tests'!testElementsToLookup	| es1 es2 edges c |	es1 := #(1 2 3) collect: [:n | RSEllipse new model: n; yourself].	es2 := #(1 2 3) collect: [:n | RSBox new model: n; yourself].	c := RSCanvas new.	c addAll: es1.	c addAll: es2.	edges := RSLineBuilder line					canvas: c;					fromShapes: es1;					toShapes: es2;					connectTo: #yourself.	self assert: edges size equals: 3.	self assert: edges first from equals: es1 first.	self assert: edges first to equals: es2 first! !!RSLineBuilderTest methodsFor: 'tests - error'!testErrors	| eb |	eb := RSLineBuilder line.	self should: [ eb shapes: #(1 2 3) ] raise: AssertionFailure.	self should: [ eb shapes: 'hello world' ] raise: AssertionFailure.	self should: [ eb shapes: 42 ] raise: AssertionFailure! !!RSLineBuilderTest methodsFor: 'tests'!testFromObjects	| edges |	b canvas: canvas.	b fromObjects: #(1 2).	b connectFrom: #yourself to: 10.	self assert: canvas numberOfEdges equals: 2.	edges := canvas edges.	self assert: edges first from model equals: 1.	self assert: edges first to model equals: 10.	self assert: b toObjects asArray equals: (1 to: 10) asArray.	self assert: b fromObjects asArray equals: #(1 2)! !!RSLineBuilderTest methodsFor: 'tests'!testFromObjects02	b canvas: canvas.	b fromObjects: #(1).	b connectFrom: #yourself to: 10.	self assert: canvas numberOfEdges equals: 1.	self assert: b toObjects asArray equals: (1 to: 10) asArray.	self assert: b fromObjects asArray equals: #(1)! !!RSLineBuilderTest methodsFor: 'tests'!testFromObjectsError"view := RTView new.	elements := RTBox elementsOn: (1 to: 10).	view addAll: elements.	b := RTEdgeBuilder new."	self should: [ RSLineBuilder new  fromObjects: #(1 2) ] raise: Error! !!RSLineBuilderTest methodsFor: 'tests'!testFromObjectsToElements	| edges |	b canvas: canvas.	edges :=		b fromObjects: #(1 2);			toShapes: (shapes copyFrom: 10 to: 10);			connectTo: 10.	self assert: edges size equals: 2! !!RSLineBuilderTest methodsFor: 'tests'!testHasEdges	| s1 s2 |	s1 := canvas nodes first.	s2 := canvas nodes second.	self deny: s1 hasEdges.	self deny: s2 hasEdges.	b canvas: canvas.	b objects: #(1 2).	b connectTo: [ :v | v - 1 ].	self assert: s1 hasEdges.	self assert: s2 hasEdges.	self assert: s1 connectedLines size equals: 1! !!RSLineBuilderTest methodsFor: 'tests'!testInferCanvas	self assert: b canvas isNil.	b toShapes: canvas nodes.	self assert: b canvas isNil.	b fromShapes: canvas nodes.	self assert: b canvas equals: canvas! !!RSLineBuilderTest methodsFor: 'tests'!testInferCanvas2	self assert: b canvas isNil.	b shapes: canvas nodes.	self assert: b canvas equals: canvas! !!RSLineBuilderTest methodsFor: 'tests'!testInferCanvas3	| c |	c := RSCanvas new.	1 to: 100 do: [ :i |		c add: (RSLabel new				 text: i;				 model: i) ].	RSLineBuilder line		shapes: c nodes;		connectFrom: [ :i | i // 2 ].	RSGridLayout on: c nodes.	self assert: c numberOfEdges equals: 99! !!RSLineBuilderTest methodsFor: 'tests'!testInit	| eb |	eb := RSLineBuilder line.	self deny: eb shouldAllowRepetition.	eb allowRepetition.	self assert: eb shouldAllowRepetition! !!RSLineBuilderTest methodsFor: 'tests'!testNoMoveBehind	RSLineBuilder line		canvas: canvas;		useAssociations: (Array									with: 1 -> 2									with: 2 -> 3									with: 5 -> 6).	self assert: (canvas canvas shapes collect: [ :c | c class name ]) asArray equals: #(#RSBox #RSBox #RSBox #RSBox #RSBox #RSBox #RSBox #RSBox #RSBox #RSBox #RSLine #RSLine #RSLine)! !!RSLineBuilderTest methodsFor: 'tests'!testObjectFrom	| e |	b canvas: canvas.	b objects: #(1 2); connectFrom: [ :v | v - 1 ].	self assert: canvas numberOfEdges equals: 1.	e := canvas edges anyOne.	self assert: e from model equals: 1.	self assert: e to model equals: 2! !!RSLineBuilderTest methodsFor: 'tests'!testObjectTo	| e |	b canvas: canvas.	b objects: #(1 2); connectTo: [ :v | v - 1 ].	self assert: canvas numberOfEdges equals: 1.	e := canvas edges anyOne.	self assert: e from model equals: 2.	self assert: e to model equals: 1! !!RSLineBuilderTest methodsFor: 'tests'!testObjects	b canvas: canvas.	b objects: (1 to: 5).	self assert: b fromShapes equals: (shapes copyFrom: 1 to: 5)"	view := RTView new.	elements := RTBox elementsOn: (1 to: 10).	view addAll: elements.	b := RTEdgeBuilder new."! !!RSLineBuilderTest methodsFor: 'tests'!testObjects02	b canvas: canvas.	b objects: #even.	self assert: (b fromShapes collect: #model) asArray equals: #(2 4 6 8 10)! !!RSLineBuilderTest methodsFor: 'tests'!testObjects03	b canvas: canvas.	b objects: #odd.	self assert: (b fromShapes collect: #model) asArray equals: #(1 3 5 7 9)! !!RSLineBuilderTest methodsFor: 'tests'!testShouldAllowBidirection	self assert: canvas numberOfEdges equals: 0.	self assert: b isBidirectional.	b canvas: canvas.	b noBidirectional.	b objects: #(1 2).	b useAssociations: (Array with: 1 -> 2 with: 2 -> 1 ).	self deny: b isBidirectional.	shapes := canvas shapesFromModels: #(1 2).	self assert: shapes size equals: 2.	self assert: (b shouldCreateEdgeFrom: shapes first to: shapes second).	self assert: canvas numberOfEdges equals: 1.	self assert: canvas edges anyOne from model equals: 1.	self assert: canvas edges anyOne to model equals: 2! !!RSLineBuilderTest methodsFor: 'tests'!testShouldNotAllowBidirection	self assert: canvas numberOfEdges equals: 0.	b canvas: canvas.	b objects: #(1 2).	b useAssociations: (Array with: 1 -> 2 with: 2 -> 1).	self assert: canvas numberOfEdges equals: 2! !!RSLineBuilderTest methodsFor: 'tests'!testShouldNotInstantiate	self should: [ RSLineBuilder new ] raise: Error! !!RSLineBuilderTest methodsFor: 'tests'!testSimple	RSLineBuilder line		canvas: canvas;		useElementAssociations: (Array									with: shapes first -> shapes second									with: shapes second -> shapes third).	self assert: canvas numberOfEdges equals: 2! !!RSLineBuilderTest methodsFor: 'tests'!testSimple2	RSLineBuilder line		canvas: canvas;		useAssociations: (Array									with: 1 -> 2									with: 2 -> 3									with: 5 -> 6).	self assert: canvas numberOfEdges equals: 3! !!RSLineBuilderTest methodsFor: 'tests'!testSimple3	RSLineBuilder line		canvas: canvas;		fromObjects: #(1 2 3 6);		toObjects: (1 to: 10);		connectFrom: #yourself to: [ :v | v + 1 ].	self assert: canvas numberOfEdges equals: 4.	self assert: (canvas edges collect: [ :e | e from model -> e to model ]) asArray equals: ((Array new: 4) at: 1 put: (1->2); at: 2 put: (2->3); at: 3 put: (3->4); at: 4 put: (6->7); yourself)! !!RSLineBuilderTest methodsFor: 'tests'!testSimple4	RSLineBuilder line		canvas: canvas;		fromObjects: #(1 2 3 6);		toObjects: #(1 2 3 6);		connectFrom: #yourself to: [ :v | v + 1 ].	self assert: canvas numberOfEdges equals: 2.	self assert: (canvas edges collect: [ :e | e from model -> e to model ]) asArray equals: ((Array new: 2) at: 1 put: (1->2); at: 2 put: (2->3); yourself)! !!RSLineBuilderTest methodsFor: 'tests'!testSimple5	RSLineBuilder line		canvas: canvas;		fromObjects: #(1 2 3 6);		connectFrom: #yourself toAll: [ :v | Array with: v + 1 with: v + 2 ].	self assert: canvas numberOfEdges equals: 8! !!RSLineBuilderTest methodsFor: 'tests'!testSimple6	RSLineBuilder line		canvas: canvas;		fromObjects: (Array with: 2);		connectFromAll: (Array with: 2) to: 3.	self assert: canvas numberOfEdges equals: 1! !!RSLineBuilderTest methodsFor: 'tests'!testSimple7	RSLineBuilder line		canvas: canvas;		useAssociation: 1 -> 2;		useAssociation: 2 -> 3;		useAssociation: 5 -> 6.	self assert: canvas numberOfEdges equals: 3! !!RSLineBuilderTest methodsFor: 'tests'!testSource	| c es eb col |	c := RSCanvas new.	es := #(1 2 3) collect: [:n | RSBox new model: n; yourself].	c addAll: es.	eb := RSLineBuilder line.	eb canvas: c.	col := OrderedCollection new.	col add: 1 -> 2.	col add: 3 -> 1.	eb source: col connectFrom: #key to: #value.	self assert: c numberOfEdges equals: 2! !!RSLineBuilderTest methodsFor: 'tests'!testToObjects	b canvas: canvas.	b toObjects: #(1 2).	b connectFrom: #yourself to: 10.	self assert: canvas numberOfEdges equals: 0.	self assert: b toObjects asArray equals: #(1 2).	self assert: b fromObjects asArray equals: (1 to: 10) asArray! !!RSLineBuilderTest methodsFor: 'tests'!testWithMoveBehind	RSLineBuilder line		canvas: canvas;		moveBehind;		useAssociations: (Array									with: 1 -> 2									with: 2 -> 3									with: 5 -> 6).	self assert: (canvas canvas shapes collect: [ :c | c class name ]) asArray equals: #(#RSLine #RSLine #RSLine #RSBox #RSBox #RSBox #RSBox #RSBox #RSBox #RSBox #RSBox #RSBox #RSBox)! !!RSLineBuilderTest methodsFor: 'tests'!testWithMoveBehind02	RSLineBuilder line		canvas: canvas;		moveBehind;		connectFrom: [ :v | v - 1 ].	self assert: (canvas canvas shapes collect: [ :c | c class name ]) asArray equals: #(#RSLine #RSLine #RSLine #RSLine #RSLine #RSLine #RSLine #RSLine #RSLine #RSBox #RSBox #RSBox #RSBox #RSBox #RSBox #RSBox #RSBox #RSBox #RSBox)! !!RSLineBuilderTest methodsFor: 'tests'!testconnectFromToAll	| es1 es2 edges c |	es1 := #(1 2 3) collect: [:n | RSEllipse new model: n; yourself].	es2 := #(1 2 3) collect: [:n | RSBox new model: n; yourself].	c := RSCanvas new.	c addAll: es1; addAll: es2.	edges := RSLineBuilder line					canvas: c;					fromShapes: es1;					toShapes: es2;					connectFrom: #yourself toAll: [ :obj | Array with: obj ].	self assert: edges size equals: 3.	self assert: edges first from equals: es1 first.	self assert: edges first to equals: es2 first! !!RSPLinesTest class methodsFor: 'building suites' prior: 59026882!testParameters	| m classesToConsider |	m := ParametrizedTestMatrix new.	classesToConsider := RSAbstractLine allSubclasses select: [ :c | c isAbstract not ].	classesToConsider do: [ :cls |		m addCase: { (#shapeClass -> cls) }	].	^ m! !!RSPLinesTest methodsFor: 'tests' prior: 59025585!testDraw	canvas addShape: (self shapeClass new		strokeColor: Color red;		width: 2).	canvas createMorph drawOnMockCanvas! !RSEdgeBuilderTest removeSelector: #testconnectFromToAll!RSEdgeBuilderTest removeSelector: #testWithMoveBehind02!RSEdgeBuilderTest removeSelector: #testWithMoveBehind!RSEdgeBuilderTest removeSelector: #testToObjects!RSEdgeBuilderTest removeSelector: #testSource!RSEdgeBuilderTest removeSelector: #testSimple7!RSEdgeBuilderTest removeSelector: #testSimple6!RSEdgeBuilderTest removeSelector: #testSimple5!RSEdgeBuilderTest removeSelector: #testSimple4!RSEdgeBuilderTest removeSelector: #testSimple3!RSEdgeBuilderTest removeSelector: #testSimple2!RSEdgeBuilderTest removeSelector: #testSimple!RSEdgeBuilderTest removeSelector: #testShouldNotInstantiate!RSEdgeBuilderTest removeSelector: #testShouldNotAllowBidirection!RSEdgeBuilderTest removeSelector: #testShouldAllowBidirection!RSEdgeBuilderTest removeSelector: #testObjects03!RSEdgeBuilderTest removeSelector: #testObjects02!RSEdgeBuilderTest removeSelector: #testObjects!RSEdgeBuilderTest removeSelector: #testObjectTo!RSEdgeBuilderTest removeSelector: #testObjectFrom!RSEdgeBuilderTest removeSelector: #testNoMoveBehind!RSEdgeBuilderTest removeSelector: #testInit!RSEdgeBuilderTest removeSelector: #testInferCanvas3!RSEdgeBuilderTest removeSelector: #testInferCanvas2!RSEdgeBuilderTest removeSelector: #testInferCanvas!RSEdgeBuilderTest removeSelector: #testHasEdges!RSEdgeBuilderTest removeSelector: #testFromObjectsToElements!RSEdgeBuilderTest removeSelector: #testFromObjectsError!RSEdgeBuilderTest removeSelector: #testFromObjects02!RSEdgeBuilderTest removeSelector: #testFromObjects!RSEdgeBuilderTest removeSelector: #testErrors!RSEdgeBuilderTest removeSelector: #testElementsToLookup!RSEdgeBuilderTest removeSelector: #testElements!RSEdgeBuilderTest removeSelector: #testDefault!RSEdgeBuilderTest removeSelector: #testConnectToAll!RSEdgeBuilderTest removeSelector: #testConnectTo!RSEdgeBuilderTest removeSelector: #testConnectFromAll!RSEdgeBuilderTest removeSelector: #testConnectFrom!RSEdgeBuilderTest removeSelector: #testBorder!RSEdgeBuilderTest removeSelector: #testAllowRepetitionAndUseAssociations!RSEdgeBuilderTest removeSelector: #setUp!Smalltalk globals removeClassNamed: #AnObsoleteRSEdgeBuilderTest!"Roassal3-Shapes-Tests"!!RSCanvasControllerTest methodsFor: 'tests' prior: 58449963!testBasic	| canvas controller |	canvas := RSCanvas new.	canvas @ self classToTest.	controller := canvas controllerInteraction.	self assert: controller class equals: self classToTest.	canvas @ self classToTest.	self assert: controller equals: canvas controllerInteraction.	self assert: canvas fixedShapes size equals: 3! !!RSCanvasControllerTest methodsFor: 'tests' prior: 58449060!testNoLegend	| canvas controller |	canvas := RSCanvas new.	controller := self classToTest new.	controller noLegend.	canvas addInteraction: controller.	self assert: canvas fixedShapes size equals: 2! !!RSCanvasControllerTest methodsFor: 'tests'!testNoZoomToFitOnExtendChanged	| controller |	controller := RSCanvasController new.	controller zoomToFitInteraction noZoomToFitOnExtendChanged			! !!RSCanvasControllerTest methodsFor: 'tests' prior: 58449324!testZoomToFitOnStart	| canvas box controller window scale pixelPosition newPixelPosition |	canvas := RSCanvas new.	box := RSBox new		position: 1000 asPoint;		extent: 100 asPoint;		yourself.	canvas add: box.	controller := self classToTest new.	canvas addInteraction: controller.	self assert: canvas position equals: 0@0.	window := canvas open.	window delete.	canvas morph drawOnMockCanvas.	pixelPosition := canvas camera fromSpaceToPixel: box position.	self assert: pixelPosition equals: canvas extent / 2.	scale := canvas camera scale.	canvas extent: 100@100.	newPixelPosition := canvas camera fromSpaceToPixel: box position.	self assert: newPixelPosition equals: canvas extent / 2.	self deny: newPixelPosition equals: pixelPosition.	self assert: scale equals: canvas camera scale! !!RSSearchInCanvasTest methodsFor: 'running' prior: 59168774!setUp	super setUp.	c := RSCanvas new.	shapes := (1 to: 10) * 100		collect: [ :n |			RSEllipse new				size: 20;				color: Color gray;				model: n ]		as: RSGroup.	c addAll: shapes.	RSGridLayout on: shapes.	shapes @ RSPopup.	con := RSCanvasController new.	search := RSSearchInCanvasInteraction new.	con addInteraction: search.	search canvas: c.	c @ con! !!RSSearchInCanvasTest methodsFor: 'tests' prior: 59168239!testBasic	search searchForShapes: '*4*'.	self assert: (shapes fourth hasProperty: #shadow).	self deny: (shapes fifth hasProperty: #shadow).	search searchForShapes: '*5*'.	self assert: (shapes fourth hasProperty: #shadow).	self assert: (shapes fifth hasProperty: #shadow).	self assert: search numberOfHighlightedShapes equals: 2.	search resetAllHighlightedShapes.	self deny: (shapes fourth hasProperty: #shadow).	self deny: (shapes fifth hasProperty: #shadow)! !!RSSearchInCanvasTest methodsFor: 'tests' prior: 59166958!testExactMatch	search useExactMatch.	search searchForShapes: '4'.	self deny: (shapes fourth hasProperty: #shadow).	search doNotUseExactMatch.	search searchForShapes: '4'.	self assert: (shapes fourth hasProperty: #shadow)! !!RSSearchInCanvasTest methodsFor: 'tests' prior: 59169819!testFixedShapes	self assert: c numberOfFixedShapes equals: 3.	search searchForShapes: '*4*'.	self assert: c numberOfFixedShapes equals: 4.	search searchForShapes: '*5*'.	self assert: c numberOfFixedShapes equals: 5.	search resetAllHighlightedShapes.	self assert: c numberOfFixedShapes equals: 3! !!RSSearchInCanvasTest methodsFor: 'tests' prior: 59167245!testFixedShapesAndPopup	| lbl |	search searchForShapes: '*4*'.	lbl := search fixedLabels first.	lbl announce: RSMouseEnter new! !!RSSearchInCanvasTest methodsFor: 'tests' prior: 59167945!testIsRegExpValid	self deny: (search isRegExpValid: '').	self deny: (search isRegExpValid: nil)! !!RSSearchInCanvasTest methodsFor: 'tests' prior: 59167435!testNumberOfHighlightedShapes	self assert: search numberOfHighlightedShapes equals: 0.	search searchForShapes: '*4*'.	self assert: search numberOfHighlightedShapes equals: 1.	search searchForShapes: '*5*'.	self assert: search numberOfHighlightedShapes equals: 2.	search searchForShapes: '*3*'.	self assert: search numberOfHighlightedShapes equals: 3.	search resetAllHighlightedShapes.	self assert: search numberOfHighlightedShapes equals: 0! !!RSSearchInCanvasTest methodsFor: 'tests' prior: 59166080!testShadow	self assert: search numberOfPerformedSearches equals: 0.	search searchForShapes: '*4*'.	self assert: (shapes fourth hasProperty: #shadow).	self deny: (shapes fifth hasProperty: #shadow).	self assert: search numberOfPerformedSearches equals: 1.	search searchForShapes: '*5*'.	self assert: (shapes fourth hasProperty: #shadow).	self assert: (shapes fifth hasProperty: #shadow).	self		deny: (shapes fourth propertyAt: #shadow) color		equals: (shapes fifth propertyAt: #shadow) color.	self assert: search numberOfPerformedSearches equals: 2.	self assert: search numberOfHighlightedShapes equals: 2.	search resetAllHighlightedShapes.	self deny: (shapes fourth hasProperty: #shadow).	self deny: (shapes fifth hasProperty: #shadow).	self assert: search numberOfPerformedSearches equals: 0! !!RSSearchInCanvasTest methodsFor: 'tests' prior: 59170182!testUpdateShadowSize	| shadow extent |	self assert: search numberOfPerformedSearches equals: 0.	c camera scale: 2.	search searchForShapes: '*4*'.	shadow := shapes fourth propertyAt: #shadow.	extent := shadow extent.	c camera scale: 3.	self assert: shadow extent < extent! !!RSSearchInCanvasTest methodsFor: 'tests' prior: 59165633!testWithEdge	| l |	l := RSLine new.	l attachPoint: RSCenteredAttachPoint new.	l color: Color black.	l from: shapes first.	l to: shapes last.	c add: l.	search searchForShapes: '*5*'.	self assert: l color equals: Color black.	search searchForShapes: '*1*'.	self assert: l color equals: Color black.	search searchForShapes: '*10*'.	self assert: l color equals: Color black! !!RSSearchInCanvasTest methodsFor: 'tests' prior: 59169199!testWithEdgeAndhighlightable	| l interaction |	interaction := RSHighlightable new.	interaction highlightBorder: (RSBorder new width: 2).	interaction withLines.	c shapes @ interaction.	l := RSLine new.	l attachPoint: RSCenteredAttachPoint new.	l color: Color black.	l from: shapes first.	l to: shapes last.	c add: l.	search searchForShapes: '*5*'.	self assert: l color equals: Color black.	search searchForShapes: '*1*'.	self assert: l color equals: Color black.	search searchForShapes: '*10*'.	self assert: l color equals: Color black! !!RSDraggableCanvasTest methodsFor: 'running' prior: 58610915!setUp	super setUp.	canvas := RSCanvas new.	canvas add: (RSEllipse new width: 40; height: 20; yourself).	camera := canvas camera.! !!RSDraggableCanvasTest methodsFor: 'tests' prior: 58609392!testDefault	self assert: canvas canvas camera position equals: 0@0! !!RSDraggableCanvasTest methodsFor: 'tests' prior: 58607242!testDraggingModeLeft	| class |	class := RSDraggableCanvasInteraction.	{#left. RSMouseLeftDragStart.	#right. RSMouseRightDragStart.	#middle. RSMouseMiddleDragStart} pairsDo: [ :selector :eventClass| 		canvas @ (selector value: class).		canvas canvas announce: (RSMouseDragging new step: 10 @ 5).		self assert: camera position closeTo: 0 @ 0.		canvas removeInteractionIfPresent: class.		canvas @ (selector value: class).		canvas announce: RSMouseDragStart new.		canvas announce: (RSMouseDragging new step: 10 @ 5).		canvas announce: RSMouseDragEnd new.		self assert: camera position closeTo: 0 @ 0.		canvas announce: eventClass new.		canvas announce: (RSMouseDragging new step: 10 @ 5).		canvas announce: RSMouseDragEnd new.		self assert: camera position closeTo: (10 @ 5).		canvas removeInteractionIfPresent: class.		camera position: 0@0.		]	! !!RSDraggableCanvasTest methodsFor: 'tests' prior: 58609519!testDraggingOnDraggable	canvas @ RSDraggableCanvasInteraction.	canvas announce: RSMouseDragStart new.	canvas announce: (RSMouseDragging new step: 10 @ 5).	canvas announce: RSMouseDragEnd new.	self assert: camera position closeTo: 10 @ 5! !!RSDraggableCanvasTest methodsFor: 'tests' prior: 58608218!testDraggingOnNotDraggable	canvas announce: (RSMouseDragging step: 10 @ 5).	self assert: camera position equals: (0 @ 0)! !!RSSelectionInCanvasInteractionTest methodsFor: 'running'!setUp	super setUp.	canvas := RSCanvas new.	shapes := RSBox models: (1 to: 10).	canvas addAll: shapes! !!RSSelectionInCanvasInteractionTest methodsFor: 'tests'!testSelectShapes	self assert: canvas selectedShapes isEmpty.	canvas selectedShapes: shapes.	self assert: canvas selectedShapes size equals: shapes size! !!RSSelectionInCanvasInteractionTest methodsFor: 'tests'!testSelectShapesHaveShadow	self skip.	canvas setSelectedShapes: shapes.	self assert: canvas selectedShapes size equals: shapes size.	self assert: (shapes allSatisfy: [ :each | each hasShadow not ]).		canvas @ RSSelectionInCanvasInteraction.		canvas setSelectedShapes: shapes.	self assert: (shapes allSatisfy: [ :each | each hasShadow ]).! !!RSElasticBoxTest methodsFor: 'running' prior: 58653713!setUp	| shapes |	super setUp.	canvas := RSCanvas new.	shapes := (1 to: 10) collect: [ :i | RSBox new size: 5; yourself ].	RSGridLayout on: shapes.	canvas addAll: shapes! !!RSElasticBoxTest methodsFor: 'tests' prior: 58653942!testEvents	| number elastic |	elastic := RSElasticBoxInteraction new.	number := nil.	elastic		when: RSSelectionStartEvent do: [ :evt | number := 0 ] for: self;		when: RSSelectionChangedEvent do: [ :evt | number := number + 1 ] for: self;		when: RSSelectionEndEvent do: [ :evt | number := number +10 ] for: self.	canvas @ elastic.	canvas announce: (RSMouseRightDragStart new position: 0@0).	self assert: number equals: 0.	canvas announce: (RSMouseDragging new position: 10@10).	self assert: number equals: 1.	canvas announce: (RSMouseDragEnd new position: 0@0).	self assert: number equals: 11! !!RSElasticBoxTest methodsFor: 'tests' prior: 58653262!testEventsDraggableCanvas	| elastic number |	elastic := RSElasticBoxInteraction new.	elastic rightLeft.	canvas @ elastic.	number := nil.	elastic when: RSSelectionStartEvent do: [ :evt | number := 0 ] for: self.	canvas announce: (RSMouseLeftDragStart new position: 0@0).	self assert: number equals: 0! !!RSGhostDraggableTest methodsFor: 'tests' prior: 58697841!testBasic	| shape interaction c |	c := RSCanvas new.	shape := RSShapeFactory star		size: 10;		yourself.	c add: shape.	interaction := RSGhostDraggable new.	shape @ interaction.	self assert: (shape propertyAt: #ghost) isNil.	shape announce: RSMouseDragStart new.	self assert: (shape propertyAt: #ghost) notNil.	self assert: (shape propertyAt: #ghost) class equals: RSPolygon.	shape announce: RSMouseDragEnd new.	self assert: (shape propertyAt: #ghost) isNil! !!RSGhostDraggableTest methodsFor: 'tests' prior: 58697172!testComposite	| shape interaction c |	c := RSCanvas new.	shape := RSComposite new		children: (RSBox			models: Collection withAllSubclasses			forEach: [ :s :cls|				s size: 10.			 ]);		adjustToChildren;		yourself.	c add: shape.	interaction := RSGhostDraggable new.	shape @ interaction.	shape announce: RSMouseDragStart new.	self assert: (shape propertyAt: #ghost) notNil.	self assert: (shape propertyAt: #ghost) class equals: RSComposite.	self assert: (shape propertyAt: #ghost) privateShapes isNil.	shape announce: RSMouseDragEnd new.	self assert: (shape propertyAt: #ghost) isNil! !!RSDraggableTest methodsFor: 'tests' prior: 58612588!testBasic	| box |	box := RSBox new.	box @ RSDraggable! !!RSDraggableTest methodsFor: 'tests' prior: 58612075!testCheckChildrenActions	| box composite |	box := RSBox new model: 'foo'; popup; yourself.	composite := { box } asShape.	self should: [ composite draggable ] raise: Error! !!RSDraggableTest methodsFor: 'tests' prior: 58612303!testDisableCheckChildrenActions	| box composite draggable |	box := RSBox new model: 'foo'; popup; yourself.	composite := { box } asShape.	draggable := RSDraggable new.	draggable noValidateChildrenEvents.	composite @ draggable! !!RSLabeledTest methodsFor: 'tests' prior: 58866436!testFontSize	| c shapes labels |	c := RSCanvas new.	shapes := (1 to: 100)		          collect: [ :v | RSBox new model: v ]		          as: RSGroup.	c addAll: shapes.	RSNormalizer size		shapes: shapes;		from: 10;		to: 30;		normalize: #yourself.	RSGridLayout on: shapes.	self assert: c numberOfShapes equals: 100.	shapes @ (RSLabeled new fontSize: 8).	self assert: c numberOfShapes equals: 200.	"We check the size of the labels"	labels := c shapes select: [ :s | s class == RSLabel ].	self assert: labels size equals: 100.	self assert: (labels allSatisfy: [ :s | s fontSize = 8 ])! !!RSHighlightableTest methodsFor: 'tests'!testHighlightAllShapes	| h c |	c := RSCanvas new.	c addAll: (RSBox models: (1 to: 10)).	h := RSHighlightable red.	c nodes @ h.	h doHighlightShapes: c nodes.	self assert:		(c nodes allSatisfy: [ :shape | shape color = Color red ])! !!RSHighlightableTest methodsFor: 'tests'!testHighlightAllShapesThenHighlightNothing	| h c defaultColor |	c := RSCanvas new.	c addAll: (RSBox models: (1 to: 10)).	defaultColor := c nodes first color.	h := RSHighlightable red.	c nodes @ h.	h doHighlightShapes: c nodes.	h doHighlightShapes: {  } onCanvas: c.	self assert:		(c nodes allSatisfy: [ :shape | shape color = defaultColor ])! !!RSHighlightableTest methodsFor: 'tests'!testHighlightShapes	| interaction canvas defaultColor |	canvas := RSCanvas new.	canvas addAll: (RSBox models: (1 to: 10)).	defaultColor := canvas nodes first color.	interaction := RSHighlightable red.	canvas nodes @ interaction.	interaction doHighlightShapes: (OrderedCollection with: canvas nodes first).	self assert: canvas nodes first color equals: Color red.	self assert: (canvas nodes allButFirst allSatisfy: [ :shape |			 shape color = defaultColor ])! !!RSHighlightableTest methodsFor: 'tests' prior: 58759834!testSameModel	| values c boxes |	values := #(1 1 2 2 2 2 3 3 3 4 4 5 5 5 5 ).	c := RSCanvas new.	boxes := values collect: [ :vv | RSBox new size: 10; model: vv ] as: RSGroup.	c addAll: boxes.	boxes @ RSPopup.	boxes @ (RSHighlightable sameModel: c).	RSGridLayout on: boxes.	c nodes first announce: RSMouseEnter! !!RSHighlightableTest methodsFor: 'tests' prior: 58756863!testWithEdges	| canvas shapes interaction |	canvas := RSCanvas new.	shapes := (1 to: 20) collect: [ :i |		RSBox new			size: 10;			model: i;			draggable;			withBorder;			yourself ].	shapes := shapes asGroup.	RSLineBuilder line		shapes: shapes;		canvas: canvas;		connectFrom: [ :n | n // 2 ].	canvas edges do: #withBorder.	canvas addAll: shapes.	RSClusterTreeLayout on: shapes.	interaction := RSHighlightable red.	interaction withLines.	shapes @ interaction.	self assert: (shapes second outgoingLines collect: #color) asSet size equals: 1.	self assert: (shapes second outgoingLines collect: #color) anyOne equals: Color gray.	shapes second announce: RSMouseEnter.	self assert: (shapes second outgoingLines collect: #color) asSet size equals: 1.	self assert: (shapes second outgoingLines collect: #color) anyOne equals: Color red.	shapes second announce: RSMouseLeave.	self assert: (shapes second outgoingLines collect: #color) asSet size equals: 1.	self assert: (shapes second outgoingLines collect: #color) anyOne equals: Color gray! !!RSHighlightableTest methodsFor: 'tests' prior: 58757990!testWithEdges2	| canvas shapes interaction |	canvas := RSCanvas new.	shapes := (1 to: 20) collect: [ :i |		RSBox new			size: 10;			model: i;			draggable;			withBorder;			yourself ].	shapes := shapes asGroup.	RSLineBuilder line		shapes: shapes;		canvas: canvas;		connectFrom: [ :n | n // 2 ].	canvas edges do: #withBorder.	canvas addAll: shapes.	RSClusterTreeLayout on: shapes.	interaction := RSHighlightable withLines.	shapes @ interaction.	self assert: (shapes second outgoingLines collect: #color) asSet size equals: 1.	self assert: (shapes second outgoingLines collect: #color) anyOne equals: Color gray.	shapes second announce: RSMouseEnter.	self assert: (shapes second outgoingLines collect: #color) asSet size equals: 1.	self assert: (shapes second outgoingLines collect: #color) anyOne equals: Color black.	shapes second announce: RSMouseLeave.	self assert: (shapes second outgoingLines collect: #color) asSet size equals: 1.	self assert: (shapes second outgoingLines collect: #color) anyOne equals: Color gray! !!RSHighlightableTest methodsFor: 'tests' prior: 58759103!testWithOutgoingLines	| h c shapes |	c := RSCanvas new.	c addAll: (RSBox models: (1 to: 10)).	RSLineBuilder line		canvas: c;		connectFrom: [ :n | n // 2 ].	h := RSHighlightable new.	h withOutgoingLines.	c nodes @ h.	shapes := h highlightShapesFor: c nodes first.	self assert: shapes size equals: 2+2."the lines and the outgoing nodes"	h withOutgoingLinesOnly.	shapes := h highlightShapesFor: c nodes first.	self assert: shapes size equals: 2.	self assert: (shapes allSatisfy: [ :s | s isLine ]).	h withOutgoingShapes.	shapes := h highlightShapesFor: c nodes first.	self assert: shapes size equals: 2.	self assert: (shapes allSatisfy: [ :s | s isNode ])! !!RSPopupTest methodsFor: 'tests' prior: 59056547!testMorphicPopup	canvas createMorph.	shapes @ RSMorphicPopupInteraction.	shapes first announce: RSMouseMove new! !!RSPopupTest methodsFor: 'tests' prior: 59058137!testMultiline	shapes @ RSPopup.	self assert: canvas fixedShapes size equals: 0 .	shapes last announce: RSMouseMove.	self assert: canvas numberOfShapes equals: shapes size.	self assert: canvas fixedShapes size equals: 1.	self assert: canvas fixedShapes first shapes second shapes size equals: 2! !!RSPopupTest methodsFor: 'tests' prior: 59058744!testNoPopup	shapes first announce: RSMouseEnter.	self assert: canvas numberOfShapes equals: shapes size! !!RSPopupTest methodsFor: 'tests' prior: 59055431!testPopup	| c |	c := RSCanvas new.	shapes := (1 to: 30) collect: [ :v | RSEllipse new  model: v; size: 10 ] as: RSGroup.	shapes @ RSPopup.	c addAll: shapes.	RSLineBuilder line	    canvas: c;	    withBorderAttachPoint;	    connectFrom: [ :v | v // 2 ].	RSTreeLayout on: shapes.	self assert: c numberOfShapes equals: 59.	self assert: c fixedShapes isEmpty.	shapes first announce: RSMouseMove.	self assert: shapes first model equals: 1.	self assert: c numberOfShapes equals: 59.	self assert: c fixedShapes size equals: 1.	self assert: c fixedShapes last children last text equals: '1'.	shapes first announce: RSMouseLeave.	shapes second announce: RSMouseMove.	self assert: c fixedShapes size equals: 1.	self assert: c fixedShapes last children last text equals: '2'! !!RSPopupTest methodsFor: 'tests' prior: 59056711!testPopupWithoutMouseLeave	"Test created while debugging https://github.com/ObjectProfile/Roassal3/issues/150"	| c |	c := RSCanvas new.	shapes := (1 to: 30) collect: [ :v | RSEllipse new  model: v; size: 10 ] as: RSGroup.	shapes @ RSPopup.	c addAll: shapes.	RSLineBuilder line	    canvas: c;	    withBorderAttachPoint;	    connectFrom: [ :v | v // 2 ].	RSTreeLayout on: shapes.	self assert: c numberOfShapes equals: 59.	self assert: c fixedShapes isEmpty.	shapes first announce: RSMouseMove.	self assert: shapes first model equals: 1.	self assert: c numberOfShapes equals: 59.	self assert: c fixedShapes size equals: 1.	self assert: c fixedShapes last children last text equals: '1'.	"Note that we do not announce RSMouseLeave"	shapes second announce: RSMouseMove.	self assert: c fixedShapes size equals: 1.	self assert: c fixedShapes last children last text equals: '2'! !!RSPopupTest methodsFor: 'tests' prior: 59056271!testWithPopup	shapes @ RSPopup.	self assert: canvas fixedShapes size equals: 0 .	shapes first announce: RSMouseMove.	self assert: canvas numberOfShapes equals: shapes size.	self assert: canvas fixedShapes size equals: 1! !!RSTransformableTest methodsFor: 'running' prior: 59461988!setUp	super setUp.	canvas := RSCanvas new.	shapes := (1 to: 5)		collect: [ :i | RSBox new size: 10; position: 10@10 * i]		as: RSGroup.	canvas addAll: shapes! !!RSTransformableTest methodsFor: 'running' prior: 59461891!testBasic	shapes @ RSTransformable! !!RSTransformableTest methodsFor: 'running' prior: 59461341!testBasic02	| s interaction handles |	interaction := RSTransformable new.	shapes @ interaction .	s := shapes first.	s announce: RSMouseLeftClick new.	self assert: canvas shapes size > shapes size.	handles := canvas propertyAt: interaction key.	self assert: handles notNil.	self assert: handles isNotEmpty.	canvas announce: RSMouseClick new.	self assert: canvas shapes size equals: shapes size.	handles := canvas propertyAt: interaction key.	self assert: handles isNil! !!RSTransformableTest methodsFor: 'running' prior: 59459549!testCornerDirections	| interaction base new |	interaction := RSTransformable new.	base := 20@20 corner: 100@100.	new := interaction bottomRight: 10@120 rectangle: base.	self assert: new equals: 20@20 -> (10@120).	new := interaction bottomCenter: 10@120 rectangle: base.	self assert: new equals: 20@20 -> (100@120).	new := interaction bottomLeft: 0@120 rectangle: base.	self assert: new equals: 0@20 -> (100@120).	new := interaction topLeft: 0@0 rectangle: base.	self assert: new equals: 0@0 -> (100@100).	new := interaction topCenter: 50@0 rectangle: base.	self assert: new equals: 20@0 -> (100@100).	new := interaction topRight: 120@0 rectangle: base.	self assert: new equals: 20@0 -> (120@100).	new := interaction leftCenter: 0@120 rectangle: base.	self assert: new equals: 0@20 -> (100@100).	new := interaction rightCenter: 120@120 rectangle: base.	self assert: new equals: 20@20 -> (120@100)! !!RSTransformableTest methodsFor: 'running' prior: 59459103!testDrag	| s interaction |	interaction := RSTransformable new.	shapes @ interaction .	s := shapes first.	s announce: RSMouseLeftClick new.	self assert: (canvas propertyAt: interaction key) notNil.	s announce: RSMouseDragStart new.	self assert: (canvas propertyAt: interaction key) isNil.	s announce: RSMouseDragEnd new.	self assert: (canvas propertyAt: interaction key) notNil! !!RSTransformableTest methodsFor: 'running' prior: 59460989!testDrag2	| s interaction |	interaction := RSTransformable new.	shapes @ interaction .	s := shapes first.	s announce: RSMouseDragStart new.	self assert: (canvas propertyAt: interaction key) isNil.	s announce: RSMouseDragEnd new.	self assert: (canvas propertyAt: interaction key) isNil! !!RSTransformableTest methodsFor: 'running' prior: 59460539!testUpdateShape	| s interaction rect handles |	interaction := RSTransformable new.	shapes @ interaction .	s := shapes first.	s announce: RSMouseLeftClick new.	rect := s encompassingRectangle.	handles := (canvas propertyAt: interaction key).	self assert: handles first class equals: RSPolygon.	handles second		translateTo: 10@10.	self deny: rect equals: s encompassingRectangle! !RSDraggableCanvasTest removeSelector: #testDraggingModeRight!RSDraggableCanvasTest removeSelector: #testDraggingModeMiddle!"Roassal3-Interaction-Tests"!!RSLineBuilderTest methodsFor: '*Roassal3-Layouts-Tests'!testUseInLayout	b		canvas: canvas;		connectTo: [ :v | v + 1 ].	RSTreeLayout on: canvas nodes.	self assert: (canvas nodes collect: #position) asArray equals: ({(7.5@7.5). (7.5@32.5). (7.5@57.5). (7.5@82.5). (7.5@107.5). (7.5@132.5). (7.5@157.5). (7.5@182.5). (7.5@207.5). (7.5@232.5)})! !!RSLineBuilderTest methodsFor: '*Roassal3-Layouts-Tests'!testUseInLayoutDefault	b		canvas: canvas;		connectTo: [ :v | v + 1 ].	RSTreeLayout on: canvas nodes.	self assert: (canvas nodes collect: #position) asArray equals: ((Array new: 10) at: 1 put: ((7.5@7.5)); at: 2 put: ((7.5@32.5)); at: 3 put: ((7.5@57.5)); at: 4 put: ((7.5@82.5)); at: 5 put: ((7.5@107.5)); at: 6 put: ((7.5@132.5)); at: 7 put: ((7.5@157.5)); at: 8 put: ((7.5@182.5)); at: 9 put: ((7.5@207.5)); at: 10 put: ((7.5@232.5)); yourself)! !!RSFlowLayoutTest methodsFor: 'tests' prior: 58670627!testLinesEven	| layout lines line n |	layout := RSFlowLayout new.	layout maxWidth: 20.	lines := layout linesFor: shapes.	n := 5.	self assert: lines size equals: n.	line := lines last.	"all shapes has the same size"	self		assert: line first position y		equals: (layout gapSize* n)+(shapes first height * (n-1.5))! !!RSFlowLayoutTest methodsFor: 'tests' prior: 58671009!testLinesOdd	| layout lines line n |	layout := RSFlowLayout new.	layout maxWidth: 30.	layout on: shapes.	lines := layout linesFor: shapes.	n := 4.	self assert: lines size equals: n.	line := lines last.	"all shapes has the same size"	self		assert: line first position y		equals: (layout gapSize* n)+(shapes first height * (n-1.5))! !!RSGridLayoutTest methodsFor: 'tests' prior: 58706810!testBasicCustomizedGapSizeGridLayout	RSGridLayout new gapSize:15; on: canvas nodes.	self assert: (shapes collect: #position) asArray equals: {(2.5@2.5). (22.5@2.5). (42.5@2.5). (62.5@2.5). (2.5@22.5). (22.5@22.5). (42.5@22.5). (62.5@22.5). (2.5@42.5). (22.5@42.5)}! !!RSGridLayoutTest methodsFor: 'tests' prior: 58706489!testBasicDefaultGapSizeGridLayout	RSGridLayout new gapSize:5; on: canvas nodes.	self assert: (shapes collect: #position) asArray equals: {(2.5@2.5). (12.5@2.5). (22.5@2.5). (32.5@2.5). (2.5@12.5). (12.5@12.5). (22.5@12.5). (32.5@12.5). (2.5@22.5). (12.5@22.5)}! !!RSGridLayoutTest methodsFor: 'tests'!testFixedPositionsAfterApplyingTheLayout	RSGridLayout on: canvas nodes.	self assert: (shapes collect: [:each | each position asIntegerPoint ] as: Array) equals: {2 @ 2.12 @ 2.22 @ 2.32 @ 2.2 @ 12.12 @ 12.22 @ 12.32 @ 12.2 @ 22.12 @ 22}! !!RSGridLayoutTest methodsFor: 'tests' prior: 58707133!testLineItemsCount	| shapesInLine |	RSGridLayout new		lineItemsCount: 3;		on: canvas nodes.	shapesInLine := canvas nodes groupedBy: [ :each | each position y ].	self assert: (shapesInLine allSatisfy: [:group | group size between: 1 and: 3 ])! !!RSGridLayoutTest methodsFor: 'tests'!testLineItemsCountForASingleLineOfShapes	canvas := RSCanvas new.	shapes := (1 to: 3) collect: [ :each | RSBox new size: 20 ].	canvas addAll: shapes.	RSGridLayout new		gapSize: 10;		lineItemsCount: 8;		on: shapes.	self assertIntegerPosition: shapes equals: {10@10. 40@10. 70@10}.		! !!RSLayoutBuilderTest methodsFor: 'tests'!testDefaultLayoutClass	self assert: builder layout class equals: RSFlowLayout! !!RSLayoutBuilderTest methodsFor: 'tests'!testSelectNoneLayout	| shapes |	shapes := RSBox models: (1 to: 10).	builder none.	self assert: builder layout class equals: RSNoLayout.	builder on: shapes.	self assert: (shapes allSatisfy: [ :each | each position = (0@0) ])! !!RSLayoutBuilderTest methodsFor: 'tests'!testUseGridCircleTreeChangesSelectedLayout	{#grid -> RSGridLayout.	 #circle -> RSCircleLayout.	#tree -> RSTreeLayout} do: [ :assoc | | selector class |		selector := assoc key.		class := assoc value.		selector value: builder.		self assert: builder layout class equals: class.		 ]! !!RSAlignmentTest methodsFor: 'running' prior: 58288553!setUp	super setUp.	align := RSAlignment new! !!RSAlignmentTest methodsFor: 'tests' prior: 58288240!testCenter	| es |	es := (1 to: 5) collect: [ :v | RSBox new size: 10 ] as: RSGroup.	RSHorizontalLineLayout on: es.	align shapes: es.	self assert: align middle equals: align.	self assert: es encompassingRectangle equals: ((0.0@0.0) corner: (70.0@10.0))! !!RSAlignmentTest methodsFor: 'tests' prior: 58287094!testFromTop	| es |	es := (10 to: 100 by: 10) collect: [ :n | RSBox new size: n; yourself ].	align shapes: es.	RSHorizontalLineLayout on: es.	es second translateBy: 0 @ -50.	self assert: (es collect: [ :e | e encompassingRectangle top ]) asArray equals: #(0.0 -50.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0).	self assert: align topMostShape equals: es second.	align top.	self assert: (es collect: [ :e | e encompassingRectangle top ]) asArray equals: #(-50.0 -50.0 -50.0 -50.0 -50.0 -50.0 -50.0 -50.0 -50.0 -50.0)! !!RSAlignmentTest methodsFor: 'tests' prior: 58285039!testFromTopWithAFixShape	| es |	es := (10 to: 100 by: 10) collect: [ :n | RSBox new size: n; yourself ].	align shapes: es.	RSHorizontalLineLayout on: es.	es second translateBy: 0 @ -50.	align fixedShape: es third.	self assert: (es collect: [ :e | e encompassingRectangle top ]) asArray equals: #(0.0 -50.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0).	self assert: align topMostShape equals: es third.	align top.	self assert: (es collect: [ :e | e encompassingRectangle top ]) asArray equals: #(0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0)! !!RSAlignmentTest methodsFor: 'tests' prior: 58285627!testHasElement	self deny: align hasShape.	align shapes: (Array with: RSBox new).	self assert: align hasShape.	align shapes: #().	self deny: align hasShape! !!RSHorizontalTreeLayoutTest methodsFor: 'tests' prior: 58789754!testCycles	| chars |	canvas := RSCanvas new.	chars := $a to: $e.	shapes := RSComposite models: chars forEach: [ :composite :char |		| box label |		label := RSLabel text: char.		box := RSBox new			position: label position;			extent: label extent + 10;			yourself.		composite			draggable;			add: box;			add: label;			yourself.		].	canvas addAll: shapes.	RSLineBuilder arrowedLine		canvas: canvas;		withVerticalAttachPoint;		useAssociations:			{$a -> $b.			$a -> $e.			$b -> $c.			$c -> $d.			$d -> $a}. "cycle"	self shouldnt: [RSHorizontalTreeLayout on: shapes] raise: Error.	self should: [RSHorizontalTreeLayout new validateCycles; on: shapes] raise: Error! !!RSAngleLineLayoutTest methodsFor: 'tests' prior: 58291747!testBasic	| layout angle |	layout := RSAngleLineLayout new.	self assert: layout angle equals: layout defaultAngle.	angle := 45 degreesToRadians.	layout angle: angle.	self assert: layout angle equals: angle! !!RSAngleLineLayoutTest methodsFor: 'tests' prior: 58290890!testGapSize	| layout var1st var2nd |	layout := RSAngleLineLayout new gapSize: 100.	layout on: shapes.	var1st := shapes first.	var2nd := shapes second.	self assert: var1st position closeTo: 2.5 @ 2.5.	self assert: var2nd position closeTo: 107.5 @ 2.5! !!RSAngleLineLayoutTest methodsFor: 'tests' prior: 58290624!testLayoutWith0Angle	| layout x gap |	layout := RSAngleLineLayout new angle: 0.	gap := layout gapSize.	layout on: shapes.	x := 2.5.	shapes do: [ :each |		self assert: each position closeTo: x @ 2.5.		x := x + each width + gap ]! !!RSAngleLineLayoutTest methodsFor: 'tests' prior: 58291489!testLayoutWith90Angle	| layout y gap |	layout := RSAngleLineLayout new.	layout angleByDegrees: 90.	gap := layout gapSize.	layout on: shapes.	y := 2.5.	shapes do: [ :each |		self assert: each position closeTo: 2.5 @ y.		y := y + each height + gap ]! !!RSAngleLineLayoutTest methodsFor: 'tests' prior: 58291206!testLayoutWithThreeElements	| layout gap extent |	layout := RSAngleLineLayout new.	gap := layout gapSize.	shapes := shapes first: 3.	extent := shapes first extent.	layout on: shapes.	self assert: shapes first position equals: extent * (0.5@ 0.5).	self assert: shapes second position equals: extent * (1.5 @ 0.5) + (gap@0).	self assert: shapes third position equals: extent * (2.5 @ 0.5) + (gap*2@0).! !!RSLocationTest methodsFor: 'running' prior: 58958995!setUp	super setUp.	shape := RSBox new size: 10 asPoint; position: 0 asPoint.	target := RSBox new size: 20 asPoint; position: 0 asPoint! !!RSLocationTest methodsFor: 'tests' prior: 58957192!testAbove	RSLocation new above; move: shape on: target.	self assert: target position equals: 0 asPoint.	self assert: shape position equals: 0 @ -15! !!RSLocationTest methodsFor: 'tests' prior: 58957858!testAboveRectangle	RSLocation new above; move: shape on: (0 asPoint corner: 50 asPoint).	self assert: shape position equals: 25 @ -5! !!RSLocationTest methodsFor: 'tests' prior: 58958560!testBasic	| location |	location := RSLocation new.	self assert: shape extent equals: 10 asPoint.	self assert: target extent equals: 20 asPoint.	self assert: shape position equals: 0 asPoint.	self assert: target position equals: 0 asPoint.	location move: shape on: target.	self assert: target position equals: 0 asPoint.	self assert: shape position equals: 0 asPoint! !!RSLocationTest methodsFor: 'tests' prior: 58959738!testBelow	RSLocation new below ; move: shape on: target.	self assert: target position equals: 0 asPoint.	self assert: shape position equals: 0 @ 15! !!RSLocationTest methodsFor: 'tests' prior: 58958045!testInComposite	| canvas composite |	canvas := RSCanvas new.	composite := { target } asShape padding: 5.	composite position: 10@10.	canvas add: composite.	canvas add: shape.	self assert: composite extent equals: (20+(5*2)) asPoint.	RSLocation new move: shape on: target.	self assert: shape parent equals: canvas.	self assert: target parent equals: composite.	self assert: composite parent equals: canvas.	self assert: shape position equals: 0@0! !!RSLocationTest methodsFor: 'tests' prior: 58959187!testInComposite2	| canvas composite |	canvas := RSCanvas new.	composite := { target. shape} asShape padding: 5.	composite position: 10@10.	target position: 10@10.	canvas add: composite.	self assert: composite extent equals: (20+(5*2)) asPoint.	RSLocation new move: shape on: target.	self assert: shape parent equals: composite.	self assert: target parent equals: composite.	self assert: composite parent equals: canvas.	self assert: shape position equals: 10 asPoint + 0 asPoint! !!RSLocationTest methodsFor: 'tests' prior: 58957631!testMiddleLeft	RSLocation new middle; left; outer; move: shape on: target.	self assert: target position equals: 0 asPoint.	self assert: shape position equals: -15 @ 0! !!RSLocationTest methodsFor: 'tests' prior: 58957400!testMiddleLeftInner	RSLocation new middle; left; inner; move: shape on: target.	self assert: target position equals: 0 asPoint.	self assert: shape position equals: -5 @ 0! !!RSResizeTest methodsFor: 'running' prior: 59137887!setUp	super setUp.	shapes := (1 to: 3) collect: [ :o |		RSBox new			height: o;			width: o + 1;			yourself ].	resize := RSResize new.	resize shapes: shapes! !!RSResizeTest methodsFor: 'tests' prior: 59136942!testBiggestShape	self assert: resize biggestShape equals: shapes last.	resize useBiggestShape.	self assert: resize fixedShape equals: shapes last! !!RSResizeTest methodsFor: 'tests' prior: 59137261!testHighestShape	self assert: resize highestShape equals: shapes last! !!RSResizeTest methodsFor: 'tests' prior: 59137141!testWidestShape	self assert: resize widestShape equals: shapes last! !!RSSugiyamaLayoutTest methodsFor: 'tests' prior: 59258506!testBasic	RSSugiyamaLayout on: canvas nodes! !!RSSugiyamaLayoutTest methodsFor: 'tests' prior: 59258609!testOnCycle	canvas nodes copy do: #remove.	canvas addAll: ((1 to: 3) collect:  [ :each | RSBox new model: each ]).	RSLineBuilder line		shapes: canvas nodes;		canvas: canvas;		useAssociations: { 1->2. 2->3. 3->1 }.	"cycle"	self should: [RSSugiyamaLayout on: canvas nodes] raise: Error! !!RSVerticalGridLayoutTest methodsFor: 'tests' prior: 59517300!testBasic	RSVerticalCellLayout on: canvas nodes.	self assert: (shapes collect: #position) asArray equals: {(2.5@2.5). (2.5@12.5). (2.5@22.5). (2.5@32.5). (12.5@2.5). (12.5@12.5). (12.5@22.5). (12.5@32.5). (22.5@2.5). (22.5@12.5)}! !!RSClusteringLayoutTest methodsFor: 'tests' prior: 58518100!testBasic	| c shapes lb nodes |	c := RSCanvas new.	shapes := RSBox models: (10 to: 50).	c addAll: shapes.	RSFlowLayout on: shapes.	lb := RSLineBuilder line.	lb shapes: shapes.	lb connectFrom: [ :nb | nb // 2 ].	nodes := c nodes.	RSConditionalLayout new		ifNotConnectedThen: RSGridLayout new;		else: (RSClusteringLayout new				 clustersLayout: RSFlowLayout new;				 forEachLayout: RSTreeLayout new);		on: nodes.	self assertIntegerPosition: nodes equals: {24 @ 5.78 @ 5.126 @ 5.160 @ 5.11 @ 80.39 @ 80.67 @ 80.95 @ 80.123 @ 80.151 @ 80.11 @ 35.37 @ 35.65 @ 35.91 @ 35.119 @ 35.139 @ 35.154 @ 35.167 @ 35.5 @ 110.18 @ 110.33 @ 110.46 @ 110.61 @ 110.74 @ 110.89 @ 110.102 @ 110.117 @ 110.130 @ 110.145 @ 110.158 @ 110.5 @ 65.18 @ 65.31 @ 65.44 @ 65.59 @ 65.72 @ 65.85 @ 65.98 @ 65.113 @ 65.126 @ 65.139 @ 65}! !!RSClusteringLayoutTest methodsFor: 'tests' prior: 58517690!testBasic2	| shapes c lb nodes clusters |	c := RSCanvas new.	shapes := RSBox models: (10 to: 50).	c addAll: shapes.	RSFlowLayout on: shapes.	lb := RSLineBuilder line.	lb shapes: shapes.	lb connectFrom: [ :nb | nb // 2 ].	nodes := c nodes.	clusters := RSClusteringLayout new getClusterFor: nodes.	self assert: clusters size equals: 10! !!RSClusteringLayoutTest methodsFor: 'tests' prior: 58516603!testBasic3	| c shapes lb nodes clusters |	c := RSCanvas new.	shapes := RSBox models: (1 to: 50).	c addAll: shapes.	RSFlowLayout on: shapes.	lb := RSLineBuilder line.	lb shapes: shapes.	lb connectFrom: [ :nb | nb // 2 ].	nodes := c nodes.	clusters := RSClusteringLayout new getClusterFor: nodes.	self assert: clusters size equals: 1! !!RSClusteringLayoutTest methodsFor: 'tests' prior: 58517011!testCycles	| chars canvas shapes |	canvas := RSCanvas new.	chars := $a to: $e.	shapes := RSComposite models: chars forEach: [ :composite :char |		| box label |		label := RSLabel text: char.		box := RSBox new			position: label position;			extent: label extent + 10;			yourself.		composite			draggable;			add: box;			add: label;			yourself.		].	canvas addAll: shapes.	RSLineBuilder arrowedLine		canvas: canvas;		withVerticalAttachPoint;		useAssociations:			{$a -> $b.			$a -> $e.			$b -> $c.			$c -> $d.			$d -> $a}. "cycle"	self should: [RSClusterTreeLayout on: shapes] raise: Error! !!RSCircularAroundAVertexLayoutTest methodsFor: 'tests'!testApplyDefaultLayoutOverlapsShapes	| layout first second |	layout := RSCircularAroundAVertexLayout new.	layout on: canvas nodes.	first := canvas nodes first.	second := canvas nodes second.	self deny: (first encompassingRectangle intersects: second encompassingRectangle).	self deny: first position equals: second position.! !!RSCircularAroundAVertexLayoutTest methodsFor: 'tests'!testApplyLayoutShouldChangeOldPositions	| layout oldPositions |	layout := RSCircularAroundAVertexLayout new.	oldPositions := canvas nodes collect: #position.	layout on: canvas nodes.	self deny: (canvas nodes collect: #position) equals: oldPositions! !!RSCircularAroundAVertexLayoutTest methodsFor: 'tests' prior: 58497132!testRadius	| layout boundingBox |	layout := RSCircularAroundAVertexLayout new.	layout radius: 1000.	layout on: canvas nodes.	boundingBox := canvas encompassingRectangle.	self assert: boundingBox width >  100! !!RSLayoutTest methodsFor: 'running' prior: 58876449!setUp	| eb |	super setUp.	canvas := RSCanvas new.	shapes := (1 to: 10) collect: [ :i | 		(RSBox model: i) 			size: 5;			yourself ] as: RSGroup.	canvas addAll: shapes.	eb := RSLineBuilder line.	eb canvas: canvas.	eb shapes: shapes.	eb connectFrom: [ :nb | nb // 2 ]! !!RSTreeLayoutTest methodsFor: 'tests'!computeTreeWithCycles	| chars |	canvas := RSCanvas new.	chars := $a to: $e.	shapes := RSComposite models: chars forEach: [ :composite :char |		| box label |		label := RSLabel text: char.		box := RSBox new			position: label position;			extent: label extent + 10;			yourself.		composite			draggable;			add: box;			add: label;			yourself.		].	canvas addAll: shapes.	RSLineBuilder arrowedLine		canvas: canvas;		withBorderAttachPoint;		useAssociations:			{$a -> $b.			$a -> $e.			$b -> $c.			$c -> $d.			$d -> $a}. "cycle"! !!RSTreeLayoutTest methodsFor: 'tests'!testDoNotValidateCyclesLayoutsEachShapeProperly	| groups |	self computeTreeWithCycles.	RSTreeLayout new		horizontalGap: 10;		childrenSortBlock: [ :a :b | a model < b model ];		doNotValidateCycles; on: shapes.	groups := shapes groupedBy: [ :each | each position ].	"at least each shape should be in a different position"	self assert: groups size equals: shapes size! !!RSTreeLayoutTest methodsFor: 'tests'!testDoNotValidateCyclesRunsNormally	self computeTreeWithCycles.	RSTreeLayout new doNotValidateCycles; on: shapes! !!RSTreeLayoutTest methodsFor: 'tests'!testValidateCyclesRaisesError	self computeTreeWithCycles.	self should: [ RSTreeLayout new validateCycles on: shapes ] raise: Error! !RSCircularAroundAVertexLayoutTest removeSelector: #testDefaultRadius!RSCircularAroundAVertexLayoutTest removeSelector: #testBasic!RSCircularAroundAVertexLayoutTest removeSelector: #setUp!RSCircularAroundAVertexLayoutTest removeSelector: #createCanvasToTest!RSAngleLineLayoutTest removeSelector: #testLayoutwith90Angle!RSLayoutBuilderTest removeSelector: #testGridCircleTree!RSLayoutBuilderTest removeSelector: #testBasic!RSTreeLayoutTest removeSelector: #testCycles!RSGridLayoutTest removeSelector: #testBasic!"Roassal3-Layouts-Tests"!!RSMarkerDecorationParametrizedTest commentStamp: '' prior: 0!A RSXLabelDecorationTest is a test class for testing the behavior of RSXLabelDecoration!!RSBarPlotTest methodsFor: 'tests' prior: 58343522!test2BarPlots	| d1 d2 extent vtick |	d1 := #(4 10 5 9).	d2 := #(-5 -6 -3 -3 ).	extent := chart extent.	chart addPlot: (RSBarPlot new y: d1).	chart addPlot: (RSBarPlot new y: d2).	vtick := chart verticalTick withNoLabels.	chart removeHorizontalTicks.	chart build.	self		assert: chart canvas encompassingRectangle extent		equals: extent+(vtick configuration tickSize @0)! !!RSBarPlotTest methodsFor: 'tests' prior: 58342684!testHorizontalBar	| c p x y |	x := 0.0 to: 2 count: 10.	y := (x raisedTo: 2) - 2.	c := RSChart new.	p := RSHorizontalBarPlot new x: x y: y.	self deny: p isVerticalBarPlot.	self assert: p isHorizontalBarPlot.	c addPlot: p.	c build.	self assert: (p bars allSatisfy: [ :shape |		 shape height closeTo: p bars anyOne height ])! !!RSBarPlotTest methodsFor: 'tests' prior: 58343074!testVerticalBar	| c p x y |	x := 0.0 to: 2 count: 10.	y := (x raisedTo: 2) - 2.	c := RSChart new.	p := RSBarPlot new x: x y: y.	self assert: p isVerticalBarPlot.	self deny: p isHorizontalBarPlot.	c addPlot: p.	c verticalTick numberOfTicks: 10;		asFloat.	c build.	self assert: (p bars allSatisfy: [ :shape |		 shape width closeTo: p bars anyOne width ])! !!RSChartTickTest methodsFor: 'tests'!testDefaultFont	| chart plot canvas ticks labels |	chart := RSChart new.	plot := RSLinePlot y: #(1 2 3).	chart add: RSVerticalTick new.	chart add: plot.	chart build.	canvas := chart container.	ticks := chart verticalTick.	labels := ticks labels.	self assert: (labels allSatisfy: [ :label | label font = label class defaultFont ]).! !!RSChartTickTest methodsFor: 'tests' prior: 58488146!testDoNotUseNiceLabel	| x c numberOfTicks vertical |	x := -10.0 to: 20.0 count: 100.	numberOfTicks := 2.	c := RSChart new		     addPlot: (RSScatterPlot new x: x y: (x raisedTo: 3));		     addPlot: (RSLinePlot new x: x y: (x raisedTo: 2));		     yourself.	c horizontalTick numberOfTicks: 20;				      integer.	vertical := c verticalTick integer numberOfTicks: numberOfTicks.	c build.	self assert: vertical labels size equals: numberOfTicks! !!RSChartTickTest methodsFor: 'tests' prior: 58487531!testFromNames	| dates y data x chart horizontal |	dates := OrderedCollection new.	y := OrderedCollection new.	data := { '04-jun-2020'. 800. '03-jun-2020'. 900. '02-jun-2020'. 850 } reverse.	data pairsDo: [ :f :d |		dates add: d.		y add: f ].	x := 1 to: dates size.	chart := RSChart new.	chart extent: 300 @ 200.	chart addPlot: (RSLinePlot new x: x y: y).	horizontal := chart horizontalTick fromNames: dates.	chart verticalTick numberOfTicks: 10;			 asFloat.	chart build.	self assert: horizontal labels size equals: dates size! !!RSChartTickTest methodsFor: 'tests' prior: 58489054!testFromNamesWithEmptyData	| dates x y chart |	dates := {}.	x := {}.	y := {}.	chart := RSChart new.	chart add: (RSHorizontalBarPlot new		x: y y: x;		yourself).	self should: [ chart horizontalTick fromNames: dates ] raise: Error! !!RSChartTickTest methodsFor: 'tests' prior: 58488706!testFromNamesWithOneData	| names indices values chart |	names := { 'Simple'.}.	indices := { 1 }.	values := {100}.	chart := RSChart new.	chart add: (RSHorizontalBarPlot new		x: indices y: values;		yourself).	chart horizontalTick fromNames: names.	chart removeVerticalTicks.	chart build! !!RSChartTickTest methodsFor: 'tests'!testSetFontSize	| chart plot canvas ticks labels |	chart := RSChart new.	plot := RSLinePlot y: #(1 2 3).	chart add: RSVerticalTick new.	chart add: plot.	canvas := chart container.	ticks := chart verticalTick.	ticks configuration fontSize: 12.	chart build.	labels := ticks labels.	self assert: (labels allSatisfy: [ :label | label fontSize = 12 ]).! !!RSChartTest methodsFor: 'tests' prior: 58485506!testBasic	| x |	x := -10.0 to: 20.0 count: 100.	RSChart new		addPlot: (RSScatterPlot new x: x y: (x raisedTo: 3));		addPlot: (RSLinePlot new x: x y: (x raisedTo: 2));		build! !!RSChartTest methodsFor: 'tests'!testExtentOnChange	| chart plot canvas|	chart := RSChart new.	self skip.	plot := RSLinePlot y: #(1 2 3).	chart add: plot.	chart build.	canvas := chart container.	self assert: canvas extent equals: canvas defaultExtent.	self assert: chart extent < canvas extent.	canvas extent: 1000@1000.	self assert: chart extent equals: canvas extent.	self assert: chart extent > canvas defaultExtent.	! !!RSChartTest methodsFor: 'tests' prior: 58484507!testMinMaxValue	| y c |	y := #(10 13 15).	c := RSChart new.	c addPlot: (RSLinePlot new y: y).	c build.	self assert: c minValueX equals: 1.	self assert: c maxValueX equals: 3.	self assert: c minValueY equals: 10.	self assert: c maxValueY equals: 15! !!RSChartTest methodsFor: 'tests' prior: 58487191!testMinMaxValue2	| y c x |	y := #(-10 -13 -15).	x := #(4 6 9).	c := RSChart new.	c addPlot: (RSLinePlot new x: x y: y).	c build.	self assert: c minValueX equals: 4.	self assert: c maxValueX equals: 9.	self assert: c minValueY equals: -15.	self assert: c maxValueY equals: -10! !!RSChartTest methodsFor: 'tests' prior: 58483298!testMustInclude0	| y c |	y := #(10 13 15).	c := RSChart new.	c addPlot: (RSLinePlot new y: y).	c mustInclude0inY.	c build.	self assert: c minValueX equals: 1.	self assert: c maxValueX equals: 3.	self assert: c minValueY equals: 0.	self assert: c maxValueY equals: 15! !!RSChartTest methodsFor: 'tests' prior: 58483625!testMustInclude02	| y c |	y := #(-10 -13 -15).	c := RSChart new.	c addPlot: (RSLinePlot new y: y).	c mustInclude0inY.	c build.	self assert: c minValueX equals: 1.	self assert: c maxValueX equals: 3.	self assert: c minValueY equals: -15.	self assert: c maxValueY equals: 0! !!RSChartTest methodsFor: 'tests' prior: 58485149!testMustInclude03	| y c x |	y := #(-10 -13 -15).	x := #(4 6 9).	c := RSChart new.	c removeAllTicks.	c addPlot: (RSLinePlot new x: x y: y).	c mustInclude0inX.	c build.	self assert: c minValueX equals: 0.	self assert: c maxValueX equals: 9.	self assert: c minValueY equals: -15.	self assert: c maxValueY equals: -10! !!RSChartTest methodsFor: 'tests' prior: 58484814!testMustInclude04	| y c |	y := OrderedCollection new.	-3.14 to: 3.14 by: 0.1 do: [ :x |		y add: x sin ].	c := RSChart new.	c removeAllTicks.	c addPlot: (RSLinePlot new y: y).	c build.	self assert: c minValueY equals: -0.9995258306054791.	self assert: c maxValueY equals: 0.9999417202299663! !!RSChartTest methodsFor: 'tests' prior: 58486836!testMustInclude05	| y c |	y := OrderedCollection new.	-3.14 to: 3.14 by: 0.1 do: [ :x |		y add: x sin ].	c := RSChart new.	c removeAllTicks.	c addPlot: (RSLinePlot new y: y).	c mustInclude0inY.	c build.	self assert: c minValueY equals: -0.9995258306054791.	self assert: c maxValueY equals: 0.9999417202299663! !!RSChartTest methodsFor: 'tests' prior: 58481901!testSameMinMax	| chart plot |	chart := RSChart new.	plot := RSLinePlot new.	plot y: #( 2 2 ).	chart addPlot: plot.	chart addDecoration: (RSChartTitleDecoration new		title: 'Reward evolution';		fontSize: 20).	chart xlabel: 'Episode' offset: 0 @ 10.	chart ylabel: 'Reward' offset: -20 @ 0.	chart build! !!RSChartTest methodsFor: 'tests'!testStylerDefault	| x tick chart |	x := -10.0 to: 20.0 count: 100.	chart := RSChart new		addPlot: (RSScatterPlot new x: x y: (x raisedTo: 3));		yourself.	tick := chart horizontalTick.	self assert: chart styler textColor equals: Color black.	self assert: tick styler textColor equals: Color black.	self assert: chart styler equals: tick styler! !!RSChartTest methodsFor: 'tests'!testStylerRedLabel	| x tick chart styler |	x := -10.0 to: 20.0 count: 100.	chart := RSChart new		addPlot: (RSScatterPlot new x: x y: (x raisedTo: 3));		yourself.	tick := chart horizontalTick.	styler := RSChartStyler new		textColor: Color red.	tick styler: styler.	chart build.	self assert: (tick labels allSatisfy: [ :line | line color = Color red ])! !!RSChartTest methodsFor: 'tests'!testStylerRedTick	| x tick chart styler |	x := -10.0 to: 20.0 count: 100.	chart := RSChart new		addPlot: (RSScatterPlot new x: x y: (x raisedTo: 3));		yourself.	tick := chart horizontalTick.	styler := RSChartStyler new		tickColor: Color red.	tick styler: styler.	chart build.	self assert: (tick ticks allSatisfy: [ :line | line color = Color red ])! !!RSChartTest methodsFor: 'tests'!testStylerRedTickInChart	| x tick chart styler |	x := -10.0 to: 20.0 count: 100.	chart := RSChart new		addPlot: (RSScatterPlot new x: x y: (x raisedTo: 3));		yourself.	tick := chart horizontalTick.	styler := RSChartStyler new		tickColor: Color red.	chart styler: styler.	chart build.	self assert: (tick ticks allSatisfy: [ :line | line color = Color red ])! !!RSChartTest methodsFor: 'tests'!testStylerSpineRed	| x chart styler spine |	x := -10.0 to: 20.0 count: 100.	chart := RSChart new		addPlot: (RSScatterPlot new x: x y: (x raisedTo: 3));		yourself.	styler := RSChartStyler new		spineColor: Color red.	spine := chart spineDecoration.	chart styler: styler.	chart build.	self assert: spine box border color equals: Color red! !!RSChartTest methodsFor: 'tests'!testStylerTitleLabel	| x title chart styler |	x := -10.0 to: 20.0 count: 100.	chart := RSChart new		addPlot: (RSScatterPlot new x: x y: (x raisedTo: 3));		yourself.	styler := RSChartStyler new		textColor: Color red.	title := chart title: 'Chart'.	chart styler: styler.	chart build.	self assert: title label color equals: Color red! !!RSChartTest methodsFor: 'tests' prior: 58482316!testWithWeirdValues	| values g d line c |	values := {Float infinity negated. Float infinity negated. 0.30102999566398114. 0.47712125471966244}.	g := RSChart new.	g removeAllTicks.	d := RSLinePlot new y: values.	g addPlot: d.	g build.	c := g canvas.	self assert: c numberOfShapes equals: 2.	self assert: c shapes first class equals: RSBox.	line := c shapes second.	self assert: line controlPoints size equals: 2! !!RSChartTest methodsFor: 'tests' prior: 58485810!testWithWeirdValuesLine	| values g d line c |	values := {Float infinity negated. Float infinity negated. 0.30102999566398114. 0.47712125471966244}.	g := RSChart new.	g removeAllTicks.	d := RSLinePlot new y: values.	g addPlot: d.	g build.	c := g canvas.	self assert: c numberOfShapes equals: 2.	self assert: c shapes first class equals: RSBox.	line := c shapes second.	self assert: line controlPoints size equals: 2! !!RSChartTest methodsFor: 'tests' prior: 58483957!testWithWeirdValuesLineWithTicks	| values chart linePlot line canvas |	values := {		          Float infinity negated.		          Float infinity negated.		          0.30102999566398114.		          0.47712125471966244 }.	chart := RSChart new.	linePlot := RSLinePlot new y: values.	chart addPlot: linePlot.	chart build.	canvas := chart canvas.	self assert: canvas numberOfShapes equals: 20.	self assert: canvas shapes first class equals: RSBox.	line := canvas shapes second.	self assert: line controlPoints size equals: 2! !!RSChartTest methodsFor: 'tests' prior: 58482774!testWithWeirdValuesLineWithTicks2	| x chart linePlot canvas labels y |	x := { -5. 0. 1. 2 }.	y := x log.	chart := RSChart new.	linePlot := RSLinePlot new x: x y: y.	chart addPlot: linePlot.	chart verticalTick doNotUseNiceLabel.	chart removeHorizontalTicks.	chart build.	self assert: chart minValueX equals: x min.	self assert: chart minValueY equals: 0. "Here is y min negative infinity but Roassal puts a 0"	self assert: chart maxValueX equals: x max.	self assert: chart maxValueY equals: y max.	canvas := chart canvas.	labels := canvas shapes select: [ :s | s class == RSLabel ].	self assert: labels first position y <= 0! !!RSChartTest methodsFor: 'tests' prior: 58486272!testYMarker	| x chart plot2 marker line y |	x := -3.14 to: 3.14 by: 0.01.	y := x cos * 0.18.	chart := RSChart new.	plot2 := RSLinePlot new.	plot2 x: x y: y.	chart addPlot: plot2.	chart horizontalTick doNotUseNiceLabel.	chart verticalTick asFloat.	marker := RSYMarkerDecoration new.	chart addDecoration: marker.	chart build.	line := marker createMarkerLineFromPlot: plot2.	self assert: line from equals: 0 @ (plot2 yScale scale: plot2 maxValueY).	self assert: line to		equals: (plot2 xScale scale: plot2 maxValueX) @ (plot2 yScale scale: plot2 maxValueY)! !!RSMarkerDecorationParametrizedTest class methodsFor: 'building suites'!testParameters	^ ParametrizedTestMatrix new		  addCase: { (#decoration -> RSXMarkerDecoration new) };		  addCase: { (#decoration -> RSYMarkerDecoration new) };		  addCase: { (#decoration -> RSLineSpineDecoration new) };		  yourself! !!RSMarkerDecorationParametrizedTest methodsFor: 'tests'!decoration: aMarkerDecoration	decoration := aMarkerDecoration! !!RSMarkerDecorationParametrizedTest methodsFor: 'tests'!testBorder	| border |	border := RSBorder new		          width: 4;		          color: Color black;		          yourself.	decoration border: border.	self assert: decoration border equals: border! !!RSMarkerDecorationParametrizedTest methodsFor: 'tests'!testColor	decoration color: Color blue.	self assert: decoration color equals: Color blue! !!RSMarkerDecorationParametrizedTest methodsFor: 'tests'!testMarker	| aMarker |	aMarker := RSBox new		           size: 5;		           asMarker.	decoration marker: aMarker.	self assert: decoration shape markers first equals: aMarker! !!RSMarkerDecorationParametrizedTest methodsFor: 'tests'!testWidth	decoration width: 18.	self assert: decoration width equals: 18! !!RSChartTitleDecorationTest methodsFor: 'tests' prior: 58490483!testBasic	| c title label |	c := RSChart new.	c removeAllTicks.	title := c title: 'hello'.	title styler textColor: Color blue.	c build.	self assert: c canvas numberOfShapes equals: 2.	label := title label.	self assert: label class equals: RSLabel.	self assert: label color equals: Color blue! !!RSChartTitleDecorationTest methodsFor: 'tests' prior: 58490127!testBasic2	| c |	c := RSChart new.	c removeAllTicks.	c addDecoration: (RSChartTitleDecoration new title: 'hello'; fontSize: 20).	c build.	self assert: c canvas numberOfShapes equals: 2.	self assert: c canvas shapes second class equals: RSLabel.	self assert: c canvas shapes second fontSize equals: 20! !!RSHistogramPlotTest methodsFor: 'tests' prior: 58766093!testBasic	| c values plot |	c := RSChart new.	values := #(1 2 3 4 5 6 7 8 9 10).	c addPlot: (plot := RSHistogramPlot new x: values).	c build.	self assert: plot bars size equals: 10.	self assert: plot xValues equals: (1 to: 10 count: 11).	self assert: (plot yValues allSatisfy: [ :v | v = 1 ])! !!RSHistogramPlotTest methodsFor: 'tests' prior: 58764366!testBinSize	| c values plot size |	c := RSChart new.	values := (1 to: 100) shuffled.	c addPlot: (plot := RSHistogramPlot new x: values; binSize: 30).	c build.	size := (plot binningStrategy computeNumberOfBinsFor: values sorted).	self assert: plot bars size equals: size! !!RSHistogramPlotTest methodsFor: 'tests' prior: 58765139!testBins	| c values plot |	c := RSChart new.	values := #(1 2 3 4 5 6 7 8 9 10).	c addPlot: (plot := RSHistogramPlot new x: values; numberOfBins: 2).	self deny: plot bins isNil.	self assert: plot numberOfBins equals: 2.	c build.	self assert: plot bars size equals: 2.	self assert: plot bins equals: (1 to: 10 count: 3).	self assert: plot xValues equals: (1 to: 10 count: 3).	self assert: (plot yValues allSatisfy: [ :v | v = 5 ])! !!RSHistogramPlotTest methodsFor: 'tests' prior: 58765638!testBinsCollection	| c values plot bins |	c := RSChart new.	bins := #(1 5 8 10).	values := #(1 2 3 4 5 6 7 8 9 10).	c addPlot: (plot := RSHistogramPlot new x: values; bins: bins).	self assert: plot bins equals: bins.	c build.	self assert: plot bars size equals: 3.	self assert: plot bins equals: bins.	self assert: plot xValues equals: bins.	self assert: plot yValues equals: #(4 3 3)! !!RSHistogramPlotTest methodsFor: 'tests' prior: 58764702!testBinsStrat	| c values plot strategy size |	c := RSChart new.	strategy := RSSturgesBinning new.	values := (1 to: 100) shuffled.	c addPlot: (plot := RSHistogramPlot new x: values; binningStrategy: strategy).	c build.	size := (strategy computeNumberOfBinsFor: values).	self assert: plot bars size equals: size.	self assert: plot xValues equals: (1 to: 100 by: 99/size)! !!RSAbstractChartTest methodsFor: 'running' prior: 58154102!setUp	super setUp.	chart := RSChart new! !!RSAbstractChartTest methodsFor: 'tests' prior: 58152763!testEmptyPlot	| p |	p := self classToTest new x: #( 0 ) y: #( 0 ).	chart addPlot: p.	chart verticalTick integer;			 numberOfTicks: 1;			 fontSize: 10.	chart horizontalTick integer;			 numberOfTicks: 1;			 fontSize: 10.	chart build! !!RSAbstractChartTest methodsFor: 'tests' prior: 58152430!testWithOnePlot	| p |	p := self classToTest new x: #(1 2 3) y: #(1 2 3).	chart addPlot: p.	self assert: chart numberOfPlots equals: 1.	chart build.	self assert: chart plots size equals: 1.	self assert: chart plots first equals: p.	self assert: p chart equals: chart! !!RSAbstractChartTest methodsFor: 'tests' prior: 58154204!testWithOnePlotWithTitle	| p |	p := self classToTest new x: #(1 2 3) y: #(1 2 3).	chart addPlot: p.	self assert: chart numberOfPlots equals: 1.	chart title: 'Hello World'.	chart build.	self assert: chart plots size equals: 1.	self assert: chart plots first equals: p.	self assert: p chart equals: chart! !!RSAbstractChartTest methodsFor: 'tests' prior: 58154575!testWithOnePlotWithTitleAndTitleOnAxes	| p |	p := self classToTest new x: #(1 2 3) y: #(1 2 3).	chart addPlot: p.	chart xlabel: 'X Axis'.	chart ylabel: 'Y Axis'.	self assert: chart numberOfPlots equals: 1.	chart title: 'Hello World'.	chart build.	self assert: chart plots size equals: 1.	self assert: chart plots first equals: p.	self assert: p chart equals: chart! !!RSAbstractChartTest methodsFor: 'tests' prior: 58153447!testWithTwoPlots	| p1 p2 |	p1 := self classToTest new x: #(1 2 3) y: #(1 2 3).	p2 := self classToTest new x: #(-1 0 1) y: #(-2 0 2).	chart addPlot: p1.	chart addPlot: p2.	self assert: chart numberOfPlots equals: 2.	self assert: chart minValueX equals: -1.	self assert: chart maxValueX equals: 3.	self assert: chart maxValueY equals: 3.	self assert: chart minValueY equals: -2! !!RSLinePlotTest methodsFor: 'tests'!testDefaultValues	| p |	p := (RSLinePlot y: #(1 2 3 4)) format: 'o-r'.	p ylabel: 'Some numbers'.	p xlabel: 'X label'.	chart := p buildChart.	self assert: chart extent equals: 250 @ 200.	self assert: chart padding equals: 15 @ 10.! !!RSLinePlotTest methodsFor: 'tests'!testLineStroke	| p |	p := (RSLinePlot y: #(1 2 3 4)) format: '--'.	chart := p buildChart.	self assert: p border style equals: (RSStrokeStyle fromString: '--').		p := (RSLinePlot y: #(1 2 3 4)) format: '-.'.	chart := p buildChart.	self assert: p border style equals: (RSStrokeStyle fromString: '-.').		p := (RSLinePlot y: #(1 2 3 4)) format: '.'.	chart := p buildChart.	self assert: p border style equals: (RSStrokeStyle fromString: '.').! !!RSLinePlotTest methodsFor: 'tests'!testMarkerShape	| circleMarkersPlot squareMarkersPlot |	circleMarkersPlot := (RSLinePlot y: #(1 2 3 4)) format: 'o-r'.	squareMarkersPlot := (RSLinePlot y: #(1 2 3 4)) format: 's-r'.	self assert: (circleMarkersPlot marker) shape class name equals: (RSShapeFactory shapeFromString: 'o') class name.	self deny: (circleMarkersPlot marker) shape class name equals: (RSShapeFactory shapeFromString: 's') class name.	self assert: (squareMarkersPlot marker) shape class name equals: (RSShapeFactory shapeFromString: 's') class name.! !!RSLinePlotTest methodsFor: 'tests'!testMarkerSize	| p |	p := (RSLinePlot y: #(1 2 3 4)) format: 'o-r'.	chart := p buildChart.	"Is it correct that buildChart modify and return attributes of plot?"	self assert: p shape markerStart shape extent equals: 4@4! !!RSLinePlotTest methodsFor: 'tests'!testPlotWithOneCollection	| p window |	p := (RSLinePlot y: #(1 2 3 4)) format: 'o-r'.	p ylabel: 'Some numbers'.	p xlabel: 'X label'. 	window := p open.	self assert: p y equals: #(1 2 3 4).	self assert: p x equals: #(1 2 3 4).	self assert: p format equals: 'o-r'.	self assert: p ylabel equals: 'Some numbers'.	self assert: p xlabel equals: 'X label'.	self assert: window isDisplayed.	window delete.	self flag: 'Add title and rename format2'! !!RSDensityPlotTest methodsFor: 'tests'!testCreatePlotWihtKernelDensity	| data densityPlot kernelDensity |	data := #(1 2 5 36 5 12 3).	kernelDensity := RSKernelDensity data: data.	densityPlot := RSDensityPlot kernelDensity: kernelDensity.	self assert: densityPlot kernel class equals: RSKernelGaussianFunction.	self assert: densityPlot data equals: data.! !!RSDensityPlotTest methodsFor: 'tests'!testDataIsACollectionOfNumbers	| data fakeData densityPlot |	data := #(1 2 5 36 5 12 3).	densityPlot := RSDensityPlot data: data.	fakeData := #('a' 'b' '15' '25').	self should: [ densityPlot := RSDensityPlot data: fakeData. ] raise: Error! !!RSDensityPlotTest methodsFor: 'tests'!testDefaultColor	| densityPlot data kernelDensity window |	data := #(-25 -25 -25 -25 10 20 30 40 50 50 50 50 ).	kernelDensity := RSKernelDensity data: data.	kernelDensity bandwidth: 10.	densityPlot := RSDensityPlot kernelDensity: kernelDensity.	window := densityPlot open. "area assigned to plot on renderIn"	self assert: densityPlot area color equals: densityPlot defaultAreaColor.	window delete.! !!RSDensityPlotTest methodsFor: 'tests'!testDensityPlotDefaultValues	| densityPlot data |	data := #(1 2 2 2 3 4).	densityPlot := RSDensityPlot data: data. 	self assert: densityPlot data equals: data.	self assert: (densityPlot kernel isKindOf: RSKernelFunction).	self assert: densityPlot bandwidth equals: 1.! !!RSDensityPlotTest methodsFor: 'tests'!testDensityPlotHasKernelDensity	| densityPlot data kernelDensity |	data := #(14 15 28 27 32 35).	densityPlot := RSDensityPlot data: data.	kernelDensity := densityPlot kernelDensity.	self assert: kernelDensity kernel class equals: RSKernelGaussianFunction.! !!RSDensityPlotTest methodsFor: 'tests'!testKernelDensityEstimation	| densityPlot data |	data := #(14 15 28 27 32 35).	densityPlot := RSDensityPlot data: data.	densityPlot bandwidth: 4.	self assert: (densityPlot kde: 30) closeTo: 0.0495.! !!RSDensityPlotTest methodsFor: 'tests'!testOpen	| densityPlot data window |	data := #(14 15 28 27 32 35).	densityPlot := RSDensityPlot data: data.	window := densityPlot open.	self assert: window isDisplayed.	window delete.! !!RSDensityPlotTest methodsFor: 'tests'!testRedArea	| densityPlot data area |	data := #(14 15 28 27 32 35).	densityPlot := RSDensityPlot data: data.	chart := RSChart new.	densityPlot shape color: Color red.	chart add: densityPlot.	chart build.	area := densityPlot area.	self assert: area class equals: RSPolygon.	self assert: area color equals: Color red.	self assert: area equals: densityPlot createdShapes first.! !!RSDensityPlotTest methodsFor: 'tests'!testSetBandwidth	| densityPlot data |	data := #(1 2 2 2 3 4).	densityPlot := RSDensityPlot data: data. 	self assert: densityPlot bandwidth equals: 1.	densityPlot bandwidth: 4.	self assert: densityPlot bandwidth equals: 4.! !!RSDensityPlotTest methodsFor: 'tests'!testSetColor	| densityPlot data color |	data := #(1 2 2 2 3 4).	densityPlot := RSDensityPlot data: data.	color := Color blue.		densityPlot color: color. 	self assert: densityPlot areaColor equals: color.! !!RSDensityPlotTest methodsFor: 'tests'!testSetLabels	| densityPlot data |	data := #(1 2 2 2 3 4).	densityPlot := RSDensityPlot data: data. 	densityPlot xlabel: 'x label'; ylabel: 'y label'; title:'Density plot'.	self assert: densityPlot xlabel equals: 'x label'.	self assert: densityPlot ylabel equals: 'y label'.	self assert: densityPlot title equals: 'Density plot'.! !!RSKernelDensityTest methodsFor: 'tests'!testBadKernelArgument	| kernelDensity anXValue |	anXValue := 30.	kernelDensity := RSKernelDensity basicNew		bandwidth: 4.0.	self should: [ kernelDensity kernel: RSKernelDensity gaussian. ] raise: Error.! !!RSKernelDensityTest methodsFor: 'tests'!testBasicNewKernelDensity	| kernelDensity anXValue |	anXValue := 30.	kernelDensity := RSKernelDensity basicNew		bandwidth: 4.0;		kernel: RSKernelFunction gaussian.	self assert: (kernelDensity evaluateKernel: anXValue) closeTo: 1.4736e-196.! !!RSKernelDensityTest methodsFor: 'tests'!testDensityCurveSample	| data proveValues validationValues kernelDensity |	data := #(14 15 28 27 32 35).	proveValues := #(0 15 20 30 50).	validationValues := #(5.105e-05 0.033 0.019 0.0495 1.536e-05).	kernelDensity := RSKernelDensity data: data.	kernelDensity bandwidth: 4.	self assert: (kernelDensity densityCurveSample: proveValues) closeTo: validationValues.! !!RSKernelDensityTest methodsFor: 'tests'!testKDEDefaultBandwidth	| kernelDensity |	kernelDensity := RSKernelDensity gaussian.	self assert: kernelDensity bandwidth closeTo: 1.00.! !!RSKernelDensityTest methodsFor: 'tests'!testKDESetBandwidth	| kernelDensity anXValue |	kernelDensity := RSKernelDensity gaussian.	kernelDensity bandwidth: 4.	anXValue := 30. 	self assert: (kernelDensity evaluateKernel: anXValue) closeTo: 1.4736e-196.! !!RSKernelDensityTest methodsFor: 'tests'!testKernelDensityEstimation	| kernelDensity anXValue data |	data := #(14 15 28 27 32 35).	kernelDensity := RSKernelDensity data: data.	kernelDensity bandwidth: 4.	anXValue := 30.	self assert: (kernelDensity kde: anXValue) closeTo: 0.0495.! !!RSKernelDensityTest methodsFor: 'tests'!testKernelFunction	| kernelDensity anXValue |	kernelDensity := RSKernelDensity gaussian.	anXValue := 30. 	self assert: (kernelDensity evaluateKernel: anXValue) closeTo: 1.4736e-196.! !!RSMarkerTest methodsFor: 'tests'!testAverageX	| plot marker mark |	plot := RSScatterPlot new x: { 1. 2. 6 } y: { 1. 1. 1 }.	marker := RSXMarkerDecoration new average.	mark := marker getValueToBeMarkedFromPlot: plot.	self assert: mark equals: 3! !!RSMarkerTest methodsFor: 'tests'!testAverageY	| plot marker mark |	plot := RSScatterPlot new x: { 1. 1. 1 } y: { 1. 2. 6 }.	marker := RSYMarkerDecoration new average.	mark := marker getValueToBeMarkedFromPlot: plot.	self assert: mark equals: 3! !!RSMarkerTest methodsFor: 'tests'!testSumUpTo	| plot marker mark |		plot := RSScatterPlot new x: (1 to: 5) y: { 5. 5. 1 . 4 . 5 }.	marker := RSXMarkerDecoration new sumUpTo: 0.6.	mark := marker getValueToBeMarkedFromPlot: plot.		self assert: mark equals: 4! !!RSMarkerTest methodsFor: 'tests'!testSumUpToLimit0	| plot marker mark |		plot := RSScatterPlot new x: (1 to: 5) y: (1 to: 5).	marker := RSXMarkerDecoration new sumUpTo: 0.	mark := marker getValueToBeMarkedFromPlot: plot.	self assert: mark equals: 1! !!RSMarkerTest methodsFor: 'tests'!testSumUpToLimit1	| plot marker mark |		plot := RSScatterPlot new x: (1 to: 5) y: (1 to: 5).	marker := RSXMarkerDecoration new sumUpTo: 1.	mark := marker getValueToBeMarkedFromPlot: plot.	self assert: mark equals: 5! !!RSKiviatTest methodsFor: 'tests' prior: 58836183!testAccessingCreatedShapes	| kiviat |	kiviat := RSKiviat new.	kiviat addRow: #(1 2 3).	kiviat axisNames: #(a b c).	kiviat build.	self assert: (kiviat labels collect: #text) asArray equals: #(a b c).	self assert: (kiviat axis allSatisfy: [:shape | shape class = RSLine ]).	self assert: (kiviat backgroundShapes  allSatisfy: [ :shape | shape class = RSEllipse ]).	self assert: kiviat polygonShapes size equals: 1.	self assert: (kiviat polygonShapes allSatisfy: [ :shape | shape class = RSPolygon ]).	self assert: kiviat shapes isNotNil.	self		assert: kiviat shapes size		equals: (#(backgroundShapes axis labels polygonShapes)			collect: [ :selector | (kiviat perform: selector) size ]) sum! !!RSKiviatTest methodsFor: 'tests' prior: 58837742!testBasic	| kiviat |	kiviat := RSKiviat new.	kiviat addRow: #(1 2 3).	kiviat axisNames: #(a b c).	self assert: kiviat shouldUseEllipse.	self assert: kiviat radius equals: 200.	self deny: kiviat shouldUsePolygonBorder.	self assert: kiviat shouldUsePolygonFillColor.	self deny: kiviat shouldUseDots! !!RSKiviatTest methodsFor: 'tests' prior: 58837310!testMaxMinValues	| kiviat |	"one value"	kiviat := RSKiviat new.	kiviat addRow: #(1 2 3).	kiviat axisNames: #(a b c).	kiviat minValue: 1.	kiviat maxValue: 5.	kiviat build! !!RSKiviatTest methodsFor: 'tests' prior: 58837538!testOddCollectionSize	| kiviat |	kiviat := RSKiviat new.	kiviat addRow: #(1 2 3).	kiviat axisNames: #(a).	self should: [ kiviat build ] raise: Error! !!RSKiviatTest methodsFor: 'tests' prior: 58836941!testZeroValues	| kiviat |	"one value"	kiviat := RSKiviat new.	kiviat addRow: #(1).	kiviat axisNames: #(a).	kiviat build.	"zero values"	kiviat := RSKiviat new.	kiviat addRow: #().	kiviat axisNames: #().	kiviat build.	kiviat := RSKiviat new.	"use addRow: first"	self should: [ kiviat build ] raise: Error! !RSNumberTest removeSelector: #testToCount4!RSNumberTest removeSelector: #testToCount3!RSNumberTest removeSelector: #testToCount2!RSNumberTest removeSelector: #testToCount!Smalltalk globals removeClassNamed: #AnObsoleteRSNumberTest!RSLabelGeneratorTest removeSelector: #testSearch!RSLabelGeneratorTest removeSelector: #testError!RSLabelGeneratorTest removeSelector: #setUp!Smalltalk globals removeClassNamed: #AnObsoleteRSLabelGeneratorTest!"Roassal3-Chart-Tests"!!RSUMLClassBuilderTest methodsFor: 'tests' prior: 59474056!testJustClassName	| builder shape  |	builder := self classToTest new.	builder classes: {RSMouseMove}.	builder build.	shape := builder shapes first.	self assert: shape shapes size equals: 2.	self assert: shape shapes first class equals: RSBox.	self assert: shape shapes second class equals: RSComposite.	builder := self classToTest new.	builder classes: {RSMouseMove}.	builder renderer: RSTorchUMLClassRenderer new.	builder build.	shape := builder shapes first.	self assert: shape shapes size equals: 3.	self assert: shape shapes first class equals: RSBox.	self assert: shape shapes second class equals: RSComposite.	self assert: shape shapes third class equals: RSBox! !"Roassal3-UML-Tests"!!RoassalSpecTest methodsFor: 'tests' prior: 60391005!isValid	^ Smalltalk globals includesKey: #SpRoassalPresenter! !!RoassalSpecTest methodsFor: 'tests' prior: 60391821!testBasic	| spec value window |	self isValid ifFalse: [ ^ self ].	spec := SpRoassalPresenter new.	window := spec asWindow open.	value := 0.	spec script: [ :view | view addShape: RSBox new. value := value + 1 ].	self assert: value equals: 1.	spec script: [ :view | view addShape: RSBox new. value := 0 ].	self assert: value equals: 0.	window close! !!RoassalSpecTest methodsFor: 'tests' prior: 60391122!testTakeKeyboardFocus	| spec window canvas window2 |	self isValid ifFalse: [ ^ self ].	canvas := RSCanvas new		add: (RSBox new size: 100);		@ RSCanvasController;		yourself.	spec := SpRoassal3InspectorPresenter new.	spec canvas: canvas.	window := spec open.	window2 := StPlayground new open.	self deny: canvas morph hasKeyboardFocus.	canvas morph mouseDown: (MouseButtonEvent new		setType: nil		position: canvas morph center		which: MouseButtonEvent yellowButton		buttons: MouseButtonEvent yellowButton		hand: canvas morph activeHand		stamp: nil).	self assert: canvas morph hasKeyboardFocus.	window delete.	window2 delete! !"Roassal3-Spec-Tests"!!RSInspectorShapeTest methodsFor: 'tests' prior: 58814689!testNoEvents	| box label composite canvas copy boxCopy labelCopy |	box := RSBox new.	label := RSLabel new text: 'io'.	box popup.	label popup.	composite := { box. label } asShape.	composite when: RSMouseEnter do: [:evt | ] for: self.	canvas := composite canvasForInspector.	self assert: canvas shapes size equals: 1.	copy := canvas shapes first.	self assert: copy children size equals: composite children size.	boxCopy := copy children first.	labelCopy := copy children second.	self assert: boxCopy class equals: RSBox.	self assert: labelCopy class equals: RSLabel.	self assert: copy privateAnnouncer isNil.	self assert: boxCopy privateAnnouncer isNil.	self assert: labelCopy privateAnnouncer isNil! !!RSSelectionPresentationTest methodsFor: 'tests' prior: 59177034!testBasic	| c shapes |	c := RSCanvas new.	shapes := (1 to: 100) collect: [ :v | RSBox new model: v ] as: RSGroup.	c addAll: shapes.	RSNormalizer size shapes: shapes; normalize: #yourself.	RSFlowLayout on: shapes.	shapes @ RSSelectionPresentationInteraction.	"make sure there is no error when clicking on an element, while being outside the GTInspector"	c nodes first announce: RSMouseClick! !!RSSelectionPresentationTest methodsFor: 'tests' prior: 59176783!testCanvasInspect	| c  window |	c := RSCanvas new.	c add: RSBox new.	window := c inspect.	window class = RSCanvas		ifTrue: [ c morph window delete ]		ifFalse: [ window delete ]! !!RSSelectionPresentationTest methodsFor: 'tests' prior: 59176532!testWithNoCanvas	| shapes |	shapes := (1 to: 100) collect: [ :v | RSBox new model: v ] as: RSGroup.	shapes @ RSSelectionPresentationInteraction.	shapes first announce: RSMouseClick! !"Roassal3-Inspector-Tests"!!RSMapBuilderTest methodsFor: 'tests' prior: 58966878!testAttributes	| map |	map := RSMapBuilder new.	map baseline: BaselineOfMorphic.	self assert: map models isCollection.	self assert: map models size > 1! !!RSMapBuilderTest methodsFor: 'tests' prior: 58966608!testHighlightOnNode	| builder |	builder := RSThemedMapBuilder new.	builder baseline: BaselineOfGeometry.	builder build.	builder highlight: (RSHighlightEvent new		shape: builder canvas nodes first;		yourself)! !"Roassal3-BaselineMap-Tests"!!RSSVGTest methodsFor: 'tests'!testBimetricLine	| s1 s2 l |	canvas := RSCanvas new.	s1 := RSBox new		color: Color blue;		draggable;		size: 100;		yourself.	s2 := RSBox new		translateTo: 400@0;		draggable;		size: 100;		yourself.	l := RSBimetricLine new		widthFrom: 50;		widthTo: 10;		paint: Color red;		border: nil;		withBorderAttachPoint;		from: s1;		to: s2;		yourself.	canvas addAll: { s1. s2. l}.	^ canvas! !!RSSVGTest methodsFor: 'tests'!testDrawSVG	canvas addShape: (RSSVGPath new).	canvas addShape: (RSSVGPath new		svgPath: 'M 100 350 q 150 -300 300 0';		yourself).	canvas createMorph drawOnMockCanvas! !!RSSVGTest methodsFor: 'tests'!testDrawSVGLine	canvas addShape: (RSSVGPathLine new		strokeColor: Color red;		svgPath: [ :aLine | 'M 100 100 L 200 200' ];		width: 2).	canvas addShape: (RSSVGPathLine new		strokeColor: Color red;		svgPath: [:aLine | String streamContents: [:stream |			| a b |			a := aLine startPoint.			b := aLine endPoint.			stream				nextPutAll: 'M ';				nextPutAll: a x asString;				space;				nextPutAll: a y asString;				space;				nextPutAll: 'L ';				nextPutAll: b x asString;				space;				nextPutAll: b y asString.		] ];		startPoint: 100@100;		endPoint: 200@200;		width: 2).	canvas addShape: (RSSVGPathLine new		strokeColor: Color red;		svgPath: [ :aLine | [ :aCanvas|			aCanvas				absolute;				moveTo: aLine startPoint;				lineTo: aLine endPoint. ] ];		width: 2).	canvas createMorph drawOnMockCanvas! !"Roassal3-SVG-Tests"!!RSSVGShapeExamples commentStamp: '' prior: 0!I have basic svg examples!!RSSVGAnimationExamples commentStamp: '' prior: 0!I have animated svg examples!!RSChartExample methodsFor: '*Roassal3-SVG-Examples'!example13AreaPlot	<script: 'self new example13AreaPlot open'>	| x y1 y2  c canvas charts |	x := 0 to: 2 by: 0.01.	y1 := (2 * Float pi * x) sin.	y2 := 1.2 * (4 * Float pi * x) sin.	canvas := RSCanvas new.	charts := {'Between y1 and 0'-> (y1 -> 0).	'Between y2 and 1'-> (y1 -> 1).	'Between y1 and y2'-> (y1 -> y2)} collect: [ :assoc |		c := RSChart new.		c extent: 500@100.		c addPlot: (RSAreaPlot new x: x y1: assoc value key y2: assoc value value).		c horizontalTick numberOfTicks: 10; asFloat.		c verticalTick numberOfTicks: 3; asFloat.		c ylabel: assoc key.		c asShape	].	RSVerticalLineLayout on: charts.	canvas addAll: charts.	canvas @ RSCanvasController.	^ canvas! !!RSChartExample methodsFor: '*Roassal3-SVG-Examples'!example14AreaPlotWithError	<script: 'self new example14AreaPlotWithError open'>	| x y polyfit res y_est y_err c scatter |	x := 0 to: 10.	y := #(3.9 4.4 10.8 10.3 11.2 13.1 14.1 9.9 13.9 15.1 12.5).	polyfit := [ :x1 :y1 :n |		"TODO"		"Need a real polyfit implementation for any n"		"maybe not in roassal3 maybe in polymath"		"https://en.wikipedia.org/wiki/Curve_fitting"		0.9-> 6].	res := polyfit value: x value: y value: 1.	y_est := res key * x + res value.	y_err := x stdev * ( (1/x size) +		(( (x - x average) raisedTo: 2) /		((x - x average) raisedTo: 2) sum) ) sqrt.	c := RSChart new.	c padding: 10@10.	c addPlot: (RSAreaPlot new x: x y1: y_est + y_err y2: y_est - y_err; color: (Color blue alpha: 0.1) ).	c addPlot: (RSLinePlot new x: x y: y_est; color: Color red).	c addPlot: (scatter := RSScatterPlot new x: x y: y).	scatter color: Color red.	c horizontalTick numberOfTicks: 10; asFloat.	c verticalTick numberOfTicks: 3; asFloat.	^ c! !!RSChartExample methodsFor: '*Roassal3-SVG-Examples'!example15AreaBox	<script: 'self new example15AreaBox open'>	| x y1 y2 c |	x := #(0 1 2 3).	y1 := #(0.8 0.8 0.2 0.2).	y2 := #(0 0 1 1).	c := RSChart new.	c extent: 150@50.	c addPlot: (RSAreaPlot new x: x y1: y1 y2: y2).	c addPlot: (RSLinePlot new x: x y: y1; color: Color red; format: 's--').	c addPlot: (RSLinePlot new x: x y: y2; color: Color orange; format: 'o--').	c horizontalTick numberOfTicks: 7; asFloat.	c verticalTick asFloat.	^ c! !!RSChartExample methodsFor: '*Roassal3-SVG-Examples'!example16Series	<script: 'self new example16Series open'>	| x cumsum c b y error |	x := 1 to: 100.	cumsum := [:arr | | sum |		sum := 0.		arr collect: [ :v | sum := sum + v. sum ] ].	c := RSChart new.	c extent: 400@400.	b := RSLegend new.	b container: c canvas.	b layout horizontal gapSize: 30.	#(	series1 red	series2 blue) pairsDo: [ :label :color |		y := (x collect: [ :i | 50 atRandom - 25 ]).		y := cumsum value: y.		error := x.		c addPlot: (RSAreaPlot new			x: x y1: y + error y2: y - error;			color: (color value: Color) translucent).		c addPlot: (RSLinePlot new x: x y: y; format: 'o';			color: (color value: Color)).		b text: label withBoxColor: (color value: Color)		 ].	c build.	b build.	^ c canvas! !!RSChartExample methodsFor: '*Roassal3-SVG-Examples'!example17CLPvsUSD	<script: 'self new example17CLPvsUSD open'>	| dates y data x c plot paint horizontal |	dates := OrderedCollection new.	y := OrderedCollection new.	data :=	{'04-jun-2020'.	769.13.	'03-jun-2020'.	782.86.	'02-jun-2020'.	796.46.	'01-jun-2020'.	806.32.	'29-may-2020'.	812.74.	'28-may-2020'.	816.47.	'27-may-2020'.	802.10.	'26-may-2020'.	803.74.	'25-may-2020'.	805.75.	'22-may-2020'.	806.17.	'20-may-2020'.	819.08.	'19-may-2020'.	820.65.	'18-may-2020'.	823.86.	'15-may-2020'.	822.93.	'14-may-2020'.	820.38.	'13-may-2020'.	821.88.	'12-may-2020'.	826.05.	'11-may-2020'.	827.65.	'08-may-2020'.	836.27.	'07-may-2020'.	839.08.	'06-may-2020'.	832.84.	'05-may-2020'.	838.74.	'04-may-2020'.	837.92} reverse.		data pairsDo: [ :f :d |			dates add: d.			y add: f ].	x := 1 to: dates size.	c := RSChart new.	c extent: 300@200.	plot := RSAreaPlot new x: x y1: y y2: 750.	paint := LinearGradientPaint fromArray:		{0-> (Color green alpha: 0.3).		0.8 -> Color transparent}.	paint start: 0@ -100; stop: 0@ 100.	plot shape paint: paint.	c addPlot: plot.	plot := RSLinePlot new x: x y: y.	plot color: Color green muchDarker.	plot width: 2.	plot joinRound.	plot markerEnd: (RSEllipse new size: 10).	c addPlot: plot.	horizontal := c horizontalTick fromNames: dates.	horizontal configuration fontSize: 4.	horizontal useDiagonalLabel.	c verticalTick numberOfTicks: 10; asFloat.	c title: 'CLP vs USD'.	^ c! !!RSChartExample methodsFor: '*Roassal3-SVG-Examples'!example18Animation	<script: 'self new example18Animation inspect'>	| c canvas line points current lineAnimation area paint afterline yticks xticks |	c := self example17CLPvsUSD.	c build.	canvas := c canvas.	"line"	line := canvas shapes detect: [ :s | s class = RSPolyline ].	points := line controlPoints.	current := OrderedCollection new.	current		add: points first;		add: points second.	line controlPoints: current.	lineAnimation := (2 to: points size)		                 collect: [ :i |			                 canvas transitionAnimation				                 duration: 100 milliSeconds;				                 from: (points at: i - 1);				                 to: (points at: i);				                 onStepDo: [ :t |					                 current						                 removeLast;						                 add: t.					                 line controlPoints: current ];				                 when: RSAnimationEndEvent				                 do: [ current add: (points at: i) ]				                 for: self ]		                 as: OrderedCollection.	"area"	area := canvas shapes detect: [ :s | s class = RSSVGPath ].	paint := area paint.	area noPaint.	afterline := canvas parallelAnimation.	afterline add: (canvas transitionAnimation onStepDo: [ :t |			 area paint: (Color transparent interpolateTo: paint at: t) ]).	lineAnimation add: afterline.	canvas animationFrom: lineAnimation.	"ticks"	yticks := canvas shapes select: [ :s | s class = RSLabel ].	yticks do: [ :s | s bold ].	yticks := yticks groupedBy: [ :s | s matrix sy ].	xticks := yticks values first.	yticks := yticks values second.	xticks doWithIndex: [ :s :index |		canvas newAnimation			delay: (index - 1 * 100) milliSeconds;			duration: 200 milliSeconds;			from: Color transparent;			to: s color;			on: s set: #color:.		s color: Color transparent ].	yticks doWithIndex: [ :s :index |		s noPaint.		afterline add: (canvas transitionAnimation				 delay: (index * 300) milliSeconds;				 duration: 2 second;				 easing: RSEasingInterpolator elasticOut;				 from: -100 @ s position y;				 to: s position;				 onStepDo: [ :p |					 s color: Color black.					 s position: p ]) ].	^ canvas! !!RSLayoutExamples methodsFor: '*Roassal3-SVG-Examples'!example14ClassHierarchy	<script: 'self new example14ClassHierarchy open'>	| c classes |	c := RSCanvas new.	classes := (Object withAllSubclasses first: 300)		flatCollect: #withAllSuperclasses.	classes := classes asSet		collect: [:cls | RSEllipse new draggable; popup; model: cls; yourself]		as: RSGroup.	c addAll: classes.	RSLineBuilder line		color: Color gray;		canvas: c;		shapes: classes;		connectFrom: #superclass.	RSNormalizer size		shapes: classes;		to: 20;		normalize: #numberOfMethods.	RSNormalizer color		shapes: classes;		normalize: #numberOfMethods.	RSClusterTreeLayout on: classes.	RSMultiBezierEdgeBuilder multiBezier		borderColor: (Color blue alpha: 0.3);		canvas: c;		shapes: classes;		withBorderAttachPoint;		following: #superclass;		connectToAll: #dependentClasses.	c @ RSCanvasController.	^ c! !!RSBasicShapeExamples methodsFor: '*Roassal3-SVG-Examples'!example16BasicLinePath	<script: 'self new example16BasicLinePath open'>	| c b1 b2 translate l arrowWidth arrowHeight middle |	c := RSCanvas new.	b1 := RSBox new size: 100 @ 100.	b2 := RSBox new		      size: 100 @ 100;		      color: Color blue;		      position: 100 @ 100.	c addShape: b1.	c addShape: b2.	l := RSSVGPathLine new		     svgPath: [ :aLine |			     [ :canvas |			     | vector u unit left right left1 right1 a b |			     a := aLine startPoint.			     b := aLine endPoint.			     arrowWidth := 50.			     arrowHeight := 30.			     vector := a - b.			     u := vector normal.			     unit := vector / (vector r max: 1).			     middle := b + (unit * arrowHeight).			     left := middle - (u * arrowWidth / 4).			     right := middle + (u * arrowWidth / 4).			     left1 := middle - (u * arrowWidth / 2).			     right1 := middle + (u * arrowWidth / 2).			     canvas				     absolute;				     moveTo: a;				     lineTo: left;				     lineTo: left1;				     lineTo: b;				     lineTo: right1;				     lineTo: right;				     close ] ];		     width: 5;		     paint: Color yellow;		     dashArray: { 10. 2 };		     joinMiter;		     startPoint: 0 @ 0;		     endPoint: 100 @ 100.	c addShape: l.	translate := [ :evt |	             l		             startPoint: b1 position;		             endPoint: b2 position.	             evt shape translateBy: evt step.	             evt signalUpdate ].	b1 when: RSMouseDragging do: translate for: self.	b2 when: RSMouseDragging do: translate for: self.	^ c! !!RSSVGShapeExamples methodsFor: 'examples'!example01SVGShape	<script: 'self new example01SVGShape open'>	| c |	c := RSCanvas new.	c addShape: (RSSVGPath new		paint: nil;		withBorder;		svgPath: 'M 100 350 q 150 -300 300 0';		yourself).	c addShape: (RSSVGPath new		paint: nil;		border: (RSBorder new color: Color red);		svgPath: 'M 100 350 l 150 -300';		yourself).	c addShape: (RSSVGPath new		paint: nil;		border: (RSBorder new color: Color red);		svgPath: 'M 250 50 l 150 300';		yourself).	c addShape: (RSSVGPath new		paint: nil;		border: (RSBorder new color: Color green);		svgPath: 'M 175 200 l 150 0';		yourself).	c showEncompassingRectangles.	c zoomToFit.	^ c! !!RSSVGShapeExamples methodsFor: 'examples'!example02SpockLizard	<script: 'self new example02SpockLizard open'>	| canvas radius paint arrow relations color lb |	canvas := RSCanvas new.	radius := 1500.	paint := LinearGradientPaint fromArray: {(0 -> 'E0BA82'). (1 -> 'F4DFA5')}.	paint start: -900 @ 900; stop: 900 @ -900.	canvas addShape: (RSEllipse new		noPaint;		border: (RSBorder new			width: 300;			paint: paint;			yourself);		radius: 1500;		yourself).	arrow := RSShapeFactory triangle		extent: 380 @ 200;		color: '36C5B8';		yourself.	1 to: 5 do: [ :i |		| angle a |		angle := i * 360 / 5 + 45.		canvas addShape: (RSPieSlice new			color: '36C5B8';			innerRadius: 1350;			externalRadius: 1650;			alphaAngle: angle;			betaAngle: (angle := angle + 15)).		a := arrow copy.		a matrix rotateByDegrees: angle negated.		angle := (angle + 3) degreesToRadians.		a position: angle cos @ angle sin negated * radius.		canvas addShape: a ].	canvas addAll: (#('paper' 'scissors' 'spock' 'lizard' 'rock')		collectWithIndex: [:m :index|			| com ang circle hand |			ang := index * Float twoPi / 5 - Float halfPi.			hand := RSSVGPath new				svgPath: (m asSymbol value: self).			circle := RSEllipse new				color: Color white;				position: hand position;				size: (hand extent x max: hand extent y);				yourself.			com := { circle. hand } asShape				popup;				draggable;				model: m;				position: ang cos @ ang sin * radius				yourself.			index = 5 ifTrue: [ com scaleBy: 2 ].			com		]).	relations := {('scissors' -> 'lizard').	('lizard' -> 'paper').	('paper' -> 'spock').	('spock' -> 'rock').	('rock' -> 'scissors')}.	color := NSScale category20c.	RSLineBuilder bezier		controlPointsController: (RSBlockCPController new			block: [ :aLine |				| vec f t a b |				a := aLine from position.				b := aLine to position.				vec := b - a.				f := vec * 0.25 + a.				t := vec * 0.75 + a.				Array with: f with: 0@0 with: t ];			yourself);		canvas: canvas;		useAssociations: relations.	canvas edges do: [ :ed | | col |		col := color scale: ed.		ed			border: (RSBorder new				width: 300;				color: col;				yourself);			markerEnd: ((arrow copy				color: col				yourself) asMarker				offset: -90;				yourself)  ].	lb := RSLegend new.	lb defaultLabel fontSize: 50.	lb container: canvas.	lb legendDo: [ :l |l withBorder;padding: 50 ].	lb		text:			'... It''s very simple. Scissors cuts paper, paper covers rock, rock crushes lizard, lizard poisons Spock, Spock smashes scissors, ';		text:			'scissors decapitates lizard, lizard eats paper, paper disproves Spock, Spock vaporizes rock, and, as it always has, rock crushes scissors';		build.	canvas @ RSCanvasController.	^ canvas! !!RSSVGShapeExamples methodsFor: 'data - svg'!lizard	^ 'M560.8,71.3c19.5,0,38,4.5,55.5,13.4c17.5,8.9,32.1,21.2,43.5,36.8l273.7,373.7c37.6,50.7,56.5,108,56.5,171.8v169.9c0,25.5-8.9,47.2-26.8,65.1s-39.6,26.8-65.1,26.8H714.4c-25.5,0-47.2-8.9-65.1-26.8s-26.8-39.6-26.8-65.1v-84.7l-136.9-68.4H224.4c-25.5,0-47.2-8.9-65.1-26.8c-17.9-17.9-26.8-39.6-26.8-65.1v-15.3c0-38,13.5-70.4,40.4-97.4c27-27,59.4-40.4,97.4-40.4h201l20.1-61.3H163.1c-31.9,0-59.6-10.8-83-32.3c-23.4-21.5-36.4-48.1-39-79.7C20.4,240.3,10,211.3,10,178.4v-15.3c0-25.5,8.9-47.2,26.8-65.1c17.9-17.9,39.6-26.8,65.1-26.8H560.8L560.8,71.3z M928.8,836.9V667c0-50.1-14.8-95.4-44.5-135.9L610.1,157.4c-12.4-16.6-28.9-24.9-49.3-24.9H101.9c-8.3,0-15.5,3-21.5,9.1c-6.1,6.1-9.1,13.2-9.1,21.5c0,10.2,0.2,18.1,0.7,23.7c0.5,5.6,2,12,4.5,19.4s6.5,14.2,12,20.6c3.2-9.9,8.9-17.9,17-23.9s17.1-9.1,27-9.1h398.1v15.3H132.5c-8.3,0-15.5,3-21.5,9.1c-6.1,6.1-9.1,13.2-9.1,21.5c0,14,0.5,23.3,1.4,27.8c2.6,14,9.6,25.7,21.1,34.9c11.5,9.3,24.4,13.9,38.8,13.9h349.8c12.8,0,23.6,4.5,32.5,13.4c8.9,8.9,13.4,19.8,13.4,32.5c0,4.8-0.8,9.6-2.4,14.4l-30.6,91.9c-3.2,9.3-8.8,16.8-16.7,22.7c-8,5.9-16.9,8.9-26.8,8.9h-212c-21.1,0-39.1,7.5-54.1,22.5c-15,15-22.5,33-22.5,54.1v15.3c0,8.3,3,15.5,9.1,21.5c6.1,6.1,13.2,9.1,21.5,9.1h268.4c5.1,0,9.7,1.1,13.9,3.3l151.7,75.6c7.7,4.1,13.8,9.9,18.4,17.2c4.6,7.3,6.9,15.3,6.9,23.9v94.3c0,8.3,3,15.5,9.1,21.5c6.1,6.1,13.2,9.1,21.5,9.1h183.8c8.3,0,15.5-3,21.5-9.1C925.7,852.3,928.8,845.2,928.8,836.9L928.8,836.9z'! !!RSSVGShapeExamples methodsFor: 'data - svg'!paper	^ 'M535.1,80.1c-16.8,0-31.2,6-43.2,18.1c-12,12-18.1,26.4-18.1,43.2v358.8h-17.5V211.3c0-16.8-6-31.2-18.1-43.2c-12-12-26.4-18.1-43.2-18.1c-16.8,0-31.1,6-43.2,18.1c-12,12-18.1,26.4-18.1,43.2v428.8l-84.2-112.1c-13.9-18.6-32.5-27.9-55.8-27.9c-19.3,0-35.8,6.8-49.5,20.5c-13.7,13.7-20.5,30.2-20.5,49.5c0,15.7,4.7,29.7,14.2,42.1l210,280c13.9,18.6,32.5,27.9,55.8,27.9h376.3c12.4,0,23.5-4,33.4-12c9.8-8,16.1-18.2,18.6-30.7l41.6-221.5c1.8-11.7,2.7-22.4,2.7-32.3V351.3c0-16.8-6-31.2-18.1-43.2c-12-12-26.4-18.1-43.2-18.1c-16.8,0-31.1,6-43.2,18.1c-12,12-18.1,26.4-18.1,43.2V500h-17.5V211.3c0-16.8-6-31.1-18.1-43.2c-12-12-26.4-18.1-43.2-18.1c-16.8,0-31.1,6-43.2,18.1c-12,12-18.1,26.4-18.1,43.2V500h-17.5V141.2c0-16.8-6-31.1-18.1-43.2C566.3,86,551.9,80,535.1,80.1L535.1,80.1z M535.1,10.1c24.8,0,47.6,6.5,68.6,19.4c21,12.9,37.1,30.5,48.4,52.8c6.9-1.4,14.6-2.2,23-2.2c36.1,0,67,12.9,92.7,38.6c25.7,25.7,38.6,56.6,38.6,92.7v9.3c38.3-2.2,71.2,9.5,98.7,35c27.5,25.5,41.3,57.4,41.3,95.7v272.4c0,14.6-1.4,29.7-4.3,45.4L900.3,890c-5.1,28.8-19,52.7-41.9,71.6c-22.8,18.9-49,28.4-78.5,28.4H403.8c-21.9,0-42.8-5-62.6-15.1c-19.9-10-36.4-23.6-49.5-40.7l-210-280C63,629.4,53.8,601.4,53.8,570c0-38.6,13.7-71.6,41-99c27.3-27.3,60.3-41,99-41c28.4,0,51.8,6.2,70,18.6V211.3c0-36.1,12.9-67,38.6-92.7C328,92.9,358.9,80,395,80c8.4,0,16.1,0.7,23,2.2c11.3-22.3,27.4-39.9,48.4-52.8c21-12.9,43.8-19.4,68.6-19.4L535.1,10.1z'! !!RSSVGShapeExamples methodsFor: 'data - svg'!rock	^ 'M408.864 79.052c-22.401-33.898-66.108-42.273-98.813-23.588-29.474-31.469-79.145-31.093-108.334-.022-47.16-27.02-108.71 5.055-110.671 60.806C44.846 105.407 0 140.001 0 187.429v56.953c0 32.741 14.28 63.954 39.18 85.634l97.71 85.081c4.252 3.702 3.11 5.573 3.11 32.903 0 17.673 14.327 32 32 32h252c17.673 0 32-14.327 32-32 0-23.513-1.015-30.745 3.982-42.37l42.835-99.656c6.094-14.177 9.183-29.172 9.183-44.568V146.963c0-52.839-54.314-88.662-103.136-67.911zM464 261.406a64.505 64.505 0 0 1-5.282 25.613l-42.835 99.655c-5.23 12.171-7.883 25.04-7.883 38.25V432H188v-10.286c0-16.37-7.14-31.977-19.59-42.817l-97.71-85.08C56.274 281.255 48 263.236 48 244.381v-56.953c0-33.208 52-33.537 52 .677v41.228a16 16 0 0 0 5.493 12.067l7 6.095A16 16 0 0 0 139 235.429V118.857c0-33.097 52-33.725 52 .677v26.751c0 8.836 7.164 16 16 16h7c8.836 0 16-7.164 16-16v-41.143c0-33.134 52-33.675 52 .677v40.466c0 8.836 7.163 16 16 16h7c8.837 0 16-7.164 16-16v-27.429c0-33.03 52-33.78 52 .677v26.751c0 8.836 7.163 16 16 16h7c8.837 0 16-7.164 16-16 0-33.146 52-33.613 52 .677v114.445z'! !!RSSVGShapeExamples methodsFor: 'data - svg'!scissors	^ 'M596.9,920h-96.8c-59.4,0-100.6-25.7-123.6-77.1c-8.4-17.9-12.6-36.5-12.6-55.8v-2.7c-22.6-10.9-40.6-27-53.9-48.4c-13.3-21.3-20-44.6-19.9-69.7c0-13.9,0.9-22.6,2.7-26.3H150c-38.6,0-71.6-13.7-99-41c-27.3-27.3-41-60.3-41-99c0-38.6,13.7-71.6,41-99s60.3-41,99-41h61.8l-24.1-9.3c-27-10.2-48.8-27.3-65.4-51.1c-16.6-23.8-24.9-50.4-24.9-79.6c0-38.6,13.7-71.6,41-99s60.3-41,99-41c16.8,0,33.3,3.1,49.8,9.3L630.7,220H850c38.6,0,71.6,13.7,99,41c27.3,27.3,41,60.3,41,99v365.3c0,32.1-9.8,60.8-29.5,86.1c-19.7,25.3-45.2,41.8-76.6,49.5l-185.4,46.5C665,915.8,631.1,920,596.9,920L596.9,920z M570.1,531.2L485.3,570l-89.1,40.5c-10.9,5.1-19.7,12.6-26.3,22.7c-6.6,10-9.9,21.1-9.9,33.1c0,16.8,6,31.1,18.1,43.2c12,12,26.4,18.1,43.2,18.1c9.5,0,17.8-1.8,25.1-5.5l184.9-84.2c-17.9-3.6-32.5-12.8-44-27.4c-11.5-14.6-17.2-31-17.2-49.2V531.2L570.1,531.2z M745.1,701.3c0-16.8-6-31.1-18.1-43.2c-12-12-26.4-18.1-43.2-18.1c-9.5,0-17.9,1.8-25.1,5.5l-158.6,72.2c-10.2,4.8-17,7.9-20.2,9.3c-3.3,1.4-8.8,4.6-16.7,9.3c-7.8,4.8-13.2,9.1-16.1,12.9c-2.9,3.8-5.8,9.1-8.7,15.9c-2.9,6.8-4.4,14.1-4.3,22.1c0,18.2,5.7,33.2,17.2,44.9c11.5,11.7,26.3,17.5,44.6,17.5c7.3,0,14.2-1.6,20.8-4.9l192.5-87.5c10.9-5.1,19.7-12.6,26.3-22.7c6.6-10,9.9-21.1,9.9-33.1L745.1,701.3z M618.2,290L262.8,154.4c-8.7-2.9-17.1-4.3-25.1-4.3c-19.3,0-35.8,6.8-49.5,20.5s-20.5,30.2-20.5,49.5c0,14.6,4.1,27.9,12.3,39.9s19.1,20.6,32.5,25.7l287.6,109.4v35h-350c-19.3,0-35.8,6.8-49.5,20.5c-13.7,13.7-20.5,30.2-20.5,49.5s6.8,35.8,20.5,49.5c13.7,13.7,30.2,20.5,49.5,20.5h292.6l127.4-58V403.8c0-23,8.4-42.3,25.1-58l60.7-55.8L618.2,290L618.2,290z M596.9,850c29.9,0,58.2-3.5,84.8-10.4L867,793.2c15.7-4,28.4-12.3,38.3-24.9c9.8-12.6,14.8-26.9,14.8-42.9V360.1c0-19.3-6.8-35.8-20.5-49.5c-13.7-13.7-30.2-20.5-49.5-20.5H681.7L607.3,359c-13.1,12-19.7,27-19.7,44.9v161.9c0,16.8,6,30.8,18.1,42.1c12,11.3,26.4,17,43.2,16.9c16.8,0,31.1-6.4,43.2-19.1c12-12.7,18.1-27.5,18.1-44.3V447.6h17.5v113.8c0,25.5-10.4,46.3-31.1,62.4c18.9,2.9,34.7,11.7,47.3,26.5c12.6,14.8,18.9,31.8,18.9,51.1c0,15.3-4.2,29.5-12.6,42.6c-8.4,13.1-19.5,22.8-33.4,29l-169.5,77.1H597L596.9,850z'! !!RSSVGShapeExamples methodsFor: 'data - svg'!spock	^ 'M426.6,107.9c-16.3,0-29.9,5.8-40.6,17.4c-10.7,11.6-16.1,25.5-16.1,41.9c0,4.7,0.5,9.5,1.5,14.3L448,500h-13.3l-59.2-246.1c-3-12.9-9.8-23.5-20.2-31.6c-10.4-8.1-22.2-12.2-35.5-12.2c-16,0-29.4,5.8-40.3,17.4c-10.9,11.6-16.3,25.4-16.3,41.4c0,3.7,0.7,8.7,2,14.8c1,4.4,7.6,31.8,19.9,82.2c12.3,50.4,23.9,98.3,34.7,143.9c10.8,45.6,16.3,69.1,16.3,70.4v115.9L179.5,578.7c-11.6-8.8-24.7-13.3-39.3-13.3c-17.7,0-32.9,6.2-45.7,18.6c-12.8,12.4-19.1,27.5-19.1,45.2c0,22.8,9.5,41.5,28.6,56.1l258.8,193.5c11.6,8.8,24.5,13.3,38.8,13.3h354.3c11.2,0,21.3-3.5,30.1-10.5c8.8-7,14.6-15.9,17.4-26.8l51-204.7c2.7-10.2,4.4-25.2,5.1-45c0.7-19.8,2.2-34.4,4.6-43.9l59.2-244c1-4.1,1.5-8.5,1.5-13.3c0-15.6-5.6-29.1-16.9-40.3c-11.2-11.2-24.9-16.9-40.8-16.9c-12.9,0-24.7,4.3-35.2,13c-10.5,8.7-17.3,19.3-20.4,31.9L761,500h-13.3l67.4-279.2c1-4.7,1.5-9.5,1.5-14.3c0-16-5.4-29.6-16.3-40.8c-10.9-11.2-24.5-16.9-40.8-16.9c-12.9,0-24.6,4.1-35,12.2c-10.4,8.1-17.1,18.7-20.2,31.6l-74,307.3h-64.8l-83.7-348.1c-3-12.9-9.8-23.5-20.2-31.6C451.1,112,439.4,107.9,426.6,107.9L426.6,107.9z M755.8,957.3H401.5c-28.9,0-55-8.7-78.1-26l-258.8-194c-17-12.9-30.4-28.9-40.1-48c-9.7-19-14.5-39.1-14.6-60.2c0-35.7,12.8-66.2,38.3-91.3c25.5-25.2,56.2-37.8,91.9-37.8c8.5,0,16.9,0.9,25.3,2.8c8.4,1.9,15.4,3.7,21.2,5.6s12.7,5.4,20.9,10.5c8.2,5.1,14.1,9,17.8,11.8c3.7,2.7,10.3,7.8,19.7,15c9.4,7.3,15.8,12.1,19.1,14.6l-62.8-261.4c-2.4-11.9-3.6-21.9-3.6-30.1c0-31.7,10.2-59.2,30.6-82.7c20.4-23.5,46.3-36.9,77.6-40.3c4.7-29.6,18.4-54.2,41.1-73.8c22.7-19.6,49.1-29.3,79.4-29.3c28.2,0,53.4,8.8,75.5,26.3c22.1,17.5,36.6,40.1,43.4,67.6L598,355l42.3-177.7c6.8-27.6,21.3-50.1,43.4-67.6c22.1-17.5,47.3-26.3,75.5-26.3c29.6,0,55.6,9.2,77.8,27.6c22.3,18.4,36.3,42,42.1,71c31.7,3.4,58,16.7,79.1,39.8S990,272.3,990,304c0,10.2-1.2,19.9-3.6,29.1l-59.2,243.5c-1.7,7.5-2.5,18.9-2.5,34.2c0,17.3-2.2,35.7-6.7,55.2l-51.6,204.7c-6.4,25.5-20,46.4-40.6,62.5c-20.6,16.2-44,24.2-70.2,24.2L755.8,957.3z'! !!RSShapeExamples methodsFor: '*Roassal3-SVG-Examples'!example03LinePath	<script: 'self new example03LinePath open'>	| canvas shapes form paint line path |	canvas := RSCanvas new.	form := self iconNamed: #remote.	paint := (AthensCairoPatternSurfacePaint		createForSurface: (AthensCairoSurface			fromForm: form)).	paint origin: (form extent / 2) negated.	shapes := #(-1 1 ) collect: [ :m |		RSBox new			size: form extent x;			paint: paint;			position: m * 50 asPoint;			draggable;			yourself		].	path := [ :aLine | String streamContents: [ :s|		| point number vector u unit middle middle2 l r a b |		a := aLine startPoint.		b := aLine endPoint.		number := [ :n |			s nextPutAll: n asFloat asString ].		point := [ :p |			number value: p x.			s space.			number value: p y.			s space. ].		vector := a - b.		u := vector normal.		unit := vector / (vector r max: 1).		1 to: 3 do: [ :i |			middle := a - (unit * (i+1)* 5).			middle2 := a - (unit * (i*2)*5).			l := middle - (u * ((i-1) * 7)).			r := middle + (u * ((i-0.9) * 7)).			s nextPutAll: 'M'.			point value: l.			s nextPutAll: 'Q '.			point value: middle2.			point value: r.			].		 ] ].	line := [:m | RSSVGPathLine new		borderColor: (m alpha: 0.4);		svgPath: path;		width: 4;		capRound;		yourself].	canvas add: ((line value: Color red)		from: shapes first;		to: shapes second).	canvas add: ((line value: Color blue)		from: shapes second;		to: shapes first).	canvas addAll: shapes.	canvas camera scale: 1.	^ canvas! !!RSShapeExamples methodsFor: '*Roassal3-SVG-Examples'!example06JoinStyles	<script: 'self new example06JoinStyles open'>	| canvas line path styles |	canvas := RSCanvas new.	path := [ :aLine | String streamContents: [ :s|		| mid number point a b |		a := aLine startPoint.		b := aLine endPoint.		number := [ :n |			s nextPutAll: n asFloat asString ].		point := [ :p |			number value: p x.			s space.			number value: p y.			s space. ].		mid := (a + b)/2 + (0@ -50).		s nextPutAll: 'M'.		point value: a.		s nextPutAll: 'L'.		point value: mid.		s nextPutAll: 'L'.		point value: b.		 ] ].	styles := #('joinMiter' 'joinRound' 'joinBevel').	styles doWithIndex: [ :style :i|		line := RSSVGPathLine new			svgPath: path;			borderColor: Color gray;			draggable;			width: 25;			from: ((i-2) * 80)@0;			to: (((i-2) * 80) + 50)@0;			perform: style asSymbol;			yourself.		canvas add: line.		.	].	^ canvas! !!RSShapeExamples methodsFor: '*Roassal3-SVG-Examples'!example15BimetricLine	<script: 'self new example15BimetricLine open'>	| canvas s1 s2 l |	canvas := RSCanvas new.	s1 := RSBox new		color: Color blue;		draggable;		size: 100;		yourself.	s2 := RSBox new		translateTo: 400@0;		draggable;		size: 100;		yourself.	l := RSBimetricLine new		widthFrom: 50;		widthTo: 10;		paint: Color red;		border: nil;		withBorderAttachPoint;		from: s1;		to: s2;		yourself.	canvas addAll: { s1. s2. l}.	canvas @ RSCanvasController.	^ canvas! !!RSShapeExamples methodsFor: '*Roassal3-SVG-Examples'!example18ExampleFromMondrian	<script: 'self new example18ExampleFromMondrian open'>	| canvas legend |	canvas := RSCanvas new.	canvas addAll: (Collection withAllSubclasses collect: [:cls |		RSEllipse new			draggable;			model: cls;			popup;			color: Color red translucent;			yourself]).	RSNormalizer size		from: 5;		to: 50;		shapes: canvas nodes;		normalize: #numberOfMethods.	RSLineBuilder line		color: Color lightGray;		shapes: canvas nodes;		canvas: canvas;		connectFrom: #superclass.	RSForceBasedLayout on: canvas nodes.	RSMultiBezierEdgeBuilder multiBezier		borderColor: (Color blue alpha: 0.1);		shapes: canvas nodes;		canvas: canvas;		tension: 0.7;		following: #superclass;		connectToAll: #dependentClasses.	legend := (RSMultilineLabelBuilder new		shapeFor: 'Circle = classes, size = number of methods; gray links = inheritance;blue links = dependencies; layout = force based layout on the inheritance links')		padding: 10;		withBorder;		yourself.	RSLocation new		below;		offset: 10;		move: legend on: canvas nodes.	canvas add: legend.	canvas @ RSCanvasController.	^ canvas! !!RSShapeExamples methodsFor: '*Roassal3-SVG-Examples'!example25BimetricLineOnLargeExample	<script: 'self new example25BimetricLineOnLargeExample open'>	| packagesRegExp packages l packageElements high canvas |	packagesRegExp := { 'Calypso*' }.	packages := packagesRegExp flatCollect: [ :regExp |		RPackageOrganizer default packages			select: [ :p | regExp match: p packageName ] ].	l := RSLabeled new text: [ :model | model packageName ].	packageElements  := packages collect: [ :pkg | | shapes |		shapes := pkg definedClasses collect: [ :cls |			RSBox new				color: Color black;				size: cls numberOfMethods sqrt;				yourself			 ].		RSGridLayout on: shapes.		RSComposite new			color: Color blue translucent;			model: pkg;			addInteraction: l;			draggable;			shapes: shapes;			padding: 5;			yourself ] as: RSGroup.	high := RSHighlightable new.	high withLines.	high highlightColor: Color red translucent.	packageElements @ high.	canvas := RSCanvas new.	canvas addAll: packageElements.	RSLineBuilder bimetricLine		canvas: canvas;		objects: packages;		noBorder;		widthFrom:[ :edge | (edge key numberOfDependenciesToward: edge value) sqrt * 4 ];		widthTo:[ :edge | (edge value numberOfDependenciesToward: edge key) sqrt * 4 ];		paint: Color blue translucent;		withBorderAttachPoint;		connectFrom: #yourself toAll: #dependentPackages.	RSWeightedCircleLayout new initialRadius: 300; on: packageElements.	canvas @ RSCanvasController.	^ canvas! !!RSShapeExamples methodsFor: '*Roassal3-SVG-Examples'!example25BisBimetricLineOnLargeExample	<script: 'self new example25BisBimetricLineOnLargeExample open'>	"Same than example25BimetricLineOnLargeExample, but with no label"	| packagesRegExp packages packageElements high canvas |	packagesRegExp := { 'Calypso*' }.	packages := packagesRegExp flatCollect: [ :regExp |		RPackageOrganizer default packages			select: [ :p | regExp match: p packageName ] ].	packageElements  := packages collect: [ :pkg | | shapes |		shapes := pkg definedClasses collect: [ :cls |			RSBox new				color: Color black;				size: cls numberOfMethods sqrt;				yourself			 ].		RSGridLayout on: shapes.		RSComposite new			color: Color blue translucent;			model: pkg;			draggable;			shapes: shapes;			padding: 5;			yourself ] as: RSGroup.	high := RSHighlightable new.	high withLines.	high highlightColor: Color red translucent.	packageElements @ high.	canvas := RSCanvas new.	canvas addAll: packageElements.	RSLineBuilder bimetricLine		canvas: canvas;		objects: packages;		noBorder;		widthFrom:[ :edge | (edge key numberOfDependenciesToward: edge value) sqrt * 4 ];		widthTo:[ :edge | (edge value numberOfDependenciesToward: edge key) sqrt * 4 ];		paint: Color blue translucent;		withBorderAttachPoint;		connectFrom: #yourself toAll: #dependentPackages.	RSWeightedCircleLayout new initialRadius: 300; on: packageElements.	canvas @ RSCanvasController.	^ canvas! !!RSAnimationExamples methodsFor: '*Roassal3-SVG-Examples'!example04Phyco	<script: 'self new example04Phyco open'>	| update canvas theta slices unit color sc1 sc2 |	canvas := RSCanvas new.	slices := 50.	unit := Float pi * 2 / slices.	"domain: aBoolean, range: aColor"	color := NSScale ordinal rangeFrom: { '480D4A'. 'BB1C60' }.	"input: a number between {-1 1} ouput: a number between 100 and 350"	sc1 := NSScale linear		       domain: #( -1 1 );		       range: { 100. 350 }.	sc2 := NSScale linear		       domain: #( -1 1 );		       range: { 350. 100 }.	"for zoom to fit"	canvas add: (RSBox new			 extent: 800 @ 800;			 noPaint;			 yourself).	theta := 0.	update := [	          canvas lines copy do: #remove.	          1 to: slices do: [ :i |		          | line sz |		          line := RSSVGPathLine new			                  model: i;			                  yourself.		          sz := i even			                ifTrue: [ sc1 scale: (i * unit + theta) sin ]			                ifFalse: [			                sc2 scale: (line model * unit - theta) sin ].		          line			          width: sz / 2;			          borderColor: (color scale: i even);			          from: (i even					           ifTrue: [ -25 @ -25 ]					           ifFalse: [ 25 @ 25 ]);			          to: 0 @ 0.		          line svgPath: [ :theLine | "this block returns a block to use complex operations of Athens Canvas""in this part you can also return a string, the svg path"			          [ :pathBuilder |			          | angle a |			          a := theLine startPoint.			          angle := i * unit.			          pathBuilder				          moveTo: a + (sz * (angle cos @ angle sin));				          arcCenterX: a x				          centerY: a y				          radius: sz				          startAngle: line model * unit				          endAngle: line model + 1 * unit ] ].		          canvas add: line ] ].	canvas		when: RSMouseClick		do: [ :evt | canvas edges inspect ]		for: self.	canvas newAnimation repeat onStepDo: [ :t |		update value.		theta := theta + 0.0523 ].	canvas		when: RSExtentChangedEvent		do: [ :evt | canvas zoomToFit ]		for: self.	^ canvas! !!RSSVGAnimationExamples methodsFor: 'data - svg'!america	^ 'M16,1.466C7.973,1.466,1.466,7.973,1.466,16c0,8.027,6.507,14.534,14.534,14.534c8.027,0,14.534-6.507,14.534-14.534C30.534,7.973,24.027,1.466,16,1.466zM19.158,23.269c-0.079,0.064-0.183,0.13-0.105,0.207c0.078,0.078-0.09,0.131-0.09,0.17s0.104,0.246,0.052,0.336c-0.052,0.092-0.091,0.223-0.13,0.301c-0.039,0.077-0.131,0.155-0.104,0.272c0.025,0.116-0.104,0.077-0.104,0.194c0,0.116,0.116,0.065,0.09,0.208c-0.025,0.144-0.09,0.183-0.09,0.285c0,0.104,0.064,0.247,0.064,0.286s-0.064,0.17-0.155,0.272c-0.092,0.104-0.155,0.17-0.144,0.233c0.014,0.065,0.104,0.144,0.091,0.184c-0.013,0.037-0.129,0.168-0.116,0.259c0.014,0.09,0.129,0.053,0.155,0.116c0.026,0.065-0.155,0.118-0.078,0.183c0.078,0.064,0.183,0.051,0.156,0.208c-0.019,0.112,0.064,0.163,0.126,0.198c-0.891,0.221-1.818,0.352-2.777,0.352C9.639,27.533,4.466,22.36,4.466,16c0-2.073,0.557-4.015,1.518-5.697c0.079-0.042,0.137-0.069,0.171-0.062c0.065,0.013,0.079,0.104,0.183,0.13c0.104,0.026,0.195-0.078,0.26-0.117c0.064-0.039,0.116-0.195,0.051-0.182c-0.065,0.013-0.234,0-0.234,0s0.183-0.104,0.183-0.169s0.025-0.169,0.129-0.208C6.83,9.655,6.83,9.681,6.765,9.837C6.7,9.993,6.896,9.928,6.973,9.863s0.13-0.013,0.272-0.104c0.143-0.091,0.143-0.143,0.221-0.143c0.078,0,0.221,0.143,0.299,0.091c0.077-0.052,0.299,0.065,0.429,0.065c0.129,0,0.545,0.169,0.624,0.169c0.078,0,0.312,0.09,0.325,0.259c0.013,0.169,0.09,0.156,0.168,0.156s0.26,0.065,0.26,0.13c0,0.065-0.052,0.325,0.078,0.39c0.129,0.064,0.247,0.169,0.299,0.143c0.052-0.026,0-0.233-0.064-0.26c-0.065-0.026-0.027-0.117-0.052-0.169c-0.026-0.051,0.078-0.051,0.117,0.039c0.039,0.091,0.143,0.26,0.208,0.26c0.064,0,0.208,0.156,0.168,0.247c-0.039,0.091,0.039,0.221,0.156,0.221c0.116,0,0.26,0.182,0.312,0.195c0.052,0.013,0.117,0.078,0.117,0.117c0,0.04,0.065,0.26,0.065,0.351c0,0.09-0.04,0.454-0.053,0.597s0.104,0.39,0.234,0.52c0.129,0.13,0.246,0.377,0.324,0.429c0.079,0.052,0.13,0.195,0.247,0.182c0.117-0.013,0.195,0.078,0.299,0.26c0.104,0.182,0.208,0.48,0.286,0.506c0.078,0.026,0.208,0.117,0.142,0.182c-0.064,0.064-0.168,0.208-0.051,0.208c0.117,0,0.156-0.065,0.247,0.053c0.09,0.116,0.208,0.181,0.194,0.26c-0.013,0.077,0.104,0.103,0.156,0.116c0.052,0.013,0.169,0.247,0.286,0.143c0.117-0.104-0.155-0.259-0.234-0.326c-0.078-0.064,0-0.207-0.182-0.35c-0.182-0.143-0.156-0.247-0.286-0.351c-0.13-0.104-0.233-0.195-0.104-0.286c0.13-0.091,0.143,0.091,0.195,0.208c0.052,0.116,0.324,0.351,0.441,0.454c0.117,0.104,0.326,0.468,0.39,0.468s0.247,0.208,0.247,0.208s0.103,0.168,0.064,0.22c-0.039,0.052,0.053,0.247,0.144,0.299c0.09,0.052,0.455,0.22,0.507,0.247c0.052,0.027,0.155,0.221,0.299,0.221c0.142,0,0.247,0.014,0.286,0.053c0.039,0.038,0.155,0.194,0.234,0.104c0.078-0.092,0.09-0.131,0.208-0.131c0.117,0,0.168,0.091,0.233,0.156c0.065,0.065,0.247,0.235,0.338,0.222c0.091-0.013,0.208,0.104,0.273,0.064s0.169,0.025,0.22,0.052c0.054,0.026,0.234,0.118,0.222,0.272c-0.013,0.157,0.103,0.195,0.182,0.234c0.078,0.039,0.182,0.13,0.248,0.195c0.064,0.063,0.206,0.077,0.246,0.116c0.039,0.039,0.065,0.117,0.182,0.052c0.116-0.064,0.092-0.181,0.092-0.181s0.129-0.026,0.194,0.026c0.064,0.05,0.104,0.22,0.144,0.246c0.038,0.026,0.115,0.221,0.063,0.362c-0.051,0.145-0.038,0.286-0.091,0.286c-0.052,0-0.116,0.17-0.195,0.209c-0.076,0.039-0.285,0.221-0.272,0.286c0.013,0.063,0.131,0.258,0.104,0.35c-0.025,0.091-0.194,0.195-0.154,0.338c0.038,0.144,0.312,0.183,0.323,0.312c0.014,0.131,0.209,0.417,0.235,0.546c0.025,0.13,0.246,0.272,0.246,0.453c0,0.184,0.312,0.3,0.377,0.312c0.063,0.013,0.182,0.131,0.272,0.17s0.169,0.116,0.233,0.221s0.053,0.261,0.053,0.299c0,0.039-0.039,0.44-0.078,0.674C19.145,23.021,19.235,23.203,19.158,23.269zM10.766,11.188c0.039,0.013,0.117,0.091,0.156,0.091c0.04,0,0.234,0.156,0.286,0.208c0.053,0.052,0.053,0.195-0.013,0.208s-0.104-0.143-0.117-0.208c-0.013-0.065-0.143-0.065-0.208-0.104C10.805,11.344,10.66,11.152,10.766,11.188zM27.51,16.41c-0.144,0.182-0.13,0.272-0.195,0.286c-0.064,0.013,0.065,0.065,0.09,0.194c0.022,0.112-0.065,0.224,0.063,0.327c-0.486,4.619-3.71,8.434-8.016,9.787c-0.007-0.011-0.019-0.025-0.021-0.034c-0.027-0.078-0.027-0.233,0.064-0.285c0.091-0.053,0.312-0.233,0.363-0.272c0.052-0.04,0.13-0.221,0.091-0.247c-0.038-0.026-0.232,0-0.26-0.039c-0.026-0.039-0.026-0.092,0.104-0.182c0.13-0.091,0.195-0.222,0.247-0.26c0.052-0.039,0.155-0.117,0.195-0.209c0.038-0.09-0.041-0.039-0.118-0.039s-0.117-0.142-0.117-0.207s0.195,0.026,0.339,0.052c0.143,0.024,0.077-0.065,0.064-0.142c-0.013-0.078,0.026-0.209,0.105-0.17c0.076,0.039,0.479-0.013,0.531-0.026c0.052-0.013,0.194-0.246,0.246-0.312c0.053-0.065,0.064-0.129,0-0.168c-0.065-0.04-0.143-0.184-0.168-0.221c-0.026-0.041-0.039-0.274-0.013-0.34c0.025-0.063,0,0.377,0.181,0.43c0.183,0.052,0.286,0.078,0.455-0.078c0.169-0.155,0.298-0.26,0.312-0.363c0.013-0.104,0.052-0.209,0.117-0.246c0.065-0.039,0.104,0.103,0.182-0.065c0.078-0.17,0.156-0.157,0.234-0.299c0.077-0.144-0.13-0.325,0.024-0.43c0.157-0.103,0.43-0.233,0.43-0.233s0.078-0.039,0.234-0.078c0.155-0.038,0.324-0.014,0.376-0.09c0.052-0.079,0.104-0.247,0.182-0.338c0.079-0.092,0.169-0.234,0.13-0.299c-0.039-0.065,0.104-0.352,0.091-0.429c-0.013-0.078-0.13-0.261,0.065-0.416s0.402-0.391,0.416-0.454c0.012-0.065,0.169-0.338,0.154-0.469c-0.012-0.129-0.154-0.285-0.245-0.325c-0.092-0.037-0.286-0.05-0.364-0.154s-0.299-0.208-0.377-0.182c-0.077,0.026-0.208,0.051-0.312-0.015c-0.104-0.063-0.272-0.143-0.337-0.194c-0.066-0.051-0.234-0.09-0.312-0.09s-0.065-0.053-0.182,0.103c-0.117,0.157,0,0.209-0.208,0.182c-0.209-0.024,0.025-0.038,0.144-0.194c0.115-0.155-0.014-0.247-0.144-0.207c-0.13,0.039-0.039,0.117-0.247,0.156c-0.207,0.038-0.207-0.092-0.077-0.117c0.13-0.026,0.363-0.143,0.363-0.194c0-0.053-0.026-0.196-0.13-0.196s-0.078-0.129-0.233-0.297c-0.156-0.17-0.351-0.274-0.508-0.249c-0.154,0.026-0.272,0.065-0.35-0.076c-0.078-0.144-0.169-0.17-0.222-0.247c-0.051-0.078-0.182,0-0.221-0.039s-0.039-0.039-0.039-0.039s-0.169,0.039-0.077-0.078c0.09-0.117,0.129-0.338,0.09-0.325c-0.038,0.013-0.104,0.196-0.168,0.183c-0.064-0.013-0.014-0.04-0.144-0.117c-0.13-0.078-0.337-0.013-0.337,0.052c0,0.065-0.065,0.117-0.065,0.117s-0.039-0.038-0.078-0.117c-0.039-0.078-0.221-0.091-0.312-0.013c-0.09,0.078-0.142-0.196-0.207-0.196s-0.194,0.065-0.26,0.184c-0.064,0.116-0.038,0.285-0.092,0.272c-0.05-0.013-0.063-0.233-0.05-0.312c0.012-0.079,0.155-0.208,0.05-0.234c-0.103-0.026-0.259,0.13-0.323,0.143c-0.065,0.013-0.195,0.104-0.273,0.209c-0.077,0.103-0.116,0.168-0.195,0.207c-0.077,0.039-0.193,0-0.167-0.039c0.025-0.039-0.222-0.181-0.261-0.13c-0.04,0.052-0.155,0.091-0.272,0.144c-0.117,0.052-0.222-0.065-0.247-0.117s-0.079-0.064-0.091-0.234c-0.013-0.168,0.027-0.351,0.065-0.454c0.038-0.104-0.195-0.312-0.286-0.3c-0.091,0.015-0.182,0.105-0.272,0.091c-0.092-0.012-0.052-0.038-0.195-0.038c-0.143,0-0.026-0.025,0-0.143c0.025-0.116-0.052-0.273,0.092-0.377c0.142-0.104,0.091-0.351,0-0.363c-0.092-0.014-0.261,0.039-0.377,0.026c-0.116-0.014-0.208,0.091-0.169,0.207c0.039,0.117-0.065,0.195-0.104,0.183c-0.039-0.013-0.09-0.078-0.234,0.026c-0.142,0.103-0.194,0.064-0.337-0.052c-0.143-0.118-0.299-0.234-0.325-0.416c-0.026-0.182-0.04-0.364,0.013-0.468c0.051-0.104,0.051-0.285-0.026-0.312c-0.078-0.025,0.09-0.155,0.181-0.181c0.092-0.026,0.234-0.143,0.26-0.195c0.026-0.052,0.156-0.04,0.298-0.04c0.143,0,0.169,0,0.312,0.078c0.143,0.078,0.169-0.039,0.169-0.078c0-0.039,0.052-0.117,0.208-0.104c0.156,0.013,0.376-0.052,0.416-0.013s0.116,0.195,0.194,0.143c0.079-0.051,0.104-0.143,0.131,0.014c0.025,0.155,0.09,0.39,0.208,0.429c0.116,0.039,0.052,0.194,0.168,0.207c0.115,0.013,0.17-0.246,0.131-0.337c-0.04-0.09-0.118-0.363-0.183-0.428c-0.064-0.065-0.064-0.234,0.064-0.286c0.13-0.052,0.442-0.312,0.532-0.389c0.092-0.079,0.338-0.144,0.261-0.248c-0.078-0.104-0.104-0.168-0.104-0.247s0.078-0.052,0.117,0s0.194-0.078,0.155-0.143c-0.038-0.064-0.026-0.155,0.065-0.143c0.091,0.013,0.116-0.065,0.078-0.117c-0.039-0.052,0.091-0.117,0.182-0.091c0.092,0.026,0.325-0.013,0.364-0.065c0.038-0.052-0.078-0.104-0.078-0.208c0-0.104,0.155-0.195,0.247-0.208c0.091-0.013,0.207,0,0.221-0.039c0.012-0.039,0.143-0.143,0.155-0.052c0.014,0.091,0,0.247,0.104,0.247c0.104,0,0.232-0.117,0.272-0.129c0.038-0.013,0.286-0.065,0.338-0.078c0.052-0.013,0.363-0.039,0.325-0.13c-0.039-0.09-0.078-0.181-0.118-0.22c-0.039-0.039-0.077,0.013-0.13,0.078c-0.051,0.065-0.143,0.065-0.168,0.013c-0.026-0.051,0.012-0.207-0.078-0.156c-0.092,0.052-0.104,0.104-0.157,0.078c-0.052-0.026-0.103-0.117-0.103-0.117s0.129-0.064,0.038-0.182c-0.09-0.117-0.221-0.091-0.35-0.025c-0.13,0.064-0.118,0.051-0.273,0.09s-0.234,0.078-0.234,0.078s0.209-0.129,0.299-0.208c0.091-0.078,0.209-0.117,0.286-0.195c0.078-0.078,0.285,0.039,0.285,0.039s0.105-0.104,0.105-0.039s-0.027,0.234,0.051,0.234c0.079,0,0.299-0.104,0.21-0.131c-0.093-0.026,0.129,0,0.219-0.065c0.092-0.065,0.194-0.065,0.247-0.09c0.052-0.026,0.092-0.143,0.182-0.143c0.092,0,0.13,0.117,0,0.195s-0.143,0.273-0.208,0.325c-0.064,0.052-0.026,0.117,0.078,0.104c0.104-0.013,0.194,0.013,0.286-0.013s0.143,0.026,0.168,0.065c0.026,0.039,0.104-0.039,0.104-0.039s0.169-0.039,0.221,0.026c0.053,0.064,0.092-0.039,0.053-0.104c-0.039-0.064-0.092-0.129-0.13-0.208c-0.039-0.078-0.091-0.104-0.194-0.078c-0.104,0.026-0.13-0.026-0.195-0.064c-0.065-0.04-0.118,0.052-0.065-0.04c0.053-0.09,0.078-0.117,0.117-0.195c0.039-0.078,0.209-0.221,0.039-0.259c-0.169-0.04-0.222-0.065-0.247-0.143c-0.026-0.078-0.221-0.221-0.272-0.221c-0.053,0-0.233,0-0.247-0.065c-0.013-0.065-0.143-0.208-0.208-0.273c-0.064-0.065-0.312-0.351-0.351-0.377c-0.039-0.026-0.091-0.013-0.208,0.143c-0.116,0.157-0.22,0.183-0.312,0.144c-0.091-0.039-0.104-0.026-0.193-0.13c-0.093-0.104,0.09-0.117,0.051-0.182c-0.04-0.064-0.247-0.091-0.377-0.104c-0.13-0.013-0.221-0.156-0.416-0.169c-0.194-0.013-0.428,0.026-0.493,0.026c-0.064,0-0.064,0.091-0.09,0.234c-0.027,0.143,0.09,0.182-0.027,0.208c-0.116,0.026-0.169,0.039-0.052,0.091c0.117,0.052,0.273,0.26,0.273,0.26s0,0.117-0.092,0.182c-0.09,0.065-0.182,0.13-0.233,0.053c-0.053-0.079-0.195-0.065-0.155,0.013c0.038,0.078,0.116,0.117,0.116,0.195c0,0.077,0.117,0.272,0.039,0.337c-0.078,0.065-0.168,0.014-0.233,0.026s-0.131-0.104-0.078-0.13c0.051-0.026-0.014-0.221-0.014-0.221s-0.155,0.221-0.143,0.104c0.014-0.117-0.064-0.13-0.064-0.221c0-0.091-0.079-0.13-0.194-0.104c-0.118,0.026-0.26-0.04-0.482-0.079c-0.22-0.039-0.311-0.064-0.493-0.156c-0.182-0.091-0.247-0.026-0.338-0.013c-0.091,0.013-0.052-0.182-0.169-0.207c-0.116-0.027-0.181,0.025-0.207-0.144c-0.026-0.168,0.039-0.208,0.324-0.39c0.286-0.182,0.247-0.26,0.468-0.286c0.22-0.026,0.325,0.026,0.325-0.039s0.052-0.325,0.052-0.195S16.95,9.109,16.832,9.2c-0.116,0.091-0.052,0.104,0.04,0.104c0.091,0,0.259-0.091,0.259-0.091s0.208-0.091,0.26-0.013c0.053,0.078,0.053,0.156,0.144,0.156s0.285-0.104,0.116-0.195c-0.168-0.091-0.272-0.078-0.376-0.182s-0.078-0.065-0.195-0.039c-0.116,0.026-0.116-0.039-0.156-0.039s-0.104,0.026-0.13-0.026c-0.025-0.052,0.014-0.065,0.145-0.065c0.129,0,0.285,0.039,0.285,0.039s0.155-0.052,0.194-0.065c0.039-0.013,0.247-0.039,0.208-0.155c-0.04-0.117-0.169-0.117-0.208-0.156s0.078-0.09,0.143-0.117c0.065-0.026,0.247,0,0.247,0s0.117,0.013,0.117-0.039S17.897,8.2,17.976,8.239s0,0.156,0.117,0.13c0.116-0.026,0.143,0,0.207,0.039c0.065,0.039-0.013,0.195-0.077,0.221c-0.065,0.025-0.169,0.077-0.026,0.09c0.144,0.014,0.246,0.014,0.246,0.014s0.092-0.091,0.131-0.169c0.038-0.078,0.104-0.026,0.155,0c0.052,0.025,0.247,0.065,0.065,0.117c-0.183,0.052-0.221,0.117-0.26,0.182c-0.038,0.065-0.053,0.104-0.221,0.065c-0.17-0.039-0.26-0.026-0.299,0.039c-0.039,0.064-0.013,0.273,0.053,0.247c0.063-0.026,0.129-0.026,0.207-0.052c0.078-0.026,0.39,0.026,0.467,0.013c0.078-0.013,0.209,0.13,0.248,0.104c0.039-0.026,0.117,0.052,0.194,0.104c0.078,0.052,0.052-0.117,0.194-0.013c0.144,0.104,0.065,0.104,0.144,0.104c0.076,0,0.246,0.013,0.246,0.013s0.014-0.129,0.144-0.104c0.13,0.026,0.245,0.169,0.232,0.064c-0.012-0.103,0.013-0.181-0.09-0.259c-0.104-0.078-0.272-0.13-0.299-0.169c-0.026-0.039-0.052-0.091-0.013-0.117c0.039-0.025,0.221,0.013,0.324,0.079c0.104,0.065,0.195,0.13,0.273,0.078c0.077-0.052,0.17-0.078,0.208-0.117c0.038-0.04,0.13-0.156,0.13-0.156s-0.391-0.051-0.441-0.117c-0.053-0.065-0.235-0.156-0.287-0.156s-0.194,0.091-0.246-0.039s-0.052-0.286-0.105-0.299c-0.05-0.013-0.597-0.091-0.674-0.13c-0.078-0.039-0.39-0.13-0.507-0.195s-0.286-0.156-0.389-0.156c-0.104,0-0.533,0.052-0.611,0.039c-0.078-0.013-0.312,0.026-0.403,0.039c-0.091,0.013,0.117,0.182-0.077,0.221c-0.195,0.039-0.169,0.065-0.13-0.13c0.038-0.195-0.131-0.247-0.299-0.169c-0.169,0.078-0.442,0.13-0.377,0.221c0.065,0.091-0.012,0.157,0.117,0.247c0.13,0.091,0.183,0.117,0.35,0.104c0.17-0.013,0.339,0.025,0.339,0.025s0,0.157-0.064,0.182c-0.065,0.026-0.169,0.026-0.196,0.104c-0.025,0.078-0.155,0.117-0.155,0.078s0.065-0.169-0.026-0.234c-0.09-0.065-0.117-0.078-0.221-0.013c-0.104,0.065-0.116,0.091-0.169-0.013C16.053,8.291,15.897,8.2,15.897,8.2s-0.104-0.129-0.182-0.194c-0.077-0.065-0.22-0.052-0.234,0.013c-0.013,0.064,0.026,0.129,0.078,0.247c0.052,0.117,0.104,0.337,0.013,0.351c-0.091,0.013-0.104,0.026-0.195,0.052c-0.091,0.026-0.13-0.039-0.13-0.143s-0.04-0.195-0.013-0.234c0.026-0.039-0.104,0.027-0.234,0c-0.13-0.025-0.233,0.052-0.104,0.092c0.13,0.039,0.157,0.194,0.039,0.233c-0.117,0.039-0.559,0-0.702,0s-0.35,0.039-0.39-0.039c-0.039-0.078,0.118-0.129,0.208-0.129c0.091,0,0.363,0.012,0.467-0.13c0.104-0.143-0.13-0.169-0.233-0.169c-0.104,0-0.183-0.039-0.299-0.155c-0.118-0.117,0.078-0.195,0.052-0.247c-0.026-0.052-0.156-0.014-0.272-0.014c-0.117,0-0.299-0.09-0.299,0.014c0,0.104,0.143,0.402,0.052,0.337c-0.091-0.064-0.078-0.156-0.143-0.234c-0.065-0.078-0.168-0.065-0.299-0.052c-0.129,0.013-0.35,0.052-0.415,0.039c-0.064-0.013-0.013-0.013-0.156-0.078c-0.142-0.065-0.208-0.052-0.312-0.117C12.091,7.576,12.182,7.551,12,7.538c-0.181-0.013-0.168,0.09-0.35,0.065c-0.182-0.026-0.234,0.013-0.416,0c-0.182-0.013-0.272-0.026-0.299,0.065c-0.025,0.091-0.078,0.247-0.156,0.247c-0.077,0-0.169,0.091,0.078,0.104c0.247,0.013,0.105,0.129,0.325,0.117c0.221-0.013,0.416-0.013,0.468-0.117c0.052-0.104,0.091-0.104,0.117-0.065c0.025,0.039,0.22,0.272,0.22,0.272s0.131,0.104,0.183,0.13c0.051,0.026-0.052,0.143-0.156,0.078c-0.104-0.065-0.299-0.051-0.377-0.116c-0.078-0.065-0.429-0.065-0.52-0.052c-0.09,0.013-0.247-0.039-0.299-0.039c-0.051,0-0.221,0.13-0.221,0.13S10.532,8.252,10.494,8.2c-0.039-0.052-0.104,0.052-0.156,0.065c-0.052,0.013-0.208-0.104-0.364-0.052C9.818,8.265,9.87,8.317,9.649,8.304s-0.272-0.052-0.35-0.039C9.22,8.278,9.22,8.278,9.22,8.278S9.233,8.33,9.143,8.382C9.052,8.434,8.986,8.499,8.921,8.421C8.857,8.343,8.818,8.343,8.779,8.33c-0.04-0.013-0.118-0.078-0.286-0.04C8.324,8.33,8.064,8.239,8.013,8.239c-0.04,0-0.313-0.015-0.491-0.033c2.109-2.292,5.124-3.74,8.478-3.74c2.128,0,4.117,0.589,5.83,1.598c-0.117,0.072-0.319,0.06-0.388,0.023c-0.078-0.043-0.158-0.078-0.475-0.061c-0.317,0.018-0.665,0.122-0.595,0.226c0.072,0.104-0.142,0.165-0.197,0.113c-0.055-0.052-0.309,0.06-0.293,0.165c0.016,0.104-0.039,0.225-0.175,0.199c-0.134-0.027-0.229,0.06-0.237,0.146c-0.007,0.087-0.309,0.147-0.332,0.147c-0.024,0-0.412-0.008-0.27,0.095c0.097,0.069,0.15,0.027,0.27,0.052c0.119,0.026,0.214,0.217,0.277,0.243c0.062,0.026,0.15,0,0.189-0.052c0.04-0.052,0.095-0.234,0.095-0.234s0,0.173,0.097,0.208c0.095,0.035,0.331-0.026,0.395-0.017c0.064,0.008,0.437,0.061,0.538,0.112c0.104,0.052,0.356,0.087,0.428,0.199c0.071,0.113,0.08,0.503,0.119,0.546c0.04,0.043,0.174-0.139,0.205-0.182c0.031-0.044,0.198-0.018,0.254,0.042c0.056,0.061,0.182,0.208,0.175,0.269C21.9,8.365,21.877,8.459,21.83,8.425c-0.048-0.034-0.127-0.025-0.096-0.095c0.032-0.069,0.048-0.217-0.015-0.217c-0.064,0-0.119,0-0.119,0s-0.12-0.035-0.199,0.095s-0.015,0.26,0.04,0.26s0.184,0,0.184,0.034c0,0.035-0.136,0.139-0.128,0.2c0.009,0.061,0.11,0.268,0.144,0.312c0.031,0.043,0.197,0.086,0.244,0.096c0.049,0.008-0.111,0.017-0.07,0.077c0.04,0.061,0.102,0.208,0.189,0.243c0.087,0.035,0.333,0.19,0.363,0.26c0.032,0.069,0.222-0.052,0.262-0.061c0.04-0.008,0.032,0.182,0.143,0.191c0.11,0.008,0.15-0.018,0.245-0.096s0.072-0.182,0.079-0.26c0.009-0.078,0-0.138,0.104-0.113c0.104,0.026,0.158-0.018,0.15-0.104c-0.008-0.087-0.095-0.191,0.07-0.217c0.167-0.026,0.254-0.138,0.357-0.138c0.103,0,0.389,0.043,0.419,0c0.032-0.043,0.167-0.243,0.254-0.251c0.067-0.007,0.224-0.021,0.385-0.042c1.582,1.885,2.561,4.284,2.673,6.905c-0.118,0.159-0.012,0.305,0.021,0.408c0.001,0.03,0.005,0.058,0.005,0.088c0,0.136-0.016,0.269-0.021,0.404C27.512,16.406,27.512,16.408,27.51,16.41zM17.794,12.084c-0.064,0.013-0.169-0.052-0.169-0.143s-0.091,0.169-0.04,0.247c0.053,0.078-0.104,0.169-0.155,0.169s-0.091-0.116-0.078-0.233c0.014-0.117-0.077-0.221-0.221-0.208c-0.143,0.014-0.208,0.13-0.259,0.169c-0.053,0.039-0.053,0.259-0.04,0.312s0.013,0.235-0.116,0.221c-0.118-0.013-0.092-0.233-0.079-0.312c0.014-0.078-0.039-0.273,0.014-0.376c0.053-0.104,0.207-0.143,0.312-0.156s0.324,0.065,0.363,0.052c0.04-0.014,0.222-0.014,0.312,0C17.729,11.837,17.858,12.071,17.794,12.084zM18.027,12.123c0.04,0.026,0.311-0.039,0.364,0.026c0.051,0.065-0.054,0.078-0.183,0.13c-0.129,0.052-0.169,0.039-0.221,0.104s-0.221,0.09-0.299,0.168c-0.078,0.079-0.217,0.125-0.246,0.065c-0.04-0.078,0.013-0.039,0.025-0.078c0.013-0.039,0.245-0.129,0.245-0.129S17.988,12.097,18.027,12.123zM16.988,11.668c-0.038,0.013-0.182-0.026-0.3-0.026c-0.116,0-0.091-0.078-0.143-0.064c-0.051,0.013-0.168,0.039-0.247,0.078c-0.078,0.039-0.208,0.03-0.208-0.04c0-0.104,0.052-0.078,0.221-0.143c0.169-0.065,0.352-0.247,0.429-0.169c0.078,0.078,0.221,0.169,0.312,0.182C17.144,11.5,17.026,11.655,16.988,11.668zM15.659,7.637c-0.079,0.026-0.347,0.139-0.321,0.199c0.01,0.023,0.078,0.069,0.19,0.052c0.113-0.018,0.276-0.035,0.355-0.043c0.078-0.009,0.095-0.139,0.009-0.147C15.805,7.689,15.736,7.611,15.659,7.637zM14.698,7.741c-0.061,0.026-0.243-0.043-0.338,0.018c-0.061,0.038-0.026,0.164,0.07,0.172c0.095,0.009,0.259-0.06,0.276-0.008c0.018,0.052,0.078,0.286,0.234,0.208c0.156-0.078,0.147-0.147,0.19-0.156c0.043-0.009-0.008-0.199-0.078-0.243C14.983,7.689,14.758,7.715,14.698,7.741zM14.385,7.005c0.017,0.044-0.008,0.078,0.113,0.095c0.121,0.018,0.173,0.035,0.243,0.035c0.069,0,0.042-0.113-0.018-0.19c-0.061-0.078-0.043-0.069-0.199-0.113c-0.156-0.043-0.312-0.043-0.416-0.035c-0.104,0.009-0.217-0.017-0.243,0.104c-0.013,0.062,0.07,0.112,0.174,0.112S14.368,6.962,14.385,7.005zM14.611,7.481c0.043,0.095,0.043,0.051,0.165,0.061C14.896,7.551,14.991,7.421,15,7.378c0.009-0.044-0.061-0.13-0.225-0.113c-0.165,0.017-0.667-0.026-0.736,0.034c-0.066,0.058,0,0.233-0.026,0.251c-0.026,0.017,0.009,0.095,0.077,0.078c0.069-0.017,0.104-0.182,0.157-0.182C14.299,7.447,14.568,7.386,14.611,7.481zM12.982,7.126c0.052,0.043,0.183,0.008,0.173-0.035c-0.008-0.043,0.053-0.217-0.051-0.225C13,6.858,12.854,6.962,12.697,7.014c-0.101,0.033-0.078,0.13-0.009,0.13S12.931,7.083,12.982,7.126zM13.72,7.282c-0.087,0.043-0.114,0.069-0.191,0.052c-0.078-0.017-0.078-0.156-0.217-0.13c-0.138,0.026-0.164,0.104-0.207,0.139s-0.139,0.061-0.173,0.043c-0.034-0.017-0.234-0.129-0.234-0.129s-0.416-0.018-0.433-0.07c-0.017-0.052-0.086-0.138-0.277-0.121s-0.52,0.13-0.572,0.13c-0.052,0,0.062,0.104-0.009,0.104c-0.069,0-0.155-0.008-0.181,0.069c-0.018,0.053,0.078,0.052,0.189,0.052c0.112,0,0.295,0,0.347-0.026c0.052-0.026,0.312-0.087,0.303-0.009c-0.009,0.079,0.104,0.199,0.164,0.182c0.061-0.017,0.183-0.13,0.243-0.086c0.061,0.043,0.07,0.146,0.13,0.173c0.061,0.025,0.226,0.025,0.304,0c0.077-0.027,0.294-0.027,0.389-0.009c0.095,0.018,0.373,0.069,0.399,0.018c0.026-0.053,0.104-0.061,0.112-0.113s0.051-0.216,0.051-0.216S13.806,7.239,13.72,7.282zM18.105,16.239c-0.119,0.021-0.091,0.252,0.052,0.21C18.3,16.407,18.223,16.217,18.105,16.239zM19.235,15.929c-0.104-0.026-0.221,0-0.299,0.013c-0.078,0.013-0.299,0.208-0.299,0.208s0.143,0.026,0.233,0.026c0.092,0,0.144,0.051,0.221,0.09c0.078,0.04,0.221-0.052,0.272-0.052c0.053,0,0.118,0.156,0.131-0.013C19.508,16.032,19.339,15.955,19.235,15.929zM15.616,7.507c-0.043-0.104-0.259-0.139-0.304-0.035C15.274,7.563,15.659,7.611,15.616,7.507zM18.093,15.292c0.143-0.026,0.064-0.144-0.053-0.13C17.922,15.175,17.949,15.318,18.093,15.292zM19.82,16.095c-0.119,0.022-0.092,0.253,0.051,0.211C20.015,16.264,19.937,16.074,19.82,16.095zM18.247,15.708c-0.09,0.013-0.285-0.09-0.389-0.182c-0.104-0.091-0.299-0.091-0.377-0.091c-0.077,0-0.39,0.091-0.39,0.091c-0.013,0.13,0.117,0.091,0.273,0.091s0.429-0.026,0.479,0.039c0.053,0.064,0.286,0.168,0.352,0.221c0.064,0.052,0.272,0.065,0.285,0.013S18.338,15.695,18.247,15.708zM16.698,7.412c-0.13-0.009-0.295-0.009-0.399,0c-0.104,0.008-0.182-0.069-0.26-0.113c-0.077-0.043-0.251-0.182-0.354-0.199c-0.104-0.017-0.086-0.017-0.303-0.069c-0.11-0.027-0.294-0.061-0.294-0.086c0-0.026-0.052,0.121,0.043,0.165c0.095,0.043,0.251,0.121,0.363,0.164c0.114,0.043,0.329,0.052,0.399,0.139c0.069,0.086,0.303,0.156,0.303,0.156l0.277,0.026c0,0,0.191-0.043,0.39-0.026c0.199,0.017,0.493,0.043,0.659,0.035c0.163-0.008,0.189-0.061,0.208-0.095c0.016-0.035-0.304-0.104-0.383-0.095C17.271,7.42,16.827,7.42,16.698,7.412zM17.182,9.404c-0.034,0.039,0.157,0.095,0.191,0.043C17.407,9.396,17.271,9.309,17.182,9.404zM17.764,9.585c0.086-0.035,0.043-0.139-0.079-0.104C17.547,9.521,17.676,9.62,17.764,9.585z'! !!RSSVGAnimationExamples methodsFor: 'examples'!example01SVGIcons	<script: 'self new example01SVGIcons open setLabel: ''Icons'''>	| canvas shapes color r theta |	canvas := RSCanvas new.	r := Random new.	color := RSGradientPalette gradient21.	color range at: 1 put: RSGradientPalette trueSunset.	theta := (1 to: 3) collect: [ :i | r next * Float twoPi ].	shapes := #( america puzzlePiece supermarketCart ) collectWithIndex: [		          :m		          :index |		          | grad |		          grad := (color scale: m)			                  start: -20 asPoint;			                  stop: 20 asPoint.		          RSSVGPath new			          draggable;			          index: index;			          svgPath: (self perform: m);			          position: r next * 50 @ (r next * 50) - 25;			          color: grad;			          yourself ].	canvas addAll: shapes.	canvas newAnimation repeat onStepDo: [ :t |		shapes do: [ :shape |			| p ang ext block |			p := shape position.			ext := shape extent / 2.			ang := theta at: shape index.			block := [			         ang := Float pi / 4 + ang.			         p := ang cos @ ang sin * 1.5 + shape position ].			p := ang cos @ ang sin * 1.5 + p.			p x + ext x > 50 ifTrue: block.			p y + ext y > 50 ifTrue: block.			p x - ext x < -50 ifTrue: block.			p y - ext y < -50 ifTrue: block.			theta at: shape index put: ang.			shape position: p ] ].	canvas addShape: (RSBox new			 extent: 100 @ 100;			 noPaint;			 withBorder).	canvas		when: RSExtentChangedEvent		do: [ canvas camera zoomToFit: canvas extent extent: 100 asPoint ]		for: self.	^ canvas! !!RSSVGAnimationExamples methodsFor: 'examples'!example02Miku	<script: 'self new example02Miku open setLabel: ''Miku'''>	| random canvas lines easing |	random := Random new.	canvas := RSCanvas new.	lines := self miku lines.	lines := (0 to: lines size / 2 - 1)		collect: [ :i | (lines at: i * 2 + 1) -> (lines at: i * 2 + 2) ].	canvas addAll: (lines collectWithIndex: [ :line :index |		RSSVGPath new			draggable;			index: index;			svgPath: line key;			color: line value;			yourself ] ).	canvas @ RSCanvasController.	easing := RSEasingInterpolator elasticOut.	canvas nodes do: [ :e | | position |		position := (random next * 1000) @ (random next * 1000) - 100.		canvas newAnimation			easing: easing;			delay: (e index * 50) milliSeconds;			from: position;			to: e position;			duration: 5 seconds;			on: e shape set: #position:.			e position: position ].	canvas addShape: (RSLabel new		text: 'Roassal';		fontName: 'Marker Felt';		noPaint;		border: (RSBorder new color: Color transparent; width: 1.5);		fontSize: 100;		position: 320 @ 630).	canvas newAnimation		delay: 6 seconds;		duration: 3 seconds;		from: Color transparent;		to: Color black;		on: canvas shapes last border set: #color:.	^ canvas! !!RSSVGAnimationExamples methodsFor: 'examples'!example03Boat	<script: 'self new example03Boat open'>	| canvas perlin frame scale lines boat x pharo g updateLines |	canvas := RSCanvas new.	canvas color: Color pink.	perlin := NSPerlinNoise2 new.	frame := 0.	"perlin octaves: 3."	scale := 20.	lines := (1 to: 25) collect: [ :i |		RSPolyline new			"width: i log;"			yourself ] as: RSGroup.	g := RSGroup new.	g add: (RSSVGPath new		svgPath:'M254.4,440.8c0,2.4-2.4,4.8-4.8,4.8l0,0c-2.4,0-4.8-2.4-4.8-4.8V24c0-2.4,2.4-4.8,4.8-4.8l0,0c2.4,0,4.8,2.4,4.8,4.8V440.8z';		color: '788787').	g add: (RSSVGPath new		svgPath: 'M9.6,418.4c10.4,45.6,113.6,80.8,240,80.8s229.6-36,240-80.8H9.6z';		color: '9E6226').	g add: (RSSVGPath new		svgPath: 'M17.6,434.4c4.8,6.4,12,12.8,20,18.4h423.2c8.8-5.6,15.2-12,20-18.4H17.6z';		color: 'AF7643').	g add: (RSSVGPath new		svgPath: 'M367.2,488c24-4.8,44.8-11.2,63.2-18.4H68.8c17.6,7.2,39.2,13.6,63.2,18.4H367.2z';		color: 'AF7643').	g add: (RSSVGPath new		svgPath:'M497.6,414.4c0,2.4-2.4,4.8-4.8,4.8H6.4c-3.2,0-4.8-2.4-4.8-4.8l0,0c0-3.2,2.4-4.8,4.8-4.8H492C495.2,409.6,497.6,411.2,497.6,414.4L497.6,414.4z';		color: 'AF7643').	g add: (RSEllipse new		position: 249.6@ 18.4; radius: 18.4;		color: '788787').	g add: (RSSVGPath new		svgPath: 'M454.4,371.2c0-7.2,0.8-14.4,0.8-22.4c0-166.4-84.8-302.4-189.6-305.6v328H454.4z';		color: '0C91C4').	g add: (RSSVGPath new		svgPath: 'M454.4,371.2c0-7.2,0.8-14.4,0.8-22.4c0-166.4-84.8-302.4-189.6-305.6';		color: '22B3E0').	g add: (RSPolygon new		points: {232.8@43.2. 144.8@87.2. 232.8@130.4};		color: 'FFAE0B').	g add: (RSPolygon new		points: {232.8@80.8. 144.8@87.2. 232.8@130.4};		color: 'FF860D').	g add: (RSPolygon new		points: {231.2@144.8. 231.2@363.2. 89.6@363.2};		color: 'E00E0E').	g add: (RSPolygon new		points: {231.2@198.4. 231.2@363.2. 89.6@363.2};		color: 'BF1111').	boat := RSComposite new shapes: g; yourself.	x := 1.	updateLines := [		lines doWithIndex: [:line :m |			| points |			points := (1 to: 200) collect: [ :i | | y |				y := (perlin snoise: (i+ frame)/scale and: (m + frame) / scale) * 20.				i @ (7* m + y)].			line controlPoints: points ] ].	updateLines value.	canvas newAnimation		repeat;		onStepDo: [ :t |			| cp p1 p2 vector |			frame := frame + 0.5.			updateLines value.			cp := (lines at: (lines size / 2) asInteger) controlPoints.			x := x + 0.3.			(x between: 1 and: cp size - 1)				ifFalse: [ x := cp size - 1 ].			p1 := cp at: x asInteger.			p2 := cp at: (x + 1) asInteger.			vector := p2 - p1.			boat matrix				loadIdentity;				rotateByRadians: vector angle;				scaleBy: 0.025;				translation: x @ p1 y.			canvas signalUpdate. ].	canvas addAll: lines.	pharo := RSBitmap new		form: (self iconNamed: #pharo);		yourself.	canvas zoomToFit.	canvas camera scale: 2.5.	canvas add: pharo.	canvas add: boat.	RSLocation new		inner; bottom; right;		move: pharo on: lines.	^ canvas! !!RSSVGAnimationExamples methodsFor: 'examples'!example04RoassalIcon	<script: 'self new example04RoassalIcon open'>	| c newEllipse paint eAnimation |	c := RSCanvas new.	newEllipse := [	              RSEllipse new		              color: 'E83A54';		              radius: 0;		              yourself ].	paint := (LinearGradientPaint fromArray: {				          (0 -> '25B4AF').				          (1 -> '0088AC') })		         start: 28.879 @ 143.392;		         stop: 272.3663 @ 143.392.	c		addShape: (RSSVGPath new				 noPaint;				 border: (RSBorder new						  paint: paint;						  width: 21;						  capRound);				 svgPath: 'M77,24.4v243.9			M264.2,232.3c0,0-24.1,30-51.7,30C144.3,262.3,174,113,77,113c-18.5,0-37.6,12.6-37.6,30		c0,16,11.8,28,38.3,28s115.7-10.7,115.7-77.1c0-53.9-45.7-69.5-116.5-69.5c-11.8,0-21.8,1.4-30.1,3.4c-4.6,1.1-8.7,2.4-12.3,3.8');		addShape: (newEllipse value position: 264.2 @ 232.3);		addShape: (newEllipse value position: 143.6 @ 158.1);		addShape: (newEllipse value position: 77 @ 268.4);		addShape: (newEllipse value position: 34.6 @ 31.6).	c newAnimation		from: 0;		to: 1000;		duration: 10 seconds;		onStepDo: [ :t |			c shapes first border dashArray: {						t.						10000 }.			c signalUpdate ].	eAnimation := [ :duration :shape |	              c newAnimation		              duration: duration milliSeconds;		              when: RSAnimationEndEvent do: [			              c newAnimation				              from: 0;				              to: 20.4;				              easing: RSEasingInterpolator elasticOut;				              on: shape set: #radius: ]		              for: self ].	eAnimation value: 1 value: c shapes second.	eAnimation value: 2000 value: c shapes third.	eAnimation value: 2500 value: c shapes fourth.	eAnimation value: 7500 value: c shapes fifth.	c @ RSCanvasController.	^ c! !!RSSVGAnimationExamples methodsFor: 'examples'!example05Corona	<script: 'self new example05Corona open'>	| canvas extent mainScale curveScale yscale color axis title ytitle xtitle lineTitle line curve normalY spoint |	canvas := RSCanvas new.	extent := 500@250.	mainScale := NSScale linear		domain: {0@0. 100@100};		range: {0@extent y. extent x@ 0}.	curveScale := NSScale linear		domain: #(0 0.5 1);		range: #(50 90 50).	yscale := NSScale linear		domain: #(40 100);		range: #(500 40).	color := NSScale linear		domain: #(40 80 100);		range: { Color red. Color orange. Color green }.	axis := RSPolyline new		controlPoints:  ({ 0@100. 0@0. 100@0} collect: [:p| mainScale scale: p]);		markerStartEnd: (RSShapeFactory arrow			extent: 10@15;			color: Color black);		yourself.	title := RSLabel new		text: 'Simulation';		bold;		fontSize: 20;		position: (mainScale scale: 50@100);		yourself.	ytitle := RSLabel new		text: 'Number of cases';		bold;		position: (mainScale scale: -3@ 50);		rotateByDegrees: -90;		yourself.	xtitle := RSLabel new		text: 'Time';		bold;		position: (mainScale scale: 50@ -7);		yourself.	lineTitle := RSLabel new		text: 'Heal care system capacity';		bold;		position: (mainScale scale: 75@ 30);		yourself.	line := RSLine new		startPoint: (mainScale scale: 0@20);		dashArray: #(10);		endPoint: (mainScale scale: 100@20);		yourself.	curve := RSSVGPath new withBorder.	normalY := [ :x :mean :std |		(-0.5 * (2* Float pi) log - std log -		 ( ((x - mean) raisedTo: 2) / (2 * std * std))) exp].	spoint := [ :s :p | s << p x asFloat asString; space; << p y asFloat asString ].	canvas newAnimation		repeat;		duration: 10 seconds;		scale: curveScale;		onStepDo: [ :t |			| low upp mean stdDev series y first |			low := 0.			upp := t.			mean := (low + upp) / 2.			stdDev := (upp - low) / 4.			first := nil.			series := (low to: upp) collect: [ :x |				y := normalY value: x value: mean value: stdDev.				y := y * (yscale scale: t).				first ifNil: [ first := y ].				mainScale scale: x @ (y - first ) ].			curve svgPath: (String streamContents: [ :s |				s << 'M'.				spoint value: s value: (mainScale scale: 0@0).				series do: [ :p | s << 'L'. spoint value: s value: p ].				s << 'L'.				spoint value: s value: series last x@ 250.				s << 'Z' ]).			curve paint: (color scale: t).			canvas signalUpdate.			].	canvas add: axis.	canvas add: title.	canvas add: ytitle.	canvas add: xtitle.	canvas add: curve.	canvas add: line.	canvas add: lineTitle.	canvas @RSCanvasController.	^ canvas! !!RSSVGAnimationExamples methodsFor: 'examples'!example06AnimatedSVG	<script: 'self new example06AnimatedSVG open'>	| monsterPath monster c |	monsterPath := 'M256,200.348c-30.736,0-55.652,24.917-55.652,55.652s24.917,55.652,55.652,55.652s55.652-24.917,55.652-55.652			S286.736,200.348,256,200.348z M272.696,256c-9.208,0-16.696-7.492-16.696-16.696c0-9.204,7.487-16.696,16.696-16.696			c9.208,0,16.696,7.492,16.696,16.696C289.391,248.508,281.904,256,272.696,256zM418.265,117.344l22.177-22.179c6.529,3.119,13.752,5.009,21.471,5.009c27.662,0,50.087-22.424,50.087-50.087			S489.576,0,461.913,0s-50.087,22.424-50.087,50.087c0,7.718,1.89,14.94,5.009,21.471L389.092,99.3			C350.286,78.679,304.711,66.783,256,66.783S161.714,78.679,122.909,99.3L95.165,71.558c3.119-6.53,5.009-13.753,5.009-21.471			C100.174,22.424,77.749,0,50.087,0S0,22.424,0,50.087s22.424,50.087,50.087,50.087c7.718,0,14.94-1.89,21.471-5.009l22.177,22.177			C36.543,158.204,0,220.156,0,289.391C0,412.135,114.843,512,256,512s256-99.865,256-222.609			C512,220.156,475.457,158.204,418.265,117.344z M322.783,445.217H200.348c-9.223,0-16.696-7.473-16.696-16.696			c0-9.223,7.473-16.696,16.696-16.696h122.435c9.223,0,16.696,7.473,16.696,16.696			C339.478,437.744,332.005,445.217,322.783,445.217z M256,378.435c-67.51,0-122.435-54.934-122.435-122.435			S188.489,133.565,256,133.565c67.511,0,122.435,54.934,122.435,122.435S323.511,378.435,256,378.435z'.	monster := RSSVGPath new svgPath: monsterPath.	c := RSCanvas new.	c add: monster.	c newAnimation repeat		duration: 0.1 seconds;		when: RSAnimationLoopEvent			do: [ :evt | monster rotateByDegrees: 5 ].	c @ RSCanvasController.	^ c! !!RSSVGAnimationExamples methodsFor: 'data - svg'!miku	^ 'm 148.25647,236.39122 -3.89508,14.84999 -14.11966,51.12292 -10.10286,26.9004 -15.70204,33.35162 -14.849996,32.37785 -10.589748,26.90039 -6.207783,20.20573 -5.477456,18.25819 -3.408195,26.77867 0.365164,20.69261 2.556146,18.62335 6.329504,21.42294 1.095491,-13.38934 2.434425,-21.7881 3.89508,-24.34425 7.546717,-21.1795 5.477456,19.84057 7.303275,27.63072 11.92868,23.97908 17.04097,22.8836 9.61598,9.25081 5.84262,-16.43237 6.81639,-24.1008 3.28648,-15.21516 2.3127,-20.57089 2.55615,-15.70204 0.48688,-21.7881 0.60861,-26.90039 3.85187,-84.73722 3.09851,-18.41896 3.09852,-17.73041 7.57415,23.58316 2.23782,-5.85275 8.95127,-21.51748 5.1642,-11.18909 6.71345,27.54237 8.60699,21.34534 3.27066,-26.85381 4.13136,15.83686 4.64777,18.24682 6.88559,16.86971 4.64778,5.33633 -0.17214,-11.87765 0.34428,-15.49258 228.94597,2.23782 2.06568,14.45974 0.8607,18.5911 1.03284,24.616 0.51642,34.08369 0.17214,32.53443 1.54926,22.55031 5.33633,26.3374 2.92638,17.38612 8.43485,32.70657 4.13136,-2.23782 17.55826,-19.62394 15.83687,-20.3125 12.22192,-17.7304 12.22193,-21.34534 9.12341,-22.72246 7.74629,-25.64883 5.68062,17.7304 8.09057,30.12447 4.81992,22.20604 2.40995,18.93538 0.51642,9.29555 2.75424,-7.22987 4.13136,-14.80403 2.58209,-14.80403 -0.86069,-19.10752 -2.75424,-16.52542 -3.4428,-16.18114 -4.99205,-13.25477 -8.26272,-17.55826 -6.19703,-12.73835 -10.84481,-20.82892 -14.63188,-25.4767 -9.4677,-19.96822 -7.05773,-16.35328 -6.36917,-14.97617 -3.95922,-11.18908 -21.87474,-45.37302 -14.3631,-37.73359 -37.73359,15.33688 0.73033,17.28442 -4.86885,6.08606 -0.24344,-23.12704 -60.86062,13.63278 -74.4934,10.22459 -67.92046,-2.19099 -54.77455,-7.30327 z#299ca3m 267.67744,453.58845 2.58209,-2.92637 10.50053,-6.19704 9.98411,-7.22987 7.7463,-7.57415 0.57862,-2.65433 -0.85205,-6.20779 3.28648,-2.55614 3.28647,-7.18156 2.06926,-9.98114 1.94754,-8.64221 1.46066,-12.53729 -0.36517,-11.07663 -0.12172,-9.37253 10.95491,-0.73033 16.67581,-3.4082 10.83319,-2.43442 6.45123,0.60861 22.27499,28.60449 0.48688,21.90982 0.48689,11.19835 4.74712,1.0955 -0.97377,6.69466 -0.48688,3.77336 4.13852,5.7209 11.56352,7.425 5.84262,5.7209 -4.09974,22.93458 -32.36229,29.95233 -38.9036,-3.09852 -40.96928,-9.29555 -17.90254,-22.0339 z#ffffffm 266.81674,454.44915 8.09057,9.29555 8.77913,9.81197 10.15625,9.63983 5.33634,-1.54925 9.63983,-4.99206 11.87764,-7.57415 5.33634,-3.27066 5.68061,6.88559 7.57416,9.29556 10.15625,7.91843 4.99205,1.37712 6.54132,-3.78708 6.74264,-6.5708 9.37254,-5.59918 4.86885,-4.13852 6.93811,-5.59918 -1.94754,-8.76393 5.35573,2.43442 4.0168,-0.36516 4.62541,-8.27704 2.67787,-4.0168 10.71147,3.89507 -1.21722,6.32951 -10.3463,20.57089 c 0,0 -12.65901,15.94548 -12.29385,15.82376 0.36517,-0.12172 -11.68524,8.39877 -11.68524,8.39877 l -6.81639,2.79958 -17.04097,4.86885 -15.58032,2.67787 -9.12909,0.85205 -12.78073,-0.73033 -11.80696,-2.55614 -8.15533,-2.43443 -11.68523,-3.65164 -9.85942,-5.84261 -9.00738,-6.32951 -8.27704,-6.69467 2.92131,-4.0168 -7.05983,-6.93811 -6.32951,-10.58975 9.37254,-5.11229 z#808791m 241.86011,504.54312 5.59917,6.20778 11.32008,4.62541 9.85942,2.79959 -10.58975,13.38933 -17.52786,20.93606 -12.53728,15.33687 -5.1123,5.59918 -7.30327,3.65164 -11.56352,0.12172 -9.85942,-2.06926 -5.47746,-1.21722 1.94754,-6.69466 17.04098,-23.61393 10.71147,-13.63277 10.3463,-11.19836 9.25082,-10.22458 z#808791m 254.27567,493.5882 8.76393,7.05984 13.38934,8.76393 -7.18155,9.37253 -9.61598,-2.92131 -10.58975,-4.13852 -7.18155,-6.81639 z#fdf4ebm 408.73993,485.79804 6.45123,-2.06926 8.39876,-4.99057 0.85205,11.80696 -4.74713,15.94549 -6.3295,17.52785 -7.54672,14.48483 -0.12172,6.45123 2.55614,10.3463 1.21722,9.00738 -2.31271,5.72089 -6.57294,2.79959 -9.25082,0.12172 -5.47745,-0.85204 -7.18156,-1.94754 -4.86885,-4.62541 -1.21721,-7.425 2.3127,-13.26761 6.45123,-15.09344 4.86885,-9.85942 4.86885,-11.56352 0.97377,-6.3295 6.93811,-5.96434 6.57295,-7.91188 1.70409,-2.43443 z#808792m 247.79529,463.48649 3.87314,6.97167 9.7259,11.4473 -2.15174,2.49602 7.83236,6.97167 11.53337,7.1438 7.74629,4.81991 17.12791,5.33634 13.94333,3.09852 14.71795,0.60249 10.84481,-0.94677 13.08263,-2.92638 12.82442,-3.18459 11.27516,-5.33633 8.34878,-6.19704 7.66022,-8.60699 7.57415,-11.10302 4.21743,-6.97166 4.13136,-9.12341 1.80746,-6.88559 3.52887,1.46318 1.80747,3.70101 -1.11891,7.66022 -5.07813,13.68512 -4.30349,6.54131 -8.26271,9.46769 -8.34879,8.52093 -6.54131,5.16419 -11.79158,5.93882 -10.15625,3.4428 -7.48808,1.7214 -9.38162,2.66817 -12.308,2.15174 -6.02489,-0.77462 -11.70551,-0.68856 -8.43485,-2.32389 -7.40202,-0.43035 -2.15174,-2.15175 -4.47564,-0.60249 -7.40201,-1.97961 -8.77913,-3.61493 -4.99206,-3.78708 -7.66022,-3.87315 -6.62738,-5.4224 -4.21743,-4.3035 -1.63533,-2.15174 1.97961,-3.01245 -6.45524,-8.26271 -4.90599,-7.14381 -1.63533,-3.95921 3.35673,-3.27066 z#93d3d5m 416.16493,468.75707 4.86885,4.26024 1.94754,5.96435 -5.47746,3.16475 -7.425,2.67786 2.31271,-6.81638 z#fdf4ebm 319.27482,371.98868 5.23401,-4.6254 4.13852,0.6086 5.7209,3.65164 0.24344,2.55615 -3.52991,5.23401 3.40819,11.19835 3.65164,13.02418 -1.7041,6.81639 -7.30327,8.39876 -7.05983,5.59918 -3.65164,-2.79959 -4.50369,-9.12909 -4.38196,-9.61598 2.43442,-5.11229 4.62541,-8.27705 4.62541,-10.83319 z#93d3d5m 284.58426,368.94565 8.39877,-2.3127 9.85942,-4.50369 4.50369,-2.55614 -9.49426,-0.85205 -10.95491,-0.97377 -3.28648,-2.67787 26.65696,-0.73033 21.42293,-1.21721 14.72827,-0.48688 -7.91188,2.92131 -4.99057,1.70409 -5.59917,10.10287 -2.79959,0.6086 -3.04303,-4.26024 -2.31271,-4.99057 -10.10286,1.09549 0.12172,17.52786 -6.93811,4.13852 -10.58975,5.7209 -4.86885,-11.68524 z#fdf4ebm 354.08709,353.24361 32.86474,0 -2.92131,4.50369 -7.425,7.30327 -1.94754,17.1627 -3.65164,8.27704 -5.59917,2.31271 -4.13852,-0.60861 -4.01681,-5.23401 -3.16475,-12.90246 -0.48688,-13.02417 z#fdf4ebm 201.4036,388.5196 24.96028,-7.57416 19.62394,-4.99205 28.05879,-8.77913 12.39407,30.29661 -9.81197,8.26271 -18.82312,14.33499 -27.75244,20.08401 -11.6077,-21.76672 z#808791m 190.90307,392.30667 9.89804,-3.87314 11.53337,20.3125 17.98861,32.01801 -11.18909,7.31594 -10.58659,-19.53787 -11.4473,-22.63639 z#93d3d5m 274.30482,367.43247 7.31594,-1.89354 3.87315,6.2831 6.11096,11.70551 2.32389,7.74629 -7.66022,5.50848 -5.07813,-11.27516 -6.19703,-13.59905 z#93d3d5m 178.56506,409.23538 2.06926,-6.93811 4.26025,-4.13852 8.27704,0.12172 14.60655,29.69999 -5.35573,7.30327 -7.66844,4.13852 -4.13853,1.82582 -8.76392,4.13852 -6.32951,0.24345 -6.20778,-2.79959 -5.11229,-8.88565 -3.52992,-8.88565 -3.77336,-10.34631 1.21721,-4.50369 5.35574,-7.42499 2.43442,8.88565 6.20779,-0.97377 z#fdf4ebm 177.99259,446.70286 6.36917,14.45975 6.71345,10.50053 5.50848,0.51641 5.59454,-4.5617 0.94677,-3.27066 -3.35673,-9.12341 -6.36917,-15.23437 -3.4428,1.89353 -5.25026,2.66817 -6.79952,1.03284 z#ffffffm 150.10593,227.74099 2.75424,-17.90254 -10.50053,7.22988 0.17214,-10.50053 2.40996,-12.73835 7.05773,-6.71346 7.22987,-7.74629 2.17303,-8.34279 3.89508,-6.57294 5.47745,-4.26025 10.71147,0.73033 5.59918,-2.55615 11.56352,-17.04097 -8.15533,-7.05983 -7.91188,-6.93811 -6.20778,-8.15533 -3.16475,-6.08606 12.17212,6.81639 19.84056,8.64221 12.90246,2.79959 15.94548,1.82582 6.3295,-1.46066 14.60655,-4.0168 25.43974,-4.26024 22.88359,-1.94754 59.54143,-10.9726 53.01907,28.91949 5.50848,16.69756 7.83236,15.57866 25.033,2.60391 42.11555,37.97702 -78.87536,23.37048 -62.80816,15.09344 -61.10407,4.86885 -73.76307,-4.62541 -68.65078,-14.11966 z#93d3d5m 72.667581,151.91668 6.694669,1.94754 9.737699,6.57295 5.599177,4.86885 9.250814,9.85942 8.0336,10.71147 7.79016,11.92868 0.48689,-9.85942 1.82582,-13.26762 3.52991,-15.58032 6.32951,-16.0672 5.23401,-11.32008 4.92159,-9.06132 6.19703,-7.74629 5.50848,-2.66817 6.88559,-0.34428 8.17664,3.27066 5.85276,4.21742 1.7214,6.62738 -0.77463,8.43486 -5.76669,11.27516 -6.97166,9.98411 -4.38957,7.40201 -6.62738,11.70551 -3.61494,10.24232 -3.35672,9.55376 -1.54926,8.34878 -0.97863,6.41624 -0.36516,17.1627 0.85205,17.1627 2.3127,15.58031 3.16475,18.37991 3.4082,16.91925 -20.57089,8.27705 -5.47746,-22.76187 -3.89508,-17.1627 -4.99057,-18.62335 -4.62541,-13.63278 -5.59917,-9.49425 -6.938113,-10.22459 -9.615978,-9.61598 -6.451226,-7.30327 -6.675989,-5.36698 -8.305746,-5.20723 -4.647776,-4.30349 -1.204979,-9.29555 2.496028,-9.63983 3.959216,-6.41221 z#5fc5c9m 166.37315,411.41419 6.54131,-0.77462 6.02489,-1.7214 1.80747,-6.62739 -4.64777,-11.53337 -4.99206,-21.34533 -5.68061,-20.82892 -5.50848,-22.20604 -8.26271,-34.25583 c -6.20014,3.16792 -11.49776,7.01271 -21.1732,7.57415 l 7.57415,33.05085 8.77914,29.43591 7.57415,18.50503 7.74629,18.59111 z#ffffffm 74.966896,158.45471 1.979608,2.79727 0.25821,4.1744 -0.860699,4.30349 -1.850503,3.78708 -1.506224,2.45299 -2.108713,1.97961 -2.237817,-0.0861 -1.721399,-1.67836 c -0.758778,-9.75855 3.696766,-18.27448 8.047537,-17.73038 z#299da4m 152.90321,117.61454 c 7.03567,-1.57483 15.78503,3.49999 17.62825,9.8666 l -0.27387,1.46065 -1.61281,2.03883 -2.79959,1.36937 -2.37356,-0.18258 -4.89928,-1.88668 -5.17315,-3.95594 -1.94754,-2.58658 -0.79119,-2.58658 0.27387,-1.94754 0.88248,-1.09549 z#299da4m 448.25212,176.09905 21.34534,-22.20604 -12.39407,-13.25477 -5.86103,-6.73631 -14.60654,-13.99794 -11.03402,-10.25092 -11.96372,-9.46769 -9.20948,-7.660223 -5.33633,-10.07018 -3.70101,-11.877648 -3.35673,-14.804025 -1.72139,-12.049789 -0.43035,-11.016949 -3.09852,-4.733845 -9.20948,-4.905985 -6.36917,0.08607 -6.97167,2.582097 -2.8403,5.422405 -0.60249,15.320445 1.29104,15.750794 2.23782,10.41446 4.90599,10.930879 0.90373,3.657971 -5.2933,1.075875 -16.43935,1.118908 -19.71001,3.442797 -13.85726,3.442797 -8.0045,3.356726 -3.18459,3.70101 -0.94677,9.55376 1.20498,9.29555 3.18459,7.05773 2.06568,0.60249 11.96371,-3.18459 19.96822,-3.52886 22.8946,-0.25821 15.49259,2.49603 16.18114,9.81197 14.97617,9.63983 14.11546,11.79157 z#5fc5c9m 431.98491,162.84428 15.92293,13.85725 -3.01245,11.27516 -2.92637,8.34879 1.63532,13.68511 8.17665,28.57521 -8.52093,9.03735 -6.88559,-13.68512 -9.29555,-17.30005 -4.5617,-13.08263 0.60248,-8.09057 4.04529,-13.85726 3.01245,-11.70551 z#808791m 247.36494,201.05932 17.21398,49.57627 10.67267,23.06674 12.39407,21.34534 13.08262,15.32044 13.77119,13.59905 -0.68856,-12.91049 -1.54926,-38.73146 5.1642,-36.49364 8.26271,-42.3464 36.66578,57.4947 13.59905,35.97723 -1.05197,13.58121 -1.15635,23.12704 -0.79119,9.61598 -36.1512,9.37253 -54.65284,3.89508 -22.39671,-5.59917 -24.58769,3.52991 -6.45123,-6.69467 -1.33893,-11.44179 -0.85205,-18.86679 -0.24344,-12.78073 -1.58238,-21.05778 13.99795,-49.90571 z#fdf4ebm 480.0625,208.28125 c -10.91988,4.12393 -21.98027,8.0309 -33.15625,11.6875 l 3.3125,12.625 c 3.80711,-1.2643 7.63016,-2.57732 11.46875,-3.9375 l 1.53125,-1.6875 L 467.375,223 l 3.53125,2.3125 c 3.08442,-1.14879 6.17882,-2.31867 9.28125,-3.53125 l 1.34375,-3.15625 4.125,-4.5 -5.59375,-5.84375 z m -49.25,16.75 c -6.10399,1.83639 -12.23387,3.58742 -18.40625,5.25 l 4.125,12.4375 c 6.93741,-1.85936 13.9349,-3.88821 21,-6.0625 l -6.71875,-11.625 z m -280.59375,4.0625 -3.125,12.25 c 18.02488,7.60993 44.65417,14.50638 77.75,18.09375 l 2.71875,-13.375 c -25.52993,-3.0698 -51.33015,-8.56718 -77.34375,-16.96875 z M 405.96875,232 c -15.43506,3.98249 -31.08297,7.36842 -46.90625,10.0625 l 4.625,12.21875 c 13.911,-2.3659 28.2087,-5.32857 42.8125,-8.96875 L 405.96875,232 z M 311.875,247.8125 c -15.10479,1.11216 -30.35409,1.5248 -45.71875,1.09375 L 270.25,262 c 13.20733,0.10471 27.07798,-0.31428 41.53125,-1.375 l 0.0937,-12.8125 z#ffffffm 187.69415,157.69844 2.43443,-9.79856 2.0084,-5.17316 5.11229,-1.82581 4.74713,2.0084 7.18155,4.86885 -5.59917,2.19098 -9.25082,4.50368 z#7f8791m 198.64907,141.57037 c -1.88612,4.4324 -2.97264,8.465 -3.89508,12.41557 l 3.65163,-0.60861 c 0.86888,-4.04055 1.97288,-7.84596 3.16476,-11.56351 z#fb9ae7m 440.50583,170.5045 3.01244,2.5821 c -3.10015,10.35019 -10.10675,24.24455 -9.46769,26.5956 0.9743,3.58438 3.14331,6.66171 4.13136,10.24232 5.43376,19.69146 7.99932,25.03314 11.87765,29.86626 l -2.84031,3.09852 c -2.56504,-5.67442 -7.68573,-16.66677 -10.5866,-25.21849 -1.76587,-5.20575 -0.84787,-7.95931 -2.8403,-13.08262 -0.39089,-1.00512 -2.1206,-4.09214 -2.23782,-5.1642 -0.45037,-4.11903 3.0183,-11.72928 8.95127,-28.91949 z#fb9ae7m 405.21716,281.53469 6.11097,-5.4224 1.63532,2.66816 0.17214,7.48809 -8.26271,10.50053 z#fb9ae7m 404.78681,281.96504 4.99206,-4.13135 2.40996,-1.7214 1.72139,9.12341 12.22193,-16.18115 -4.38956,-5.50847 -1.54926,-8.34878 -2.92638,-9.46769 -3.18459,-12.04979 -4.30349,-9.81197 -4.21743,-8.17664 -0.0861,14.97616 1.46319,16.69757 -1.29105,25.90704 z#808791m 478.24276,230.18344 1.46065,-8.88565 3.52992,-5.96434 4.86885,-2.67787 6.81639,1.33893 3.16475,3.04303 4.38197,-4.38196 3.16475,-6.57295 1.21721,-4.99057 -3.40819,-2.67787 -0.12173,-1.94754 4.38197,-1.15635 6.99897,3.7125 12.11126,10.10286 6.57295,7.97274 4.99057,10.28545 -1.09549,6.45122 -2.79959,6.75553 -4.3211,8.03361 -5.53832,4.0168 -3.83422,0.6086 -1.64323,4.32111 -4.13853,2.617 -6.45122,1.15635 -5.35574,0.36517 -7.48585,-11.1375 -9.55512,-11.62437 -6.3295,-5.7209 z#fdf4ebm 467.22699,223.00188 -8.27705,8.39877 6.26865,4.26024 8.45962,6.69467 8.94651,10.28545 5.29488,7.66843 5.17315,10.10287 5.35574,12.47642 6.14692,23.30962 3.22561,0.54775 4.74713,-3.65164 5.96434,-6.08606 -3.10389,-10.65061 -10.52889,-21.11864 -5.23401,-7.54671 -8.0336,-12.65901 -8.76393,-10.10286 -9.61598,-8.27705 z#93d3d4m 381.47437,333.52477 10.22982,-0.4342 12.39406,-1.03284 20.74285,-1.97961 13.51298,-0.43035 17.12791,-1.54925 9.46769,-0.51642 8.69306,-4.47564 11.87765,-9.38162 11.18909,-7.05773 6.62739,-0.60249 6.62738,1.80747 4.90598,7.83236 1.03284,7.40201 -2.58209,5.59455 -7.66023,4.90598 -10.50053,4.38957 -11.79157,3.44279 -7.83237,1.11891 13.51298,5.68062 20.91499,8.77913 20.05429,9.7259 16.78363,9.03734 8.8652,7.74629 2.40996,6.62739 -2.15175,9.38162 -3.25366,5.11167 -3.80407,4.52816 -7.31594,5.16419 -5.1642,0.60249 -9.20948,-3.61494 -11.79158,-10.07018 -11.79157,-11.10301 -11.70551,-10.24232 -12.91049,-9.72591 -9.63983,-7.22987 -10.41446,-4.81991 -9.46769,-3.61494 -10.50053,-0.34428 -17.12791,-0.60249 -24.01351,-0.0861 -17.64433,-0.34428 z#5fc5c9m 378.27728,328.87315 -3.35673,4.13135 6.45525,0.0861 z#93d3d4m 385.73462,353.42619 12.71987,0.0609 5.29487,5.05144 -6.69467,5.05143 -5.78176,-3.52992 -4.92971,-5.05143 z#93d3d4m 458.92479,232.13056 4.99205,2.66817 9.29556,7.1438 10.15625,10.67267 6.2831,10.15625 5.68061,11.87765 3.70101,10.07018 3.70101,11.36123 2.23781,9.89804 -5.25026,0.0861 -4.64778,1.80747 -6.54131,4.30349 -11.10302,8.09057 -8.77913,5.68062 -5.25027,2.5821 -10.93087,0.17214 -11.83865,0.7461 -11.68524,0.48688 -12.35471,1.21722 -13.57192,1.03463 -5.41659,0.6086 -15.1543,0.42603 -4.13852,-8.88565 6.57295,-5.59918 4.92971,13.57192 7.91188,-0.60861 3.46905,-12.53729 1.94754,-11.19835 1.27808,-10.22458 4.74712,-6.81639 7.60758,-9.25082 8.06757,-10.8095 8.95127,-12.04979 12.39407,-14.63188 11.96372,-12.39407 z#808791m 399.62262,353.66128 12.99655,0.25821 -9.12341,4.90599 z#808791m 236.17585,344.27966 2.23782,-5.33633 7.31594,-4.13136 12.99656,-0.60249 15.40651,-0.0861 2.49603,5.1642 5.76668,1.63532 6.62739,-1.63532 3.95921,-3.35673 7.31595,3.95921 7.57415,1.11891 6.71345,-1.63532 6.45524,-5.93883 6.62739,-0.8607 17.55826,0.43035 16.43935,0.8607 18.41897,-0.17214 3.701,-0.17214 c -1.46829,4.78103 -1.9166,11.60199 -1.54925,20.05429 l -14.63189,-0.25821 -21.86176,-0.43035 -18.16075,1.03284 -17.47219,0.60249 -20.91499,0.43035 -18.50504,0.17214 -13.4269,0.17214 -8.34878,-0.51642 -8.26272,-1.37712 -4.38956,-3.52887 z#ffffffm 552.371,389.75998 c -2.49095,9.6659 -6.94355,16.46199 -13.81537,19.71885 l -3.10389,-1.33894 -0.18258,-3.7125 1.21721,-4.80798 2.67787,-5.59918 3.52992,-3.65164 3.52991,-2.19098 3.83422,-1.21721 1.71442,0.87064 z#299ca3m 538.12961,234.20024 7.18155,12.53729 4.50369,12.29384 0.12172,6.93811 -2.67787,4.74713 -3.65163,2.92131 -2.67787,0.54775 -3.46906,-3.52992 -6.51208,-8.09446 -6.81639,-9.7377 5.78176,-4.50369 4.07766,-5.96434 2.67787,-7.18155 z#ffffffm 485.60646,214.40016 5.25027,-0.51642 7.91843,2.84031 3.61494,-4.13136 3.52886,-6.79952 0.51642,-5.07813 -7.40201,-9.12341 -7.523,-10.46185 -9.61597,-12.29385 -14.60656,-18.01474 c -7.65585,12.01479 -15.38301,18.65231 -23.00531,22.64015 l 20.08401,18.37991 16.18892,16.0672 z#ffffffm 223.78178,263.71822 1.54926,19.10752 c 7.42354,-28.43554 16.28337,-50.63582 22.20604,-74.19227 4.3298,19.47745 11.43985,39.4604 25.82097,60.76536 l -8.43485,-22.37817 -6.02489,-22.55032 -3.78708,-16.35329 -1.7214,-20.3125 -0.68856,-19.10752 -3.95921,6.71346 -4.99206,16.52542 -4.13136,12.04979 -7.05773,24.61599 z#f8bba6m 317.25371,165.9428 5.68061,6.36917 8.09057,12.39407 9.63984,18.5911 13.59904,29.43591 9.63983,23.7553 c -14.91707,-17.72028 -27.14191,-35.93006 -37.01006,-54.56833 -3.97848,18.72673 -8.76077,47.90307 -14.11547,84.52066 l -1.20498,-23.7553 1.7214,-27.37023 0.8607,-25.13242 1.54926,-22.72246 z#f8bba6m 155.125,209.125 -3.34375,2.125 c -1.19191,7.58216 -2.51216,15.4045 -4.25,23.03125 -1.13172,5.29018 -2.40529,10.6577 -3.75,16.0625 l 1.25,6.75 c 1.82232,-7.15843 3.55969,-14.32927 5.25,-21.5625 2.08211,-9.04014 3.55542,-17.99909 4.84375,-26.40625 z m -25.59375,89.40625 c -1.22344,3.54891 -2.43061,7.01443 -3.65625,10.3125 -23.29503,63.59916 -64.03125,122.16517 -64.03125,189.25 0,18.6086 4.187985,36.84136 8.919678,48.90884 1.230121,3.13724 2.285052,4.28124 3.091048,4.05766 0.805996,-0.22358 1.092635,-1.9105 1.320275,-4.86445 1.82224,-23.64618 3.983515,-47.09643 10.436204,-68.13804 0.773996,-2.52393 1.76968,-5.57549 2.514045,-5.57047 0.744365,0.005 0.894453,2.99632 1.385426,5.41439 7.300589,35.95584 21.141314,67.85441 45.611034,91.28735 1.58142,1.51441 3.34127,2.77095 4.57424,2.54929 1.23297,-0.22166 1.76376,-1.84855 2.45611,-3.6903 20.19014,-53.70883 19.44685,-92.93263 20.72319,-133.73552 0.36982,-5.23993 -1.45168,-7.94582 -3.8125,-10 1.79353,45.24895 -1.58002,91.22691 -18.30123,139.00221 -0.5714,1.63257 -0.76411,3.38147 -2.06557,3.56511 -1.30146,0.18364 -2.51798,-1.36983 -3.86206,-2.73881 -28.3933,-28.91926 -37.112825,-62.12083 -43.700293,-95.76591 -0.523738,-2.67496 -0.57079,-3.49989 -1.969947,-3.81392 -1.399156,-0.31404 -2.099286,1.07435 -3.238228,3.70467 -6.029559,13.92491 -9.798966,28.86851 -12.766938,65.63269 -0.21294,2.63768 -0.02193,5.03411 -0.885194,5.15919 -0.863258,0.12509 -1.968502,-2.68814 -2.563441,-5.03455 C 67.643566,525.87487 65.25,512.88476 65.25,498.59375 c 0,-67.11566 42.17483,-128.50301 63.3125,-188.21875 0.90203,-2.37718 1.78085,-4.73456 2.625,-7.09375 z#000000m 176.61752,446.84725 1.47057,-1.48444 1.93763,1.60616 c 0,0 7.49134,23.7965 12.90245,23.7965 3.26872,0 8.94651,-3.35424 8.94651,-5.29487 0,-5.48726 -9.92028,-23.4922 -9.92028,-23.4922 l 1.21721,-2.06926 2.3127,1.33893 c 0,0 8.88565,18.77162 8.88565,24.46597 0,3.77364 -6.82795,7.72929 -11.38093,7.72929 -6.56381,0 -11.26047,-14.49902 -16.37151,-26.59608 z#000000m 171.84375,298.625 c -2.85759,15.3187 -5.72399,30.49037 -7.96875,45.8125 l 2.59375,10.53125 c 1.06462,-12.78171 2.8288,-25.43522 6.46875,-43.5625 L 171.84375,298.625 z M 159.6875,393.25 c -0.006,0.46079 -0.0279,0.91337 -0.0312,1.375 l -0.0937,11.71875 4.5,-2 c 0.012,-0.27879 0.0194,-0.44244 0.0312,-0.71875 l -4.4063,-10.375 z#000000m 160.34825,404.87288 c 0,0 -4.99205,5.25958 -4.99205,8.43485 0,3.9951 4.72479,11.3353 6.36917,17.4722 1.54529,5.76709 3.90438,16.61149 16.52542,16.61149 7.15488,0 12.34049,-5.72226 16.00901,-5.93883 7.28991,-0.43035 14.63188,-11.36122 14.63188,-11.36122 l -1.80746,-3.35673 c 0,0 -5.09149,10.62263 -13.25477,11.27516 -2.82496,0.22581 -6.6816,6.02489 -15.40652,6.02489 -8.55579,0 -9.49679,-3.94525 -11.72228,-8.47034 -1.21925,-2.47909 -2.99567,-3.87558 -3.68423,-7.36652 -1.13118,-5.73501 -4.38957,-11.55254 -4.38957,-14.97617 0,-3.4319 6.0249,-8.34878 6.0249,-8.34878 z#000000m 156.97065,110.82851 c 8.65658,0 20.67766,5.08911 20.67766,16.78975 0,15.33809 -12.60506,24.23485 -21.52895,42.80853 -7.36801,15.33537 -12.89902,32.61104 -12.89902,49.74005 0,33.63945 8.23568,65.12984 16.45638,98.02644 5.91996,23.68975 10.12224,43.99383 18.14373,72.04772 0.68607,2.39944 3.87314,11.79158 3.87314,11.79158 l -2.15175,3.27065 c 0,0 -2.0746,-8.0815 -4.5617,-15.06223 -7.44753,-20.90356 -12.77937,-49.25654 -18.21055,-70.95563 -8.43911,-33.71657 -16.30349,-66.01529 -16.30349,-100.49565 0,-18.78214 5.77733,-38.4196 12.64807,-49.83623 9.27198,-15.4066 22.43892,-33.05931 22.43892,-41.03271 0,-7.84344 -10.37384,-14.65277 -18.21728,-14.65277 -13.82406,0 -28.70684,34.2996 -33.63582,60.23358 -2.96922,15.62256 -1.51073,28.33236 -3.37425,28.33236 -1.88463,0 -6.01878,-10.5924 -13.70697,-20.41117 -10.808656,-13.80397 -26.50237,-28.21833 -34.147901,-28.21833 -2.395694,0 -8.606992,12.48112 -8.606992,19.62394 0,8.1786 4.870582,7.89565 11.189089,12.73835 15.196452,11.64703 35.820634,35.72632 38.731464,44.41207 15.01519,44.80452 22.37051,111.06298 50.04551,170.22387 2.79816,5.98163 3.09093,9.87194 4.40662,9.40276 4.10047,-1.46225 11.61115,-1.9828 11.61115,-1.9828 l -0.79209,2.92855 c 0,0 -11.23008,3.74551 -14.12802,2.38587 -1.92184,-0.90168 -0.43804,-5.7025 -3.02712,-10.97517 -15.9584,-32.49931 -29.01209,-79.67101 -36.80362,-117.7329 -6.11416,-29.86787 -9.5759,-36.33093 -14.63107,-53.22495 -2.30271,-7.6955 -21.526955,-31.68977 -36.602028,-42.93248 -5.283146,-3.94007 -12.640953,-5.43559 -12.640953,-15.26866 0,-8.36137 6.333661,-22.58162 10.921671,-22.58162 7.777044,0 27.347107,14.53391 36.69931,28.21354 5.42501,7.93525 9.61266,15.57192 9.93912,15.57192 0.32646,0 -0.40762,-10.08087 2.057,-21.69525 5.25342,-24.7564 20.39861,-61.48298 36.13074,-61.48298 z#000000m 177.3901,411.93061 c 0,-7.33191 3.68905,-15.39503 9.89804,-15.49258 1.98952,-0.0313 5.93882,0.60249 5.93882,0.60249 l 0.94677,3.01245 c 0,0 -4.9212,-0.77463 -7.40201,-0.77463 -3.13916,0 -6.36918,5.29918 -6.36918,12.39406 0,5.58091 2.56211,11.01695 5.07813,11.01695 3.41181,0 -0.13347,-9.96061 3.44279,-9.7259 2.66396,0.17483 0.89486,5.60549 1.63533,8.34878 0.95054,3.52157 3.2769,5.90082 4.04529,12.22193 0.25358,2.08608 -0.60249,5.85276 -0.60249,5.85276 l -3.95922,2.75423 c 0,0 -1.41666,-1.43564 1.09646,-2.88659 0.88691,-0.51206 1.03464,-3.9322 0.964,-5.52827 -0.12627,-2.85321 -2.3763,-10.28752 -3.53409,-10.28752 -1.40229,0 -1.21575,2.09089 -3.43235,2.09089 -4.35615,0 -7.74629,-7.69387 -7.74629,-13.59905 z#000000m 221.30562,445.05505 c 22.92826,-16.76309 46.24633,-33.0145 69.63218,-53.41572 1.19842,-0.80536 1.11432,-1.33 0.77871,-2.49147 -1.8367,-6.03689 -5.60053,-13.03734 -9.40221,-20.05672 -0.76082,-1.77284 -1.12393,-1.88943 -2.75308,-1.39997 -28.73356,8.59439 -73.20649,18.7757 -86.31977,25.55523 -0.66624,0.26024 -0.8572,0.74362 -0.45046,1.60277 8.47649,17.88549 17.35796,35.36554 26.33071,49.77353 0.74287,1.49646 1.04381,1.26638 2.18392,0.43235 z m 16.10114,-68.49451 c 8.06997,-2.30699 29.93795,-8.63547 42.36507,-12.53403 1.97258,-0.91595 2.29603,-0.19009 3.2265,1.37333 4.93685,8.346 8.90828,16.37019 11.82532,24.04292 0.81101,1.63884 0.64777,2.08506 -0.57039,3.13816 -21.5295,18.56984 -46.79294,36.91613 -71.77744,55.27912 -0.52818,0.3882 -1.70176,1.37889 -2.77318,1.21709 -1.07143,-0.16179 -2.03138,-1.34058 -2.25756,-1.74155 -14.13892,-25.06442 -19.81454,-37.68038 -27.70129,-53.48098 -0.22439,-0.44954 -0.23539,-1.33202 -0.003,-2.00773 0.23214,-0.67571 0.90296,-1.31228 1.43393,-1.51277 15.77351,-5.95615 22.05873,-6.86297 46.23229,-13.77356 z#000000m 199.25767,389.2731 3.04303,-1.09549 c 9.95284,17.24177 19.54344,34.20423 28.84794,51.12292 l -2.19098,1.82582 c -9.04577,-16.77188 -19.03223,-34.10817 -29.69999,-51.85325 z#000000m 273.02075,368.45877 2.55614,-0.97377 c 3.95594,10.62501 7.54672,20.72127 11.50266,28.78707 l -1.82582,2.13012 c -4.01098,-8.64762 -8.06074,-18.07062 -12.23298,-29.94342 z#000000m 283.25609,368.12103 c 8.56571,-2.6387 16.47429,-5.56945 22.98067,-9.12341 l 4.3035,0.94676 c -6.12149,3.70101 -15.31864,7.40201 -26.25133,11.10302 z#000000m 292.29343,386.28178 c 5.82083,-3.31186 11.68231,-6.82698 17.73041,-11.27516 l 0.17214,3.35673 c -5.31773,3.83366 -11.10221,7.30908 -16.69757,10.15625 z#000000m 223.99569,212.88476 c 2.44838,-1.79166 8.70933,19.39485 40.31025,30.77305 l 0.61726,3.53499 c -32.75735,-12.12348 -43.3759,-32.51638 -40.92751,-34.30804 z#000000m 335.5437,244.03878 c -1.54327,-2.01708 6.22883,-3.82083 19.63888,-14.46395 17.3319,-13.75577 21.14919,-19.59885 22.76187,-17.89303 1.61268,1.70582 -4.65072,6.71639 -20.98647,20.22662 -14.26057,11.79398 -19.87101,14.14744 -21.41428,12.13036 z#000000m 249.93839,294.34539 c -1.08843,-13.81741 -3.39074,-33.66454 0.74762,-34.40202 4.08713,-0.72834 3.95335,12.49575 4.74862,28.0415 0.44725,8.74294 0.58322,17.65725 -1.01196,18.25189 -2.84295,1.05978 -4.0511,-6.39217 -4.48428,-11.89137 z#000000m 344.59284,252.58014 c 3.62536,-0.15165 3.87607,20.20414 3.89508,30.43031 0.0122,6.58257 -0.003,19.31888 -2.43443,19.59712 -3.44964,0.3948 -4.96536,-26.99989 -4.74713,-38.22047 0.0794,-4.0845 0.17705,-11.67689 3.28648,-11.80696 z#000000m 72.556939,157.85222 c 0,0 4.133465,0.19322 4.131356,6.8856 -0.0012,3.75088 -4.19954,12.82441 -6.713454,12.82441 -2.427261,0 -3.873146,-3.44279 -3.873146,-3.44279 0,0 0.529439,4.5617 3.959216,4.5617 2.605358,0 7.574153,-7.87294 7.574153,-14.20153 0,-8.03334 -5.078125,-6.62739 -5.078125,-6.62739 z#000000m 154.28167,117.1044 c 0,0 -3.16475,0.87752 -3.16475,3.95594 0,4.54214 10.56257,11.08555 13.69364,10.83319 6.06022,-0.48844 5.84262,-6.39036 5.84262,-6.39036 0,0 1.46619,7.54672 -6.14692,7.54672 -3.86668,0 -14.405,-6.47409 -14.48483,-12.11127 -0.0555,-3.91575 4.26024,-3.83422 4.26024,-3.83422 z#000000m 206.83841,181.53767 c -0.55762,3.3853 -1.13144,6.68726 -1.87662,9.86612 -11.62549,49.59324 -17.74277,83.92057 3.47477,143.5815 1.63208,4.57631 1.34631,4.36292 1.86668,0.0572 8.20046,-67.80527 23.10991,-126.32341 40.15006,-167.08876 2.1378,-5.11428 3.06825,-3.64589 3.33805,0.41178 3.52836,53.06509 10.08558,105.62102 57.43218,150.99979 1.66327,1.36913 1.55393,0.56499 1.6168,-0.80847 -4.29057,-49.68136 -1.45931,-98.85411 2.21538,-147.96644 0.34474,-4.60751 0.3183,-6.61391 1.07675,-6.97744 0.47421,-0.22729 1.1255,-0.42398 2.7666,1.67499 14.92912,19.09443 28.39621,46.21862 40.28098,74.71218 13.65128,32.72874 25.09124,67.15274 31.78859,92.79428 l 5.55487,-0.8877 c 2.30722,-12.21832 6.6699,-28.2312 6.6699,-37.44042 0,-46.25986 10.20351,-88.72236 -19.4832,-131.6081 -1.32743,-1.91762 -1.88853,-4.1705 -2.35358,-6.43102 -0.40798,-1.72104 -0.24844,-2.47305 0.0625,-2.53716 0.54773,-0.11291 0.70573,0.65634 1.65951,2.15099 27.58001,43.24245 27.16452,60.29308 23.00328,138.75357 -0.62975,11.87402 -3.35545,24.58775 -6.37325,37.86562 l -12.13586,1.29105 C 376.0696,286.06075 352.97625,221.9036 321.249,173.21897 c -1.53034,-2.51656 -2.07113,-2.41823 -2.45849,-2.43498 -0.53981,-0.0233 -0.58101,0.81914 -0.80743,3.71091 -3.51167,44.87584 -5.85773,91.69438 -2.46498,148.07758 0.42155,2.9416 -0.67752,3.00703 -2.58358,1.61488 -39.00648,-29.36009 -61.66245,-93.97244 -61.29921,-146.70942 0.0932,-5.04388 0.25069,-4.88949 -1.31821,-0.54853 -18.90316,52.32828 -29.72011,109.2985 -38.23456,165.11326 -0.55582,5.55752 -0.96017,6.09042 -3.4041,0.95416 -28.47729,-62.02075 -17.5003,-116.54305 -2.97072,-163.54086 2.4702,-8.06614 2.76034,-7.83153 1.13066,2.0817 z#000000m 196.21464,295.06086 -1.94754,-5.84262 c -5.26961,12.00005 -9.80287,24.42087 -14.28363,36.87169 0,0 -0.68006,2.6445 -1.37538,2.54257 -0.69531,-0.10193 -0.73501,-1.51861 -1.04676,-2.82489 -7.67983,-32.17914 -1.74447,-59.21869 0.45811,-74.54092 0.31701,-2.2053 0.81436,-4.47309 0.15092,-4.74919 -0.66344,-0.27611 -2.11038,2.03085 -3.42262,3.60866 -8.48495,10.20215 -16.86838,20.6581 -23.8134,34.71011 -2.75754,-34.01406 14.14817,-63.9577 29.30139,-90.83717 1.07749,-1.91129 2.0947,-3.3903 1.56285,-3.96637 -0.53185,-0.57607 -1.95183,0.56538 -3.71353,1.67274 -10.74858,6.75627 -20.96688,12.89053 -35.42775,23.38453 l 1.46065,-13.7545 c 6.74826,-16.25273 28.23339,-33.04462 61.59095,-50.27087 l 3.43446,-1.22659 c 0,0 2.04168,-0.83434 2.19388,-1.50844 0.1522,-0.6741 -0.0556,-1.6479 -1.0555,-2.22496 -11.73883,-6.77463 -23.48722,-14.42682 -30.95212,-25.26941 -0.97985,-1.4232 -2.53488,-2.88836 -1.79919,-3.6091 0.73569,-0.72074 1.89644,0.92996 3.28064,1.75512 21.53222,12.83591 39.64489,15.21867 48.8665,15.24479 0.34729,9.8e-4 0.68917,-0.0721 0.7898,0.19308 0.10398,0.27396 -0.0365,0.89007 0.13294,1.12647 0.19996,0.27894 0.83467,0.32118 1.14294,0.22971 25.58212,-7.59111 48.88731,-11.54314 72.25569,-12.69532 l -0.34428,-2.75424 c -19.41767,0.73051 -41.96076,1.92651 -70.23305,12.91049 -0.68646,0.2667 -0.11878,-0.58647 -0.42835,-1.03028 -0.35953,-0.51542 -1.58388,-0.65914 -2.32589,-0.69112 -19.58094,-0.84397 -39.54973,-8.83242 -55.36771,-19.40231 -1.80202,-1.20415 -2.98842,-2.41164 -3.77709,-1.94124 -0.78866,0.4704 -0.18828,2.17262 0.68821,4.23996 3.97976,9.38687 11.9573,20.13945 33.39907,32.41141 0.70626,0.40421 0.89018,0.61107 0.8934,0.74422 0.003,0.13314 -0.0737,0.2943 -0.99366,0.4492 -10.85517,1.82774 -43.63068,25.48341 -58.33003,40.47704 l -4.13136,14.28761 -0.89024,16.89058 c 11.69268,-8.10748 20.27882,-14.23962 29.0903,-19.73733 1.20131,-0.74953 2.25725,-1.8424 2.80727,-1.31288 0.55001,0.52953 -0.36056,1.16778 -1.4107,2.87156 -6.71505,10.89473 -24.49878,39.45812 -24.60458,75.3082 l 3.27066,15.49258 c 5.59093,-13.29105 12.8929,-22.51523 19.78182,-31.85638 1.04969,-1.42335 2.15152,-3.55629 2.68243,-3.17407 0.53091,0.38221 -0.18615,2.31975 -0.48545,4.13645 -3.38887,20.56955 -5.71761,49.02927 3.05694,70.72303 0.55994,1.38437 1.14537,3.39693 2.20538,3.37807 1.06002,-0.0189 1.45188,-1.87586 2.12232,-3.498 5.12328,-12.39585 9.82394,-25.37302 15.54029,-36.94167 z#000000m 174.5625,158.4375 c -9.52407,-0.0682 -14.23155,9.03951 -17.46875,22.5 l 3.59375,-2.65625 c 2.9046,-10.50801 7.13459,-17.04175 15.1875,-16.75 2.17976,0.079 6.46875,1.09375 6.46875,1.09375 l 4.25,-2.6875 c -2.93853,-0.80821 -5.22297,-0.65099 -9.71875,-1.3125 -0.79289,-0.11667 -1.5781,-0.18224 -2.3125,-0.1875 z#000000m 201.23146,142.87606 c -10.4521,0.4076 -8.11711,-0.27116 -12.56621,14.54581 l -3.52886,2.84031 c 5.45094,-20.10126 5.08028,-20.68404 13.77118,-19.62394 z#000000m 215.32488,312.58872 c 4.01949,17.21093 6.72949,36.63324 14.99368,52.72691 1.00237,1.95203 1.68133,3.4007 2.50375,3.08227 0.82242,-0.31842 0.5746,-1.74035 0.48966,-3.63951 -0.37556,-8.39707 -0.61608,-13.65583 -0.33751,-22.46969 l 2.79959,1.33894 c 0.18688,7.67134 -0.15201,17.44248 0.11225,25.92976 0.0998,3.20457 -0.37149,4.18459 -1.20775,4.50054 -0.83625,0.31596 -2.45959,-0.0118 -4.32214,-2.93166 -9.71228,-15.22566 -14.459,-41.7398 -16.0053,-51.11257 z#000000m 225.34375,260.78125 -2.4375,7.0625 c 0,0 2.78125,27.08184 2.78125,48.8125 0,17.99661 -0.87282,22.15173 9.28125,29 0.43866,0.29585 0.94257,0.60904 1.4375,0.90625 l 0.0937,-3.125 c -0.12494,-0.0701 -0.25359,-0.14865 -0.375,-0.21875 -9.54454,-5.51054 -6.46106,-11.31452 -7.28125,-27 -1.13139,-21.63678 -3.5,-55.4375 -3.5,-55.4375 z m 146.56906,65.70195 c -0.12425,1.45943 -0.43519,5.15968 -1.81906,6.92305 l 3.1875,1 c 0.33806,-0.52515 0.59375,-0.96875 0.59375,-0.96875 2.03407,-15.13437 1.9791,-29.01533 2.50432,-43.24439 l -2.66542,-7.56086 c 0,0 -0.56645,29.34887 -1.80109,43.85095 z M 348.8125,353.5 l -9.125,0.15625 c -7.67299,2.49629 -16.88255,4.15625 -27.84375,4.15625 -12.44914,0 -24.81462,-1.13264 -36.03125,-2.9375 l -14.78125,0.4375 c 13.1811,2.9707 30.31289,5.0625 51.09375,5.0625 15.559,0 27.5729,-2.94471 36.6875,-6.875 z#000000m 274.37489,329.17323 c 0.32235,0.14256 0.40567,0.39236 0.53068,0.99568 0.65915,3.18125 1.26783,9.62883 8.23281,9.62883 3.70201,0 7.10418,-4.94015 10.03156,-4.94015 2.74751,0 4.28911,5.02622 13.93275,5.02622 7.65622,0 10.7677,-4.71828 13.17625,-8.80835 0.67297,-1.14279 1.29872,-1.71773 1.59379,-1.61537 1.07361,0.37242 1.29071,1.74297 0.70492,3.0012 -2.75652,5.92074 -7.34358,9.94048 -15.80447,9.94048 -9.86891,0 -11.81474,-4.25159 -13.66843,-4.25159 -1.78964,0 -6.29696,4.74713 -9.98114,4.74713 -10.30018,0 -10.82804,-9.23667 -9.60946,-12.77325 0.26678,-0.77426 0.53839,-1.09338 0.86074,-0.95083 z#000000m 253.3019,492.12755 2.19099,2.19098 c -32.59003,27.22711 -65.54689,75.39477 -65.54689,77.96246 1e-5,2.67704 9.81672,3.04736 15.93504,3.04736 14.56582,0 16.50197,-1.29475 25.3311,-13.35737 4.62675,-6.32122 10.01003,-12.74794 15.45777,-19.27648 10.13827,-12.14964 20.71182,-24.22788 28.54182,-33.6477 l 2.06926,1.46066 c -7.99137,9.55323 -18.64267,21.93678 -28.78451,34.35699 -5.23006,6.40499 -10.76689,12.44065 -14.80563,18.89833 -9.6377,15.41007 -17.64989,14.40945 -28.05771,14.40945 -7.20728,0 -18.8519,-0.66098 -18.8519,-5.83039 0,-4.20001 19.8118,-29.73004 30.8444,-43.45238 9.93086,-12.352 18.81217,-21.03832 35.67626,-36.76191 z#000000m 243.00058,504.19323 c 7.03354,8.41444 17.16608,9.85614 26.65647,12.74268 l -1.7214,2.40996 c -8.98747,-3.02714 -18.14715,-3.75808 -26.68168,-12.82442 z#000000m 416.28665,467.53986 c 0,0 9.25081,3.92497 9.25081,18.13646 0,20.25713 -18.86679,51.13311 -18.86679,57.57415 0,7.96006 4.62541,10.17706 4.62541,20.81433 0,4.63567 -5.15041,10.34631 -19.59712,10.34631 -8.12387,0 -20.5709,-3.19442 -20.5709,-13.51106 0,-19.19642 17.13795,-45.88375 19.59713,-57.81759 l 3.28647,-2.79959 c 0.57798,13.56246 -20.08401,39.5991 -20.08401,60.1303 0,9.38345 13.46684,11.68524 18.25819,11.68524 7.59642,0 16.0672,-3.64083 16.0672,-7.79016 0,-8.73591 -4.13852,-12.81591 -4.13852,-21.05778 0,-10.02895 18.62335,-36.41339 18.62335,-57.45243 0,-12.20369 -7.91188,-15.33687 -7.91188,-15.33687 z#000000m 408.92251,483.8505 c 5.29105,-1.01969 9.47253,-3.5928 13.1459,-6.87725 l 1.39979,3.34734 c -6.66033,4.37135 -11.85711,6.12924 -16.24979,6.45122 z#000000m 395.43666,461.64682 c -2.34308,0 -5.00609,-4.00871 -6.2852,-3.14745 -1.1364,0.76517 0.86428,4.03705 0.86428,7.07818 0,2.49628 -9.11773,7.50567 -16.56997,13.1261 -6.06389,4.57335 -15.94347,14.03251 -20.08901,14.03251 -3.64102,0 -11.44703,-6.35837 -16.02402,-10.75523 -8.17382,-7.85215 -10.62371,-14.355 -12.144,-14.355 -1.7452,0 -7.39486,5.53003 -14.44969,9.42373 -6.78107,3.74261 -14.62665,7.57487 -16.7466,7.70943 -3.00201,0.19054 -8.73045,-7.55741 -15.26022,-14.69449 -6.59756,-7.21119 -12.77132,-11.92133 -12.77132,-16.0358 0,-2.13932 5.33773,-3.74931 11.93838,-8.98264 8.08967,-6.41389 19.2132,-14.428 19.95259,-17.18743 0.65521,-2.44529 -1.96637,-5.27359 -0.85205,-7.54671 0.48088,-0.98095 2.20014,-0.79077 2.79959,-1.7041 3.11177,-4.74117 5.49193,-15.94257 6.78125,-23.29122 3.28305,-18.71224 1.49579,-36.47391 1.49579,-36.47391 l 2.67787,0.24344 c 0,0 2.03081,17.72313 -1.47846,36.70232 -1.43142,7.74157 -3.68313,20.05531 -7.52891,24.64519 -0.41201,0.49173 -1.48438,0.0655 -1.82582,0.6086 -1.19727,1.90448 1.66593,4.5975 0.85205,6.69467 -1.60539,4.13671 -3.59063,5.96753 -8.03041,9.78138 -3.67694,3.15855 -9.61093,8.44192 -13.25457,10.65182 -5.57082,3.37874 -10.1191,4.44037 -10.1191,6.22375 0,2.24946 6.26658,7.88387 11.55209,13.90118 5.83778,6.64607 10.83836,13.60783 12.91388,13.60783 2.87126,0 8.65993,-3.36779 14.82404,-6.99333 7.6389,-4.49296 14.89636,-10.53454 17.18864,-10.53454 2.36648,0 6.59244,9.40259 13.37025,15.57456 6.23747,5.67994 10.87813,9.81477 14.26659,9.81477 2.43878,0 9.19684,-7.00762 17.11727,-12.24913 5.63247,-3.7274 16.70673,-10.60962 16.5221,-12.50459 -0.48425,-4.96987 -3.70299,-11.75918 -0.50345,-12.61649 2.71613,-0.72779 4.37245,5.80875 7.99362,5.80875 1.18239,0 6.33952,-9.71894 6.33952,-12.22871 0,-2.60891 -21.79199,-13.49454 -21.79199,-18.66327 0,-6.12202 1.94754,-6.41527 1.94754,-9.31168 0,-1.36529 -4.94425,-0.026 -5.23402,-3.65163 -0.27854,-3.48506 -0.38027,-10.20923 -0.49324,-15.08765 -0.23863,-10.30468 -0.11536,-19.11602 -0.11536,-19.11602 l 1.21721,-14.24139 2.06926,-2.55614 c 0,0 -0.53564,47.6682 0.73033,50.27087 0.97465,2.00377 4.99057,-0.52414 4.99057,3.40819 0,5.2266 -2.13012,4.82096 -2.13012,9.49427 0,4.23753 22.64015,15.15835 22.64015,18.86678 0,2.6438 -7.46836,16.26023 -9.34733,16.26023 z#000000m 386.76924,457.98474 c 15.81572,17.23035 20.18336,27.75245 22.82274,27.75245 2.40946,0 10.58975,-21.38961 10.58975,-29.15224 0,-6.73096 -16.55409,-11.56352 -16.55409,-11.56352 l -1.09549,3.28647 c 0,0 15.32211,2.59339 15.32211,8.61268 0,3.39833 -6.67324,24.00862 -8.62745,24.00862 -1.94438,0 -4.86162,-6.90788 -20.084,-24.52683 z#000000m 374.57627,475.88056 2.15175,-0.8607 c 2.49478,4.77176 9.14483,27.62844 11.87765,27.62844 1.25338,0 14.59718,-11.89315 18.33289,-20.57071 l 3.09852,2.23782 c -5.43655,7.9806 -18.53249,22.72246 -22.20604,22.72246 -2.77576,0 -10.31268,-20.17816 -13.25477,-31.15731 z#000000m 356.7598,489.90996 c 0.34657,14.52929 0.32652,26.50953 2.84031,26.50953 5.67248,0 17.24265,-5.20727 27.71451,-11.70551 l 1.29105,1.63533 c -7.84202,6.53879 -25.29893,12.91049 -29.43591,12.91049 -4.40149,0 -4.14006,-7.87148 -4.73385,-27.71451 z#000000m 333.60699,476.39698 2.40996,3.09852 c -0.89076,14.23072 -5.09809,42.54169 -2.66817,42.69068 2.81889,0.17284 15.55655,-2.6595 24.09958,-5.1642 l 1.89354,1.89354 c -9.7276,3.359 -19.52336,5.74272 -27.54238,5.59454 -4.63846,-0.0857 1.18375,-32.03505 1.80747,-48.11308 z#000000m 310.87605,475.8169 c -1.83066,6.8258 -4.79068,16.72841 -7.08528,24.61912 -2.3308,8.01524 -3.71954,13.80982 -3.15407,15.92017 0.77141,2.87893 6.85145,1.21757 15.03685,3.61525 4.41194,1.29234 11.26186,1.508 15.89511,1.97781 l 0.32952,1.87624 c -3.3601,-0.46868 -10.60298,0.79963 -17.07868,-1.58311 -6.97743,-2.56736 -14.00915,-0.10939 -15.87213,-3.33616 -1.55579,-2.69471 -0.0705,-10.0921 2.44293,-19.39624 1.97195,-7.29978 4.60983,-16.13727 6.68616,-22.35414 z#000000m 288.47934,479.46854 1.82582,1.94754 c -4.97799,9.4234 -14.87087,21.84428 -14.87087,24.3799 0,3.34758 13.36518,9.5897 23.51308,9.94549 l 0.85205,3.04303 c -10.30463,-0.25821 -27.40816,-8.36791 -27.40816,-11.89303 0,-5.12364 9.58371,-16.20795 16.08808,-27.42293 z#000000m 275.5098,464.6054 c -8.73865,9.31072 -23.84137,24.56481 -23.84137,26.68168 0,4.2216 16.32964,14.81612 22.46425,17.55826 l -0.0861,-2.92638 c -6.2113,-2.66339 -19.27966,-12.09541 -19.27966,-14.37367 0,-1.96621 14.48042,-15.38985 22.29211,-24.78814 z#000000m 267.84958,453.41631 c -5.46019,-0.68666 -27.88666,11.70691 -27.88666,16.00901 0,1.47385 7.03221,10.49689 14.63189,19.96822 l 1.63533,-1.97961 c -5.26976,-6.98611 -12.82442,-15.51329 -12.82442,-18.07468 0,-2.25422 18.37097,-13.07324 24.01351,-13.51298 z#000000m 249.08634,463.05614 c 4.05476,6.32627 8.2092,12.50302 13.16869,17.4722 l -2.23782,2.66816 c -5.03287,-6.11096 -9.27964,-12.22193 -13.16869,-18.33289 z#000000m 259.93114,483.71292 c 5.66754,5.07559 11.80693,9.20747 18.16076,12.91049 l -1.11891,2.32389 c -7.25838,-3.88144 -13.75255,-8.16205 -19.02145,-13.08263 z#000000m 278.78046,497.82839 c 6.34256,4.32241 14.22041,6.72571 22.37817,8.77913 l -1.1189,2.92638 c -7.86915,-2.79432 -16.31443,-4.86848 -22.46425,-9.81197 z#000000m 301.50291,506.60752 c 10.17086,3.9213 20.18229,4.81319 30.12447,4.38957 l -0.34428,3.35672 c -9.02847,-0.74075 -16.87813,-0.24654 -30.46875,-5.76668 z#000000m 332.22987,511.42744 c 7.91843,-0.52074 15.83687,-2.16096 23.7553,-4.04529 l 0.51642,2.92638 c -8.3883,1.55305 -16.71431,2.91922 -24.87421,3.78707 z#000000m 356.32945,507.21001 c 11.48527,-2.07751 19.04528,-6.45127 26.07918,-11.36123 l 1.7214,3.09852 c -7.85107,4.82714 -16.25257,9.14316 -27.28416,11.01695 z#000000m 383.69968,495.76271 c 8.14024,-5.69978 13.40544,-13.19646 17.90255,-21.1732 l 2.06567,2.5821 c -3.73941,7.74308 -10.29315,14.95009 -18.84931,21.77569 z#000000m 402.54899,474.50344 c 4.88229,-8.95376 9.84974,-17.95011 9.81198,-24.44385 l 2.75423,1.11891 c -1.24312,9.11387 -6.01102,17.34655 -10.84481,25.56276 z#000000m 306.92532,424.66896 c 8.20172,5.33995 20.21973,7.89823 31.60422,10.05541 -9.10736,0.36189 -29.24628,-4.98873 -31.60422,-10.05541 z#000000m 385.61289,354.09566 4.16194,0.20272 c -5.70226,6.04504 -11.83037,9.86498 -11.83037,11.96941 0,5.25206 -1.31838,28.23932 -13.26762,28.23932 -9.53857,0 -13.71275,-18.24618 -12.90245,-41.99382 l 2.79959,0.85204 c -0.51522,23.24137 4.11444,38.25951 10.10286,38.22047 9.35915,-0.061 10.08198,-20.04026 10.08198,-25.4102 0,-4.21862 5.75756,-5.17792 10.85407,-12.07994 z#000000m 501.9375,304.71875 c -3.05781,0.12604 -6.50239,0.79133 -10.34375,3.375 -10.57046,7.10961 -23.88725,18.8125 -28.03125,18.8125 -13.61104,0 -52.62424,4.1046 -79,4.96875 -17.5059,0.57353 -34.0581,-0.16453 -51.46875,-0.0312 -3.87007,0.0296 -7.78008,0.0632 -11.6875,0.125 l -0.6875,2.15625 c 4.24337,-0.0873 8.49287,-0.15898 12.71875,-0.1875 16.62106,-0.11217 32.89072,1.16992 49.5,0.5625 27.38661,-1.00156 65.81102,-4.84375 80.65625,-4.84375 7.92199,0 27.83509,-22.34375 39.3125,-22.34375 6.31336,0 11.71875,6.8724 11.71875,14.28125 0,9.74198 -28.72611,19.58365 -46,20.6875 21.84959,7.56508 43.09162,17.00065 59.875,25.5625 16.14148,8.23439 28.25,15.58879 28.25,22.875 0,8.26997 -8.95374,22.40625 -19,22.40625 -10.1627,0 -20.67914,-12.90357 -34.46875,-25.03125 -15.60494,-13.72424 -36.21314,-30.05522 -50.46875,-33.875 -3.81308,-1.02171 -27.32501,-1.34571 -52.21875,-1.71875 -16.78702,-0.25155 -33.86702,-0.78923 -47.21875,-0.5625 -28.54836,0.48477 -58.07714,2.03125 -81.09375,2.03125 -7.85551,0 -35.03125,2.73369 -35.03125,-7.75 0.3672,-8.68555 9.85842,-10.75 22.75,-10.75 4.8326,0 9.6764,-0.0689 14.53125,-0.15625 l -0.59375,-2.46875 c -4.57092,0.055 -9.12432,0.125 -13.65625,0.125 -7.6447,0 -25.46875,-1.09178 -25.46875,13.40625 0,12.11891 13.79243,9.96875 37.375,9.96875 21.26912,0 48.92668,-1.26109 75.8125,-1.46875 48.7184,-0.3763 95.70662,0.45364 103.34375,2.5 17.74073,4.75362 35.0506,20.04945 50.5625,34.03125 13.99231,12.6121 24.62924,25 36.03125,25 9.9157,0 21.8125,-15.2755 21.8125,-27.21875 0,-15.66649 -58.03462,-36.16161 -77.40625,-46.46875 10.9255,-2.60648 34.96875,-8.35896 34.96875,-20.65625 0,-10.73215 -6.28291,-17.34375 -14.09375,-17.34375 -0.42168,0 -0.84442,-0.018 -1.28125,0 z#000000m 541.17264,409.72227 c -3.91602,-1.17614 -5.11229,-1.13155 -5.11229,-4.86885 0,-5.67922 7.0103,-16.91925 14.11966,-16.91925 1.98945,0 1.76361,1.56905 1.52152,3.71249 2.26925,-2.09021 0.66324,-4.99057 -1.52151,-4.99057 -8.5754,0 -15.58033,12.29569 -15.58033,18.92766 0,3.75229 1.24986,5.04116 6.57295,4.13852 z#000000m 364.29091,395.6634 c 0,0 1.49582,7.15552 1.49582,9.54983 0,3.38733 -1.88313,9.59628 -1.88313,12.82835 0,3.51628 4.1987,8.03431 8.79976,15.48157 1.66791,2.69966 5.59294,8.46603 6.34855,11.45831 -3.20494,-5.00454 -4.86974,-7.62579 -6.727,-10.24882 -6.02894,-8.51474 -9.10987,-12.37188 -9.10987,-16.51892 0,-4.9997 1.70053,-8.03659 1.70053,-12.69599 0,-3.36296 -0.62466,-9.85433 -0.62466,-9.85433 z#000000m 357.23318,422.21597 c 4.02135,-1.98682 7.88398,-4.21173 11.4473,-6.88559 -4.10703,1.65441 -7.91404,3.96888 -11.4473,6.88559 z#000000m 321.64327,359.3419 c 0.48795,1.82107 2.68424,7.18683 4.47564,7.18683 1.53816,0 4.09259,-5.95169 5.33633,-8.9943 l 4.64778,-0.94677 c -2.21722,2.677 -6.67042,8.32336 -6.67042,10.28536 0,0.89002 3.5043,2.45423 5.25657,3.73022 2.54006,1.84966 4.34758,3.88696 5.33003,3.88696 0.98164,0 2.2534,-4.31602 4.13334,-9.58706 1.31767,-3.69454 3.24063,-8.01152 4.25848,-10.98365 l 3.52886,0.17214 c -1.47289,3.54324 -3.62271,7.76813 -5.24469,11.84516 -2.48763,6.25293 -4.43199,11.86711 -6.24564,11.86711 -2.0822,0 -4.36915,-2.51591 -7.01376,-4.83315 -2.58543,-2.26539 -5.3596,-3.85992 -7.14474,-3.85992 -1.21208,0 -3.7344,1.90914 -5.87485,4.28793 -2.05946,2.28877 -3.73344,5.05066 -5.1421,5.05066 -2.18229,0 -2.58,-8.90647 -2.92638,-19.4518 l 2.92638,0.086 c -0.0196,4.69846 -0.36226,14.15849 1.11891,14.15849 1.07961,0 2.65136,-1.96047 3.61424,-2.92336 1.35205,-1.35204 2.62583,-2.44071 2.62583,-3.35973 0,-1.23985 -3.43413,-4.84577 -4.00225,-8.13361 z#000000m 322.62748,370.41358 c 0,0 -1.27893,5.47389 -0.19481,6.67349 0.71687,0.79323 8.40016,0.93177 8.9365,0.15734 0.66776,-0.96419 1.7214,-5.59455 1.7214,-5.59455 l 3.09852,2.32389 c 0,0 -2.37238,4.01136 -3.55229,5.41017 -0.83978,0.99558 -11.09275,1.32169 -11.90032,0.23911 -1.46067,-1.95806 -1.33102,-6.59605 -1.33102,-6.59605 z#000000m 321.95268,379.17024 c -2.15913,9.07663 -10.94565,20.82022 -11.07663,24.34425 -0.0535,1.43972 3.84563,8.31009 7.00952,13.4994 1.77715,2.91482 2.96884,5.71167 3.96016,5.71167 1.34498,0 4.26183,-3.54904 7.72709,-6.82886 3.33321,-3.15482 6.98641,-6.31475 6.98641,-9.94779 0,-7.28864 -6.28639,-19.52688 -6.57294,-26.77867 l 2.3127,-0.73033 c 0.9004,7.79336 6.81639,22.13484 6.81639,27.38728 0,5.2109 -4.39329,8.57395 -8.19883,12.36483 -4.16933,4.15327 -7.87859,7.8763 -9.69419,7.59745 -2.06523,-0.31719 -3.12014,-3.49845 -5.57253,-7.28407 -3.7335,-5.76321 -8.18668,-12.85195 -7.69509,-14.99091 0.70832,-3.08195 9.44823,-18.15186 12.53729,-26.41351 z#000000m 467.0666,221.9616 c -0.77903,0.27169 -1.46375,0.84304 -2.11759,1.47176 -34.6979,33.36534 -44.2692,51.87533 -60.60526,71.97289 l 0,4.65625 c 17.60239,-20.94232 26.44104,-39.06574 61.08947,-73.34455 0.72946,-0.72168 1.34009,-1.65158 2.35213,-1.75635 1.01205,-0.10478 1.45525,0.73609 2.23733,1.3406 21.80627,16.85514 38.33746,44.56702 46.15003,68.52657 0.29902,0.91701 0.69398,1.61573 0.5573,2.43249 -0.13669,0.81675 -0.72725,1.29151 -1.2605,1.78134 -2.72674,2.50471 -5.78557,4.92052 -9.18826,7.30115 L 508.625,307.75 c 3.40565,-2.4744 6.52178,-4.98767 9.31608,-7.52979 0.66289,-0.60308 1.36443,-1.18359 1.63268,-2.1152 0.26824,-0.93162 -0.0247,-1.81814 -0.23291,-2.88422 -6.11373,-31.30601 -37.71273,-65.93071 -49.85755,-72.62806 -0.98438,-0.54285 -1.63766,-0.90282 -2.4167,-0.63113 z m -82.1916,94.38215 c -2.28395,2.16204 -4.70596,4.3899 -7.31585,6.69191 -0.79355,0.69993 -1.32615,1.16266 -1.61649,2.07756 -0.29033,0.91489 -0.0686,1.51619 0.32235,2.24816 1.12844,2.11282 2.34646,4.20019 3.64124,6.26362 l 4.1875,-0.6875 c -0.98197,-1.49323 -1.9951,-3.07401 -3.12004,-4.84133 -0.51709,-0.81236 -0.92454,-1.58377 -0.8123,-2.60795 0.11225,-1.02419 0.6533,-1.2715 1.36702,-1.92133 1.50781,-1.37281 2.95274,-2.72172 4.34657,-4.03564 z m 11.28125,37.4375 c 1.81311,1.74941 3.64828,3.37814 5.4912,4.86938 0.75197,0.60848 1.58195,1.0638 2.60308,1.1101 1.02113,0.0463 1.67938,-0.32783 2.74139,-0.82723 2.65751,-1.24967 5.51566,-2.55189 8.50808,-3.90225 l -5.71875,-0.375 c -0.74492,0.35727 -1.48286,0.70962 -2.22313,1.06339 -1.00723,0.48135 -1.67712,0.91656 -2.71384,0.82234 -1.03672,-0.0942 -1.5952,-0.61044 -2.17301,-1.19508 -0.4049,-0.40969 -0.80098,-0.81213 -1.20252,-1.2219 z#000000m 459.98457,231.1572 c 33.73254,18.64689 41.01287,55.04132 46.25407,75.34545 l -2.79959,-0.6086 c -7.30842,-26.05981 -15.27965,-54.99767 -45.40202,-73.39791 z#000000m 375.14487,333.88994 3.89508,-4.13853 -1.58238,-2.79959 -4.86885,4.74713 1.33893,2.31271 z#000000m 388.04732,354.70427 c 0,0 6.01666,6.84429 8.27704,6.93811 1.80665,0.075 6.20779,-4.38197 6.20779,-4.38197 l 2.79959,1.94754 c 0,0 -6.40548,5.59918 -9.1291,5.59918 -2.19478,0 -10.58975,-7.79016 -10.58975,-7.79016 z#000000m 479.40943,231.35593 c 0,0 -0.25085,-16.18114 10.50053,-16.18114 5.57059,0 11.98931,5.47632 12.56621,11.01695 0.17827,1.71214 -1.49884,3.88791 -3.22024,3.88791 -1.70564,0 -3.85848,-1.21162 -5.80611,-2.33608 -2.51514,-1.45212 -3.25244,-2.92899 -4.25795,-1.76394 -1.00552,1.16504 0.85937,2.32236 3.08658,3.9799 2.03554,1.5149 5.17355,2.9752 7.25046,2.9752 2.9253,0 5.35721,-3.93911 5.35721,-6.91513 0,-5.72163 -7.90239,-14.14501 -15.0057,-14.14501 -12.77567,0 -12.88095,18.62064 -12.88095,18.62064 z#000000m 495.52718,231.15721 c -0.49402,0.67385 -0.60861,1.22719 -0.60861,2.3127 0,3.72979 3.69524,6.98326 6.64898,8.65644 6.86789,3.8904 12.87102,9.84519 19.76453,9.84519 7.60137,0 15.82376,-17.19737 15.82376,-23.4922 0,-5.84691 -16.43963,-27.62455 -30.55203,-31.28236 -1.28853,-0.33398 -1.80329,0.31556 -2.67787,1.46066 l -2.37356,-2.13012 c 1.10243,-0.86887 2.73098,-1.82582 4.86885,-1.82582 9.84379,0 33.04731,22.09042 33.04731,33.77764 0,6.37402 -7.47405,26.04834 -18.19732,26.04834 -7.46103,0 -18.53724,-8.49031 -25.38401,-13.23411 -2.86653,-1.98608 -3.40307,-6.20853 -3.40307,-7.94538 0,-1.34457 0.44011,-2.51557 1.21722,-3.77336 z#000000m 503.89758,196.87217 c 0,0 3.91492,1.64217 3.91492,4.96178 0,6.35165 -8.0045,16.52542 -8.0045,16.52542 l -2.23782,-1.9796 c 0,0 6.84876,-6.72191 7.22987,-14.20154 0.0324,-0.6362 -0.90247,-5.30606 -0.90247,-5.30606 z#000000m 519.38454,253.43219 c -2.27354,7.09841 -9.65136,6.94336 -16.06721,8.15533 l 1.7311,2.40489 c 8.23646,-1.25602 15.52973,-3.29212 16.84184,-10.27501 z#000000m 484.96875,215.25 3.71875,-1.28125 c -6.90455,-7.10093 -14.22188,-14.6095 -22.71875,-23.125 -13.52559,-13.55524 -35.70202,-33.66951 -55.82105,-48.5732 -5.81406,-4.30692 -11.80057,-7.31799 -17.01257,-10.47058 -6.24648,-3.77833 -11.5307,-7.38435 -16.09636,-8.60771 -12.14844,-3.25517 -31.41762,-2.25815 -43.09292,-0.6685 -15.26367,2.07822 -21.69874,5.53556 -24.28701,5.53556 -3.31206,0 -4.99058,-5.02549 -4.99058,-14.11967 0,-3.98884 -1.53725,-8.9323 1.46066,-11.56352 7.38337,-6.480281 38.52463,-10.55366 58.30448,-12.537285 1.66103,-0.166576 3.42501,0.006 5.14658,0.153639 1.79347,0.153764 3.21068,-0.645223 3.48571,-1.193864 0.27503,-0.548638 -0.41122,-1.930704 -1.32461,-3.437316 -5.96764,-9.843532 -9.37694,-19.340353 -9.37694,-43.845795 0,-4.665275 0.66403,-11.881744 2.77259,-14.220501 2.45797,-2.726307 5.57753,-2.642216 9.24827,-2.642216 5.33562,0 14.37176,6.429958 14.37176,10.533213 0,21.799923 8.68648,55.007465 16.57027,60.732701 8.25342,5.993654 16.07313,11.852364 23.61047,18.737544 13.80312,12.60883 27.25467,27.22562 39.71875,41.1875 13.0445,14.61206 23.74922,31.67537 36.25,45.59375 0.2388,0.26588 0.47852,0.51853 0.71875,0.78125 l -0.84375,-4.40625 -0.5,-1.84375 0.28125,0.21875 c -11.79708,-13.62956 -20.94393,-28.24199 -34.5,-43.46875 -12.97394,-14.57288 -26.2676,-28.74464 -40.75,-41.65625 -7.15931,-6.38279 -14.63742,-12.366647 -22.28034,-17.644489 -6.08019,-4.198692 -15.71314,-37.367064 -15.71314,-58.558984 0,-6.603653 -9.1006,-13.236041 -16.62897,-13.276267 -4.72691,-0.02526 -8.67993,1.453788 -12.4451,4.311712 -2.30627,1.750552 -2.44308,11.712201 -2.44308,16.4079 0,12.422854 0.32808,27.521265 7.14416,40.228853 0.71223,1.327839 1.61893,2.864535 1.28035,3.426038 -0.33859,0.561504 -1.04628,0.670318 -2.38524,0.635184 -0.67443,-0.0177 -1.41703,-0.04008 -2.25979,-0.04008 -9.64506,0 -52.70292,6.397525 -59.27824,13.511063 -3.34605,3.61993 -2.67788,8.61196 -2.67788,14.60655 0,6.71052 3.47659,16.76281 6.32951,16.79753 1.64247,0.02 11.62392,-2.99997 27.39302,-4.96116 12.61418,-1.56881 30.29559,-2.5841 40.28718,0.0931 4.14207,1.10987 8.50333,4.50234 14.71456,8.35537 4.99438,3.09818 11.54991,6.25077 17.37482,10.60359 26.63498,19.90373 59.58886,50.50578 77.24443,69.69156 z m 52.6875,16.3125 -1,4.03125 c 0.68459,1.09639 1.35033,2.21431 1.96875,3.375 4.21044,7.90236 10.34375,15.71231 10.34375,24.6875 0,2.81677 -4.92786,9.125 -8.15625,9.125 -1.83008,0 -4.99756,-9.03753 -15.5625,-20.84375 l -3.34375,1.125 c 9.06668,11.04246 15.68874,22.28125 18.78125,22.28125 5.29017,0 10.46875,-6.6455 10.46875,-11.9375 0,-9.87256 -6.2175,-18.58637 -10.75,-27.25 -0.83453,-1.59516 -1.77593,-3.10599 -2.75,-4.59375 z#000000m 421.57045,154.92585 c 2.869,4.5768 5.73799,8.38791 8.60699,16.009 0,0 -1.42034,3.39697 -1.7214,2.75424 -1.02435,-2.18686 -14.38086,-25.34767 -14.28761,-24.78814 z#000000m 448.5964,177.47616 c -1.09549,10.17976 -5.2404,16.90451 -5.24414,19.20837 -0.01,5.97441 6.20883,27.09179 9.54764,40.35202 l -2.06568,2.92637 c -5.00553,-13.72498 -10.63578,-37.97576 -10.84481,-43.72351 -0.0705,-1.93898 4.24241,-11.04458 6.36917,-20.14036 z#000000m 432.84074,163.4802 c -1.34328,11.27206 -9.1291,31.83126 -9.1291,37.97702 0,6.49839 13.66599,29.67395 20.57089,45.40203 l -2.43442,2.19098 c -7.75457,-18.30577 -21.16183,-37.76897 -21.05778,-47.59301 0.11448,-10.80892 5.54043,-16.03603 9.49426,-39.07251 z#000000m 437.75159,238.06938 c -0.0268,7.11051 -0.61824,13.88224 -2.92638,19.62395 l 4.13136,-4.3035 c 1.47051,-4.10932 1.79801,-7.7798 1.89354,-11.36123 z#000000m 405.21001,209.24738 c 9.7274,22.56975 16.55409,39.77396 16.55409,50.75776 0,2.57256 2.5809,6.26099 5.23402,8.27705 l -1.94754,2.43442 c -3.03688,-2.87042 -6.27493,-7.36443 -6.45123,-10.83319 -0.48512,-9.54464 -7.09419,-28.7342 -12.41557,-41.50694 z#000000m 406.79239,249.41539 c 4.33296,-0.18016 8.60026,0.13203 12.29385,4.74713 l -0.73033,-4.38196 c -2.62571,-1.77365 -4.70938,-3.95383 -11.07664,-2.92131 z#000000m 406.54895,262.56129 c 4.20465,-0.6642 8.27192,-1.46578 14.3631,-0.24344 l 1.33894,2.55614 c -4.93459,-0.65807 -10.00205,-0.91589 -15.58032,0.36516 z#000000m 405.45346,284.59283 c 0,0 4.80798,-6.45123 5.90347,-6.08606 1.0955,0.36516 0.42603,8.64221 0.42603,8.64221 l 3.16475,-3.52992 c 0,0 0.0812,-7.89928 -2.0084,-8.88565 -2.08961,-0.98636 -7.24241,5.59918 -7.24241,5.59918 z#000000m 466.15466,362.01006 c 3.19923,26.33245 3.71863,64.39733 2.7468,78.73861 -2.79763,41.28461 11.46608,104.38145 16.61197,122.86304 0.80181,2.87972 1.09227,4.28624 2.06831,4.28624 0.97605,0 1.85005,-1.48736 2.96453,-2.65183 43.54284,-45.49597 63.22587,-85.68975 72.23254,-123.51101 0.68923,-2.89424 1.33028,-3.07654 2.06861,-3.04318 0.73833,0.0334 1.54144,0.24766 2.38019,3.13729 10.01082,34.48884 17.72566,65.50146 20.0174,83.44393 0.3633,2.84428 0.43409,5.53642 1.15547,5.74433 0.72139,0.20792 1.09714,-2.8716 1.84102,-5.55099 2.30784,-8.31262 4.15734,-18.77878 4.15734,-29.87592 0,-69.16011 -53.45009,-119.81074 -78.4225,-195.66086 l 2.67787,-2.3127 c 27.11887,78.73308 78.5102,129.91128 78.5102,198.04046 0,14.85947 -3.42589,31.0045 -8.22618,43.99853 -1.35617,3.67106 -2.66532,7.96757 -3.68189,7.60247 -1.01658,-0.36509 -0.39333,-4.61478 -0.4714,-8.32858 -0.55347,-26.32961 -8.15539,-56.84425 -18.67951,-89.09393 -0.48941,-1.49973 -0.79073,-2.6151 -1.21291,-2.59311 -0.42217,0.022 -0.8003,1.06267 -1.10511,2.55776 -7.83243,38.4178 -33.91467,79.11684 -73.56067,121.51135 -1.38154,1.47731 -2.31983,2.36791 -3.46349,2.36882 -1.14367,9.1e-4 -1.86415,-1.05219 -2.47775,-2.853 -7.42803,-21.79997 -18.97634,-66.92927 -18.62374,-130.81056 0.11887,-21.53784 1.38221,-45.10044 -2.0892,-79.21214 z#000000'! !!RSSVGAnimationExamples methodsFor: 'accessing'!order	^ 1001! !!RSSVGAnimationExamples methodsFor: 'data - svg'!puzzlePiece	^ 'M3.739,13.619c0,0,3.516-4.669,5.592-3.642c2.077,1.027-0.414,2.795,1.598,3.719c2.011,0.924,5.048-0.229,4.376-2.899c-0.672-2.67-1.866-0.776-2.798-2.208c-0.934-1.432,4.586-4.59,4.586-4.59s3.361,6.651,4.316,4.911c1.157-2.105,3.193-4.265,5.305-1.025c0,0,1.814,2.412,0.246,3.434s-2.917,0.443-3.506,1.553c-0.586,1.112,3.784,4.093,3.784,4.093s-2.987,4.81-4.926,3.548c-1.939-1.262,0.356-3.364-2.599-3.989c-1.288-0.23-3.438,0.538-3.818,2.34c-0.13,2.709,1.604,2.016,2.797,3.475c1.191,1.457-4.484,4.522-4.484,4.522s-1.584-3.923-3.811-4.657c-2.227-0.735-0.893,2.135-2.917,2.531c-2.024,0.396-4.816-2.399-3.46-4.789c1.358-2.391,3.275-0.044,3.441-1.951C7.629,16.087,3.739,13.619,3.739,13.619z'! !!RSSVGAnimationExamples methodsFor: 'data - svg'!supermarketCart	^ 'M29.02,11.754L8.416,9.473L7.16,4.716C7.071,4.389,6.772,4.158,6.433,4.158H3.341C3.114,3.866,2.775,3.667,2.377,3.667c-0.686,0-1.242,0.556-1.242,1.242c0,0.686,0.556,1.242,1.242,1.242c0.399,0,0.738-0.201,0.965-0.493h2.512l5.23,19.8c-0.548,0.589-0.891,1.373-0.891,2.242c0,1.821,1.473,3.293,3.293,3.293c1.82,0,3.294-1.472,3.297-3.293c0-0.257-0.036-0.504-0.093-0.743h5.533c-0.056,0.239-0.092,0.486-0.092,0.743c0,1.821,1.475,3.293,3.295,3.293s3.295-1.472,3.295-3.293c0-1.82-1.473-3.295-3.295-3.297c-0.951,0.001-1.801,0.409-2.402,1.053h-7.136c-0.601-0.644-1.451-1.052-2.402-1.053c-0.379,0-0.738,0.078-1.077,0.196l-0.181-0.685H26.81c1.157-0.027,2.138-0.83,2.391-1.959l1.574-7.799c0.028-0.145,0.041-0.282,0.039-0.414C30.823,12.733,30.051,11.86,29.02,11.754zM25.428,27.994c-0.163,0-0.295-0.132-0.297-0.295c0.002-0.165,0.134-0.297,0.297-0.297s0.295,0.132,0.297,0.297C25.723,27.862,25.591,27.994,25.428,27.994zM27.208,20.499l0.948-0.948l-0.318,1.578L27.208,20.499zM12.755,11.463l1.036,1.036l-1.292,1.292l-1.292-1.292l1.087-1.087L12.755,11.463zM17.253,11.961l0.538,0.538l-1.292,1.292l-1.292-1.292l0.688-0.688L17.253,11.961zM9.631,14.075l0.868-0.868l1.292,1.292l-1.292,1.292l-0.564-0.564L9.631,14.075zM9.335,12.956l-0.328-1.24L9.792,12.5L9.335,12.956zM21.791,16.499l-1.292,1.292l-1.292-1.292l1.292-1.292L21.791,16.499zM21.207,14.5l1.292-1.292l1.292,1.292l-1.292,1.292L21.207,14.5zM18.5,15.791l-1.293-1.292l1.292-1.292l1.292,1.292L18.5,15.791zM17.791,16.499L16.5,17.791l-1.292-1.292l1.292-1.292L17.791,16.499zM14.499,15.791l-1.292-1.292l1.292-1.292l1.292,1.292L14.499,15.791zM13.791,16.499l-1.292,1.291l-1.292-1.291l1.292-1.292L13.791,16.499zM10.499,17.207l1.292,1.292l-0.785,0.784l-0.54-2.044L10.499,17.207zM11.302,20.404l1.197-1.197l1.292,1.292L12.5,21.791l-1.131-1.13L11.302,20.404zM13.208,18.499l1.291-1.292l1.292,1.292L14.5,19.791L13.208,18.499zM16.5,19.207l1.292,1.292L16.5,21.79l-1.292-1.291L16.5,19.207zM17.208,18.499l1.292-1.292l1.291,1.292L18.5,19.79L17.208,18.499zM20.499,19.207l1.292,1.292L20.5,21.79l-1.292-1.292L20.499,19.207zM21.207,18.499l1.292-1.292l1.292,1.292l-1.292,1.292L21.207,18.499zM23.207,16.499l1.292-1.292l1.292,1.292l-1.292,1.292L23.207,16.499zM25.207,14.499l1.292-1.292L27.79,14.5l-1.291,1.292L25.207,14.499zM24.499,13.792l-1.156-1.156l2.082,0.23L24.499,13.792zM21.791,12.5l-1.292,1.292L19.207,12.5l0.29-0.29l2.253,0.25L21.791,12.5zM14.5,11.791l-0.152-0.152l0.273,0.03L14.5,11.791zM10.5,11.792l-0.65-0.65l1.171,0.129L10.5,11.792zM14.5,21.207l1.205,1.205h-2.409L14.5,21.207zM18.499,21.207l1.206,1.206h-2.412L18.499,21.207zM22.499,21.207l1.208,1.207l-2.414-0.001L22.499,21.207zM23.207,20.499l1.292-1.292l1.292,1.292l-1.292,1.292L23.207,20.499zM25.207,18.499l1.292-1.291l1.291,1.291l-1.291,1.292L25.207,18.499zM28.499,17.791l-1.291-1.292l1.291-1.291l0.444,0.444l-0.429,2.124L28.499,17.791zM29.001,13.289l-0.502,0.502l-0.658-0.658l1.016,0.112C28.911,13.253,28.956,13.271,29.001,13.289zM13.487,27.994c-0.161,0-0.295-0.132-0.295-0.295c0-0.165,0.134-0.297,0.295-0.297c0.163,0,0.296,0.132,0.296,0.297C13.783,27.862,13.651,27.994,13.487,27.994zM26.81,22.414h-1.517l1.207-1.207l0.93,0.93C27.243,22.306,27.007,22.428,26.81,22.414z'! !"Roassal3-SVG-Examples"!!SpPresenter methodsFor: '*Roassal3-Pharo9'!open	^ self asWindow open! !!RSIconBrowser class methodsFor: '*Roassal3-Pharo9'!defaultSpec	^ self defaultLayout! !!SpDropListPresenter methodsFor: '*Roassal3-Pharo9' prior: 65185958!displayIcon: aBlock	self iconBlock: aBlock! !!RSExamplesBrowser class methodsFor: '*Roassal3-Pharo9'!defaultSpec	^ self defaultLayout! !!SpRoassal3InspectorPresenter class methodsFor: '*Roassal3-Pharo9'!defaultSpec	^ self defaultLayout! !"Roassal3-Pharo9"!!CompiledMethod methodsFor: '*Roassal3-Pharo'!protocolName	^ self protocol! !----QUIT----2023-10-23T23:26:38.99456-05:00 Visualizer.image priorSource: 198!