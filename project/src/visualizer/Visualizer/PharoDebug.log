THERE_BE_DRAGONS_HERE
Could not resolve: BaselineOfJSON [BaselineOfJSON] in /Users/ryanperez/Documents/Pharo/images/Visualizer/pharo-local/package-cache https://github.com/SvenVC/NeoJSON.git[master]
23 October 2023 11:00:48.528986 pm

VM: Mac OS - arm64 - 1000 - CoInterpreter VMMaker-tonel.1 uuid: 902dd483-c0c4-0d00-86f2-0f880df24b96 Oct 23 2023
StackToRegisterMappingCogit VMMaker-tonel.1 uuid: 902dd483-c0c4-0d00-86f2-0f880df24b96 Oct 23 2023
v10.0.8 - Commit: b323c5fb - Date: 2023-10-20 16:02:07 -0400

Image: Pharo11.0.0 [Build information: Pharo-11.0.0+build.710.sha.ea28d8552cac85a7ce1e9c34ab1e7bd45f7b9910 (64 Bit)]

MetacelloFetchingMCSpecLoader(MetacelloCommonMCSpecLoader)>>retryingResolvePackageSpecReferences:gofer:
	Receiver: a MetacelloFetchingMCSpecLoader(explicit load : BaselineOfJSON)
	Arguments and temporary variables: 
		packageSpec: 	spec 
	name: 'BaselineOfJSON';
	repository: 'github://SvenVC/N[..]
		gofer: 	a MetacelloGofer
		references: 	#()
		retryCount: 	3
		repositoryError: 	nil
	Receiver's instance variables: 
		spec: 	spec 
	name: 'BaselineOfJSON';
	repository: 'github://SvenVC/NeoJSON/[..]
		operator: 	nil
		loaderPolicy: 	a MetacelloLoaderPolicy
		disablePackageCache: 	false


[ 
      | references nearestReference cachedReference externalReference mcVersion loadedVersionInfos |
      cachedReference := nil.
      packageSpec
        searchCacheRepositoryForPackage: [ 
          "check to see if mcz file is already in cacheRepository"
          cachedReference := self
            resolvePackageSpec: packageSpec
            cachedGofer: self loaderPolicy cacheGofer.
          (cachedReference ~~ nil and: [ packageSpec getFile ~~ nil ])
            ifTrue: [ 
              cachedReference name = packageSpec file
                ifTrue: [ 
                  "exact match between packageSpec file and cache"
                  ^ self
                    scheduleFetchFor: packageSpec
                    cachedReference: cachedReference ] ] ].
      references := self
        retryingResolvePackageSpecReferences: packageSpec
        gofer: gofer.	"look up mcz file"
      nearestReference := references last asMetacelloCachingResolvedReference.
      (cachedReference ~~ nil
        and: [ cachedReference name = nearestReference name ])
        ifTrue: [ 
          "latest reference in repository matches cachedReference ... "
          ^ self
            scheduleFetchFor: packageSpec
            nearestReference: nearestReference ].
      (self ignoreImage not
        and: [ (loadedVersionInfos := self ancestorsFor: packageSpec) ~~ nil ])
        ifTrue: [ 
          "If the mcz is already loaded into the image, no need to copy"
          loadedVersionInfos
            do: [ :info | 
              info name = nearestReference name
                ifTrue: [ 
                  | spc |
                  spc := packageSpec copy.
                  spc file: info name.
                  (MetacelloIgnorePackageLoaded signal: spc)
                    ifFalse: [ ^ self ] ] ] ].
      externalReference := (references
        select: [ :ref | ref name = nearestReference name ]) first
        asMetacelloCachingResolvedReference.
      self repositoryMap
        at: externalReference name
        put: externalReference repository.
      (self
        resolveDependencies: externalReference
        nearest: nearestReference
        into: (OrderedCollection with: nearestReference))
        do: [ :reference | 
          | pSpec l |
          mcVersion := reference version.
          (l := (GoferVersionReference name: reference name)
            resolveAllWith: self loaderPolicy cacheGofer) isEmpty
            ifTrue: [ 
              self cacheRepository storeVersion: mcVersion.
              reference == nearestReference
                ifTrue: [ pSpec := packageSpec ]
                ifFalse: [ 
                  pSpec := packageSpec project packageSpec.
                  pSpec name: mcVersion package name ].
              self loadData
                addVersion: mcVersion
                versionInfo: mcVersion info
                resolvedReference: reference
                packageSpec: pSpec ] ].
      self scheduleFetchFor: packageSpec externalReference: externalReference ] in MetacelloFetchingMCSpecLoader>>linearLoadPackageSpec:gofer:
	Receiver: a MetacelloFetchingMCSpecLoader(explicit load : BaselineOfJSON)
	Arguments and temporary variables: 
		packageSpec: 	spec 
	name: 'BaselineOfJSON';
	repository: 'github://SvenVC/N[..]
		gofer: 	a MetacelloGofer
		cachedReference: 	nil
		mcVersion: 	nil
		references: 	nil
		nearestReference: 	nil
		externalReference: 	nil
		loadedVersionInfos: 	nil
	Receiver's instance variables: 
		spec: 	spec 
	name: 'BaselineOfJSON';
	repository: 'github://SvenVC/NeoJSON/[..]
		operator: 	nil
		loaderPolicy: 	a MetacelloLoaderPolicy
		disablePackageCache: 	false


[:bar |
            bar value: 1.
            aBlock value.
            bar value: 2 ] in IceMetacelloPharoPlatform(MetacelloPharoCommonPlatform)>>do:displaying:
	Receiver: an IceMetacelloPharoPlatform
	Arguments and temporary variables: 
		aBlock: 	[ 
      | references nearestReference cachedReference externalRefe[..]
		aString: 	'Fetching BaselineOfJSON'
		bar: 	a Job
	Receiver's instance variables: 
		bypassProgressBars: 	false
		bypassGoferLoadUpdateCategories: 	false


FullBlockClosure(BlockClosure)>>cull:
	Receiver: [:bar |
            bar value: 1.
            aBlock value.
            bar value: 2 ]
	Arguments and temporary variables: 
		anArg: 	a Job
	Receiver's instance variables: 
		outerContext: 	IceMetacelloPharoPlatform(MetacelloPharoCommonPlatform)>>do:d[..]
		compiledBlock: 	a CompiledBlock: [:bar |
            bar value: 1.
         [..]
		numArgs: 	1
		receiver: 	an IceMetacelloPharoPlatform


[ ^ block cull: self ] in [ self prepareForRunning.
	  CurrentJob value: self during: [ ^ block cull: self ] ] in Job>>run
	Receiver: a Job
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		block: 	[:bar |
            bar value: 1.
            aBlock value.
        [..]
		currentValue: 	1
		min: 	0
		max: 	2
		title: 	'Fetching BaselineOfJSON'
		children: 	an OrderedCollection()
		isRunning: 	true
		parent: 	nil
		process: 	a Process in nil
		owner: 	a MorphicUIManager


[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in CurrentJob(DynamicVariable)>>value:during:
	Receiver: a CurrentJob
	Arguments and temporary variables: 
		anObject: 	a Job
		aBlock: 	[ ^ block cull: self ]
		activeProcess: 	a Process in nil
		oldValue: 	nil
	Receiver's instance variables: 
		index: 	2


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ]
	Arguments and temporary variables: 
		aBlock: 	[
			activeProcess
				psValueAt: index
				put: oldValue ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	CurrentJob(DynamicVariable)>>value:during:
		compiledBlock: 	a CompiledBlock: [ activeProcess
			psValueAt: index
			put:[..]
		numArgs: 	0
		receiver: 	a CurrentJob


CurrentJob(DynamicVariable)>>value:during:
	Receiver: a CurrentJob
	Arguments and temporary variables: 
		anObject: 	a Job
		aBlock: 	[ ^ block cull: self ]
		activeProcess: 	a Process in nil
		oldValue: 	nil
	Receiver's instance variables: 
		index: 	2


CurrentJob class(DynamicVariable class)>>value:during:
	Receiver: CurrentJob
	Arguments and temporary variables: 
		anObject: 	a Job
		aBlock: 	[ ^ block cull: self ]
	Receiver's instance variables: 
		superclass: 	DynamicVariable
		methodDict: 	a MethodDictionary()
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		commentSourcePointer: 	nil
		subclasses: 	nil
		name: 	#CurrentJob
		classPool: 	nil
		sharedPools: 	nil
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Jobs-Base'
		soleInstance: 	a CurrentJob


[ self prepareForRunning.
	  CurrentJob value: self during: [ ^ block cull: self ] ] in Job>>run
	Receiver: a Job
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		block: 	[:bar |
            bar value: 1.
            aBlock value.
        [..]
		currentValue: 	1
		min: 	0
		max: 	2
		title: 	'Fetching BaselineOfJSON'
		children: 	an OrderedCollection()
		isRunning: 	true
		parent: 	nil
		process: 	a Process in nil
		owner: 	a MorphicUIManager


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ self prepareForRunning.
	  CurrentJob value: self during: [ ^ block cull: self ] ]
	Arguments and temporary variables: 
		aBlock: 	[ self cleanupAfterRunning ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	Job>>run
		compiledBlock: 	a CompiledBlock: [ self prepareForRunning.
	  CurrentJob val[..]
		numArgs: 	0
		receiver: 	a Job


Job>>run
	Receiver: a Job
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		block: 	[:bar |
            bar value: 1.
            aBlock value.
        [..]
		currentValue: 	1
		min: 	0
		max: 	2
		title: 	'Fetching BaselineOfJSON'
		children: 	an OrderedCollection()
		isRunning: 	true
		parent: 	nil
		process: 	a Process in nil
		owner: 	a MorphicUIManager


MorphicUIManager(UIManager)>>displayProgress:from:to:during:
	Receiver: a MorphicUIManager
	Arguments and temporary variables: 
		titleString: 	'Fetching BaselineOfJSON'
		minVal: 	0
		maxVal: 	2
		workBlock: 	[:bar |
            bar value: 1.
            aBlock value.
    [..]
	Receiver's instance variables: 
		activeTranscript: 	nil


ByteString(String)>>displayProgressFrom:to:during:
	Receiver: 'Fetching BaselineOfJSON'
	Arguments and temporary variables: 
		minVal: 	0
		maxVal: 	2
		workBlock: 	[:bar |
            bar value: 1.
            aBlock value.
    [..]
	Receiver's instance variables: 
'Fetching BaselineOfJSON'

IceMetacelloPharoPlatform(MetacelloPharoCommonPlatform)>>do:displaying:
	Receiver: an IceMetacelloPharoPlatform
	Arguments and temporary variables: 
		aBlock: 	[ 
      | references nearestReference cachedReference externalRefe[..]
		aString: 	'Fetching BaselineOfJSON'
	Receiver's instance variables: 
		bypassProgressBars: 	false
		bypassGoferLoadUpdateCategories: 	false


MetacelloFetchingMCSpecLoader>>linearLoadPackageSpec:gofer:
	Receiver: a MetacelloFetchingMCSpecLoader(explicit load : BaselineOfJSON)
	Arguments and temporary variables: 
		packageSpec: 	spec 
	name: 'BaselineOfJSON';
	repository: 'github://SvenVC/N[..]
		gofer: 	a MetacelloGofer
	Receiver's instance variables: 
		spec: 	spec 
	name: 'BaselineOfJSON';
	repository: 'github://SvenVC/NeoJSON/[..]
		operator: 	nil
		loaderPolicy: 	a MetacelloLoaderPolicy
		disablePackageCache: 	false


MetacelloPackageSpec>>loadUsing:gofer:
	Receiver: spec 
	name: 'BaselineOfJSON';
	repository: 'github://SvenVC/NeoJSON/repository'.
	Arguments and temporary variables: 
		aLoader: 	a MetacelloFetchingMCSpecLoader(explicit load : BaselineOfJSON)
		gofer: 	a MetacelloGofer
	Receiver's instance variables: 
		project: 	<<error during printing>>

[:pkg | pkg loadUsing: self gofer: gofer ] in MetacelloFetchingMCSpecLoader(MetacelloCommonMCSpecLoader)>>linearLoadPackageSpecs:repositories:
	Receiver: a MetacelloFetchingMCSpecLoader(explicit load : BaselineOfJSON)
	Arguments and temporary variables: 
		packageSpecs: 	an Array(spec 
	name: 'BaselineOfJSON';
	repository: 'github:[..]
		repositories: 	an OrderedCollection(an IceMetacelloRepositoryAdapter)
		gofer: 	a MetacelloGofer
		pkg: 	spec 
	name: 'BaselineOfJSON';
	repository: 'github://SvenVC/NeoJSON/r[..]
	Receiver's instance variables: 
		spec: 	spec 
	name: 'BaselineOfJSON';
	repository: 'github://SvenVC/NeoJSON/[..]
		operator: 	nil
		loaderPolicy: 	a MetacelloLoaderPolicy
		disablePackageCache: 	false


Array(SequenceableCollection)>>do:
	Receiver: an Array(spec 
	name: 'BaselineOfJSON';
	repository: 'github://SvenVC/NeoJSON/reposito[..]
	Arguments and temporary variables: 
		aBlock: 	[:pkg | pkg loadUsing: self gofer: gofer ]
		index: 	1
	Receiver's instance variables: 
an Array(spec 
	name: 'BaselineOfJSON';
	repository: 'github://SvenVC/NeoJSON/reposito[..]

MetacelloFetchingMCSpecLoader(MetacelloCommonMCSpecLoader)>>linearLoadPackageSpecs:repositories:
	Receiver: a MetacelloFetchingMCSpecLoader(explicit load : BaselineOfJSON)
	Arguments and temporary variables: 
		packageSpecs: 	an Array(spec 
	name: 'BaselineOfJSON';
	repository: 'github:[..]
		repositories: 	an OrderedCollection(an IceMetacelloRepositoryAdapter)
		gofer: 	a MetacelloGofer
	Receiver's instance variables: 
		spec: 	spec 
	name: 'BaselineOfJSON';
	repository: 'github://SvenVC/NeoJSON/[..]
		operator: 	nil
		loaderPolicy: 	a MetacelloLoaderPolicy
		disablePackageCache: 	false


[ super linearLoadPackageSpecs: packageSpecs repositories: repositories ] in MetacelloFetchingMCSpecLoader>>explicitLoadPackageSpecs:repositories:
	Receiver: a MetacelloFetchingMCSpecLoader(explicit load : BaselineOfJSON)
	Arguments and temporary variables: 
		packageSpecs: 	an Array(spec 
	name: 'BaselineOfJSON';
	repository: 'github:[..]
		repositories: 	an OrderedCollection(an IceMetacelloRepositoryAdapter)
		directive: 	nil
	Receiver's instance variables: 
		spec: 	spec 
	name: 'BaselineOfJSON';
	repository: 'github://SvenVC/NeoJSON/[..]
		operator: 	nil
		loaderPolicy: 	a MetacelloLoaderPolicy
		disablePackageCache: 	false


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ super linearLoadPackageSpecs: packageSpecs repositories: repositories ]
	Arguments and temporary variables: 
		aBlock: 	[ loadDirective := oldRoot ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	MetacelloFetchingMCSpecLoader>>explicitLoadPackageSpecs:repos[..]
		compiledBlock: 	a CompiledBlock: [ super linearLoadPackageSpecs: packageSpec[..]
		numArgs: 	0
		receiver: 	a MetacelloFetchingMCSpecLoader(explicit load : BaselineOfJSON)


MetacelloLoaderPolicy>>pushLoadDirective:during:
	Receiver: a MetacelloLoaderPolicy
	Arguments and temporary variables: 
		aLoaderDirective: 	explicit load : BaselineOfJSON
		aBlock: 	[ super linearLoadPackageSpecs: packageSpecs repositories: reposito[..]
		oldRoot: 	linear load : 
	explicit load : BaselineOfJSON
	Receiver's instance variables: 
		overrideRepositories: 	nil
		repositoryMap: 	a Dictionary()
		ensuredMap: 	a Dictionary()
		cacheRepository: 	a MCDictionaryRepository(cache)
		cacheGofer: 	a Gofer
		ignoreImage: 	false
		loadData: 	nil
		loadDirective: 	explicit load : BaselineOfJSON
		silently: 	nil


MetacelloLoaderPolicy>>pushExplicitLoadDirectivesDuring:for:
	Receiver: a MetacelloLoaderPolicy
	Arguments and temporary variables: 
		aBlock: 	[ super linearLoadPackageSpecs: packageSpecs repositories: reposito[..]
		aLoader: 	a MetacelloFetchingMCSpecLoader(explicit load : BaselineOfJSON)
		directive: 	explicit load : BaselineOfJSON
	Receiver's instance variables: 
		overrideRepositories: 	nil
		repositoryMap: 	a Dictionary()
		ensuredMap: 	a Dictionary()
		cacheRepository: 	a MCDictionaryRepository(cache)
		cacheGofer: 	a Gofer
		ignoreImage: 	false
		loadData: 	nil
		loadDirective: 	explicit load : BaselineOfJSON
		silently: 	nil


MetacelloFetchingMCSpecLoader>>explicitLoadPackageSpecs:repositories:
	Receiver: a MetacelloFetchingMCSpecLoader(explicit load : BaselineOfJSON)
	Arguments and temporary variables: 
		packageSpecs: 	an Array(spec 
	name: 'BaselineOfJSON';
	repository: 'github:[..]
		repositories: 	an OrderedCollection(an IceMetacelloRepositoryAdapter)
		directive: 	nil
	Receiver's instance variables: 
		spec: 	spec 
	name: 'BaselineOfJSON';
	repository: 'github://SvenVC/NeoJSON/[..]
		operator: 	nil
		loaderPolicy: 	a MetacelloLoaderPolicy
		disablePackageCache: 	false


MetacelloPackageSpec>>explicitLoadUsing:
	Receiver: spec 
	name: 'BaselineOfJSON';
	repository: 'github://SvenVC/NeoJSON/repository'.
	Arguments and temporary variables: 
		mcLoader: 	a MetacelloLoadingMCSpecLoader
		wc: 	nil
		fetchingSpecLoader: 	a MetacelloFetchingMCSpecLoader(explicit load : Baselin[..]
	Receiver's instance variables: 
		project: 	<<error during printing>>

MetacelloPackageSpec>>load
	Receiver: spec 
	name: 'BaselineOfJSON';
	repository: 'github://SvenVC/NeoJSON/repository'.
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		project: 	<<error during printing>>

[ spec projectPackage load ] in MetacelloScriptEngine>>getBaselineUnconditionalLoad:
	Receiver: a MetacelloScriptEngine
	Arguments and temporary variables: 
		unconditionalLoad: 	true
		spec: 	spec 
	name: 'JSON';
	repository: 'github://SvenVC/NeoJSON/repository'.
	Receiver's instance variables: 
		root: 	nil
		projectSpec: 	spec 
	name: 'JSON';
	repository: 'github://SvenVC/NeoJSON/rep[..]
		options: 	a Dictionary()


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [ spec projectPackage load ]
	Arguments and temporary variables: 
		exception: 	MetacelloIgnorePackageLoaded
		handlerAction: 	[ :ex | 
      "see https://github.com/dalehenrich/metacello[..]
	Receiver's instance variables: 
		outerContext: 	MetacelloScriptEngine>>getBaselineUnconditionalLoad:
		compiledBlock: 	a CompiledBlock: [ spec projectPackage load ]
		numArgs: 	0
		receiver: 	a MetacelloScriptEngine


MetacelloScriptEngine>>getBaselineUnconditionalLoad:
	Receiver: a MetacelloScriptEngine
	Arguments and temporary variables: 
		unconditionalLoad: 	true
		spec: 	spec 
	name: 'JSON';
	repository: 'github://SvenVC/NeoJSON/repository'.
	Receiver's instance variables: 
		root: 	nil
		projectSpec: 	spec 
	name: 'JSON';
	repository: 'github://SvenVC/NeoJSON/rep[..]
		options: 	a Dictionary()


MetacelloScriptEngine>>getBaselineProjectUnconditionalLoad:
	Receiver: a MetacelloScriptEngine
	Arguments and temporary variables: 
		unconditionalLoad: 	true
		project: 	nil
	Receiver's instance variables: 
		root: 	nil
		projectSpec: 	spec 
	name: 'JSON';
	repository: 'github://SvenVC/NeoJSON/rep[..]
		options: 	a Dictionary()


MetacelloMCBaselineProject>>projectForScriptEngine:unconditionalLoad:
	Receiver: <<error during printing>>
	Arguments and temporary variables: 
		aMetacelloScriptEngine: 	a MetacelloScriptEngine
		aBool: 	false
	Receiver's instance variables: 
		versionMap: 	nil
		symbolicVersionMap: 	nil
		errorMap: 	nil
		loader: 	nil
		loaderClass: 	MetacelloLoadingMCSpecLoader
		loadType: 	nil
		configuration: 	<<error during printing>>

MetacelloMCBaselineProject(MetacelloProject)>>projectForScriptEngine:
	Receiver: <<error during printing>>
	Arguments and temporary variables: 
		aMetacelloScriptEngine: 	a MetacelloScriptEngine
	Receiver's instance variables: 
		versionMap: 	nil
		symbolicVersionMap: 	nil
		errorMap: 	nil
		loader: 	nil
		loaderClass: 	MetacelloLoadingMCSpecLoader
		loadType: 	nil
		configuration: 	<<error during printing>>

MetacelloMCBaselineOfProjectSpec(MetacelloMCProjectSpec)>>versionForScriptEngine:
	Receiver: spec 
	name: 'JSON';
	repository: 'github://SvenVC/NeoJSON/repository'.
	Arguments and temporary variables: 
<<error during printing>>
	Receiver's instance variables: 
		project: 	<<error during printing>>

[ 
          | version loadedSpec |
          self setDefaultsAndValidateProjectSpec.
          [ loadedSpec := (self lookupProjectSpecFor: self projectSpec) copy ]
            on: MetacelloAllowProjectDowngrade , MetacelloAllowProjectUpgrade
            do: [ :ex | ex handleOnDownGrade: onDownGradeBlock onUpgrade: onUpgradeBlock ].
          version := loadedSpec versionForScriptEngine: self.
          self
            root:
              (required isEmpty
                ifTrue: [ version load ]
                ifFalse: [ version load: required ]) loadDirective.
          loadedSpec loads: required.
          MetacelloProjectRegistration
            registrationForProjectSpec: loadedSpec
            ifAbsent: [ :new | 
              new
                loadedInImage: true;
                registerProject ]
            ifPresent: [ :existing :new | 
              existing
                copyOnWrite: [ :existingCopy | 
                  existingCopy
                    loadedInImage: true;
                    merge: new ] ] ] in [ 
      self
        handleNotificationsForAction: [ 
          | version loadedSpec |
          self setDefaultsAndValidateProjectSpec.
          [ loadedSpec := (self lookupProjectSpecFor: self projectSpec) copy ]
            on: MetacelloAllowProjectDowngrade , MetacelloAllowProjectUpgrade
            do: [ :ex | ex handleOnDownGrade: onDownGradeBlock onUpgrade: onUpgradeBlock ].
          version := loadedSpec versionForScriptEngine: self.
          self
            root:
              (required isEmpty
                ifTrue: [ version load ]
                ifFalse: [ version load: required ]) loadDirective.
          loadedSpec loads: required.
          MetacelloProjectRegistration
            registrationForProjectSpec: loadedSpec
            ifAbsent: [ :new | 
              new
                loadedInImage: true;
                registerProject ]
            ifPresent: [ :existing :new | 
              existing
                copyOnWrite: [ :existingCopy | 
                  existingCopy
                    loadedInImage: true;
                    merge: new ] ] ] ] in MetacelloScriptEngine>>load:onProjectDownGrade:onProjectUpgrade:
	Receiver: a MetacelloScriptEngine
	Arguments and temporary variables: 
		required: 	#()
		onDownGradeBlock: 	[ :ex :existing :new | ex allowEvenIfLocked ]
		onUpgradeBlock: 	[ :ex :existing :new | ex allowEvenIfLocked ]
		loadedSpec: 	spec 
	name: 'JSON';
	repository: 'github://SvenVC/NeoJSON/repo[..]
		version: 	nil
	Receiver's instance variables: 
		root: 	nil
		projectSpec: 	spec 
	name: 'JSON';
	repository: 'github://SvenVC/NeoJSON/rep[..]
		options: 	a Dictionary()


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [ 
          | version loadedSpec |
          self setDefaultsAndValidateProjectSpec.
[..]
	Arguments and temporary variables: 
		exception: 	an ExceptionSet
		handlerAction: 	[ :ex | 
      "lookup and registration handlers need to be [..]
	Receiver's instance variables: 
		outerContext: 	[ 
      self
        handleNotificationsForAction: [ 
      [..]
		compiledBlock: 	a CompiledBlock: [ 
          | version loadedSpec |
       [..]
		numArgs: 	0
		receiver: 	a MetacelloScriptEngine


[ 
  actionBlock
    on:
      MetacelloLookupProjectSpec , MetacelloLookupProjectSpecForLoad
        , MetacelloProjectSpecLoadedNotification
        , MetacelloScriptEnsureProjectLoadedForDevelopment
        , MetacelloLookupBaselineSpecForEnsureLoad
    do: [ :ex | 
      "lookup and registration handlers need to be innermost set of handlers ...they may throw option notifications"
      ex handleResolutionFor: self ] ] in [ 
  [ 
  actionBlock
    on:
      MetacelloLookupProjectSpec , MetacelloLookupProjectSpecForLoad
        , MetacelloProjectSpecLoadedNotification
        , MetacelloScriptEnsureProjectLoadedForDevelopment
        , MetacelloLookupBaselineSpecForEnsureLoad
    do: [ :ex | 
      "lookup and registration handlers need to be innermost set of handlers ...they may throw option notifications"
      ex handleResolutionFor: self ] ]
    on:
      MetacelloAllowProjectDowngrade , MetacelloAllowProjectUpgrade
        , MetacelloAllowConflictingProjectUpgrade
    do: [ :ex | 
      "option handlers need to be outermost set of handlers ... last line of defense before users are involved"
      ex handleResolutionFor: self ] ] in [ 
  [ 
  [ 
  actionBlock
    on:
      MetacelloLookupProjectSpec , MetacelloLookupProjectSpecForLoad
        , MetacelloProjectSpecLoadedNotification
        , MetacelloScriptEnsureProjectLoadedForDevelopment
        , MetacelloLookupBaselineSpecForEnsureLoad
    do: [ :ex | 
      "lookup and registration handlers need to be innermost set of handlers ...they may throw option notifications"
      ex handleResolutionFor: self ] ]
    on:
      MetacelloAllowProjectDowngrade , MetacelloAllowProjectUpgrade
        , MetacelloAllowConflictingProjectUpgrade
    do: [ :ex | 
      "option handlers need to be outermost set of handlers ... last line of defense before users are involved"
      ex handleResolutionFor: self ] ]
    on: MetacelloAllowLockedProjectChange
    do: [ :ex | 
      "MetacelloAllowLockedProjectChange need to be outermost handler ... since it is signaled from second line of handlers"
      ex handleResolutionFor: self ] ] in MetacelloScriptEngine>>handleNotificationsForAction:
	Receiver: a MetacelloScriptEngine
	Arguments and temporary variables: 
		actionBlock: 	[ 
          | version loadedSpec |
          self setDefaults[..]
	Receiver's instance variables: 
		root: 	nil
		projectSpec: 	spec 
	name: 'JSON';
	repository: 'github://SvenVC/NeoJSON/rep[..]
		options: 	a Dictionary()


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [ 
  actionBlock
    on:
      MetacelloLookupProjectSpec , MetacelloLookupProjectSpec[..]
	Arguments and temporary variables: 
		exception: 	an ExceptionSet
		handlerAction: 	[ :ex | 
      "option handlers need to be outermost set of [..]
	Receiver's instance variables: 
		outerContext: 	[ 
  [ 
  actionBlock
    on:
      MetacelloLookupProjectSpe[..]
		compiledBlock: 	a CompiledBlock: [ 
  actionBlock
    on:
      MetacelloLoo[..]
		numArgs: 	0
		receiver: 	a MetacelloScriptEngine


[ 
  [ 
  actionBlock
    on:
      MetacelloLookupProjectSpec , MetacelloLookupProjectSpecForLoad
        , MetacelloProjectSpecLoadedNotification
        , MetacelloScriptEnsureProjectLoadedForDevelopment
        , MetacelloLookupBaselineSpecForEnsureLoad
    do: [ :ex | 
      "lookup and registration handlers need to be innermost set of handlers ...they may throw option notifications"
      ex handleResolutionFor: self ] ]
    on:
      MetacelloAllowProjectDowngrade , MetacelloAllowProjectUpgrade
        , MetacelloAllowConflictingProjectUpgrade
    do: [ :ex | 
      "option handlers need to be outermost set of handlers ... last line of defense before users are involved"
      ex handleResolutionFor: self ] ] in [ 
  [ 
  [ 
  actionBlock
    on:
      MetacelloLookupProjectSpec , MetacelloLookupProjectSpecForLoad
        , MetacelloProjectSpecLoadedNotification
        , MetacelloScriptEnsureProjectLoadedForDevelopment
        , MetacelloLookupBaselineSpecForEnsureLoad
    do: [ :ex | 
      "lookup and registration handlers need to be innermost set of handlers ...they may throw option notifications"
      ex handleResolutionFor: self ] ]
    on:
      MetacelloAllowProjectDowngrade , MetacelloAllowProjectUpgrade
        , MetacelloAllowConflictingProjectUpgrade
    do: [ :ex | 
      "option handlers need to be outermost set of handlers ... last line of defense before users are involved"
      ex handleResolutionFor: self ] ]
    on: MetacelloAllowLockedProjectChange
    do: [ :ex | 
      "MetacelloAllowLockedProjectChange need to be outermost handler ... since it is signaled from second line of handlers"
      ex handleResolutionFor: self ] ] in MetacelloScriptEngine>>handleNotificationsForAction:
	Receiver: a MetacelloScriptEngine
	Arguments and temporary variables: 
		actionBlock: 	[ 
          | version loadedSpec |
          self setDefaults[..]
	Receiver's instance variables: 
		root: 	nil
		projectSpec: 	spec 
	name: 'JSON';
	repository: 'github://SvenVC/NeoJSON/rep[..]
		options: 	a Dictionary()



--- The full stack ---
MetacelloFetchingMCSpecLoader(MetacelloCommonMCSpecLoader)>>retryingResolvePackageSpecReferences:gofer:
[ 
      | references nearestReference cachedReference externalReference mcVersion loadedVersionInfos |
      cachedReference := nil.
      packageSpec
        searchCacheRepositoryForPackage: [ 
          "check to see if mcz file is already in cacheRepository"
          cachedReference := self
            resolvePackageSpec: packageSpec
            cachedGofer: self loaderPolicy cacheGofer.
          (cachedReference ~~ nil and: [ packageSpec getFile ~~ nil ])
            ifTrue: [ 
              cachedReference name = packageSpec file
                ifTrue: [ 
                  "exact match between packageSpec file and cache"
                  ^ self
                    scheduleFetchFor: packageSpec
                    cachedReference: cachedReference ] ] ].
      references := self
        retryingResolvePackageSpecReferences: packageSpec
        gofer: gofer.	"look up mcz file"
      nearestReference := references last asMetacelloCachingResolvedReference.
      (cachedReference ~~ nil
        and: [ cachedReference name = nearestReference name ])
        ifTrue: [ 
          "latest reference in repository matches cachedReference ... "
          ^ self
            scheduleFetchFor: packageSpec
            nearestReference: nearestReference ].
      (self ignoreImage not
        and: [ (loadedVersionInfos := self ancestorsFor: packageSpec) ~~ nil ])
        ifTrue: [ 
          "If the mcz is already loaded into the image, no need to copy"
          loadedVersionInfos
            do: [ :info | 
              info name = nearestReference name
                ifTrue: [ 
                  | spc |
                  spc := packageSpec copy.
                  spc file: info name.
                  (MetacelloIgnorePackageLoaded signal: spc)
                    ifFalse: [ ^ self ] ] ] ].
      externalReference := (references
        select: [ :ref | ref name = nearestReference name ]) first
        asMetacelloCachingResolvedReference.
      self repositoryMap
        at: externalReference name
        put: externalReference repository.
      (self
        resolveDependencies: externalReference
        nearest: nearestReference
        into: (OrderedCollection with: nearestReference))
        do: [ :reference | 
          | pSpec l |
          mcVersion := reference version.
          (l := (GoferVersionReference name: reference name)
            resolveAllWith: self loaderPolicy cacheGofer) isEmpty
            ifTrue: [ 
              self cacheRepository storeVersion: mcVersion.
              reference == nearestReference
                ifTrue: [ pSpec := packageSpec ]
                ifFalse: [ 
                  pSpec := packageSpec project packageSpec.
                  pSpec name: mcVersion package name ].
              self loadData
                addVersion: mcVersion
                versionInfo: mcVersion info
                resolvedReference: reference
                packageSpec: pSpec ] ].
      self scheduleFetchFor: packageSpec externalReference: externalReference ] in MetacelloFetchingMCSpecLoader>>linearLoadPackageSpec:gofer:
[:bar |
            bar value: 1.
            aBlock value.
            bar value: 2 ] in IceMetacelloPharoPlatform(MetacelloPharoCommonPlatform)>>do:displaying:
FullBlockClosure(BlockClosure)>>cull:
[ ^ block cull: self ] in [ self prepareForRunning.
	  CurrentJob value: self during: [ ^ block cull: self ] ] in Job>>run
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in CurrentJob(DynamicVariable)>>value:during:
FullBlockClosure(BlockClosure)>>ensure:
CurrentJob(DynamicVariable)>>value:during:
CurrentJob class(DynamicVariable class)>>value:during:
[ self prepareForRunning.
	  CurrentJob value: self during: [ ^ block cull: self ] ] in Job>>run
FullBlockClosure(BlockClosure)>>ensure:
Job>>run
MorphicUIManager(UIManager)>>displayProgress:from:to:during:
ByteString(String)>>displayProgressFrom:to:during:
IceMetacelloPharoPlatform(MetacelloPharoCommonPlatform)>>do:displaying:
MetacelloFetchingMCSpecLoader>>linearLoadPackageSpec:gofer:
MetacelloPackageSpec>>loadUsing:gofer:
[:pkg | pkg loadUsing: self gofer: gofer ] in MetacelloFetchingMCSpecLoader(MetacelloCommonMCSpecLoader)>>linearLoadPackageSpecs:repositories:
Array(SequenceableCollection)>>do:
MetacelloFetchingMCSpecLoader(MetacelloCommonMCSpecLoader)>>linearLoadPackageSpecs:repositories:
[ super linearLoadPackageSpecs: packageSpecs repositories: repositories ] in MetacelloFetchingMCSpecLoader>>explicitLoadPackageSpecs:repositories:
FullBlockClosure(BlockClosure)>>ensure:
MetacelloLoaderPolicy>>pushLoadDirective:during:
MetacelloLoaderPolicy>>pushExplicitLoadDirectivesDuring:for:
MetacelloFetchingMCSpecLoader>>explicitLoadPackageSpecs:repositories:
MetacelloPackageSpec>>explicitLoadUsing:
MetacelloPackageSpec>>load
[ spec projectPackage load ] in MetacelloScriptEngine>>getBaselineUnconditionalLoad:
FullBlockClosure(BlockClosure)>>on:do:
MetacelloScriptEngine>>getBaselineUnconditionalLoad:
MetacelloScriptEngine>>getBaselineProjectUnconditionalLoad:
MetacelloMCBaselineProject>>projectForScriptEngine:unconditionalLoad:
MetacelloMCBaselineProject(MetacelloProject)>>projectForScriptEngine:
MetacelloMCBaselineOfProjectSpec(MetacelloMCProjectSpec)>>versionForScriptEngine:
[ 
          | version loadedSpec |
          self setDefaultsAndValidateProjectSpec.
          [ loadedSpec := (self lookupProjectSpecFor: self projectSpec) copy ]
            on: MetacelloAllowProjectDowngrade , MetacelloAllowProjectUpgrade
            do: [ :ex | ex handleOnDownGrade: onDownGradeBlock onUpgrade: onUpgradeBlock ].
          version := loadedSpec versionForScriptEngine: self.
          self
            root:
              (required isEmpty
                ifTrue: [ version load ]
                ifFalse: [ version load: required ]) loadDirective.
          loadedSpec loads: required.
          MetacelloProjectRegistration
            registrationForProjectSpec: loadedSpec
            ifAbsent: [ :new | 
              new
                loadedInImage: true;
                registerProject ]
            ifPresent: [ :existing :new | 
              existing
                copyOnWrite: [ :existingCopy | 
                  existingCopy
                    loadedInImage: true;
                    merge: new ] ] ] in [ 
      self
        handleNotificationsForAction: [ 
          | version loadedSpec |
          self setDefaultsAndValidateProjectSpec.
          [ loadedSpec := (self lookupProjectSpecFor: self projectSpec) copy ]
            on: MetacelloAllowProjectDowngrade , MetacelloAllowProjectUpgrade
            do: [ :ex | ex handleOnDownGrade: onDownGradeBlock onUpgrade: onUpgradeBlock ].
          version := loadedSpec versionForScriptEngine: self.
          self
            root:
              (required isEmpty
                ifTrue: [ version load ]
                ifFalse: [ version load: required ]) loadDirective.
          loadedSpec loads: required.
          MetacelloProjectRegistration
            registrationForProjectSpec: loadedSpec
            ifAbsent: [ :new | 
              new
                loadedInImage: true;
                registerProject ]
            ifPresent: [ :existing :new | 
              existing
                copyOnWrite: [ :existingCopy | 
                  existingCopy
                    loadedInImage: true;
                    merge: new ] ] ] ] in MetacelloScriptEngine>>load:onProjectDownGrade:onProjectUpgrade:
FullBlockClosure(BlockClosure)>>on:do:
[ 
  actionBlock
    on:
      MetacelloLookupProjectSpec , MetacelloLookupProjectSpecForLoad
        , MetacelloProjectSpecLoadedNotification
        , MetacelloScriptEnsureProjectLoadedForDevelopment
        , MetacelloLookupBaselineSpecForEnsureLoad
    do: [ :ex | 
      "lookup and registration handlers need to be innermost set of handlers ...they may throw option notifications"
      ex handleResolutionFor: self ] ] in [ 
  [ 
  actionBlock
    on:
      MetacelloLookupProjectSpec , MetacelloLookupProjectSpecForLoad
        , MetacelloProjectSpecLoadedNotification
        , MetacelloScriptEnsureProjectLoadedForDevelopment
        , MetacelloLookupBaselineSpecForEnsureLoad
    do: [ :ex | 
      "lookup and registration handlers need to be innermost set of handlers ...they may throw option notifications"
      ex handleResolutionFor: self ] ]
    on:
      MetacelloAllowProjectDowngrade , MetacelloAllowProjectUpgrade
        , MetacelloAllowConflictingProjectUpgrade
    do: [ :ex | 
      "option handlers need to be outermost set of handlers ... last line of defense before users are involved"
      ex handleResolutionFor: self ] ] in [ 
  [ 
  [ 
  actionBlock
    on:
      MetacelloLookupProjectSpec , MetacelloLookupProjectSpecForLoad
        , MetacelloProjectSpecLoadedNotification
        , MetacelloScriptEnsureProjectLoadedForDevelopment
        , MetacelloLookupBaselineSpecForEnsureLoad
    do: [ :ex | 
      "lookup and registration handlers need to be innermost set of handlers ...they may throw option notifications"
      ex handleResolutionFor: self ] ]
    on:
      MetacelloAllowProjectDowngrade , MetacelloAllowProjectUpgrade
        , MetacelloAllowConflictingProjectUpgrade
    do: [ :ex | 
      "option handlers need to be outermost set of handlers ... last line of defense before users are involved"
      ex handleResolutionFor: self ] ]
    on: MetacelloAllowLockedProjectChange
    do: [ :ex | 
      "MetacelloAllowLockedProjectChange need to be outermost handler ... since it is signaled from second line of handlers"
      ex handleResolutionFor: self ] ] in MetacelloScriptEngine>>handleNotificationsForAction:
FullBlockClosure(BlockClosure)>>on:do:
[ 
  [ 
  actionBlock
    on:
      MetacelloLookupProjectSpec , MetacelloLookupProjectSpecForLoad
        , MetacelloProjectSpecLoadedNotification
        , MetacelloScriptEnsureProjectLoadedForDevelopment
        , MetacelloLookupBaselineSpecForEnsureLoad
    do: [ :ex | 
      "lookup and registration handlers need to be innermost set of handlers ...they may throw option notifications"
      ex handleResolutionFor: self ] ]
    on:
      MetacelloAllowProjectDowngrade , MetacelloAllowProjectUpgrade
        , MetacelloAllowConflictingProjectUpgrade
    do: [ :ex | 
      "option handlers need to be outermost set of handlers ... last line of defense before users are involved"
      ex handleResolutionFor: self ] ] in [ 
  [ 
  [ 
  actionBlock
    on:
      MetacelloLookupProjectSpec , MetacelloLookupProjectSpecForLoad
        , MetacelloProjectSpecLoadedNotification
        , MetacelloScriptEnsureProjectLoadedForDevelopment
        , MetacelloLookupBaselineSpecForEnsureLoad
    do: [ :ex | 
      "lookup and registration handlers need to be innermost set of handlers ...they may throw option notifications"
      ex handleResolutionFor: self ] ]
    on:
      MetacelloAllowProjectDowngrade , MetacelloAllowProjectUpgrade
        , MetacelloAllowConflictingProjectUpgrade
    do: [ :ex | 
      "option handlers need to be outermost set of handlers ... last line of defense before users are involved"
      ex handleResolutionFor: self ] ]
    on: MetacelloAllowLockedProjectChange
    do: [ :ex | 
      "MetacelloAllowLockedProjectChange need to be outermost handler ... since it is signaled from second line of handlers"
      ex handleResolutionFor: self ] ] in MetacelloScriptEngine>>handleNotificationsForAction:
 - - - - - - - - - - - - - - -
			- - - - - - - - - - - - - - - - - -
FullBlockClosure(BlockClosure)>>on:do:
[ 
  [ 
  [ 
  actionBlock
    on:
      MetacelloLookupProjectSpec , MetacelloLookupProjectSpecForLoad
        , MetacelloProjectSpecLoadedNotification
        , MetacelloScriptEnsureProjectLoadedForDevelopment
        , MetacelloLookupBaselineSpecForEnsureLoad
    do: [ :ex | 
      "lookup and registration handlers need to be innermost set of handlers ...they may throw option notifications"
      ex handleResolutionFor: self ] ]
    on:
      MetacelloAllowProjectDowngrade , MetacelloAllowProjectUpgrade
        , MetacelloAllowConflictingProjectUpgrade
    do: [ :ex | 
      "option handlers need to be outermost set of handlers ... last line of defense before users are involved"
      ex handleResolutionFor: self ] ]
    on: MetacelloAllowLockedProjectChange
    do: [ :ex | 
      "MetacelloAllowLockedProjectChange need to be outermost handler ... since it is signaled from second line of handlers"
      ex handleResolutionFor: self ] ] in MetacelloScriptEngine>>handleNotificationsForAction:
FullBlockClosure(BlockClosure)>>on:do:
MetacelloScriptEngine>>handleNotificationsForAction:
[ 
      self
        handleNotificationsForAction: [ 
          | version loadedSpec |
          self setDefaultsAndValidateProjectSpec.
          [ loadedSpec := (self lookupProjectSpecFor: self projectSpec) copy ]
            on: MetacelloAllowProjectDowngrade , MetacelloAllowProjectUpgrade
            do: [ :ex | ex handleOnDownGrade: onDownGradeBlock onUpgrade: onUpgradeBlock ].
          version := loadedSpec versionForScriptEngine: self.
          self
            root:
              (required isEmpty
                ifTrue: [ version load ]
                ifFalse: [ version load: required ]) loadDirective.
          loadedSpec loads: required.
          MetacelloProjectRegistration
            registrationForProjectSpec: loadedSpec
            ifAbsent: [ :new | 
              new
                loadedInImage: true;
                registerProject ]
            ifPresent: [ :existing :new | 
              existing
                copyOnWrite: [ :existingCopy | 
                  existingCopy
                    loadedInImage: true;
                    merge: new ] ] ] ] in MetacelloScriptEngine>>load:onProjectDownGrade:onProjectUpgrade:
FullBlockClosure(BlockClosure)>>ensure:
MetacelloProjectRegistration class>>copyRegistryRestoreOnErrorWhile:
MetacelloScriptEngine>>load:onProjectDownGrade:onProjectUpgrade:
MetacelloScriptEngine>>load:
[ :projectSpec | 
      | engine |
      engine := MetacelloScriptEngine new
        options: self options copy;
        projectSpec: projectSpec;
        yourself.
      engine perform: actionArg key withArguments: actionArg value.
      engine root ifNotNil: [ :root | self roots add: root ] ] in MetacelloScriptApiExecutor(MetacelloScriptExecutor)>>execute:
[ :projectSpec | 
      projectSpec
        ifNotNil: [ projectSpecBlock value: (self applyArgsToProjectSpec: projectSpec copy) ] ] in MetacelloScriptApiExecutor>>executeString:do:
Array(SequenceableCollection)>>do:
MetacelloScriptApiExecutor>>executeString:do:
ByteString(String)>>execute:against:
MetacelloScriptApiExecutor(MetacelloScriptExecutor)>>execute:
[ 
		super execute: statements ] in MetacelloScriptApiExecutor>>execute:
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in IceMetacelloLoadSessionContext(DynamicVariable)>>value:during:
FullBlockClosure(BlockClosure)>>ensure:
IceMetacelloLoadSessionContext(DynamicVariable)>>value:during:
IceMetacelloLoadSessionContext class(DynamicVariable class)>>value:during:
IceMetacelloPharoPlatform>>withMetacelloLoadSessionDo:
MetacelloScriptApiExecutor>>execute:
Metacello>>execute:args:
Metacello>>load
UndefinedObject>>DoIt
OCReceiverDoItSemanticScope(OCDoItSemanticScope)>>evaluateDoIt:
OpalCompiler>>evaluate
[
		self announcer announce: (SpCodeWillBeEvaluatedAnnouncement newContent: aString).
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionModel doItReceiver.
		result := receiver class compiler
			source: aString;
			context: self interactionModel doItContext;
			receiver: self interactionModel doItReceiver;
			requestor: self interactionModel;
			environment: self environment;
			failBlock:  [ 
				self announcer announce: (SpCodeEvaluationFailedAnnouncement newContent: aString).
				^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		self announcer announce: (SpCodeEvaluationSucceedAnnouncement newContent: aString).
		result ] in SpCodePresenter>>evaluate:onCompileError:onError:
FullBlockClosure(BlockClosure)>>on:do:
SpCodePresenter>>evaluate:onCompileError:onError:
StPlaygroundPagePresenter>>doEvaluateAndGo
StPlaygroundPagePresenter>>doEvaluateAllAndGo
StPlaygroundDoItCommand>>execute
SpCommand(CmCommandDecorator)>>execute
[ specCommand execute ] in [ :specCommand | 
			aButtonClass new
				label: specCommand name;
				help: specCommand description;
				in: [ :button | 
					specCommand hasIcon
						ifTrue: [ button icon: specCommand icon ] ];
				action: [ specCommand execute ];
				yourself ] in SpCommand>>configureAsButtonOfClass:
FullBlockClosure(BlockClosure)>>cull:
SpMorphicToolbarButtonAdapter>>execute
SpToolbarButtonMorph(PluggableButtonMorph)>>performAction:
[:m |
		(m containsPoint: evt cursorPoint) ifTrue: [m enabled ifTrue: [ m performAction: evt ]]] in SpToolbarButtonMorph(PluggableButtonMorph)>>mouseUp:
Array(SequenceableCollection)>>do:
SpToolbarButtonMorph(PluggableButtonMorph)>>mouseUp:
SpToolbarButtonMorph(Morph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
SpToolbarButtonMorph(Morph)>>handleEvent:
SpToolbarButtonMorph(Morph)>>handleFocusEvent:
[
		result := focusHolder handleFocusEvent: transformedEvent.
	] in HandMorph>>sendFocusEvent:to:clear:
FullBlockClosure(BlockClosure)>>on:do:
WorldMorph>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil ]) ifTrue: [
			morphicWorld activeHand handleEvent: anEvent
		]
	] in OSWindowMorphicEventHandler>>dispatchMorphicEvent:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycleNow
WorldMorph>>doOneCycle
[
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMutex critical: [
			                     self extraWorldList ].
		extraWorldsToDraw do: [ :world | world doOneCycle ].

		(self currentWorld isNotNil and: [
			 (extraWorldsToDraw includes: self currentWorld) not ]) ifTrue: [
			self currentWorld doOneCycle ] ] in WorldMorph class>>doOneCycle
FullBlockClosure(BlockClosure)>>ensure:
WorldState class>>doDrawCycleWith:
WorldMorph class>>doOneCycle
MorphicRenderLoop>>doOneCycle
MorphicRenderLoop>>doOneCycleWhile:
[ MorphicRenderLoop new doOneCycleWhile: [ true ] ] in MorphicUIManager>>spawnNewProcess
[self value.
			"IMPORTANT: Do not step over next line of code. See method comments for details"
			Processor terminateRealActive] in FullBlockClosure(BlockClosure)>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
Could not resolve: BaselineOfJSON [BaselineOfJSON] in /Users/ryanperez/Documents/Pharo/images/Visualizer/pharo-local/package-cache https://github.com/SvenVC/NeoJSON.git[master]
23 October 2023 11:00:48.564991 pm

VM: Mac OS - arm64 - 1000 - CoInterpreter VMMaker-tonel.1 uuid: 902dd483-c0c4-0d00-86f2-0f880df24b96 Oct 23 2023
StackToRegisterMappingCogit VMMaker-tonel.1 uuid: 902dd483-c0c4-0d00-86f2-0f880df24b96 Oct 23 2023
v10.0.8 - Commit: b323c5fb - Date: 2023-10-20 16:02:07 -0400

Image: Pharo11.0.0 [Build information: Pharo-11.0.0+build.710.sha.ea28d8552cac85a7ce1e9c34ab1e7bd45f7b9910 (64 Bit)]

MetacelloFetchingMCSpecLoader(MetacelloCommonMCSpecLoader)>>retryingResolvePackageSpecReferences:gofer:
	Receiver: a MetacelloFetchingMCSpecLoader(explicit load : BaselineOfJSON)
	Arguments and temporary variables: 
		packageSpec: 	spec 
	name: 'BaselineOfJSON';
	repository: 'github://SvenVC/N[..]
		gofer: 	a MetacelloGofer
		references: 	#()
		retryCount: 	3
		repositoryError: 	nil
	Receiver's instance variables: 
		spec: 	spec 
	name: 'BaselineOfJSON';
	repository: 'github://SvenVC/NeoJSON/[..]
		operator: 	nil
		loaderPolicy: 	a MetacelloLoaderPolicy
		disablePackageCache: 	false


[ 
      | references nearestReference cachedReference externalReference mcVersion loadedVersionInfos |
      cachedReference := nil.
      packageSpec
        searchCacheRepositoryForPackage: [ 
          "check to see if mcz file is already in cacheRepository"
          cachedReference := self
            resolvePackageSpec: packageSpec
            cachedGofer: self loaderPolicy cacheGofer.
          (cachedReference ~~ nil and: [ packageSpec getFile ~~ nil ])
            ifTrue: [ 
              cachedReference name = packageSpec file
                ifTrue: [ 
                  "exact match between packageSpec file and cache"
                  ^ self
                    scheduleFetchFor: packageSpec
                    cachedReference: cachedReference ] ] ].
      references := self
        retryingResolvePackageSpecReferences: packageSpec
        gofer: gofer.	"look up mcz file"
      nearestReference := references last asMetacelloCachingResolvedReference.
      (cachedReference ~~ nil
        and: [ cachedReference name = nearestReference name ])
        ifTrue: [ 
          "latest reference in repository matches cachedReference ... "
          ^ self
            scheduleFetchFor: packageSpec
            nearestReference: nearestReference ].
      (self ignoreImage not
        and: [ (loadedVersionInfos := self ancestorsFor: packageSpec) ~~ nil ])
        ifTrue: [ 
          "If the mcz is already loaded into the image, no need to copy"
          loadedVersionInfos
            do: [ :info | 
              info name = nearestReference name
                ifTrue: [ 
                  | spc |
                  spc := packageSpec copy.
                  spc file: info name.
                  (MetacelloIgnorePackageLoaded signal: spc)
                    ifFalse: [ ^ self ] ] ] ].
      externalReference := (references
        select: [ :ref | ref name = nearestReference name ]) first
        asMetacelloCachingResolvedReference.
      self repositoryMap
        at: externalReference name
        put: externalReference repository.
      (self
        resolveDependencies: externalReference
        nearest: nearestReference
        into: (OrderedCollection with: nearestReference))
        do: [ :reference | 
          | pSpec l |
          mcVersion := reference version.
          (l := (GoferVersionReference name: reference name)
            resolveAllWith: self loaderPolicy cacheGofer) isEmpty
            ifTrue: [ 
              self cacheRepository storeVersion: mcVersion.
              reference == nearestReference
                ifTrue: [ pSpec := packageSpec ]
                ifFalse: [ 
                  pSpec := packageSpec project packageSpec.
                  pSpec name: mcVersion package name ].
              self loadData
                addVersion: mcVersion
                versionInfo: mcVersion info
                resolvedReference: reference
                packageSpec: pSpec ] ].
      self scheduleFetchFor: packageSpec externalReference: externalReference ] in MetacelloFetchingMCSpecLoader>>linearLoadPackageSpec:gofer:
	Receiver: a MetacelloFetchingMCSpecLoader(explicit load : BaselineOfJSON)
	Arguments and temporary variables: 
		packageSpec: 	spec 
	name: 'BaselineOfJSON';
	repository: 'github://SvenVC/N[..]
		gofer: 	a MetacelloGofer
		cachedReference: 	nil
		mcVersion: 	nil
		references: 	nil
		nearestReference: 	nil
		externalReference: 	nil
		loadedVersionInfos: 	nil
	Receiver's instance variables: 
		spec: 	spec 
	name: 'BaselineOfJSON';
	repository: 'github://SvenVC/NeoJSON/[..]
		operator: 	nil
		loaderPolicy: 	a MetacelloLoaderPolicy
		disablePackageCache: 	false


[:bar |
            bar value: 1.
            aBlock value.
            bar value: 2 ] in IceMetacelloPharoPlatform(MetacelloPharoCommonPlatform)>>do:displaying:
	Receiver: an IceMetacelloPharoPlatform
	Arguments and temporary variables: 
		aBlock: 	[ 
      | references nearestReference cachedReference externalRefe[..]
		aString: 	'Fetching BaselineOfJSON'
		bar: 	a Job
	Receiver's instance variables: 
		bypassProgressBars: 	false
		bypassGoferLoadUpdateCategories: 	false


FullBlockClosure(BlockClosure)>>cull:
	Receiver: [:bar |
            bar value: 1.
            aBlock value.
            bar value: 2 ]
	Arguments and temporary variables: 
		anArg: 	a Job
	Receiver's instance variables: 
		outerContext: 	IceMetacelloPharoPlatform(MetacelloPharoCommonPlatform)>>do:d[..]
		compiledBlock: 	a CompiledBlock: [:bar |
            bar value: 1.
         [..]
		numArgs: 	1
		receiver: 	an IceMetacelloPharoPlatform


[ ^ block cull: self ] in [ self prepareForRunning.
	  CurrentJob value: self during: [ ^ block cull: self ] ] in Job>>run
	Receiver: a Job
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		block: 	[:bar |
            bar value: 1.
            aBlock value.
        [..]
		currentValue: 	1
		min: 	0
		max: 	2
		title: 	'Fetching BaselineOfJSON'
		children: 	an OrderedCollection()
		isRunning: 	true
		parent: 	nil
		process: 	a Process in nil
		owner: 	a MorphicUIManager


[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in CurrentJob(DynamicVariable)>>value:during:
	Receiver: a CurrentJob
	Arguments and temporary variables: 
		anObject: 	a Job
		aBlock: 	[ ^ block cull: self ]
		activeProcess: 	a Process in nil
		oldValue: 	nil
	Receiver's instance variables: 
		index: 	2


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ]
	Arguments and temporary variables: 
		aBlock: 	[
			activeProcess
				psValueAt: index
				put: oldValue ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	CurrentJob(DynamicVariable)>>value:during:
		compiledBlock: 	a CompiledBlock: [ activeProcess
			psValueAt: index
			put:[..]
		numArgs: 	0
		receiver: 	a CurrentJob


CurrentJob(DynamicVariable)>>value:during:
	Receiver: a CurrentJob
	Arguments and temporary variables: 
		anObject: 	a Job
		aBlock: 	[ ^ block cull: self ]
		activeProcess: 	a Process in nil
		oldValue: 	nil
	Receiver's instance variables: 
		index: 	2


CurrentJob class(DynamicVariable class)>>value:during:
	Receiver: CurrentJob
	Arguments and temporary variables: 
		anObject: 	a Job
		aBlock: 	[ ^ block cull: self ]
	Receiver's instance variables: 
		superclass: 	DynamicVariable
		methodDict: 	a MethodDictionary()
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		commentSourcePointer: 	nil
		subclasses: 	nil
		name: 	#CurrentJob
		classPool: 	nil
		sharedPools: 	nil
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Jobs-Base'
		soleInstance: 	a CurrentJob


[ self prepareForRunning.
	  CurrentJob value: self during: [ ^ block cull: self ] ] in Job>>run
	Receiver: a Job
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		block: 	[:bar |
            bar value: 1.
            aBlock value.
        [..]
		currentValue: 	1
		min: 	0
		max: 	2
		title: 	'Fetching BaselineOfJSON'
		children: 	an OrderedCollection()
		isRunning: 	true
		parent: 	nil
		process: 	a Process in nil
		owner: 	a MorphicUIManager


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ self prepareForRunning.
	  CurrentJob value: self during: [ ^ block cull: self ] ]
	Arguments and temporary variables: 
		aBlock: 	[ self cleanupAfterRunning ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	Job>>run
		compiledBlock: 	a CompiledBlock: [ self prepareForRunning.
	  CurrentJob val[..]
		numArgs: 	0
		receiver: 	a Job


Job>>run
	Receiver: a Job
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		block: 	[:bar |
            bar value: 1.
            aBlock value.
        [..]
		currentValue: 	1
		min: 	0
		max: 	2
		title: 	'Fetching BaselineOfJSON'
		children: 	an OrderedCollection()
		isRunning: 	true
		parent: 	nil
		process: 	a Process in nil
		owner: 	a MorphicUIManager


MorphicUIManager(UIManager)>>displayProgress:from:to:during:
	Receiver: a MorphicUIManager
	Arguments and temporary variables: 
		titleString: 	'Fetching BaselineOfJSON'
		minVal: 	0
		maxVal: 	2
		workBlock: 	[:bar |
            bar value: 1.
            aBlock value.
    [..]
	Receiver's instance variables: 
		activeTranscript: 	nil


ByteString(String)>>displayProgressFrom:to:during:
	Receiver: 'Fetching BaselineOfJSON'
	Arguments and temporary variables: 
		minVal: 	0
		maxVal: 	2
		workBlock: 	[:bar |
            bar value: 1.
            aBlock value.
    [..]
	Receiver's instance variables: 
'Fetching BaselineOfJSON'

IceMetacelloPharoPlatform(MetacelloPharoCommonPlatform)>>do:displaying:
	Receiver: an IceMetacelloPharoPlatform
	Arguments and temporary variables: 
		aBlock: 	[ 
      | references nearestReference cachedReference externalRefe[..]
		aString: 	'Fetching BaselineOfJSON'
	Receiver's instance variables: 
		bypassProgressBars: 	false
		bypassGoferLoadUpdateCategories: 	false


MetacelloFetchingMCSpecLoader>>linearLoadPackageSpec:gofer:
	Receiver: a MetacelloFetchingMCSpecLoader(explicit load : BaselineOfJSON)
	Arguments and temporary variables: 
		packageSpec: 	spec 
	name: 'BaselineOfJSON';
	repository: 'github://SvenVC/N[..]
		gofer: 	a MetacelloGofer
	Receiver's instance variables: 
		spec: 	spec 
	name: 'BaselineOfJSON';
	repository: 'github://SvenVC/NeoJSON/[..]
		operator: 	nil
		loaderPolicy: 	a MetacelloLoaderPolicy
		disablePackageCache: 	false


MetacelloPackageSpec>>loadUsing:gofer:
	Receiver: spec 
	name: 'BaselineOfJSON';
	repository: 'github://SvenVC/NeoJSON/repository'.
	Arguments and temporary variables: 
		aLoader: 	a MetacelloFetchingMCSpecLoader(explicit load : BaselineOfJSON)
		gofer: 	a MetacelloGofer
	Receiver's instance variables: 
		project: 	<<error during printing>>

[:pkg | pkg loadUsing: self gofer: gofer ] in MetacelloFetchingMCSpecLoader(MetacelloCommonMCSpecLoader)>>linearLoadPackageSpecs:repositories:
	Receiver: a MetacelloFetchingMCSpecLoader(explicit load : BaselineOfJSON)
	Arguments and temporary variables: 
		packageSpecs: 	an Array(spec 
	name: 'BaselineOfJSON';
	repository: 'github:[..]
		repositories: 	an OrderedCollection(an IceMetacelloRepositoryAdapter)
		gofer: 	a MetacelloGofer
		pkg: 	spec 
	name: 'BaselineOfJSON';
	repository: 'github://SvenVC/NeoJSON/r[..]
	Receiver's instance variables: 
		spec: 	spec 
	name: 'BaselineOfJSON';
	repository: 'github://SvenVC/NeoJSON/[..]
		operator: 	nil
		loaderPolicy: 	a MetacelloLoaderPolicy
		disablePackageCache: 	false


Array(SequenceableCollection)>>do:
	Receiver: an Array(spec 
	name: 'BaselineOfJSON';
	repository: 'github://SvenVC/NeoJSON/reposito[..]
	Arguments and temporary variables: 
		aBlock: 	[:pkg | pkg loadUsing: self gofer: gofer ]
		index: 	1
	Receiver's instance variables: 
an Array(spec 
	name: 'BaselineOfJSON';
	repository: 'github://SvenVC/NeoJSON/reposito[..]

MetacelloFetchingMCSpecLoader(MetacelloCommonMCSpecLoader)>>linearLoadPackageSpecs:repositories:
	Receiver: a MetacelloFetchingMCSpecLoader(explicit load : BaselineOfJSON)
	Arguments and temporary variables: 
		packageSpecs: 	an Array(spec 
	name: 'BaselineOfJSON';
	repository: 'github:[..]
		repositories: 	an OrderedCollection(an IceMetacelloRepositoryAdapter)
		gofer: 	a MetacelloGofer
	Receiver's instance variables: 
		spec: 	spec 
	name: 'BaselineOfJSON';
	repository: 'github://SvenVC/NeoJSON/[..]
		operator: 	nil
		loaderPolicy: 	a MetacelloLoaderPolicy
		disablePackageCache: 	false


[ super linearLoadPackageSpecs: packageSpecs repositories: repositories ] in MetacelloFetchingMCSpecLoader>>explicitLoadPackageSpecs:repositories:
	Receiver: a MetacelloFetchingMCSpecLoader(explicit load : BaselineOfJSON)
	Arguments and temporary variables: 
		packageSpecs: 	an Array(spec 
	name: 'BaselineOfJSON';
	repository: 'github:[..]
		repositories: 	an OrderedCollection(an IceMetacelloRepositoryAdapter)
		directive: 	nil
	Receiver's instance variables: 
		spec: 	spec 
	name: 'BaselineOfJSON';
	repository: 'github://SvenVC/NeoJSON/[..]
		operator: 	nil
		loaderPolicy: 	a MetacelloLoaderPolicy
		disablePackageCache: 	false


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ super linearLoadPackageSpecs: packageSpecs repositories: repositories ]
	Arguments and temporary variables: 
		aBlock: 	[ loadDirective := oldRoot ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	MetacelloFetchingMCSpecLoader>>explicitLoadPackageSpecs:repos[..]
		compiledBlock: 	a CompiledBlock: [ super linearLoadPackageSpecs: packageSpec[..]
		numArgs: 	0
		receiver: 	a MetacelloFetchingMCSpecLoader(explicit load : BaselineOfJSON)


MetacelloLoaderPolicy>>pushLoadDirective:during:
	Receiver: a MetacelloLoaderPolicy
	Arguments and temporary variables: 
		aLoaderDirective: 	explicit load : BaselineOfJSON
		aBlock: 	[ super linearLoadPackageSpecs: packageSpecs repositories: reposito[..]
		oldRoot: 	linear load : 
	explicit load : BaselineOfJSON
	Receiver's instance variables: 
		overrideRepositories: 	nil
		repositoryMap: 	a Dictionary()
		ensuredMap: 	a Dictionary()
		cacheRepository: 	a MCDictionaryRepository(cache)
		cacheGofer: 	a Gofer
		ignoreImage: 	false
		loadData: 	nil
		loadDirective: 	explicit load : BaselineOfJSON
		silently: 	nil


MetacelloLoaderPolicy>>pushExplicitLoadDirectivesDuring:for:
	Receiver: a MetacelloLoaderPolicy
	Arguments and temporary variables: 
		aBlock: 	[ super linearLoadPackageSpecs: packageSpecs repositories: reposito[..]
		aLoader: 	a MetacelloFetchingMCSpecLoader(explicit load : BaselineOfJSON)
		directive: 	explicit load : BaselineOfJSON
	Receiver's instance variables: 
		overrideRepositories: 	nil
		repositoryMap: 	a Dictionary()
		ensuredMap: 	a Dictionary()
		cacheRepository: 	a MCDictionaryRepository(cache)
		cacheGofer: 	a Gofer
		ignoreImage: 	false
		loadData: 	nil
		loadDirective: 	explicit load : BaselineOfJSON
		silently: 	nil


MetacelloFetchingMCSpecLoader>>explicitLoadPackageSpecs:repositories:
	Receiver: a MetacelloFetchingMCSpecLoader(explicit load : BaselineOfJSON)
	Arguments and temporary variables: 
		packageSpecs: 	an Array(spec 
	name: 'BaselineOfJSON';
	repository: 'github:[..]
		repositories: 	an OrderedCollection(an IceMetacelloRepositoryAdapter)
		directive: 	nil
	Receiver's instance variables: 
		spec: 	spec 
	name: 'BaselineOfJSON';
	repository: 'github://SvenVC/NeoJSON/[..]
		operator: 	nil
		loaderPolicy: 	a MetacelloLoaderPolicy
		disablePackageCache: 	false


MetacelloPackageSpec>>explicitLoadUsing:
	Receiver: spec 
	name: 'BaselineOfJSON';
	repository: 'github://SvenVC/NeoJSON/repository'.
	Arguments and temporary variables: 
		mcLoader: 	a MetacelloLoadingMCSpecLoader
		wc: 	nil
		fetchingSpecLoader: 	a MetacelloFetchingMCSpecLoader(explicit load : Baselin[..]
	Receiver's instance variables: 
		project: 	<<error during printing>>

MetacelloPackageSpec>>load
	Receiver: spec 
	name: 'BaselineOfJSON';
	repository: 'github://SvenVC/NeoJSON/repository'.
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		project: 	<<error during printing>>

[ spec projectPackage load ] in MetacelloScriptEngine>>getBaselineUnconditionalLoad:
	Receiver: a MetacelloScriptEngine
	Arguments and temporary variables: 
		unconditionalLoad: 	true
		spec: 	spec 
	name: 'JSON';
	repository: 'github://SvenVC/NeoJSON/repository'.
	Receiver's instance variables: 
		root: 	nil
		projectSpec: 	spec 
	name: 'JSON';
	repository: 'github://SvenVC/NeoJSON/rep[..]
		options: 	a Dictionary()


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [ spec projectPackage load ]
	Arguments and temporary variables: 
		exception: 	MetacelloIgnorePackageLoaded
		handlerAction: 	[ :ex | 
      "see https://github.com/dalehenrich/metacello[..]
	Receiver's instance variables: 
		outerContext: 	MetacelloScriptEngine>>getBaselineUnconditionalLoad:
		compiledBlock: 	a CompiledBlock: [ spec projectPackage load ]
		numArgs: 	0
		receiver: 	a MetacelloScriptEngine


MetacelloScriptEngine>>getBaselineUnconditionalLoad:
	Receiver: a MetacelloScriptEngine
	Arguments and temporary variables: 
		unconditionalLoad: 	true
		spec: 	spec 
	name: 'JSON';
	repository: 'github://SvenVC/NeoJSON/repository'.
	Receiver's instance variables: 
		root: 	nil
		projectSpec: 	spec 
	name: 'JSON';
	repository: 'github://SvenVC/NeoJSON/rep[..]
		options: 	a Dictionary()


MetacelloScriptEngine>>getBaselineProjectUnconditionalLoad:
	Receiver: a MetacelloScriptEngine
	Arguments and temporary variables: 
		unconditionalLoad: 	true
		project: 	nil
	Receiver's instance variables: 
		root: 	nil
		projectSpec: 	spec 
	name: 'JSON';
	repository: 'github://SvenVC/NeoJSON/rep[..]
		options: 	a Dictionary()


MetacelloMCBaselineProject>>projectForScriptEngine:unconditionalLoad:
	Receiver: <<error during printing>>
	Arguments and temporary variables: 
		aMetacelloScriptEngine: 	a MetacelloScriptEngine
		aBool: 	false
	Receiver's instance variables: 
		versionMap: 	nil
		symbolicVersionMap: 	nil
		errorMap: 	nil
		loader: 	nil
		loaderClass: 	MetacelloLoadingMCSpecLoader
		loadType: 	nil
		configuration: 	<<error during printing>>

MetacelloMCBaselineProject(MetacelloProject)>>projectForScriptEngine:
	Receiver: <<error during printing>>
	Arguments and temporary variables: 
		aMetacelloScriptEngine: 	a MetacelloScriptEngine
	Receiver's instance variables: 
		versionMap: 	nil
		symbolicVersionMap: 	nil
		errorMap: 	nil
		loader: 	nil
		loaderClass: 	MetacelloLoadingMCSpecLoader
		loadType: 	nil
		configuration: 	<<error during printing>>

MetacelloMCBaselineOfProjectSpec(MetacelloMCProjectSpec)>>versionForScriptEngine:
	Receiver: spec 
	name: 'JSON';
	repository: 'github://SvenVC/NeoJSON/repository'.
	Arguments and temporary variables: 
<<error during printing>>
	Receiver's instance variables: 
		project: 	<<error during printing>>

[ 
          | version loadedSpec |
          self setDefaultsAndValidateProjectSpec.
          [ loadedSpec := (self lookupProjectSpecFor: self projectSpec) copy ]
            on: MetacelloAllowProjectDowngrade , MetacelloAllowProjectUpgrade
            do: [ :ex | ex handleOnDownGrade: onDownGradeBlock onUpgrade: onUpgradeBlock ].
          version := loadedSpec versionForScriptEngine: self.
          self
            root:
              (required isEmpty
                ifTrue: [ version load ]
                ifFalse: [ version load: required ]) loadDirective.
          loadedSpec loads: required.
          MetacelloProjectRegistration
            registrationForProjectSpec: loadedSpec
            ifAbsent: [ :new | 
              new
                loadedInImage: true;
                registerProject ]
            ifPresent: [ :existing :new | 
              existing
                copyOnWrite: [ :existingCopy | 
                  existingCopy
                    loadedInImage: true;
                    merge: new ] ] ] in [ 
      self
        handleNotificationsForAction: [ 
          | version loadedSpec |
          self setDefaultsAndValidateProjectSpec.
          [ loadedSpec := (self lookupProjectSpecFor: self projectSpec) copy ]
            on: MetacelloAllowProjectDowngrade , MetacelloAllowProjectUpgrade
            do: [ :ex | ex handleOnDownGrade: onDownGradeBlock onUpgrade: onUpgradeBlock ].
          version := loadedSpec versionForScriptEngine: self.
          self
            root:
              (required isEmpty
                ifTrue: [ version load ]
                ifFalse: [ version load: required ]) loadDirective.
          loadedSpec loads: required.
          MetacelloProjectRegistration
            registrationForProjectSpec: loadedSpec
            ifAbsent: [ :new | 
              new
                loadedInImage: true;
                registerProject ]
            ifPresent: [ :existing :new | 
              existing
                copyOnWrite: [ :existingCopy | 
                  existingCopy
                    loadedInImage: true;
                    merge: new ] ] ] ] in MetacelloScriptEngine>>load:onProjectDownGrade:onProjectUpgrade:
	Receiver: a MetacelloScriptEngine
	Arguments and temporary variables: 
		required: 	#()
		onDownGradeBlock: 	[ :ex :existing :new | ex allowEvenIfLocked ]
		onUpgradeBlock: 	[ :ex :existing :new | ex allowEvenIfLocked ]
		loadedSpec: 	spec 
	name: 'JSON';
	repository: 'github://SvenVC/NeoJSON/repo[..]
		version: 	nil
	Receiver's instance variables: 
		root: 	nil
		projectSpec: 	spec 
	name: 'JSON';
	repository: 'github://SvenVC/NeoJSON/rep[..]
		options: 	a Dictionary()


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [ 
          | version loadedSpec |
          self setDefaultsAndValidateProjectSpec.
[..]
	Arguments and temporary variables: 
		exception: 	an ExceptionSet
		handlerAction: 	[ :ex | 
      "lookup and registration handlers need to be [..]
	Receiver's instance variables: 
		outerContext: 	[ 
      self
        handleNotificationsForAction: [ 
      [..]
		compiledBlock: 	a CompiledBlock: [ 
          | version loadedSpec |
       [..]
		numArgs: 	0
		receiver: 	a MetacelloScriptEngine


[ 
  actionBlock
    on:
      MetacelloLookupProjectSpec , MetacelloLookupProjectSpecForLoad
        , MetacelloProjectSpecLoadedNotification
        , MetacelloScriptEnsureProjectLoadedForDevelopment
        , MetacelloLookupBaselineSpecForEnsureLoad
    do: [ :ex | 
      "lookup and registration handlers need to be innermost set of handlers ...they may throw option notifications"
      ex handleResolutionFor: self ] ] in [ 
  [ 
  actionBlock
    on:
      MetacelloLookupProjectSpec , MetacelloLookupProjectSpecForLoad
        , MetacelloProjectSpecLoadedNotification
        , MetacelloScriptEnsureProjectLoadedForDevelopment
        , MetacelloLookupBaselineSpecForEnsureLoad
    do: [ :ex | 
      "lookup and registration handlers need to be innermost set of handlers ...they may throw option notifications"
      ex handleResolutionFor: self ] ]
    on:
      MetacelloAllowProjectDowngrade , MetacelloAllowProjectUpgrade
        , MetacelloAllowConflictingProjectUpgrade
    do: [ :ex | 
      "option handlers need to be outermost set of handlers ... last line of defense before users are involved"
      ex handleResolutionFor: self ] ] in [ 
  [ 
  [ 
  actionBlock
    on:
      MetacelloLookupProjectSpec , MetacelloLookupProjectSpecForLoad
        , MetacelloProjectSpecLoadedNotification
        , MetacelloScriptEnsureProjectLoadedForDevelopment
        , MetacelloLookupBaselineSpecForEnsureLoad
    do: [ :ex | 
      "lookup and registration handlers need to be innermost set of handlers ...they may throw option notifications"
      ex handleResolutionFor: self ] ]
    on:
      MetacelloAllowProjectDowngrade , MetacelloAllowProjectUpgrade
        , MetacelloAllowConflictingProjectUpgrade
    do: [ :ex | 
      "option handlers need to be outermost set of handlers ... last line of defense before users are involved"
      ex handleResolutionFor: self ] ]
    on: MetacelloAllowLockedProjectChange
    do: [ :ex | 
      "MetacelloAllowLockedProjectChange need to be outermost handler ... since it is signaled from second line of handlers"
      ex handleResolutionFor: self ] ] in MetacelloScriptEngine>>handleNotificationsForAction:
	Receiver: a MetacelloScriptEngine
	Arguments and temporary variables: 
		actionBlock: 	[ 
          | version loadedSpec |
          self setDefaults[..]
	Receiver's instance variables: 
		root: 	nil
		projectSpec: 	spec 
	name: 'JSON';
	repository: 'github://SvenVC/NeoJSON/rep[..]
		options: 	a Dictionary()


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [ 
  actionBlock
    on:
      MetacelloLookupProjectSpec , MetacelloLookupProjectSpec[..]
	Arguments and temporary variables: 
		exception: 	an ExceptionSet
		handlerAction: 	[ :ex | 
      "option handlers need to be outermost set of [..]
	Receiver's instance variables: 
		outerContext: 	[ 
  [ 
  actionBlock
    on:
      MetacelloLookupProjectSpe[..]
		compiledBlock: 	a CompiledBlock: [ 
  actionBlock
    on:
      MetacelloLoo[..]
		numArgs: 	0
		receiver: 	a MetacelloScriptEngine


[ 
  [ 
  actionBlock
    on:
      MetacelloLookupProjectSpec , MetacelloLookupProjectSpecForLoad
        , MetacelloProjectSpecLoadedNotification
        , MetacelloScriptEnsureProjectLoadedForDevelopment
        , MetacelloLookupBaselineSpecForEnsureLoad
    do: [ :ex | 
      "lookup and registration handlers need to be innermost set of handlers ...they may throw option notifications"
      ex handleResolutionFor: self ] ]
    on:
      MetacelloAllowProjectDowngrade , MetacelloAllowProjectUpgrade
        , MetacelloAllowConflictingProjectUpgrade
    do: [ :ex | 
      "option handlers need to be outermost set of handlers ... last line of defense before users are involved"
      ex handleResolutionFor: self ] ] in [ 
  [ 
  [ 
  actionBlock
    on:
      MetacelloLookupProjectSpec , MetacelloLookupProjectSpecForLoad
        , MetacelloProjectSpecLoadedNotification
        , MetacelloScriptEnsureProjectLoadedForDevelopment
        , MetacelloLookupBaselineSpecForEnsureLoad
    do: [ :ex | 
      "lookup and registration handlers need to be innermost set of handlers ...they may throw option notifications"
      ex handleResolutionFor: self ] ]
    on:
      MetacelloAllowProjectDowngrade , MetacelloAllowProjectUpgrade
        , MetacelloAllowConflictingProjectUpgrade
    do: [ :ex | 
      "option handlers need to be outermost set of handlers ... last line of defense before users are involved"
      ex handleResolutionFor: self ] ]
    on: MetacelloAllowLockedProjectChange
    do: [ :ex | 
      "MetacelloAllowLockedProjectChange need to be outermost handler ... since it is signaled from second line of handlers"
      ex handleResolutionFor: self ] ] in MetacelloScriptEngine>>handleNotificationsForAction:
	Receiver: a MetacelloScriptEngine
	Arguments and temporary variables: 
		actionBlock: 	[ 
          | version loadedSpec |
          self setDefaults[..]
	Receiver's instance variables: 
		root: 	nil
		projectSpec: 	spec 
	name: 'JSON';
	repository: 'github://SvenVC/NeoJSON/rep[..]
		options: 	a Dictionary()



--- The full stack ---
MetacelloFetchingMCSpecLoader(MetacelloCommonMCSpecLoader)>>retryingResolvePackageSpecReferences:gofer:
[ 
      | references nearestReference cachedReference externalReference mcVersion loadedVersionInfos |
      cachedReference := nil.
      packageSpec
        searchCacheRepositoryForPackage: [ 
          "check to see if mcz file is already in cacheRepository"
          cachedReference := self
            resolvePackageSpec: packageSpec
            cachedGofer: self loaderPolicy cacheGofer.
          (cachedReference ~~ nil and: [ packageSpec getFile ~~ nil ])
            ifTrue: [ 
              cachedReference name = packageSpec file
                ifTrue: [ 
                  "exact match between packageSpec file and cache"
                  ^ self
                    scheduleFetchFor: packageSpec
                    cachedReference: cachedReference ] ] ].
      references := self
        retryingResolvePackageSpecReferences: packageSpec
        gofer: gofer.	"look up mcz file"
      nearestReference := references last asMetacelloCachingResolvedReference.
      (cachedReference ~~ nil
        and: [ cachedReference name = nearestReference name ])
        ifTrue: [ 
          "latest reference in repository matches cachedReference ... "
          ^ self
            scheduleFetchFor: packageSpec
            nearestReference: nearestReference ].
      (self ignoreImage not
        and: [ (loadedVersionInfos := self ancestorsFor: packageSpec) ~~ nil ])
        ifTrue: [ 
          "If the mcz is already loaded into the image, no need to copy"
          loadedVersionInfos
            do: [ :info | 
              info name = nearestReference name
                ifTrue: [ 
                  | spc |
                  spc := packageSpec copy.
                  spc file: info name.
                  (MetacelloIgnorePackageLoaded signal: spc)
                    ifFalse: [ ^ self ] ] ] ].
      externalReference := (references
        select: [ :ref | ref name = nearestReference name ]) first
        asMetacelloCachingResolvedReference.
      self repositoryMap
        at: externalReference name
        put: externalReference repository.
      (self
        resolveDependencies: externalReference
        nearest: nearestReference
        into: (OrderedCollection with: nearestReference))
        do: [ :reference | 
          | pSpec l |
          mcVersion := reference version.
          (l := (GoferVersionReference name: reference name)
            resolveAllWith: self loaderPolicy cacheGofer) isEmpty
            ifTrue: [ 
              self cacheRepository storeVersion: mcVersion.
              reference == nearestReference
                ifTrue: [ pSpec := packageSpec ]
                ifFalse: [ 
                  pSpec := packageSpec project packageSpec.
                  pSpec name: mcVersion package name ].
              self loadData
                addVersion: mcVersion
                versionInfo: mcVersion info
                resolvedReference: reference
                packageSpec: pSpec ] ].
      self scheduleFetchFor: packageSpec externalReference: externalReference ] in MetacelloFetchingMCSpecLoader>>linearLoadPackageSpec:gofer:
[:bar |
            bar value: 1.
            aBlock value.
            bar value: 2 ] in IceMetacelloPharoPlatform(MetacelloPharoCommonPlatform)>>do:displaying:
FullBlockClosure(BlockClosure)>>cull:
[ ^ block cull: self ] in [ self prepareForRunning.
	  CurrentJob value: self during: [ ^ block cull: self ] ] in Job>>run
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in CurrentJob(DynamicVariable)>>value:during:
FullBlockClosure(BlockClosure)>>ensure:
CurrentJob(DynamicVariable)>>value:during:
CurrentJob class(DynamicVariable class)>>value:during:
[ self prepareForRunning.
	  CurrentJob value: self during: [ ^ block cull: self ] ] in Job>>run
FullBlockClosure(BlockClosure)>>ensure:
Job>>run
MorphicUIManager(UIManager)>>displayProgress:from:to:during:
ByteString(String)>>displayProgressFrom:to:during:
IceMetacelloPharoPlatform(MetacelloPharoCommonPlatform)>>do:displaying:
MetacelloFetchingMCSpecLoader>>linearLoadPackageSpec:gofer:
MetacelloPackageSpec>>loadUsing:gofer:
[:pkg | pkg loadUsing: self gofer: gofer ] in MetacelloFetchingMCSpecLoader(MetacelloCommonMCSpecLoader)>>linearLoadPackageSpecs:repositories:
Array(SequenceableCollection)>>do:
MetacelloFetchingMCSpecLoader(MetacelloCommonMCSpecLoader)>>linearLoadPackageSpecs:repositories:
[ super linearLoadPackageSpecs: packageSpecs repositories: repositories ] in MetacelloFetchingMCSpecLoader>>explicitLoadPackageSpecs:repositories:
FullBlockClosure(BlockClosure)>>ensure:
MetacelloLoaderPolicy>>pushLoadDirective:during:
MetacelloLoaderPolicy>>pushExplicitLoadDirectivesDuring:for:
MetacelloFetchingMCSpecLoader>>explicitLoadPackageSpecs:repositories:
MetacelloPackageSpec>>explicitLoadUsing:
MetacelloPackageSpec>>load
[ spec projectPackage load ] in MetacelloScriptEngine>>getBaselineUnconditionalLoad:
FullBlockClosure(BlockClosure)>>on:do:
MetacelloScriptEngine>>getBaselineUnconditionalLoad:
MetacelloScriptEngine>>getBaselineProjectUnconditionalLoad:
MetacelloMCBaselineProject>>projectForScriptEngine:unconditionalLoad:
MetacelloMCBaselineProject(MetacelloProject)>>projectForScriptEngine:
MetacelloMCBaselineOfProjectSpec(MetacelloMCProjectSpec)>>versionForScriptEngine:
[ 
          | version loadedSpec |
          self setDefaultsAndValidateProjectSpec.
          [ loadedSpec := (self lookupProjectSpecFor: self projectSpec) copy ]
            on: MetacelloAllowProjectDowngrade , MetacelloAllowProjectUpgrade
            do: [ :ex | ex handleOnDownGrade: onDownGradeBlock onUpgrade: onUpgradeBlock ].
          version := loadedSpec versionForScriptEngine: self.
          self
            root:
              (required isEmpty
                ifTrue: [ version load ]
                ifFalse: [ version load: required ]) loadDirective.
          loadedSpec loads: required.
          MetacelloProjectRegistration
            registrationForProjectSpec: loadedSpec
            ifAbsent: [ :new | 
              new
                loadedInImage: true;
                registerProject ]
            ifPresent: [ :existing :new | 
              existing
                copyOnWrite: [ :existingCopy | 
                  existingCopy
                    loadedInImage: true;
                    merge: new ] ] ] in [ 
      self
        handleNotificationsForAction: [ 
          | version loadedSpec |
          self setDefaultsAndValidateProjectSpec.
          [ loadedSpec := (self lookupProjectSpecFor: self projectSpec) copy ]
            on: MetacelloAllowProjectDowngrade , MetacelloAllowProjectUpgrade
            do: [ :ex | ex handleOnDownGrade: onDownGradeBlock onUpgrade: onUpgradeBlock ].
          version := loadedSpec versionForScriptEngine: self.
          self
            root:
              (required isEmpty
                ifTrue: [ version load ]
                ifFalse: [ version load: required ]) loadDirective.
          loadedSpec loads: required.
          MetacelloProjectRegistration
            registrationForProjectSpec: loadedSpec
            ifAbsent: [ :new | 
              new
                loadedInImage: true;
                registerProject ]
            ifPresent: [ :existing :new | 
              existing
                copyOnWrite: [ :existingCopy | 
                  existingCopy
                    loadedInImage: true;
                    merge: new ] ] ] ] in MetacelloScriptEngine>>load:onProjectDownGrade:onProjectUpgrade:
FullBlockClosure(BlockClosure)>>on:do:
[ 
  actionBlock
    on:
      MetacelloLookupProjectSpec , MetacelloLookupProjectSpecForLoad
        , MetacelloProjectSpecLoadedNotification
        , MetacelloScriptEnsureProjectLoadedForDevelopment
        , MetacelloLookupBaselineSpecForEnsureLoad
    do: [ :ex | 
      "lookup and registration handlers need to be innermost set of handlers ...they may throw option notifications"
      ex handleResolutionFor: self ] ] in [ 
  [ 
  actionBlock
    on:
      MetacelloLookupProjectSpec , MetacelloLookupProjectSpecForLoad
        , MetacelloProjectSpecLoadedNotification
        , MetacelloScriptEnsureProjectLoadedForDevelopment
        , MetacelloLookupBaselineSpecForEnsureLoad
    do: [ :ex | 
      "lookup and registration handlers need to be innermost set of handlers ...they may throw option notifications"
      ex handleResolutionFor: self ] ]
    on:
      MetacelloAllowProjectDowngrade , MetacelloAllowProjectUpgrade
        , MetacelloAllowConflictingProjectUpgrade
    do: [ :ex | 
      "option handlers need to be outermost set of handlers ... last line of defense before users are involved"
      ex handleResolutionFor: self ] ] in [ 
  [ 
  [ 
  actionBlock
    on:
      MetacelloLookupProjectSpec , MetacelloLookupProjectSpecForLoad
        , MetacelloProjectSpecLoadedNotification
        , MetacelloScriptEnsureProjectLoadedForDevelopment
        , MetacelloLookupBaselineSpecForEnsureLoad
    do: [ :ex | 
      "lookup and registration handlers need to be innermost set of handlers ...they may throw option notifications"
      ex handleResolutionFor: self ] ]
    on:
      MetacelloAllowProjectDowngrade , MetacelloAllowProjectUpgrade
        , MetacelloAllowConflictingProjectUpgrade
    do: [ :ex | 
      "option handlers need to be outermost set of handlers ... last line of defense before users are involved"
      ex handleResolutionFor: self ] ]
    on: MetacelloAllowLockedProjectChange
    do: [ :ex | 
      "MetacelloAllowLockedProjectChange need to be outermost handler ... since it is signaled from second line of handlers"
      ex handleResolutionFor: self ] ] in MetacelloScriptEngine>>handleNotificationsForAction:
FullBlockClosure(BlockClosure)>>on:do:
[ 
  [ 
  actionBlock
    on:
      MetacelloLookupProjectSpec , MetacelloLookupProjectSpecForLoad
        , MetacelloProjectSpecLoadedNotification
        , MetacelloScriptEnsureProjectLoadedForDevelopment
        , MetacelloLookupBaselineSpecForEnsureLoad
    do: [ :ex | 
      "lookup and registration handlers need to be innermost set of handlers ...they may throw option notifications"
      ex handleResolutionFor: self ] ]
    on:
      MetacelloAllowProjectDowngrade , MetacelloAllowProjectUpgrade
        , MetacelloAllowConflictingProjectUpgrade
    do: [ :ex | 
      "option handlers need to be outermost set of handlers ... last line of defense before users are involved"
      ex handleResolutionFor: self ] ] in [ 
  [ 
  [ 
  actionBlock
    on:
      MetacelloLookupProjectSpec , MetacelloLookupProjectSpecForLoad
        , MetacelloProjectSpecLoadedNotification
        , MetacelloScriptEnsureProjectLoadedForDevelopment
        , MetacelloLookupBaselineSpecForEnsureLoad
    do: [ :ex | 
      "lookup and registration handlers need to be innermost set of handlers ...they may throw option notifications"
      ex handleResolutionFor: self ] ]
    on:
      MetacelloAllowProjectDowngrade , MetacelloAllowProjectUpgrade
        , MetacelloAllowConflictingProjectUpgrade
    do: [ :ex | 
      "option handlers need to be outermost set of handlers ... last line of defense before users are involved"
      ex handleResolutionFor: self ] ]
    on: MetacelloAllowLockedProjectChange
    do: [ :ex | 
      "MetacelloAllowLockedProjectChange need to be outermost handler ... since it is signaled from second line of handlers"
      ex handleResolutionFor: self ] ] in MetacelloScriptEngine>>handleNotificationsForAction:
 - - - - - - - - - - - - - - -
			- - - - - - - - - - - - - - - - - -
FullBlockClosure(BlockClosure)>>on:do:
[ 
  [ 
  [ 
  actionBlock
    on:
      MetacelloLookupProjectSpec , MetacelloLookupProjectSpecForLoad
        , MetacelloProjectSpecLoadedNotification
        , MetacelloScriptEnsureProjectLoadedForDevelopment
        , MetacelloLookupBaselineSpecForEnsureLoad
    do: [ :ex | 
      "lookup and registration handlers need to be innermost set of handlers ...they may throw option notifications"
      ex handleResolutionFor: self ] ]
    on:
      MetacelloAllowProjectDowngrade , MetacelloAllowProjectUpgrade
        , MetacelloAllowConflictingProjectUpgrade
    do: [ :ex | 
      "option handlers need to be outermost set of handlers ... last line of defense before users are involved"
      ex handleResolutionFor: self ] ]
    on: MetacelloAllowLockedProjectChange
    do: [ :ex | 
      "MetacelloAllowLockedProjectChange need to be outermost handler ... since it is signaled from second line of handlers"
      ex handleResolutionFor: self ] ] in MetacelloScriptEngine>>handleNotificationsForAction:
FullBlockClosure(BlockClosure)>>on:do:
MetacelloScriptEngine>>handleNotificationsForAction:
[ 
      self
        handleNotificationsForAction: [ 
          | version loadedSpec |
          self setDefaultsAndValidateProjectSpec.
          [ loadedSpec := (self lookupProjectSpecFor: self projectSpec) copy ]
            on: MetacelloAllowProjectDowngrade , MetacelloAllowProjectUpgrade
            do: [ :ex | ex handleOnDownGrade: onDownGradeBlock onUpgrade: onUpgradeBlock ].
          version := loadedSpec versionForScriptEngine: self.
          self
            root:
              (required isEmpty
                ifTrue: [ version load ]
                ifFalse: [ version load: required ]) loadDirective.
          loadedSpec loads: required.
          MetacelloProjectRegistration
            registrationForProjectSpec: loadedSpec
            ifAbsent: [ :new | 
              new
                loadedInImage: true;
                registerProject ]
            ifPresent: [ :existing :new | 
              existing
                copyOnWrite: [ :existingCopy | 
                  existingCopy
                    loadedInImage: true;
                    merge: new ] ] ] ] in MetacelloScriptEngine>>load:onProjectDownGrade:onProjectUpgrade:
FullBlockClosure(BlockClosure)>>ensure:
MetacelloProjectRegistration class>>copyRegistryRestoreOnErrorWhile:
MetacelloScriptEngine>>load:onProjectDownGrade:onProjectUpgrade:
MetacelloScriptEngine>>load:
[ :projectSpec | 
      | engine |
      engine := MetacelloScriptEngine new
        options: self options copy;
        projectSpec: projectSpec;
        yourself.
      engine perform: actionArg key withArguments: actionArg value.
      engine root ifNotNil: [ :root | self roots add: root ] ] in MetacelloScriptApiExecutor(MetacelloScriptExecutor)>>execute:
[ :projectSpec | 
      projectSpec
        ifNotNil: [ projectSpecBlock value: (self applyArgsToProjectSpec: projectSpec copy) ] ] in MetacelloScriptApiExecutor>>executeString:do:
Array(SequenceableCollection)>>do:
MetacelloScriptApiExecutor>>executeString:do:
ByteString(String)>>execute:against:
MetacelloScriptApiExecutor(MetacelloScriptExecutor)>>execute:
[ 
		super execute: statements ] in MetacelloScriptApiExecutor>>execute:
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in IceMetacelloLoadSessionContext(DynamicVariable)>>value:during:
FullBlockClosure(BlockClosure)>>ensure:
IceMetacelloLoadSessionContext(DynamicVariable)>>value:during:
IceMetacelloLoadSessionContext class(DynamicVariable class)>>value:during:
IceMetacelloPharoPlatform>>withMetacelloLoadSessionDo:
MetacelloScriptApiExecutor>>execute:
Metacello>>execute:args:
Metacello>>load
UndefinedObject>>DoIt
OCReceiverDoItSemanticScope(OCDoItSemanticScope)>>evaluateDoIt:
OpalCompiler>>evaluate
[
		self announcer announce: (SpCodeWillBeEvaluatedAnnouncement newContent: aString).
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionModel doItReceiver.
		result := receiver class compiler
			source: aString;
			context: self interactionModel doItContext;
			receiver: self interactionModel doItReceiver;
			requestor: self interactionModel;
			environment: self environment;
			failBlock:  [ 
				self announcer announce: (SpCodeEvaluationFailedAnnouncement newContent: aString).
				^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		self announcer announce: (SpCodeEvaluationSucceedAnnouncement newContent: aString).
		result ] in SpCodePresenter>>evaluate:onCompileError:onError:
FullBlockClosure(BlockClosure)>>on:do:
SpCodePresenter>>evaluate:onCompileError:onError:
StPlaygroundPagePresenter>>doEvaluateAndGo
StPlaygroundPagePresenter>>doEvaluateAllAndGo
StPlaygroundDoItCommand>>execute
SpCommand(CmCommandDecorator)>>execute
[ specCommand execute ] in [ :specCommand | 
			aButtonClass new
				label: specCommand name;
				help: specCommand description;
				in: [ :button | 
					specCommand hasIcon
						ifTrue: [ button icon: specCommand icon ] ];
				action: [ specCommand execute ];
				yourself ] in SpCommand>>configureAsButtonOfClass:
FullBlockClosure(BlockClosure)>>cull:
SpMorphicToolbarButtonAdapter>>execute
SpToolbarButtonMorph(PluggableButtonMorph)>>performAction:
[:m |
		(m containsPoint: evt cursorPoint) ifTrue: [m enabled ifTrue: [ m performAction: evt ]]] in SpToolbarButtonMorph(PluggableButtonMorph)>>mouseUp:
Array(SequenceableCollection)>>do:
SpToolbarButtonMorph(PluggableButtonMorph)>>mouseUp:
SpToolbarButtonMorph(Morph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
SpToolbarButtonMorph(Morph)>>handleEvent:
SpToolbarButtonMorph(Morph)>>handleFocusEvent:
[
		result := focusHolder handleFocusEvent: transformedEvent.
	] in HandMorph>>sendFocusEvent:to:clear:
FullBlockClosure(BlockClosure)>>on:do:
WorldMorph>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil ]) ifTrue: [
			morphicWorld activeHand handleEvent: anEvent
		]
	] in OSWindowMorphicEventHandler>>dispatchMorphicEvent:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycleNow
WorldMorph>>doOneCycle
[
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMutex critical: [
			                     self extraWorldList ].
		extraWorldsToDraw do: [ :world | world doOneCycle ].

		(self currentWorld isNotNil and: [
			 (extraWorldsToDraw includes: self currentWorld) not ]) ifTrue: [
			self currentWorld doOneCycle ] ] in WorldMorph class>>doOneCycle
FullBlockClosure(BlockClosure)>>ensure:
WorldState class>>doDrawCycleWith:
WorldMorph class>>doOneCycle
MorphicRenderLoop>>doOneCycle
MorphicRenderLoop>>doOneCycleWhile:
[ MorphicRenderLoop new doOneCycleWhile: [ true ] ] in MorphicUIManager>>spawnNewProcess
[self value.
			"IMPORTANT: Do not step over next line of code. See method comments for details"
			Processor terminateRealActive] in FullBlockClosure(BlockClosure)>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
Could not resolve: BaselineOfJSON [BaselineOfJSON] in /Users/ryanperez/Documents/Pharo/images/Visualizer/pharo-local/package-cache https://github.com/SvenVC/NeoJSON.git[master]
23 October 2023 11:03:38.317776 pm

VM: Mac OS - arm64 - 1000 - CoInterpreter VMMaker-tonel.1 uuid: 902dd483-c0c4-0d00-86f2-0f880df24b96 Oct 23 2023
StackToRegisterMappingCogit VMMaker-tonel.1 uuid: 902dd483-c0c4-0d00-86f2-0f880df24b96 Oct 23 2023
v10.0.8 - Commit: b323c5fb - Date: 2023-10-20 16:02:07 -0400

Image: Pharo11.0.0 [Build information: Pharo-11.0.0+build.710.sha.ea28d8552cac85a7ce1e9c34ab1e7bd45f7b9910 (64 Bit)]

MetacelloFetchingMCSpecLoader(MetacelloCommonMCSpecLoader)>>retryingResolvePackageSpecReferences:gofer:
	Receiver: a MetacelloFetchingMCSpecLoader(explicit load : BaselineOfJSON)
	Arguments and temporary variables: 
		packageSpec: 	spec 
	name: 'BaselineOfJSON';
	repository: 'github://svenvc/N[..]
		gofer: 	a MetacelloGofer
		references: 	#()
		retryCount: 	3
		repositoryError: 	nil
	Receiver's instance variables: 
		spec: 	spec 
	name: 'BaselineOfJSON';
	repository: 'github://svenvc/NeoJSON/[..]
		operator: 	nil
		loaderPolicy: 	a MetacelloLoaderPolicy
		disablePackageCache: 	false


[ 
      | references nearestReference cachedReference externalReference mcVersion loadedVersionInfos |
      cachedReference := nil.
      packageSpec
        searchCacheRepositoryForPackage: [ 
          "check to see if mcz file is already in cacheRepository"
          cachedReference := self
            resolvePackageSpec: packageSpec
            cachedGofer: self loaderPolicy cacheGofer.
          (cachedReference ~~ nil and: [ packageSpec getFile ~~ nil ])
            ifTrue: [ 
              cachedReference name = packageSpec file
                ifTrue: [ 
                  "exact match between packageSpec file and cache"
                  ^ self
                    scheduleFetchFor: packageSpec
                    cachedReference: cachedReference ] ] ].
      references := self
        retryingResolvePackageSpecReferences: packageSpec
        gofer: gofer.	"look up mcz file"
      nearestReference := references last asMetacelloCachingResolvedReference.
      (cachedReference ~~ nil
        and: [ cachedReference name = nearestReference name ])
        ifTrue: [ 
          "latest reference in repository matches cachedReference ... "
          ^ self
            scheduleFetchFor: packageSpec
            nearestReference: nearestReference ].
      (self ignoreImage not
        and: [ (loadedVersionInfos := self ancestorsFor: packageSpec) ~~ nil ])
        ifTrue: [ 
          "If the mcz is already loaded into the image, no need to copy"
          loadedVersionInfos
            do: [ :info | 
              info name = nearestReference name
                ifTrue: [ 
                  | spc |
                  spc := packageSpec copy.
                  spc file: info name.
                  (MetacelloIgnorePackageLoaded signal: spc)
                    ifFalse: [ ^ self ] ] ] ].
      externalReference := (references
        select: [ :ref | ref name = nearestReference name ]) first
        asMetacelloCachingResolvedReference.
      self repositoryMap
        at: externalReference name
        put: externalReference repository.
      (self
        resolveDependencies: externalReference
        nearest: nearestReference
        into: (OrderedCollection with: nearestReference))
        do: [ :reference | 
          | pSpec l |
          mcVersion := reference version.
          (l := (GoferVersionReference name: reference name)
            resolveAllWith: self loaderPolicy cacheGofer) isEmpty
            ifTrue: [ 
              self cacheRepository storeVersion: mcVersion.
              reference == nearestReference
                ifTrue: [ pSpec := packageSpec ]
                ifFalse: [ 
                  pSpec := packageSpec project packageSpec.
                  pSpec name: mcVersion package name ].
              self loadData
                addVersion: mcVersion
                versionInfo: mcVersion info
                resolvedReference: reference
                packageSpec: pSpec ] ].
      self scheduleFetchFor: packageSpec externalReference: externalReference ] in MetacelloFetchingMCSpecLoader>>linearLoadPackageSpec:gofer:
	Receiver: a MetacelloFetchingMCSpecLoader(explicit load : BaselineOfJSON)
	Arguments and temporary variables: 
		packageSpec: 	spec 
	name: 'BaselineOfJSON';
	repository: 'github://svenvc/N[..]
		gofer: 	a MetacelloGofer
		cachedReference: 	nil
		mcVersion: 	nil
		references: 	nil
		nearestReference: 	nil
		externalReference: 	nil
		loadedVersionInfos: 	nil
	Receiver's instance variables: 
		spec: 	spec 
	name: 'BaselineOfJSON';
	repository: 'github://svenvc/NeoJSON/[..]
		operator: 	nil
		loaderPolicy: 	a MetacelloLoaderPolicy
		disablePackageCache: 	false


[:bar |
            bar value: 1.
            aBlock value.
            bar value: 2 ] in IceMetacelloPharoPlatform(MetacelloPharoCommonPlatform)>>do:displaying:
	Receiver: an IceMetacelloPharoPlatform
	Arguments and temporary variables: 
		aBlock: 	[ 
      | references nearestReference cachedReference externalRefe[..]
		aString: 	'Fetching BaselineOfJSON'
		bar: 	a Job
	Receiver's instance variables: 
		bypassProgressBars: 	false
		bypassGoferLoadUpdateCategories: 	false


FullBlockClosure(BlockClosure)>>cull:
	Receiver: [:bar |
            bar value: 1.
            aBlock value.
            bar value: 2 ]
	Arguments and temporary variables: 
		anArg: 	a Job
	Receiver's instance variables: 
		outerContext: 	IceMetacelloPharoPlatform(MetacelloPharoCommonPlatform)>>do:d[..]
		compiledBlock: 	a CompiledBlock: [:bar |
            bar value: 1.
         [..]
		numArgs: 	1
		receiver: 	an IceMetacelloPharoPlatform


[ ^ block cull: self ] in [ self prepareForRunning.
	  CurrentJob value: self during: [ ^ block cull: self ] ] in Job>>run
	Receiver: a Job
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		block: 	[:bar |
            bar value: 1.
            aBlock value.
        [..]
		currentValue: 	1
		min: 	0
		max: 	2
		title: 	'Fetching BaselineOfJSON'
		children: 	an OrderedCollection()
		isRunning: 	true
		parent: 	nil
		process: 	a Process in nil
		owner: 	a MorphicUIManager


[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in CurrentJob(DynamicVariable)>>value:during:
	Receiver: a CurrentJob
	Arguments and temporary variables: 
		anObject: 	a Job
		aBlock: 	[ ^ block cull: self ]
		activeProcess: 	a Process in nil
		oldValue: 	nil
	Receiver's instance variables: 
		index: 	2


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ]
	Arguments and temporary variables: 
		aBlock: 	[
			activeProcess
				psValueAt: index
				put: oldValue ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	CurrentJob(DynamicVariable)>>value:during:
		compiledBlock: 	a CompiledBlock: [ activeProcess
			psValueAt: index
			put:[..]
		numArgs: 	0
		receiver: 	a CurrentJob


CurrentJob(DynamicVariable)>>value:during:
	Receiver: a CurrentJob
	Arguments and temporary variables: 
		anObject: 	a Job
		aBlock: 	[ ^ block cull: self ]
		activeProcess: 	a Process in nil
		oldValue: 	nil
	Receiver's instance variables: 
		index: 	2


CurrentJob class(DynamicVariable class)>>value:during:
	Receiver: CurrentJob
	Arguments and temporary variables: 
		anObject: 	a Job
		aBlock: 	[ ^ block cull: self ]
	Receiver's instance variables: 
		superclass: 	DynamicVariable
		methodDict: 	a MethodDictionary()
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		commentSourcePointer: 	nil
		subclasses: 	nil
		name: 	#CurrentJob
		classPool: 	nil
		sharedPools: 	nil
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Jobs-Base'
		soleInstance: 	a CurrentJob


[ self prepareForRunning.
	  CurrentJob value: self during: [ ^ block cull: self ] ] in Job>>run
	Receiver: a Job
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		block: 	[:bar |
            bar value: 1.
            aBlock value.
        [..]
		currentValue: 	1
		min: 	0
		max: 	2
		title: 	'Fetching BaselineOfJSON'
		children: 	an OrderedCollection()
		isRunning: 	true
		parent: 	nil
		process: 	a Process in nil
		owner: 	a MorphicUIManager


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ self prepareForRunning.
	  CurrentJob value: self during: [ ^ block cull: self ] ]
	Arguments and temporary variables: 
		aBlock: 	[ self cleanupAfterRunning ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	Job>>run
		compiledBlock: 	a CompiledBlock: [ self prepareForRunning.
	  CurrentJob val[..]
		numArgs: 	0
		receiver: 	a Job


Job>>run
	Receiver: a Job
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		block: 	[:bar |
            bar value: 1.
            aBlock value.
        [..]
		currentValue: 	1
		min: 	0
		max: 	2
		title: 	'Fetching BaselineOfJSON'
		children: 	an OrderedCollection()
		isRunning: 	true
		parent: 	nil
		process: 	a Process in nil
		owner: 	a MorphicUIManager


MorphicUIManager(UIManager)>>displayProgress:from:to:during:
	Receiver: a MorphicUIManager
	Arguments and temporary variables: 
		titleString: 	'Fetching BaselineOfJSON'
		minVal: 	0
		maxVal: 	2
		workBlock: 	[:bar |
            bar value: 1.
            aBlock value.
    [..]
	Receiver's instance variables: 
		activeTranscript: 	nil


ByteString(String)>>displayProgressFrom:to:during:
	Receiver: 'Fetching BaselineOfJSON'
	Arguments and temporary variables: 
		minVal: 	0
		maxVal: 	2
		workBlock: 	[:bar |
            bar value: 1.
            aBlock value.
    [..]
	Receiver's instance variables: 
'Fetching BaselineOfJSON'

IceMetacelloPharoPlatform(MetacelloPharoCommonPlatform)>>do:displaying:
	Receiver: an IceMetacelloPharoPlatform
	Arguments and temporary variables: 
		aBlock: 	[ 
      | references nearestReference cachedReference externalRefe[..]
		aString: 	'Fetching BaselineOfJSON'
	Receiver's instance variables: 
		bypassProgressBars: 	false
		bypassGoferLoadUpdateCategories: 	false


MetacelloFetchingMCSpecLoader>>linearLoadPackageSpec:gofer:
	Receiver: a MetacelloFetchingMCSpecLoader(explicit load : BaselineOfJSON)
	Arguments and temporary variables: 
		packageSpec: 	spec 
	name: 'BaselineOfJSON';
	repository: 'github://svenvc/N[..]
		gofer: 	a MetacelloGofer
	Receiver's instance variables: 
		spec: 	spec 
	name: 'BaselineOfJSON';
	repository: 'github://svenvc/NeoJSON/[..]
		operator: 	nil
		loaderPolicy: 	a MetacelloLoaderPolicy
		disablePackageCache: 	false


MetacelloPackageSpec>>loadUsing:gofer:
	Receiver: spec 
	name: 'BaselineOfJSON';
	repository: 'github://svenvc/NeoJSON/repository'.
	Arguments and temporary variables: 
		aLoader: 	a MetacelloFetchingMCSpecLoader(explicit load : BaselineOfJSON)
		gofer: 	a MetacelloGofer
	Receiver's instance variables: 
		project: 	<<error during printing>>

[:pkg | pkg loadUsing: self gofer: gofer ] in MetacelloFetchingMCSpecLoader(MetacelloCommonMCSpecLoader)>>linearLoadPackageSpecs:repositories:
	Receiver: a MetacelloFetchingMCSpecLoader(explicit load : BaselineOfJSON)
	Arguments and temporary variables: 
		packageSpecs: 	an Array(spec 
	name: 'BaselineOfJSON';
	repository: 'github:[..]
		repositories: 	an OrderedCollection(an IceMetacelloRepositoryAdapter)
		gofer: 	a MetacelloGofer
		pkg: 	spec 
	name: 'BaselineOfJSON';
	repository: 'github://svenvc/NeoJSON/r[..]
	Receiver's instance variables: 
		spec: 	spec 
	name: 'BaselineOfJSON';
	repository: 'github://svenvc/NeoJSON/[..]
		operator: 	nil
		loaderPolicy: 	a MetacelloLoaderPolicy
		disablePackageCache: 	false


Array(SequenceableCollection)>>do:
	Receiver: an Array(spec 
	name: 'BaselineOfJSON';
	repository: 'github://svenvc/NeoJSON/reposito[..]
	Arguments and temporary variables: 
		aBlock: 	[:pkg | pkg loadUsing: self gofer: gofer ]
		index: 	1
	Receiver's instance variables: 
an Array(spec 
	name: 'BaselineOfJSON';
	repository: 'github://svenvc/NeoJSON/reposito[..]

MetacelloFetchingMCSpecLoader(MetacelloCommonMCSpecLoader)>>linearLoadPackageSpecs:repositories:
	Receiver: a MetacelloFetchingMCSpecLoader(explicit load : BaselineOfJSON)
	Arguments and temporary variables: 
		packageSpecs: 	an Array(spec 
	name: 'BaselineOfJSON';
	repository: 'github:[..]
		repositories: 	an OrderedCollection(an IceMetacelloRepositoryAdapter)
		gofer: 	a MetacelloGofer
	Receiver's instance variables: 
		spec: 	spec 
	name: 'BaselineOfJSON';
	repository: 'github://svenvc/NeoJSON/[..]
		operator: 	nil
		loaderPolicy: 	a MetacelloLoaderPolicy
		disablePackageCache: 	false


[ super linearLoadPackageSpecs: packageSpecs repositories: repositories ] in MetacelloFetchingMCSpecLoader>>explicitLoadPackageSpecs:repositories:
	Receiver: a MetacelloFetchingMCSpecLoader(explicit load : BaselineOfJSON)
	Arguments and temporary variables: 
		packageSpecs: 	an Array(spec 
	name: 'BaselineOfJSON';
	repository: 'github:[..]
		repositories: 	an OrderedCollection(an IceMetacelloRepositoryAdapter)
		directive: 	nil
	Receiver's instance variables: 
		spec: 	spec 
	name: 'BaselineOfJSON';
	repository: 'github://svenvc/NeoJSON/[..]
		operator: 	nil
		loaderPolicy: 	a MetacelloLoaderPolicy
		disablePackageCache: 	false


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ super linearLoadPackageSpecs: packageSpecs repositories: repositories ]
	Arguments and temporary variables: 
		aBlock: 	[ loadDirective := oldRoot ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	MetacelloFetchingMCSpecLoader>>explicitLoadPackageSpecs:repos[..]
		compiledBlock: 	a CompiledBlock: [ super linearLoadPackageSpecs: packageSpec[..]
		numArgs: 	0
		receiver: 	a MetacelloFetchingMCSpecLoader(explicit load : BaselineOfJSON)


MetacelloLoaderPolicy>>pushLoadDirective:during:
	Receiver: a MetacelloLoaderPolicy
	Arguments and temporary variables: 
		aLoaderDirective: 	explicit load : BaselineOfJSON
		aBlock: 	[ super linearLoadPackageSpecs: packageSpecs repositories: reposito[..]
		oldRoot: 	linear load : 
	explicit load : BaselineOfJSON
	Receiver's instance variables: 
		overrideRepositories: 	nil
		repositoryMap: 	a Dictionary()
		ensuredMap: 	a Dictionary()
		cacheRepository: 	a MCDictionaryRepository(cache)
		cacheGofer: 	a Gofer
		ignoreImage: 	false
		loadData: 	nil
		loadDirective: 	explicit load : BaselineOfJSON
		silently: 	nil


MetacelloLoaderPolicy>>pushExplicitLoadDirectivesDuring:for:
	Receiver: a MetacelloLoaderPolicy
	Arguments and temporary variables: 
		aBlock: 	[ super linearLoadPackageSpecs: packageSpecs repositories: reposito[..]
		aLoader: 	a MetacelloFetchingMCSpecLoader(explicit load : BaselineOfJSON)
		directive: 	explicit load : BaselineOfJSON
	Receiver's instance variables: 
		overrideRepositories: 	nil
		repositoryMap: 	a Dictionary()
		ensuredMap: 	a Dictionary()
		cacheRepository: 	a MCDictionaryRepository(cache)
		cacheGofer: 	a Gofer
		ignoreImage: 	false
		loadData: 	nil
		loadDirective: 	explicit load : BaselineOfJSON
		silently: 	nil


MetacelloFetchingMCSpecLoader>>explicitLoadPackageSpecs:repositories:
	Receiver: a MetacelloFetchingMCSpecLoader(explicit load : BaselineOfJSON)
	Arguments and temporary variables: 
		packageSpecs: 	an Array(spec 
	name: 'BaselineOfJSON';
	repository: 'github:[..]
		repositories: 	an OrderedCollection(an IceMetacelloRepositoryAdapter)
		directive: 	nil
	Receiver's instance variables: 
		spec: 	spec 
	name: 'BaselineOfJSON';
	repository: 'github://svenvc/NeoJSON/[..]
		operator: 	nil
		loaderPolicy: 	a MetacelloLoaderPolicy
		disablePackageCache: 	false


MetacelloPackageSpec>>explicitLoadUsing:
	Receiver: spec 
	name: 'BaselineOfJSON';
	repository: 'github://svenvc/NeoJSON/repository'.
	Arguments and temporary variables: 
		mcLoader: 	a MetacelloLoadingMCSpecLoader
		wc: 	nil
		fetchingSpecLoader: 	a MetacelloFetchingMCSpecLoader(explicit load : Baselin[..]
	Receiver's instance variables: 
		project: 	<<error during printing>>

MetacelloPackageSpec>>load
	Receiver: spec 
	name: 'BaselineOfJSON';
	repository: 'github://svenvc/NeoJSON/repository'.
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		project: 	<<error during printing>>

[ spec projectPackage load ] in MetacelloScriptEngine>>getBaselineUnconditionalLoad:
	Receiver: a MetacelloScriptEngine
	Arguments and temporary variables: 
		unconditionalLoad: 	true
		spec: 	spec 
	name: 'JSON';
	repository: 'github://svenvc/NeoJSON/repository'.
	Receiver's instance variables: 
		root: 	nil
		projectSpec: 	spec 
	name: 'JSON';
	repository: 'github://svenvc/NeoJSON/rep[..]
		options: 	a Dictionary()


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [ spec projectPackage load ]
	Arguments and temporary variables: 
		exception: 	MetacelloIgnorePackageLoaded
		handlerAction: 	[ :ex | 
      "see https://github.com/dalehenrich/metacello[..]
	Receiver's instance variables: 
		outerContext: 	MetacelloScriptEngine>>getBaselineUnconditionalLoad:
		compiledBlock: 	a CompiledBlock: [ spec projectPackage load ]
		numArgs: 	0
		receiver: 	a MetacelloScriptEngine


MetacelloScriptEngine>>getBaselineUnconditionalLoad:
	Receiver: a MetacelloScriptEngine
	Arguments and temporary variables: 
		unconditionalLoad: 	true
		spec: 	spec 
	name: 'JSON';
	repository: 'github://svenvc/NeoJSON/repository'.
	Receiver's instance variables: 
		root: 	nil
		projectSpec: 	spec 
	name: 'JSON';
	repository: 'github://svenvc/NeoJSON/rep[..]
		options: 	a Dictionary()


MetacelloScriptEngine>>getBaselineProjectUnconditionalLoad:
	Receiver: a MetacelloScriptEngine
	Arguments and temporary variables: 
		unconditionalLoad: 	true
		project: 	nil
	Receiver's instance variables: 
		root: 	nil
		projectSpec: 	spec 
	name: 'JSON';
	repository: 'github://svenvc/NeoJSON/rep[..]
		options: 	a Dictionary()


MetacelloMCBaselineProject>>projectForScriptEngine:unconditionalLoad:
	Receiver: <<error during printing>>
	Arguments and temporary variables: 
		aMetacelloScriptEngine: 	a MetacelloScriptEngine
		aBool: 	false
	Receiver's instance variables: 
		versionMap: 	nil
		symbolicVersionMap: 	nil
		errorMap: 	nil
		loader: 	nil
		loaderClass: 	MetacelloLoadingMCSpecLoader
		loadType: 	nil
		configuration: 	<<error during printing>>

MetacelloMCBaselineProject(MetacelloProject)>>projectForScriptEngine:
	Receiver: <<error during printing>>
	Arguments and temporary variables: 
		aMetacelloScriptEngine: 	a MetacelloScriptEngine
	Receiver's instance variables: 
		versionMap: 	nil
		symbolicVersionMap: 	nil
		errorMap: 	nil
		loader: 	nil
		loaderClass: 	MetacelloLoadingMCSpecLoader
		loadType: 	nil
		configuration: 	<<error during printing>>

MetacelloMCBaselineOfProjectSpec(MetacelloMCProjectSpec)>>versionForScriptEngine:
	Receiver: spec 
	name: 'JSON';
	repository: 'github://svenvc/NeoJSON/repository'.
	Arguments and temporary variables: 
<<error during printing>>
	Receiver's instance variables: 
		project: 	<<error during printing>>

[ 
          | version loadedSpec |
          self setDefaultsAndValidateProjectSpec.
          [ loadedSpec := (self lookupProjectSpecFor: self projectSpec) copy ]
            on: MetacelloAllowProjectDowngrade , MetacelloAllowProjectUpgrade
            do: [ :ex | ex handleOnDownGrade: onDownGradeBlock onUpgrade: onUpgradeBlock ].
          version := loadedSpec versionForScriptEngine: self.
          self
            root:
              (required isEmpty
                ifTrue: [ version load ]
                ifFalse: [ version load: required ]) loadDirective.
          loadedSpec loads: required.
          MetacelloProjectRegistration
            registrationForProjectSpec: loadedSpec
            ifAbsent: [ :new | 
              new
                loadedInImage: true;
                registerProject ]
            ifPresent: [ :existing :new | 
              existing
                copyOnWrite: [ :existingCopy | 
                  existingCopy
                    loadedInImage: true;
                    merge: new ] ] ] in [ 
      self
        handleNotificationsForAction: [ 
          | version loadedSpec |
          self setDefaultsAndValidateProjectSpec.
          [ loadedSpec := (self lookupProjectSpecFor: self projectSpec) copy ]
            on: MetacelloAllowProjectDowngrade , MetacelloAllowProjectUpgrade
            do: [ :ex | ex handleOnDownGrade: onDownGradeBlock onUpgrade: onUpgradeBlock ].
          version := loadedSpec versionForScriptEngine: self.
          self
            root:
              (required isEmpty
                ifTrue: [ version load ]
                ifFalse: [ version load: required ]) loadDirective.
          loadedSpec loads: required.
          MetacelloProjectRegistration
            registrationForProjectSpec: loadedSpec
            ifAbsent: [ :new | 
              new
                loadedInImage: true;
                registerProject ]
            ifPresent: [ :existing :new | 
              existing
                copyOnWrite: [ :existingCopy | 
                  existingCopy
                    loadedInImage: true;
                    merge: new ] ] ] ] in MetacelloScriptEngine>>load:onProjectDownGrade:onProjectUpgrade:
	Receiver: a MetacelloScriptEngine
	Arguments and temporary variables: 
		required: 	#()
		onDownGradeBlock: 	[ :ex :existing :new | ex allowEvenIfLocked ]
		onUpgradeBlock: 	[ :ex :existing :new | ex allowEvenIfLocked ]
		loadedSpec: 	spec 
	name: 'JSON';
	repository: 'github://svenvc/NeoJSON/repo[..]
		version: 	nil
	Receiver's instance variables: 
		root: 	nil
		projectSpec: 	spec 
	name: 'JSON';
	repository: 'github://svenvc/NeoJSON/rep[..]
		options: 	a Dictionary()


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [ 
          | version loadedSpec |
          self setDefaultsAndValidateProjectSpec.
[..]
	Arguments and temporary variables: 
		exception: 	an ExceptionSet
		handlerAction: 	[ :ex | 
      "lookup and registration handlers need to be [..]
	Receiver's instance variables: 
		outerContext: 	[ 
      self
        handleNotificationsForAction: [ 
      [..]
		compiledBlock: 	a CompiledBlock: [ 
          | version loadedSpec |
       [..]
		numArgs: 	0
		receiver: 	a MetacelloScriptEngine


[ 
  actionBlock
    on:
      MetacelloLookupProjectSpec , MetacelloLookupProjectSpecForLoad
        , MetacelloProjectSpecLoadedNotification
        , MetacelloScriptEnsureProjectLoadedForDevelopment
        , MetacelloLookupBaselineSpecForEnsureLoad
    do: [ :ex | 
      "lookup and registration handlers need to be innermost set of handlers ...they may throw option notifications"
      ex handleResolutionFor: self ] ] in [ 
  [ 
  actionBlock
    on:
      MetacelloLookupProjectSpec , MetacelloLookupProjectSpecForLoad
        , MetacelloProjectSpecLoadedNotification
        , MetacelloScriptEnsureProjectLoadedForDevelopment
        , MetacelloLookupBaselineSpecForEnsureLoad
    do: [ :ex | 
      "lookup and registration handlers need to be innermost set of handlers ...they may throw option notifications"
      ex handleResolutionFor: self ] ]
    on:
      MetacelloAllowProjectDowngrade , MetacelloAllowProjectUpgrade
        , MetacelloAllowConflictingProjectUpgrade
    do: [ :ex | 
      "option handlers need to be outermost set of handlers ... last line of defense before users are involved"
      ex handleResolutionFor: self ] ] in [ 
  [ 
  [ 
  actionBlock
    on:
      MetacelloLookupProjectSpec , MetacelloLookupProjectSpecForLoad
        , MetacelloProjectSpecLoadedNotification
        , MetacelloScriptEnsureProjectLoadedForDevelopment
        , MetacelloLookupBaselineSpecForEnsureLoad
    do: [ :ex | 
      "lookup and registration handlers need to be innermost set of handlers ...they may throw option notifications"
      ex handleResolutionFor: self ] ]
    on:
      MetacelloAllowProjectDowngrade , MetacelloAllowProjectUpgrade
        , MetacelloAllowConflictingProjectUpgrade
    do: [ :ex | 
      "option handlers need to be outermost set of handlers ... last line of defense before users are involved"
      ex handleResolutionFor: self ] ]
    on: MetacelloAllowLockedProjectChange
    do: [ :ex | 
      "MetacelloAllowLockedProjectChange need to be outermost handler ... since it is signaled from second line of handlers"
      ex handleResolutionFor: self ] ] in MetacelloScriptEngine>>handleNotificationsForAction:
	Receiver: a MetacelloScriptEngine
	Arguments and temporary variables: 
		actionBlock: 	[ 
          | version loadedSpec |
          self setDefaults[..]
	Receiver's instance variables: 
		root: 	nil
		projectSpec: 	spec 
	name: 'JSON';
	repository: 'github://svenvc/NeoJSON/rep[..]
		options: 	a Dictionary()


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [ 
  actionBlock
    on:
      MetacelloLookupProjectSpec , MetacelloLookupProjectSpec[..]
	Arguments and temporary variables: 
		exception: 	an ExceptionSet
		handlerAction: 	[ :ex | 
      "option handlers need to be outermost set of [..]
	Receiver's instance variables: 
		outerContext: 	[ 
  [ 
  actionBlock
    on:
      MetacelloLookupProjectSpe[..]
		compiledBlock: 	a CompiledBlock: [ 
  actionBlock
    on:
      MetacelloLoo[..]
		numArgs: 	0
		receiver: 	a MetacelloScriptEngine


[ 
  [ 
  actionBlock
    on:
      MetacelloLookupProjectSpec , MetacelloLookupProjectSpecForLoad
        , MetacelloProjectSpecLoadedNotification
        , MetacelloScriptEnsureProjectLoadedForDevelopment
        , MetacelloLookupBaselineSpecForEnsureLoad
    do: [ :ex | 
      "lookup and registration handlers need to be innermost set of handlers ...they may throw option notifications"
      ex handleResolutionFor: self ] ]
    on:
      MetacelloAllowProjectDowngrade , MetacelloAllowProjectUpgrade
        , MetacelloAllowConflictingProjectUpgrade
    do: [ :ex | 
      "option handlers need to be outermost set of handlers ... last line of defense before users are involved"
      ex handleResolutionFor: self ] ] in [ 
  [ 
  [ 
  actionBlock
    on:
      MetacelloLookupProjectSpec , MetacelloLookupProjectSpecForLoad
        , MetacelloProjectSpecLoadedNotification
        , MetacelloScriptEnsureProjectLoadedForDevelopment
        , MetacelloLookupBaselineSpecForEnsureLoad
    do: [ :ex | 
      "lookup and registration handlers need to be innermost set of handlers ...they may throw option notifications"
      ex handleResolutionFor: self ] ]
    on:
      MetacelloAllowProjectDowngrade , MetacelloAllowProjectUpgrade
        , MetacelloAllowConflictingProjectUpgrade
    do: [ :ex | 
      "option handlers need to be outermost set of handlers ... last line of defense before users are involved"
      ex handleResolutionFor: self ] ]
    on: MetacelloAllowLockedProjectChange
    do: [ :ex | 
      "MetacelloAllowLockedProjectChange need to be outermost handler ... since it is signaled from second line of handlers"
      ex handleResolutionFor: self ] ] in MetacelloScriptEngine>>handleNotificationsForAction:
	Receiver: a MetacelloScriptEngine
	Arguments and temporary variables: 
		actionBlock: 	[ 
          | version loadedSpec |
          self setDefaults[..]
	Receiver's instance variables: 
		root: 	nil
		projectSpec: 	spec 
	name: 'JSON';
	repository: 'github://svenvc/NeoJSON/rep[..]
		options: 	a Dictionary()



--- The full stack ---
MetacelloFetchingMCSpecLoader(MetacelloCommonMCSpecLoader)>>retryingResolvePackageSpecReferences:gofer:
[ 
      | references nearestReference cachedReference externalReference mcVersion loadedVersionInfos |
      cachedReference := nil.
      packageSpec
        searchCacheRepositoryForPackage: [ 
          "check to see if mcz file is already in cacheRepository"
          cachedReference := self
            resolvePackageSpec: packageSpec
            cachedGofer: self loaderPolicy cacheGofer.
          (cachedReference ~~ nil and: [ packageSpec getFile ~~ nil ])
            ifTrue: [ 
              cachedReference name = packageSpec file
                ifTrue: [ 
                  "exact match between packageSpec file and cache"
                  ^ self
                    scheduleFetchFor: packageSpec
                    cachedReference: cachedReference ] ] ].
      references := self
        retryingResolvePackageSpecReferences: packageSpec
        gofer: gofer.	"look up mcz file"
      nearestReference := references last asMetacelloCachingResolvedReference.
      (cachedReference ~~ nil
        and: [ cachedReference name = nearestReference name ])
        ifTrue: [ 
          "latest reference in repository matches cachedReference ... "
          ^ self
            scheduleFetchFor: packageSpec
            nearestReference: nearestReference ].
      (self ignoreImage not
        and: [ (loadedVersionInfos := self ancestorsFor: packageSpec) ~~ nil ])
        ifTrue: [ 
          "If the mcz is already loaded into the image, no need to copy"
          loadedVersionInfos
            do: [ :info | 
              info name = nearestReference name
                ifTrue: [ 
                  | spc |
                  spc := packageSpec copy.
                  spc file: info name.
                  (MetacelloIgnorePackageLoaded signal: spc)
                    ifFalse: [ ^ self ] ] ] ].
      externalReference := (references
        select: [ :ref | ref name = nearestReference name ]) first
        asMetacelloCachingResolvedReference.
      self repositoryMap
        at: externalReference name
        put: externalReference repository.
      (self
        resolveDependencies: externalReference
        nearest: nearestReference
        into: (OrderedCollection with: nearestReference))
        do: [ :reference | 
          | pSpec l |
          mcVersion := reference version.
          (l := (GoferVersionReference name: reference name)
            resolveAllWith: self loaderPolicy cacheGofer) isEmpty
            ifTrue: [ 
              self cacheRepository storeVersion: mcVersion.
              reference == nearestReference
                ifTrue: [ pSpec := packageSpec ]
                ifFalse: [ 
                  pSpec := packageSpec project packageSpec.
                  pSpec name: mcVersion package name ].
              self loadData
                addVersion: mcVersion
                versionInfo: mcVersion info
                resolvedReference: reference
                packageSpec: pSpec ] ].
      self scheduleFetchFor: packageSpec externalReference: externalReference ] in MetacelloFetchingMCSpecLoader>>linearLoadPackageSpec:gofer:
[:bar |
            bar value: 1.
            aBlock value.
            bar value: 2 ] in IceMetacelloPharoPlatform(MetacelloPharoCommonPlatform)>>do:displaying:
FullBlockClosure(BlockClosure)>>cull:
[ ^ block cull: self ] in [ self prepareForRunning.
	  CurrentJob value: self during: [ ^ block cull: self ] ] in Job>>run
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in CurrentJob(DynamicVariable)>>value:during:
FullBlockClosure(BlockClosure)>>ensure:
CurrentJob(DynamicVariable)>>value:during:
CurrentJob class(DynamicVariable class)>>value:during:
[ self prepareForRunning.
	  CurrentJob value: self during: [ ^ block cull: self ] ] in Job>>run
FullBlockClosure(BlockClosure)>>ensure:
Job>>run
MorphicUIManager(UIManager)>>displayProgress:from:to:during:
ByteString(String)>>displayProgressFrom:to:during:
IceMetacelloPharoPlatform(MetacelloPharoCommonPlatform)>>do:displaying:
MetacelloFetchingMCSpecLoader>>linearLoadPackageSpec:gofer:
MetacelloPackageSpec>>loadUsing:gofer:
[:pkg | pkg loadUsing: self gofer: gofer ] in MetacelloFetchingMCSpecLoader(MetacelloCommonMCSpecLoader)>>linearLoadPackageSpecs:repositories:
Array(SequenceableCollection)>>do:
MetacelloFetchingMCSpecLoader(MetacelloCommonMCSpecLoader)>>linearLoadPackageSpecs:repositories:
[ super linearLoadPackageSpecs: packageSpecs repositories: repositories ] in MetacelloFetchingMCSpecLoader>>explicitLoadPackageSpecs:repositories:
FullBlockClosure(BlockClosure)>>ensure:
MetacelloLoaderPolicy>>pushLoadDirective:during:
MetacelloLoaderPolicy>>pushExplicitLoadDirectivesDuring:for:
MetacelloFetchingMCSpecLoader>>explicitLoadPackageSpecs:repositories:
MetacelloPackageSpec>>explicitLoadUsing:
MetacelloPackageSpec>>load
[ spec projectPackage load ] in MetacelloScriptEngine>>getBaselineUnconditionalLoad:
FullBlockClosure(BlockClosure)>>on:do:
MetacelloScriptEngine>>getBaselineUnconditionalLoad:
MetacelloScriptEngine>>getBaselineProjectUnconditionalLoad:
MetacelloMCBaselineProject>>projectForScriptEngine:unconditionalLoad:
MetacelloMCBaselineProject(MetacelloProject)>>projectForScriptEngine:
MetacelloMCBaselineOfProjectSpec(MetacelloMCProjectSpec)>>versionForScriptEngine:
[ 
          | version loadedSpec |
          self setDefaultsAndValidateProjectSpec.
          [ loadedSpec := (self lookupProjectSpecFor: self projectSpec) copy ]
            on: MetacelloAllowProjectDowngrade , MetacelloAllowProjectUpgrade
            do: [ :ex | ex handleOnDownGrade: onDownGradeBlock onUpgrade: onUpgradeBlock ].
          version := loadedSpec versionForScriptEngine: self.
          self
            root:
              (required isEmpty
                ifTrue: [ version load ]
                ifFalse: [ version load: required ]) loadDirective.
          loadedSpec loads: required.
          MetacelloProjectRegistration
            registrationForProjectSpec: loadedSpec
            ifAbsent: [ :new | 
              new
                loadedInImage: true;
                registerProject ]
            ifPresent: [ :existing :new | 
              existing
                copyOnWrite: [ :existingCopy | 
                  existingCopy
                    loadedInImage: true;
                    merge: new ] ] ] in [ 
      self
        handleNotificationsForAction: [ 
          | version loadedSpec |
          self setDefaultsAndValidateProjectSpec.
          [ loadedSpec := (self lookupProjectSpecFor: self projectSpec) copy ]
            on: MetacelloAllowProjectDowngrade , MetacelloAllowProjectUpgrade
            do: [ :ex | ex handleOnDownGrade: onDownGradeBlock onUpgrade: onUpgradeBlock ].
          version := loadedSpec versionForScriptEngine: self.
          self
            root:
              (required isEmpty
                ifTrue: [ version load ]
                ifFalse: [ version load: required ]) loadDirective.
          loadedSpec loads: required.
          MetacelloProjectRegistration
            registrationForProjectSpec: loadedSpec
            ifAbsent: [ :new | 
              new
                loadedInImage: true;
                registerProject ]
            ifPresent: [ :existing :new | 
              existing
                copyOnWrite: [ :existingCopy | 
                  existingCopy
                    loadedInImage: true;
                    merge: new ] ] ] ] in MetacelloScriptEngine>>load:onProjectDownGrade:onProjectUpgrade:
FullBlockClosure(BlockClosure)>>on:do:
[ 
  actionBlock
    on:
      MetacelloLookupProjectSpec , MetacelloLookupProjectSpecForLoad
        , MetacelloProjectSpecLoadedNotification
        , MetacelloScriptEnsureProjectLoadedForDevelopment
        , MetacelloLookupBaselineSpecForEnsureLoad
    do: [ :ex | 
      "lookup and registration handlers need to be innermost set of handlers ...they may throw option notifications"
      ex handleResolutionFor: self ] ] in [ 
  [ 
  actionBlock
    on:
      MetacelloLookupProjectSpec , MetacelloLookupProjectSpecForLoad
        , MetacelloProjectSpecLoadedNotification
        , MetacelloScriptEnsureProjectLoadedForDevelopment
        , MetacelloLookupBaselineSpecForEnsureLoad
    do: [ :ex | 
      "lookup and registration handlers need to be innermost set of handlers ...they may throw option notifications"
      ex handleResolutionFor: self ] ]
    on:
      MetacelloAllowProjectDowngrade , MetacelloAllowProjectUpgrade
        , MetacelloAllowConflictingProjectUpgrade
    do: [ :ex | 
      "option handlers need to be outermost set of handlers ... last line of defense before users are involved"
      ex handleResolutionFor: self ] ] in [ 
  [ 
  [ 
  actionBlock
    on:
      MetacelloLookupProjectSpec , MetacelloLookupProjectSpecForLoad
        , MetacelloProjectSpecLoadedNotification
        , MetacelloScriptEnsureProjectLoadedForDevelopment
        , MetacelloLookupBaselineSpecForEnsureLoad
    do: [ :ex | 
      "lookup and registration handlers need to be innermost set of handlers ...they may throw option notifications"
      ex handleResolutionFor: self ] ]
    on:
      MetacelloAllowProjectDowngrade , MetacelloAllowProjectUpgrade
        , MetacelloAllowConflictingProjectUpgrade
    do: [ :ex | 
      "option handlers need to be outermost set of handlers ... last line of defense before users are involved"
      ex handleResolutionFor: self ] ]
    on: MetacelloAllowLockedProjectChange
    do: [ :ex | 
      "MetacelloAllowLockedProjectChange need to be outermost handler ... since it is signaled from second line of handlers"
      ex handleResolutionFor: self ] ] in MetacelloScriptEngine>>handleNotificationsForAction:
FullBlockClosure(BlockClosure)>>on:do:
[ 
  [ 
  actionBlock
    on:
      MetacelloLookupProjectSpec , MetacelloLookupProjectSpecForLoad
        , MetacelloProjectSpecLoadedNotification
        , MetacelloScriptEnsureProjectLoadedForDevelopment
        , MetacelloLookupBaselineSpecForEnsureLoad
    do: [ :ex | 
      "lookup and registration handlers need to be innermost set of handlers ...they may throw option notifications"
      ex handleResolutionFor: self ] ]
    on:
      MetacelloAllowProjectDowngrade , MetacelloAllowProjectUpgrade
        , MetacelloAllowConflictingProjectUpgrade
    do: [ :ex | 
      "option handlers need to be outermost set of handlers ... last line of defense before users are involved"
      ex handleResolutionFor: self ] ] in [ 
  [ 
  [ 
  actionBlock
    on:
      MetacelloLookupProjectSpec , MetacelloLookupProjectSpecForLoad
        , MetacelloProjectSpecLoadedNotification
        , MetacelloScriptEnsureProjectLoadedForDevelopment
        , MetacelloLookupBaselineSpecForEnsureLoad
    do: [ :ex | 
      "lookup and registration handlers need to be innermost set of handlers ...they may throw option notifications"
      ex handleResolutionFor: self ] ]
    on:
      MetacelloAllowProjectDowngrade , MetacelloAllowProjectUpgrade
        , MetacelloAllowConflictingProjectUpgrade
    do: [ :ex | 
      "option handlers need to be outermost set of handlers ... last line of defense before users are involved"
      ex handleResolutionFor: self ] ]
    on: MetacelloAllowLockedProjectChange
    do: [ :ex | 
      "MetacelloAllowLockedProjectChange need to be outermost handler ... since it is signaled from second line of handlers"
      ex handleResolutionFor: self ] ] in MetacelloScriptEngine>>handleNotificationsForAction:
 - - - - - - - - - - - - - - -
			- - - - - - - - - - - - - - - - - -
FullBlockClosure(BlockClosure)>>on:do:
[ 
  [ 
  [ 
  actionBlock
    on:
      MetacelloLookupProjectSpec , MetacelloLookupProjectSpecForLoad
        , MetacelloProjectSpecLoadedNotification
        , MetacelloScriptEnsureProjectLoadedForDevelopment
        , MetacelloLookupBaselineSpecForEnsureLoad
    do: [ :ex | 
      "lookup and registration handlers need to be innermost set of handlers ...they may throw option notifications"
      ex handleResolutionFor: self ] ]
    on:
      MetacelloAllowProjectDowngrade , MetacelloAllowProjectUpgrade
        , MetacelloAllowConflictingProjectUpgrade
    do: [ :ex | 
      "option handlers need to be outermost set of handlers ... last line of defense before users are involved"
      ex handleResolutionFor: self ] ]
    on: MetacelloAllowLockedProjectChange
    do: [ :ex | 
      "MetacelloAllowLockedProjectChange need to be outermost handler ... since it is signaled from second line of handlers"
      ex handleResolutionFor: self ] ] in MetacelloScriptEngine>>handleNotificationsForAction:
FullBlockClosure(BlockClosure)>>on:do:
MetacelloScriptEngine>>handleNotificationsForAction:
[ 
      self
        handleNotificationsForAction: [ 
          | version loadedSpec |
          self setDefaultsAndValidateProjectSpec.
          [ loadedSpec := (self lookupProjectSpecFor: self projectSpec) copy ]
            on: MetacelloAllowProjectDowngrade , MetacelloAllowProjectUpgrade
            do: [ :ex | ex handleOnDownGrade: onDownGradeBlock onUpgrade: onUpgradeBlock ].
          version := loadedSpec versionForScriptEngine: self.
          self
            root:
              (required isEmpty
                ifTrue: [ version load ]
                ifFalse: [ version load: required ]) loadDirective.
          loadedSpec loads: required.
          MetacelloProjectRegistration
            registrationForProjectSpec: loadedSpec
            ifAbsent: [ :new | 
              new
                loadedInImage: true;
                registerProject ]
            ifPresent: [ :existing :new | 
              existing
                copyOnWrite: [ :existingCopy | 
                  existingCopy
                    loadedInImage: true;
                    merge: new ] ] ] ] in MetacelloScriptEngine>>load:onProjectDownGrade:onProjectUpgrade:
FullBlockClosure(BlockClosure)>>ensure:
MetacelloProjectRegistration class>>copyRegistryRestoreOnErrorWhile:
MetacelloScriptEngine>>load:onProjectDownGrade:onProjectUpgrade:
MetacelloScriptEngine>>load:
[ :projectSpec | 
      | engine |
      engine := MetacelloScriptEngine new
        options: self options copy;
        projectSpec: projectSpec;
        yourself.
      engine perform: actionArg key withArguments: actionArg value.
      engine root ifNotNil: [ :root | self roots add: root ] ] in MetacelloScriptApiExecutor(MetacelloScriptExecutor)>>execute:
[ :projectSpec | 
      projectSpec
        ifNotNil: [ projectSpecBlock value: (self applyArgsToProjectSpec: projectSpec copy) ] ] in MetacelloScriptApiExecutor>>executeString:do:
Array(SequenceableCollection)>>do:
MetacelloScriptApiExecutor>>executeString:do:
ByteString(String)>>execute:against:
MetacelloScriptApiExecutor(MetacelloScriptExecutor)>>execute:
[ 
		super execute: statements ] in MetacelloScriptApiExecutor>>execute:
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in IceMetacelloLoadSessionContext(DynamicVariable)>>value:during:
FullBlockClosure(BlockClosure)>>ensure:
IceMetacelloLoadSessionContext(DynamicVariable)>>value:during:
IceMetacelloLoadSessionContext class(DynamicVariable class)>>value:during:
IceMetacelloPharoPlatform>>withMetacelloLoadSessionDo:
MetacelloScriptApiExecutor>>execute:
Metacello>>execute:args:
Metacello>>load
UndefinedObject>>DoIt
OCReceiverDoItSemanticScope(OCDoItSemanticScope)>>evaluateDoIt:
OpalCompiler>>evaluate
[
		self announcer announce: (SpCodeWillBeEvaluatedAnnouncement newContent: aString).
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionModel doItReceiver.
		result := receiver class compiler
			source: aString;
			context: self interactionModel doItContext;
			receiver: self interactionModel doItReceiver;
			requestor: self interactionModel;
			environment: self environment;
			failBlock:  [ 
				self announcer announce: (SpCodeEvaluationFailedAnnouncement newContent: aString).
				^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		self announcer announce: (SpCodeEvaluationSucceedAnnouncement newContent: aString).
		result ] in SpCodePresenter>>evaluate:onCompileError:onError:
FullBlockClosure(BlockClosure)>>on:do:
SpCodePresenter>>evaluate:onCompileError:onError:
StPlaygroundPagePresenter>>doEvaluateAndGo
StPlaygroundPagePresenter>>doEvaluateAllAndGo
StPlaygroundDoItCommand>>execute
SpCommand(CmCommandDecorator)>>execute
[ specCommand execute ] in [ :specCommand | 
			aButtonClass new
				label: specCommand name;
				help: specCommand description;
				in: [ :button | 
					specCommand hasIcon
						ifTrue: [ button icon: specCommand icon ] ];
				action: [ specCommand execute ];
				yourself ] in SpCommand>>configureAsButtonOfClass:
FullBlockClosure(BlockClosure)>>cull:
SpMorphicToolbarButtonAdapter>>execute
SpToolbarButtonMorph(PluggableButtonMorph)>>performAction:
[:m |
		(m containsPoint: evt cursorPoint) ifTrue: [m enabled ifTrue: [ m performAction: evt ]]] in SpToolbarButtonMorph(PluggableButtonMorph)>>mouseUp:
Array(SequenceableCollection)>>do:
SpToolbarButtonMorph(PluggableButtonMorph)>>mouseUp:
SpToolbarButtonMorph(Morph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
SpToolbarButtonMorph(Morph)>>handleEvent:
SpToolbarButtonMorph(Morph)>>handleFocusEvent:
[
		result := focusHolder handleFocusEvent: transformedEvent.
	] in HandMorph>>sendFocusEvent:to:clear:
FullBlockClosure(BlockClosure)>>on:do:
WorldMorph>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil ]) ifTrue: [
			morphicWorld activeHand handleEvent: anEvent
		]
	] in OSWindowMorphicEventHandler>>dispatchMorphicEvent:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycleNow
WorldMorph>>doOneCycle
[
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMutex critical: [
			                     self extraWorldList ].
		extraWorldsToDraw do: [ :world | world doOneCycle ].

		(self currentWorld isNotNil and: [
			 (extraWorldsToDraw includes: self currentWorld) not ]) ifTrue: [
			self currentWorld doOneCycle ] ] in WorldMorph class>>doOneCycle
FullBlockClosure(BlockClosure)>>ensure:
WorldState class>>doDrawCycleWith:
WorldMorph class>>doOneCycle
MorphicRenderLoop>>doOneCycle
MorphicRenderLoop>>doOneCycleWhile:
[ MorphicRenderLoop new doOneCycleWhile: [ true ] ] in MorphicUIManager>>spawnNewProcess
[self value.
			"IMPORTANT: Do not step over next line of code. See method comments for details"
			Processor terminateRealActive] in FullBlockClosure(BlockClosure)>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
Could not resolve: BaselineOfJSON [BaselineOfJSON] in /Users/ryanperez/Documents/Pharo/images/Visualizer/pharo-local/package-cache https://github.com/SvenVC/NeoJSON.git[master]
23 October 2023 11:03:38.337448 pm

VM: Mac OS - arm64 - 1000 - CoInterpreter VMMaker-tonel.1 uuid: 902dd483-c0c4-0d00-86f2-0f880df24b96 Oct 23 2023
StackToRegisterMappingCogit VMMaker-tonel.1 uuid: 902dd483-c0c4-0d00-86f2-0f880df24b96 Oct 23 2023
v10.0.8 - Commit: b323c5fb - Date: 2023-10-20 16:02:07 -0400

Image: Pharo11.0.0 [Build information: Pharo-11.0.0+build.710.sha.ea28d8552cac85a7ce1e9c34ab1e7bd45f7b9910 (64 Bit)]

MetacelloFetchingMCSpecLoader(MetacelloCommonMCSpecLoader)>>retryingResolvePackageSpecReferences:gofer:
	Receiver: a MetacelloFetchingMCSpecLoader(explicit load : BaselineOfJSON)
	Arguments and temporary variables: 
		packageSpec: 	spec 
	name: 'BaselineOfJSON';
	repository: 'github://svenvc/N[..]
		gofer: 	a MetacelloGofer
		references: 	#()
		retryCount: 	3
		repositoryError: 	nil
	Receiver's instance variables: 
		spec: 	spec 
	name: 'BaselineOfJSON';
	repository: 'github://svenvc/NeoJSON/[..]
		operator: 	nil
		loaderPolicy: 	a MetacelloLoaderPolicy
		disablePackageCache: 	false


[ 
      | references nearestReference cachedReference externalReference mcVersion loadedVersionInfos |
      cachedReference := nil.
      packageSpec
        searchCacheRepositoryForPackage: [ 
          "check to see if mcz file is already in cacheRepository"
          cachedReference := self
            resolvePackageSpec: packageSpec
            cachedGofer: self loaderPolicy cacheGofer.
          (cachedReference ~~ nil and: [ packageSpec getFile ~~ nil ])
            ifTrue: [ 
              cachedReference name = packageSpec file
                ifTrue: [ 
                  "exact match between packageSpec file and cache"
                  ^ self
                    scheduleFetchFor: packageSpec
                    cachedReference: cachedReference ] ] ].
      references := self
        retryingResolvePackageSpecReferences: packageSpec
        gofer: gofer.	"look up mcz file"
      nearestReference := references last asMetacelloCachingResolvedReference.
      (cachedReference ~~ nil
        and: [ cachedReference name = nearestReference name ])
        ifTrue: [ 
          "latest reference in repository matches cachedReference ... "
          ^ self
            scheduleFetchFor: packageSpec
            nearestReference: nearestReference ].
      (self ignoreImage not
        and: [ (loadedVersionInfos := self ancestorsFor: packageSpec) ~~ nil ])
        ifTrue: [ 
          "If the mcz is already loaded into the image, no need to copy"
          loadedVersionInfos
            do: [ :info | 
              info name = nearestReference name
                ifTrue: [ 
                  | spc |
                  spc := packageSpec copy.
                  spc file: info name.
                  (MetacelloIgnorePackageLoaded signal: spc)
                    ifFalse: [ ^ self ] ] ] ].
      externalReference := (references
        select: [ :ref | ref name = nearestReference name ]) first
        asMetacelloCachingResolvedReference.
      self repositoryMap
        at: externalReference name
        put: externalReference repository.
      (self
        resolveDependencies: externalReference
        nearest: nearestReference
        into: (OrderedCollection with: nearestReference))
        do: [ :reference | 
          | pSpec l |
          mcVersion := reference version.
          (l := (GoferVersionReference name: reference name)
            resolveAllWith: self loaderPolicy cacheGofer) isEmpty
            ifTrue: [ 
              self cacheRepository storeVersion: mcVersion.
              reference == nearestReference
                ifTrue: [ pSpec := packageSpec ]
                ifFalse: [ 
                  pSpec := packageSpec project packageSpec.
                  pSpec name: mcVersion package name ].
              self loadData
                addVersion: mcVersion
                versionInfo: mcVersion info
                resolvedReference: reference
                packageSpec: pSpec ] ].
      self scheduleFetchFor: packageSpec externalReference: externalReference ] in MetacelloFetchingMCSpecLoader>>linearLoadPackageSpec:gofer:
	Receiver: a MetacelloFetchingMCSpecLoader(explicit load : BaselineOfJSON)
	Arguments and temporary variables: 
		packageSpec: 	spec 
	name: 'BaselineOfJSON';
	repository: 'github://svenvc/N[..]
		gofer: 	a MetacelloGofer
		cachedReference: 	nil
		mcVersion: 	nil
		references: 	nil
		nearestReference: 	nil
		externalReference: 	nil
		loadedVersionInfos: 	nil
	Receiver's instance variables: 
		spec: 	spec 
	name: 'BaselineOfJSON';
	repository: 'github://svenvc/NeoJSON/[..]
		operator: 	nil
		loaderPolicy: 	a MetacelloLoaderPolicy
		disablePackageCache: 	false


[:bar |
            bar value: 1.
            aBlock value.
            bar value: 2 ] in IceMetacelloPharoPlatform(MetacelloPharoCommonPlatform)>>do:displaying:
	Receiver: an IceMetacelloPharoPlatform
	Arguments and temporary variables: 
		aBlock: 	[ 
      | references nearestReference cachedReference externalRefe[..]
		aString: 	'Fetching BaselineOfJSON'
		bar: 	a Job
	Receiver's instance variables: 
		bypassProgressBars: 	false
		bypassGoferLoadUpdateCategories: 	false


FullBlockClosure(BlockClosure)>>cull:
	Receiver: [:bar |
            bar value: 1.
            aBlock value.
            bar value: 2 ]
	Arguments and temporary variables: 
		anArg: 	a Job
	Receiver's instance variables: 
		outerContext: 	IceMetacelloPharoPlatform(MetacelloPharoCommonPlatform)>>do:d[..]
		compiledBlock: 	a CompiledBlock: [:bar |
            bar value: 1.
         [..]
		numArgs: 	1
		receiver: 	an IceMetacelloPharoPlatform


[ ^ block cull: self ] in [ self prepareForRunning.
	  CurrentJob value: self during: [ ^ block cull: self ] ] in Job>>run
	Receiver: a Job
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		block: 	[:bar |
            bar value: 1.
            aBlock value.
        [..]
		currentValue: 	1
		min: 	0
		max: 	2
		title: 	'Fetching BaselineOfJSON'
		children: 	an OrderedCollection()
		isRunning: 	true
		parent: 	nil
		process: 	a Process in nil
		owner: 	a MorphicUIManager


[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in CurrentJob(DynamicVariable)>>value:during:
	Receiver: a CurrentJob
	Arguments and temporary variables: 
		anObject: 	a Job
		aBlock: 	[ ^ block cull: self ]
		activeProcess: 	a Process in nil
		oldValue: 	nil
	Receiver's instance variables: 
		index: 	2


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ]
	Arguments and temporary variables: 
		aBlock: 	[
			activeProcess
				psValueAt: index
				put: oldValue ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	CurrentJob(DynamicVariable)>>value:during:
		compiledBlock: 	a CompiledBlock: [ activeProcess
			psValueAt: index
			put:[..]
		numArgs: 	0
		receiver: 	a CurrentJob


CurrentJob(DynamicVariable)>>value:during:
	Receiver: a CurrentJob
	Arguments and temporary variables: 
		anObject: 	a Job
		aBlock: 	[ ^ block cull: self ]
		activeProcess: 	a Process in nil
		oldValue: 	nil
	Receiver's instance variables: 
		index: 	2


CurrentJob class(DynamicVariable class)>>value:during:
	Receiver: CurrentJob
	Arguments and temporary variables: 
		anObject: 	a Job
		aBlock: 	[ ^ block cull: self ]
	Receiver's instance variables: 
		superclass: 	DynamicVariable
		methodDict: 	a MethodDictionary()
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		commentSourcePointer: 	nil
		subclasses: 	nil
		name: 	#CurrentJob
		classPool: 	nil
		sharedPools: 	nil
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Jobs-Base'
		soleInstance: 	a CurrentJob


[ self prepareForRunning.
	  CurrentJob value: self during: [ ^ block cull: self ] ] in Job>>run
	Receiver: a Job
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		block: 	[:bar |
            bar value: 1.
            aBlock value.
        [..]
		currentValue: 	1
		min: 	0
		max: 	2
		title: 	'Fetching BaselineOfJSON'
		children: 	an OrderedCollection()
		isRunning: 	true
		parent: 	nil
		process: 	a Process in nil
		owner: 	a MorphicUIManager


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ self prepareForRunning.
	  CurrentJob value: self during: [ ^ block cull: self ] ]
	Arguments and temporary variables: 
		aBlock: 	[ self cleanupAfterRunning ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	Job>>run
		compiledBlock: 	a CompiledBlock: [ self prepareForRunning.
	  CurrentJob val[..]
		numArgs: 	0
		receiver: 	a Job


Job>>run
	Receiver: a Job
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		block: 	[:bar |
            bar value: 1.
            aBlock value.
        [..]
		currentValue: 	1
		min: 	0
		max: 	2
		title: 	'Fetching BaselineOfJSON'
		children: 	an OrderedCollection()
		isRunning: 	true
		parent: 	nil
		process: 	a Process in nil
		owner: 	a MorphicUIManager


MorphicUIManager(UIManager)>>displayProgress:from:to:during:
	Receiver: a MorphicUIManager
	Arguments and temporary variables: 
		titleString: 	'Fetching BaselineOfJSON'
		minVal: 	0
		maxVal: 	2
		workBlock: 	[:bar |
            bar value: 1.
            aBlock value.
    [..]
	Receiver's instance variables: 
		activeTranscript: 	nil


ByteString(String)>>displayProgressFrom:to:during:
	Receiver: 'Fetching BaselineOfJSON'
	Arguments and temporary variables: 
		minVal: 	0
		maxVal: 	2
		workBlock: 	[:bar |
            bar value: 1.
            aBlock value.
    [..]
	Receiver's instance variables: 
'Fetching BaselineOfJSON'

IceMetacelloPharoPlatform(MetacelloPharoCommonPlatform)>>do:displaying:
	Receiver: an IceMetacelloPharoPlatform
	Arguments and temporary variables: 
		aBlock: 	[ 
      | references nearestReference cachedReference externalRefe[..]
		aString: 	'Fetching BaselineOfJSON'
	Receiver's instance variables: 
		bypassProgressBars: 	false
		bypassGoferLoadUpdateCategories: 	false


MetacelloFetchingMCSpecLoader>>linearLoadPackageSpec:gofer:
	Receiver: a MetacelloFetchingMCSpecLoader(explicit load : BaselineOfJSON)
	Arguments and temporary variables: 
		packageSpec: 	spec 
	name: 'BaselineOfJSON';
	repository: 'github://svenvc/N[..]
		gofer: 	a MetacelloGofer
	Receiver's instance variables: 
		spec: 	spec 
	name: 'BaselineOfJSON';
	repository: 'github://svenvc/NeoJSON/[..]
		operator: 	nil
		loaderPolicy: 	a MetacelloLoaderPolicy
		disablePackageCache: 	false


MetacelloPackageSpec>>loadUsing:gofer:
	Receiver: spec 
	name: 'BaselineOfJSON';
	repository: 'github://svenvc/NeoJSON/repository'.
	Arguments and temporary variables: 
		aLoader: 	a MetacelloFetchingMCSpecLoader(explicit load : BaselineOfJSON)
		gofer: 	a MetacelloGofer
	Receiver's instance variables: 
		project: 	<<error during printing>>

[:pkg | pkg loadUsing: self gofer: gofer ] in MetacelloFetchingMCSpecLoader(MetacelloCommonMCSpecLoader)>>linearLoadPackageSpecs:repositories:
	Receiver: a MetacelloFetchingMCSpecLoader(explicit load : BaselineOfJSON)
	Arguments and temporary variables: 
		packageSpecs: 	an Array(spec 
	name: 'BaselineOfJSON';
	repository: 'github:[..]
		repositories: 	an OrderedCollection(an IceMetacelloRepositoryAdapter)
		gofer: 	a MetacelloGofer
		pkg: 	spec 
	name: 'BaselineOfJSON';
	repository: 'github://svenvc/NeoJSON/r[..]
	Receiver's instance variables: 
		spec: 	spec 
	name: 'BaselineOfJSON';
	repository: 'github://svenvc/NeoJSON/[..]
		operator: 	nil
		loaderPolicy: 	a MetacelloLoaderPolicy
		disablePackageCache: 	false


Array(SequenceableCollection)>>do:
	Receiver: an Array(spec 
	name: 'BaselineOfJSON';
	repository: 'github://svenvc/NeoJSON/reposito[..]
	Arguments and temporary variables: 
		aBlock: 	[:pkg | pkg loadUsing: self gofer: gofer ]
		index: 	1
	Receiver's instance variables: 
an Array(spec 
	name: 'BaselineOfJSON';
	repository: 'github://svenvc/NeoJSON/reposito[..]

MetacelloFetchingMCSpecLoader(MetacelloCommonMCSpecLoader)>>linearLoadPackageSpecs:repositories:
	Receiver: a MetacelloFetchingMCSpecLoader(explicit load : BaselineOfJSON)
	Arguments and temporary variables: 
		packageSpecs: 	an Array(spec 
	name: 'BaselineOfJSON';
	repository: 'github:[..]
		repositories: 	an OrderedCollection(an IceMetacelloRepositoryAdapter)
		gofer: 	a MetacelloGofer
	Receiver's instance variables: 
		spec: 	spec 
	name: 'BaselineOfJSON';
	repository: 'github://svenvc/NeoJSON/[..]
		operator: 	nil
		loaderPolicy: 	a MetacelloLoaderPolicy
		disablePackageCache: 	false


[ super linearLoadPackageSpecs: packageSpecs repositories: repositories ] in MetacelloFetchingMCSpecLoader>>explicitLoadPackageSpecs:repositories:
	Receiver: a MetacelloFetchingMCSpecLoader(explicit load : BaselineOfJSON)
	Arguments and temporary variables: 
		packageSpecs: 	an Array(spec 
	name: 'BaselineOfJSON';
	repository: 'github:[..]
		repositories: 	an OrderedCollection(an IceMetacelloRepositoryAdapter)
		directive: 	nil
	Receiver's instance variables: 
		spec: 	spec 
	name: 'BaselineOfJSON';
	repository: 'github://svenvc/NeoJSON/[..]
		operator: 	nil
		loaderPolicy: 	a MetacelloLoaderPolicy
		disablePackageCache: 	false


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ super linearLoadPackageSpecs: packageSpecs repositories: repositories ]
	Arguments and temporary variables: 
		aBlock: 	[ loadDirective := oldRoot ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	MetacelloFetchingMCSpecLoader>>explicitLoadPackageSpecs:repos[..]
		compiledBlock: 	a CompiledBlock: [ super linearLoadPackageSpecs: packageSpec[..]
		numArgs: 	0
		receiver: 	a MetacelloFetchingMCSpecLoader(explicit load : BaselineOfJSON)


MetacelloLoaderPolicy>>pushLoadDirective:during:
	Receiver: a MetacelloLoaderPolicy
	Arguments and temporary variables: 
		aLoaderDirective: 	explicit load : BaselineOfJSON
		aBlock: 	[ super linearLoadPackageSpecs: packageSpecs repositories: reposito[..]
		oldRoot: 	linear load : 
	explicit load : BaselineOfJSON
	Receiver's instance variables: 
		overrideRepositories: 	nil
		repositoryMap: 	a Dictionary()
		ensuredMap: 	a Dictionary()
		cacheRepository: 	a MCDictionaryRepository(cache)
		cacheGofer: 	a Gofer
		ignoreImage: 	false
		loadData: 	nil
		loadDirective: 	explicit load : BaselineOfJSON
		silently: 	nil


MetacelloLoaderPolicy>>pushExplicitLoadDirectivesDuring:for:
	Receiver: a MetacelloLoaderPolicy
	Arguments and temporary variables: 
		aBlock: 	[ super linearLoadPackageSpecs: packageSpecs repositories: reposito[..]
		aLoader: 	a MetacelloFetchingMCSpecLoader(explicit load : BaselineOfJSON)
		directive: 	explicit load : BaselineOfJSON
	Receiver's instance variables: 
		overrideRepositories: 	nil
		repositoryMap: 	a Dictionary()
		ensuredMap: 	a Dictionary()
		cacheRepository: 	a MCDictionaryRepository(cache)
		cacheGofer: 	a Gofer
		ignoreImage: 	false
		loadData: 	nil
		loadDirective: 	explicit load : BaselineOfJSON
		silently: 	nil


MetacelloFetchingMCSpecLoader>>explicitLoadPackageSpecs:repositories:
	Receiver: a MetacelloFetchingMCSpecLoader(explicit load : BaselineOfJSON)
	Arguments and temporary variables: 
		packageSpecs: 	an Array(spec 
	name: 'BaselineOfJSON';
	repository: 'github:[..]
		repositories: 	an OrderedCollection(an IceMetacelloRepositoryAdapter)
		directive: 	nil
	Receiver's instance variables: 
		spec: 	spec 
	name: 'BaselineOfJSON';
	repository: 'github://svenvc/NeoJSON/[..]
		operator: 	nil
		loaderPolicy: 	a MetacelloLoaderPolicy
		disablePackageCache: 	false


MetacelloPackageSpec>>explicitLoadUsing:
	Receiver: spec 
	name: 'BaselineOfJSON';
	repository: 'github://svenvc/NeoJSON/repository'.
	Arguments and temporary variables: 
		mcLoader: 	a MetacelloLoadingMCSpecLoader
		wc: 	nil
		fetchingSpecLoader: 	a MetacelloFetchingMCSpecLoader(explicit load : Baselin[..]
	Receiver's instance variables: 
		project: 	<<error during printing>>

MetacelloPackageSpec>>load
	Receiver: spec 
	name: 'BaselineOfJSON';
	repository: 'github://svenvc/NeoJSON/repository'.
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		project: 	<<error during printing>>

[ spec projectPackage load ] in MetacelloScriptEngine>>getBaselineUnconditionalLoad:
	Receiver: a MetacelloScriptEngine
	Arguments and temporary variables: 
		unconditionalLoad: 	true
		spec: 	spec 
	name: 'JSON';
	repository: 'github://svenvc/NeoJSON/repository'.
	Receiver's instance variables: 
		root: 	nil
		projectSpec: 	spec 
	name: 'JSON';
	repository: 'github://svenvc/NeoJSON/rep[..]
		options: 	a Dictionary()


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [ spec projectPackage load ]
	Arguments and temporary variables: 
		exception: 	MetacelloIgnorePackageLoaded
		handlerAction: 	[ :ex | 
      "see https://github.com/dalehenrich/metacello[..]
	Receiver's instance variables: 
		outerContext: 	MetacelloScriptEngine>>getBaselineUnconditionalLoad:
		compiledBlock: 	a CompiledBlock: [ spec projectPackage load ]
		numArgs: 	0
		receiver: 	a MetacelloScriptEngine


MetacelloScriptEngine>>getBaselineUnconditionalLoad:
	Receiver: a MetacelloScriptEngine
	Arguments and temporary variables: 
		unconditionalLoad: 	true
		spec: 	spec 
	name: 'JSON';
	repository: 'github://svenvc/NeoJSON/repository'.
	Receiver's instance variables: 
		root: 	nil
		projectSpec: 	spec 
	name: 'JSON';
	repository: 'github://svenvc/NeoJSON/rep[..]
		options: 	a Dictionary()


MetacelloScriptEngine>>getBaselineProjectUnconditionalLoad:
	Receiver: a MetacelloScriptEngine
	Arguments and temporary variables: 
		unconditionalLoad: 	true
		project: 	nil
	Receiver's instance variables: 
		root: 	nil
		projectSpec: 	spec 
	name: 'JSON';
	repository: 'github://svenvc/NeoJSON/rep[..]
		options: 	a Dictionary()


MetacelloMCBaselineProject>>projectForScriptEngine:unconditionalLoad:
	Receiver: <<error during printing>>
	Arguments and temporary variables: 
		aMetacelloScriptEngine: 	a MetacelloScriptEngine
		aBool: 	false
	Receiver's instance variables: 
		versionMap: 	nil
		symbolicVersionMap: 	nil
		errorMap: 	nil
		loader: 	nil
		loaderClass: 	MetacelloLoadingMCSpecLoader
		loadType: 	nil
		configuration: 	<<error during printing>>

MetacelloMCBaselineProject(MetacelloProject)>>projectForScriptEngine:
	Receiver: <<error during printing>>
	Arguments and temporary variables: 
		aMetacelloScriptEngine: 	a MetacelloScriptEngine
	Receiver's instance variables: 
		versionMap: 	nil
		symbolicVersionMap: 	nil
		errorMap: 	nil
		loader: 	nil
		loaderClass: 	MetacelloLoadingMCSpecLoader
		loadType: 	nil
		configuration: 	<<error during printing>>

MetacelloMCBaselineOfProjectSpec(MetacelloMCProjectSpec)>>versionForScriptEngine:
	Receiver: spec 
	name: 'JSON';
	repository: 'github://svenvc/NeoJSON/repository'.
	Arguments and temporary variables: 
<<error during printing>>
	Receiver's instance variables: 
		project: 	<<error during printing>>

[ 
          | version loadedSpec |
          self setDefaultsAndValidateProjectSpec.
          [ loadedSpec := (self lookupProjectSpecFor: self projectSpec) copy ]
            on: MetacelloAllowProjectDowngrade , MetacelloAllowProjectUpgrade
            do: [ :ex | ex handleOnDownGrade: onDownGradeBlock onUpgrade: onUpgradeBlock ].
          version := loadedSpec versionForScriptEngine: self.
          self
            root:
              (required isEmpty
                ifTrue: [ version load ]
                ifFalse: [ version load: required ]) loadDirective.
          loadedSpec loads: required.
          MetacelloProjectRegistration
            registrationForProjectSpec: loadedSpec
            ifAbsent: [ :new | 
              new
                loadedInImage: true;
                registerProject ]
            ifPresent: [ :existing :new | 
              existing
                copyOnWrite: [ :existingCopy | 
                  existingCopy
                    loadedInImage: true;
                    merge: new ] ] ] in [ 
      self
        handleNotificationsForAction: [ 
          | version loadedSpec |
          self setDefaultsAndValidateProjectSpec.
          [ loadedSpec := (self lookupProjectSpecFor: self projectSpec) copy ]
            on: MetacelloAllowProjectDowngrade , MetacelloAllowProjectUpgrade
            do: [ :ex | ex handleOnDownGrade: onDownGradeBlock onUpgrade: onUpgradeBlock ].
          version := loadedSpec versionForScriptEngine: self.
          self
            root:
              (required isEmpty
                ifTrue: [ version load ]
                ifFalse: [ version load: required ]) loadDirective.
          loadedSpec loads: required.
          MetacelloProjectRegistration
            registrationForProjectSpec: loadedSpec
            ifAbsent: [ :new | 
              new
                loadedInImage: true;
                registerProject ]
            ifPresent: [ :existing :new | 
              existing
                copyOnWrite: [ :existingCopy | 
                  existingCopy
                    loadedInImage: true;
                    merge: new ] ] ] ] in MetacelloScriptEngine>>load:onProjectDownGrade:onProjectUpgrade:
	Receiver: a MetacelloScriptEngine
	Arguments and temporary variables: 
		required: 	#()
		onDownGradeBlock: 	[ :ex :existing :new | ex allowEvenIfLocked ]
		onUpgradeBlock: 	[ :ex :existing :new | ex allowEvenIfLocked ]
		loadedSpec: 	spec 
	name: 'JSON';
	repository: 'github://svenvc/NeoJSON/repo[..]
		version: 	nil
	Receiver's instance variables: 
		root: 	nil
		projectSpec: 	spec 
	name: 'JSON';
	repository: 'github://svenvc/NeoJSON/rep[..]
		options: 	a Dictionary()


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [ 
          | version loadedSpec |
          self setDefaultsAndValidateProjectSpec.
[..]
	Arguments and temporary variables: 
		exception: 	an ExceptionSet
		handlerAction: 	[ :ex | 
      "lookup and registration handlers need to be [..]
	Receiver's instance variables: 
		outerContext: 	[ 
      self
        handleNotificationsForAction: [ 
      [..]
		compiledBlock: 	a CompiledBlock: [ 
          | version loadedSpec |
       [..]
		numArgs: 	0
		receiver: 	a MetacelloScriptEngine


[ 
  actionBlock
    on:
      MetacelloLookupProjectSpec , MetacelloLookupProjectSpecForLoad
        , MetacelloProjectSpecLoadedNotification
        , MetacelloScriptEnsureProjectLoadedForDevelopment
        , MetacelloLookupBaselineSpecForEnsureLoad
    do: [ :ex | 
      "lookup and registration handlers need to be innermost set of handlers ...they may throw option notifications"
      ex handleResolutionFor: self ] ] in [ 
  [ 
  actionBlock
    on:
      MetacelloLookupProjectSpec , MetacelloLookupProjectSpecForLoad
        , MetacelloProjectSpecLoadedNotification
        , MetacelloScriptEnsureProjectLoadedForDevelopment
        , MetacelloLookupBaselineSpecForEnsureLoad
    do: [ :ex | 
      "lookup and registration handlers need to be innermost set of handlers ...they may throw option notifications"
      ex handleResolutionFor: self ] ]
    on:
      MetacelloAllowProjectDowngrade , MetacelloAllowProjectUpgrade
        , MetacelloAllowConflictingProjectUpgrade
    do: [ :ex | 
      "option handlers need to be outermost set of handlers ... last line of defense before users are involved"
      ex handleResolutionFor: self ] ] in [ 
  [ 
  [ 
  actionBlock
    on:
      MetacelloLookupProjectSpec , MetacelloLookupProjectSpecForLoad
        , MetacelloProjectSpecLoadedNotification
        , MetacelloScriptEnsureProjectLoadedForDevelopment
        , MetacelloLookupBaselineSpecForEnsureLoad
    do: [ :ex | 
      "lookup and registration handlers need to be innermost set of handlers ...they may throw option notifications"
      ex handleResolutionFor: self ] ]
    on:
      MetacelloAllowProjectDowngrade , MetacelloAllowProjectUpgrade
        , MetacelloAllowConflictingProjectUpgrade
    do: [ :ex | 
      "option handlers need to be outermost set of handlers ... last line of defense before users are involved"
      ex handleResolutionFor: self ] ]
    on: MetacelloAllowLockedProjectChange
    do: [ :ex | 
      "MetacelloAllowLockedProjectChange need to be outermost handler ... since it is signaled from second line of handlers"
      ex handleResolutionFor: self ] ] in MetacelloScriptEngine>>handleNotificationsForAction:
	Receiver: a MetacelloScriptEngine
	Arguments and temporary variables: 
		actionBlock: 	[ 
          | version loadedSpec |
          self setDefaults[..]
	Receiver's instance variables: 
		root: 	nil
		projectSpec: 	spec 
	name: 'JSON';
	repository: 'github://svenvc/NeoJSON/rep[..]
		options: 	a Dictionary()


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [ 
  actionBlock
    on:
      MetacelloLookupProjectSpec , MetacelloLookupProjectSpec[..]
	Arguments and temporary variables: 
		exception: 	an ExceptionSet
		handlerAction: 	[ :ex | 
      "option handlers need to be outermost set of [..]
	Receiver's instance variables: 
		outerContext: 	[ 
  [ 
  actionBlock
    on:
      MetacelloLookupProjectSpe[..]
		compiledBlock: 	a CompiledBlock: [ 
  actionBlock
    on:
      MetacelloLoo[..]
		numArgs: 	0
		receiver: 	a MetacelloScriptEngine


[ 
  [ 
  actionBlock
    on:
      MetacelloLookupProjectSpec , MetacelloLookupProjectSpecForLoad
        , MetacelloProjectSpecLoadedNotification
        , MetacelloScriptEnsureProjectLoadedForDevelopment
        , MetacelloLookupBaselineSpecForEnsureLoad
    do: [ :ex | 
      "lookup and registration handlers need to be innermost set of handlers ...they may throw option notifications"
      ex handleResolutionFor: self ] ]
    on:
      MetacelloAllowProjectDowngrade , MetacelloAllowProjectUpgrade
        , MetacelloAllowConflictingProjectUpgrade
    do: [ :ex | 
      "option handlers need to be outermost set of handlers ... last line of defense before users are involved"
      ex handleResolutionFor: self ] ] in [ 
  [ 
  [ 
  actionBlock
    on:
      MetacelloLookupProjectSpec , MetacelloLookupProjectSpecForLoad
        , MetacelloProjectSpecLoadedNotification
        , MetacelloScriptEnsureProjectLoadedForDevelopment
        , MetacelloLookupBaselineSpecForEnsureLoad
    do: [ :ex | 
      "lookup and registration handlers need to be innermost set of handlers ...they may throw option notifications"
      ex handleResolutionFor: self ] ]
    on:
      MetacelloAllowProjectDowngrade , MetacelloAllowProjectUpgrade
        , MetacelloAllowConflictingProjectUpgrade
    do: [ :ex | 
      "option handlers need to be outermost set of handlers ... last line of defense before users are involved"
      ex handleResolutionFor: self ] ]
    on: MetacelloAllowLockedProjectChange
    do: [ :ex | 
      "MetacelloAllowLockedProjectChange need to be outermost handler ... since it is signaled from second line of handlers"
      ex handleResolutionFor: self ] ] in MetacelloScriptEngine>>handleNotificationsForAction:
	Receiver: a MetacelloScriptEngine
	Arguments and temporary variables: 
		actionBlock: 	[ 
          | version loadedSpec |
          self setDefaults[..]
	Receiver's instance variables: 
		root: 	nil
		projectSpec: 	spec 
	name: 'JSON';
	repository: 'github://svenvc/NeoJSON/rep[..]
		options: 	a Dictionary()



--- The full stack ---
MetacelloFetchingMCSpecLoader(MetacelloCommonMCSpecLoader)>>retryingResolvePackageSpecReferences:gofer:
[ 
      | references nearestReference cachedReference externalReference mcVersion loadedVersionInfos |
      cachedReference := nil.
      packageSpec
        searchCacheRepositoryForPackage: [ 
          "check to see if mcz file is already in cacheRepository"
          cachedReference := self
            resolvePackageSpec: packageSpec
            cachedGofer: self loaderPolicy cacheGofer.
          (cachedReference ~~ nil and: [ packageSpec getFile ~~ nil ])
            ifTrue: [ 
              cachedReference name = packageSpec file
                ifTrue: [ 
                  "exact match between packageSpec file and cache"
                  ^ self
                    scheduleFetchFor: packageSpec
                    cachedReference: cachedReference ] ] ].
      references := self
        retryingResolvePackageSpecReferences: packageSpec
        gofer: gofer.	"look up mcz file"
      nearestReference := references last asMetacelloCachingResolvedReference.
      (cachedReference ~~ nil
        and: [ cachedReference name = nearestReference name ])
        ifTrue: [ 
          "latest reference in repository matches cachedReference ... "
          ^ self
            scheduleFetchFor: packageSpec
            nearestReference: nearestReference ].
      (self ignoreImage not
        and: [ (loadedVersionInfos := self ancestorsFor: packageSpec) ~~ nil ])
        ifTrue: [ 
          "If the mcz is already loaded into the image, no need to copy"
          loadedVersionInfos
            do: [ :info | 
              info name = nearestReference name
                ifTrue: [ 
                  | spc |
                  spc := packageSpec copy.
                  spc file: info name.
                  (MetacelloIgnorePackageLoaded signal: spc)
                    ifFalse: [ ^ self ] ] ] ].
      externalReference := (references
        select: [ :ref | ref name = nearestReference name ]) first
        asMetacelloCachingResolvedReference.
      self repositoryMap
        at: externalReference name
        put: externalReference repository.
      (self
        resolveDependencies: externalReference
        nearest: nearestReference
        into: (OrderedCollection with: nearestReference))
        do: [ :reference | 
          | pSpec l |
          mcVersion := reference version.
          (l := (GoferVersionReference name: reference name)
            resolveAllWith: self loaderPolicy cacheGofer) isEmpty
            ifTrue: [ 
              self cacheRepository storeVersion: mcVersion.
              reference == nearestReference
                ifTrue: [ pSpec := packageSpec ]
                ifFalse: [ 
                  pSpec := packageSpec project packageSpec.
                  pSpec name: mcVersion package name ].
              self loadData
                addVersion: mcVersion
                versionInfo: mcVersion info
                resolvedReference: reference
                packageSpec: pSpec ] ].
      self scheduleFetchFor: packageSpec externalReference: externalReference ] in MetacelloFetchingMCSpecLoader>>linearLoadPackageSpec:gofer:
[:bar |
            bar value: 1.
            aBlock value.
            bar value: 2 ] in IceMetacelloPharoPlatform(MetacelloPharoCommonPlatform)>>do:displaying:
FullBlockClosure(BlockClosure)>>cull:
[ ^ block cull: self ] in [ self prepareForRunning.
	  CurrentJob value: self during: [ ^ block cull: self ] ] in Job>>run
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in CurrentJob(DynamicVariable)>>value:during:
FullBlockClosure(BlockClosure)>>ensure:
CurrentJob(DynamicVariable)>>value:during:
CurrentJob class(DynamicVariable class)>>value:during:
[ self prepareForRunning.
	  CurrentJob value: self during: [ ^ block cull: self ] ] in Job>>run
FullBlockClosure(BlockClosure)>>ensure:
Job>>run
MorphicUIManager(UIManager)>>displayProgress:from:to:during:
ByteString(String)>>displayProgressFrom:to:during:
IceMetacelloPharoPlatform(MetacelloPharoCommonPlatform)>>do:displaying:
MetacelloFetchingMCSpecLoader>>linearLoadPackageSpec:gofer:
MetacelloPackageSpec>>loadUsing:gofer:
[:pkg | pkg loadUsing: self gofer: gofer ] in MetacelloFetchingMCSpecLoader(MetacelloCommonMCSpecLoader)>>linearLoadPackageSpecs:repositories:
Array(SequenceableCollection)>>do:
MetacelloFetchingMCSpecLoader(MetacelloCommonMCSpecLoader)>>linearLoadPackageSpecs:repositories:
[ super linearLoadPackageSpecs: packageSpecs repositories: repositories ] in MetacelloFetchingMCSpecLoader>>explicitLoadPackageSpecs:repositories:
FullBlockClosure(BlockClosure)>>ensure:
MetacelloLoaderPolicy>>pushLoadDirective:during:
MetacelloLoaderPolicy>>pushExplicitLoadDirectivesDuring:for:
MetacelloFetchingMCSpecLoader>>explicitLoadPackageSpecs:repositories:
MetacelloPackageSpec>>explicitLoadUsing:
MetacelloPackageSpec>>load
[ spec projectPackage load ] in MetacelloScriptEngine>>getBaselineUnconditionalLoad:
FullBlockClosure(BlockClosure)>>on:do:
MetacelloScriptEngine>>getBaselineUnconditionalLoad:
MetacelloScriptEngine>>getBaselineProjectUnconditionalLoad:
MetacelloMCBaselineProject>>projectForScriptEngine:unconditionalLoad:
MetacelloMCBaselineProject(MetacelloProject)>>projectForScriptEngine:
MetacelloMCBaselineOfProjectSpec(MetacelloMCProjectSpec)>>versionForScriptEngine:
[ 
          | version loadedSpec |
          self setDefaultsAndValidateProjectSpec.
          [ loadedSpec := (self lookupProjectSpecFor: self projectSpec) copy ]
            on: MetacelloAllowProjectDowngrade , MetacelloAllowProjectUpgrade
            do: [ :ex | ex handleOnDownGrade: onDownGradeBlock onUpgrade: onUpgradeBlock ].
          version := loadedSpec versionForScriptEngine: self.
          self
            root:
              (required isEmpty
                ifTrue: [ version load ]
                ifFalse: [ version load: required ]) loadDirective.
          loadedSpec loads: required.
          MetacelloProjectRegistration
            registrationForProjectSpec: loadedSpec
            ifAbsent: [ :new | 
              new
                loadedInImage: true;
                registerProject ]
            ifPresent: [ :existing :new | 
              existing
                copyOnWrite: [ :existingCopy | 
                  existingCopy
                    loadedInImage: true;
                    merge: new ] ] ] in [ 
      self
        handleNotificationsForAction: [ 
          | version loadedSpec |
          self setDefaultsAndValidateProjectSpec.
          [ loadedSpec := (self lookupProjectSpecFor: self projectSpec) copy ]
            on: MetacelloAllowProjectDowngrade , MetacelloAllowProjectUpgrade
            do: [ :ex | ex handleOnDownGrade: onDownGradeBlock onUpgrade: onUpgradeBlock ].
          version := loadedSpec versionForScriptEngine: self.
          self
            root:
              (required isEmpty
                ifTrue: [ version load ]
                ifFalse: [ version load: required ]) loadDirective.
          loadedSpec loads: required.
          MetacelloProjectRegistration
            registrationForProjectSpec: loadedSpec
            ifAbsent: [ :new | 
              new
                loadedInImage: true;
                registerProject ]
            ifPresent: [ :existing :new | 
              existing
                copyOnWrite: [ :existingCopy | 
                  existingCopy
                    loadedInImage: true;
                    merge: new ] ] ] ] in MetacelloScriptEngine>>load:onProjectDownGrade:onProjectUpgrade:
FullBlockClosure(BlockClosure)>>on:do:
[ 
  actionBlock
    on:
      MetacelloLookupProjectSpec , MetacelloLookupProjectSpecForLoad
        , MetacelloProjectSpecLoadedNotification
        , MetacelloScriptEnsureProjectLoadedForDevelopment
        , MetacelloLookupBaselineSpecForEnsureLoad
    do: [ :ex | 
      "lookup and registration handlers need to be innermost set of handlers ...they may throw option notifications"
      ex handleResolutionFor: self ] ] in [ 
  [ 
  actionBlock
    on:
      MetacelloLookupProjectSpec , MetacelloLookupProjectSpecForLoad
        , MetacelloProjectSpecLoadedNotification
        , MetacelloScriptEnsureProjectLoadedForDevelopment
        , MetacelloLookupBaselineSpecForEnsureLoad
    do: [ :ex | 
      "lookup and registration handlers need to be innermost set of handlers ...they may throw option notifications"
      ex handleResolutionFor: self ] ]
    on:
      MetacelloAllowProjectDowngrade , MetacelloAllowProjectUpgrade
        , MetacelloAllowConflictingProjectUpgrade
    do: [ :ex | 
      "option handlers need to be outermost set of handlers ... last line of defense before users are involved"
      ex handleResolutionFor: self ] ] in [ 
  [ 
  [ 
  actionBlock
    on:
      MetacelloLookupProjectSpec , MetacelloLookupProjectSpecForLoad
        , MetacelloProjectSpecLoadedNotification
        , MetacelloScriptEnsureProjectLoadedForDevelopment
        , MetacelloLookupBaselineSpecForEnsureLoad
    do: [ :ex | 
      "lookup and registration handlers need to be innermost set of handlers ...they may throw option notifications"
      ex handleResolutionFor: self ] ]
    on:
      MetacelloAllowProjectDowngrade , MetacelloAllowProjectUpgrade
        , MetacelloAllowConflictingProjectUpgrade
    do: [ :ex | 
      "option handlers need to be outermost set of handlers ... last line of defense before users are involved"
      ex handleResolutionFor: self ] ]
    on: MetacelloAllowLockedProjectChange
    do: [ :ex | 
      "MetacelloAllowLockedProjectChange need to be outermost handler ... since it is signaled from second line of handlers"
      ex handleResolutionFor: self ] ] in MetacelloScriptEngine>>handleNotificationsForAction:
FullBlockClosure(BlockClosure)>>on:do:
[ 
  [ 
  actionBlock
    on:
      MetacelloLookupProjectSpec , MetacelloLookupProjectSpecForLoad
        , MetacelloProjectSpecLoadedNotification
        , MetacelloScriptEnsureProjectLoadedForDevelopment
        , MetacelloLookupBaselineSpecForEnsureLoad
    do: [ :ex | 
      "lookup and registration handlers need to be innermost set of handlers ...they may throw option notifications"
      ex handleResolutionFor: self ] ]
    on:
      MetacelloAllowProjectDowngrade , MetacelloAllowProjectUpgrade
        , MetacelloAllowConflictingProjectUpgrade
    do: [ :ex | 
      "option handlers need to be outermost set of handlers ... last line of defense before users are involved"
      ex handleResolutionFor: self ] ] in [ 
  [ 
  [ 
  actionBlock
    on:
      MetacelloLookupProjectSpec , MetacelloLookupProjectSpecForLoad
        , MetacelloProjectSpecLoadedNotification
        , MetacelloScriptEnsureProjectLoadedForDevelopment
        , MetacelloLookupBaselineSpecForEnsureLoad
    do: [ :ex | 
      "lookup and registration handlers need to be innermost set of handlers ...they may throw option notifications"
      ex handleResolutionFor: self ] ]
    on:
      MetacelloAllowProjectDowngrade , MetacelloAllowProjectUpgrade
        , MetacelloAllowConflictingProjectUpgrade
    do: [ :ex | 
      "option handlers need to be outermost set of handlers ... last line of defense before users are involved"
      ex handleResolutionFor: self ] ]
    on: MetacelloAllowLockedProjectChange
    do: [ :ex | 
      "MetacelloAllowLockedProjectChange need to be outermost handler ... since it is signaled from second line of handlers"
      ex handleResolutionFor: self ] ] in MetacelloScriptEngine>>handleNotificationsForAction:
 - - - - - - - - - - - - - - -
			- - - - - - - - - - - - - - - - - -
FullBlockClosure(BlockClosure)>>on:do:
[ 
  [ 
  [ 
  actionBlock
    on:
      MetacelloLookupProjectSpec , MetacelloLookupProjectSpecForLoad
        , MetacelloProjectSpecLoadedNotification
        , MetacelloScriptEnsureProjectLoadedForDevelopment
        , MetacelloLookupBaselineSpecForEnsureLoad
    do: [ :ex | 
      "lookup and registration handlers need to be innermost set of handlers ...they may throw option notifications"
      ex handleResolutionFor: self ] ]
    on:
      MetacelloAllowProjectDowngrade , MetacelloAllowProjectUpgrade
        , MetacelloAllowConflictingProjectUpgrade
    do: [ :ex | 
      "option handlers need to be outermost set of handlers ... last line of defense before users are involved"
      ex handleResolutionFor: self ] ]
    on: MetacelloAllowLockedProjectChange
    do: [ :ex | 
      "MetacelloAllowLockedProjectChange need to be outermost handler ... since it is signaled from second line of handlers"
      ex handleResolutionFor: self ] ] in MetacelloScriptEngine>>handleNotificationsForAction:
FullBlockClosure(BlockClosure)>>on:do:
MetacelloScriptEngine>>handleNotificationsForAction:
[ 
      self
        handleNotificationsForAction: [ 
          | version loadedSpec |
          self setDefaultsAndValidateProjectSpec.
          [ loadedSpec := (self lookupProjectSpecFor: self projectSpec) copy ]
            on: MetacelloAllowProjectDowngrade , MetacelloAllowProjectUpgrade
            do: [ :ex | ex handleOnDownGrade: onDownGradeBlock onUpgrade: onUpgradeBlock ].
          version := loadedSpec versionForScriptEngine: self.
          self
            root:
              (required isEmpty
                ifTrue: [ version load ]
                ifFalse: [ version load: required ]) loadDirective.
          loadedSpec loads: required.
          MetacelloProjectRegistration
            registrationForProjectSpec: loadedSpec
            ifAbsent: [ :new | 
              new
                loadedInImage: true;
                registerProject ]
            ifPresent: [ :existing :new | 
              existing
                copyOnWrite: [ :existingCopy | 
                  existingCopy
                    loadedInImage: true;
                    merge: new ] ] ] ] in MetacelloScriptEngine>>load:onProjectDownGrade:onProjectUpgrade:
FullBlockClosure(BlockClosure)>>ensure:
MetacelloProjectRegistration class>>copyRegistryRestoreOnErrorWhile:
MetacelloScriptEngine>>load:onProjectDownGrade:onProjectUpgrade:
MetacelloScriptEngine>>load:
[ :projectSpec | 
      | engine |
      engine := MetacelloScriptEngine new
        options: self options copy;
        projectSpec: projectSpec;
        yourself.
      engine perform: actionArg key withArguments: actionArg value.
      engine root ifNotNil: [ :root | self roots add: root ] ] in MetacelloScriptApiExecutor(MetacelloScriptExecutor)>>execute:
[ :projectSpec | 
      projectSpec
        ifNotNil: [ projectSpecBlock value: (self applyArgsToProjectSpec: projectSpec copy) ] ] in MetacelloScriptApiExecutor>>executeString:do:
Array(SequenceableCollection)>>do:
MetacelloScriptApiExecutor>>executeString:do:
ByteString(String)>>execute:against:
MetacelloScriptApiExecutor(MetacelloScriptExecutor)>>execute:
[ 
		super execute: statements ] in MetacelloScriptApiExecutor>>execute:
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in IceMetacelloLoadSessionContext(DynamicVariable)>>value:during:
FullBlockClosure(BlockClosure)>>ensure:
IceMetacelloLoadSessionContext(DynamicVariable)>>value:during:
IceMetacelloLoadSessionContext class(DynamicVariable class)>>value:during:
IceMetacelloPharoPlatform>>withMetacelloLoadSessionDo:
MetacelloScriptApiExecutor>>execute:
Metacello>>execute:args:
Metacello>>load
UndefinedObject>>DoIt
OCReceiverDoItSemanticScope(OCDoItSemanticScope)>>evaluateDoIt:
OpalCompiler>>evaluate
[
		self announcer announce: (SpCodeWillBeEvaluatedAnnouncement newContent: aString).
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionModel doItReceiver.
		result := receiver class compiler
			source: aString;
			context: self interactionModel doItContext;
			receiver: self interactionModel doItReceiver;
			requestor: self interactionModel;
			environment: self environment;
			failBlock:  [ 
				self announcer announce: (SpCodeEvaluationFailedAnnouncement newContent: aString).
				^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		self announcer announce: (SpCodeEvaluationSucceedAnnouncement newContent: aString).
		result ] in SpCodePresenter>>evaluate:onCompileError:onError:
FullBlockClosure(BlockClosure)>>on:do:
SpCodePresenter>>evaluate:onCompileError:onError:
StPlaygroundPagePresenter>>doEvaluateAndGo
StPlaygroundPagePresenter>>doEvaluateAllAndGo
StPlaygroundDoItCommand>>execute
SpCommand(CmCommandDecorator)>>execute
[ specCommand execute ] in [ :specCommand | 
			aButtonClass new
				label: specCommand name;
				help: specCommand description;
				in: [ :button | 
					specCommand hasIcon
						ifTrue: [ button icon: specCommand icon ] ];
				action: [ specCommand execute ];
				yourself ] in SpCommand>>configureAsButtonOfClass:
FullBlockClosure(BlockClosure)>>cull:
SpMorphicToolbarButtonAdapter>>execute
SpToolbarButtonMorph(PluggableButtonMorph)>>performAction:
[:m |
		(m containsPoint: evt cursorPoint) ifTrue: [m enabled ifTrue: [ m performAction: evt ]]] in SpToolbarButtonMorph(PluggableButtonMorph)>>mouseUp:
Array(SequenceableCollection)>>do:
SpToolbarButtonMorph(PluggableButtonMorph)>>mouseUp:
SpToolbarButtonMorph(Morph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
SpToolbarButtonMorph(Morph)>>handleEvent:
SpToolbarButtonMorph(Morph)>>handleFocusEvent:
[
		result := focusHolder handleFocusEvent: transformedEvent.
	] in HandMorph>>sendFocusEvent:to:clear:
FullBlockClosure(BlockClosure)>>on:do:
WorldMorph>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil ]) ifTrue: [
			morphicWorld activeHand handleEvent: anEvent
		]
	] in OSWindowMorphicEventHandler>>dispatchMorphicEvent:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycleNow
WorldMorph>>doOneCycle
[
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMutex critical: [
			                     self extraWorldList ].
		extraWorldsToDraw do: [ :world | world doOneCycle ].

		(self currentWorld isNotNil and: [
			 (extraWorldsToDraw includes: self currentWorld) not ]) ifTrue: [
			self currentWorld doOneCycle ] ] in WorldMorph class>>doOneCycle
FullBlockClosure(BlockClosure)>>ensure:
WorldState class>>doDrawCycleWith:
WorldMorph class>>doOneCycle
MorphicRenderLoop>>doOneCycle
MorphicRenderLoop>>doOneCycleWhile:
[ MorphicRenderLoop new doOneCycleWhile: [ true ] ] in MorphicUIManager>>spawnNewProcess
[self value.
			"IMPORTANT: Do not step over next line of code. See method comments for details"
			Processor terminateRealActive] in FullBlockClosure(BlockClosure)>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
Warning: Package *Roassal3-Pharo9 depends on the following classes:
  RSLayoutStudio
You must resolve these dependencies before you will be able to load these definitions: 
  RSLayoutStudio>>#defaultSpec

23 October 2023 11:25:38.372869 pm

VM: Mac OS - arm64 - 1000 - CoInterpreter VMMaker-tonel.1 uuid: 902dd483-c0c4-0d00-86f2-0f880df24b96 Oct 23 2023
StackToRegisterMappingCogit VMMaker-tonel.1 uuid: 902dd483-c0c4-0d00-86f2-0f880df24b96 Oct 23 2023
v10.0.8 - Commit: b323c5fb - Date: 2023-10-20 16:02:07 -0400

Image: Pharo11.0.0 [Build information: Pharo-11.0.0+build.710.sha.ea28d8552cac85a7ce1e9c34ab1e7bd45f7b9910 (64 Bit)]

MCPackageLoader(Object)>>notify:
	Receiver: a MCPackageLoader
	Arguments and temporary variables: 
		aString: 	'Package *Roassal3-Pharo9 depends on the following classes:
  RSLa[..]
	Receiver's instance variables: 
		requirements: 	#(#RSLayoutStudio)
		unloadableDefinitions: 	a SortedCollection(a MCMethodDefinition(RSLayoutStud[..]
		obsoletions: 	a Dictionary()
		additions: 	an OrderedCollection(a MCMethodDefinition(SpPresenter>>#open) a [..]
		removals: 	an OrderedCollection()
		errorDefinitions: 	nil
		provisions: 	a Set(#TRemoveTest #WeakSet #RSHorizontalLeftRightController #S[..]
		methodAdditions: 	an OrderedCollection()


MCPackageLoader>>warnAboutDependencies
	Receiver: a MCPackageLoader
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		requirements: 	#(#RSLayoutStudio)
		unloadableDefinitions: 	a SortedCollection(a MCMethodDefinition(RSLayoutStud[..]
		obsoletions: 	a Dictionary()
		additions: 	an OrderedCollection(a MCMethodDefinition(SpPresenter>>#open) a [..]
		removals: 	an OrderedCollection()
		errorDefinitions: 	nil
		provisions: 	a Set(#TRemoveTest #WeakSet #RSHorizontalLeftRightController #S[..]
		methodAdditions: 	an OrderedCollection()


MCPackageLoader>>validate
	Receiver: a MCPackageLoader
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		requirements: 	#(#RSLayoutStudio)
		unloadableDefinitions: 	a SortedCollection(a MCMethodDefinition(RSLayoutStud[..]
		obsoletions: 	a Dictionary()
		additions: 	an OrderedCollection(a MCMethodDefinition(SpPresenter>>#open) a [..]
		removals: 	an OrderedCollection()
		errorDefinitions: 	nil
		provisions: 	a Set(#TRemoveTest #WeakSet #RSHorizontalLeftRightController #S[..]
		methodAdditions: 	an OrderedCollection()


MCPackageLoader>>loadWithNameLike:
	Receiver: a MCPackageLoader
	Arguments and temporary variables: 
		baseName: 	'Roassal3-Pharo9-CompatibleUserName.1686657480'
	Receiver's instance variables: 
		requirements: 	#(#RSLayoutStudio)
		unloadableDefinitions: 	a SortedCollection(a MCMethodDefinition(RSLayoutStud[..]
		obsoletions: 	a Dictionary()
		additions: 	an OrderedCollection(a MCMethodDefinition(SpPresenter>>#open) a [..]
		removals: 	an OrderedCollection()
		errorDefinitions: 	nil
		provisions: 	a Set(#TRemoveTest #WeakSet #RSHorizontalLeftRightController #S[..]
		methodAdditions: 	an OrderedCollection()


MCVersionLoader>>basicLoadWithNameLike:
	Receiver: a MCVersionLoader
	Arguments and temporary variables: 
		aString: 	'Roassal3-Pharo9-CompatibleUserName.1686657480'
		loader: 	a MCPackageLoader
	Receiver's instance variables: 
		versions: 	an OrderedCollection(a MCVersion(an IceMCVersionInfo(Roassal3-Pha[..]


[ self basicLoadWithNameLike: aString ] in MCVersionLoader>>loadWithNameLike:
	Receiver: a MCVersionLoader
	Arguments and temporary variables: 
		aString: 	'Roassal3-Pharo9-CompatibleUserName.1686657480'
	Receiver's instance variables: 
		versions: 	an OrderedCollection(a MCVersion(an IceMCVersionInfo(Roassal3-Pha[..]


[ returnValue := aBlock value ] in [ 
		[ returnValue := aBlock value ] ensure: [ 
			self announceLoadStop: aString ] ] in MCVersionLoader>>announceLoad:do:
	Receiver: a MCVersionLoader
	Arguments and temporary variables: 
		aString: 	'Roassal3-Pharo9-CompatibleUserName.1686657480'
		aBlock: 	[ self basicLoadWithNameLike: aString ]
		returnValue: 	nil
	Receiver's instance variables: 
		versions: 	an OrderedCollection(a MCVersion(an IceMCVersionInfo(Roassal3-Pha[..]


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ returnValue := aBlock value ]
	Arguments and temporary variables: 
		aBlock: 	[ 
			self announceLoadStop: aString ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	[ 
		[ returnValue := aBlock value ] ensure: [ 
			self annou[..]
		compiledBlock: 	a CompiledBlock: [ returnValue := aBlock value ]
		numArgs: 	0
		receiver: 	a MCVersionLoader


[ 
		[ returnValue := aBlock value ] ensure: [ 
			self announceLoadStop: aString ] ] in MCVersionLoader>>announceLoad:do:
	Receiver: a MCVersionLoader
	Arguments and temporary variables: 
		aString: 	'Roassal3-Pharo9-CompatibleUserName.1686657480'
		aBlock: 	[ self basicLoadWithNameLike: aString ]
		returnValue: 	nil
	Receiver's instance variables: 
		versions: 	an OrderedCollection(a MCVersion(an IceMCVersionInfo(Roassal3-Pha[..]


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ self announceLoadStart: aString ]
	Arguments and temporary variables: 
		aBlock: 	[ 
		[ returnValue := aBlock value ] ensure: [ 
			self announceLoa[..]
		complete: 	true
		returnValue: 	a MCVersionLoader
	Receiver's instance variables: 
		outerContext: 	MCVersionLoader>>announceLoad:do:
		compiledBlock: 	a CompiledBlock: [ self announceLoadStart: aString ]
		numArgs: 	0
		receiver: 	a MCVersionLoader


MCVersionLoader>>announceLoad:do:
	Receiver: a MCVersionLoader
	Arguments and temporary variables: 
		returnValue: 	nil
		aString: 	'Roassal3-Pharo9-CompatibleUserName.1686657480'
		aBlock: 	[ self basicLoadWithNameLike: aString ]
	Receiver's instance variables: 
		versions: 	an OrderedCollection(a MCVersion(an IceMCVersionInfo(Roassal3-Pha[..]


MCVersionLoader>>loadWithNameLike:
	Receiver: a MCVersionLoader
	Arguments and temporary variables: 
		aString: 	'Roassal3-Pharo9-CompatibleUserName.1686657480'
	Receiver's instance variables: 
		versions: 	an OrderedCollection(a MCVersion(an IceMCVersionInfo(Roassal3-Pha[..]


[ self ensurePackage: version package.
		  self loadWithNameLike: version info name ] in [   
		| version |
		version := versions first. 
		[ self ensurePackage: version package.
		  self loadWithNameLike: version info name ] asJob
				title: 'Loading ', version info name asString;
				run ] in MCVersionLoader>>load
	Receiver: a MCVersionLoader
	Arguments and temporary variables: 
		version: 	a MCVersion(an IceMCVersionInfo(Roassal3-Pharo9-CompatibleUserName[..]
	Receiver's instance variables: 
		versions: 	an OrderedCollection(a MCVersion(an IceMCVersionInfo(Roassal3-Pha[..]


FullBlockClosure(BlockClosure)>>cull:
	Receiver: [ self ensurePackage: version package.
		  self loadWithNameLike: version info name ]
	Arguments and temporary variables: 
		anArg: 	a Job
	Receiver's instance variables: 
		outerContext: 	[   
		| version |
		version := versions first. 
		[ self ens[..]
		compiledBlock: 	a CompiledBlock: [ self ensurePackage: version package.
		  [..]
		numArgs: 	0
		receiver: 	a MCVersionLoader


[ ^ block cull: self ] in [ self prepareForRunning.
	  CurrentJob value: self during: [ ^ block cull: self ] ] in Job>>run
	Receiver: a Job
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		block: 	[ self ensurePackage: version package.
		  self loadWithNameLike: ve[..]
		currentValue: 	0
		min: 	0
		max: 	100
		title: 	'Loading Roassal3-Pharo9-CompatibleUserName.1686657480'
		children: 	an OrderedCollection()
		isRunning: 	true
		parent: 	a Job
		process: 	a Process in nil
		owner: 	a MCVersionLoader


[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in CurrentJob(DynamicVariable)>>value:during:
	Receiver: a CurrentJob
	Arguments and temporary variables: 
		anObject: 	a Job
		aBlock: 	[ ^ block cull: self ]
		activeProcess: 	a Process in nil
		oldValue: 	a Job
	Receiver's instance variables: 
		index: 	2


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ]
	Arguments and temporary variables: 
		aBlock: 	[
			activeProcess
				psValueAt: index
				put: oldValue ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	CurrentJob(DynamicVariable)>>value:during:
		compiledBlock: 	a CompiledBlock: [ activeProcess
			psValueAt: index
			put:[..]
		numArgs: 	0
		receiver: 	a CurrentJob


CurrentJob(DynamicVariable)>>value:during:
	Receiver: a CurrentJob
	Arguments and temporary variables: 
		anObject: 	a Job
		aBlock: 	[ ^ block cull: self ]
		activeProcess: 	a Process in nil
		oldValue: 	a Job
	Receiver's instance variables: 
		index: 	2


CurrentJob class(DynamicVariable class)>>value:during:
	Receiver: CurrentJob
	Arguments and temporary variables: 
		anObject: 	a Job
		aBlock: 	[ ^ block cull: self ]
	Receiver's instance variables: 
		superclass: 	DynamicVariable
		methodDict: 	a MethodDictionary()
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		commentSourcePointer: 	nil
		subclasses: 	nil
		name: 	#CurrentJob
		classPool: 	nil
		sharedPools: 	nil
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Jobs-Base'
		soleInstance: 	a CurrentJob


[ self prepareForRunning.
	  CurrentJob value: self during: [ ^ block cull: self ] ] in Job>>run
	Receiver: a Job
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		block: 	[ self ensurePackage: version package.
		  self loadWithNameLike: ve[..]
		currentValue: 	0
		min: 	0
		max: 	100
		title: 	'Loading Roassal3-Pharo9-CompatibleUserName.1686657480'
		children: 	an OrderedCollection()
		isRunning: 	true
		parent: 	a Job
		process: 	a Process in nil
		owner: 	a MCVersionLoader


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ self prepareForRunning.
	  CurrentJob value: self during: [ ^ block cull: self ] ]
	Arguments and temporary variables: 
		aBlock: 	[ self cleanupAfterRunning ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	Job>>run
		compiledBlock: 	a CompiledBlock: [ self prepareForRunning.
	  CurrentJob val[..]
		numArgs: 	0
		receiver: 	a Job


Job>>run
	Receiver: a Job
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		block: 	[ self ensurePackage: version package.
		  self loadWithNameLike: ve[..]
		currentValue: 	0
		min: 	0
		max: 	100
		title: 	'Loading Roassal3-Pharo9-CompatibleUserName.1686657480'
		children: 	an OrderedCollection()
		isRunning: 	true
		parent: 	a Job
		process: 	a Process in nil
		owner: 	a MCVersionLoader


[   
		| version |
		version := versions first. 
		[ self ensurePackage: version package.
		  self loadWithNameLike: version info name ] asJob
				title: 'Loading ', version info name asString;
				run ] in MCVersionLoader>>load
	Receiver: a MCVersionLoader
	Arguments and temporary variables: 
		version: 	a MCVersion(an IceMCVersionInfo(Roassal3-Pharo9-CompatibleUserName[..]
	Receiver's instance variables: 
		versions: 	an OrderedCollection(a MCVersion(an IceMCVersionInfo(Roassal3-Pha[..]


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [   
		| version |
		version := versions first. 
		[ self ensurePackage: version packa[..]
	Arguments and temporary variables: 
		aBlock: 	[
		self cacheActive: oldActive.
		self isCacheActive ifFalse: [ se[..]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	MCVersionLoader>>load
		compiledBlock: 	a CompiledBlock: [   
		| version |
		version := versions fi[..]
		numArgs: 	0
		receiver: 	a MCVersionLoader


RPackageSet class>>withCacheDo:
	Receiver: RPackageSet
	Arguments and temporary variables: 
		aBlock: 	[   
		| version |
		version := versions first. 
		[ self ensurePac[..]
		oldActive: 	false
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary(#asRPackageSet->RPackageSet>>#asRPackageSet [..]
		format: 	65543
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		commentSourcePointer: 	nil
		subclasses: 	{MetacelloTestsPackageSet}
		name: 	#RPackageSet
		classPool: 	nil
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'RPackage-Core-Base'
		cacheActive: 	true
		cachePackages: 	an IdentityDictionary(#'Roassal3-Pharo9'->a RPackageSet )


MCVersionLoader>>load
	Receiver: a MCVersionLoader
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		versions: 	an OrderedCollection(a MCVersion(an IceMCVersionInfo(Roassal3-Pha[..]


MetacelloGoferLoad(GoferLoad)>>execute
	Receiver: a MetacelloGoferLoad
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		gofer: 	a MetacelloGofer
		model: 	a MCVersionLoader


[ "mcLoader preLoad: packageSpec."
			goferLoad := MetacelloGoferLoad on: aGofer.
			goferLoad addResolved: resolvedReference.
			goferLoad execute.
			MetacelloPlatform current clearCurrentVersionCache	"mcLoader postLoad: packageSpec"
			] in [ | loadBlock goferLoad answers resolvedReference |

			aGofer disablePackageCache.	"for good luck:)"
			resolvedReference := self resolvePackageSpec: packageSpec gofer: aGofer.
			resolvedReference ifNil: [ "Package version already loaded into image" ^ self ].
			loadBlock := [ "mcLoader preLoad: packageSpec."
			goferLoad := MetacelloGoferLoad on: aGofer.
			goferLoad addResolved: resolvedReference.
			goferLoad execute.
			MetacelloPlatform current clearCurrentVersionCache	"mcLoader postLoad: packageSpec"
			].
			MetacelloNotification signal:
					'Loading -> ' , resolvedReference name , ' --- '
						, aPackageLoadDirective repository repositoryDescription , ' --- '
						, resolvedReference repository description.
			( answers := packageSpec answers ) notEmpty
				ifTrue: [ loadBlock valueSupplyingMetacelloAnswers: answers ]
				ifFalse: [ loadBlock value ].
			resolvedReference workingCopy repositoryGroup addRepository: aPackageLoadDirective repository.
			MetacelloNotification signal:
					'Loaded -> ' , resolvedReference name , ' --- '
						, aPackageLoadDirective repository repositoryDescription , ' --- '
						, resolvedReference repository description
			] in MetacelloLoadingMCSpecLoader(MetacelloCommonMCSpecLoader)>>loadPackageDirective:gofer:
	Receiver: a MetacelloLoadingMCSpecLoader
	Arguments and temporary variables: 
		aPackageLoadDirective: 	load : Roassal3-Pharo9-CompatibleUserName.1686657480
		aGofer: 	a MetacelloGofer
		packageSpec: 	spec name: #'Roassal3-Pharo9'
		loadBlock: 	[ "mcLoader preLoad: packageSpec."
			goferLoad := MetacelloGofe[..]
		answers: 	#()
		resolvedReference: 	a MetacelloCachingGoferResolvedReference name: 'Roassal3[..]
		goferLoad: 	a MetacelloGoferLoad
	Receiver's instance variables: 
		spec: 	a MetacelloMCVersionSpecLoader
		operator: 	nil
		loaderPolicy: 	a MetacelloLoaderPolicy
		disablePackageCache: 	false


[ | loadBlock goferLoad answers resolvedReference |

			aGofer disablePackageCache.	"for good luck:)"
			resolvedReference := self resolvePackageSpec: packageSpec gofer: aGofer.
			resolvedReference ifNil: [ "Package version already loaded into image" ^ self ].
			loadBlock := [ "mcLoader preLoad: packageSpec."
			goferLoad := MetacelloGoferLoad on: aGofer.
			goferLoad addResolved: resolvedReference.
			goferLoad execute.
			MetacelloPlatform current clearCurrentVersionCache	"mcLoader postLoad: packageSpec"
			].
			MetacelloNotification signal:
					'Loading -> ' , resolvedReference name , ' --- '
						, aPackageLoadDirective repository repositoryDescription , ' --- '
						, resolvedReference repository description.
			( answers := packageSpec answers ) notEmpty
				ifTrue: [ loadBlock valueSupplyingMetacelloAnswers: answers ]
				ifFalse: [ loadBlock value ].
			resolvedReference workingCopy repositoryGroup addRepository: aPackageLoadDirective repository.
			MetacelloNotification signal:
					'Loaded -> ' , resolvedReference name , ' --- '
						, aPackageLoadDirective repository repositoryDescription , ' --- '
						, resolvedReference repository description
			] in MetacelloLoadingMCSpecLoader(MetacelloCommonMCSpecLoader)>>loadPackageDirective:gofer:
	Receiver: a MetacelloLoadingMCSpecLoader
	Arguments and temporary variables: 
		aPackageLoadDirective: 	load : Roassal3-Pharo9-CompatibleUserName.1686657480
		aGofer: 	a MetacelloGofer
		packageSpec: 	spec name: #'Roassal3-Pharo9'
		goferLoad: 	a MetacelloGoferLoad
		loadBlock: 	[ "mcLoader preLoad: packageSpec."
			goferLoad := MetacelloGofe[..]
		answers: 	#()
		resolvedReference: 	a MetacelloCachingGoferResolvedReference name: 'Roassal3[..]
	Receiver's instance variables: 
		spec: 	a MetacelloMCVersionSpecLoader
		operator: 	nil
		loaderPolicy: 	a MetacelloLoaderPolicy
		disablePackageCache: 	false


[:bar |
            bar value: 1.
            aBlock value.
            bar value: 2 ] in IceMetacelloPharoPlatform(MetacelloPharoCommonPlatform)>>do:displaying:
	Receiver: an IceMetacelloPharoPlatform
	Arguments and temporary variables: 
		aBlock: 	[ | loadBlock goferLoad answers resolvedReference |

			aGofer disa[..]
		aString: 	'Loading Roassal3-Pharo9'
		bar: 	a Job
	Receiver's instance variables: 
		bypassProgressBars: 	false
		bypassGoferLoadUpdateCategories: 	false


FullBlockClosure(BlockClosure)>>cull:
	Receiver: [:bar |
            bar value: 1.
            aBlock value.
            bar value: 2 ]
	Arguments and temporary variables: 
		anArg: 	a Job
	Receiver's instance variables: 
		outerContext: 	IceMetacelloPharoPlatform(MetacelloPharoCommonPlatform)>>do:d[..]
		compiledBlock: 	a CompiledBlock: [:bar |
            bar value: 1.
         [..]
		numArgs: 	1
		receiver: 	an IceMetacelloPharoPlatform


[ ^ block cull: self ] in [ self prepareForRunning.
	  CurrentJob value: self during: [ ^ block cull: self ] ] in Job>>run
	Receiver: a Job
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		block: 	[:bar |
            bar value: 1.
            aBlock value.
        [..]
		currentValue: 	1
		min: 	0
		max: 	2
		title: 	'Loading Roassal3-Pharo9'
		children: 	an OrderedCollection(a Job)
		isRunning: 	true
		parent: 	a Job
		process: 	a Process in nil
		owner: 	a MorphicUIManager


[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in CurrentJob(DynamicVariable)>>value:during:
	Receiver: a CurrentJob
	Arguments and temporary variables: 
		anObject: 	a Job
		aBlock: 	[ ^ block cull: self ]
		activeProcess: 	a Process in nil
		oldValue: 	a Job
	Receiver's instance variables: 
		index: 	2


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ]
	Arguments and temporary variables: 
		aBlock: 	[
			activeProcess
				psValueAt: index
				put: oldValue ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	CurrentJob(DynamicVariable)>>value:during:
		compiledBlock: 	a CompiledBlock: [ activeProcess
			psValueAt: index
			put:[..]
		numArgs: 	0
		receiver: 	a CurrentJob


CurrentJob(DynamicVariable)>>value:during:
	Receiver: a CurrentJob
	Arguments and temporary variables: 
		anObject: 	a Job
		aBlock: 	[ ^ block cull: self ]
		activeProcess: 	a Process in nil
		oldValue: 	a Job
	Receiver's instance variables: 
		index: 	2


CurrentJob class(DynamicVariable class)>>value:during:
	Receiver: CurrentJob
	Arguments and temporary variables: 
		anObject: 	a Job
		aBlock: 	[ ^ block cull: self ]
	Receiver's instance variables: 
		superclass: 	DynamicVariable
		methodDict: 	a MethodDictionary()
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		commentSourcePointer: 	nil
		subclasses: 	nil
		name: 	#CurrentJob
		classPool: 	nil
		sharedPools: 	nil
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Jobs-Base'
		soleInstance: 	a CurrentJob


[ self prepareForRunning.
	  CurrentJob value: self during: [ ^ block cull: self ] ] in Job>>run
	Receiver: a Job
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		block: 	[:bar |
            bar value: 1.
            aBlock value.
        [..]
		currentValue: 	1
		min: 	0
		max: 	2
		title: 	'Loading Roassal3-Pharo9'
		children: 	an OrderedCollection(a Job)
		isRunning: 	true
		parent: 	a Job
		process: 	a Process in nil
		owner: 	a MorphicUIManager


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ self prepareForRunning.
	  CurrentJob value: self during: [ ^ block cull: self ] ]
	Arguments and temporary variables: 
		aBlock: 	[ self cleanupAfterRunning ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	Job>>run
		compiledBlock: 	a CompiledBlock: [ self prepareForRunning.
	  CurrentJob val[..]
		numArgs: 	0
		receiver: 	a Job


Job>>run
	Receiver: a Job
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		block: 	[:bar |
            bar value: 1.
            aBlock value.
        [..]
		currentValue: 	1
		min: 	0
		max: 	2
		title: 	'Loading Roassal3-Pharo9'
		children: 	an OrderedCollection(a Job)
		isRunning: 	true
		parent: 	a Job
		process: 	a Process in nil
		owner: 	a MorphicUIManager



--- The full stack ---
MCPackageLoader(Object)>>notify:
MCPackageLoader>>warnAboutDependencies
MCPackageLoader>>validate
MCPackageLoader>>loadWithNameLike:
MCVersionLoader>>basicLoadWithNameLike:
[ self basicLoadWithNameLike: aString ] in MCVersionLoader>>loadWithNameLike:
[ returnValue := aBlock value ] in [ 
		[ returnValue := aBlock value ] ensure: [ 
			self announceLoadStop: aString ] ] in MCVersionLoader>>announceLoad:do:
FullBlockClosure(BlockClosure)>>ensure:
[ 
		[ returnValue := aBlock value ] ensure: [ 
			self announceLoadStop: aString ] ] in MCVersionLoader>>announceLoad:do:
FullBlockClosure(BlockClosure)>>ensure:
MCVersionLoader>>announceLoad:do:
MCVersionLoader>>loadWithNameLike:
[ self ensurePackage: version package.
		  self loadWithNameLike: version info name ] in [   
		| version |
		version := versions first. 
		[ self ensurePackage: version package.
		  self loadWithNameLike: version info name ] asJob
				title: 'Loading ', version info name asString;
				run ] in MCVersionLoader>>load
FullBlockClosure(BlockClosure)>>cull:
[ ^ block cull: self ] in [ self prepareForRunning.
	  CurrentJob value: self during: [ ^ block cull: self ] ] in Job>>run
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in CurrentJob(DynamicVariable)>>value:during:
FullBlockClosure(BlockClosure)>>ensure:
CurrentJob(DynamicVariable)>>value:during:
CurrentJob class(DynamicVariable class)>>value:during:
[ self prepareForRunning.
	  CurrentJob value: self during: [ ^ block cull: self ] ] in Job>>run
FullBlockClosure(BlockClosure)>>ensure:
Job>>run
[   
		| version |
		version := versions first. 
		[ self ensurePackage: version package.
		  self loadWithNameLike: version info name ] asJob
				title: 'Loading ', version info name asString;
				run ] in MCVersionLoader>>load
FullBlockClosure(BlockClosure)>>ensure:
RPackageSet class>>withCacheDo:
MCVersionLoader>>load
MetacelloGoferLoad(GoferLoad)>>execute
[ "mcLoader preLoad: packageSpec."
			goferLoad := MetacelloGoferLoad on: aGofer.
			goferLoad addResolved: resolvedReference.
			goferLoad execute.
			MetacelloPlatform current clearCurrentVersionCache	"mcLoader postLoad: packageSpec"
			] in [ | loadBlock goferLoad answers resolvedReference |

			aGofer disablePackageCache.	"for good luck:)"
			resolvedReference := self resolvePackageSpec: packageSpec gofer: aGofer.
			resolvedReference ifNil: [ "Package version already loaded into image" ^ self ].
			loadBlock := [ "mcLoader preLoad: packageSpec."
			goferLoad := MetacelloGoferLoad on: aGofer.
			goferLoad addResolved: resolvedReference.
			goferLoad execute.
			MetacelloPlatform current clearCurrentVersionCache	"mcLoader postLoad: packageSpec"
			].
			MetacelloNotification signal:
					'Loading -> ' , resolvedReference name , ' --- '
						, aPackageLoadDirective repository repositoryDescription , ' --- '
						, resolvedReference repository description.
			( answers := packageSpec answers ) notEmpty
				ifTrue: [ loadBlock valueSupplyingMetacelloAnswers: answers ]
				ifFalse: [ loadBlock value ].
			resolvedReference workingCopy repositoryGroup addRepository: aPackageLoadDirective repository.
			MetacelloNotification signal:
					'Loaded -> ' , resolvedReference name , ' --- '
						, aPackageLoadDirective repository repositoryDescription , ' --- '
						, resolvedReference repository description
			] in MetacelloLoadingMCSpecLoader(MetacelloCommonMCSpecLoader)>>loadPackageDirective:gofer:
[ | loadBlock goferLoad answers resolvedReference |

			aGofer disablePackageCache.	"for good luck:)"
			resolvedReference := self resolvePackageSpec: packageSpec gofer: aGofer.
			resolvedReference ifNil: [ "Package version already loaded into image" ^ self ].
			loadBlock := [ "mcLoader preLoad: packageSpec."
			goferLoad := MetacelloGoferLoad on: aGofer.
			goferLoad addResolved: resolvedReference.
			goferLoad execute.
			MetacelloPlatform current clearCurrentVersionCache	"mcLoader postLoad: packageSpec"
			].
			MetacelloNotification signal:
					'Loading -> ' , resolvedReference name , ' --- '
						, aPackageLoadDirective repository repositoryDescription , ' --- '
						, resolvedReference repository description.
			( answers := packageSpec answers ) notEmpty
				ifTrue: [ loadBlock valueSupplyingMetacelloAnswers: answers ]
				ifFalse: [ loadBlock value ].
			resolvedReference workingCopy repositoryGroup addRepository: aPackageLoadDirective repository.
			MetacelloNotification signal:
					'Loaded -> ' , resolvedReference name , ' --- '
						, aPackageLoadDirective repository repositoryDescription , ' --- '
						, resolvedReference repository description
			] in MetacelloLoadingMCSpecLoader(MetacelloCommonMCSpecLoader)>>loadPackageDirective:gofer:
[:bar |
            bar value: 1.
            aBlock value.
            bar value: 2 ] in IceMetacelloPharoPlatform(MetacelloPharoCommonPlatform)>>do:displaying:
FullBlockClosure(BlockClosure)>>cull:
[ ^ block cull: self ] in [ self prepareForRunning.
	  CurrentJob value: self during: [ ^ block cull: self ] ] in Job>>run
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in CurrentJob(DynamicVariable)>>value:during:
FullBlockClosure(BlockClosure)>>ensure:
CurrentJob(DynamicVariable)>>value:during:
CurrentJob class(DynamicVariable class)>>value:during:
[ self prepareForRunning.
	  CurrentJob value: self during: [ ^ block cull: self ] ] in Job>>run
FullBlockClosure(BlockClosure)>>ensure:
Job>>run
 - - - - - - - - - - - - - - -
			- - - - - - - - - - - - - - - - - -
MorphicUIManager(UIManager)>>displayProgress:from:to:during:
ByteString(String)>>displayProgressFrom:to:during:
IceMetacelloPharoPlatform(MetacelloPharoCommonPlatform)>>do:displaying:
MetacelloLoadingMCSpecLoader(MetacelloCommonMCSpecLoader)>>loadPackageDirective:gofer:
MetacelloLinearLoadDirective(MetacelloVersionLoadDirective)>>loadPackageDirective:gofer:
MetacelloPackageLoadDirective>>loadUsing:gofer:
[:directive | directive loadUsing: aLoaderDirective gofer: aGofer ] in MetacelloLinearLoadDirective(MetacelloVersionLoadDirective)>>loadLinearLoadDirective:gofer:
OrderedCollection>>do:
MetacelloLinearLoadDirective(MetacelloVersionLoadDirective)>>loadLinearLoadDirective:gofer:
MetacelloLinearLoadDirective>>loadUsing:gofer:
[:directive | directive loadUsing: aLoaderDirective gofer: aGofer ] in MetacelloLinearLoadDirective(MetacelloVersionLoadDirective)>>loadLinearLoadDirective:gofer:
OrderedCollection>>do:
MetacelloLinearLoadDirective(MetacelloVersionLoadDirective)>>loadLinearLoadDirective:gofer:
MetacelloLinearLoadDirective>>loadUsing:gofer:
MetacelloLinearLoadDirective(MetacelloVersionLoadDirective)>>loadWithPolicy:
MetacelloLoaderPolicy>>load
MetacelloFetchingMCSpecLoader>>doLoad
[  fetchLoader doLoad ] in [	| fetchLoader |
		fetchLoader := self fetchRequiredFromArray: (self defaultPackageNamesToLoad: anArray).
		MetacelloPlatform current
			do:  [  fetchLoader doLoad ]
			displaying: 'Loading ', displayString.
		MetacelloNotification signal: ('...finished ', self versionNumber printString).
		^fetchLoader ] in MetacelloMCVersion>>doLoadRequiredFromArray:
[:bar |
            bar value: 1.
            aBlock value.
            bar value: 2 ] in IceMetacelloPharoPlatform(MetacelloPharoCommonPlatform)>>do:displaying:
FullBlockClosure(BlockClosure)>>cull:
[ ^ block cull: self ] in [ self prepareForRunning.
	  CurrentJob value: self during: [ ^ block cull: self ] ] in Job>>run
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in CurrentJob(DynamicVariable)>>value:during:
FullBlockClosure(BlockClosure)>>ensure:
CurrentJob(DynamicVariable)>>value:during:
CurrentJob class(DynamicVariable class)>>value:during:
[ self prepareForRunning.
	  CurrentJob value: self during: [ ^ block cull: self ] ] in Job>>run
FullBlockClosure(BlockClosure)>>ensure:
Job>>run
MorphicUIManager(UIManager)>>displayProgress:from:to:during:
ByteString(String)>>displayProgressFrom:to:during:
IceMetacelloPharoPlatform(MetacelloPharoCommonPlatform)>>do:displaying:
[	| fetchLoader |
		fetchLoader := self fetchRequiredFromArray: (self defaultPackageNamesToLoad: anArray).
		MetacelloPlatform current
			do:  [  fetchLoader doLoad ]
			displaying: 'Loading ', displayString.
		MetacelloNotification signal: ('...finished ', self versionNumber printString).
		^fetchLoader ] in MetacelloMCVersion>>doLoadRequiredFromArray:
FullBlockClosure(BlockClosure)>>ensure:
MetacelloMCVersion>>doLoadRequiredFromArray:
MetacelloMCVersion>>load
[ 
          | version loadedSpec |
          self setDefaultsAndValidateProjectSpec.
          [ loadedSpec := (self lookupProjectSpecFor: self projectSpec) copy ]
            on: MetacelloAllowProjectDowngrade , MetacelloAllowProjectUpgrade
            do: [ :ex | ex handleOnDownGrade: onDownGradeBlock onUpgrade: onUpgradeBlock ].
          version := loadedSpec versionForScriptEngine: self.
          self
            root:
              (required isEmpty
                ifTrue: [ version load ]
                ifFalse: [ version load: required ]) loadDirective.
          loadedSpec loads: required.
          MetacelloProjectRegistration
            registrationForProjectSpec: loadedSpec
            ifAbsent: [ :new | 
              new
                loadedInImage: true;
                registerProject ]
            ifPresent: [ :existing :new | 
              existing
                copyOnWrite: [ :existingCopy | 
                  existingCopy
                    loadedInImage: true;
                    merge: new ] ] ] in [ 
      self
        handleNotificationsForAction: [ 
          | version loadedSpec |
          self setDefaultsAndValidateProjectSpec.
          [ loadedSpec := (self lookupProjectSpecFor: self projectSpec) copy ]
            on: MetacelloAllowProjectDowngrade , MetacelloAllowProjectUpgrade
            do: [ :ex | ex handleOnDownGrade: onDownGradeBlock onUpgrade: onUpgradeBlock ].
          version := loadedSpec versionForScriptEngine: self.
          self
            root:
              (required isEmpty
                ifTrue: [ version load ]
                ifFalse: [ version load: required ]) loadDirective.
          loadedSpec loads: required.
          MetacelloProjectRegistration
            registrationForProjectSpec: loadedSpec
            ifAbsent: [ :new | 
              new
                loadedInImage: true;
                registerProject ]
            ifPresent: [ :existing :new | 
              existing
                copyOnWrite: [ :existingCopy | 
                  existingCopy
                    loadedInImage: true;
                    merge: new ] ] ] ] in MetacelloScriptEngine>>load:onProjectDownGrade:onProjectUpgrade:
FullBlockClosure(BlockClosure)>>on:do:
[ 
  actionBlock
    on:
      MetacelloLookupProjectSpec , MetacelloLookupProjectSpecForLoad
        , MetacelloProjectSpecLoadedNotification
        , MetacelloScriptEnsureProjectLoadedForDevelopment
        , MetacelloLookupBaselineSpecForEnsureLoad
    do: [ :ex | 
      "lookup and registration handlers need to be innermost set of handlers ...they may throw option notifications"
      ex handleResolutionFor: self ] ] in [ 
  [ 
  actionBlock
    on:
      MetacelloLookupProjectSpec , MetacelloLookupProjectSpecForLoad
        , MetacelloProjectSpecLoadedNotification
        , MetacelloScriptEnsureProjectLoadedForDevelopment
        , MetacelloLookupBaselineSpecForEnsureLoad
    do: [ :ex | 
      "lookup and registration handlers need to be innermost set of handlers ...they may throw option notifications"
      ex handleResolutionFor: self ] ]
    on:
      MetacelloAllowProjectDowngrade , MetacelloAllowProjectUpgrade
        , MetacelloAllowConflictingProjectUpgrade
    do: [ :ex | 
      "option handlers need to be outermost set of handlers ... last line of defense before users are involved"
      ex handleResolutionFor: self ] ] in [ 
  [ 
  [ 
  actionBlock
    on:
      MetacelloLookupProjectSpec , MetacelloLookupProjectSpecForLoad
        , MetacelloProjectSpecLoadedNotification
        , MetacelloScriptEnsureProjectLoadedForDevelopment
        , MetacelloLookupBaselineSpecForEnsureLoad
    do: [ :ex | 
      "lookup and registration handlers need to be innermost set of handlers ...they may throw option notifications"
      ex handleResolutionFor: self ] ]
    on:
      MetacelloAllowProjectDowngrade , MetacelloAllowProjectUpgrade
        , MetacelloAllowConflictingProjectUpgrade
    do: [ :ex | 
      "option handlers need to be outermost set of handlers ... last line of defense before users are involved"
      ex handleResolutionFor: self ] ]
    on: MetacelloAllowLockedProjectChange
    do: [ :ex | 
      "MetacelloAllowLockedProjectChange need to be outermost handler ... since it is signaled from second line of handlers"
      ex handleResolutionFor: self ] ] in MetacelloScriptEngine>>handleNotificationsForAction:
FullBlockClosure(BlockClosure)>>on:do:
[ 
  [ 
  actionBlock
    on:
      MetacelloLookupProjectSpec , MetacelloLookupProjectSpecForLoad
        , MetacelloProjectSpecLoadedNotification
        , MetacelloScriptEnsureProjectLoadedForDevelopment
        , MetacelloLookupBaselineSpecForEnsureLoad
    do: [ :ex | 
      "lookup and registration handlers need to be innermost set of handlers ...they may throw option notifications"
      ex handleResolutionFor: self ] ]
    on:
      MetacelloAllowProjectDowngrade , MetacelloAllowProjectUpgrade
        , MetacelloAllowConflictingProjectUpgrade
    do: [ :ex | 
      "option handlers need to be outermost set of handlers ... last line of defense before users are involved"
      ex handleResolutionFor: self ] ] in [ 
  [ 
  [ 
  actionBlock
    on:
      MetacelloLookupProjectSpec , MetacelloLookupProjectSpecForLoad
        , MetacelloProjectSpecLoadedNotification
        , MetacelloScriptEnsureProjectLoadedForDevelopment
        , MetacelloLookupBaselineSpecForEnsureLoad
    do: [ :ex | 
      "lookup and registration handlers need to be innermost set of handlers ...they may throw option notifications"
      ex handleResolutionFor: self ] ]
    on:
      MetacelloAllowProjectDowngrade , MetacelloAllowProjectUpgrade
        , MetacelloAllowConflictingProjectUpgrade
    do: [ :ex | 
      "option handlers need to be outermost set of handlers ... last line of defense before users are involved"
      ex handleResolutionFor: self ] ]
    on: MetacelloAllowLockedProjectChange
    do: [ :ex | 
      "MetacelloAllowLockedProjectChange need to be outermost handler ... since it is signaled from second line of handlers"
      ex handleResolutionFor: self ] ] in MetacelloScriptEngine>>handleNotificationsForAction:
FullBlockClosure(BlockClosure)>>on:do:
[ 
  [ 
  [ 
  actionBlock
    on:
      MetacelloLookupProjectSpec , MetacelloLookupProjectSpecForLoad
        , MetacelloProjectSpecLoadedNotification
        , MetacelloScriptEnsureProjectLoadedForDevelopment
        , MetacelloLookupBaselineSpecForEnsureLoad
    do: [ :ex | 
      "lookup and registration handlers need to be innermost set of handlers ...they may throw option notifications"
      ex handleResolutionFor: self ] ]
    on:
      MetacelloAllowProjectDowngrade , MetacelloAllowProjectUpgrade
        , MetacelloAllowConflictingProjectUpgrade
    do: [ :ex | 
      "option handlers need to be outermost set of handlers ... last line of defense before users are involved"
      ex handleResolutionFor: self ] ]
    on: MetacelloAllowLockedProjectChange
    do: [ :ex | 
      "MetacelloAllowLockedProjectChange need to be outermost handler ... since it is signaled from second line of handlers"
      ex handleResolutionFor: self ] ] in MetacelloScriptEngine>>handleNotificationsForAction:
FullBlockClosure(BlockClosure)>>on:do:
MetacelloScriptEngine>>handleNotificationsForAction:
[ 
      self
        handleNotificationsForAction: [ 
          | version loadedSpec |
          self setDefaultsAndValidateProjectSpec.
          [ loadedSpec := (self lookupProjectSpecFor: self projectSpec) copy ]
            on: MetacelloAllowProjectDowngrade , MetacelloAllowProjectUpgrade
            do: [ :ex | ex handleOnDownGrade: onDownGradeBlock onUpgrade: onUpgradeBlock ].
          version := loadedSpec versionForScriptEngine: self.
          self
            root:
              (required isEmpty
                ifTrue: [ version load ]
                ifFalse: [ version load: required ]) loadDirective.
          loadedSpec loads: required.
          MetacelloProjectRegistration
            registrationForProjectSpec: loadedSpec
            ifAbsent: [ :new | 
              new
                loadedInImage: true;
                registerProject ]
            ifPresent: [ :existing :new | 
              existing
                copyOnWrite: [ :existingCopy | 
                  existingCopy
                    loadedInImage: true;
                    merge: new ] ] ] ] in MetacelloScriptEngine>>load:onProjectDownGrade:onProjectUpgrade:
FullBlockClosure(BlockClosure)>>ensure:
MetacelloProjectRegistration class>>copyRegistryRestoreOnErrorWhile:
MetacelloScriptEngine>>load:onProjectDownGrade:onProjectUpgrade:
MetacelloScriptEngine>>load:
[ :projectSpec | 
      | engine |
      engine := MetacelloScriptEngine new
        options: self options copy;
        projectSpec: projectSpec;
        yourself.
      engine perform: actionArg key withArguments: actionArg value.
      engine root ifNotNil: [ :root | self roots add: root ] ] in MetacelloScriptApiExecutor(MetacelloScriptExecutor)>>execute:
[ :projectSpec | 
      projectSpec
        ifNotNil: [ projectSpecBlock value: (self applyArgsToProjectSpec: projectSpec copy) ] ] in MetacelloScriptApiExecutor>>executeString:do:
Array(SequenceableCollection)>>do:
MetacelloScriptApiExecutor>>executeString:do:
ByteString(String)>>execute:against:
MetacelloScriptApiExecutor(MetacelloScriptExecutor)>>execute:
[ 
		super execute: statements ] in MetacelloScriptApiExecutor>>execute:
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in IceMetacelloLoadSessionContext(DynamicVariable)>>value:during:
FullBlockClosure(BlockClosure)>>ensure:
IceMetacelloLoadSessionContext(DynamicVariable)>>value:during:
IceMetacelloLoadSessionContext class(DynamicVariable class)>>value:during:
IceMetacelloPharoPlatform>>withMetacelloLoadSessionDo:
MetacelloScriptApiExecutor>>execute:
Metacello>>execute:args:
Metacello>>load
UndefinedObject>>DoIt
OCReceiverDoItSemanticScope(OCDoItSemanticScope)>>evaluateDoIt:
OpalCompiler>>evaluate
[
		self announcer announce: (SpCodeWillBeEvaluatedAnnouncement newContent: aString).
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionModel doItReceiver.
		result := receiver class compiler
			source: aString;
			context: self interactionModel doItContext;
			receiver: self interactionModel doItReceiver;
			requestor: self interactionModel;
			environment: self environment;
			failBlock:  [ 
				self announcer announce: (SpCodeEvaluationFailedAnnouncement newContent: aString).
				^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		self announcer announce: (SpCodeEvaluationSucceedAnnouncement newContent: aString).
		result ] in SpCodePresenter>>evaluate:onCompileError:onError:
FullBlockClosure(BlockClosure)>>on:do:
SpCodePresenter>>evaluate:onCompileError:onError:
StPlaygroundPagePresenter>>doEvaluateAndGo
StPlaygroundPagePresenter>>doEvaluateAllAndGo
StPlaygroundDoItCommand>>execute
SpCommand(CmCommandDecorator)>>execute
[ specCommand execute ] in [ :specCommand | 
			aButtonClass new
				label: specCommand name;
				help: specCommand description;
				in: [ :button | 
					specCommand hasIcon
						ifTrue: [ button icon: specCommand icon ] ];
				action: [ specCommand execute ];
				yourself ] in SpCommand>>configureAsButtonOfClass:
FullBlockClosure(BlockClosure)>>cull:
SpMorphicToolbarButtonAdapter>>execute
SpToolbarButtonMorph(PluggableButtonMorph)>>performAction:
[:m |
		(m containsPoint: evt cursorPoint) ifTrue: [m enabled ifTrue: [ m performAction: evt ]]] in SpToolbarButtonMorph(PluggableButtonMorph)>>mouseUp:
Array(SequenceableCollection)>>do:
SpToolbarButtonMorph(PluggableButtonMorph)>>mouseUp:
SpToolbarButtonMorph(Morph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
SpToolbarButtonMorph(Morph)>>handleEvent:
SpToolbarButtonMorph(Morph)>>handleFocusEvent:
[
		result := focusHolder handleFocusEvent: transformedEvent.
	] in HandMorph>>sendFocusEvent:to:clear:
FullBlockClosure(BlockClosure)>>on:do:
WorldMorph>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil ]) ifTrue: [
			morphicWorld activeHand handleEvent: anEvent
		]
	] in OSWindowMorphicEventHandler>>dispatchMorphicEvent:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycleNow
WorldMorph>>doOneCycle
[
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMutex critical: [
			                     self extraWorldList ].
		extraWorldsToDraw do: [ :world | world doOneCycle ].

		(self currentWorld isNotNil and: [
			 (extraWorldsToDraw includes: self currentWorld) not ]) ifTrue: [
			self currentWorld doOneCycle ] ] in WorldMorph class>>doOneCycle
FullBlockClosure(BlockClosure)>>ensure:
WorldState class>>doDrawCycleWith:
WorldMorph class>>doOneCycle
MorphicRenderLoop>>doOneCycle
MorphicRenderLoop>>doOneCycleWhile:
[ MorphicRenderLoop new doOneCycleWhile: [ true ] ] in MorphicUIManager>>spawnNewProcess
[self value.
			"IMPORTANT: Do not step over next line of code. See method comments for details"
			Processor terminateRealActive] in FullBlockClosure(BlockClosure)>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
Warning: Package *Roassal3-Pharo9 depends on the following classes:
  RSLayoutStudio
You must resolve these dependencies before you will be able to load these definitions: 
  RSLayoutStudio>>#defaultSpec

23 October 2023 11:25:38.392139 pm

VM: Mac OS - arm64 - 1000 - CoInterpreter VMMaker-tonel.1 uuid: 902dd483-c0c4-0d00-86f2-0f880df24b96 Oct 23 2023
StackToRegisterMappingCogit VMMaker-tonel.1 uuid: 902dd483-c0c4-0d00-86f2-0f880df24b96 Oct 23 2023
v10.0.8 - Commit: b323c5fb - Date: 2023-10-20 16:02:07 -0400

Image: Pharo11.0.0 [Build information: Pharo-11.0.0+build.710.sha.ea28d8552cac85a7ce1e9c34ab1e7bd45f7b9910 (64 Bit)]

MCPackageLoader(Object)>>notify:
	Receiver: a MCPackageLoader
	Arguments and temporary variables: 
		aString: 	'Package *Roassal3-Pharo9 depends on the following classes:
  RSLa[..]
	Receiver's instance variables: 
		requirements: 	#(#RSLayoutStudio)
		unloadableDefinitions: 	a SortedCollection(a MCMethodDefinition(RSLayoutStud[..]
		obsoletions: 	a Dictionary()
		additions: 	an OrderedCollection(a MCMethodDefinition(SpPresenter>>#open) a [..]
		removals: 	an OrderedCollection()
		errorDefinitions: 	nil
		provisions: 	a Set(#TRemoveTest #WeakSet #RSHorizontalLeftRightController #S[..]
		methodAdditions: 	an OrderedCollection()


MCPackageLoader>>warnAboutDependencies
	Receiver: a MCPackageLoader
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		requirements: 	#(#RSLayoutStudio)
		unloadableDefinitions: 	a SortedCollection(a MCMethodDefinition(RSLayoutStud[..]
		obsoletions: 	a Dictionary()
		additions: 	an OrderedCollection(a MCMethodDefinition(SpPresenter>>#open) a [..]
		removals: 	an OrderedCollection()
		errorDefinitions: 	nil
		provisions: 	a Set(#TRemoveTest #WeakSet #RSHorizontalLeftRightController #S[..]
		methodAdditions: 	an OrderedCollection()


MCPackageLoader>>validate
	Receiver: a MCPackageLoader
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		requirements: 	#(#RSLayoutStudio)
		unloadableDefinitions: 	a SortedCollection(a MCMethodDefinition(RSLayoutStud[..]
		obsoletions: 	a Dictionary()
		additions: 	an OrderedCollection(a MCMethodDefinition(SpPresenter>>#open) a [..]
		removals: 	an OrderedCollection()
		errorDefinitions: 	nil
		provisions: 	a Set(#TRemoveTest #WeakSet #RSHorizontalLeftRightController #S[..]
		methodAdditions: 	an OrderedCollection()


MCPackageLoader>>loadWithNameLike:
	Receiver: a MCPackageLoader
	Arguments and temporary variables: 
		baseName: 	'Roassal3-Pharo9-CompatibleUserName.1686657480'
	Receiver's instance variables: 
		requirements: 	#(#RSLayoutStudio)
		unloadableDefinitions: 	a SortedCollection(a MCMethodDefinition(RSLayoutStud[..]
		obsoletions: 	a Dictionary()
		additions: 	an OrderedCollection(a MCMethodDefinition(SpPresenter>>#open) a [..]
		removals: 	an OrderedCollection()
		errorDefinitions: 	nil
		provisions: 	a Set(#TRemoveTest #WeakSet #RSHorizontalLeftRightController #S[..]
		methodAdditions: 	an OrderedCollection()


MCVersionLoader>>basicLoadWithNameLike:
	Receiver: a MCVersionLoader
	Arguments and temporary variables: 
		aString: 	'Roassal3-Pharo9-CompatibleUserName.1686657480'
		loader: 	a MCPackageLoader
	Receiver's instance variables: 
		versions: 	an OrderedCollection(a MCVersion(an IceMCVersionInfo(Roassal3-Pha[..]


[ self basicLoadWithNameLike: aString ] in MCVersionLoader>>loadWithNameLike:
	Receiver: a MCVersionLoader
	Arguments and temporary variables: 
		aString: 	'Roassal3-Pharo9-CompatibleUserName.1686657480'
	Receiver's instance variables: 
		versions: 	an OrderedCollection(a MCVersion(an IceMCVersionInfo(Roassal3-Pha[..]


[ returnValue := aBlock value ] in [ 
		[ returnValue := aBlock value ] ensure: [ 
			self announceLoadStop: aString ] ] in MCVersionLoader>>announceLoad:do:
	Receiver: a MCVersionLoader
	Arguments and temporary variables: 
		aString: 	'Roassal3-Pharo9-CompatibleUserName.1686657480'
		aBlock: 	[ self basicLoadWithNameLike: aString ]
		returnValue: 	nil
	Receiver's instance variables: 
		versions: 	an OrderedCollection(a MCVersion(an IceMCVersionInfo(Roassal3-Pha[..]


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ returnValue := aBlock value ]
	Arguments and temporary variables: 
		aBlock: 	[ 
			self announceLoadStop: aString ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	[ 
		[ returnValue := aBlock value ] ensure: [ 
			self annou[..]
		compiledBlock: 	a CompiledBlock: [ returnValue := aBlock value ]
		numArgs: 	0
		receiver: 	a MCVersionLoader


[ 
		[ returnValue := aBlock value ] ensure: [ 
			self announceLoadStop: aString ] ] in MCVersionLoader>>announceLoad:do:
	Receiver: a MCVersionLoader
	Arguments and temporary variables: 
		aString: 	'Roassal3-Pharo9-CompatibleUserName.1686657480'
		aBlock: 	[ self basicLoadWithNameLike: aString ]
		returnValue: 	nil
	Receiver's instance variables: 
		versions: 	an OrderedCollection(a MCVersion(an IceMCVersionInfo(Roassal3-Pha[..]


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ self announceLoadStart: aString ]
	Arguments and temporary variables: 
		aBlock: 	[ 
		[ returnValue := aBlock value ] ensure: [ 
			self announceLoa[..]
		complete: 	true
		returnValue: 	a MCVersionLoader
	Receiver's instance variables: 
		outerContext: 	MCVersionLoader>>announceLoad:do:
		compiledBlock: 	a CompiledBlock: [ self announceLoadStart: aString ]
		numArgs: 	0
		receiver: 	a MCVersionLoader


MCVersionLoader>>announceLoad:do:
	Receiver: a MCVersionLoader
	Arguments and temporary variables: 
		returnValue: 	nil
		aString: 	'Roassal3-Pharo9-CompatibleUserName.1686657480'
		aBlock: 	[ self basicLoadWithNameLike: aString ]
	Receiver's instance variables: 
		versions: 	an OrderedCollection(a MCVersion(an IceMCVersionInfo(Roassal3-Pha[..]


MCVersionLoader>>loadWithNameLike:
	Receiver: a MCVersionLoader
	Arguments and temporary variables: 
		aString: 	'Roassal3-Pharo9-CompatibleUserName.1686657480'
	Receiver's instance variables: 
		versions: 	an OrderedCollection(a MCVersion(an IceMCVersionInfo(Roassal3-Pha[..]


[ self ensurePackage: version package.
		  self loadWithNameLike: version info name ] in [   
		| version |
		version := versions first. 
		[ self ensurePackage: version package.
		  self loadWithNameLike: version info name ] asJob
				title: 'Loading ', version info name asString;
				run ] in MCVersionLoader>>load
	Receiver: a MCVersionLoader
	Arguments and temporary variables: 
		version: 	a MCVersion(an IceMCVersionInfo(Roassal3-Pharo9-CompatibleUserName[..]
	Receiver's instance variables: 
		versions: 	an OrderedCollection(a MCVersion(an IceMCVersionInfo(Roassal3-Pha[..]


FullBlockClosure(BlockClosure)>>cull:
	Receiver: [ self ensurePackage: version package.
		  self loadWithNameLike: version info name ]
	Arguments and temporary variables: 
		anArg: 	a Job
	Receiver's instance variables: 
		outerContext: 	[   
		| version |
		version := versions first. 
		[ self ens[..]
		compiledBlock: 	a CompiledBlock: [ self ensurePackage: version package.
		  [..]
		numArgs: 	0
		receiver: 	a MCVersionLoader


[ ^ block cull: self ] in [ self prepareForRunning.
	  CurrentJob value: self during: [ ^ block cull: self ] ] in Job>>run
	Receiver: a Job
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		block: 	[ self ensurePackage: version package.
		  self loadWithNameLike: ve[..]
		currentValue: 	0
		min: 	0
		max: 	100
		title: 	'Loading Roassal3-Pharo9-CompatibleUserName.1686657480'
		children: 	an OrderedCollection()
		isRunning: 	true
		parent: 	a Job
		process: 	a Process in nil
		owner: 	a MCVersionLoader


[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in CurrentJob(DynamicVariable)>>value:during:
	Receiver: a CurrentJob
	Arguments and temporary variables: 
		anObject: 	a Job
		aBlock: 	[ ^ block cull: self ]
		activeProcess: 	a Process in nil
		oldValue: 	a Job
	Receiver's instance variables: 
		index: 	2


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ]
	Arguments and temporary variables: 
		aBlock: 	[
			activeProcess
				psValueAt: index
				put: oldValue ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	CurrentJob(DynamicVariable)>>value:during:
		compiledBlock: 	a CompiledBlock: [ activeProcess
			psValueAt: index
			put:[..]
		numArgs: 	0
		receiver: 	a CurrentJob


CurrentJob(DynamicVariable)>>value:during:
	Receiver: a CurrentJob
	Arguments and temporary variables: 
		anObject: 	a Job
		aBlock: 	[ ^ block cull: self ]
		activeProcess: 	a Process in nil
		oldValue: 	a Job
	Receiver's instance variables: 
		index: 	2


CurrentJob class(DynamicVariable class)>>value:during:
	Receiver: CurrentJob
	Arguments and temporary variables: 
		anObject: 	a Job
		aBlock: 	[ ^ block cull: self ]
	Receiver's instance variables: 
		superclass: 	DynamicVariable
		methodDict: 	a MethodDictionary()
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		commentSourcePointer: 	nil
		subclasses: 	nil
		name: 	#CurrentJob
		classPool: 	nil
		sharedPools: 	nil
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Jobs-Base'
		soleInstance: 	a CurrentJob


[ self prepareForRunning.
	  CurrentJob value: self during: [ ^ block cull: self ] ] in Job>>run
	Receiver: a Job
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		block: 	[ self ensurePackage: version package.
		  self loadWithNameLike: ve[..]
		currentValue: 	0
		min: 	0
		max: 	100
		title: 	'Loading Roassal3-Pharo9-CompatibleUserName.1686657480'
		children: 	an OrderedCollection()
		isRunning: 	true
		parent: 	a Job
		process: 	a Process in nil
		owner: 	a MCVersionLoader


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ self prepareForRunning.
	  CurrentJob value: self during: [ ^ block cull: self ] ]
	Arguments and temporary variables: 
		aBlock: 	[ self cleanupAfterRunning ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	Job>>run
		compiledBlock: 	a CompiledBlock: [ self prepareForRunning.
	  CurrentJob val[..]
		numArgs: 	0
		receiver: 	a Job


Job>>run
	Receiver: a Job
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		block: 	[ self ensurePackage: version package.
		  self loadWithNameLike: ve[..]
		currentValue: 	0
		min: 	0
		max: 	100
		title: 	'Loading Roassal3-Pharo9-CompatibleUserName.1686657480'
		children: 	an OrderedCollection()
		isRunning: 	true
		parent: 	a Job
		process: 	a Process in nil
		owner: 	a MCVersionLoader


[   
		| version |
		version := versions first. 
		[ self ensurePackage: version package.
		  self loadWithNameLike: version info name ] asJob
				title: 'Loading ', version info name asString;
				run ] in MCVersionLoader>>load
	Receiver: a MCVersionLoader
	Arguments and temporary variables: 
		version: 	a MCVersion(an IceMCVersionInfo(Roassal3-Pharo9-CompatibleUserName[..]
	Receiver's instance variables: 
		versions: 	an OrderedCollection(a MCVersion(an IceMCVersionInfo(Roassal3-Pha[..]


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [   
		| version |
		version := versions first. 
		[ self ensurePackage: version packa[..]
	Arguments and temporary variables: 
		aBlock: 	[
		self cacheActive: oldActive.
		self isCacheActive ifFalse: [ se[..]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	MCVersionLoader>>load
		compiledBlock: 	a CompiledBlock: [   
		| version |
		version := versions fi[..]
		numArgs: 	0
		receiver: 	a MCVersionLoader


RPackageSet class>>withCacheDo:
	Receiver: RPackageSet
	Arguments and temporary variables: 
		aBlock: 	[   
		| version |
		version := versions first. 
		[ self ensurePac[..]
		oldActive: 	false
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary(#asRPackageSet->RPackageSet>>#asRPackageSet [..]
		format: 	65543
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		commentSourcePointer: 	nil
		subclasses: 	{MetacelloTestsPackageSet}
		name: 	#RPackageSet
		classPool: 	nil
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'RPackage-Core-Base'
		cacheActive: 	true
		cachePackages: 	an IdentityDictionary(#'Roassal3-Pharo9'->a RPackageSet )


MCVersionLoader>>load
	Receiver: a MCVersionLoader
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		versions: 	an OrderedCollection(a MCVersion(an IceMCVersionInfo(Roassal3-Pha[..]


MetacelloGoferLoad(GoferLoad)>>execute
	Receiver: a MetacelloGoferLoad
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		gofer: 	a MetacelloGofer
		model: 	a MCVersionLoader


[ "mcLoader preLoad: packageSpec."
			goferLoad := MetacelloGoferLoad on: aGofer.
			goferLoad addResolved: resolvedReference.
			goferLoad execute.
			MetacelloPlatform current clearCurrentVersionCache	"mcLoader postLoad: packageSpec"
			] in [ | loadBlock goferLoad answers resolvedReference |

			aGofer disablePackageCache.	"for good luck:)"
			resolvedReference := self resolvePackageSpec: packageSpec gofer: aGofer.
			resolvedReference ifNil: [ "Package version already loaded into image" ^ self ].
			loadBlock := [ "mcLoader preLoad: packageSpec."
			goferLoad := MetacelloGoferLoad on: aGofer.
			goferLoad addResolved: resolvedReference.
			goferLoad execute.
			MetacelloPlatform current clearCurrentVersionCache	"mcLoader postLoad: packageSpec"
			].
			MetacelloNotification signal:
					'Loading -> ' , resolvedReference name , ' --- '
						, aPackageLoadDirective repository repositoryDescription , ' --- '
						, resolvedReference repository description.
			( answers := packageSpec answers ) notEmpty
				ifTrue: [ loadBlock valueSupplyingMetacelloAnswers: answers ]
				ifFalse: [ loadBlock value ].
			resolvedReference workingCopy repositoryGroup addRepository: aPackageLoadDirective repository.
			MetacelloNotification signal:
					'Loaded -> ' , resolvedReference name , ' --- '
						, aPackageLoadDirective repository repositoryDescription , ' --- '
						, resolvedReference repository description
			] in MetacelloLoadingMCSpecLoader(MetacelloCommonMCSpecLoader)>>loadPackageDirective:gofer:
	Receiver: a MetacelloLoadingMCSpecLoader
	Arguments and temporary variables: 
		aPackageLoadDirective: 	load : Roassal3-Pharo9-CompatibleUserName.1686657480
		aGofer: 	a MetacelloGofer
		packageSpec: 	spec name: #'Roassal3-Pharo9'
		loadBlock: 	[ "mcLoader preLoad: packageSpec."
			goferLoad := MetacelloGofe[..]
		answers: 	#()
		resolvedReference: 	a MetacelloCachingGoferResolvedReference name: 'Roassal3[..]
		goferLoad: 	a MetacelloGoferLoad
	Receiver's instance variables: 
		spec: 	a MetacelloMCVersionSpecLoader
		operator: 	nil
		loaderPolicy: 	a MetacelloLoaderPolicy
		disablePackageCache: 	false


[ | loadBlock goferLoad answers resolvedReference |

			aGofer disablePackageCache.	"for good luck:)"
			resolvedReference := self resolvePackageSpec: packageSpec gofer: aGofer.
			resolvedReference ifNil: [ "Package version already loaded into image" ^ self ].
			loadBlock := [ "mcLoader preLoad: packageSpec."
			goferLoad := MetacelloGoferLoad on: aGofer.
			goferLoad addResolved: resolvedReference.
			goferLoad execute.
			MetacelloPlatform current clearCurrentVersionCache	"mcLoader postLoad: packageSpec"
			].
			MetacelloNotification signal:
					'Loading -> ' , resolvedReference name , ' --- '
						, aPackageLoadDirective repository repositoryDescription , ' --- '
						, resolvedReference repository description.
			( answers := packageSpec answers ) notEmpty
				ifTrue: [ loadBlock valueSupplyingMetacelloAnswers: answers ]
				ifFalse: [ loadBlock value ].
			resolvedReference workingCopy repositoryGroup addRepository: aPackageLoadDirective repository.
			MetacelloNotification signal:
					'Loaded -> ' , resolvedReference name , ' --- '
						, aPackageLoadDirective repository repositoryDescription , ' --- '
						, resolvedReference repository description
			] in MetacelloLoadingMCSpecLoader(MetacelloCommonMCSpecLoader)>>loadPackageDirective:gofer:
	Receiver: a MetacelloLoadingMCSpecLoader
	Arguments and temporary variables: 
		aPackageLoadDirective: 	load : Roassal3-Pharo9-CompatibleUserName.1686657480
		aGofer: 	a MetacelloGofer
		packageSpec: 	spec name: #'Roassal3-Pharo9'
		goferLoad: 	a MetacelloGoferLoad
		loadBlock: 	[ "mcLoader preLoad: packageSpec."
			goferLoad := MetacelloGofe[..]
		answers: 	#()
		resolvedReference: 	a MetacelloCachingGoferResolvedReference name: 'Roassal3[..]
	Receiver's instance variables: 
		spec: 	a MetacelloMCVersionSpecLoader
		operator: 	nil
		loaderPolicy: 	a MetacelloLoaderPolicy
		disablePackageCache: 	false


[:bar |
            bar value: 1.
            aBlock value.
            bar value: 2 ] in IceMetacelloPharoPlatform(MetacelloPharoCommonPlatform)>>do:displaying:
	Receiver: an IceMetacelloPharoPlatform
	Arguments and temporary variables: 
		aBlock: 	[ | loadBlock goferLoad answers resolvedReference |

			aGofer disa[..]
		aString: 	'Loading Roassal3-Pharo9'
		bar: 	a Job
	Receiver's instance variables: 
		bypassProgressBars: 	false
		bypassGoferLoadUpdateCategories: 	false


FullBlockClosure(BlockClosure)>>cull:
	Receiver: [:bar |
            bar value: 1.
            aBlock value.
            bar value: 2 ]
	Arguments and temporary variables: 
		anArg: 	a Job
	Receiver's instance variables: 
		outerContext: 	IceMetacelloPharoPlatform(MetacelloPharoCommonPlatform)>>do:d[..]
		compiledBlock: 	a CompiledBlock: [:bar |
            bar value: 1.
         [..]
		numArgs: 	1
		receiver: 	an IceMetacelloPharoPlatform


[ ^ block cull: self ] in [ self prepareForRunning.
	  CurrentJob value: self during: [ ^ block cull: self ] ] in Job>>run
	Receiver: a Job
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		block: 	[:bar |
            bar value: 1.
            aBlock value.
        [..]
		currentValue: 	1
		min: 	0
		max: 	2
		title: 	'Loading Roassal3-Pharo9'
		children: 	an OrderedCollection(a Job)
		isRunning: 	true
		parent: 	a Job
		process: 	a Process in nil
		owner: 	a MorphicUIManager


[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in CurrentJob(DynamicVariable)>>value:during:
	Receiver: a CurrentJob
	Arguments and temporary variables: 
		anObject: 	a Job
		aBlock: 	[ ^ block cull: self ]
		activeProcess: 	a Process in nil
		oldValue: 	a Job
	Receiver's instance variables: 
		index: 	2


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ]
	Arguments and temporary variables: 
		aBlock: 	[
			activeProcess
				psValueAt: index
				put: oldValue ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	CurrentJob(DynamicVariable)>>value:during:
		compiledBlock: 	a CompiledBlock: [ activeProcess
			psValueAt: index
			put:[..]
		numArgs: 	0
		receiver: 	a CurrentJob


CurrentJob(DynamicVariable)>>value:during:
	Receiver: a CurrentJob
	Arguments and temporary variables: 
		anObject: 	a Job
		aBlock: 	[ ^ block cull: self ]
		activeProcess: 	a Process in nil
		oldValue: 	a Job
	Receiver's instance variables: 
		index: 	2


CurrentJob class(DynamicVariable class)>>value:during:
	Receiver: CurrentJob
	Arguments and temporary variables: 
		anObject: 	a Job
		aBlock: 	[ ^ block cull: self ]
	Receiver's instance variables: 
		superclass: 	DynamicVariable
		methodDict: 	a MethodDictionary()
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		commentSourcePointer: 	nil
		subclasses: 	nil
		name: 	#CurrentJob
		classPool: 	nil
		sharedPools: 	nil
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Jobs-Base'
		soleInstance: 	a CurrentJob


[ self prepareForRunning.
	  CurrentJob value: self during: [ ^ block cull: self ] ] in Job>>run
	Receiver: a Job
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		block: 	[:bar |
            bar value: 1.
            aBlock value.
        [..]
		currentValue: 	1
		min: 	0
		max: 	2
		title: 	'Loading Roassal3-Pharo9'
		children: 	an OrderedCollection(a Job)
		isRunning: 	true
		parent: 	a Job
		process: 	a Process in nil
		owner: 	a MorphicUIManager


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ self prepareForRunning.
	  CurrentJob value: self during: [ ^ block cull: self ] ]
	Arguments and temporary variables: 
		aBlock: 	[ self cleanupAfterRunning ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	Job>>run
		compiledBlock: 	a CompiledBlock: [ self prepareForRunning.
	  CurrentJob val[..]
		numArgs: 	0
		receiver: 	a Job


Job>>run
	Receiver: a Job
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		block: 	[:bar |
            bar value: 1.
            aBlock value.
        [..]
		currentValue: 	1
		min: 	0
		max: 	2
		title: 	'Loading Roassal3-Pharo9'
		children: 	an OrderedCollection(a Job)
		isRunning: 	true
		parent: 	a Job
		process: 	a Process in nil
		owner: 	a MorphicUIManager



--- The full stack ---
MCPackageLoader(Object)>>notify:
MCPackageLoader>>warnAboutDependencies
MCPackageLoader>>validate
MCPackageLoader>>loadWithNameLike:
MCVersionLoader>>basicLoadWithNameLike:
[ self basicLoadWithNameLike: aString ] in MCVersionLoader>>loadWithNameLike:
[ returnValue := aBlock value ] in [ 
		[ returnValue := aBlock value ] ensure: [ 
			self announceLoadStop: aString ] ] in MCVersionLoader>>announceLoad:do:
FullBlockClosure(BlockClosure)>>ensure:
[ 
		[ returnValue := aBlock value ] ensure: [ 
			self announceLoadStop: aString ] ] in MCVersionLoader>>announceLoad:do:
FullBlockClosure(BlockClosure)>>ensure:
MCVersionLoader>>announceLoad:do:
MCVersionLoader>>loadWithNameLike:
[ self ensurePackage: version package.
		  self loadWithNameLike: version info name ] in [   
		| version |
		version := versions first. 
		[ self ensurePackage: version package.
		  self loadWithNameLike: version info name ] asJob
				title: 'Loading ', version info name asString;
				run ] in MCVersionLoader>>load
FullBlockClosure(BlockClosure)>>cull:
[ ^ block cull: self ] in [ self prepareForRunning.
	  CurrentJob value: self during: [ ^ block cull: self ] ] in Job>>run
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in CurrentJob(DynamicVariable)>>value:during:
FullBlockClosure(BlockClosure)>>ensure:
CurrentJob(DynamicVariable)>>value:during:
CurrentJob class(DynamicVariable class)>>value:during:
[ self prepareForRunning.
	  CurrentJob value: self during: [ ^ block cull: self ] ] in Job>>run
FullBlockClosure(BlockClosure)>>ensure:
Job>>run
[   
		| version |
		version := versions first. 
		[ self ensurePackage: version package.
		  self loadWithNameLike: version info name ] asJob
				title: 'Loading ', version info name asString;
				run ] in MCVersionLoader>>load
FullBlockClosure(BlockClosure)>>ensure:
RPackageSet class>>withCacheDo:
MCVersionLoader>>load
MetacelloGoferLoad(GoferLoad)>>execute
[ "mcLoader preLoad: packageSpec."
			goferLoad := MetacelloGoferLoad on: aGofer.
			goferLoad addResolved: resolvedReference.
			goferLoad execute.
			MetacelloPlatform current clearCurrentVersionCache	"mcLoader postLoad: packageSpec"
			] in [ | loadBlock goferLoad answers resolvedReference |

			aGofer disablePackageCache.	"for good luck:)"
			resolvedReference := self resolvePackageSpec: packageSpec gofer: aGofer.
			resolvedReference ifNil: [ "Package version already loaded into image" ^ self ].
			loadBlock := [ "mcLoader preLoad: packageSpec."
			goferLoad := MetacelloGoferLoad on: aGofer.
			goferLoad addResolved: resolvedReference.
			goferLoad execute.
			MetacelloPlatform current clearCurrentVersionCache	"mcLoader postLoad: packageSpec"
			].
			MetacelloNotification signal:
					'Loading -> ' , resolvedReference name , ' --- '
						, aPackageLoadDirective repository repositoryDescription , ' --- '
						, resolvedReference repository description.
			( answers := packageSpec answers ) notEmpty
				ifTrue: [ loadBlock valueSupplyingMetacelloAnswers: answers ]
				ifFalse: [ loadBlock value ].
			resolvedReference workingCopy repositoryGroup addRepository: aPackageLoadDirective repository.
			MetacelloNotification signal:
					'Loaded -> ' , resolvedReference name , ' --- '
						, aPackageLoadDirective repository repositoryDescription , ' --- '
						, resolvedReference repository description
			] in MetacelloLoadingMCSpecLoader(MetacelloCommonMCSpecLoader)>>loadPackageDirective:gofer:
[ | loadBlock goferLoad answers resolvedReference |

			aGofer disablePackageCache.	"for good luck:)"
			resolvedReference := self resolvePackageSpec: packageSpec gofer: aGofer.
			resolvedReference ifNil: [ "Package version already loaded into image" ^ self ].
			loadBlock := [ "mcLoader preLoad: packageSpec."
			goferLoad := MetacelloGoferLoad on: aGofer.
			goferLoad addResolved: resolvedReference.
			goferLoad execute.
			MetacelloPlatform current clearCurrentVersionCache	"mcLoader postLoad: packageSpec"
			].
			MetacelloNotification signal:
					'Loading -> ' , resolvedReference name , ' --- '
						, aPackageLoadDirective repository repositoryDescription , ' --- '
						, resolvedReference repository description.
			( answers := packageSpec answers ) notEmpty
				ifTrue: [ loadBlock valueSupplyingMetacelloAnswers: answers ]
				ifFalse: [ loadBlock value ].
			resolvedReference workingCopy repositoryGroup addRepository: aPackageLoadDirective repository.
			MetacelloNotification signal:
					'Loaded -> ' , resolvedReference name , ' --- '
						, aPackageLoadDirective repository repositoryDescription , ' --- '
						, resolvedReference repository description
			] in MetacelloLoadingMCSpecLoader(MetacelloCommonMCSpecLoader)>>loadPackageDirective:gofer:
[:bar |
            bar value: 1.
            aBlock value.
            bar value: 2 ] in IceMetacelloPharoPlatform(MetacelloPharoCommonPlatform)>>do:displaying:
FullBlockClosure(BlockClosure)>>cull:
[ ^ block cull: self ] in [ self prepareForRunning.
	  CurrentJob value: self during: [ ^ block cull: self ] ] in Job>>run
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in CurrentJob(DynamicVariable)>>value:during:
FullBlockClosure(BlockClosure)>>ensure:
CurrentJob(DynamicVariable)>>value:during:
CurrentJob class(DynamicVariable class)>>value:during:
[ self prepareForRunning.
	  CurrentJob value: self during: [ ^ block cull: self ] ] in Job>>run
FullBlockClosure(BlockClosure)>>ensure:
Job>>run
 - - - - - - - - - - - - - - -
			- - - - - - - - - - - - - - - - - -
MorphicUIManager(UIManager)>>displayProgress:from:to:during:
ByteString(String)>>displayProgressFrom:to:during:
IceMetacelloPharoPlatform(MetacelloPharoCommonPlatform)>>do:displaying:
MetacelloLoadingMCSpecLoader(MetacelloCommonMCSpecLoader)>>loadPackageDirective:gofer:
MetacelloLinearLoadDirective(MetacelloVersionLoadDirective)>>loadPackageDirective:gofer:
MetacelloPackageLoadDirective>>loadUsing:gofer:
[:directive | directive loadUsing: aLoaderDirective gofer: aGofer ] in MetacelloLinearLoadDirective(MetacelloVersionLoadDirective)>>loadLinearLoadDirective:gofer:
OrderedCollection>>do:
MetacelloLinearLoadDirective(MetacelloVersionLoadDirective)>>loadLinearLoadDirective:gofer:
MetacelloLinearLoadDirective>>loadUsing:gofer:
[:directive | directive loadUsing: aLoaderDirective gofer: aGofer ] in MetacelloLinearLoadDirective(MetacelloVersionLoadDirective)>>loadLinearLoadDirective:gofer:
OrderedCollection>>do:
MetacelloLinearLoadDirective(MetacelloVersionLoadDirective)>>loadLinearLoadDirective:gofer:
MetacelloLinearLoadDirective>>loadUsing:gofer:
MetacelloLinearLoadDirective(MetacelloVersionLoadDirective)>>loadWithPolicy:
MetacelloLoaderPolicy>>load
MetacelloFetchingMCSpecLoader>>doLoad
[  fetchLoader doLoad ] in [	| fetchLoader |
		fetchLoader := self fetchRequiredFromArray: (self defaultPackageNamesToLoad: anArray).
		MetacelloPlatform current
			do:  [  fetchLoader doLoad ]
			displaying: 'Loading ', displayString.
		MetacelloNotification signal: ('...finished ', self versionNumber printString).
		^fetchLoader ] in MetacelloMCVersion>>doLoadRequiredFromArray:
[:bar |
            bar value: 1.
            aBlock value.
            bar value: 2 ] in IceMetacelloPharoPlatform(MetacelloPharoCommonPlatform)>>do:displaying:
FullBlockClosure(BlockClosure)>>cull:
[ ^ block cull: self ] in [ self prepareForRunning.
	  CurrentJob value: self during: [ ^ block cull: self ] ] in Job>>run
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in CurrentJob(DynamicVariable)>>value:during:
FullBlockClosure(BlockClosure)>>ensure:
CurrentJob(DynamicVariable)>>value:during:
CurrentJob class(DynamicVariable class)>>value:during:
[ self prepareForRunning.
	  CurrentJob value: self during: [ ^ block cull: self ] ] in Job>>run
FullBlockClosure(BlockClosure)>>ensure:
Job>>run
MorphicUIManager(UIManager)>>displayProgress:from:to:during:
ByteString(String)>>displayProgressFrom:to:during:
IceMetacelloPharoPlatform(MetacelloPharoCommonPlatform)>>do:displaying:
[	| fetchLoader |
		fetchLoader := self fetchRequiredFromArray: (self defaultPackageNamesToLoad: anArray).
		MetacelloPlatform current
			do:  [  fetchLoader doLoad ]
			displaying: 'Loading ', displayString.
		MetacelloNotification signal: ('...finished ', self versionNumber printString).
		^fetchLoader ] in MetacelloMCVersion>>doLoadRequiredFromArray:
FullBlockClosure(BlockClosure)>>ensure:
MetacelloMCVersion>>doLoadRequiredFromArray:
MetacelloMCVersion>>load
[ 
          | version loadedSpec |
          self setDefaultsAndValidateProjectSpec.
          [ loadedSpec := (self lookupProjectSpecFor: self projectSpec) copy ]
            on: MetacelloAllowProjectDowngrade , MetacelloAllowProjectUpgrade
            do: [ :ex | ex handleOnDownGrade: onDownGradeBlock onUpgrade: onUpgradeBlock ].
          version := loadedSpec versionForScriptEngine: self.
          self
            root:
              (required isEmpty
                ifTrue: [ version load ]
                ifFalse: [ version load: required ]) loadDirective.
          loadedSpec loads: required.
          MetacelloProjectRegistration
            registrationForProjectSpec: loadedSpec
            ifAbsent: [ :new | 
              new
                loadedInImage: true;
                registerProject ]
            ifPresent: [ :existing :new | 
              existing
                copyOnWrite: [ :existingCopy | 
                  existingCopy
                    loadedInImage: true;
                    merge: new ] ] ] in [ 
      self
        handleNotificationsForAction: [ 
          | version loadedSpec |
          self setDefaultsAndValidateProjectSpec.
          [ loadedSpec := (self lookupProjectSpecFor: self projectSpec) copy ]
            on: MetacelloAllowProjectDowngrade , MetacelloAllowProjectUpgrade
            do: [ :ex | ex handleOnDownGrade: onDownGradeBlock onUpgrade: onUpgradeBlock ].
          version := loadedSpec versionForScriptEngine: self.
          self
            root:
              (required isEmpty
                ifTrue: [ version load ]
                ifFalse: [ version load: required ]) loadDirective.
          loadedSpec loads: required.
          MetacelloProjectRegistration
            registrationForProjectSpec: loadedSpec
            ifAbsent: [ :new | 
              new
                loadedInImage: true;
                registerProject ]
            ifPresent: [ :existing :new | 
              existing
                copyOnWrite: [ :existingCopy | 
                  existingCopy
                    loadedInImage: true;
                    merge: new ] ] ] ] in MetacelloScriptEngine>>load:onProjectDownGrade:onProjectUpgrade:
FullBlockClosure(BlockClosure)>>on:do:
[ 
  actionBlock
    on:
      MetacelloLookupProjectSpec , MetacelloLookupProjectSpecForLoad
        , MetacelloProjectSpecLoadedNotification
        , MetacelloScriptEnsureProjectLoadedForDevelopment
        , MetacelloLookupBaselineSpecForEnsureLoad
    do: [ :ex | 
      "lookup and registration handlers need to be innermost set of handlers ...they may throw option notifications"
      ex handleResolutionFor: self ] ] in [ 
  [ 
  actionBlock
    on:
      MetacelloLookupProjectSpec , MetacelloLookupProjectSpecForLoad
        , MetacelloProjectSpecLoadedNotification
        , MetacelloScriptEnsureProjectLoadedForDevelopment
        , MetacelloLookupBaselineSpecForEnsureLoad
    do: [ :ex | 
      "lookup and registration handlers need to be innermost set of handlers ...they may throw option notifications"
      ex handleResolutionFor: self ] ]
    on:
      MetacelloAllowProjectDowngrade , MetacelloAllowProjectUpgrade
        , MetacelloAllowConflictingProjectUpgrade
    do: [ :ex | 
      "option handlers need to be outermost set of handlers ... last line of defense before users are involved"
      ex handleResolutionFor: self ] ] in [ 
  [ 
  [ 
  actionBlock
    on:
      MetacelloLookupProjectSpec , MetacelloLookupProjectSpecForLoad
        , MetacelloProjectSpecLoadedNotification
        , MetacelloScriptEnsureProjectLoadedForDevelopment
        , MetacelloLookupBaselineSpecForEnsureLoad
    do: [ :ex | 
      "lookup and registration handlers need to be innermost set of handlers ...they may throw option notifications"
      ex handleResolutionFor: self ] ]
    on:
      MetacelloAllowProjectDowngrade , MetacelloAllowProjectUpgrade
        , MetacelloAllowConflictingProjectUpgrade
    do: [ :ex | 
      "option handlers need to be outermost set of handlers ... last line of defense before users are involved"
      ex handleResolutionFor: self ] ]
    on: MetacelloAllowLockedProjectChange
    do: [ :ex | 
      "MetacelloAllowLockedProjectChange need to be outermost handler ... since it is signaled from second line of handlers"
      ex handleResolutionFor: self ] ] in MetacelloScriptEngine>>handleNotificationsForAction:
FullBlockClosure(BlockClosure)>>on:do:
[ 
  [ 
  actionBlock
    on:
      MetacelloLookupProjectSpec , MetacelloLookupProjectSpecForLoad
        , MetacelloProjectSpecLoadedNotification
        , MetacelloScriptEnsureProjectLoadedForDevelopment
        , MetacelloLookupBaselineSpecForEnsureLoad
    do: [ :ex | 
      "lookup and registration handlers need to be innermost set of handlers ...they may throw option notifications"
      ex handleResolutionFor: self ] ]
    on:
      MetacelloAllowProjectDowngrade , MetacelloAllowProjectUpgrade
        , MetacelloAllowConflictingProjectUpgrade
    do: [ :ex | 
      "option handlers need to be outermost set of handlers ... last line of defense before users are involved"
      ex handleResolutionFor: self ] ] in [ 
  [ 
  [ 
  actionBlock
    on:
      MetacelloLookupProjectSpec , MetacelloLookupProjectSpecForLoad
        , MetacelloProjectSpecLoadedNotification
        , MetacelloScriptEnsureProjectLoadedForDevelopment
        , MetacelloLookupBaselineSpecForEnsureLoad
    do: [ :ex | 
      "lookup and registration handlers need to be innermost set of handlers ...they may throw option notifications"
      ex handleResolutionFor: self ] ]
    on:
      MetacelloAllowProjectDowngrade , MetacelloAllowProjectUpgrade
        , MetacelloAllowConflictingProjectUpgrade
    do: [ :ex | 
      "option handlers need to be outermost set of handlers ... last line of defense before users are involved"
      ex handleResolutionFor: self ] ]
    on: MetacelloAllowLockedProjectChange
    do: [ :ex | 
      "MetacelloAllowLockedProjectChange need to be outermost handler ... since it is signaled from second line of handlers"
      ex handleResolutionFor: self ] ] in MetacelloScriptEngine>>handleNotificationsForAction:
FullBlockClosure(BlockClosure)>>on:do:
[ 
  [ 
  [ 
  actionBlock
    on:
      MetacelloLookupProjectSpec , MetacelloLookupProjectSpecForLoad
        , MetacelloProjectSpecLoadedNotification
        , MetacelloScriptEnsureProjectLoadedForDevelopment
        , MetacelloLookupBaselineSpecForEnsureLoad
    do: [ :ex | 
      "lookup and registration handlers need to be innermost set of handlers ...they may throw option notifications"
      ex handleResolutionFor: self ] ]
    on:
      MetacelloAllowProjectDowngrade , MetacelloAllowProjectUpgrade
        , MetacelloAllowConflictingProjectUpgrade
    do: [ :ex | 
      "option handlers need to be outermost set of handlers ... last line of defense before users are involved"
      ex handleResolutionFor: self ] ]
    on: MetacelloAllowLockedProjectChange
    do: [ :ex | 
      "MetacelloAllowLockedProjectChange need to be outermost handler ... since it is signaled from second line of handlers"
      ex handleResolutionFor: self ] ] in MetacelloScriptEngine>>handleNotificationsForAction:
FullBlockClosure(BlockClosure)>>on:do:
MetacelloScriptEngine>>handleNotificationsForAction:
[ 
      self
        handleNotificationsForAction: [ 
          | version loadedSpec |
          self setDefaultsAndValidateProjectSpec.
          [ loadedSpec := (self lookupProjectSpecFor: self projectSpec) copy ]
            on: MetacelloAllowProjectDowngrade , MetacelloAllowProjectUpgrade
            do: [ :ex | ex handleOnDownGrade: onDownGradeBlock onUpgrade: onUpgradeBlock ].
          version := loadedSpec versionForScriptEngine: self.
          self
            root:
              (required isEmpty
                ifTrue: [ version load ]
                ifFalse: [ version load: required ]) loadDirective.
          loadedSpec loads: required.
          MetacelloProjectRegistration
            registrationForProjectSpec: loadedSpec
            ifAbsent: [ :new | 
              new
                loadedInImage: true;
                registerProject ]
            ifPresent: [ :existing :new | 
              existing
                copyOnWrite: [ :existingCopy | 
                  existingCopy
                    loadedInImage: true;
                    merge: new ] ] ] ] in MetacelloScriptEngine>>load:onProjectDownGrade:onProjectUpgrade:
FullBlockClosure(BlockClosure)>>ensure:
MetacelloProjectRegistration class>>copyRegistryRestoreOnErrorWhile:
MetacelloScriptEngine>>load:onProjectDownGrade:onProjectUpgrade:
MetacelloScriptEngine>>load:
[ :projectSpec | 
      | engine |
      engine := MetacelloScriptEngine new
        options: self options copy;
        projectSpec: projectSpec;
        yourself.
      engine perform: actionArg key withArguments: actionArg value.
      engine root ifNotNil: [ :root | self roots add: root ] ] in MetacelloScriptApiExecutor(MetacelloScriptExecutor)>>execute:
[ :projectSpec | 
      projectSpec
        ifNotNil: [ projectSpecBlock value: (self applyArgsToProjectSpec: projectSpec copy) ] ] in MetacelloScriptApiExecutor>>executeString:do:
Array(SequenceableCollection)>>do:
MetacelloScriptApiExecutor>>executeString:do:
ByteString(String)>>execute:against:
MetacelloScriptApiExecutor(MetacelloScriptExecutor)>>execute:
[ 
		super execute: statements ] in MetacelloScriptApiExecutor>>execute:
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in IceMetacelloLoadSessionContext(DynamicVariable)>>value:during:
FullBlockClosure(BlockClosure)>>ensure:
IceMetacelloLoadSessionContext(DynamicVariable)>>value:during:
IceMetacelloLoadSessionContext class(DynamicVariable class)>>value:during:
IceMetacelloPharoPlatform>>withMetacelloLoadSessionDo:
MetacelloScriptApiExecutor>>execute:
Metacello>>execute:args:
Metacello>>load
UndefinedObject>>DoIt
OCReceiverDoItSemanticScope(OCDoItSemanticScope)>>evaluateDoIt:
OpalCompiler>>evaluate
[
		self announcer announce: (SpCodeWillBeEvaluatedAnnouncement newContent: aString).
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionModel doItReceiver.
		result := receiver class compiler
			source: aString;
			context: self interactionModel doItContext;
			receiver: self interactionModel doItReceiver;
			requestor: self interactionModel;
			environment: self environment;
			failBlock:  [ 
				self announcer announce: (SpCodeEvaluationFailedAnnouncement newContent: aString).
				^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		self announcer announce: (SpCodeEvaluationSucceedAnnouncement newContent: aString).
		result ] in SpCodePresenter>>evaluate:onCompileError:onError:
FullBlockClosure(BlockClosure)>>on:do:
SpCodePresenter>>evaluate:onCompileError:onError:
StPlaygroundPagePresenter>>doEvaluateAndGo
StPlaygroundPagePresenter>>doEvaluateAllAndGo
StPlaygroundDoItCommand>>execute
SpCommand(CmCommandDecorator)>>execute
[ specCommand execute ] in [ :specCommand | 
			aButtonClass new
				label: specCommand name;
				help: specCommand description;
				in: [ :button | 
					specCommand hasIcon
						ifTrue: [ button icon: specCommand icon ] ];
				action: [ specCommand execute ];
				yourself ] in SpCommand>>configureAsButtonOfClass:
FullBlockClosure(BlockClosure)>>cull:
SpMorphicToolbarButtonAdapter>>execute
SpToolbarButtonMorph(PluggableButtonMorph)>>performAction:
[:m |
		(m containsPoint: evt cursorPoint) ifTrue: [m enabled ifTrue: [ m performAction: evt ]]] in SpToolbarButtonMorph(PluggableButtonMorph)>>mouseUp:
Array(SequenceableCollection)>>do:
SpToolbarButtonMorph(PluggableButtonMorph)>>mouseUp:
SpToolbarButtonMorph(Morph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
SpToolbarButtonMorph(Morph)>>handleEvent:
SpToolbarButtonMorph(Morph)>>handleFocusEvent:
[
		result := focusHolder handleFocusEvent: transformedEvent.
	] in HandMorph>>sendFocusEvent:to:clear:
FullBlockClosure(BlockClosure)>>on:do:
WorldMorph>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil ]) ifTrue: [
			morphicWorld activeHand handleEvent: anEvent
		]
	] in OSWindowMorphicEventHandler>>dispatchMorphicEvent:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycleNow
WorldMorph>>doOneCycle
[
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMutex critical: [
			                     self extraWorldList ].
		extraWorldsToDraw do: [ :world | world doOneCycle ].

		(self currentWorld isNotNil and: [
			 (extraWorldsToDraw includes: self currentWorld) not ]) ifTrue: [
			self currentWorld doOneCycle ] ] in WorldMorph class>>doOneCycle
FullBlockClosure(BlockClosure)>>ensure:
WorldState class>>doDrawCycleWith:
WorldMorph class>>doOneCycle
MorphicRenderLoop>>doOneCycle
MorphicRenderLoop>>doOneCycleWhile:
[ MorphicRenderLoop new doOneCycleWhile: [ true ] ] in MorphicUIManager>>spawnNewProcess
[self value.
			"IMPORTANT: Do not step over next line of code. See method comments for details"
			Processor terminateRealActive] in FullBlockClosure(BlockClosure)>>newProcess
-------------------------------------------------------------------------------

